## Monolithic Architecture
모노리틱 아키텍쳐란, 기존의 전통적인 웹 시스템 개발 스타일로 하나의 어플리케이션(war)에 모든 기능이 다 들어가 있는 형태를 의미한다. 
<br/><br/>
아래 이미지처럼, 모든 모듈에 대해 UX로직부터 비지니스 레이어까지 통합 되어 있는 구조
<br/>
<br/>
![monolithic-image]({{site_url}}/img/2018-05-01-msa-basic/monolithic.png)
<br/>
<br/>

<p>모노리틱(Monolithic)은 무슨 뜻 일까? 구글 번역기로 검색을 해보면..</p>

![search-image]({{site_url}}/img/2018-05-01-msa-basic/search.png)
<br/><br/>
하나로 뭉쳐져 있다라는 느낌이 강하게 오는 단어 인듯 합니다.
<br/><br/>


- 장점
  - 하나의 어플리케이션으로 관리되기 때문에 배포/운영이 간단하다<br/>
    (작은 사이트에서는 오히려 더 편한 방법)
  - 트랜잭션 관리가 쉽다 (@Transaction으로 한번에 묶어 처리가 가능)
  - 테스트 케이스 작성이 간편하며, 테스트가 편하다

- 단점
  - 서비스가 늘어날 수록 어플리케이션의 덩치(?)가 커진다. 
  - 개발자가 전체 서비스에 대한 구조를 이해하는데 오래 걸린다.
  - 서비스가 늘어날 수록 빌드시간, 배포시간이 오래 걸린다.
  - 일부분에 대한 수정 후 배포 시, 전체 서비스를 배포해야 한다.
  - 부분적인 장애가 전체 서비스 장애로 번질 수 있다. <br/>
    (한 군데로 트래픽이 몰리는 경우 전체 시스템에 영향을 줄 수 있다.)
  - 한 두사람의 실수가 전체 시스템 빌드에 실패 할 수 있다.
  - 선택적 Scale out이 불가능하다. <br/>
    (좌석 선점, 결제 기능이 있을 때 좌석 선점 기능에 대한 scale out이 요구되지만 결국 전체 서비스에 대한 scale out이 필요하다)
  - 개발 언어에 종속적이다. <br/>
    (개발 기반이 java + Spring이라면 다른기능 또한 java + Spring기반으로 개발 해야한다.)

<br/><br/>
## MSA (Micro Service Architecture) - Don`t put all your eggs in one basket

 Spring MSA란, Spring Micro Service Architecture라는 의미로 기존의 거대한 EnterPrise Service를 각 모듈 별, 기능 별로 서비스를 세분화 하여 개발하는 방법론입니다.<br/>
대용량 웹서비스가 많아짐에 따라 정의된 아키텍처이며, SOA(Service Oriented Architecture)에 근간을 두고 있습니다. <br/>
SOA는 엔터프라이즈 시스템을 중심으로 고안된 아키텍쳐라면, 마이크로 서비스 아키텍쳐는 SOA 사상에 근간을 두고, 대용량 웹서비스 개발에 맞는 구조로 사상이 경량화 되고, 대규모 개발팀의 조직 구조에 맞도록 변형된 아키텍쳐입니다.

<br/><br/>
![모노리틱 아키텍처]({{site_url}}/img/2018-05-01-msa-basic/monolithic-diagram.png) 
<br/><br/>

### 모노리틱(Monolithic) 아키텍처 구조
위 에서 봤듯이 모노리틱(Monolithic) 아키텍처 구조에서는 
* 프레젠테이션 레이어(Front)
* 비지니스 레이어(Service)
* 퍼시스턴트(Persistence) 레이어

<br/>
구성되어 하나의 어플리케이션으로 동작하고 있습니다. <br/>
<br/>
이를 MSA를 이용하여 개발하게 된다면 아래와 같은 구조로 접근해 볼 수 있습니다.
<br/><br/>
![MSA 아키텍처]({{site_url}}/img/2018-05-01-msa-basic/msa-diagram.png) 
<br/><br/>

<br/><br/>
![MSA]({{site_url}}/img/2018-05-01-msa-basic/ux-msa.png)
<br/><br/>

### 마이크로 서비스 아키텍처(MSA) 구조
가로 방향으로 레이어에 대한 구분으로 시스템을 구분 했다면, MSA에는 모듈, 도메인 단위로 세로 방향으로 시스템을 구분합니다.<br/>
즉 각각의 도메인 별로 프레젠테이션 레이어 + 비지니스 레이어 + 퍼시스턴트 레이어를 가지며, DB또한 인스턴스가 분리되는 구조를 가집니다. <br/>
<br/>
기존의 모노리틱(Monolithic) 구조에서 call-by-reference를 이용한 method 호출에서 굳이 오버헤드를 만들어 가며 REST API 형태로 바꿈으로써<br/>
얻을 수 있는 장점은 무엇이고, 단점은 무엇일까요?

- 장점
  - 다른 서비스의 의존성 (Dependency)와 관계 없이 배포 가능
  - 경량 어플리케이션 -> 빠른 빌드/배포
  - 선택적 Scale out 가능 (AWS에서는 Auto Scaling이 가능)
  - Poly glot아키텍처 구성 가능 (어디는 Java+Spring, 어디는 Node.js등.. 필요한 곳에 필요한 기술을 사용할 수 있다.)
  - 하나의 서비스가 다른 서비스에 영향을 주지 않는다. (죽은 서비스를 호출 하게 되면 문제가 됩니다.)
  - 낮은 결합도, 높은 응집력
<br/><br/>
- 단점
  - 트랜잭션 처리가 매우 어렵다.<br/>
    기존에 Call-by-reference방식으로 메소드만 호출하던 부분을 @Transaction으로만 묶어줬다면,<br/>
    이제는 각 서비스 별로 Rollback을 별도 처리 해줘야 합니다.
  - 성능 이슈가 있다. <br/>
    기존 모노리틱(Monolithic) 구조에서는 서비스 간 Dependency, DI를 이용하여 직접 method를 호출 하는 방식에서<br/>
    이제는 http프로토콜을 이용한 API 호출방식으로 변경 되었습니다.<br/>
    분명 이 과정에서 Network IO에 대한 오버헤드(Overhead)가 발생하므로 모노로틱(Monolothic) 구조보단 상대적으로 느릴 수 밖에 없습니다.<br/>
    하지만 하드웨어가 발달 된 현 시점에서, 많은 차이가 나지 않는다고 하면 MSA방식을 채택 하는 것이 더 좋습니다.
  - 관리 포인트가 늘어난다.<br/>
    모노로틱(Monolithic) 구조에서는 n-tier에 대한 서버 인스턴스만 관리하면 되어, 관리 서버의 수가 적었습니다.<br/>
    하지만 MSA 구조에서는 서비스 수 x 서버 인스턴스 + a로 늘어 나게 되며, 배포, 모니터링 환경에 대한 관리 포인트가 많아지게 됩니다.<br/>
    이 과정에서 발생하는 비용도 많아지게 됩니다.
  - 각 서비스 간 통신 시, Model Spec에 의존하게 된다.<br/>
    각 서비스 간 API 통신 시, VO, DTO등이 생성되게 될 텐데, 결국은 JSON형태로 데이터를 주고 받아 Serializing/Deserializing이 이루어지는 형태<br/>
    Model 데이터가 변경 될 경우 타 서비스에 장애를 초래 하거나 정상적으로 서비스가 동작 하지 않을 수 있다.
<br/><br/>

### MSA 구조의 경계는 어떻게 구분하는게 좋을까?
* 자율적인 기능 
* SRP (Single Response Principle) - 단일 책임의 원칙 
* 배포 단위의 크기 
* 서브도메인 
* Polyglot 아키텍처 
* 선택적 확장 
* 작고 애자일한 팀 
* 트랜잭션


## API Gateway

API Gateway란, 간단하게 모든 API 서버 앞단에서 End-Point를 단일/통합 하는 서버입니다. <br/>
<br/>
추가로 아래 기능을 제공하고 있습니다. <br/> 
1. 인증 (Certification) <br/>
   * 인증의 대표적인 예로 API Token 발행이 있습니다. <br/>
   * Application에 로그인 하는 경우, 여러 서비스에 대한 SSO처리 없이 Session을 유지할 수 있습니다.<br/><br/>
   ![auth]({{site_url}}/img/2018-05-01-msa-basic/token.png)<br/>
2. 권한 (Authority) <br/><br/>
3. 라우팅 (Routing) <br/>
   * API Gateway에서는 각 API서버에 대한 라우팅 및 로드밸런싱을 제공 합니다. <br/><br/>
   ![auth]({{site_url}}/img/2018-05-01-msa-basic/noapigateway.png)<br/><br/>
   API Gateway가 없는 형태 <br/><br/>
   ![auth]({{site_url}}/img/2018-05-01-msa-basic/apigateway.png)<br/><br/>
   API Gateway가 있는 형태 <br/><br/>
   
   * AWS와 같은 클라우드 환경을 사용할 경우 Auto scaling과 같은 기능을 사용하게 되는데, 이 경우 Spring Cloud Eureka와 같은 라이브러리를 통해 자동으로 서버에 대한 정보를 등록하여, <br/>
   API서버 별로 로드 밸런싱을 통해 트래픽 분산이 가능합니다.<br/>
   * 단순하게 라운드 로빈으로 분산이 가능하며, 서버의 하드웨어 조건에 따라 가중치를 설정하여 트래픽을 분산하는 것도 가능합니다.
   * 메세지 헤더 기반 라우팅이 가능합니다. en_us, ko_kr등의 Country_code에 따라 해외에 있는 서버로의 요청도 분산 할 수 있습니다.<br/><br/>
   ![country]({{site_url}}/img/2018-05-01-msa-basic/country.png)
   
4. 모니터링 (Monitoring)
   * AWS API Gateway와 같은 일부 API Gateway에서는 API Gateway에 대한 모니터링을 제공합니다.
   * 아래 이미지는 오픈 소스 API Gateway인 Kong에서 제공하는 모니터링입니다.<br/><br/>

   ![maxresdefault]({{site_url}}/img/2018-05-01-msa-basic/maxresdefault.jpg)
   
5. 공통 로직처리
   * API Gateway 특성상, 각 API 서버들의 앞 단에 위치하기 때문에 각 서비스에서 필요한 Session정보나, 전처리 정보등을 공통으로 처리 할 수 있습니다.
   * 모든 API가 거쳐가는 곳이기 때문에 동일한 포맷으로 로그를 처리하기 좋습니다.
     이러한 로그는 차후 장애분석이나, 트래픽 분석등에 중요한 지표로 사용 될 수 있습니다.<br/><br/>
   ![token]({{site_url}}/img/2018-05-01-msa-basic/a8.png)
   

* 장점
  * 각 API서버에 대한 Dependency를 최소화 할 수 있음
  * 모든 API서버는 API Gateway에만 Dependency가 적용
  * 각 서비스에서는 API Gateway를 통해 상호 간 통신 (서버에 대한 IP/Port정보를 일일이 확인하지 않아도 됨)
  * Swagger와 같은 라이브러리를 이용하여 API Doc 자동화 관리 가능
  * Eureka와 같은 라이브러리를 이용하면 ServerID로 관리되어 관리가 쉬움 (대신 비용이 많이 듬, 작은 그룹의 API서버는 그냥 라우팅 관리를 해도 된다.)

* 단점
  * 모든 API Call이 API Gateway로부터 시작되기 때문에 API Gateway에 대한 부하가 집중 됨
    (API Gateway를 잘 분리하여 운영하여야 함.)

<br/><br/>


## Circuit Breaker

Circuit Breaker란, 직역하면 누전차단기라는 뜻을 가지고 있습니다. <br/>
전류의 양이 한 순간 급격하게 흘러들어오면 전기를 차단하여.. 집에 불나는 것을 막아줍니다. <br/>
(집에 불이 나서 난리가 나느니... 전기 한번 끊기고 두꺼비집 다시 올려주는 게 낫습니다.) <br/>
<br/>

Circuit Breaker란 많은 내부 API를 호출 해야하는 환경에서, 특정 API로 트래픽이 몰리거나, 서버가 다운되어
장애가 발생 한 경우 시스템의 장애전파를 막는 역할을 수행 합니다.
<br/><br/>
위의 예제로 다시 한번 설명을 해보자면..<br/>
전류의 양이 한순간에 급격하게 흘러들어오면 (특정 트래픽이 한군데로 겁나게 몰리면...)<br/>
다른 말로 일정량 이상의 전류가 흘러들어오면 (특정 API서버에 대한 fail이 특정 횟수 이상 발생하면..)<br/>
누전 차단기(Circuit Breaker)를 내려 전류를 차단합니다 (특정 API에 대한 연결을 차단하고, client에게 에러 메세지를 보여줍니다.)<br/>
로 직역 해 볼 수 있습니다.<br/>
<br/>
<br/>
![장애 상황]({{site_url}}/img/2018-05-01-msa-basic/circuit-error.png)
<br/>
<br/>
위의 이미지는 한 API서버에 대한 장애 상황을 나타낸 것입니다.<br/>
API Gateway에서는 한정된 Thread로 외부 API호출을 수행하게 됩니다.<br/>
만약, Circuit Breaker가 없다면 어떤 상황이 벌어질까요?<br/>
API 호출에 할당된 Thread는 API 호출을 수행해야 하기 때문에 Thread pool에 반납되지 못하고 호출이 끝날 때 까지 자원을 선점하게 됩니다.<br/>
이러한 Thread pool 자원이 모두 선점되게 되면 다음 API호출은 수행해줄 Thread를 하염없이 기다리게 되고, 이는 종속 관계의 서비스에 대한 장애로 전파 될 수 있습니다.<br/>

<br/><br/>
![Circuit Breaker1]({{site_url}}/img/2018-05-01-msa-basic/no-error-circuit.png)
<br/><br/>

이런 문제를 해결하기 위해 Circuit Breaker 패턴을 사용합니다.<br/>
위의 이미지처럼 Service B에 대한 Dependency를 가지는 Service A에 대해 Service B가 문제 없이 동작한다면,<br/>
위의 이미지대로 각 API서버에 문제가 없다면 Circuit Breaker에 대한 제어는 트래픽을 문제없이 bypass하게 됩니다.
<br/><br/>
![Circuit Breaker2]({{site_url}}/img/2018-05-01-msa-basic/circuit-breaker.png)
<br/><br/>
하지만, Service B에서 Slow Query등 시간이 지연되어, timeout이나 장애가 발생하는 경우 <br/>
Circuit Breaker는 미리 지정된 fail횟수를 카운트하여 미리 저정된 횟수 만큼 fail에 발생하면 Service B에 대한 API호출을 막아버립니다.<br/>
이 때 Circuit Breaker에 fallBack 로직을 수행하여 Service A에게 에러메세지를 전달해 주거나, 일시적으로 캐싱된 데이터를 전달하는 등, <br/>
Default 결과 값을 지정하여 전달해 줍니다.<br/>
이런 식으로 Circuit을 닫아 줄 시간을 지정하고 이 시간 동안에는 장애 전파가 되지 않도록 장애 서비스 호출을 하지 않게 됩니다.<br/>
그리고 지정한 시간이 지나면 다시 Circuit을 열고, 절반은 Circuit Breaker fallback로직을 실행하고, 절반은 Service B를 호출 하게 합니다.<br/>
이런 식으로 장애가 해결 되었는지를 판단한 다음에 Circuit을 열어 Service B를 다시 정상적으로 서비스 하도록 합니다.<br/>

<br/><br/>
![Circuit Breaker flow]({{site_url}}/img/2018-05-01-msa-basic/circuit-breaker-flow.png)
<br/><br/>
<br/>
### 예제 코드

~~~
 //2분 내로 5번이 넘는 오류가 발생하면 10분동안 Circuit을 닫고 breaker.checkState()에서 false 리턴
 EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(5, 2, TimeUnit.MINUTE, 5, 10, TimeUnit.MINUTE);
 ...
 public void handleRequest(Request request) {
     
     // Circuit Breaker의 상태 체크 true면 서비스 호출 로직을 실행
     if (breaker.checkState()) {
         try {
             service.doSomething();
         } catch (ServiceException ex) {
             breaker.incrementAndCheckState();
         }
     } else {
         // return an error code, use an alternative service, etc.
         // 에러인 경우, 캐싱된 데이터를 실행하거나 에러메세지 표현
     }
 }
~~~

<br/><br/>
~~~

//1분에 1000건 이상의 Request가 오는 경우 Circuit을 닫는다.
//1분마다 체크하여 800건 이하로 Request가 내려가면 다시 Circuit을 열어준다.
 EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(1000, 1, TimeUnit.MINUTE, 800);
 ...
 public void handleRequest(Request request) {
     if (breaker.incrementAndCheckState()) {
         // actually handle this request
     } else {
         // do something else, e.g. send an error code
     }
 }
 ~~~

<br/><br/>
## Spring Cloud