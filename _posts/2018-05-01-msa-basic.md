## Monolithic Architecture
모노리틱 아키텍쳐란, 기존의 전통적인 웹 시스템 개발 스타일로 하나의 어플리케이션(war)에 모든 기능이 다 들어가 있는 형태를 의미한다. 
<br/><br/>
아래 이미지처럼, 모든 모듈에 대해 UX로직부터 비지니스 레이어까지 통합 되어 있는 구조
<br/>
<br/>
![monolithic-image]({{site_url}}/img/2018-05-01-msa-basic/monolithic.png)
<br/>
<br/>

<p>모노리틱(Monolithic)은 무슨 뜻 일까? 구글 번역기로 검색을 해보면..</p>

![search-image]({{site_url}}/img/2018-05-01-msa-basic/search.png)
<br/><br/>
하나로 뭉쳐져 있다라는 느낌이 강하게 오는 단어 인듯 합니다.
<br/><br/>


- 장점
  - 하나의 어플리케이션으로 관리되기 때문에 배포/운영이 간단하다<br/>
    (작은 사이트에서는 오히려 더 편한 방법)
  - 트랜잭션 관리가 쉽다 (@Transaction으로 한번에 묶어 처리가 가능)
  - 테스트 케이스 작성이 간편하며, 테스트가 편하다

- 단점
  - 서비스가 늘어날 수록 어플리케이션의 덩치(?)가 커진다. 
  - 개발자가 전체 서비스에 대한 구조를 이해하는데 오래 걸린다.
  - 서비스가 늘어날 수록 빌드시간, 배포시간이 오래 걸린다.
  - 일부분에 대한 수정 후 배포 시, 전체 서비스를 배포해야 한다.
  - 부분적인 장애가 전체 서비스 장애로 번질 수 있다. <br/>
    (한 군데로 트래픽이 몰리는 경우 전체 시스템에 영향을 줄 수 있다.)
  - 한 두사람의 실수가 전체 시스템 빌드에 실패 할 수 있다.
  - 선택적 Scale out이 불가능하다. <br/>
    (좌석 선점, 결제 기능이 있을 때 좌석 선점 기능에 대한 scale out이 요구되지만 결국 전체 서비스에 대한 scale out이 필요하다)
  - 개발 언어에 종속적이다. <br/>
    (개발 기반이 java + Spring이라면 다른기능 또한 java + Spring기반으로 개발 해야한다.)

<br/><br/>
## MSA (Micro Service Architecture) - Don`t put all your eggs in one basket

 Spring MSA란, Spring Micro Service Architecture라는 의미로 기존의 거대한 EnterPrise Service를 각 모듈 별, 기능 별로 서비스를 세분화 하여 개발하는 방법론입니다.<br/>
대용량 웹서비스가 많아짐에 따라 정의된 아키텍처이며, SOA(Service Oriented Architecture)에 근간을 두고 있습니다. <br/>
SOA는 엔터프라이즈 시스템을 중심으로 고안된 아키텍쳐라면, 마이크로 서비스 아키텍쳐는 SOA 사상에 근간을 두고, 대용량 웹서비스 개발에 맞는 구조로 사상이 경량화 되고, 대규모 개발팀의 조직 구조에 맞도록 변형된 아키텍쳐입니다.

<br/><br/>
![모노리틱 아키텍처]({{site_url}}/img/2018-05-01-msa-basic/monolithic-diagram.png) 
<br/><br/>

### 모노리틱(Monolithic) 아키텍처 구조
위 에서 봤듯이 모노리틱(Monolithic) 아키텍처 구조에서는 
* 프레젠테이션 레이어(Front)
* 비지니스 레이어(Service)
* 퍼시스턴트(Persistence) 레이어

<br/>
구성되어 하나의 어플리케이션으로 동작하고 있습니다. <br/>
<br/>
이를 MSA를 이용하여 개발하게 된다면 아래와 같은 구조로 접근해 볼 수 있습니다.
<br/><br/>
![MSA 아키텍처]({{site_url}}/img/2018-05-01-msa-basic/msa-diagram.png) 
<br/><br/>

<br/><br/>
![MSA]({{site_url}}/img/2018-05-01-msa-basic/ux-msa.png)
<br/><br/>

### 마이크로 서비스 아키텍처(MSA) 구조
가로 방향으로 레이어에 대한 구분으로 시스템을 구분 했다면, MSA에는 모듈, 도메인 단위로 세로 방향으로 시스템을 구분합니다.<br/>
즉 각각의 도메인 별로 프레젠테이션 레이어 + 비지니스 레이어 + 퍼시스턴트 레이어를 가지며, DB또한 인스턴스가 분리되는 구조를 가집니다. <br/>
<br/>
기존의 모노리틱(Monolithic) 구조에서 call-by-reference를 이용한 method 호출에서 굳이 오버헤드를 만들어 가며 REST API 형태로 바꿈으로써<br/>
얻을 수 있는 장점은 무엇이고, 단점은 무엇일까요?

- 장점
  - 다른 서비스의 의존성 (Dependency)와 관계 없이 배포 가능
  - 경량 어플리케이션 -> 빠른 빌드/배포
  - 선택적 Scale out 가능 (AWS에서는 Auto Scaling이 가능)
  - Poly glot아키텍처 구성 가능 (어디는 Java+Spring, 어디는 Node.js등.. 필요한 곳에 필요한 기술을 사용할 수 있다.)
  - 하나의 서비스가 다른 서비스에 영향을 주지 않는다. (죽은 서비스를 호출 하게 되면 문제가 됩니다.)
  - 낮은 결합도, 높은 응집력
<br/><br/>
- 단점
  - 트랜잭션 처리가 매우 어렵다.<br/>
    기존에 Call-by-reference방식으로 메소드만 호출하던 부분을 @Transaction으로만 묶어줬다면,<br/>
    이제는 각 서비스 별로 Rollback을 별도 처리 해줘야 합니다.
  - 성능 이슈가 있다. <br/>
    기존 모노리틱(Monolithic) 구조에서는 서비스 간 Dependency, DI를 이용하여 직접 method를 호출 하는 방식에서<br/>
    이제는 http프로토콜을 이용한 API 호출방식으로 변경 되었습니다.<br/>
    분명 이 과정에서 Network IO에 대한 오버헤드(Overhead)가 발생하므로 모노로틱(Monolothic) 구조보단 상대적으로 느릴 수 밖에 없습니다.<br/>
    하지만 하드웨어가 발달 된 현 시점에서, 많은 차이가 나지 않는다고 하면 MSA방식을 채택 하는 것이 더 좋습니다.
  - 관리 포인트가 늘어난다.<br/>
    모노로틱(Monolithic) 구조에서는 n-tier에 대한 서버 인스턴스만 관리하면 되어, 관리 서버의 수가 적었습니다.<br/>
    하지만 MSA 구조에서는 서비스 수 x 서버 인스턴스 + a로 늘어 나게 되며, 배포, 모니터링 환경에 대한 관리 포인트가 많아지게 됩니다.<br/>
    이 과정에서 발생하는 비용도 많아지게 됩니다.
  - 각 서비스 간 통신 시, Model Spec에 의존하게 된다.<br/>
    각 서비스 간 API 통신 시, VO, DTO등이 생성되게 될 텐데, 결국은 JSON형태로 데이터를 주고 받아 Serializing/Deserializing이 이루어지는 형태<br/>
    Model 데이터가 변경 될 경우 타 서비스에 장애를 초래 하거나 정상적으로 서비스가 동작 하지 않을 수 있다.
<br/><br/>

### MSA 구조의 경계는 어떻게 구분하는게 좋을까?
* 자율적인 기능 
* SRP (Single Response Principle) - 단일 책임의 원칙 
* 배포 단위의 크기 
* 서브도메인 
* Polyglot 아키텍처 
* 선택적 확장 
* 작고 애자일한 팀 
* 트랜잭션


## API Gateway

API Gateway란, 간단하게 모든 API 서버 앞단에서 End-Point를 단일/통합 하는 서버입니다. <br/>
<br/>
추가로 아래 기능을 제공하고 있습니다. <br/> 
1. 인증 (Certification) <br/>
   * 인증의 대표적인 예로 API Token 발행이 있습니다. <br/>
   * Application에 로그인 하는 경우, 여러 서비스에 대한 SSO처리 없이 Session을 유지할 수 있습니다.<br/><br/>
   ![auth]({{site_url}}/img/2018-05-01-msa-basic/token.png)<br/>
2. 권한 (Authority) <br/><br/>
3. 라우팅 (Routing) <br/>
   * API Gateway에서는 각 API서버에 대한 라우팅 및 로드밸런싱을 제공 합니다. <br/><br/>
   ![auth]({{site_url}}/img/2018-05-01-msa-basic/noapigateway.png)<br/><br/>
   API Gateway가 없는 형태 <br/><br/>
   ![auth]({{site_url}}/img/2018-05-01-msa-basic/apigateway.png)<br/><br/>
   API Gateway가 있는 형태 <br/><br/>
   
   * AWS와 같은 클라우드 환경을 사용할 경우 Auto scaling과 같은 기능을 사용하게 되는데, 이 경우 Spring Cloud Eureka와 같은 라이브러리를 통해 자동으로 서버에 대한 정보를 등록하여, API서버 별로 로드 밸런싱을 통해 트래픽 분산이 가능합니다.
   단순하게 라운드 로빈으로 분산이 가능하며, 서버의 하드웨어 조건에 따라 가중치를 설정하여 트래픽을 분산하는 것도 가능합니다.
   * 메세지 헤더 기반 라우팅이 가능합니다. en_us, ko_kr등의 Country_code에 따라 해외에 있는 서버로의 요청도 분산 할 수 있습니다.<br/><br/>
   ![country]({{site_url}}/img/2018-05-01-msa-basic/country.png)
   
4. 모니터링 (Monitoring)
   * AWS API Gateway와 같은 일부 API Gateway에서는 API Gateway에 대한 모니터링을 제공합니다.
   * 아래 이미지는 오픈 소스 API Gateway인 Kong에서 제공하는 모니터링입니다.<br/><br/>

   ![maxresdefault]({{site_url}}/img/2018-05-01-msa-basic/maxresdefault.jpg)
   
5. 공통 로직처리
   * API Gateway 특성상, 각 API 서버들의 앞 단에 위치하기 때문에 각 서비스에서 필요한 Session정보나, 전처리 정보등을 공통으로 처리 할 수 있습니다.
   * 모든 API가 거쳐가는 곳이기 때문에 동일한 포맷으로 로그를 처리하기 좋습니다.
     이러한 로그는 차후 장애분석이나, 트래픽 분석등에 중요한 지표로 사용 될 수 있습니다.<br/><br/>
   ![token]({{site_url}}/img/2018-05-01-msa-basic/token.png)
   

* 장점
  * 각 API서버에 대한 Dependency를 최소화 할 수 있음
  * 모든 API서버는 API Gateway에만 Dependency가 적용
  * 각 서비스에서는 API Gateway를 통해 상호 간 통신 (서버에 대한 IP/Port정보를 일일이 확인하지 않아도 됨)
  * Swagger와 같은 라이브러리를 이용하여 API Doc 자동화 관리 가능
  * Eureka와 같은 라이브러리를 이용하면 ServerID로 관리되어 관리가 쉬움 (대신 비용이 많이 듬, 작은 그룹의 API서버는 그냥 라우팅 관리를 해도 된다.)

* 단점
  * 모든 API Call이 API Gateway로부터 시작되기 때문에 API Gateway에 대한 부하가 집중 됨
    (API Gateway를 잘 분리하여 운영하여야 함.)

<br/><br/>


## Circuit Breaker


<br/><br/>



<br/><br/>
## Spring Cloud