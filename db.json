{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":0,"renderable":0},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"aa1c500a6511fe91275d13877b9e5468413d864e","modified":1533860044479},{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1533735880029},{"_id":"source/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1533735880029},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1533735880082},{"_id":"themes/beantech/_config.yml","hash":"6afd65c055d9b1c70ae67323cc869f1b4aa60348","modified":1533735880082},{"_id":"source/about/index.md","hash":"54ffc05e694cda8607487a0e1d05bf38fbd14963","modified":1536241682046},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1536676434235},{"_id":"source/_posts/2018-07-15-spring-aop.md","hash":"b2416e01e18a07908eb9983f2792c1a47ca173e2","modified":1533735880030},{"_id":"source/_posts/2018-07-20-spring-aop2.md","hash":"47fed6344f090ef86329a1114640afd668d328ee","modified":1533735880030},{"_id":"source/_posts/2018-07-21-spring-aop3.md","hash":"f9ee48b62b7e238213e643ca4b1f98c3c9c557fa","modified":1533735880030},{"_id":"source/_posts/2018-07-22-spring-aop4.md","hash":"a04545bdb9b27330fc63adf73bcca59129396fb8","modified":1533735880030},{"_id":"source/_posts/2018-07-24-spring-aop5.md","hash":"244f3300ca2f2610da52abedc1b29dc82b0fcfd5","modified":1533735880031},{"_id":"source/_posts/2018-08-10-httprequest-client-ip.md","hash":"3828a9d80ea5beb9f0348adc359eeb73c9728474","modified":1533913006968},{"_id":"source/_posts/2018-08-10-spring-argument-resolver.md","hash":"5ccaaba3637ce3eb22d5eb4eb796e2daf1e9b51c","modified":1533906677059},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet.md","hash":"31fd90d36ec76907d8ca9708a84690e86f3faa73","modified":1534065911005},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor.md","hash":"668125a8a615eb222a744caef8963d8a9a3d45be","modified":1535729456278},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception.md","hash":"6a4831c905f03bf985978ce75e75624c8a72cb77","modified":1535729456279},{"_id":"source/_posts/2018-08-29-java-exception.md","hash":"823c4e7364092fdcb3c05d65e5d5f2adb46f667e","modified":1535729456284},{"_id":"source/_posts/2018-09-01-servlet.md","hash":"ebecd107dd150dff6b7f8c00ac10bd3333feb596","modified":1535791158530},{"_id":"source/_posts/2018-09-12-spring-ioc.md","hash":"3bdcfbfa9b0dc0e52bc1bc57d093e183b6375708","modified":1537606700359},{"_id":"source/_posts/2018-09-21-spring-ioc-2.md","hash":"c82ec3a2ef1964441b8ea15319016ac979ffe439","modified":1537606700365},{"_id":"source/_posts/2018-10-21-java-config-import.md","hash":"adbb213bd6f1d5bf09d7bdfaf5eeb40f3841af51","modified":1540117695034},{"_id":"source/_posts/2018-10-21-spring-context.md","hash":"c7d0baa58fcca09953bc2f1c05d1827930587e9a","modified":1540114814654},{"_id":"source/image/.DS_Store","hash":"7adc86aa88c77beca52b3b56f09db71ae4106ee3","modified":1533833482514},{"_id":"source/archive/index.md","hash":"279ff19668395f5c6b26417da99d2c1f3ecd5886","modified":1533735880040},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1533834946520},{"_id":"source/tags/index.md","hash":"9d558ce28d0d44c3463517088689bbca44bbb364","modified":1533735880081},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1533735880083},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1533735880083},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1533735880083},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1533735880084},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1533735880084},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1533735880084},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1533735880084},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1533735880084},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1533735880085},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1533735880085},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1533735880089},{"_id":"themes/beantech/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1533735880090},{"_id":"themes/beantech/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1533735880090},{"_id":"themes/beantech/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1533735880090},{"_id":"themes/beantech/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1533735880090},{"_id":"themes/beantech/layout/page.ejs","hash":"c90797e4394c5cb63c2515109480e766d04e486e","modified":1533735880091},{"_id":"themes/beantech/layout/post.ejs","hash":"2d55684fc539dc281f9e2ec0409f09ea6ca43949","modified":1533735880091},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1533735880092},{"_id":"themes/beantech/source/.DS_Store","hash":"3037d5331d92d3f549f33102664cadfff9459707","modified":1535882674797},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1533837188612},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/Dispatch-Seq.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1533836666637},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/argument-resolver-result.png","hash":"cd37d456fa0edc6c814db3e9a2cdfe77ebf11fa9","modified":1533836666640},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet/Front-controller-pattern.png","hash":"62befacb5ce536303e605341fc7dbf103172526d","modified":1534065351051},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor/filter-chain.gif","hash":"e9bbc8316a3611e64194628fb5f2d524be1ccf56","modified":1535729456278},{"_id":"source/_posts/2018-09-01-servlet/Servlet-life-cycle.png","hash":"25e5eba2e087ee76504a5ac69e0541dd5f97b020","modified":1535791158530},{"_id":"source/_posts/2018-09-01-servlet/jspToServlet.jpeg","hash":"df8c145eca3f082d95dd99d3e391406f75b7ea21","modified":1535791158530},{"_id":"source/_posts/2018-09-01-servlet/servlet.png","hash":"fcd04673f2b14d367a6c6dd3f97fdb6f8a348476","modified":1535791158531},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921142925583.png","hash":"66ef48b35f6b60d2788ea4aba67dd00b5bc481e3","modified":1537606700360},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921142928480.png","hash":"66ef48b35f6b60d2788ea4aba67dd00b5bc481e3","modified":1537606700361},{"_id":"source/_posts/2018-10-21-spring-context/99A34C3359FEAA8410.png","hash":"cb676e0e077ede3f019018de47abe2e4e5ecfc4d","modified":1540114814655},{"_id":"source/image/2018-08-08/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1533831555686},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1533834946481},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"c31863b1fa66fd915bc4913440be6c610d12af80","modified":1533735880086},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"3542d15bdf73aa59f05f566b7ecd2255e83ee370","modified":1533735880086},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"aafb744601042f0270d2e6595129ac8a73ad2608","modified":1533735880086},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1533735880086},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1533735880087},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1533735880087},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1533735880087},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1533735880087},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1533735880088},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1533735880088},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1533735880088},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1533735880089},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"3b10bd768f6ef30a42b1703fbc9a88627f9bfdf1","modified":1533735880089},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1533735880092},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1533735880092},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1533735880093},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1533735880095},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1533735880096},{"_id":"themes/beantech/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1533735880097},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1533735880097},{"_id":"themes/beantech/source/css/toc.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1533735880097},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1533735880098},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1533735880098},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1533735880101},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1533735880101},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1533735880101},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1533735880103},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1533735880103},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1533735880103},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1533735880107},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1533735880107},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1533735880107},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1533735880108},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ipv4.png","hash":"bee74710d25633b4e34472e1ed796ca6ea9c6c60","modified":1533912541116},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ipv6.png","hash":"b48a91102ad1481ef1d0c7a87ba774a255a1a780","modified":1533912541117},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet/dispatcher-servlet-lifecycle.jpg","hash":"52c983fadcf1cb7a6121885ea13a0944d9b4131f","modified":1534065351051},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor/spring-request-lifecycle.jpg","hash":"45c54cf5ba571c2061920fa1222af49a4520cb32","modified":1535729456279},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/Exception-Class.png","hash":"97084943599629350623ab0ef20e32d22ced4500","modified":1535729456280},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/spring-mvc-request.jpg","hash":"45c54cf5ba571c2061920fa1222af49a4520cb32","modified":1535729456283},{"_id":"source/_posts/2018-08-29-java-exception/Exception-Class.png","hash":"97084943599629350623ab0ef20e32d22ced4500","modified":1535729456285},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921143924788.png","hash":"bca18bb1036005442c3ca623245d2419b1863a9f","modified":1537606700362},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921145310488.png","hash":"a81cb156dfd22d05f43af23f97fac1da7c27356f","modified":1537606700363},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1533834946489},{"_id":"source/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1533834946522},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1533735880095},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1533735880100},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1533735880102},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1533735880106},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide setting.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1533912184593},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide-setting.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1533912184593},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide설정.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1533912541115},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/image-20180831235454808.png","hash":"752c481b2880b9ff4af53dc1f2ee4a2b0306528e","modified":1535729456282},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921153027741.png","hash":"b3ff77f45cfabe97517baee545932baf63ae11dd","modified":1537606700365},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1533735880038},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1533834946488},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1533834946526},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1533735880094},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1533735880096},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1533735880096},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1533735880039},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1533834946520},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1533834946524},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1533735880105},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/image-20180831234615081.png","hash":"c80e8087b73e4f149b9ab607a76187a6fc9fdf17","modified":1535729456281},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/RequestMappingHandlerAdapter.png","hash":"71751889b49d402fe29355c7ea9bb172ead4b95c","modified":1533836666640},{"_id":"source/_posts/2018-09-21-spring-ioc-2/containers.jpg","hash":"b51257292a3497e4adcdf5560a7f09f7f1a8b5a6","modified":1537606700367},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1533834946486},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1533834946518},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1533735880036},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1533834946514},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1533834946507},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1533834946500},{"_id":"public/post-sitemap.xml","hash":"20dc53d5ed51f4b367b8fd9a381fafb6d72b49eb","modified":1540117708525},{"_id":"public/page-sitemap.xml","hash":"b2015e79c38c8dba560e8b5cd9a86e2fce548e78","modified":1540117340847},{"_id":"public/tag-sitemap.xml","hash":"e6830cb5863bb9b39f6e7a5869b0c532ef58a6c9","modified":1540117708790},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1540117340894},{"_id":"public/sitemap.xml","hash":"8d6cfb8c5960ecba6aeff18d401fc67973a2eb0f","modified":1540117708861},{"_id":"public/404.html","hash":"080d41b8632bd183794fe0e1e28d2b29aeb8ee8e","modified":1540117340901},{"_id":"public/about/index.html","hash":"46fac9362cd9d9c2fb1fa908eb8795d98bcd50f5","modified":1540117538258},{"_id":"public/tags/index.html","hash":"9a2f685ac3390d5045aa815081d7647a075b136e","modified":1540117538258},{"_id":"public/2018/10/21/2018-10-21-spring-context/index.html","hash":"d4512b046d48cebda86300fb1bc8a4e420afa5c8","modified":1540117538258},{"_id":"public/2018/09/22/2018-09-21-spring-ioc-2/index.html","hash":"3fb284b746af94f7ea7827f19cd267a7796f6b9c","modified":1540117340901},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/index.html","hash":"f829e13199f03bb6a1bbe6bfe5e071a1574e4cd7","modified":1540117340901},{"_id":"public/2018/09/01/2018-09-01-servlet/index.html","hash":"5101681dc7332be1d9321ce081bd9276c682c524","modified":1540117340901},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/index.html","hash":"cf08f0a77e968d25b24e902a85e70d374cf3c1e7","modified":1540117340901},{"_id":"public/2018/08/30/2018-08-29-java-exception/index.html","hash":"67d85dbb2a69b3a55f902cc9b61195e853188f9f","modified":1540117340901},{"_id":"public/2018/08/25/2018-08-18-spring-filter-interceptor/index.html","hash":"4f81c50155f38f8f661fe272f2078b3e48c8a181","modified":1540117340901},{"_id":"public/2018/08/11/2018-08-11-spring-dispatcher-servlet/index.html","hash":"a7c26f85b2cbf095f30dae16eac878af26bc96e5","modified":1540117340901},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/index.html","hash":"5f0772df528a95d8836c4198a6822eeccda6cdc3","modified":1540117340901},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/index.html","hash":"71615597cd526598b15f95bfc664a26bd920adce","modified":1540117340902},{"_id":"public/2018/07/24/2018-07-24-spring-aop5/index.html","hash":"97ed380768582eea528f822e278a2b21da3babb7","modified":1540117340902},{"_id":"public/2018/07/22/2018-07-22-spring-aop4/index.html","hash":"e519076d6d141e1813a1321c0016dd409a0b1040","modified":1540117340902},{"_id":"public/2018/07/21/2018-07-21-spring-aop3/index.html","hash":"ba671f4d7c5998fbd75fb063c95ebf276d8c5030","modified":1540117340902},{"_id":"public/2018/07/20/2018-07-20-spring-aop2/index.html","hash":"cc8b1ff8d03605ac9c74f926ad403d8d74aa5c62","modified":1540117340902},{"_id":"public/2018/07/15/2018-07-15-spring-aop/index.html","hash":"26309260ad1c0e14cf746e287e654f2b9a4de237","modified":1540117340902},{"_id":"public/archive/index.html","hash":"81697b48ff517c8c519e4330f10d4c47307dd891","modified":1540117538258},{"_id":"public/index.html","hash":"568265d22d0e408e093bb3299e134be186052ff6","modified":1540117538259},{"_id":"public/archives/2/index.html","hash":"39a2ffc692b9ddabc51747e561f3059173752631","modified":1540117538259},{"_id":"public/tags/Spring/index.html","hash":"851b312e6e6a5b1c4dbed97b889a4013fe847e6c","modified":1540117538259},{"_id":"public/tags/Spring-Core/index.html","hash":"717c61fd4e720630029df4230936541fcec311a7","modified":1540117538259},{"_id":"public/tags/core/index.html","hash":"fea818178850345ab7a03e3ec37517cdfc888e65","modified":1540117538259},{"_id":"public/tags/J2EE/index.html","hash":"9797ce56285f47c7e1b4839dec310160825be9a1","modified":1540117538260},{"_id":"public/tags/Java/index.html","hash":"fa4f6aa610f94df0873aa59c06f78a5c2ba72202","modified":1540117538260},{"_id":"public/tags/WAS/index.html","hash":"76378a5e3106291b8eb4259a3c7e05c97f0a63c6","modified":1540117538260},{"_id":"public/archives/index.html","hash":"052f65ffdfb9719d96af5d6fbbe45770d22c3fcb","modified":1540117538259},{"_id":"public/archives/archives/2/index.html","hash":"f371fd72297f99ddb13ccb2eadbfc631a7ebc3a4","modified":1540117538259},{"_id":"public/archives/2018/index.html","hash":"6c70c5abacbffc271ce3d43312870a62ebf5610d","modified":1540117538259},{"_id":"public/archives/2018/archives/2/index.html","hash":"62c55305ebc9682c1be71c8b162cc504b5209e0a","modified":1540117538259},{"_id":"public/archives/2018/07/index.html","hash":"31e4a7b98b26e68bf111f7b090f6a72a0bfeec41","modified":1540117538259},{"_id":"public/archives/2018/08/index.html","hash":"6740eec02223c97c320ce110b85aac8e64a920c1","modified":1540117538259},{"_id":"public/archives/2018/09/index.html","hash":"eadddca0a74caa36e43e0656574e4517e0b2fa1e","modified":1540117538259},{"_id":"public/archives/2018/10/index.html","hash":"b1891067f2334e4afa54788140d8db71aa4c6436","modified":1540117538259},{"_id":"public/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1540117340958},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1540117340958},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1540117340958},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1540117340958},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1540117340958},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1540117340958},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1540117340958},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1540117340959},{"_id":"public/2018/10/21/2018-10-21-spring-context/99A34C3359FEAA8410.png","hash":"cb676e0e077ede3f019018de47abe2e4e5ecfc4d","modified":1540117340959},{"_id":"public/2018/08/25/2018-08-18-spring-filter-interceptor/filter-chain.gif","hash":"e9bbc8316a3611e64194628fb5f2d524be1ccf56","modified":1540117340959},{"_id":"public/2018/08/11/2018-08-11-spring-dispatcher-servlet/Front-controller-pattern.png","hash":"62befacb5ce536303e605341fc7dbf103172526d","modified":1540117340959},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/Dispatch-Seq.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1540117340959},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/argument-resolver-result.png","hash":"cd37d456fa0edc6c814db3e9a2cdfe77ebf11fa9","modified":1540117340959},{"_id":"public/2018/09/01/2018-09-01-servlet/Servlet-life-cycle.png","hash":"25e5eba2e087ee76504a5ac69e0541dd5f97b020","modified":1540117340959},{"_id":"public/2018/09/01/2018-09-01-servlet/jspToServlet.jpeg","hash":"df8c145eca3f082d95dd99d3e391406f75b7ea21","modified":1540117340959},{"_id":"public/2018/09/01/2018-09-01-servlet/servlet.png","hash":"fcd04673f2b14d367a6c6dd3f97fdb6f8a348476","modified":1540117340959},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921142925583.png","hash":"66ef48b35f6b60d2788ea4aba67dd00b5bc481e3","modified":1540117340959},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921142928480.png","hash":"66ef48b35f6b60d2788ea4aba67dd00b5bc481e3","modified":1540117340959},{"_id":"public/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1540117341225},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1540117341228},{"_id":"public/2018/08/30/2018-08-29-java-exception/Exception-Class.png","hash":"97084943599629350623ab0ef20e32d22ced4500","modified":1540117341230},{"_id":"public/2018/08/25/2018-08-18-spring-filter-interceptor/spring-request-lifecycle.jpg","hash":"45c54cf5ba571c2061920fa1222af49a4520cb32","modified":1540117341230},{"_id":"public/2018/08/11/2018-08-11-spring-dispatcher-servlet/dispatcher-servlet-lifecycle.jpg","hash":"52c983fadcf1cb7a6121885ea13a0944d9b4131f","modified":1540117341230},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/Exception-Class.png","hash":"97084943599629350623ab0ef20e32d22ced4500","modified":1540117341230},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/spring-mvc-request.jpg","hash":"45c54cf5ba571c2061920fa1222af49a4520cb32","modified":1540117341230},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ipv4.png","hash":"bee74710d25633b4e34472e1ed796ca6ea9c6c60","modified":1540117341230},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ipv6.png","hash":"b48a91102ad1481ef1d0c7a87ba774a255a1a780","modified":1540117341231},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921143924788.png","hash":"bca18bb1036005442c3ca623245d2419b1863a9f","modified":1540117341231},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921145310488.png","hash":"a81cb156dfd22d05f43af23f97fac1da7c27356f","modified":1540117341231},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1540117341235},{"_id":"public/css/highlight.css","hash":"03d1f0a648e9bdf7b1f57d217313cbac5d0c7eb1","modified":1540117341235},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1540117341235},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1540117341235},{"_id":"public/css/toc.css","hash":"2062bf4e5b219654e0d4bf470f5eef1be213da95","modified":1540117341235},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1540117341235},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1540117341235},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1540117341235},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1540117341235},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1540117341235},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1540117341235},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1540117341236},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1540117341236},{"_id":"public/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1540117341236},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1540117341236},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1540117341236},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1540117341236},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1540117341236},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1540117341236},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1540117341236},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1540117341236},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1540117341236},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1540117341236},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ide-setting.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1540117341236},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ide setting.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1540117341236},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ide설정.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1540117341236},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/image-20180831235454808.png","hash":"752c481b2880b9ff4af53dc1f2ee4a2b0306528e","modified":1540117341236},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921153027741.png","hash":"b3ff77f45cfabe97517baee545932baf63ae11dd","modified":1540117341236},{"_id":"public/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1540117341242},{"_id":"public/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1540117341242},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1540117341243},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1540117341246},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/image-20180831234615081.png","hash":"c80e8087b73e4f149b9ab607a76187a6fc9fdf17","modified":1540117341246},{"_id":"public/2018/09/22/2018-09-21-spring-ioc-2/containers.jpg","hash":"b51257292a3497e4adcdf5560a7f09f7f1a8b5a6","modified":1540117341252},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/RequestMappingHandlerAdapter.png","hash":"71751889b49d402fe29355c7ea9bb172ead4b95c","modified":1540117341252},{"_id":"public/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1540117341285},{"_id":"public/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1540117341288},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1540117341292},{"_id":"public/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1540117341294},{"_id":"public/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1540117341312},{"_id":"public/2018/10/21/2018-10-21-java-config-import/index.html","hash":"7f185c1576ee837e8ebe8e9f73402582832c6b47","modified":1540117708876},{"_id":"public/tags/Java-Config/index.html","hash":"760da7fd2a9e37175129dca1d42974d68326466a","modified":1540117538260}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2018-10-21T06:55:58.307Z","updated":"2018-08-08T13:44:40.029Z","path":"404.html","title":"","comments":1,"_id":"cjniq3kll0000u0yaft4hn4cq","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T19:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n> 개발 공부 열심히!!\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n> 개발 공부 열심히!!\n","updated":"2018-09-06T13:48:02.046Z","path":"about/index.html","_id":"cjniq3kmn0002u0yat01kgne1","content":"<blockquote>\n<p>개발 공부 열심히!!</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>개발 공부 열심히!!</p>\n</blockquote>\n"},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T11:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2018-08-08T13:44:40.040Z","path":"archive/index.html","_id":"cjniq3kmt0004u0yap0jqpsxv","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2018-08-08T13:44:40.081Z","updated":"2018-08-08T13:44:40.081Z","path":"tags/index.html","comments":1,"_id":"cjniq3kq10016u0yajngusca1","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"Spring AOP (1)","subtitle":"1. AOP를 사용해야 하는 이유","date":"2018-07-15T13:28:13.000Z","background":"/img/posts/06.jpg","_content":"\n\n\n개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다. \nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.\n\n\n\n# 들어가면서..\n\n\n\n정리하고자 하는 내용\n\n1. AOP를 사용해야하는 이유\n2. AOP에서 사용되는 용어 정리\n3. \u0010Spring AOP\n4. AspectJ\n5. Custom Annotation\n\n\n\n내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.\n\n\n\n# 1. AOP를 사용 해야 하는 이유\n\n## AOP란?\n\n AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.\n\n예를 들어 결제를 담당하는 소스가 있다고 할 때\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n~~~\n\n\n\n위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.\n\n여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.\n\n이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.\n\n그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이 \n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.\n\n\n\nAOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    return response;\n}\n~~~\n\n\n\n~~~java\n@Aspect\n@Component\npublic class PaymentLogAdvisor {\n    \n    @Autowired\n    private PaymentLogRepository paymentLogRepository;\n    \n    @AfterReturning(\"execution(* com.example.payment.doPayment*(..))\", returning=\"paymentResponse\")\n    public void afterPayment(JoinPoint jp, PaymentResponse paymentResponse) {\n        Object[] args = jp.getArgs();\n        if(args.length == 0) {\n            throw new illegalArgumentException(\"argument is none\");\n        }\n        \n        if(!(args[0] instanceof PaymentRequest)) {\n            throw new Exception(\"argument is not PaymentRequest Type\");\n        }\n        \n        PaymentRequest paymentRequest = (PaymentRequest) args[0];\n        \n        //결제 로그 삽입\n        paymentLogRepository.insert(paymentRequest, paymentResponse);\n    }\n}\n~~~\n\n","source":"_posts/2018-07-15-spring-aop.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (1)\"\nsubtitle: \"1. AOP를 사용해야 하는 이유\"\ndate:   2018-07-15 22:28:13 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n\n\n개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다. \nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.\n\n\n\n# 들어가면서..\n\n\n\n정리하고자 하는 내용\n\n1. AOP를 사용해야하는 이유\n2. AOP에서 사용되는 용어 정리\n3. \u0010Spring AOP\n4. AspectJ\n5. Custom Annotation\n\n\n\n내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.\n\n\n\n# 1. AOP를 사용 해야 하는 이유\n\n## AOP란?\n\n AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.\n\n예를 들어 결제를 담당하는 소스가 있다고 할 때\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n~~~\n\n\n\n위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.\n\n여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.\n\n이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.\n\n그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이 \n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.\n\n\n\nAOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    return response;\n}\n~~~\n\n\n\n~~~java\n@Aspect\n@Component\npublic class PaymentLogAdvisor {\n    \n    @Autowired\n    private PaymentLogRepository paymentLogRepository;\n    \n    @AfterReturning(\"execution(* com.example.payment.doPayment*(..))\", returning=\"paymentResponse\")\n    public void afterPayment(JoinPoint jp, PaymentResponse paymentResponse) {\n        Object[] args = jp.getArgs();\n        if(args.length == 0) {\n            throw new illegalArgumentException(\"argument is none\");\n        }\n        \n        if(!(args[0] instanceof PaymentRequest)) {\n            throw new Exception(\"argument is not PaymentRequest Type\");\n        }\n        \n        PaymentRequest paymentRequest = (PaymentRequest) args[0];\n        \n        //결제 로그 삽입\n        paymentLogRepository.insert(paymentRequest, paymentResponse);\n    }\n}\n~~~\n\n","slug":"2018-07-15-spring-aop","published":1,"updated":"2018-08-08T13:44:40.030Z","comments":1,"photos":[],"link":"","_id":"cjniq3kmi0001u0yai2zm8xe0","content":"<p>개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다.<br>\nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.</p>\n<h1><span id=\"들어가면서\">들어가면서…</span></h1>\n<p>정리하고자 하는 내용</p>\n<ol>\n<li>AOP를 사용해야하는 이유</li>\n<li>AOP에서 사용되는 용어 정리</li>\n<li>\u0010Spring AOP</li>\n<li>AspectJ</li>\n<li>Custom Annotation</li>\n</ol>\n<p>내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.</p>\n<h1><span id=\"1-aop를-사용-해야-하는-이유\">1. AOP를 사용 해야 하는 이유</span></h1>\n<h2><span id=\"aop란\">AOP란?</span></h2>\n<p>AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.<br>\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.<br>\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.</p>\n<p>예를 들어 결제를 담당하는 소스가 있다고 할 때</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.<br>\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.<br>\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.</p>\n<p>여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.<br>\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.</p>\n<p>이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.</p>\n<p>그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이<br>\n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.</p>\n<p>AOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PaymentLogAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PaymentLogRepository paymentLogRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning</span>(<span class=\"string\">\"execution(* com.example.payment.doPayment*(..))\"</span>, returning=<span class=\"string\">\"paymentResponse\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPayment</span><span class=\"params\">(JoinPoint jp, PaymentResponse paymentResponse)</span> </span>&#123;</span><br><span class=\"line\">        Object[] args = jp.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> illegalArgumentException(<span class=\"string\">\"argument is none\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(args[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> PaymentRequest)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"argument is not PaymentRequest Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        PaymentRequest paymentRequest = (PaymentRequest) args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//결제 로그 삽입</span></span><br><span class=\"line\">        paymentLogRepository.insert(paymentRequest, paymentResponse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다.<br>\nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.</p>\n<h1>들어가면서…</h1>\n<p>정리하고자 하는 내용</p>\n<ol>\n<li>AOP를 사용해야하는 이유</li>\n<li>AOP에서 사용되는 용어 정리</li>\n<li>\u0010Spring AOP</li>\n<li>AspectJ</li>\n<li>Custom Annotation</li>\n</ol>\n<p>내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.</p>\n<h1>1. AOP를 사용 해야 하는 이유</h1>\n<h2>AOP란?</h2>\n<p>AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.<br>\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.<br>\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.</p>\n<p>예를 들어 결제를 담당하는 소스가 있다고 할 때</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.<br>\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.<br>\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.</p>\n<p>여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.<br>\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.</p>\n<p>이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.</p>\n<p>그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이<br>\n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.</p>\n<p>AOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PaymentLogAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PaymentLogRepository paymentLogRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning</span>(<span class=\"string\">\"execution(* com.example.payment.doPayment*(..))\"</span>, returning=<span class=\"string\">\"paymentResponse\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPayment</span><span class=\"params\">(JoinPoint jp, PaymentResponse paymentResponse)</span> </span>&#123;</span><br><span class=\"line\">        Object[] args = jp.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> illegalArgumentException(<span class=\"string\">\"argument is none\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(args[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> PaymentRequest)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"argument is not PaymentRequest Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        PaymentRequest paymentRequest = (PaymentRequest) args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//결제 로그 삽입</span></span><br><span class=\"line\">        paymentLogRepository.insert(paymentRequest, paymentResponse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"Spring AOP (2)","subtitle":"2. AOP에서 사용되는 용어 정리","date":"2018-07-20T14:06:13.000Z","background":"/img/posts/06.jpg","_content":"\n앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.\n\n여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.\n\n\n\n# AOP(Aspect Oriented Programming) 란?\n\n## AOP의 등장배경\n\n AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.  \n\n 수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.\n\n 하지만 객체지향 프로그래밍 방식에도 헛점은 있었다. \n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. `횡단 관심사 (CrossCutting Concerns)`이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.\n\n\n\n## AOP의 개념\n\n 실제 핵심 로직(Core Concern)을 수행하면서 발생하는 `횡단 관심사 (CrossCutting Concerns)` 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.\n\n![횡단관심사와 핵심로직](https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png)\n\nAOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.\n\nAOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다. \nAspect를 정의 하자면, \n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다. \n\n이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.\n\n\n\n# AOP 에서 사용되는 용어들\n\n## Join Point\n\n말그대로 Join + Point이다. `횡단관심사(Cross Cutting Concern)` 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.\n\n## Advice\n\n`횡단관심사(Cross Cutting Concern)` 으로 분리 된 로직에 대한 코드\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어\n\n## Point Cut\n\n말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어\n\n## Weaving\n\nAdvice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.\n방법에 따라 \n* 런타임 시, Proxy로 생성하며 코드를 합치는 방법\n* 컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법\n이 있다.\n\n## Aspect\n\n여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.\n보안, 트랜잭션, 로깅등이 대표적인 예이다.\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.\n\n## Target\n\n핵심 로직을 구현하는 클래스 또는 객체\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.\n\n## Advisor\n\nAdvice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.\n\n\n\n------\n\n참고\n\nhttps://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttp://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106","source":"_posts/2018-07-20-spring-aop2.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (2)\"\nsubtitle: \"2. AOP에서 사용되는 용어 정리\"\ndate:   2018-07-20 23:06:13 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.\n\n여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.\n\n\n\n# AOP(Aspect Oriented Programming) 란?\n\n## AOP의 등장배경\n\n AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.  \n\n 수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.\n\n 하지만 객체지향 프로그래밍 방식에도 헛점은 있었다. \n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. `횡단 관심사 (CrossCutting Concerns)`이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.\n\n\n\n## AOP의 개념\n\n 실제 핵심 로직(Core Concern)을 수행하면서 발생하는 `횡단 관심사 (CrossCutting Concerns)` 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.\n\n![횡단관심사와 핵심로직](https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png)\n\nAOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.\n\nAOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다. \nAspect를 정의 하자면, \n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다. \n\n이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.\n\n\n\n# AOP 에서 사용되는 용어들\n\n## Join Point\n\n말그대로 Join + Point이다. `횡단관심사(Cross Cutting Concern)` 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.\n\n## Advice\n\n`횡단관심사(Cross Cutting Concern)` 으로 분리 된 로직에 대한 코드\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어\n\n## Point Cut\n\n말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어\n\n## Weaving\n\nAdvice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.\n방법에 따라 \n* 런타임 시, Proxy로 생성하며 코드를 합치는 방법\n* 컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법\n이 있다.\n\n## Aspect\n\n여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.\n보안, 트랜잭션, 로깅등이 대표적인 예이다.\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.\n\n## Target\n\n핵심 로직을 구현하는 클래스 또는 객체\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.\n\n## Advisor\n\nAdvice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.\n\n\n\n------\n\n참고\n\nhttps://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttp://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106","slug":"2018-07-20-spring-aop2","published":1,"updated":"2018-08-08T13:44:40.030Z","comments":1,"photos":[],"link":"","_id":"cjniq3kmq0003u0yaht8i4tcu","content":"<p>앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.</p>\n<p>여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.</p>\n<h1><span id=\"aopaspect-oriented-programming-란\">AOP(Aspect Oriented Programming) 란?</span></h1>\n<h2><span id=\"aop의-등장배경\">AOP의 등장배경</span></h2>\n<p>AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.</p>\n<p>수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.</p>\n<p>하지만 객체지향 프로그래밍 방식에도 헛점은 있었다.<br>\n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. <code>횡단 관심사 (CrossCutting Concerns)</code>이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.</p>\n<h2><span id=\"aop의-개념\">AOP의 개념</span></h2>\n<p>실제 핵심 로직(Core Concern)을 수행하면서 발생하는 <code>횡단 관심사 (CrossCutting Concerns)</code> 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.</p>\n<p><img src=\"https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png\" alt=\"횡단관심사와 핵심로직\"></p>\n<p>AOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.</p>\n<p>AOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다.<br>\nAspect를 정의 하자면,<br>\n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다.</p>\n<p>이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.<br>\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.</p>\n<h1><span id=\"aop-에서-사용되는-용어들\">AOP 에서 사용되는 용어들</span></h1>\n<h2><span id=\"join-point\">Join Point</span></h2>\n<p>말그대로 Join + Point이다. <code>횡단관심사(Cross Cutting Concern)</code> 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.</p>\n<h2><span id=\"advice\">Advice</span></h2>\n<p><code>횡단관심사(Cross Cutting Concern)</code> 으로 분리 된 로직에 대한 코드<br>\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어</p>\n<h2><span id=\"point-cut\">Point Cut</span></h2>\n<p>말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,<br>\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어</p>\n<h2><span id=\"weaving\">Weaving</span></h2>\n<p>Advice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.<br>\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.<br>\n방법에 따라</p>\n<ul>\n<li>런타임 시, Proxy로 생성하며 코드를 합치는 방법</li>\n<li>컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법<br>\n이 있다.</li>\n</ul>\n<h2><span id=\"aspect\">Aspect</span></h2>\n<p>여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.<br>\n보안, 트랜잭션, 로깅등이 대표적인 예이다.<br>\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.</p>\n<h2><span id=\"target\">Target</span></h2>\n<p>핵심 로직을 구현하는 클래스 또는 객체<br>\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.</p>\n<h2><span id=\"advisor\">Advisor</span></h2>\n<p>Advice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.<br>\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.</p>\n<hr>\n<p>참고</p>\n<p><a href=\"https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop의-등장-배경</a></p>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p>\n<p><a href=\"http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106\" target=\"_blank\" rel=\"noopener\">http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.</p>\n<p>여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.</p>\n<h1>AOP(Aspect Oriented Programming) 란?</h1>\n<h2>AOP의 등장배경</h2>\n<p>AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.</p>\n<p>수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.</p>\n<p>하지만 객체지향 프로그래밍 방식에도 헛점은 있었다.<br>\n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. <code>횡단 관심사 (CrossCutting Concerns)</code>이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.</p>\n<h2>AOP의 개념</h2>\n<p>실제 핵심 로직(Core Concern)을 수행하면서 발생하는 <code>횡단 관심사 (CrossCutting Concerns)</code> 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.</p>\n<p><img src=\"https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png\" alt=\"횡단관심사와 핵심로직\"></p>\n<p>AOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.</p>\n<p>AOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다.<br>\nAspect를 정의 하자면,<br>\n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다.</p>\n<p>이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.<br>\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.</p>\n<h1>AOP 에서 사용되는 용어들</h1>\n<h2>Join Point</h2>\n<p>말그대로 Join + Point이다. <code>횡단관심사(Cross Cutting Concern)</code> 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.</p>\n<h2>Advice</h2>\n<p><code>횡단관심사(Cross Cutting Concern)</code> 으로 분리 된 로직에 대한 코드<br>\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어</p>\n<h2>Point Cut</h2>\n<p>말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,<br>\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어</p>\n<h2>Weaving</h2>\n<p>Advice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.<br>\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.<br>\n방법에 따라</p>\n<ul>\n<li>런타임 시, Proxy로 생성하며 코드를 합치는 방법</li>\n<li>컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법<br>\n이 있다.</li>\n</ul>\n<h2>Aspect</h2>\n<p>여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.<br>\n보안, 트랜잭션, 로깅등이 대표적인 예이다.<br>\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.</p>\n<h2>Target</h2>\n<p>핵심 로직을 구현하는 클래스 또는 객체<br>\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.</p>\n<h2>Advisor</h2>\n<p>Advice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.<br>\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.</p>\n<hr>\n<p>참고</p>\n<p><a href=\"https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop의-등장-배경</a></p>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p>\n<p><a href=\"http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106\" target=\"_blank\" rel=\"noopener\">http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106</a></p>\n"},{"layout":"post","title":"Spring AOP (4)","subtitle":"4. AspectJ","date":"2018-07-22T03:52:33.000Z","background":"/img/posts/06.jpg","_content":"\n# AspectJ란?\n\n> AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.\n\nAspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, `CTW, LTW`과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.\n\n\n\n> Aspect란?\n>\n> Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.\n> 그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.\n> 구조적으로 보자면 Aspect = PointCut + Advisor이다.\n\n \n\n# 위빙 Weaving\n\n위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.\n\n\n\n##런타임 시, 위빙 (RTW: Runtime Weaving)\n\nSpring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.\n\n![Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw)\n\n\n\n\n\n\n\n## 컴파일 시, 위빙 (CTW: Compile time Weaving)\n\nAspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)\n\n\n\n### CTW를 사용하기 위한 메이븐 설정\n\n**라이브러리 추가:** (pom.xml)\n\n```xml\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjrt</artifactId>\n    <version>1.8.6</version>\n    <scope>runtime</scope>\n</dependency>\n \n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjtools</artifactId>\n    <version>1.8.6</version>\n</dependency> \n```\n\n**플러그인 설정:** (pom.xml)\n\n```xml\n<plugin>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>aspectj-maven-plugin</artifactId>\n    <version>1.7</version>\n    <configuration>\n        <showWeaveInfo>true</showWeaveInfo>\n            <source>${aspectj-compiler.version}</source>\n            <target>${aspectj-compiler.version}</target>\n            <verbose>true</verbose>\n            <complianceLevel>${aspectj-compiler.version}</complianceLevel>\n            <outxml>true</outxml>\n    </configuration>\n    <executions>\n        <execution>\n            <goals>\n                <goal>compile</goal>\n                <goal>test-compile</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n*(\\*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)*\n\n위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용 \n\nAspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용\n\n\n\n## 클래스 로드 시, 위빙 (LTW: Load time Weaving)\n\n ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.\n\n그리고 설정이 가장 복잡하지 않은가 싶다..\n\n아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.\n\n~~~xml\n<context:load-time-weaver/> <!-- 스프링 설정 파일에 추가 servlet.xml -->\n~~~\n\n~~~java\n@EnableLoadTimeWeaving //Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.\n~~~\n\n~~~vm\n//IDE에서 개발 시, 해당 설정을 추가\n-javaagent:/fullpath/aspectjweaver-1.8.1.jar \n-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar \n~~~\n\n~~~\n//톰캣 시작 시, jvmargs 옵션에 추가\n-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar\n~~~\n\n\n\n# Annotations\n\n## JoinPoint 관련 Annotations\n\n공통적으로 pointcut에 대한 표현식을 인자로 받는다.\n\n* @Before\n  * 메소드 실행 이전 부분에 대한 Joinpoint 설정\n* @Around\n  * ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.\n  * 메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.\n* @After\n  * 메소드 실행 이후 부분의 대한 Joinpoint 설정\n* @AfterReturning\n  * 메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정\n* @AfterThrowable\n  * 메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정\n\n\n\n## Pointcut 관련 Annotation\n\n* @Pointcut\n  * Pointcut에 대한 표현식을 값으로 가짐\n  * @Pointcut이 적용된 메소드는 무조건 리턴타입이 void\n\n\n\n\n\n# Point Cut\n\n포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.\n\n![pointcut 개념](https://t1.daumcdn.net/cfile/tistory/223B623D548C415631)\n\n\n\n## 포인트 컷 표현식\n\nExpression을 이용한 pointcut 표현식\n\n![pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg)\n\n\n\n1. 접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)\n   * \\* 인 경우 모든 접근제어자에 대해 설정 가능\n   * 생략 시, \\* 과 같은 효과\n\n2. 리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)\n   * 필수 적으로 기재해야 한다.\n   * \\* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.\n3. Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)\n   * 단, 패키지 명도 기재해야 함 \n   * com.springframework.aop.. 처럼 ..으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리\n   * 필수 적으로 기재해야 한다.\n4. 메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * 모든 메소드에 적용 하려면 \\* 을 사용\n5. 파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * ,로 구분하여 순서대로 파라미터를 기재한다.\n   * 타입과 갯수에 상관없다면 .. 또는 \\* 를 기재한다.\n6. 예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)\n\n\n\n## 예시\n\n- **execution(int minus(int, int))**: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(int, int))**: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(..))**: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드\n\n- **execution(\\* *(..))**: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드\n\n- **execution(\\* *())**: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드\n\n- **execution(\\* springbook.aop.Target.*(..))**: springbook.aop.Target 클래스의 모든 메소드\n\n- **execution(\\* springbook.aop.*.*(..))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.\n\n- **execution(\\* springbook.aop..*.*(..))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함\n\n- **execution(\\* *..Target.*(..))**: 패키지에는 상관없이 Target 클래스의 모든 메소드\n\n- **execution(* *(..) throws Exception) **: Exception을 throw하는 모든 메소드\n\n- **within(com.springbook.aop.service.***) : service 패키지 내의 모든 Joinpoint\n\n- **within(com.springbook.aop.service..***) : service 패키지의 하위패키지 내의 모든 Joinpoint\n\n- **this(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint\n\n- **target(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint\n\n- **args(java.utils.List)** : 파라미터가 1개이고 List타입인 모든 Joinpoint\n\n- **@target(org.springframework.transaction.annotation.Transactional)** :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@within(org.springframework.transaction.annotation.Transactional)** : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@annotation(org.springframework.transaction.annotation.Transactional)** : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점\n\n* **@args(com.xyz.security.Classified)** : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점\n\n* **bean(UserRepository)** : “UserRepository” 빈\n\n* **!bean(UserRepository)** :  “UserRepository” 빈을 제외한 모든 빈\n\n* **bean(*)** : 모든 빈\n\n* **bean(user*)** : 이름이 'user'로 시작되는 모든 빈\n\n* **bean(*Repository)** : 이름이 “Repository”로 끝나는 모든 빈\n\n* **bean(user/*)** : 이름이 “user/“로 시작하는 모든 빈\n\n* **bean(*dataSource) || bean(*DataSource)** : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈\n\n \n\n# 예시코드\n\n## Aspect 파일 사용\n\n~~~java\npublic aspect TestAdvisor {\n    pointcut advicePoint() : execution(* com.example.advice..*(..));\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n    \n    //order는 어떻게 주는건지 모르겠다.\n}\n~~~\n\n\n\n## @Aspect 어노테이션 사용\n\n~~~java\n@Aspect\npublic class TestAdvisor {\n    \n    /**\n    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut\n    */\n    @Pointcut(\"execution(* com.example.advice..*(..))\")\n    public void pointcut(){\n        \n    }\n    \n    @order(2) //order가 높은 순으로 먼저 실행\n    @After(pointcut=\"pointcut()\")\n    public void afterAdvice(Joinpoint joinpoint) {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    @order(1)\n    @After(pointcut=\"pointcut()\")\n    public void showLog(Joinpoint joinpoint) {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n}\n~~~\n\n\n\n\n\n# 참고\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220564638014\n\nhttp://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\n\nhttps://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5","source":"_posts/2018-07-22-spring-aop4.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (4)\"\nsubtitle: \"4. AspectJ\"\ndate:   2018-07-22 12:52:33 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n# AspectJ란?\n\n> AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.\n\nAspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, `CTW, LTW`과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.\n\n\n\n> Aspect란?\n>\n> Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.\n> 그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.\n> 구조적으로 보자면 Aspect = PointCut + Advisor이다.\n\n \n\n# 위빙 Weaving\n\n위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.\n\n\n\n##런타임 시, 위빙 (RTW: Runtime Weaving)\n\nSpring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.\n\n![Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw)\n\n\n\n\n\n\n\n## 컴파일 시, 위빙 (CTW: Compile time Weaving)\n\nAspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)\n\n\n\n### CTW를 사용하기 위한 메이븐 설정\n\n**라이브러리 추가:** (pom.xml)\n\n```xml\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjrt</artifactId>\n    <version>1.8.6</version>\n    <scope>runtime</scope>\n</dependency>\n \n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjtools</artifactId>\n    <version>1.8.6</version>\n</dependency> \n```\n\n**플러그인 설정:** (pom.xml)\n\n```xml\n<plugin>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>aspectj-maven-plugin</artifactId>\n    <version>1.7</version>\n    <configuration>\n        <showWeaveInfo>true</showWeaveInfo>\n            <source>${aspectj-compiler.version}</source>\n            <target>${aspectj-compiler.version}</target>\n            <verbose>true</verbose>\n            <complianceLevel>${aspectj-compiler.version}</complianceLevel>\n            <outxml>true</outxml>\n    </configuration>\n    <executions>\n        <execution>\n            <goals>\n                <goal>compile</goal>\n                <goal>test-compile</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n*(\\*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)*\n\n위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용 \n\nAspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용\n\n\n\n## 클래스 로드 시, 위빙 (LTW: Load time Weaving)\n\n ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.\n\n그리고 설정이 가장 복잡하지 않은가 싶다..\n\n아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.\n\n~~~xml\n<context:load-time-weaver/> <!-- 스프링 설정 파일에 추가 servlet.xml -->\n~~~\n\n~~~java\n@EnableLoadTimeWeaving //Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.\n~~~\n\n~~~vm\n//IDE에서 개발 시, 해당 설정을 추가\n-javaagent:/fullpath/aspectjweaver-1.8.1.jar \n-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar \n~~~\n\n~~~\n//톰캣 시작 시, jvmargs 옵션에 추가\n-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar\n~~~\n\n\n\n# Annotations\n\n## JoinPoint 관련 Annotations\n\n공통적으로 pointcut에 대한 표현식을 인자로 받는다.\n\n* @Before\n  * 메소드 실행 이전 부분에 대한 Joinpoint 설정\n* @Around\n  * ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.\n  * 메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.\n* @After\n  * 메소드 실행 이후 부분의 대한 Joinpoint 설정\n* @AfterReturning\n  * 메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정\n* @AfterThrowable\n  * 메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정\n\n\n\n## Pointcut 관련 Annotation\n\n* @Pointcut\n  * Pointcut에 대한 표현식을 값으로 가짐\n  * @Pointcut이 적용된 메소드는 무조건 리턴타입이 void\n\n\n\n\n\n# Point Cut\n\n포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.\n\n![pointcut 개념](https://t1.daumcdn.net/cfile/tistory/223B623D548C415631)\n\n\n\n## 포인트 컷 표현식\n\nExpression을 이용한 pointcut 표현식\n\n![pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg)\n\n\n\n1. 접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)\n   * \\* 인 경우 모든 접근제어자에 대해 설정 가능\n   * 생략 시, \\* 과 같은 효과\n\n2. 리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)\n   * 필수 적으로 기재해야 한다.\n   * \\* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.\n3. Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)\n   * 단, 패키지 명도 기재해야 함 \n   * com.springframework.aop.. 처럼 ..으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리\n   * 필수 적으로 기재해야 한다.\n4. 메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * 모든 메소드에 적용 하려면 \\* 을 사용\n5. 파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * ,로 구분하여 순서대로 파라미터를 기재한다.\n   * 타입과 갯수에 상관없다면 .. 또는 \\* 를 기재한다.\n6. 예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)\n\n\n\n## 예시\n\n- **execution(int minus(int, int))**: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(int, int))**: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(..))**: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드\n\n- **execution(\\* *(..))**: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드\n\n- **execution(\\* *())**: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드\n\n- **execution(\\* springbook.aop.Target.*(..))**: springbook.aop.Target 클래스의 모든 메소드\n\n- **execution(\\* springbook.aop.*.*(..))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.\n\n- **execution(\\* springbook.aop..*.*(..))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함\n\n- **execution(\\* *..Target.*(..))**: 패키지에는 상관없이 Target 클래스의 모든 메소드\n\n- **execution(* *(..) throws Exception) **: Exception을 throw하는 모든 메소드\n\n- **within(com.springbook.aop.service.***) : service 패키지 내의 모든 Joinpoint\n\n- **within(com.springbook.aop.service..***) : service 패키지의 하위패키지 내의 모든 Joinpoint\n\n- **this(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint\n\n- **target(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint\n\n- **args(java.utils.List)** : 파라미터가 1개이고 List타입인 모든 Joinpoint\n\n- **@target(org.springframework.transaction.annotation.Transactional)** :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@within(org.springframework.transaction.annotation.Transactional)** : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@annotation(org.springframework.transaction.annotation.Transactional)** : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점\n\n* **@args(com.xyz.security.Classified)** : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점\n\n* **bean(UserRepository)** : “UserRepository” 빈\n\n* **!bean(UserRepository)** :  “UserRepository” 빈을 제외한 모든 빈\n\n* **bean(*)** : 모든 빈\n\n* **bean(user*)** : 이름이 'user'로 시작되는 모든 빈\n\n* **bean(*Repository)** : 이름이 “Repository”로 끝나는 모든 빈\n\n* **bean(user/*)** : 이름이 “user/“로 시작하는 모든 빈\n\n* **bean(*dataSource) || bean(*DataSource)** : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈\n\n \n\n# 예시코드\n\n## Aspect 파일 사용\n\n~~~java\npublic aspect TestAdvisor {\n    pointcut advicePoint() : execution(* com.example.advice..*(..));\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n    \n    //order는 어떻게 주는건지 모르겠다.\n}\n~~~\n\n\n\n## @Aspect 어노테이션 사용\n\n~~~java\n@Aspect\npublic class TestAdvisor {\n    \n    /**\n    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut\n    */\n    @Pointcut(\"execution(* com.example.advice..*(..))\")\n    public void pointcut(){\n        \n    }\n    \n    @order(2) //order가 높은 순으로 먼저 실행\n    @After(pointcut=\"pointcut()\")\n    public void afterAdvice(Joinpoint joinpoint) {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    @order(1)\n    @After(pointcut=\"pointcut()\")\n    public void showLog(Joinpoint joinpoint) {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n}\n~~~\n\n\n\n\n\n# 참고\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220564638014\n\nhttp://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\n\nhttps://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5","slug":"2018-07-22-spring-aop4","published":1,"updated":"2018-08-08T13:44:40.030Z","comments":1,"photos":[],"link":"","_id":"cjniq3kmy0005u0ya2z8y05re","content":"<h1><span id=\"aspectj란\">AspectJ란?</span></h1>\n<blockquote>\n<p>AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.</p>\n</blockquote>\n<p>AspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, <code>CTW, LTW</code>과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.<br>\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.<br>\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.</p>\n<blockquote>\n<p>Aspect란?</p>\n<p>Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.<br>\n그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.<br>\n구조적으로 보자면 Aspect = PointCut + Advisor이다.</p>\n</blockquote>\n<h1><span id=\"위빙-weaving\">위빙 Weaving</span></h1>\n<p>위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.<br>\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.</p>\n<p>##런타임 시, 위빙 (RTW: Runtime Weaving)</p>\n<p>Spring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.<br>\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.<br>\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.</p>\n<p><img src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw\" alt=\"Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<h2><span id=\"컴파일-시-위빙-ctw-compile-time-weaving\">컴파일 시, 위빙 (CTW: Compile time Weaving)</span></h2>\n<p>AspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.<br>\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.<br>\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)</p>\n<h3><span id=\"ctw를-사용하기-위한-메이븐-설정\">CTW를 사용하기 위한 메이븐 설정</span></h3>\n<p><strong>라이브러리 추가:</strong> (pom.xml)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>플러그인 설정:</strong> (pom.xml)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectj-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">showWeaveInfo</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">showWeaveInfo</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">verbose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">verbose</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">complianceLevel</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">complianceLevel</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outxml</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">outxml</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>test-compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><em>(*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)</em></p>\n<p>위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용</p>\n<p>AspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용</p>\n<h2><span id=\"클래스-로드-시-위빙-ltw-load-time-weaving\">클래스 로드 시, 위빙 (LTW: Load time Weaving)</span></h2>\n<p>ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식<br>\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.<br>\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.</p>\n<p>그리고 설정이 가장 복잡하지 않은가 싶다…</p>\n<p>아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:load-time-weaver</span>/&gt;</span> <span class=\"comment\">&lt;!-- 스프링 설정 파일에 추가 servlet.xml --&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableLoadTimeWeaving</span> <span class=\"comment\">//Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//IDE에서 개발 시, 해당 설정을 추가</span><br><span class=\"line\">-javaagent:/fullpath/aspectjweaver-1.8.1.jar </span><br><span class=\"line\">-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//톰캣 시작 시, jvmargs 옵션에 추가</span><br><span class=\"line\">-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure>\n<h1><span id=\"annotations\">Annotations</span></h1>\n<h2><span id=\"joinpoint-관련-annotations\">JoinPoint 관련 Annotations</span></h2>\n<p>공통적으로 pointcut에 대한 표현식을 인자로 받는다.</p>\n<ul>\n<li>@Before\n<ul>\n<li>메소드 실행 이전 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@Around\n<ul>\n<li>ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.</li>\n<li>메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.</li>\n</ul>\n</li>\n<li>@After\n<ul>\n<li>메소드 실행 이후 부분의 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterReturning\n<ul>\n<li>메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterThrowable\n<ul>\n<li>메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n</ul>\n<h2><span id=\"pointcut-관련-annotation\">Pointcut 관련 Annotation</span></h2>\n<ul>\n<li>@Pointcut\n<ul>\n<li>Pointcut에 대한 표현식을 값으로 가짐</li>\n<li>@Pointcut이 적용된 메소드는 무조건 리턴타입이 void</li>\n</ul>\n</li>\n</ul>\n<h1><span id=\"point-cut\">Point Cut</span></h1>\n<p>포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.<br>\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/223B623D548C415631\" alt=\"pointcut 개념\"></p>\n<h2><span id=\"포인트-컷-표현식\">포인트 컷 표현식</span></h2>\n<p>Expression을 이용한 pointcut 표현식</p>\n<p><img src=\"http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg\" alt=\"pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<ol>\n<li>\n<p>접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)</p>\n<ul>\n<li>* 인 경우 모든 접근제어자에 대해 설정 가능</li>\n<li>생략 시, * 과 같은 효과</li>\n</ul>\n</li>\n<li>\n<p>리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)</p>\n<ul>\n<li>단, 패키지 명도 기재해야 함</li>\n<li>com.springframework.aop… 처럼 …으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리</li>\n<li>필수 적으로 기재해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>모든 메소드에 적용 하려면 * 을 사용</li>\n</ul>\n</li>\n<li>\n<p>파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>,로 구분하여 순서대로 파라미터를 기재한다.</li>\n<li>타입과 갯수에 상관없다면 … 또는 * 를 기재한다.</li>\n</ul>\n</li>\n<li>\n<p>예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)</p>\n</li>\n</ol>\n<h2><span id=\"예시\">예시</span></h2>\n<ul>\n<li>\n<p><strong>execution(int minus(int, int))</strong>: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(int, int))</strong>: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(…))</strong>: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>(…))</em></em>: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>())</em></em>: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.Target.</em>(…))</em>*: springbook.aop.Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.</em>.</em>(…))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop…</em>.</em>(…))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함</p>\n</li>\n<li>\n<p><strong>execution(* <em>…Target.</em>(…))</strong>: 패키지에는 상관없이 Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(</em> *(…) throws Exception) **: Exception을 throw하는 모든 메소드</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service.</strong>*) : service 패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service…</strong>*) : service 패키지의 하위패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>this(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>target(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>args(java.utils.List)</strong> : 파라미터가 1개이고 List타입인 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>@target(org.springframework.transaction.annotation.Transactional)</strong> :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@within(org.springframework.transaction.annotation.Transactional)</strong> : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@annotation(org.springframework.transaction.annotation.Transactional)</strong> : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n</ul>\n<ul>\n<li>\n<p><strong>@args(com.xyz.security.Classified)</strong> : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>bean(UserRepository)</strong> : “UserRepository” 빈</p>\n</li>\n<li>\n<p><strong>!bean(UserRepository)</strong> :  “UserRepository” 빈을 제외한 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(</em>)</em>* : 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user</em>)</em>* : 이름이 'user’로 시작되는 모든 빈</p>\n</li>\n<li>\n<p>*<em>bean(<em>Repository)</em></em> : 이름이 “Repository”로 끝나는 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user/</em>)</em>* : 이름이 “user/“로 시작하는 모든 빈</p>\n</li>\n<li>\n<p>**bean(<em>dataSource) || bean(<em>DataSource)</em></em> : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈</p>\n</li>\n</ul>\n<h1><span id=\"예시코드\">예시코드</span></h1>\n<h2><span id=\"aspect-파일-사용\">Aspect 파일 사용</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> aspect TestAdvisor &#123;</span><br><span class=\"line\">    <span class=\"function\">pointcut <span class=\"title\">advicePoint</span><span class=\"params\">()</span> : <span class=\"title\">execution</span><span class=\"params\">(* com.example.advice..*(..)</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//order는 어떻게 주는건지 모르겠다.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"aspect-어노테이션-사용\">@Aspect 어노테이션 사용</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.example.advice..*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pointcut</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">2</span>) <span class=\"comment\">//order가 높은 순으로 먼저 실행</span></span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterAdvice</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showLog</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"참고\">참고</span></h1>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014</a></p>\n<p><a href=\"http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\" target=\"_blank\" rel=\"noopener\">http://netframework.tistory.com/entry/LTW-CTW를-이용한-Transactional의-사용</a></p>\n<p><a href=\"https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5\" target=\"_blank\" rel=\"noopener\">https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>AspectJ란?</h1>\n<blockquote>\n<p>AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.</p>\n</blockquote>\n<p>AspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, <code>CTW, LTW</code>과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.<br>\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.<br>\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.</p>\n<blockquote>\n<p>Aspect란?</p>\n<p>Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.<br>\n그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.<br>\n구조적으로 보자면 Aspect = PointCut + Advisor이다.</p>\n</blockquote>\n<h1>위빙 Weaving</h1>\n<p>위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.<br>\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.</p>\n<p>##런타임 시, 위빙 (RTW: Runtime Weaving)</p>\n<p>Spring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.<br>\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.<br>\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.</p>\n<p><img src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw\" alt=\"Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<h2>컴파일 시, 위빙 (CTW: Compile time Weaving)</h2>\n<p>AspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.<br>\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.<br>\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)</p>\n<h3>CTW를 사용하기 위한 메이븐 설정</h3>\n<p><strong>라이브러리 추가:</strong> (pom.xml)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>플러그인 설정:</strong> (pom.xml)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectj-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">showWeaveInfo</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">showWeaveInfo</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">verbose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">verbose</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">complianceLevel</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">complianceLevel</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outxml</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">outxml</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>test-compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><em>(*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)</em></p>\n<p>위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용</p>\n<p>AspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용</p>\n<h2>클래스 로드 시, 위빙 (LTW: Load time Weaving)</h2>\n<p>ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식<br>\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.<br>\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.</p>\n<p>그리고 설정이 가장 복잡하지 않은가 싶다…</p>\n<p>아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:load-time-weaver</span>/&gt;</span> <span class=\"comment\">&lt;!-- 스프링 설정 파일에 추가 servlet.xml --&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableLoadTimeWeaving</span> <span class=\"comment\">//Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//IDE에서 개발 시, 해당 설정을 추가</span><br><span class=\"line\">-javaagent:/fullpath/aspectjweaver-1.8.1.jar </span><br><span class=\"line\">-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//톰캣 시작 시, jvmargs 옵션에 추가</span><br><span class=\"line\">-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure>\n<h1>Annotations</h1>\n<h2>JoinPoint 관련 Annotations</h2>\n<p>공통적으로 pointcut에 대한 표현식을 인자로 받는다.</p>\n<ul>\n<li>@Before\n<ul>\n<li>메소드 실행 이전 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@Around\n<ul>\n<li>ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.</li>\n<li>메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.</li>\n</ul>\n</li>\n<li>@After\n<ul>\n<li>메소드 실행 이후 부분의 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterReturning\n<ul>\n<li>메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterThrowable\n<ul>\n<li>메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n</ul>\n<h2>Pointcut 관련 Annotation</h2>\n<ul>\n<li>@Pointcut\n<ul>\n<li>Pointcut에 대한 표현식을 값으로 가짐</li>\n<li>@Pointcut이 적용된 메소드는 무조건 리턴타입이 void</li>\n</ul>\n</li>\n</ul>\n<h1>Point Cut</h1>\n<p>포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.<br>\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/223B623D548C415631\" alt=\"pointcut 개념\"></p>\n<h2>포인트 컷 표현식</h2>\n<p>Expression을 이용한 pointcut 표현식</p>\n<p><img src=\"http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg\" alt=\"pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<ol>\n<li>\n<p>접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)</p>\n<ul>\n<li>* 인 경우 모든 접근제어자에 대해 설정 가능</li>\n<li>생략 시, * 과 같은 효과</li>\n</ul>\n</li>\n<li>\n<p>리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)</p>\n<ul>\n<li>단, 패키지 명도 기재해야 함</li>\n<li>com.springframework.aop… 처럼 …으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리</li>\n<li>필수 적으로 기재해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>모든 메소드에 적용 하려면 * 을 사용</li>\n</ul>\n</li>\n<li>\n<p>파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>,로 구분하여 순서대로 파라미터를 기재한다.</li>\n<li>타입과 갯수에 상관없다면 … 또는 * 를 기재한다.</li>\n</ul>\n</li>\n<li>\n<p>예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)</p>\n</li>\n</ol>\n<h2>예시</h2>\n<ul>\n<li>\n<p><strong>execution(int minus(int, int))</strong>: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(int, int))</strong>: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(…))</strong>: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>(…))</em></em>: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>())</em></em>: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.Target.</em>(…))</em>*: springbook.aop.Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.</em>.</em>(…))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop…</em>.</em>(…))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함</p>\n</li>\n<li>\n<p><strong>execution(* <em>…Target.</em>(…))</strong>: 패키지에는 상관없이 Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(</em> *(…) throws Exception) **: Exception을 throw하는 모든 메소드</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service.</strong>*) : service 패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service…</strong>*) : service 패키지의 하위패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>this(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>target(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>args(java.utils.List)</strong> : 파라미터가 1개이고 List타입인 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>@target(org.springframework.transaction.annotation.Transactional)</strong> :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@within(org.springframework.transaction.annotation.Transactional)</strong> : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@annotation(org.springframework.transaction.annotation.Transactional)</strong> : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n</ul>\n<ul>\n<li>\n<p><strong>@args(com.xyz.security.Classified)</strong> : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>bean(UserRepository)</strong> : “UserRepository” 빈</p>\n</li>\n<li>\n<p><strong>!bean(UserRepository)</strong> :  “UserRepository” 빈을 제외한 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(</em>)</em>* : 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user</em>)</em>* : 이름이 'user’로 시작되는 모든 빈</p>\n</li>\n<li>\n<p>*<em>bean(<em>Repository)</em></em> : 이름이 “Repository”로 끝나는 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user/</em>)</em>* : 이름이 “user/“로 시작하는 모든 빈</p>\n</li>\n<li>\n<p>**bean(<em>dataSource) || bean(<em>DataSource)</em></em> : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈</p>\n</li>\n</ul>\n<h1>예시코드</h1>\n<h2>Aspect 파일 사용</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> aspect TestAdvisor &#123;</span><br><span class=\"line\">    <span class=\"function\">pointcut <span class=\"title\">advicePoint</span><span class=\"params\">()</span> : <span class=\"title\">execution</span><span class=\"params\">(* com.example.advice..*(..)</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//order는 어떻게 주는건지 모르겠다.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>@Aspect 어노테이션 사용</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.example.advice..*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pointcut</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">2</span>) <span class=\"comment\">//order가 높은 순으로 먼저 실행</span></span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterAdvice</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showLog</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>참고</h1>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014</a></p>\n<p><a href=\"http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\" target=\"_blank\" rel=\"noopener\">http://netframework.tistory.com/entry/LTW-CTW를-이용한-Transactional의-사용</a></p>\n<p><a href=\"https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5\" target=\"_blank\" rel=\"noopener\">https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5</a></p>\n"},{"layout":"post","title":"Spring AOP (5)","subtitle":"5. Custom Annotation Pointcut","date":"2018-07-24T14:14:33.000Z","background":"/img/posts/06.jpg","_content":"\n\n\nAOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.\n아래의 리뷰와 같다.\n\n![AOP코드리뷰](/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP코드리뷰.png)\n\n메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.\n\n이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.\n\n\n\n# Custom Annotation\n\nAPI에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.\n\n\n\n## Annotation 생성하기\n\n~~~java\nimport java.lang.annotation.*;\n\n@Inherited  //Annotation의 상속이 가능함 \n@Documented //JavaDoc 문서 추가 가능\n@Retention(RetentionPolicy.RUNTIME) // 컴파일 이후에도 JVM에 의해서 참조가 가능\n//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효\n//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)\n@Target({\n        ElementType.PACKAGE,         // 패키지 선언시\n        ElementType.TYPE,            // 타입 선언시\n        ElementType.CONSTRUCTOR,     // 생성자 선언시\n        ElementType.FIELD,           // 멤버 변수 선언시\n        ElementType.METHOD,          // 메소드 선언시\n        ElementType.ANNOTATION_TYPE, // 어노테이션 타입 선언시\n        ElementType.LOCAL_VARIABLE,  // 지역 변수 선언시\n        ElementType.PARAMETER,       // 매개 변수 선언시\n        ElementType.TYPE_PARAMETER,  // 매개 변수 타입 선언시\n        ElementType.TYPE_USE         // 타입 사용시\n})\npublic @interface CustomAnnotation {  //interface에 @를 붙여주면 Annotation으로 등록\n    /* enum 타입을 선언할 수 있습니다. */\n    public enum Quality {BAD, GOOD, VERYGOOD}\n    /* String은 기본 자료형은 아니지만 사용 가능합니다. */\n    String value();\n    /* 배열 형태로도 사용할 수 있습니다. */\n    int[] values();\n    /* enum 형태를 사용하는 방법입니다. */\n    Quality quality() default Quality.GOOD;\n}\n~~~\n\n\n\n## Annotation Pointcut 지정하기\n\n예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.\n\n~~~java\npackage com.example.aopexam;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.ComponentScan;\n\n@SpringBootApplication\n//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능\n@ComponentScan(value={\"com.example.aopexam\", \"com.example.custom.annotation\"})\npublic class AopExamApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AopExamApplication.class, args);\n    }\n}\n\n~~~\n\n~~~java\npackage com.example.aopexam;\n\nimport com.example.custom.annotation.CustomLog;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api/aop-test\")\npublic class ApiController {\n\n    @Autowired\n    private ApiService apiService;\n\n    @GetMapping\n    @CustomLog //get 메소드에 @CustomLog추가\n    public void getTest() {\n        apiService.method(ApiType.GET);\n    }\n\n    @PostMapping\n    public void postTest() {\n        apiService.method(ApiType.POST);\n    }\n\n    @PutMapping\n    public void putTest() {\n        apiService.method(ApiType.PUT);\n    }\n\n    @DeleteMapping\n    public void deleteTest() {\n        apiService.method(ApiType.DELETE);\n    }\n\n}\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD) //메소드 어노테이션 적용\npublic @interface CustomLog {\n}\n\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@EnableAspectJAutoProxy(proxyTargetClass = true) //cglib 사용 -> class기반 proxy생성\n@Component\npublic class CustomLogAdvisor {\n\n    //Annotation을 기준으로 pointcut설정\n    @Pointcut(\"@annotation(com.example.custom.annotation.CustomLog)\")\n    public void customLogPointcut() {\n    }\n\n    @Before(value=\"customLogPointcut()\")\n    public void pringLog() {\n        System.out.println(\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\");\n    }\n}\n~~~\n\n~~~log\nhttp://localhost:8080/api/aop-test\n\n메소드 실행 전 무조건 이 로그를 보게 될 것이야...\n[ApiService.method] apiType : GET\n~~~\n\n","source":"_posts/2018-07-24-spring-aop5.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (5)\"\nsubtitle: \"5. Custom Annotation Pointcut\"\ndate:   2018-07-24 23:14:33 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n\n\nAOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.\n아래의 리뷰와 같다.\n\n![AOP코드리뷰](/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP코드리뷰.png)\n\n메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.\n\n이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.\n\n\n\n# Custom Annotation\n\nAPI에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.\n\n\n\n## Annotation 생성하기\n\n~~~java\nimport java.lang.annotation.*;\n\n@Inherited  //Annotation의 상속이 가능함 \n@Documented //JavaDoc 문서 추가 가능\n@Retention(RetentionPolicy.RUNTIME) // 컴파일 이후에도 JVM에 의해서 참조가 가능\n//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효\n//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)\n@Target({\n        ElementType.PACKAGE,         // 패키지 선언시\n        ElementType.TYPE,            // 타입 선언시\n        ElementType.CONSTRUCTOR,     // 생성자 선언시\n        ElementType.FIELD,           // 멤버 변수 선언시\n        ElementType.METHOD,          // 메소드 선언시\n        ElementType.ANNOTATION_TYPE, // 어노테이션 타입 선언시\n        ElementType.LOCAL_VARIABLE,  // 지역 변수 선언시\n        ElementType.PARAMETER,       // 매개 변수 선언시\n        ElementType.TYPE_PARAMETER,  // 매개 변수 타입 선언시\n        ElementType.TYPE_USE         // 타입 사용시\n})\npublic @interface CustomAnnotation {  //interface에 @를 붙여주면 Annotation으로 등록\n    /* enum 타입을 선언할 수 있습니다. */\n    public enum Quality {BAD, GOOD, VERYGOOD}\n    /* String은 기본 자료형은 아니지만 사용 가능합니다. */\n    String value();\n    /* 배열 형태로도 사용할 수 있습니다. */\n    int[] values();\n    /* enum 형태를 사용하는 방법입니다. */\n    Quality quality() default Quality.GOOD;\n}\n~~~\n\n\n\n## Annotation Pointcut 지정하기\n\n예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.\n\n~~~java\npackage com.example.aopexam;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.ComponentScan;\n\n@SpringBootApplication\n//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능\n@ComponentScan(value={\"com.example.aopexam\", \"com.example.custom.annotation\"})\npublic class AopExamApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AopExamApplication.class, args);\n    }\n}\n\n~~~\n\n~~~java\npackage com.example.aopexam;\n\nimport com.example.custom.annotation.CustomLog;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api/aop-test\")\npublic class ApiController {\n\n    @Autowired\n    private ApiService apiService;\n\n    @GetMapping\n    @CustomLog //get 메소드에 @CustomLog추가\n    public void getTest() {\n        apiService.method(ApiType.GET);\n    }\n\n    @PostMapping\n    public void postTest() {\n        apiService.method(ApiType.POST);\n    }\n\n    @PutMapping\n    public void putTest() {\n        apiService.method(ApiType.PUT);\n    }\n\n    @DeleteMapping\n    public void deleteTest() {\n        apiService.method(ApiType.DELETE);\n    }\n\n}\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD) //메소드 어노테이션 적용\npublic @interface CustomLog {\n}\n\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@EnableAspectJAutoProxy(proxyTargetClass = true) //cglib 사용 -> class기반 proxy생성\n@Component\npublic class CustomLogAdvisor {\n\n    //Annotation을 기준으로 pointcut설정\n    @Pointcut(\"@annotation(com.example.custom.annotation.CustomLog)\")\n    public void customLogPointcut() {\n    }\n\n    @Before(value=\"customLogPointcut()\")\n    public void pringLog() {\n        System.out.println(\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\");\n    }\n}\n~~~\n\n~~~log\nhttp://localhost:8080/api/aop-test\n\n메소드 실행 전 무조건 이 로그를 보게 될 것이야...\n[ApiService.method] apiType : GET\n~~~\n\n","slug":"2018-07-24-spring-aop5","published":1,"updated":"2018-08-08T13:44:40.031Z","comments":1,"photos":[],"link":"","_id":"cjniq3kn20006u0ya3kdnlt81","content":"<p>AOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.<br>\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.<br>\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.<br>\n아래의 리뷰와 같다.</p>\n<p><img src=\"/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2.png\" alt=\"AOP코드리뷰\"></p>\n<p>메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.</p>\n<p>이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.</p>\n<h1><span id=\"custom-annotation\">Custom Annotation</span></h1>\n<p>API에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.</p>\n<h2><span id=\"annotation-생성하기\">Annotation 생성하기</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span>  <span class=\"comment\">//Annotation의 상속이 가능함 </span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span> <span class=\"comment\">//JavaDoc 문서 추가 가능</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME) <span class=\"comment\">// 컴파일 이후에도 JVM에 의해서 참조가 가능</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;</span><br><span class=\"line\">        ElementType.PACKAGE,         <span class=\"comment\">// 패키지 선언시</span></span><br><span class=\"line\">        ElementType.TYPE,            <span class=\"comment\">// 타입 선언시</span></span><br><span class=\"line\">        ElementType.CONSTRUCTOR,     <span class=\"comment\">// 생성자 선언시</span></span><br><span class=\"line\">        ElementType.FIELD,           <span class=\"comment\">// 멤버 변수 선언시</span></span><br><span class=\"line\">        ElementType.METHOD,          <span class=\"comment\">// 메소드 선언시</span></span><br><span class=\"line\">        ElementType.ANNOTATION_TYPE, <span class=\"comment\">// 어노테이션 타입 선언시</span></span><br><span class=\"line\">        ElementType.LOCAL_VARIABLE,  <span class=\"comment\">// 지역 변수 선언시</span></span><br><span class=\"line\">        ElementType.PARAMETER,       <span class=\"comment\">// 매개 변수 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_PARAMETER,  <span class=\"comment\">// 매개 변수 타입 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_USE         <span class=\"comment\">// 타입 사용시</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomAnnotation &#123;  <span class=\"comment\">//interface에 @를 붙여주면 Annotation으로 등록</span></span><br><span class=\"line\">    <span class=\"comment\">/* enum 타입을 선언할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Quality &#123;BAD, GOOD, VERYGOOD&#125;</span><br><span class=\"line\">    <span class=\"comment\">/* String은 기본 자료형은 아니지만 사용 가능합니다. */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 배열 형태로도 사용할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] values();</span><br><span class=\"line\">    <span class=\"comment\">/* enum 형태를 사용하는 방법입니다. */</span></span><br><span class=\"line\">    <span class=\"function\">Quality <span class=\"title\">quality</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Quality.GOOD</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"annotation-pointcut-지정하기\">Annotation Pointcut 지정하기</span></h2>\n<p>예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(value=&#123;<span class=\"string\">\"com.example.aopexam\"</span>, <span class=\"string\">\"com.example.custom.annotation\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AopExamApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(AopExamApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.custom.annotation.CustomLog;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/api/aop-test\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiService apiService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@CustomLog</span> <span class=\"comment\">//get 메소드에 @CustomLog추가</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.GET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.POST);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.PUT);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.DELETE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.ElementType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD) <span class=\"comment\">//메소드 어노테이션 적용</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomLog &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class=\"keyword\">true</span>) <span class=\"comment\">//cglib 사용 -&gt; class기반 proxy생성</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomLogAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Annotation을 기준으로 pointcut설정</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@annotation(com.example.custom.annotation.CustomLog)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">customLogPointcut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(value=<span class=\"string\">\"customLogPointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pringLog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/api/aop-test</span><br><span class=\"line\"></span><br><span class=\"line\">메소드 실행 전 무조건 이 로그를 보게 될 것이야...</span><br><span class=\"line\">[ApiService.method] apiType : GET</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>AOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.<br>\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.<br>\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.<br>\n아래의 리뷰와 같다.</p>\n<p><img src=\"/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2.png\" alt=\"AOP코드리뷰\"></p>\n<p>메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.</p>\n<p>이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.</p>\n<h1>Custom Annotation</h1>\n<p>API에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.</p>\n<h2>Annotation 생성하기</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span>  <span class=\"comment\">//Annotation의 상속이 가능함 </span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span> <span class=\"comment\">//JavaDoc 문서 추가 가능</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME) <span class=\"comment\">// 컴파일 이후에도 JVM에 의해서 참조가 가능</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;</span><br><span class=\"line\">        ElementType.PACKAGE,         <span class=\"comment\">// 패키지 선언시</span></span><br><span class=\"line\">        ElementType.TYPE,            <span class=\"comment\">// 타입 선언시</span></span><br><span class=\"line\">        ElementType.CONSTRUCTOR,     <span class=\"comment\">// 생성자 선언시</span></span><br><span class=\"line\">        ElementType.FIELD,           <span class=\"comment\">// 멤버 변수 선언시</span></span><br><span class=\"line\">        ElementType.METHOD,          <span class=\"comment\">// 메소드 선언시</span></span><br><span class=\"line\">        ElementType.ANNOTATION_TYPE, <span class=\"comment\">// 어노테이션 타입 선언시</span></span><br><span class=\"line\">        ElementType.LOCAL_VARIABLE,  <span class=\"comment\">// 지역 변수 선언시</span></span><br><span class=\"line\">        ElementType.PARAMETER,       <span class=\"comment\">// 매개 변수 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_PARAMETER,  <span class=\"comment\">// 매개 변수 타입 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_USE         <span class=\"comment\">// 타입 사용시</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomAnnotation &#123;  <span class=\"comment\">//interface에 @를 붙여주면 Annotation으로 등록</span></span><br><span class=\"line\">    <span class=\"comment\">/* enum 타입을 선언할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Quality &#123;BAD, GOOD, VERYGOOD&#125;</span><br><span class=\"line\">    <span class=\"comment\">/* String은 기본 자료형은 아니지만 사용 가능합니다. */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 배열 형태로도 사용할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] values();</span><br><span class=\"line\">    <span class=\"comment\">/* enum 형태를 사용하는 방법입니다. */</span></span><br><span class=\"line\">    <span class=\"function\">Quality <span class=\"title\">quality</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Quality.GOOD</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Annotation Pointcut 지정하기</h2>\n<p>예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(value=&#123;<span class=\"string\">\"com.example.aopexam\"</span>, <span class=\"string\">\"com.example.custom.annotation\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AopExamApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(AopExamApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.custom.annotation.CustomLog;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/api/aop-test\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiService apiService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@CustomLog</span> <span class=\"comment\">//get 메소드에 @CustomLog추가</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.GET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.POST);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.PUT);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.DELETE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.ElementType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD) <span class=\"comment\">//메소드 어노테이션 적용</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomLog &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class=\"keyword\">true</span>) <span class=\"comment\">//cglib 사용 -&gt; class기반 proxy생성</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomLogAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Annotation을 기준으로 pointcut설정</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@annotation(com.example.custom.annotation.CustomLog)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">customLogPointcut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(value=<span class=\"string\">\"customLogPointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pringLog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/api/aop-test</span><br><span class=\"line\"></span><br><span class=\"line\">메소드 실행 전 무조건 이 로그를 보게 될 것이야...</span><br><span class=\"line\">[ApiService.method] apiType : GET</span><br></pre></td></tr></table></figure>\n"},{"title":"Spring에서 Client IP구하기","catalog":true,"date":"2018-08-10T13:24:23.000Z","subtitle":null,"header-img":null,"typora-root-url":"./2018-08-10-httprequest-client-ip","typora-copy-images-to":"./2018-08-10-httprequest-client-ip","_content":"\n\n\n# HttpServletRequest에서 IP 구하기\n\n회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다. \n\n생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.\n\nHttpServletRequest에서 IP를 구하는 소스는 아래와 같다.\n\n이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 ([Spring Argument Resolver](https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/))\n\n~~~java\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            //Proxy 서버인 경우\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            //Weblogic 서버인 경우\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n~~~\n\n\n\n보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.\n구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.\n\n\n\n\n\n# IPv6 형식으로 나오는 IP를 IPv4로 변환\n\n위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.\n\n![ipv6](./ipv6.png)\n\n \n\n예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다. \n\n\n IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.\n\n1. Tomcat인 경우\n   1. $CATALINA_HOME\\bin\\catalina.bat(.sh) 을 찾는다.\n   2. `:noJuliConfig, :noJuliManager` 를 검색한다. \n   3. JAVA_OPTS에 `-Djava.net.preferIPv4Stack=true` 를 추가한다.\n\n~~~shell\nif not \"%LOGGING_CONFIG%\" == \"\" goto noJuliConfig\nset LOGGING_CONFIG=-Dnop\nif not exist \"%CATALINA_BASE%\\conf\\logging.properties\" goto noJuliConfig\nset LOGGING_CONFIG=-Djava.util.logging.config.file=\"%CATALINA_BASE%\\conf\\logging.properties\"\n:noJuliConfig\nset JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true\n\nif not \"%LOGGING_MANAGER%\" == \"\" goto noJuliManager\nset LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager\n:noJuliManager\nset JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true\n~~~\n\n\n\n2. 개발 환경에서 VM 속성 추가 하기\n   1. 사용 중인 IDE에서 VM Options에 `-Djava.net.preferIPv4Stack=true` 를 추가한다.\n\n![ide-setting](./ide-setting.png)\n\n\n\n확인 결과\n\n![ipv4](./ipv4.png)\n\n\n\n127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.\n\n\n\n# 참고\n\nhttp://all-record.tistory.com/168\nhttp://www.leafcats.com/35\nhttp://ooz.co.kr/138","source":"_posts/2018-08-10-httprequest-client-ip.md","raw":"---\ntitle: Spring에서 Client IP구하기\ncatalog: true\ndate: 2018-08-10 22:24:23\nsubtitle:\nheader-img:\ntags: Spring\ntypora-root-url: ./2018-08-10-httprequest-client-ip\ntypora-copy-images-to: ./2018-08-10-httprequest-client-ip\n---\n\n\n\n# HttpServletRequest에서 IP 구하기\n\n회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다. \n\n생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.\n\nHttpServletRequest에서 IP를 구하는 소스는 아래와 같다.\n\n이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 ([Spring Argument Resolver](https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/))\n\n~~~java\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            //Proxy 서버인 경우\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            //Weblogic 서버인 경우\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n~~~\n\n\n\n보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.\n구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.\n\n\n\n\n\n# IPv6 형식으로 나오는 IP를 IPv4로 변환\n\n위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.\n\n![ipv6](./ipv6.png)\n\n \n\n예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다. \n\n\n IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.\n\n1. Tomcat인 경우\n   1. $CATALINA_HOME\\bin\\catalina.bat(.sh) 을 찾는다.\n   2. `:noJuliConfig, :noJuliManager` 를 검색한다. \n   3. JAVA_OPTS에 `-Djava.net.preferIPv4Stack=true` 를 추가한다.\n\n~~~shell\nif not \"%LOGGING_CONFIG%\" == \"\" goto noJuliConfig\nset LOGGING_CONFIG=-Dnop\nif not exist \"%CATALINA_BASE%\\conf\\logging.properties\" goto noJuliConfig\nset LOGGING_CONFIG=-Djava.util.logging.config.file=\"%CATALINA_BASE%\\conf\\logging.properties\"\n:noJuliConfig\nset JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true\n\nif not \"%LOGGING_MANAGER%\" == \"\" goto noJuliManager\nset LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager\n:noJuliManager\nset JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true\n~~~\n\n\n\n2. 개발 환경에서 VM 속성 추가 하기\n   1. 사용 중인 IDE에서 VM Options에 `-Djava.net.preferIPv4Stack=true` 를 추가한다.\n\n![ide-setting](./ide-setting.png)\n\n\n\n확인 결과\n\n![ipv4](./ipv4.png)\n\n\n\n127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.\n\n\n\n# 참고\n\nhttp://all-record.tistory.com/168\nhttp://www.leafcats.com/35\nhttp://ooz.co.kr/138","slug":"2018-08-10-httprequest-client-ip","published":1,"updated":"2018-08-10T14:56:46.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjniq3kn40007u0yavuz4re5s","content":"<h1><span id=\"httpservletrequest에서-ip-구하기\">HttpServletRequest에서 IP 구하기</span></h1>\n<p>회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다.</p>\n<p>생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.</p>\n<p>HttpServletRequest에서 IP를 구하는 소스는 아래와 같다.</p>\n<p>이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 (<a href=\"https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/\" target=\"_blank\" rel=\"noopener\">Spring Argument Resolver</a>)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Proxy 서버인 경우</span></span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Weblogic 서버인 경우</span></span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getRemoteAddr();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.<br>\n구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.</p>\n<h1><span id=\"ipv6-형식으로-나오는-ip를-ipv4로-변환\">IPv6 형식으로 나오는 IP를 IPv4로 변환</span></h1>\n<p>위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.</p>\n<p><img src=\"./ipv6.png\" alt=\"ipv6\"></p>\n<p>예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다.</p>\n<p>IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.</p>\n<ol>\n<li>Tomcat인 경우\n<ol>\n<li>$CATALINA_HOME\\bin\\catalina.bat(.sh) 을 찾는다.</li>\n<li><code>:noJuliConfig, :noJuliManager</code> 를 검색한다.</li>\n<li>JAVA_OPTS에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if not \"%LOGGING_CONFIG%\" == \"\" goto noJuliConfig</span><br><span class=\"line\">set LOGGING_CONFIG=-Dnop</span><br><span class=\"line\">if not exist \"%CATALINA_BASE%\\conf\\logging.properties\" goto noJuliConfig</span><br><span class=\"line\">set LOGGING_CONFIG=-Djava.util.logging.config.file=\"%CATALINA_BASE%\\conf\\logging.properties\"</span><br><span class=\"line\">:noJuliConfig</span><br><span class=\"line\">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true</span><br><span class=\"line\"></span><br><span class=\"line\">if not \"%LOGGING_MANAGER%\" == \"\" goto noJuliManager</span><br><span class=\"line\">set LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class=\"line\">:noJuliManager</span><br><span class=\"line\">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>개발 환경에서 VM 속성 추가 하기\n<ol>\n<li>사용 중인 IDE에서 VM Options에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"./ide-setting.png\" alt=\"ide-setting\"></p>\n<p>확인 결과</p>\n<p><img src=\"./ipv4.png\" alt=\"ipv4\"></p>\n<p>127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.</p>\n<h1><span id=\"참고\">참고</span></h1>\n<p><a href=\"http://all-record.tistory.com/168\" target=\"_blank\" rel=\"noopener\">http://all-record.tistory.com/168</a><br>\n<a href=\"http://www.leafcats.com/35\" target=\"_blank\" rel=\"noopener\">http://www.leafcats.com/35</a><br>\n<a href=\"http://ooz.co.kr/138\" target=\"_blank\" rel=\"noopener\">http://ooz.co.kr/138</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>HttpServletRequest에서 IP 구하기</h1>\n<p>회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다.</p>\n<p>생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.</p>\n<p>HttpServletRequest에서 IP를 구하는 소스는 아래와 같다.</p>\n<p>이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 (<a href=\"https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/\" target=\"_blank\" rel=\"noopener\">Spring Argument Resolver</a>)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Proxy 서버인 경우</span></span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Weblogic 서버인 경우</span></span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getRemoteAddr();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.<br>\n구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.</p>\n<h1>IPv6 형식으로 나오는 IP를 IPv4로 변환</h1>\n<p>위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.</p>\n<p><img src=\"./ipv6.png\" alt=\"ipv6\"></p>\n<p>예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다.</p>\n<p>IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.</p>\n<ol>\n<li>Tomcat인 경우\n<ol>\n<li>$CATALINA_HOME\\bin\\catalina.bat(.sh) 을 찾는다.</li>\n<li><code>:noJuliConfig, :noJuliManager</code> 를 검색한다.</li>\n<li>JAVA_OPTS에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if not \"%LOGGING_CONFIG%\" == \"\" goto noJuliConfig</span><br><span class=\"line\">set LOGGING_CONFIG=-Dnop</span><br><span class=\"line\">if not exist \"%CATALINA_BASE%\\conf\\logging.properties\" goto noJuliConfig</span><br><span class=\"line\">set LOGGING_CONFIG=-Djava.util.logging.config.file=\"%CATALINA_BASE%\\conf\\logging.properties\"</span><br><span class=\"line\">:noJuliConfig</span><br><span class=\"line\">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true</span><br><span class=\"line\"></span><br><span class=\"line\">if not \"%LOGGING_MANAGER%\" == \"\" goto noJuliManager</span><br><span class=\"line\">set LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class=\"line\">:noJuliManager</span><br><span class=\"line\">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>개발 환경에서 VM 속성 추가 하기\n<ol>\n<li>사용 중인 IDE에서 VM Options에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"./ide-setting.png\" alt=\"ide-setting\"></p>\n<p>확인 결과</p>\n<p><img src=\"./ipv4.png\" alt=\"ipv4\"></p>\n<p>127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.</p>\n<h1>참고</h1>\n<p><a href=\"http://all-record.tistory.com/168\" target=\"_blank\" rel=\"noopener\">http://all-record.tistory.com/168</a><br>\n<a href=\"http://www.leafcats.com/35\" target=\"_blank\" rel=\"noopener\">http://www.leafcats.com/35</a><br>\n<a href=\"http://ooz.co.kr/138\" target=\"_blank\" rel=\"noopener\">http://ooz.co.kr/138</a></p>\n"},{"title":"Spring Argument Resovler","catalog":true,"date":"2018-08-09T16:53:17.000Z","subtitle":"Controller를 깔끔하게 해주는 Argument Resolver","header-img":null,"typora-root-url":"./2018-08-10-spring-argument-resolver","typora-copy-images-to":"./2018-08-10-spring-argument-resolver","_content":"\n\n\n회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나.. 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.\n\n그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.\n\n하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다.. (Client IP를 구하는 코드가 한 10줄 정도는 된다.)\n\n그래서 중간에 Filter나 Interceptor로 해볼까..? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.\n\n\n\n# Spring Argument Resolver\n\nSpring Argument Resolver는 `Controller에 들어오는 파라미터를 가공` 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공/추가/수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.\nSpring에서는 `HandlerMethodArgumentResolver`라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.\n\n\n\n# Argument Resolver 동작 방식\n\n![Dispatch-Seq](./Dispatch-Seq.jpg)\n\n\n\n(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)\n\n1. Client Request 요청\n2. Dispatcher Servlet에서 해당 요청을 처리\n3. Client Request에 대한 Handler Mapping \n   1. RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)\n   2. Interceptor처리\n   3. `Argument Resolver 처리` <-- 바로 여기서 우리가 지정한 Argument Resolver 실행\n   4. Message Converter 처리\n4. Controller Method invoke\n\n\n\n![RequestMappingHandlerAdapter](./RequestMappingHandlerAdapter.png)\n\n\n\nRequestHandlerMappingAdapter.java > getDefaultArgumentResolvers\n\n위에서 지정 된 순서대로 Argument Resolver를 실행 한다.\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.\n\n\n\n# Custom Argument Resolver 만들기\n\n내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에..)\n\n기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.\nCustom Argument Resolver를 만들기 위해서는 `HandlerMethodArgumentResolver` 인터페이스를 구현하여 만든다.\n\n```java\npackage com.example.springstudy.resolver;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.support.WebDataBinderFactory;\nimport org.springframework.web.context.request.NativeWebRequest;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.method.support.ModelAndViewContainer;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class ClientIpArgumentResolver implements HandlerMethodArgumentResolver {\n\n    /**\n     * resolveArgument를 실행 할 수 있는 method인지 판별\n     * @param methodParameter\n     * @return\n     */\n    @Override\n    public boolean supportsParameter(MethodParameter methodParameter) {\n        //@ClientIP 어노테이션이 붙은 파라미터에 대해 적용\n        return methodParameter.hasParameterAnnotation(ClientIP.class);\n    }\n\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n}\n\n```\n\n\n\nHandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.\n\n- supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n  - 물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.\n- resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.\n\n\n\n# Custom Argument Resolver 등록하기\n\n개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.\n\n전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.\n\n\n\n1. ServletContext.xml 에 등록하는 방법\n\n```xml\n<mvc:annotation-driven>\n    <mvc:argument-resolvers>\n        <bean class=\"com.example.springstudy.resolver.ClientIpArgumentResolver\"></bean>      \n    </mvc:argument-resolvers>\n</mvc:annotation-driven>\n```\n\n\n\n1. Java Config를 이용하는 방법\n\n```java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\nimport java.util.List;\n\n//WebMvcConfigurationSupport를 상속 \n//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n    \n    //우리가 만든 ArgumentResolver를 추가한다.\n    @Override\n    protected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        super.addArgumentResolvers(argumentResolvers);\n        argumentResolvers.add(new ClientIpArgumentResolver());\n    }\n}\n```\n\n\n\n# Controller에 적용\n\n```java\npackage com.example.springstudy.controller;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class ClientController {\n\n    /**\n     * 요청을 보낸 Client Ip를 return\n     * @param clientIp\n     * @return\n     */\n    @GetMapping(\"/client\")\n    public String getClientIp(@ClientIP String clientIp) {\n\n        return String.format(\"Request Client Ip = %s\", clientIp);\n    }\n}\n```\n\n\n\nController 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.\n\n\n\n실행 결과\n\n![argument-resolver-result](./argument-resolver-result.png)\n\n\n\n\n\n# 참조\n\n토비의 스프링 vol.2\n\nhttp://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\n\nhttp://zgundam.tistory.com/38\n\nhttp://rstoyanchev.github.io/spring-mvc-31-update/#13","source":"_posts/2018-08-10-spring-argument-resolver.md","raw":"---\ntitle: Spring Argument Resovler\ncatalog: true\ndate: 2018-08-10 01:53:17\nsubtitle: Controller를 깔끔하게 해주는 Argument Resolver\nheader-img:\ntags: Spring\ntypora-root-url: ./2018-08-10-spring-argument-resolver\ntypora-copy-images-to: ./2018-08-10-spring-argument-resolver\n---\n\n\n\n회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나.. 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.\n\n그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.\n\n하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다.. (Client IP를 구하는 코드가 한 10줄 정도는 된다.)\n\n그래서 중간에 Filter나 Interceptor로 해볼까..? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.\n\n\n\n# Spring Argument Resolver\n\nSpring Argument Resolver는 `Controller에 들어오는 파라미터를 가공` 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공/추가/수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.\nSpring에서는 `HandlerMethodArgumentResolver`라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.\n\n\n\n# Argument Resolver 동작 방식\n\n![Dispatch-Seq](./Dispatch-Seq.jpg)\n\n\n\n(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)\n\n1. Client Request 요청\n2. Dispatcher Servlet에서 해당 요청을 처리\n3. Client Request에 대한 Handler Mapping \n   1. RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)\n   2. Interceptor처리\n   3. `Argument Resolver 처리` <-- 바로 여기서 우리가 지정한 Argument Resolver 실행\n   4. Message Converter 처리\n4. Controller Method invoke\n\n\n\n![RequestMappingHandlerAdapter](./RequestMappingHandlerAdapter.png)\n\n\n\nRequestHandlerMappingAdapter.java > getDefaultArgumentResolvers\n\n위에서 지정 된 순서대로 Argument Resolver를 실행 한다.\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.\n\n\n\n# Custom Argument Resolver 만들기\n\n내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에..)\n\n기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.\nCustom Argument Resolver를 만들기 위해서는 `HandlerMethodArgumentResolver` 인터페이스를 구현하여 만든다.\n\n```java\npackage com.example.springstudy.resolver;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.support.WebDataBinderFactory;\nimport org.springframework.web.context.request.NativeWebRequest;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.method.support.ModelAndViewContainer;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class ClientIpArgumentResolver implements HandlerMethodArgumentResolver {\n\n    /**\n     * resolveArgument를 실행 할 수 있는 method인지 판별\n     * @param methodParameter\n     * @return\n     */\n    @Override\n    public boolean supportsParameter(MethodParameter methodParameter) {\n        //@ClientIP 어노테이션이 붙은 파라미터에 대해 적용\n        return methodParameter.hasParameterAnnotation(ClientIP.class);\n    }\n\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n}\n\n```\n\n\n\nHandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.\n\n- supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n  - 물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.\n- resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.\n\n\n\n# Custom Argument Resolver 등록하기\n\n개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.\n\n전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.\n\n\n\n1. ServletContext.xml 에 등록하는 방법\n\n```xml\n<mvc:annotation-driven>\n    <mvc:argument-resolvers>\n        <bean class=\"com.example.springstudy.resolver.ClientIpArgumentResolver\"></bean>      \n    </mvc:argument-resolvers>\n</mvc:annotation-driven>\n```\n\n\n\n1. Java Config를 이용하는 방법\n\n```java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\nimport java.util.List;\n\n//WebMvcConfigurationSupport를 상속 \n//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n    \n    //우리가 만든 ArgumentResolver를 추가한다.\n    @Override\n    protected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        super.addArgumentResolvers(argumentResolvers);\n        argumentResolvers.add(new ClientIpArgumentResolver());\n    }\n}\n```\n\n\n\n# Controller에 적용\n\n```java\npackage com.example.springstudy.controller;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class ClientController {\n\n    /**\n     * 요청을 보낸 Client Ip를 return\n     * @param clientIp\n     * @return\n     */\n    @GetMapping(\"/client\")\n    public String getClientIp(@ClientIP String clientIp) {\n\n        return String.format(\"Request Client Ip = %s\", clientIp);\n    }\n}\n```\n\n\n\nController 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.\n\n\n\n실행 결과\n\n![argument-resolver-result](./argument-resolver-result.png)\n\n\n\n\n\n# 참조\n\n토비의 스프링 vol.2\n\nhttp://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\n\nhttp://zgundam.tistory.com/38\n\nhttp://rstoyanchev.github.io/spring-mvc-31-update/#13","slug":"2018-08-10-spring-argument-resolver","published":1,"updated":"2018-08-10T13:11:17.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjniq3kn70008u0yau0i3ve6l","content":"<p>회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나… 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.</p>\n<p>그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.</p>\n<p>하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다… (Client IP를 구하는 코드가 한 10줄 정도는 된다.)</p>\n<p>그래서 중간에 Filter나 Interceptor로 해볼까…? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.</p>\n<h1><span id=\"spring-argument-resolver\">Spring Argument Resolver</span></h1>\n<p>Spring Argument Resolver는 <code>Controller에 들어오는 파라미터를 가공</code> 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공/추가/수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.<br>\nSpring에서는 <code>HandlerMethodArgumentResolver</code>라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.</p>\n<h1><span id=\"argument-resolver-동작-방식\">Argument Resolver 동작 방식</span></h1>\n<p><img src=\"./Dispatch-Seq.jpg\" alt=\"Dispatch-Seq\"></p>\n<p>(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)</p>\n<ol>\n<li>Client Request 요청</li>\n<li>Dispatcher Servlet에서 해당 요청을 처리</li>\n<li>Client Request에 대한 Handler Mapping\n<ol>\n<li>RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)</li>\n<li>Interceptor처리</li>\n<li><code>Argument Resolver 처리</code> &lt;-- 바로 여기서 우리가 지정한 Argument Resolver 실행</li>\n<li>Message Converter 처리</li>\n</ol>\n</li>\n<li>Controller Method invoke</li>\n</ol>\n<p><img src=\"./RequestMappingHandlerAdapter.png\" alt=\"RequestMappingHandlerAdapter\"></p>\n<p>RequestHandlerMappingAdapter.java &gt; getDefaultArgumentResolvers</p>\n<p>위에서 지정 된 순서대로 Argument Resolver를 실행 한다.<br>\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.<br>\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.</p>\n<h1><span id=\"custom-argument-resolver-만들기\">Custom Argument Resolver 만들기</span></h1>\n<p>내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에…)</p>\n<p>기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.<br>\nCustom Argument Resolver를 만들기 위해서는 <code>HandlerMethodArgumentResolver</code> 인터페이스를 구현하여 만든다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.resolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.MethodParameter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.util.StringUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientIpArgumentResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * resolveArgument를 실행 할 수 있는 method인지 판별</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supportsParameter</span><span class=\"params\">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//@ClientIP 어노테이션이 붙은 파라미터에 대해 적용</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> methodParameter.hasParameterAnnotation(ClientIP.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">        String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getRemoteAddr();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.</p>\n<ul>\n<li>supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n<ul>\n<li>물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.</li>\n</ul>\n</li>\n<li>resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.</li>\n</ul>\n<h1><span id=\"custom-argument-resolver-등록하기\">Custom Argument Resolver 등록하기</span></h1>\n<p>개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.</p>\n<p>전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.</p>\n<ol>\n<li>ServletContext.xml 에 등록하는 방법</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.resolver.ClientIpArgumentResolver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span>      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>Java Config를 이용하는 방법</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//WebMvcConfigurationSupport를 상속 </span></span><br><span class=\"line\"><span class=\"comment\">//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//우리가 만든 ArgumentResolver를 추가한다.</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addArgumentResolvers</span><span class=\"params\">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addArgumentResolvers(argumentResolvers);</span><br><span class=\"line\">        argumentResolvers.add(<span class=\"keyword\">new</span> ClientIpArgumentResolver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"controller에-적용\">Controller에 적용</span></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 요청을 보낸 Client Ip를 return</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> clientIp</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/client\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getClientIp</span><span class=\"params\">(@ClientIP String clientIp)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.format(<span class=\"string\">\"Request Client Ip = %s\"</span>, clientIp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Controller 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.</p>\n<p>실행 결과</p>\n<p><img src=\"./argument-resolver-result.png\" alt=\"argument-resolver-result\"></p>\n<h1><span id=\"참조\">참조</span></h1>\n<p>토비의 스프링 vol.2</p>\n<p><a href=\"http://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"noopener\">http://jekalmin.tistory.com/entry/커스텀-ArgumentResolver-등록하기</a></p>\n<p><a href=\"http://zgundam.tistory.com/38\" target=\"_blank\" rel=\"noopener\">http://zgundam.tistory.com/38</a></p>\n<p><a href=\"http://rstoyanchev.github.io/spring-mvc-31-update/#13\" target=\"_blank\" rel=\"noopener\">http://rstoyanchev.github.io/spring-mvc-31-update/#13</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나… 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.</p>\n<p>그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.</p>\n<p>하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다… (Client IP를 구하는 코드가 한 10줄 정도는 된다.)</p>\n<p>그래서 중간에 Filter나 Interceptor로 해볼까…? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.</p>\n<h1>Spring Argument Resolver</h1>\n<p>Spring Argument Resolver는 <code>Controller에 들어오는 파라미터를 가공</code> 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공/추가/수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.<br>\nSpring에서는 <code>HandlerMethodArgumentResolver</code>라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.</p>\n<h1>Argument Resolver 동작 방식</h1>\n<p><img src=\"./Dispatch-Seq.jpg\" alt=\"Dispatch-Seq\"></p>\n<p>(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)</p>\n<ol>\n<li>Client Request 요청</li>\n<li>Dispatcher Servlet에서 해당 요청을 처리</li>\n<li>Client Request에 대한 Handler Mapping\n<ol>\n<li>RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)</li>\n<li>Interceptor처리</li>\n<li><code>Argument Resolver 처리</code> &lt;-- 바로 여기서 우리가 지정한 Argument Resolver 실행</li>\n<li>Message Converter 처리</li>\n</ol>\n</li>\n<li>Controller Method invoke</li>\n</ol>\n<p><img src=\"./RequestMappingHandlerAdapter.png\" alt=\"RequestMappingHandlerAdapter\"></p>\n<p>RequestHandlerMappingAdapter.java &gt; getDefaultArgumentResolvers</p>\n<p>위에서 지정 된 순서대로 Argument Resolver를 실행 한다.<br>\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.<br>\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.</p>\n<h1>Custom Argument Resolver 만들기</h1>\n<p>내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에…)</p>\n<p>기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.<br>\nCustom Argument Resolver를 만들기 위해서는 <code>HandlerMethodArgumentResolver</code> 인터페이스를 구현하여 만든다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.resolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.MethodParameter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.util.StringUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientIpArgumentResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * resolveArgument를 실행 할 수 있는 method인지 판별</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supportsParameter</span><span class=\"params\">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//@ClientIP 어노테이션이 붙은 파라미터에 대해 적용</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> methodParameter.hasParameterAnnotation(ClientIP.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">        String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getRemoteAddr();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.</p>\n<ul>\n<li>supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n<ul>\n<li>물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.</li>\n</ul>\n</li>\n<li>resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.</li>\n</ul>\n<h1>Custom Argument Resolver 등록하기</h1>\n<p>개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.</p>\n<p>전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.</p>\n<ol>\n<li>ServletContext.xml 에 등록하는 방법</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.resolver.ClientIpArgumentResolver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span>      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>Java Config를 이용하는 방법</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//WebMvcConfigurationSupport를 상속 </span></span><br><span class=\"line\"><span class=\"comment\">//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//우리가 만든 ArgumentResolver를 추가한다.</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addArgumentResolvers</span><span class=\"params\">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addArgumentResolvers(argumentResolvers);</span><br><span class=\"line\">        argumentResolvers.add(<span class=\"keyword\">new</span> ClientIpArgumentResolver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>Controller에 적용</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 요청을 보낸 Client Ip를 return</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> clientIp</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/client\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getClientIp</span><span class=\"params\">(@ClientIP String clientIp)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.format(<span class=\"string\">\"Request Client Ip = %s\"</span>, clientIp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Controller 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.</p>\n<p>실행 결과</p>\n<p><img src=\"./argument-resolver-result.png\" alt=\"argument-resolver-result\"></p>\n<h1>참조</h1>\n<p>토비의 스프링 vol.2</p>\n<p><a href=\"http://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"noopener\">http://jekalmin.tistory.com/entry/커스텀-ArgumentResolver-등록하기</a></p>\n<p><a href=\"http://zgundam.tistory.com/38\" target=\"_blank\" rel=\"noopener\">http://zgundam.tistory.com/38</a></p>\n<p><a href=\"http://rstoyanchev.github.io/spring-mvc-31-update/#13\" target=\"_blank\" rel=\"noopener\">http://rstoyanchev.github.io/spring-mvc-31-update/#13</a></p>\n"},{"title":"Spring Filter와 Interceptor","catalog":true,"date":"2018-08-25T09:30:26.000Z","subtitle":null,"header-img":null,"Categories":["Spring"],"typora-root-url":"./2018-08-18-spring-filter-interceptor","typora-copy-images-to":"./2018-08-18-spring-filter-interceptor","_content":"\n# 들어가며..\n\n개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다. \n회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.\nFilter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.\n\n\n\n# Spring Request Flow\n\n![spring-request-lifecycle](./spring-request-lifecycle.jpg)\n\n\n\n이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.\n(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)\n\n\n\n그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.\nFilter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 `J2EE 표준스펙`이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다. \n\nInterceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.\n따라서 Interceptor는 `Spring Framework에서 제공하는 API`이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.\n\n\n\n# Filter\n\n위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.\n실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 `Spring Security, CORS Filter`등이 있다.\n\n\n\n## Filter Chain\n\n![filter-chain](./filter-chain.gif)\n\nFilter의 큰 특징으로는 Filter chain이라는 개념이 있다.\n실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 `Standard Context`에 `FilterMap`이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 `Filter chain`을 구성하게 되어 순차적으로 실행 되게 된다. \n\n* [Request에 대한 Filter Chain 생성](https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705)\n* [Request URL에 대한 FilterMap 생성](https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53)\n\n※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.\n\n\n\nFilter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.\n\n1. url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.\n2. servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.\n\n\n\n## Filter 생성\n\n~~~java\npackage com.example.springstudy.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\npublic class TestFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\t\t//filter 생성 시 처리\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        //다음 Filter 실행 전 처리 (preHandle)\n        \n        //다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)\n\t\tfilterChain.doFilter(servletRequest, servletResponse);\n        \n        //다음 Filter 실행 후 처리 (postHandle)\n    }\n\n    @Override\n    public void destroy() {\n\t\t//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)\n    }\n}\n\n~~~\n\n\n\n## 설정 방법\n\nFilter를 등록하는 방식을 크게 4가지 정도 있다.\n\n1. web.xml 등록 방식\n2. Java config 등록 방식 -> FilterRegistration Bean을 정의하여 추가할 Filter를 정의\n3. java config 등록 방식 -> AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가\n4. @WebFilter Annotation 등록 방식\n\n\n\n### 1. web.xml 등록 방식\n\n```xml\n<filter>\n    <filter-name>testFilter</filter-name>\n    <filter-class>com.example.springstudy.filter.TestFilter</filter-class>\n</filter>\n<filter>\n    <filter-name>testFilter2</filter-name>\n    <filter-class>com.example.springstudy.filter.TestFilter</filter-class>\n</filter>\n\n<filter-mapping>\n    <filter-name>testFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n    <!-- url-pattern 대신 Servlet을 지정할 수도 있다. -->\n    <servlet-name>testServlet</servlet-name> \n</filter-mapping>\n<filter-mapping>\n    <filter-name>testFilter2</filter-name>\n    <url-pattern>/*</url-pattern>\n    <!-- url-pattern 대신 Servlet을 지정할 수도 있다. -->\n    <servlet-name>testServlet</servlet-name> \n</filter-mapping>\n```\n\n\n\n### 2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의\n\n~~~java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class WebApplicationFilterConfig {\n\n    @Bean\n    public FilterRegistrationBean testFilterRegistration() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n        filterRegistrationBean.setFilter(new TestFilter());\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        filterRegistrationBean.setName(\"Test-Filter\");\n        filterRegistrationBean.setOrder(1);\n\n        return filterRegistrationBean;\n    }\n    \n    @Bean\n    public FilterRegistrationBean testFilter2Registration() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n        filterRegistrationBean.setFilter(new TestFilter2());\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        filterRegistrationBean.setName(\"Test-Filter2\");\n        filterRegistrationBean.setOrder(2);\n\n        return filterRegistrationBean;\n    }\n}\n~~~\n\n\n\nFilter chain의 실행 순서는 Filter1(Prehandle) -> Filter2(Prehandle) -> Filter2 (Posthandle) -> Filter1 (Posthandle) 순으로 실행 된다. \n\n\n\n### 3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가\n\n※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)\n\n~~~java\npackage com.example.springstudy.config;\n\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\nimport javax.servlet.Filter;\n\n@Configuration\npublic class WebInitializerConfig extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Filter[] getServletFilters() {\n        //추가할 필터 리스트를 추가한다.\n        return new Filter[]{new TestFilter(), new TestFilter2()};\n    }\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[0];\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class[0];\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[0];\n    }\n}\n\n~~~\n\n\n\n### 4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록\n\n~~~java\npackage com.example.springstudy.filter;\n\nimport org.springframework.core.annotation.Order;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n@Component\n@WebFilter(\n        description = \"1번째 필터\",\n        urlPatterns = \"/*\",\n        filterName = \"Test-Filter1\"\n)\n@Order(2)\npublic class TestFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"start testFilter1\");\n        filterChain.doFilter(servletRequest, servletResponse);\n        System.out.println(\"finish testFilter1\");\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n~~~\n\n다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.\n@Component -> Component-scan 시 Spring Bean으로 등록 된다.\n@WebFIlter -> Filter등록에 필요한 Interface를 제공한다.\n@Order -> @Component 어노테이션 사용 시 `Order Interface` 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다. \n개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.\n\n\n\n# Interceptor\n\n인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.\n\n인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 `preHandle(), postHandle()` 메소드가 구분 되어져 있어, 분기가 명확하다.\n또한 Filter와는 다르게 `handlerMethod`를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.\n\n\n\n## Interceptor 동작 방식\n\n1. 외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.\n2. DispatcherServlet의 doDispatch() 메소드에서 [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013) 메소드로 HandlerExecutionChain를 호출 한다.\n   (정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)\n3.  [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227) 메소드 내부에는 [getHandlerInternal()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401) 메소드로 handler를 가져오는 부분이 있다.\n   이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.\n4. 그 다음 [getHandlerExecutionChain()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480) 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.\n5. 추출 된 interceptor들에 대해 [preHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032) 메소드를 실행 시킨다.\n   (preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)\n6. 그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.\n7. 메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 [postHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044) 메소드를 실행 시킨다.\n\n\n\n## 설정 방법\n\n설정 방법은 크게 2가지로 이루어져 있다.\n\n1. servlet-context.xml에 등록\n\n2. Java-config 방식을 이용한 등록 -> WebMvcConfigurationSupport 이용하여 등록\n\n\n###  1. Servlet-context.xml에 등록\n\n~~~xml\n<mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/client\"/>\n            <mvc:mapping path=\"/client/test1\"/>\n            <bean id=\"testInterceptor\"\n                  class=\"com.example.springstudy.interceptor.TestInterceptor\"/>\n        </mvc:interceptor>\n</mvc:interceptors>\n~~~\n\n\n\n### 2. WebMvcConfigurationSupport 이용하여 등록\n\n~~~java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.interceptor.TestInterceptor;\nimport com.example.springstudy.interceptor.TestInterceptor2;\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n\nimport java.util.List;\n\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n\n    /**\n    * addInterceptors 메소드를 통해 Interceptor 등록\n    */\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) {\n        super.addInterceptors(registry);\n        //String... 타입으로 여러개 지정 가능\n        registry.addInterceptor(new TestInterceptor())\n                .addPathPatterns(\"/client/test1\", \"/client/help\");\n        //List 타입으로 여러개 지정 가능\n        registry.addInterceptor(new TestInterceptor2())\n                .addPathPatterns(Lists.newArrayList(\"/client\", \"/client/test1\"));\n    }\n}\n\n~~~\n\n\n\n# 참조\n\nhttp://javacan.tistory.com/entry/58\nhttp://www.leafcats.com/39\nhttps://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/","source":"_posts/2018-08-18-spring-filter-interceptor.md","raw":"---\ntitle: Spring Filter와 Interceptor\ncatalog: true\ndate: 2018-08-25 18:30:26\nsubtitle:\nheader-img:\nCategories:\n - Spring\ntags: \n - Spring\n - Spring Core\ntypora-root-url: ./2018-08-18-spring-filter-interceptor\ntypora-copy-images-to: ./2018-08-18-spring-filter-interceptor\n---\n\n# 들어가며..\n\n개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다. \n회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.\nFilter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.\n\n\n\n# Spring Request Flow\n\n![spring-request-lifecycle](./spring-request-lifecycle.jpg)\n\n\n\n이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.\n(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)\n\n\n\n그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.\nFilter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 `J2EE 표준스펙`이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다. \n\nInterceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.\n따라서 Interceptor는 `Spring Framework에서 제공하는 API`이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.\n\n\n\n# Filter\n\n위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.\n실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 `Spring Security, CORS Filter`등이 있다.\n\n\n\n## Filter Chain\n\n![filter-chain](./filter-chain.gif)\n\nFilter의 큰 특징으로는 Filter chain이라는 개념이 있다.\n실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 `Standard Context`에 `FilterMap`이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 `Filter chain`을 구성하게 되어 순차적으로 실행 되게 된다. \n\n* [Request에 대한 Filter Chain 생성](https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705)\n* [Request URL에 대한 FilterMap 생성](https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53)\n\n※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.\n\n\n\nFilter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.\n\n1. url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.\n2. servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.\n\n\n\n## Filter 생성\n\n~~~java\npackage com.example.springstudy.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\npublic class TestFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\t\t//filter 생성 시 처리\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        //다음 Filter 실행 전 처리 (preHandle)\n        \n        //다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)\n\t\tfilterChain.doFilter(servletRequest, servletResponse);\n        \n        //다음 Filter 실행 후 처리 (postHandle)\n    }\n\n    @Override\n    public void destroy() {\n\t\t//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)\n    }\n}\n\n~~~\n\n\n\n## 설정 방법\n\nFilter를 등록하는 방식을 크게 4가지 정도 있다.\n\n1. web.xml 등록 방식\n2. Java config 등록 방식 -> FilterRegistration Bean을 정의하여 추가할 Filter를 정의\n3. java config 등록 방식 -> AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가\n4. @WebFilter Annotation 등록 방식\n\n\n\n### 1. web.xml 등록 방식\n\n```xml\n<filter>\n    <filter-name>testFilter</filter-name>\n    <filter-class>com.example.springstudy.filter.TestFilter</filter-class>\n</filter>\n<filter>\n    <filter-name>testFilter2</filter-name>\n    <filter-class>com.example.springstudy.filter.TestFilter</filter-class>\n</filter>\n\n<filter-mapping>\n    <filter-name>testFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n    <!-- url-pattern 대신 Servlet을 지정할 수도 있다. -->\n    <servlet-name>testServlet</servlet-name> \n</filter-mapping>\n<filter-mapping>\n    <filter-name>testFilter2</filter-name>\n    <url-pattern>/*</url-pattern>\n    <!-- url-pattern 대신 Servlet을 지정할 수도 있다. -->\n    <servlet-name>testServlet</servlet-name> \n</filter-mapping>\n```\n\n\n\n### 2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의\n\n~~~java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class WebApplicationFilterConfig {\n\n    @Bean\n    public FilterRegistrationBean testFilterRegistration() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n        filterRegistrationBean.setFilter(new TestFilter());\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        filterRegistrationBean.setName(\"Test-Filter\");\n        filterRegistrationBean.setOrder(1);\n\n        return filterRegistrationBean;\n    }\n    \n    @Bean\n    public FilterRegistrationBean testFilter2Registration() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n        filterRegistrationBean.setFilter(new TestFilter2());\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        filterRegistrationBean.setName(\"Test-Filter2\");\n        filterRegistrationBean.setOrder(2);\n\n        return filterRegistrationBean;\n    }\n}\n~~~\n\n\n\nFilter chain의 실행 순서는 Filter1(Prehandle) -> Filter2(Prehandle) -> Filter2 (Posthandle) -> Filter1 (Posthandle) 순으로 실행 된다. \n\n\n\n### 3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가\n\n※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)\n\n~~~java\npackage com.example.springstudy.config;\n\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\nimport javax.servlet.Filter;\n\n@Configuration\npublic class WebInitializerConfig extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Filter[] getServletFilters() {\n        //추가할 필터 리스트를 추가한다.\n        return new Filter[]{new TestFilter(), new TestFilter2()};\n    }\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[0];\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class[0];\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[0];\n    }\n}\n\n~~~\n\n\n\n### 4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록\n\n~~~java\npackage com.example.springstudy.filter;\n\nimport org.springframework.core.annotation.Order;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n@Component\n@WebFilter(\n        description = \"1번째 필터\",\n        urlPatterns = \"/*\",\n        filterName = \"Test-Filter1\"\n)\n@Order(2)\npublic class TestFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"start testFilter1\");\n        filterChain.doFilter(servletRequest, servletResponse);\n        System.out.println(\"finish testFilter1\");\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n~~~\n\n다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.\n@Component -> Component-scan 시 Spring Bean으로 등록 된다.\n@WebFIlter -> Filter등록에 필요한 Interface를 제공한다.\n@Order -> @Component 어노테이션 사용 시 `Order Interface` 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다. \n개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.\n\n\n\n# Interceptor\n\n인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.\n\n인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 `preHandle(), postHandle()` 메소드가 구분 되어져 있어, 분기가 명확하다.\n또한 Filter와는 다르게 `handlerMethod`를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.\n\n\n\n## Interceptor 동작 방식\n\n1. 외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.\n2. DispatcherServlet의 doDispatch() 메소드에서 [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013) 메소드로 HandlerExecutionChain를 호출 한다.\n   (정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)\n3.  [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227) 메소드 내부에는 [getHandlerInternal()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401) 메소드로 handler를 가져오는 부분이 있다.\n   이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.\n4. 그 다음 [getHandlerExecutionChain()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480) 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.\n5. 추출 된 interceptor들에 대해 [preHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032) 메소드를 실행 시킨다.\n   (preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)\n6. 그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.\n7. 메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 [postHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044) 메소드를 실행 시킨다.\n\n\n\n## 설정 방법\n\n설정 방법은 크게 2가지로 이루어져 있다.\n\n1. servlet-context.xml에 등록\n\n2. Java-config 방식을 이용한 등록 -> WebMvcConfigurationSupport 이용하여 등록\n\n\n###  1. Servlet-context.xml에 등록\n\n~~~xml\n<mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/client\"/>\n            <mvc:mapping path=\"/client/test1\"/>\n            <bean id=\"testInterceptor\"\n                  class=\"com.example.springstudy.interceptor.TestInterceptor\"/>\n        </mvc:interceptor>\n</mvc:interceptors>\n~~~\n\n\n\n### 2. WebMvcConfigurationSupport 이용하여 등록\n\n~~~java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.interceptor.TestInterceptor;\nimport com.example.springstudy.interceptor.TestInterceptor2;\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n\nimport java.util.List;\n\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n\n    /**\n    * addInterceptors 메소드를 통해 Interceptor 등록\n    */\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) {\n        super.addInterceptors(registry);\n        //String... 타입으로 여러개 지정 가능\n        registry.addInterceptor(new TestInterceptor())\n                .addPathPatterns(\"/client/test1\", \"/client/help\");\n        //List 타입으로 여러개 지정 가능\n        registry.addInterceptor(new TestInterceptor2())\n                .addPathPatterns(Lists.newArrayList(\"/client\", \"/client/test1\"));\n    }\n}\n\n~~~\n\n\n\n# 참조\n\nhttp://javacan.tistory.com/entry/58\nhttp://www.leafcats.com/39\nhttps://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/","slug":"2018-08-18-spring-filter-interceptor","published":1,"updated":"2018-08-31T15:30:56.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjniq3knh000au0yaodzzadr0","content":"<h1><span id=\"들어가며\">들어가며…</span></h1>\n<p>개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다.<br>\n회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.<br>\nFilter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.</p>\n<h1><span id=\"spring-request-flow\">Spring Request Flow</span></h1>\n<p><img src=\"./spring-request-lifecycle.jpg\" alt=\"spring-request-lifecycle\"></p>\n<p>이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.<br>\n(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)</p>\n<p>그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.<br>\nFilter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 <code>J2EE 표준스펙</code>이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다.</p>\n<p>Interceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.<br>\n따라서 Interceptor는 <code>Spring Framework에서 제공하는 API</code>이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.</p>\n<h1><span id=\"filter\">Filter</span></h1>\n<p>위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.<br>\n실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 <code>Spring Security, CORS Filter</code>등이 있다.</p>\n<h2><span id=\"filter-chain\">Filter Chain</span></h2>\n<p><img src=\"./filter-chain.gif\" alt=\"filter-chain\"></p>\n<p>Filter의 큰 특징으로는 Filter chain이라는 개념이 있다.<br>\n실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 <code>Standard Context</code>에 <code>FilterMap</code>이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 <code>Filter chain</code>을 구성하게 되어 순차적으로 실행 되게 된다.</p>\n<ul>\n<li><a href=\"https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705\" target=\"_blank\" rel=\"noopener\">Request에 대한 Filter Chain 생성</a></li>\n<li><a href=\"https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53\" target=\"_blank\" rel=\"noopener\">Request URL에 대한 FilterMap 생성</a></li>\n</ul>\n<p>※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.</p>\n<p>Filter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.</p>\n<ol>\n<li>url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>\n<li>servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>\n</ol>\n<h2><span id=\"filter-생성\">Filter 생성</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.annotation.WebFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//filter 생성 시 처리</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//다음 Filter 실행 전 처리 (preHandle)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)</span></span><br><span class=\"line\">\t\tfilterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//다음 Filter 실행 후 처리 (postHandle)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"설정-방법\">설정 방법</span></h2>\n<p>Filter를 등록하는 방식을 크게 4가지 정도 있다.</p>\n<ol>\n<li>web.xml 등록 방식</li>\n<li>Java config 등록 방식 -&gt; FilterRegistration Bean을 정의하여 추가할 Filter를 정의</li>\n<li>java config 등록 방식 -&gt; AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</li>\n<li>@WebFilter Annotation 등록 방식</li>\n</ol>\n<h3><span id=\"1-webxml-등록-방식\">1. web.xml 등록 방식</span></h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"2-filterregistration-bean을-정의하여-추가할-filter를-정의\">2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.filter.TestFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebApplicationFilterConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">testFilterRegistration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean filterRegistrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        filterRegistrationBean.setFilter(<span class=\"keyword\">new</span> TestFilter());</span><br><span class=\"line\">        filterRegistrationBean.addUrlPatterns(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setName(<span class=\"string\">\"Test-Filter\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setOrder(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">testFilter2Registration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean filterRegistrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        filterRegistrationBean.setFilter(<span class=\"keyword\">new</span> TestFilter2());</span><br><span class=\"line\">        filterRegistrationBean.addUrlPatterns(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setName(<span class=\"string\">\"Test-Filter2\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setOrder(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Filter chain의 실행 순서는 Filter1(Prehandle) -&gt; Filter2(Prehandle) -&gt; Filter2 (Posthandle) -&gt; Filter1 (Posthandle) 순으로 실행 된다.</p>\n<h3><span id=\"3-abstractannotationconfigdispatcherservletinitializer에서-getservletfilter에-추가\">3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</span></h3>\n<p>※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.Filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebInitializerConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Filter[] getServletFilters() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//추가할 필터 리스트를 추가한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Filter[]&#123;<span class=\"keyword\">new</span> TestFilter(), <span class=\"keyword\">new</span> TestFilter2()&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String[] getServletMappings() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"4-component-webfilter-order-어노테이션을-이용한-필터-등록\">4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.annotation.Order;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.annotation.WebFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@WebFilter</span>(</span><br><span class=\"line\">        description = <span class=\"string\">\"1번째 필터\"</span>,</span><br><span class=\"line\">        urlPatterns = <span class=\"string\">\"/*\"</span>,</span><br><span class=\"line\">        filterName = <span class=\"string\">\"Test-Filter1\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"meta\">@Order</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"start testFilter1\"</span>);</span><br><span class=\"line\">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"finish testFilter1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.<br>\n@Component -&gt; Component-scan 시 Spring Bean으로 등록 된다.<br>\n@WebFIlter -&gt; Filter등록에 필요한 Interface를 제공한다.<br>\n@Order -&gt; @Component 어노테이션 사용 시 <code>Order Interface</code> 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다.<br>\n개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.</p>\n<h1><span id=\"interceptor\">Interceptor</span></h1>\n<p>인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.</p>\n<p>인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 <code>preHandle(), postHandle()</code> 메소드가 구분 되어져 있어, 분기가 명확하다.<br>\n또한 Filter와는 다르게 <code>handlerMethod</code>를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.</p>\n<h2><span id=\"interceptor-동작-방식\">Interceptor 동작 방식</span></h2>\n<ol>\n<li>외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.</li>\n<li>DispatcherServlet의 doDispatch() 메소드에서 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드로 HandlerExecutionChain를 호출 한다.<br>\n(정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드 내부에는 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401\" target=\"_blank\" rel=\"noopener\">getHandlerInternal()</a> 메소드로 handler를 가져오는 부분이 있다.<br>\n이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.</li>\n<li>그 다음 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480\" target=\"_blank\" rel=\"noopener\">getHandlerExecutionChain()</a> 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.</li>\n<li>추출 된 interceptor들에 대해 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032\" target=\"_blank\" rel=\"noopener\">preHandle()</a> 메소드를 실행 시킨다.<br>\n(preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)</li>\n<li>그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.</li>\n<li>메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044\" target=\"_blank\" rel=\"noopener\">postHandle()</a> 메소드를 실행 시킨다.</li>\n</ol>\n<h2><span id=\"설정-방법\">설정 방법</span></h2>\n<p>설정 방법은 크게 2가지로 이루어져 있다.</p>\n<ol>\n<li>\n<p>servlet-context.xml에 등록</p>\n</li>\n<li>\n<p>Java-config 방식을 이용한 등록 -&gt; WebMvcConfigurationSupport 이용하여 등록</p>\n</li>\n</ol>\n<h3><span id=\"1-servlet-contextxml에-등록\">1. Servlet-context.xml에 등록</span></h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/client\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/client/test1\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testInterceptor\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                  <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.interceptor.TestInterceptor\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"2-webmvcconfigurationsupport-이용하여-등록\">2. WebMvcConfigurationSupport 이용하여 등록</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.interceptor.TestInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.interceptor.TestInterceptor2;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * addInterceptors 메소드를 통해 Interceptor 등록</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addInterceptors(registry);</span><br><span class=\"line\">        <span class=\"comment\">//String... 타입으로 여러개 지정 가능</span></span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> TestInterceptor())</span><br><span class=\"line\">                .addPathPatterns(<span class=\"string\">\"/client/test1\"</span>, <span class=\"string\">\"/client/help\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//List 타입으로 여러개 지정 가능</span></span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> TestInterceptor2())</span><br><span class=\"line\">                .addPathPatterns(Lists.newArrayList(<span class=\"string\">\"/client\"</span>, <span class=\"string\">\"/client/test1\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"참조\">참조</span></h1>\n<p><a href=\"http://javacan.tistory.com/entry/58\" target=\"_blank\" rel=\"noopener\">http://javacan.tistory.com/entry/58</a><br>\n<a href=\"http://www.leafcats.com/39\" target=\"_blank\" rel=\"noopener\">http://www.leafcats.com/39</a><br>\n<a href=\"https://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war</a><br>\n<a href=\"https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/\" target=\"_blank\" rel=\"noopener\">https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며…</h1>\n<p>개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다.<br>\n회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.<br>\nFilter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.</p>\n<h1>Spring Request Flow</h1>\n<p><img src=\"./spring-request-lifecycle.jpg\" alt=\"spring-request-lifecycle\"></p>\n<p>이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.<br>\n(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)</p>\n<p>그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.<br>\nFilter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 <code>J2EE 표준스펙</code>이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다.</p>\n<p>Interceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.<br>\n따라서 Interceptor는 <code>Spring Framework에서 제공하는 API</code>이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.</p>\n<h1>Filter</h1>\n<p>위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.<br>\n실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 <code>Spring Security, CORS Filter</code>등이 있다.</p>\n<h2>Filter Chain</h2>\n<p><img src=\"./filter-chain.gif\" alt=\"filter-chain\"></p>\n<p>Filter의 큰 특징으로는 Filter chain이라는 개념이 있다.<br>\n실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 <code>Standard Context</code>에 <code>FilterMap</code>이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 <code>Filter chain</code>을 구성하게 되어 순차적으로 실행 되게 된다.</p>\n<ul>\n<li><a href=\"https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705\" target=\"_blank\" rel=\"noopener\">Request에 대한 Filter Chain 생성</a></li>\n<li><a href=\"https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53\" target=\"_blank\" rel=\"noopener\">Request URL에 대한 FilterMap 생성</a></li>\n</ul>\n<p>※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.</p>\n<p>Filter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.</p>\n<ol>\n<li>url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>\n<li>servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>\n</ol>\n<h2>Filter 생성</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.annotation.WebFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//filter 생성 시 처리</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//다음 Filter 실행 전 처리 (preHandle)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)</span></span><br><span class=\"line\">\t\tfilterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//다음 Filter 실행 후 처리 (postHandle)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>설정 방법</h2>\n<p>Filter를 등록하는 방식을 크게 4가지 정도 있다.</p>\n<ol>\n<li>web.xml 등록 방식</li>\n<li>Java config 등록 방식 -&gt; FilterRegistration Bean을 정의하여 추가할 Filter를 정의</li>\n<li>java config 등록 방식 -&gt; AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</li>\n<li>@WebFilter Annotation 등록 방식</li>\n</ol>\n<h3>1. web.xml 등록 방식</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.filter.TestFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebApplicationFilterConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">testFilterRegistration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean filterRegistrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        filterRegistrationBean.setFilter(<span class=\"keyword\">new</span> TestFilter());</span><br><span class=\"line\">        filterRegistrationBean.addUrlPatterns(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setName(<span class=\"string\">\"Test-Filter\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setOrder(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">testFilter2Registration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean filterRegistrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        filterRegistrationBean.setFilter(<span class=\"keyword\">new</span> TestFilter2());</span><br><span class=\"line\">        filterRegistrationBean.addUrlPatterns(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setName(<span class=\"string\">\"Test-Filter2\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setOrder(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Filter chain의 실행 순서는 Filter1(Prehandle) -&gt; Filter2(Prehandle) -&gt; Filter2 (Posthandle) -&gt; Filter1 (Posthandle) 순으로 실행 된다.</p>\n<h3>3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</h3>\n<p>※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.Filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebInitializerConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Filter[] getServletFilters() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//추가할 필터 리스트를 추가한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Filter[]&#123;<span class=\"keyword\">new</span> TestFilter(), <span class=\"keyword\">new</span> TestFilter2()&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String[] getServletMappings() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.annotation.Order;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.annotation.WebFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@WebFilter</span>(</span><br><span class=\"line\">        description = <span class=\"string\">\"1번째 필터\"</span>,</span><br><span class=\"line\">        urlPatterns = <span class=\"string\">\"/*\"</span>,</span><br><span class=\"line\">        filterName = <span class=\"string\">\"Test-Filter1\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"meta\">@Order</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"start testFilter1\"</span>);</span><br><span class=\"line\">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"finish testFilter1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.<br>\n@Component -&gt; Component-scan 시 Spring Bean으로 등록 된다.<br>\n@WebFIlter -&gt; Filter등록에 필요한 Interface를 제공한다.<br>\n@Order -&gt; @Component 어노테이션 사용 시 <code>Order Interface</code> 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다.<br>\n개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.</p>\n<h1>Interceptor</h1>\n<p>인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.</p>\n<p>인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 <code>preHandle(), postHandle()</code> 메소드가 구분 되어져 있어, 분기가 명확하다.<br>\n또한 Filter와는 다르게 <code>handlerMethod</code>를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.</p>\n<h2>Interceptor 동작 방식</h2>\n<ol>\n<li>외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.</li>\n<li>DispatcherServlet의 doDispatch() 메소드에서 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드로 HandlerExecutionChain를 호출 한다.<br>\n(정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드 내부에는 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401\" target=\"_blank\" rel=\"noopener\">getHandlerInternal()</a> 메소드로 handler를 가져오는 부분이 있다.<br>\n이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.</li>\n<li>그 다음 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480\" target=\"_blank\" rel=\"noopener\">getHandlerExecutionChain()</a> 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.</li>\n<li>추출 된 interceptor들에 대해 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032\" target=\"_blank\" rel=\"noopener\">preHandle()</a> 메소드를 실행 시킨다.<br>\n(preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)</li>\n<li>그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.</li>\n<li>메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044\" target=\"_blank\" rel=\"noopener\">postHandle()</a> 메소드를 실행 시킨다.</li>\n</ol>\n<h2>설정 방법</h2>\n<p>설정 방법은 크게 2가지로 이루어져 있다.</p>\n<ol>\n<li>\n<p>servlet-context.xml에 등록</p>\n</li>\n<li>\n<p>Java-config 방식을 이용한 등록 -&gt; WebMvcConfigurationSupport 이용하여 등록</p>\n</li>\n</ol>\n<h3>1. Servlet-context.xml에 등록</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/client\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/client/test1\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testInterceptor\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                  <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.interceptor.TestInterceptor\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>2. WebMvcConfigurationSupport 이용하여 등록</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.interceptor.TestInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.interceptor.TestInterceptor2;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * addInterceptors 메소드를 통해 Interceptor 등록</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addInterceptors(registry);</span><br><span class=\"line\">        <span class=\"comment\">//String... 타입으로 여러개 지정 가능</span></span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> TestInterceptor())</span><br><span class=\"line\">                .addPathPatterns(<span class=\"string\">\"/client/test1\"</span>, <span class=\"string\">\"/client/help\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//List 타입으로 여러개 지정 가능</span></span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> TestInterceptor2())</span><br><span class=\"line\">                .addPathPatterns(Lists.newArrayList(<span class=\"string\">\"/client\"</span>, <span class=\"string\">\"/client/test1\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>참조</h1>\n<p><a href=\"http://javacan.tistory.com/entry/58\" target=\"_blank\" rel=\"noopener\">http://javacan.tistory.com/entry/58</a><br>\n<a href=\"http://www.leafcats.com/39\" target=\"_blank\" rel=\"noopener\">http://www.leafcats.com/39</a><br>\n<a href=\"https://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war</a><br>\n<a href=\"https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/\" target=\"_blank\" rel=\"noopener\">https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</a></p>\n"},{"layout":"post","title":"Spring AOP (3)","subtitle":"3. Spring AOP","date":"2018-07-21T03:52:33.000Z","background":"/img/posts/06.jpg","_content":"\n앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.\n\n이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.\n\n\n\n# Spring AOP\n\nAOP란 `횡단 관심사 (Cross Cutting Concern)` 을 한데 모아 로직을 설계한다음\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다. \n\n이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.\n\n\n\n# Proxy란?\n\n![Proxy구성도](https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336)\n\n\n\n> Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.\n>\n> 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.\n>\n> 토비의 스프링 vol.1 (p. 430)\n\n\n\n토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다. \n\nSpring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.\n\n\n\n> OCP (Open-Close Principal : 개방 폐쇄의 원칙)\n>\n> **개방-폐쇄 원칙**(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.  \n\n실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.\n\n\n\n# Proxy vs Proxy Pattern\n\n일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.\n비슷한 개념이지만, 내용이 조금 다르다.\n\n일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.\n\nProxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.\n\n\n\n# JDK Dynamic Proxy\n\n![JDK Dynamic Proxy](https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif)\n\n\n\nJDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다. \n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다. \n\n내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.\n\n~~~java\npublic class ExamDynamicHandler implements InvocationHandler {\n    private ExamInterface target; // 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용\n     \n    public ExamDynamicHandler(ExamInterface target) {\n        this.target = target;\n    }\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args)\n            throws Throwable {\n        // TODO Auto-generated method stub\n        // 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용\n        String ret = (String)method.invoke(target, args); //타입 Safe하지 않는 단점이 있다.\n        return ret.toUpperCase(); //메소드 기능에 대한 확장\n    }\n}\n~~~\n\n\n\n# CGLIB Proxy\n\nCGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다. \n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.\n\n하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다. \n\nCGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.\n\n![CGLIB Proxy](http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png)\n\n\n\n* CGLIB Proxy 설정법\n\n* ~~~yaml\n  spring.aop.proxy-target-class=false\n  ~~~\n\n  ~~~xml\n  <aop:config proxy-target-class=\"true\">\n  </aop:config>\n  <aop:aspectj-autoproxy proxy-target-class=\"true\"/> <!-- AspectJ를 사용하는 경우 -->\n  ~~~\n\n  ~~~java\n  //AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다\n  @EnableAsync(proxyTargetClass = true)\n  @EnableCaching(proxyTargetClass = true) \n  ~~~\n\n\n\n# Spring Bean에 대한 Proxy는?\n\nSpring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데.. 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?\n\n![00.png](https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png)\n\n\n\nSpring에서는 `자동 프록시 생성기` 라는 것이 있다.\n\n빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  `DefaultAdvisorAutoProxyCreator` 라는 클래스를 사용한다. \n이 클래스는 어드바이저를 이용한 `자동 프록시 생성기` 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.\n\nDefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.\n\n1. 후처리기는 `빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해` 전달받은 빈이 프록시 적용 대상인지 확인한다.\n2. 프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 `프록시를 생성하고 어드바이저를 연결한다.`\n3. 프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.\n4. 컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.\n\n이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.\n\n \n\n# 요약..\n\n* Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.\n* Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n  * JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)\n  * CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)\n    따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)\n* Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.\n  (그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)\n\n\n\n# 참고\n\n토비의 스프링 vol.1\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttps://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99","source":"_posts/2018-07-21-spring-aop3.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (3)\"\nsubtitle: \"3. Spring AOP\"\ndate:   2018-07-21 12:52:33 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.\n\n이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.\n\n\n\n# Spring AOP\n\nAOP란 `횡단 관심사 (Cross Cutting Concern)` 을 한데 모아 로직을 설계한다음\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다. \n\n이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.\n\n\n\n# Proxy란?\n\n![Proxy구성도](https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336)\n\n\n\n> Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.\n>\n> 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.\n>\n> 토비의 스프링 vol.1 (p. 430)\n\n\n\n토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다. \n\nSpring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.\n\n\n\n> OCP (Open-Close Principal : 개방 폐쇄의 원칙)\n>\n> **개방-폐쇄 원칙**(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.  \n\n실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.\n\n\n\n# Proxy vs Proxy Pattern\n\n일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.\n비슷한 개념이지만, 내용이 조금 다르다.\n\n일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.\n\nProxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.\n\n\n\n# JDK Dynamic Proxy\n\n![JDK Dynamic Proxy](https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif)\n\n\n\nJDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다. \n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다. \n\n내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.\n\n~~~java\npublic class ExamDynamicHandler implements InvocationHandler {\n    private ExamInterface target; // 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용\n     \n    public ExamDynamicHandler(ExamInterface target) {\n        this.target = target;\n    }\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args)\n            throws Throwable {\n        // TODO Auto-generated method stub\n        // 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용\n        String ret = (String)method.invoke(target, args); //타입 Safe하지 않는 단점이 있다.\n        return ret.toUpperCase(); //메소드 기능에 대한 확장\n    }\n}\n~~~\n\n\n\n# CGLIB Proxy\n\nCGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다. \n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.\n\n하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다. \n\nCGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.\n\n![CGLIB Proxy](http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png)\n\n\n\n* CGLIB Proxy 설정법\n\n* ~~~yaml\n  spring.aop.proxy-target-class=false\n  ~~~\n\n  ~~~xml\n  <aop:config proxy-target-class=\"true\">\n  </aop:config>\n  <aop:aspectj-autoproxy proxy-target-class=\"true\"/> <!-- AspectJ를 사용하는 경우 -->\n  ~~~\n\n  ~~~java\n  //AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다\n  @EnableAsync(proxyTargetClass = true)\n  @EnableCaching(proxyTargetClass = true) \n  ~~~\n\n\n\n# Spring Bean에 대한 Proxy는?\n\nSpring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데.. 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?\n\n![00.png](https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png)\n\n\n\nSpring에서는 `자동 프록시 생성기` 라는 것이 있다.\n\n빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  `DefaultAdvisorAutoProxyCreator` 라는 클래스를 사용한다. \n이 클래스는 어드바이저를 이용한 `자동 프록시 생성기` 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.\n\nDefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.\n\n1. 후처리기는 `빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해` 전달받은 빈이 프록시 적용 대상인지 확인한다.\n2. 프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 `프록시를 생성하고 어드바이저를 연결한다.`\n3. 프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.\n4. 컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.\n\n이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.\n\n \n\n# 요약..\n\n* Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.\n* Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n  * JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)\n  * CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)\n    따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)\n* Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.\n  (그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)\n\n\n\n# 참고\n\n토비의 스프링 vol.1\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttps://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99","slug":"2018-07-21-spring-aop3","published":1,"updated":"2018-08-08T13:44:40.030Z","comments":1,"photos":[],"link":"","_id":"cjniq3knj000bu0ya9s0a8t7p","content":"<p>앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.</p>\n<p>이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.</p>\n<h1><span id=\"spring-aop\">Spring AOP</span></h1>\n<p>AOP란 <code>횡단 관심사 (Cross Cutting Concern)</code> 을 한데 모아 로직을 설계한다음<br>\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다.</p>\n<p>이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.<br>\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.<br>\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.</p>\n<h1><span id=\"proxy란\">Proxy란?</span></h1>\n<p><img src=\"https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336\" alt=\"Proxy구성도\"></p>\n<blockquote>\n<p>Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.</p>\n<p>그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.</p>\n<p>토비의 스프링 vol.1 (p. 430)</p>\n</blockquote>\n<p>토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다.</p>\n<p>Spring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.</p>\n<blockquote>\n<p>OCP (Open-Close Principal : 개방 폐쇄의 원칙)</p>\n<p><strong>개방-폐쇄 원칙</strong>(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.</p>\n</blockquote>\n<p>실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.</p>\n<h1><span id=\"proxy-vs-proxy-pattern\">Proxy vs Proxy Pattern</span></h1>\n<p>일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.<br>\n비슷한 개념이지만, 내용이 조금 다르다.</p>\n<p>일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.</p>\n<p>Proxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.</p>\n<h1><span id=\"jdk-dynamic-proxy\">JDK Dynamic Proxy</span></h1>\n<p><img src=\"https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif\" alt=\"JDK Dynamic Proxy\"></p>\n<p>JDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.<br>\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다.<br>\n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.<br>\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다.</p>\n<p>내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExamDynamicHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExamInterface target; <span class=\"comment\">// 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExamDynamicHandler</span><span class=\"params\">(ExamInterface target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        <span class=\"comment\">// 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용</span></span><br><span class=\"line\">        String ret = (String)method.invoke(target, args); <span class=\"comment\">//타입 Safe하지 않는 단점이 있다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret.toUpperCase(); <span class=\"comment\">//메소드 기능에 대한 확장</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"cglib-proxy\">CGLIB Proxy</span></h1>\n<p>CGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다.<br>\n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.</p>\n<p>하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다.</p>\n<p>CGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.</p>\n<p><img src=\"http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png\" alt=\"CGLIB Proxy\"></p>\n<ul>\n<li>\n<p>CGLIB Proxy 설정법</p>\n</li>\n<li>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.aop.proxy-target-class=false</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>/&gt;</span> <span class=\"comment\">&lt;!-- AspectJ를 사용하는 경우 --&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAsync</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1><span id=\"spring-bean에-대한-proxy는\">Spring Bean에 대한 Proxy는?</span></h1>\n<p>Spring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.<br>\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데… 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?</p>\n<p><img src=\"https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png\" alt=\"00.png\"></p>\n<p>Spring에서는 <code>자동 프록시 생성기</code> 라는 것이 있다.</p>\n<p>빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  <code>DefaultAdvisorAutoProxyCreator</code> 라는 클래스를 사용한다.<br>\n이 클래스는 어드바이저를 이용한 <code>자동 프록시 생성기</code> 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.</p>\n<p>DefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.</p>\n<ol>\n<li>후처리기는 <code>빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해</code> 전달받은 빈이 프록시 적용 대상인지 확인한다.</li>\n<li>프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 <code>프록시를 생성하고 어드바이저를 연결한다.</code></li>\n<li>프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.</li>\n<li>컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.</li>\n</ol>\n<p>이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.</p>\n<h1><span id=\"요약\">요약…</span></h1>\n<ul>\n<li>Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.</li>\n<li>Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n<ul>\n<li>JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)</li>\n<li>CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)<br>\n따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)</li>\n</ul>\n</li>\n<li>Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.<br>\n(그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)</li>\n</ul>\n<h1><span id=\"참고\">참고</span></h1>\n<p>토비의 스프링 vol.1</p>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99\" target=\"_blank\" rel=\"noopener\">https://ko.wikipedia.org/wiki/개방-폐쇄_원칙</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.</p>\n<p>이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.</p>\n<h1>Spring AOP</h1>\n<p>AOP란 <code>횡단 관심사 (Cross Cutting Concern)</code> 을 한데 모아 로직을 설계한다음<br>\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다.</p>\n<p>이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.<br>\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.<br>\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.</p>\n<h1>Proxy란?</h1>\n<p><img src=\"https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336\" alt=\"Proxy구성도\"></p>\n<blockquote>\n<p>Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.</p>\n<p>그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.</p>\n<p>토비의 스프링 vol.1 (p. 430)</p>\n</blockquote>\n<p>토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다.</p>\n<p>Spring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.</p>\n<blockquote>\n<p>OCP (Open-Close Principal : 개방 폐쇄의 원칙)</p>\n<p><strong>개방-폐쇄 원칙</strong>(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.</p>\n</blockquote>\n<p>실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.</p>\n<h1>Proxy vs Proxy Pattern</h1>\n<p>일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.<br>\n비슷한 개념이지만, 내용이 조금 다르다.</p>\n<p>일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.</p>\n<p>Proxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.</p>\n<h1>JDK Dynamic Proxy</h1>\n<p><img src=\"https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif\" alt=\"JDK Dynamic Proxy\"></p>\n<p>JDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.<br>\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다.<br>\n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.<br>\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다.</p>\n<p>내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExamDynamicHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExamInterface target; <span class=\"comment\">// 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExamDynamicHandler</span><span class=\"params\">(ExamInterface target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        <span class=\"comment\">// 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용</span></span><br><span class=\"line\">        String ret = (String)method.invoke(target, args); <span class=\"comment\">//타입 Safe하지 않는 단점이 있다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret.toUpperCase(); <span class=\"comment\">//메소드 기능에 대한 확장</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>CGLIB Proxy</h1>\n<p>CGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다.<br>\n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.</p>\n<p>하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다.</p>\n<p>CGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.</p>\n<p><img src=\"http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png\" alt=\"CGLIB Proxy\"></p>\n<ul>\n<li>\n<p>CGLIB Proxy 설정법</p>\n</li>\n<li>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.aop.proxy-target-class=false</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>/&gt;</span> <span class=\"comment\">&lt;!-- AspectJ를 사용하는 경우 --&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAsync</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1>Spring Bean에 대한 Proxy는?</h1>\n<p>Spring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.<br>\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데… 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?</p>\n<p><img src=\"https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png\" alt=\"00.png\"></p>\n<p>Spring에서는 <code>자동 프록시 생성기</code> 라는 것이 있다.</p>\n<p>빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  <code>DefaultAdvisorAutoProxyCreator</code> 라는 클래스를 사용한다.<br>\n이 클래스는 어드바이저를 이용한 <code>자동 프록시 생성기</code> 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.</p>\n<p>DefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.</p>\n<ol>\n<li>후처리기는 <code>빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해</code> 전달받은 빈이 프록시 적용 대상인지 확인한다.</li>\n<li>프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 <code>프록시를 생성하고 어드바이저를 연결한다.</code></li>\n<li>프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.</li>\n<li>컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.</li>\n</ol>\n<p>이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.</p>\n<h1>요약…</h1>\n<ul>\n<li>Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.</li>\n<li>Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n<ul>\n<li>JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)</li>\n<li>CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)<br>\n따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)</li>\n</ul>\n</li>\n<li>Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.<br>\n(그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)</li>\n</ul>\n<h1>참고</h1>\n<p>토비의 스프링 vol.1</p>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99\" target=\"_blank\" rel=\"noopener\">https://ko.wikipedia.org/wiki/개방-폐쇄_원칙</a></p>\n"},{"title":"Spring Dispatcher Servlet","catalog":true,"date":"2018-08-11T08:17:36.000Z","subtitle":null,"header-img":null,"Categories":["Spring"],"typora-root-url":"./2018-08-11-spring-dispatcher-servlet","typora-copy-images-to":"./2018-08-11-spring-dispatcher-servlet","_content":"\n# Spring Dispatcher Servlet\n\nSpring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다. \n\n\n\n# Front Controller Pattern\n\nDispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.\n\n\n\n![Front-controller-pattern](./Front-controller-pattern.png)\n\n\n\nSpring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.\n모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다. \n자세한 Cycle은 아래 그림과 같다.\n\n\n\n# Dispatcher Servlet Cycle\n\n![dispatcher-servlet-lifecycle](./dispatcher-servlet-lifecycle.jpg)\n\n\n\n1. doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 [doDispatch()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942) 메소드를 호출한다. \n2. 아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.\n3. [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017)  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.\n4. 요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.\n5. 실행될 interceptor들이 있다면 interceptor의 [preHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036) 메소드를 차례로 실행한다.\n6. Controller의 인스턴스는 HandlerExecutionChain의 [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017) 메소드를 이용해서 얻는다.\n7. HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, [getHandlerAdaptor()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024) 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.\n8. 선택된 HanlderAdaptor의 [handle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041) 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.\n9. 계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 [invoke()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894)한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)\n10. interceptor의 [postHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048) 메소드가 실행된다.\n11. [resolveViewName()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409) 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.\n12. Model 객체의 데이터를 보여주기 위해 해당 View 객체의 [render()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119) 메소드가 수행된다.\n\n\n\n# web.xml 설정하기\n\n### 기본 설정\n\n~~~xml\n<web-app> <!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--> \n    <servlet> \n        <servlet-name>appServlet</servlet-name> \n    \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    </servlet> \n\n    <servlet-mapping>\n        <servlet-name>appServlet</servlet-name>\n        <url-pattern>/</url-pattern> <!-- Default Servlet을 의미 --> \n    </servlet-mapping>\n</web-app>\n~~~\n\nappServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.\nDispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, `/` prefix로 들어오는 모든 요청을 처리한다.\n\nservlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 `/WEB-INF/appServlet-servlet.xml`을 찾게 된다. \n\n\n\n### contextConfigLocation을 이용한 설정\n\n빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다. \n\n```xml\n<servlet>\n    <servlet-name>appServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>\n        \t/WEB-INF/spring/appServlet/servlet-context.xml\n\t\t<!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --> \n        </param-value>\n    </init-param>\n</servlet>\n```\n\n\n\n### ContextLoaderListener를 이용한 설정\n\n일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.\n또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.\n이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.\n공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고, \nweb layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.\n\n~~~xml\n<!-- ApplicationContext 빈 설정 파일--> \n<context-param> \n    <param-name>contextConfigLocation</param-name> \n    <param-value> \n        <!--빈 설정 파일들간에 구분은 줄바꿈(\\n),컴마(,),세미콜론(;)등으로 한다.--> \n        /WEB-INF/config/myapp-service.xml,\n        /WEB-INF/config/myapp-dao.xml \t\t\n    </param-value> \n</context-param> \n\n<!-- \n웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, \n로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.\n--> \n<listener> \n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> </listener> \n\n<servlet> \n    <servlet-name>employee</servlet-name> \n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \t\t<init-param> \n    \t<param-name>contextConfigLocation</param-name> \t\n    \t<param-value> /WEB-INF/config/myapp-servlet.xml </param-value> \n    </init-param> \n</servlet> \n\n<servlet> \n    <servlet-name>webservice</servlet-name> \n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \t\t<init-param> \n    \t<param-name>contextConfigLocation</param-name> \n    \t<param-value> /WEB-INF/config/myapp-webservice.xml </param-value> \n    </init-param> \n</servlet>\n~~~\n\n맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.\n(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)\n\n따라서\nemployee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,\nwebServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.\n\n\n\n\n\n\n\n# 참고\n\nhttp://mangkyu.tistory.com/18\nhttp://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet\nhttp://hermeslog.tistory.com/156\nhttps://github.com/dongmyo/dispatcher2\nhttps://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/\nhttps://nesoy.github.io/articles/2017-02/Front-Controller\nhttp://wonwoo.ml/index.php/post/1590","source":"_posts/2018-08-11-spring-dispatcher-servlet.md","raw":"---\ntitle: Spring Dispatcher Servlet\ncatalog: true\ndate: 2018-08-11 17:17:36\nsubtitle:\nheader-img:\nCategories:\n - Spring\ntags: \n - Spring\n - core\ntypora-root-url: ./2018-08-11-spring-dispatcher-servlet\ntypora-copy-images-to: ./2018-08-11-spring-dispatcher-servlet\n---\n\n# Spring Dispatcher Servlet\n\nSpring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다. \n\n\n\n# Front Controller Pattern\n\nDispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.\n\n\n\n![Front-controller-pattern](./Front-controller-pattern.png)\n\n\n\nSpring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.\n모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다. \n자세한 Cycle은 아래 그림과 같다.\n\n\n\n# Dispatcher Servlet Cycle\n\n![dispatcher-servlet-lifecycle](./dispatcher-servlet-lifecycle.jpg)\n\n\n\n1. doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 [doDispatch()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942) 메소드를 호출한다. \n2. 아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.\n3. [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017)  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.\n4. 요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.\n5. 실행될 interceptor들이 있다면 interceptor의 [preHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036) 메소드를 차례로 실행한다.\n6. Controller의 인스턴스는 HandlerExecutionChain의 [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017) 메소드를 이용해서 얻는다.\n7. HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, [getHandlerAdaptor()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024) 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.\n8. 선택된 HanlderAdaptor의 [handle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041) 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.\n9. 계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 [invoke()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894)한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)\n10. interceptor의 [postHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048) 메소드가 실행된다.\n11. [resolveViewName()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409) 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.\n12. Model 객체의 데이터를 보여주기 위해 해당 View 객체의 [render()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119) 메소드가 수행된다.\n\n\n\n# web.xml 설정하기\n\n### 기본 설정\n\n~~~xml\n<web-app> <!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--> \n    <servlet> \n        <servlet-name>appServlet</servlet-name> \n    \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    </servlet> \n\n    <servlet-mapping>\n        <servlet-name>appServlet</servlet-name>\n        <url-pattern>/</url-pattern> <!-- Default Servlet을 의미 --> \n    </servlet-mapping>\n</web-app>\n~~~\n\nappServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.\nDispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, `/` prefix로 들어오는 모든 요청을 처리한다.\n\nservlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 `/WEB-INF/appServlet-servlet.xml`을 찾게 된다. \n\n\n\n### contextConfigLocation을 이용한 설정\n\n빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다. \n\n```xml\n<servlet>\n    <servlet-name>appServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>\n        \t/WEB-INF/spring/appServlet/servlet-context.xml\n\t\t<!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --> \n        </param-value>\n    </init-param>\n</servlet>\n```\n\n\n\n### ContextLoaderListener를 이용한 설정\n\n일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.\n또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.\n이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.\n공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고, \nweb layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.\n\n~~~xml\n<!-- ApplicationContext 빈 설정 파일--> \n<context-param> \n    <param-name>contextConfigLocation</param-name> \n    <param-value> \n        <!--빈 설정 파일들간에 구분은 줄바꿈(\\n),컴마(,),세미콜론(;)등으로 한다.--> \n        /WEB-INF/config/myapp-service.xml,\n        /WEB-INF/config/myapp-dao.xml \t\t\n    </param-value> \n</context-param> \n\n<!-- \n웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, \n로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.\n--> \n<listener> \n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> </listener> \n\n<servlet> \n    <servlet-name>employee</servlet-name> \n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \t\t<init-param> \n    \t<param-name>contextConfigLocation</param-name> \t\n    \t<param-value> /WEB-INF/config/myapp-servlet.xml </param-value> \n    </init-param> \n</servlet> \n\n<servlet> \n    <servlet-name>webservice</servlet-name> \n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \t\t<init-param> \n    \t<param-name>contextConfigLocation</param-name> \n    \t<param-value> /WEB-INF/config/myapp-webservice.xml </param-value> \n    </init-param> \n</servlet>\n~~~\n\n맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.\n(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)\n\n따라서\nemployee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,\nwebServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.\n\n\n\n\n\n\n\n# 참고\n\nhttp://mangkyu.tistory.com/18\nhttp://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet\nhttp://hermeslog.tistory.com/156\nhttps://github.com/dongmyo/dispatcher2\nhttps://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/\nhttps://nesoy.github.io/articles/2017-02/Front-Controller\nhttp://wonwoo.ml/index.php/post/1590","slug":"2018-08-11-spring-dispatcher-servlet","published":1,"updated":"2018-08-12T09:25:11.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjniq3knl000cu0ya6ckht259","content":"<h1><span id=\"spring-dispatcher-servlet\">Spring Dispatcher Servlet</span></h1>\n<p>Spring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다.</p>\n<h1><span id=\"front-controller-pattern\">Front Controller Pattern</span></h1>\n<p>Dispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.</p>\n<p><img src=\"./Front-controller-pattern.png\" alt=\"Front-controller-pattern\"></p>\n<p>Spring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.<br>\n모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다.<br>\n자세한 Cycle은 아래 그림과 같다.</p>\n<h1><span id=\"dispatcher-servlet-cycle\">Dispatcher Servlet Cycle</span></h1>\n<p><img src=\"./dispatcher-servlet-lifecycle.jpg\" alt=\"dispatcher-servlet-lifecycle\"></p>\n<ol>\n<li>doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942\" target=\"_blank\" rel=\"noopener\">doDispatch()</a> 메소드를 호출한다.</li>\n<li>아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017\" target=\"_blank\" rel=\"noopener\">getHandler()</a>  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.</li>\n<li>요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.</li>\n<li>실행될 interceptor들이 있다면 interceptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036\" target=\"_blank\" rel=\"noopener\">preHandle()</a> 메소드를 차례로 실행한다.</li>\n<li>Controller의 인스턴스는 HandlerExecutionChain의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드를 이용해서 얻는다.</li>\n<li>HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024\" target=\"_blank\" rel=\"noopener\">getHandlerAdaptor()</a> 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.</li>\n<li>선택된 HanlderAdaptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041\" target=\"_blank\" rel=\"noopener\">handle()</a> 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.</li>\n<li>계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894\" target=\"_blank\" rel=\"noopener\">invoke()</a>한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)</li>\n<li>interceptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048\" target=\"_blank\" rel=\"noopener\">postHandle()</a> 메소드가 실행된다.</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409\" target=\"_blank\" rel=\"noopener\">resolveViewName()</a> 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.</li>\n<li>Model 객체의 데이터를 보여주기 위해 해당 View 객체의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119\" target=\"_blank\" rel=\"noopener\">render()</a> 메소드가 수행된다.</li>\n</ol>\n<h1><span id=\"webxml-설정하기\">web.xml 설정하기</span></h1>\n<h3><span id=\"기본-설정\">기본 설정</span></h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span>&gt;</span> <span class=\"comment\">&lt;!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span> <span class=\"comment\">&lt;!-- Default Servlet을 의미 --&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>appServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.<br>\nDispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, <code>/</code> prefix로 들어오는 모든 요청을 처리한다.</p>\n<p>servlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 <code>/WEB-INF/appServlet-servlet.xml</code>을 찾게 된다.</p>\n<h3><span id=\"contextconfiglocation을-이용한-설정\">contextConfigLocation을 이용한 설정</span></h3>\n<p>빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        \t/WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"contextloaderlistener를-이용한-설정\">ContextLoaderListener를 이용한 설정</span></h3>\n<p>일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.<br>\n또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.<br>\n이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.<br>\n공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고,<br>\nweb layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- ApplicationContext 빈 설정 파일--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"comment\">&lt;!--빈 설정 파일들간에 구분은 줄바꿈(\\n),컴마(,),세미콜론(;)등으로 한다.--&gt;</span> </span><br><span class=\"line\">        /WEB-INF/config/myapp-service.xml,</span><br><span class=\"line\">        /WEB-INF/config/myapp-dao.xml \t\t</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, </span></span><br><span class=\"line\"><span class=\"comment\">로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>employee<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> \t\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> \t</span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> /WEB-INF/config/myapp-servlet.xml <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>webservice<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> \t\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> /WEB-INF/config/myapp-webservice.xml <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.<br>\n(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)</p>\n<p>따라서<br>\nemployee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,<br>\nwebServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.</p>\n<h1><span id=\"참고\">참고</span></h1>\n<p><a href=\"http://mangkyu.tistory.com/18\" target=\"_blank\" rel=\"noopener\">http://mangkyu.tistory.com/18</a><br>\n<a href=\"http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet\" target=\"_blank\" rel=\"noopener\">http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet</a><br>\n<a href=\"http://hermeslog.tistory.com/156\" target=\"_blank\" rel=\"noopener\">http://hermeslog.tistory.com/156</a><br>\n<a href=\"https://github.com/dongmyo/dispatcher2\" target=\"_blank\" rel=\"noopener\">https://github.com/dongmyo/dispatcher2</a><br>\n<a href=\"https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/\" target=\"_blank\" rel=\"noopener\">https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/</a><br>\n<a href=\"https://nesoy.github.io/articles/2017-02/Front-Controller\" target=\"_blank\" rel=\"noopener\">https://nesoy.github.io/articles/2017-02/Front-Controller</a><br>\n<a href=\"http://wonwoo.ml/index.php/post/1590\" target=\"_blank\" rel=\"noopener\">http://wonwoo.ml/index.php/post/1590</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>Spring Dispatcher Servlet</h1>\n<p>Spring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다.</p>\n<h1>Front Controller Pattern</h1>\n<p>Dispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.</p>\n<p><img src=\"./Front-controller-pattern.png\" alt=\"Front-controller-pattern\"></p>\n<p>Spring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.<br>\n모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다.<br>\n자세한 Cycle은 아래 그림과 같다.</p>\n<h1>Dispatcher Servlet Cycle</h1>\n<p><img src=\"./dispatcher-servlet-lifecycle.jpg\" alt=\"dispatcher-servlet-lifecycle\"></p>\n<ol>\n<li>doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942\" target=\"_blank\" rel=\"noopener\">doDispatch()</a> 메소드를 호출한다.</li>\n<li>아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017\" target=\"_blank\" rel=\"noopener\">getHandler()</a>  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.</li>\n<li>요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.</li>\n<li>실행될 interceptor들이 있다면 interceptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036\" target=\"_blank\" rel=\"noopener\">preHandle()</a> 메소드를 차례로 실행한다.</li>\n<li>Controller의 인스턴스는 HandlerExecutionChain의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드를 이용해서 얻는다.</li>\n<li>HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024\" target=\"_blank\" rel=\"noopener\">getHandlerAdaptor()</a> 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.</li>\n<li>선택된 HanlderAdaptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041\" target=\"_blank\" rel=\"noopener\">handle()</a> 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.</li>\n<li>계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894\" target=\"_blank\" rel=\"noopener\">invoke()</a>한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)</li>\n<li>interceptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048\" target=\"_blank\" rel=\"noopener\">postHandle()</a> 메소드가 실행된다.</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409\" target=\"_blank\" rel=\"noopener\">resolveViewName()</a> 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.</li>\n<li>Model 객체의 데이터를 보여주기 위해 해당 View 객체의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119\" target=\"_blank\" rel=\"noopener\">render()</a> 메소드가 수행된다.</li>\n</ol>\n<h1>web.xml 설정하기</h1>\n<h3>기본 설정</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span>&gt;</span> <span class=\"comment\">&lt;!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span> <span class=\"comment\">&lt;!-- Default Servlet을 의미 --&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>appServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.<br>\nDispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, <code>/</code> prefix로 들어오는 모든 요청을 처리한다.</p>\n<p>servlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 <code>/WEB-INF/appServlet-servlet.xml</code>을 찾게 된다.</p>\n<h3>contextConfigLocation을 이용한 설정</h3>\n<p>빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        \t/WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>ContextLoaderListener를 이용한 설정</h3>\n<p>일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.<br>\n또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.<br>\n이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.<br>\n공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고,<br>\nweb layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- ApplicationContext 빈 설정 파일--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"comment\">&lt;!--빈 설정 파일들간에 구분은 줄바꿈(\\n),컴마(,),세미콜론(;)등으로 한다.--&gt;</span> </span><br><span class=\"line\">        /WEB-INF/config/myapp-service.xml,</span><br><span class=\"line\">        /WEB-INF/config/myapp-dao.xml \t\t</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, </span></span><br><span class=\"line\"><span class=\"comment\">로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>employee<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> \t\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> \t</span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> /WEB-INF/config/myapp-servlet.xml <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>webservice<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> \t\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> /WEB-INF/config/myapp-webservice.xml <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.<br>\n(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)</p>\n<p>따라서<br>\nemployee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,<br>\nwebServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.</p>\n<h1>참고</h1>\n<p><a href=\"http://mangkyu.tistory.com/18\" target=\"_blank\" rel=\"noopener\">http://mangkyu.tistory.com/18</a><br>\n<a href=\"http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet\" target=\"_blank\" rel=\"noopener\">http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet</a><br>\n<a href=\"http://hermeslog.tistory.com/156\" target=\"_blank\" rel=\"noopener\">http://hermeslog.tistory.com/156</a><br>\n<a href=\"https://github.com/dongmyo/dispatcher2\" target=\"_blank\" rel=\"noopener\">https://github.com/dongmyo/dispatcher2</a><br>\n<a href=\"https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/\" target=\"_blank\" rel=\"noopener\">https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/</a><br>\n<a href=\"https://nesoy.github.io/articles/2017-02/Front-Controller\" target=\"_blank\" rel=\"noopener\">https://nesoy.github.io/articles/2017-02/Front-Controller</a><br>\n<a href=\"http://wonwoo.ml/index.php/post/1590\" target=\"_blank\" rel=\"noopener\">http://wonwoo.ml/index.php/post/1590</a></p>\n"},{"title":"Spring Handle Exception","catalog":true,"date":"2018-08-30T14:30:26.000Z","subtitle":"Spring에서 지원하는 다양한 예외처리 방법","header-img":null,"Categories":["Spring"],"typora-root-url":"./2018-08-25-spring-mvc-handle-exception","typora-copy-images-to":"./2018-08-25-spring-mvc-handle-exception","_content":"\n# 들어가며\n\nSpring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.\nDispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.\nSpring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.\n\n\n\n# 예외(Exception) 처리는 어떻게?\n\nSpring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.\n\n1. Controller 레벨에서 처리\n2. Global 레벨에서 처리\n3. HandlerExceptionResolver를 이용한 처리\n\n\n\n# Controller 레벨에서의 처리\n\nSpring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.\n`@ExceptionHandler` 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.\n\n예제 코드\n\n~~~java\npackage com.example.springstudy.demo2.controller;\n\nimport com.example.springstudy.demo2.exception.DemoException;\nimport com.example.springstudy.demo2.exception.FilterException;\nimport com.example.springstudy.demo2.exception.InterceptorException;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@Slf4j\n@Controller\npublic class DemoController {\n\n    @GetMapping(path=\"/exception/demo\")\n    public String occurDemoException() {\n        //강제로 DemoException을 발생 시켜 보았다.\n        throw new DemoException(); //occur DemoException (RuntimeException)\n    }\n    \n    @GetMapping(path=\"/exception/demo2\")\n    public String occurDemoException2() {\n        //강제로 DemoException을 발생 시켜 보았다.\n        throw new DemoException(); //occur DemoException (RuntimeException)\n    }\n\n    @ExceptionHandler(value=DemoException.class)\n    public String handleDemoException(DemoException e) {\n        log.error(e.getMessage());\n        return \"/error/404\";\n    }\n}\n~~~\n\nDemoController내에서 발생한 DemoException에 대해서는 `handleDemoException` 메소드에서 모두 처리를 해준다.\n\n* Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면` @ExceptionHandler` 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.\n* Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.\n\nSpring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.\n\n\n\n# Global 레벨에서의 처리\n\n만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?\n위의 방식 처럼 Controller 별로 `@ExceptionHandler` 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.\nSpring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.\n\n* `@ControllerAdvice` - Exception 처리 후 Error Page등을 통해 처리가 가능하다.\n* `@RestControllerAdvice`\n  * REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)\n  * @RestControllerAdvice = @ControllerAdvice + @ResponseBody\n\n위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.\n\n**주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!**\n\n\n\n예제 코드\n\n~~~java\nimport com.example.springstudy.demo2.exception.DemoException;\nimport com.example.springstudy.demo2.exception.FilterException;\nimport com.example.springstudy.demo2.exception.InterceptorException;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\n\n@Slf4j\n@ControllerAdvice\npublic class DemoControllerAdvisor {\n\n    //모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리\n    @ExceptionHandler(value = DemoException.class)\n    public String handleDemoExceptionForGlobal(DemoException e) {\n        log.error(e.getMessage());\n        return \"/error/404\";\n    }\n}\n~~~\n\n\n\n## 여기서 궁금한 점...\n\nController 클래스 내에 `@ExceptionHandler`, `@ControllerAdvice` 클래스 내의 `@ExceptionHandler` 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?\n\n\n\n실험을 해보았다.\n준비물은 아래와 같다.\n\n1. DemoException을 throw하는 DemoController1, DemoController2\n2. DemoController1에서는 DemoException에 대해 `@ExceptionHandler`를 구현하였다.\n3. DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.\n4. 전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고\n   `@ExceptionHandler`를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.\n\n\n\n### Test-Case\n\n1. DemoController1 -> throw DemoException\n2. DemoController2 -> throw DemoException\n\n\n\n### 어떤 결과가 나왔을까?\n\n1. DemoController1 -> throw DemoException\n   * 예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.\n   * 예외처리가 끝난 후 404페이지가 리턴 되었다.\n   * `@ControllerAdvice내의 @ExceptionHandler`는 실행 되지 않았다.\n\n   **=> **@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.**\n        더 상위로 Exception을 throw하더라도 `@ControllerAdvice의 @ExceptionHandler`에서 예외처리를 하지 않는다.**\n\n\n\n2. DemoController2 -> throw DemoException\n\n   * 예상대로 DemoControllerAdvice 내의 `@ExceptionHandler` 메소드에서 예외처리가 되었다.\n   * DemoController2에는 `@ExceptionHandler`가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.\n\n\n\n# HandlerExceptionResolver를 이용한 처리\n\nHandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.\n`DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것`이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.\n(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)\n\nHandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.\n\n~~~java\npackage org.springframework.web.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.lang.Nullable;\n\npublic interface HandlerExceptionResolver {\n    @Nullable\n    ModelAndView resolveException(HttpServletRequest var1, HttpServletResponse var2, @Nullable Object var3, Exception var4);\n}\n~~~\n\nDispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.\n사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.\nSpring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.\n\n\n\nDispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.\n\n1. ExceptionHandlerExceptionResolver\n2. ResponseStatusExceptionResolver\n3. DefaultHandlerExceptionResolver\n\n순으로 Resolver가 실행된다.\n\n![image-20180831234615081](./image-20180831234615081.png)\n\n\n\n## ExceptionHandlerExceptionResolver\n\nSpring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.\n위에서 사용한 `@ExceptionHandler` 어노테이션에 대한 Resolver 클래스이다.\n\n\n\n## ResponseStatusExceptionResolver\n\nResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다. \n특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.\n\n사용 예제 (@ExceptionHandler와 함께 사용)\n\n~~~java\n//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.\n//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.\n@ResponseStatus(value = HttpStatus.FORBIDDEN, reason = \"Permission Denied\")\n@ExceptionHandler(value=DemoException.class)\npublic String handleDemoException(DemoException e) {\n    log.error(e.getMessage());\n    return \"/error/403\";\n}\n~~~\n\n![image-20180831235454808](./image-20180831235454808.png)\n\n위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.\n(403에 대한 페이지는 못만들었다 ^^;)\n\n\n\n## DefaultHandlerExceptionResolver\n\nDispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 `DefaultHandlerExceptionResolver`에서 예외처리를 해준다.\n\nDefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.\n각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다. \n\n* Request URL에 맞는 Controller를 못찾는 경우 ==> 404 Not Found\n* Controller 메소드 실행 중 예외가 발생하는 경우 ==> 500 Internal Server error\n* Controller의 파라미터 형식이 잘못된 경우 ==> 400 Bad Request\n\n\n\n## SimpleMappingExceptionResolver\n\nSimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.\nException별로 error-page를 매핑할 수 있는 기능을 제공한다.\n\n설정방법은 2가지로 설명하도록 하겠다.\n\n1. Java config 방식\n\n~~~java\n@Configuration\n@EnableWebMvc\npublic WebMvcConfig extends WebMvcConfigurerAdapter {\n    @Bean(name=“customMappingExceptionResolver”)\n    public SimpleMappingExceptionResolver customMappingExceptionResolver() {\n    \tSimpleMappingExceptionResolver r = new SimpleMappingExceptionResolver();\n\n        Properties mappings = new Properties();\n        mappings.setProperty(\"DatabaseException\", \"databaseError\");\n        mappings.setProperty(\"DemoException\", \"demoError\");\n\n        r.setExceptionMappings(mappings);  \n        r.setDefaultErrorView(\"default-error-page\");    \n        r.setExceptionAttribute(\"ex\");     \n        return r;\n    }\n}\n~~~\n\n2. xml 방식\n\n~~~xml\n<bean id=\"simpleMappingExceptionResolver\" class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\n    <property name=\"exceptionMappings\"> \n        <map> \n            <entry key=\"DatabaseException\" value=\"databaseError\"/> \n            <entry key=\"DemoException\" value=\"demoError\"/> \n        </map> \n    </property> \n    <property name=\"defaultErrorView\" value=\"error\"/> \n    <property name=\"exceptionAttribute\" value=\"ex\"/>\n</bean>\n~~~\n\n\n\n자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.\n근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?\n\n# 다시 한번 Spring MVC를 보자 (자꾸 보게되네?)\n\n![spring-mvc-request](./spring-mvc-request.jpg)\n\n\n\nSpring MVC의 대한 처리는 99프로가 `Dispatcher Servlet`에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.\n하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 `HandlerExceptionResolver`의 처리를 받을 수 없다. 이럴때는 어떡할건가?\n지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.\n\n\n\n# Filter에서 예외가 발생하면?\n\nfilter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.\n\nFilter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.\n\n* web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현\n* Filter 내부에서 try-catch 구문을 통해 예외 발생 시, `request.getRequestDispatcher(String)`를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.\n  (웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.\n   Interceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)\n\n\n\n# 참조\n\nhttps://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc\nhttps://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver\nhttp://www.nextree.co.kr/p3239/\nhttp://springsource.tistory.com/7\nhttp://stewie38.tistory.com/59\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/","source":"_posts/2018-08-25-spring-mvc-handle-exception.md","raw":"---\ntitle: Spring Handle Exception\ncatalog: true\ndate: 2018-08-30 23:30:26\nsubtitle: Spring에서 지원하는 다양한 예외처리 방법\nheader-img:\nCategories:\n - Spring\ntags: \n - Spring\n - Spring Core\ntypora-root-url: ./2018-08-25-spring-mvc-handle-exception\ntypora-copy-images-to: ./2018-08-25-spring-mvc-handle-exception\n---\n\n# 들어가며\n\nSpring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.\nDispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.\nSpring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.\n\n\n\n# 예외(Exception) 처리는 어떻게?\n\nSpring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.\n\n1. Controller 레벨에서 처리\n2. Global 레벨에서 처리\n3. HandlerExceptionResolver를 이용한 처리\n\n\n\n# Controller 레벨에서의 처리\n\nSpring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.\n`@ExceptionHandler` 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.\n\n예제 코드\n\n~~~java\npackage com.example.springstudy.demo2.controller;\n\nimport com.example.springstudy.demo2.exception.DemoException;\nimport com.example.springstudy.demo2.exception.FilterException;\nimport com.example.springstudy.demo2.exception.InterceptorException;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@Slf4j\n@Controller\npublic class DemoController {\n\n    @GetMapping(path=\"/exception/demo\")\n    public String occurDemoException() {\n        //강제로 DemoException을 발생 시켜 보았다.\n        throw new DemoException(); //occur DemoException (RuntimeException)\n    }\n    \n    @GetMapping(path=\"/exception/demo2\")\n    public String occurDemoException2() {\n        //강제로 DemoException을 발생 시켜 보았다.\n        throw new DemoException(); //occur DemoException (RuntimeException)\n    }\n\n    @ExceptionHandler(value=DemoException.class)\n    public String handleDemoException(DemoException e) {\n        log.error(e.getMessage());\n        return \"/error/404\";\n    }\n}\n~~~\n\nDemoController내에서 발생한 DemoException에 대해서는 `handleDemoException` 메소드에서 모두 처리를 해준다.\n\n* Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면` @ExceptionHandler` 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.\n* Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.\n\nSpring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.\n\n\n\n# Global 레벨에서의 처리\n\n만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?\n위의 방식 처럼 Controller 별로 `@ExceptionHandler` 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.\nSpring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.\n\n* `@ControllerAdvice` - Exception 처리 후 Error Page등을 통해 처리가 가능하다.\n* `@RestControllerAdvice`\n  * REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)\n  * @RestControllerAdvice = @ControllerAdvice + @ResponseBody\n\n위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.\n\n**주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!**\n\n\n\n예제 코드\n\n~~~java\nimport com.example.springstudy.demo2.exception.DemoException;\nimport com.example.springstudy.demo2.exception.FilterException;\nimport com.example.springstudy.demo2.exception.InterceptorException;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\n\n@Slf4j\n@ControllerAdvice\npublic class DemoControllerAdvisor {\n\n    //모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리\n    @ExceptionHandler(value = DemoException.class)\n    public String handleDemoExceptionForGlobal(DemoException e) {\n        log.error(e.getMessage());\n        return \"/error/404\";\n    }\n}\n~~~\n\n\n\n## 여기서 궁금한 점...\n\nController 클래스 내에 `@ExceptionHandler`, `@ControllerAdvice` 클래스 내의 `@ExceptionHandler` 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?\n\n\n\n실험을 해보았다.\n준비물은 아래와 같다.\n\n1. DemoException을 throw하는 DemoController1, DemoController2\n2. DemoController1에서는 DemoException에 대해 `@ExceptionHandler`를 구현하였다.\n3. DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.\n4. 전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고\n   `@ExceptionHandler`를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.\n\n\n\n### Test-Case\n\n1. DemoController1 -> throw DemoException\n2. DemoController2 -> throw DemoException\n\n\n\n### 어떤 결과가 나왔을까?\n\n1. DemoController1 -> throw DemoException\n   * 예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.\n   * 예외처리가 끝난 후 404페이지가 리턴 되었다.\n   * `@ControllerAdvice내의 @ExceptionHandler`는 실행 되지 않았다.\n\n   **=> **@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.**\n        더 상위로 Exception을 throw하더라도 `@ControllerAdvice의 @ExceptionHandler`에서 예외처리를 하지 않는다.**\n\n\n\n2. DemoController2 -> throw DemoException\n\n   * 예상대로 DemoControllerAdvice 내의 `@ExceptionHandler` 메소드에서 예외처리가 되었다.\n   * DemoController2에는 `@ExceptionHandler`가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.\n\n\n\n# HandlerExceptionResolver를 이용한 처리\n\nHandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.\n`DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것`이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.\n(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)\n\nHandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.\n\n~~~java\npackage org.springframework.web.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.lang.Nullable;\n\npublic interface HandlerExceptionResolver {\n    @Nullable\n    ModelAndView resolveException(HttpServletRequest var1, HttpServletResponse var2, @Nullable Object var3, Exception var4);\n}\n~~~\n\nDispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.\n사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.\nSpring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.\n\n\n\nDispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.\n\n1. ExceptionHandlerExceptionResolver\n2. ResponseStatusExceptionResolver\n3. DefaultHandlerExceptionResolver\n\n순으로 Resolver가 실행된다.\n\n![image-20180831234615081](./image-20180831234615081.png)\n\n\n\n## ExceptionHandlerExceptionResolver\n\nSpring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.\n위에서 사용한 `@ExceptionHandler` 어노테이션에 대한 Resolver 클래스이다.\n\n\n\n## ResponseStatusExceptionResolver\n\nResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다. \n특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.\n\n사용 예제 (@ExceptionHandler와 함께 사용)\n\n~~~java\n//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.\n//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.\n@ResponseStatus(value = HttpStatus.FORBIDDEN, reason = \"Permission Denied\")\n@ExceptionHandler(value=DemoException.class)\npublic String handleDemoException(DemoException e) {\n    log.error(e.getMessage());\n    return \"/error/403\";\n}\n~~~\n\n![image-20180831235454808](./image-20180831235454808.png)\n\n위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.\n(403에 대한 페이지는 못만들었다 ^^;)\n\n\n\n## DefaultHandlerExceptionResolver\n\nDispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 `DefaultHandlerExceptionResolver`에서 예외처리를 해준다.\n\nDefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.\n각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다. \n\n* Request URL에 맞는 Controller를 못찾는 경우 ==> 404 Not Found\n* Controller 메소드 실행 중 예외가 발생하는 경우 ==> 500 Internal Server error\n* Controller의 파라미터 형식이 잘못된 경우 ==> 400 Bad Request\n\n\n\n## SimpleMappingExceptionResolver\n\nSimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.\nException별로 error-page를 매핑할 수 있는 기능을 제공한다.\n\n설정방법은 2가지로 설명하도록 하겠다.\n\n1. Java config 방식\n\n~~~java\n@Configuration\n@EnableWebMvc\npublic WebMvcConfig extends WebMvcConfigurerAdapter {\n    @Bean(name=“customMappingExceptionResolver”)\n    public SimpleMappingExceptionResolver customMappingExceptionResolver() {\n    \tSimpleMappingExceptionResolver r = new SimpleMappingExceptionResolver();\n\n        Properties mappings = new Properties();\n        mappings.setProperty(\"DatabaseException\", \"databaseError\");\n        mappings.setProperty(\"DemoException\", \"demoError\");\n\n        r.setExceptionMappings(mappings);  \n        r.setDefaultErrorView(\"default-error-page\");    \n        r.setExceptionAttribute(\"ex\");     \n        return r;\n    }\n}\n~~~\n\n2. xml 방식\n\n~~~xml\n<bean id=\"simpleMappingExceptionResolver\" class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\n    <property name=\"exceptionMappings\"> \n        <map> \n            <entry key=\"DatabaseException\" value=\"databaseError\"/> \n            <entry key=\"DemoException\" value=\"demoError\"/> \n        </map> \n    </property> \n    <property name=\"defaultErrorView\" value=\"error\"/> \n    <property name=\"exceptionAttribute\" value=\"ex\"/>\n</bean>\n~~~\n\n\n\n자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.\n근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?\n\n# 다시 한번 Spring MVC를 보자 (자꾸 보게되네?)\n\n![spring-mvc-request](./spring-mvc-request.jpg)\n\n\n\nSpring MVC의 대한 처리는 99프로가 `Dispatcher Servlet`에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.\n하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 `HandlerExceptionResolver`의 처리를 받을 수 없다. 이럴때는 어떡할건가?\n지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.\n\n\n\n# Filter에서 예외가 발생하면?\n\nfilter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.\n\nFilter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.\n\n* web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현\n* Filter 내부에서 try-catch 구문을 통해 예외 발생 시, `request.getRequestDispatcher(String)`를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.\n  (웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.\n   Interceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)\n\n\n\n# 참조\n\nhttps://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc\nhttps://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver\nhttp://www.nextree.co.kr/p3239/\nhttp://springsource.tistory.com/7\nhttp://stewie38.tistory.com/59\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/","slug":"2018-08-25-spring-mvc-handle-exception","published":1,"updated":"2018-08-31T15:30:56.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjniq3ko0000fu0yayb0e87cb","content":"<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>Spring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.<br>\nDispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.<br>\nSpring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.</p>\n<h1><span id=\"예외exception-처리는-어떻게\">예외(Exception) 처리는 어떻게?</span></h1>\n<p>Spring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.</p>\n<ol>\n<li>Controller 레벨에서 처리</li>\n<li>Global 레벨에서 처리</li>\n<li>HandlerExceptionResolver를 이용한 처리</li>\n</ol>\n<h1><span id=\"controller-레벨에서의-처리\">Controller 레벨에서의 처리</span></h1>\n<p>Spring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.<br>\n<code>@ExceptionHandler</code> 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.</p>\n<p>예제 코드</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo2.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(path=<span class=\"string\">\"/exception/demo\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">occurDemoException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DemoException(); <span class=\"comment\">//occur DemoException (RuntimeException)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(path=<span class=\"string\">\"/exception/demo2\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">occurDemoException2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DemoException(); <span class=\"comment\">//occur DemoException (RuntimeException)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value=DemoException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoException</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">        log.error(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"/error/404\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DemoController내에서 발생한 DemoException에 대해서는 <code>handleDemoException</code> 메소드에서 모두 처리를 해준다.</p>\n<ul>\n<li>Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면<code>@ExceptionHandler</code> 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.</li>\n<li>Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.</li>\n</ul>\n<p>Spring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.</p>\n<h1><span id=\"global-레벨에서의-처리\">Global 레벨에서의 처리</span></h1>\n<p>만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?<br>\n위의 방식 처럼 Controller 별로 <code>@ExceptionHandler</code> 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.<br>\nSpring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.</p>\n<ul>\n<li><code>@ControllerAdvice</code> - Exception 처리 후 Error Page등을 통해 처리가 가능하다.</li>\n<li><code>@RestControllerAdvice</code>\n<ul>\n<li>REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)</li>\n<li>@RestControllerAdvice = @ControllerAdvice + @ResponseBody</li>\n</ul>\n</li>\n</ul>\n<p>위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.</p>\n<p><strong>주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!</strong></p>\n<p>예제 코드</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@ControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoControllerAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리</span></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value = DemoException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoExceptionForGlobal</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">        log.error(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"/error/404\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"여기서-궁금한-점\">여기서 궁금한 점…</span></h2>\n<p>Controller 클래스 내에 <code>@ExceptionHandler</code>, <code>@ControllerAdvice</code> 클래스 내의 <code>@ExceptionHandler</code> 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?</p>\n<p>실험을 해보았다.<br>\n준비물은 아래와 같다.</p>\n<ol>\n<li>DemoException을 throw하는 DemoController1, DemoController2</li>\n<li>DemoController1에서는 DemoException에 대해 <code>@ExceptionHandler</code>를 구현하였다.</li>\n<li>DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.</li>\n<li>전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고<br>\n<code>@ExceptionHandler</code>를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.</li>\n</ol>\n<h3><span id=\"test-case\">Test-Case</span></h3>\n<ol>\n<li>DemoController1 -&gt; throw DemoException</li>\n<li>DemoController2 -&gt; throw DemoException</li>\n</ol>\n<h3><span id=\"어떤-결과가-나왔을까\">어떤 결과가 나왔을까?</span></h3>\n<ol>\n<li>\n<p>DemoController1 -&gt; throw DemoException</p>\n<ul>\n<li>예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.</li>\n<li>예외처리가 끝난 후 404페이지가 리턴 되었다.</li>\n<li><code>@ControllerAdvice내의 @ExceptionHandler</code>는 실행 되지 않았다.</li>\n</ul>\n<p><strong>=&gt; <strong>@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.</strong><br>\n더 상위로 Exception을 throw하더라도 <code>@ControllerAdvice의 @ExceptionHandler</code>에서 예외처리를 하지 않는다.</strong></p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>DemoController2 -&gt; throw DemoException</p>\n<ul>\n<li>예상대로 DemoControllerAdvice 내의 <code>@ExceptionHandler</code> 메소드에서 예외처리가 되었다.</li>\n<li>DemoController2에는 <code>@ExceptionHandler</code>가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.</li>\n</ul>\n</li>\n</ol>\n<h1><span id=\"handlerexceptionresolver를-이용한-처리\">HandlerExceptionResolver를 이용한 처리</span></h1>\n<p>HandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.<br>\n<code>DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것</code>이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.<br>\n(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)</p>\n<p>HandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.web.servlet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.lang.Nullable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandlerExceptionResolver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"function\">ModelAndView <span class=\"title\">resolveException</span><span class=\"params\">(HttpServletRequest var1, HttpServletResponse var2, @Nullable Object var3, Exception var4)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.<br>\n사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.<br>\nSpring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.</p>\n<p>Dispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.</p>\n<ol>\n<li>ExceptionHandlerExceptionResolver</li>\n<li>ResponseStatusExceptionResolver</li>\n<li>DefaultHandlerExceptionResolver</li>\n</ol>\n<p>순으로 Resolver가 실행된다.</p>\n<p><img src=\"./image-20180831234615081.png\" alt=\"image-20180831234615081\"></p>\n<h2><span id=\"exceptionhandlerexceptionresolver\">ExceptionHandlerExceptionResolver</span></h2>\n<p>Spring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.<br>\n위에서 사용한 <code>@ExceptionHandler</code> 어노테이션에 대한 Resolver 클래스이다.</p>\n<h2><span id=\"responsestatusexceptionresolver\">ResponseStatusExceptionResolver</span></h2>\n<p>ResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다.<br>\n특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.</p>\n<p>사용 예제 (@ExceptionHandler와 함께 사용)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseStatus</span>(value = HttpStatus.FORBIDDEN, reason = <span class=\"string\">\"Permission Denied\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ExceptionHandler</span>(value=DemoException.class)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoException</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">    log.error(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"/error/403\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"./image-20180831235454808.png\" alt=\"image-20180831235454808\"></p>\n<p>위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.<br>\n(403에 대한 페이지는 못만들었다 ^^;)</p>\n<h2><span id=\"defaulthandlerexceptionresolver\">DefaultHandlerExceptionResolver</span></h2>\n<p>DispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 <code>DefaultHandlerExceptionResolver</code>에서 예외처리를 해준다.</p>\n<p>DefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.<br>\n각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다.</p>\n<ul>\n<li>Request URL에 맞는 Controller를 못찾는 경우 ==&gt; 404 Not Found</li>\n<li>Controller 메소드 실행 중 예외가 발생하는 경우 ==&gt; 500 Internal Server error</li>\n<li>Controller의 파라미터 형식이 잘못된 경우 ==&gt; 400 Bad Request</li>\n</ul>\n<h2><span id=\"simplemappingexceptionresolver\">SimpleMappingExceptionResolver</span></h2>\n<p>SimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.<br>\nException별로 error-page를 매핑할 수 있는 기능을 제공한다.</p>\n<p>설정방법은 2가지로 설명하도록 하겠다.</p>\n<ol>\n<li>Java config 방식</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> WebMvcConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=“customMappingExceptionResolver”)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SimpleMappingExceptionResolver <span class=\"title\">customMappingExceptionResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \tSimpleMappingExceptionResolver r = <span class=\"keyword\">new</span> SimpleMappingExceptionResolver();</span><br><span class=\"line\"></span><br><span class=\"line\">        Properties mappings = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        mappings.setProperty(<span class=\"string\">\"DatabaseException\"</span>, <span class=\"string\">\"databaseError\"</span>);</span><br><span class=\"line\">        mappings.setProperty(<span class=\"string\">\"DemoException\"</span>, <span class=\"string\">\"demoError\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        r.setExceptionMappings(mappings);  </span><br><span class=\"line\">        r.setDefaultErrorView(<span class=\"string\">\"default-error-page\"</span>);    </span><br><span class=\"line\">        r.setExceptionAttribute(<span class=\"string\">\"ex\"</span>);     </span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>xml 방식</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"simpleMappingExceptionResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionMappings\"</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span> </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"DatabaseException\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"databaseError\"</span>/&gt;</span> </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"DemoException\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"demoError\"</span>/&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"defaultErrorView\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"error\"</span>/&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionAttribute\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"ex\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.<br>\n근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?</p>\n<h1><span id=\"다시-한번-spring-mvc를-보자-자꾸-보게되네\">다시 한번 Spring MVC를 보자 (자꾸 보게되네?)</span></h1>\n<p><img src=\"./spring-mvc-request.jpg\" alt=\"spring-mvc-request\"></p>\n<p>Spring MVC의 대한 처리는 99프로가 <code>Dispatcher Servlet</code>에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.<br>\n하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 <code>HandlerExceptionResolver</code>의 처리를 받을 수 없다. 이럴때는 어떡할건가?<br>\n지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.</p>\n<h1><span id=\"filter에서-예외가-발생하면\">Filter에서 예외가 발생하면?</span></h1>\n<p>filter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.</p>\n<p>Filter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.</p>\n<ul>\n<li>web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현</li>\n<li>Filter 내부에서 try-catch 구문을 통해 예외 발생 시, <code>request.getRequestDispatcher(String)</code>를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.<br>\n(웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.<br>\nInterceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)</li>\n</ul>\n<h1><span id=\"참조\">참조</span></h1>\n<p><a href=\"https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc\" target=\"_blank\" rel=\"noopener\">https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc</a><br>\n<a href=\"https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver\" target=\"_blank\" rel=\"noopener\">https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver</a><br>\n<a href=\"http://www.nextree.co.kr/p3239/\" target=\"_blank\" rel=\"noopener\">http://www.nextree.co.kr/p3239/</a><br>\n<a href=\"http://springsource.tistory.com/7\" target=\"_blank\" rel=\"noopener\">http://springsource.tistory.com/7</a><br>\n<a href=\"http://stewie38.tistory.com/59\" target=\"_blank\" rel=\"noopener\">http://stewie38.tistory.com/59</a><br>\n<a href=\"https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/\" target=\"_blank\" rel=\"noopener\">https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>Spring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.<br>\nDispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.<br>\nSpring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.</p>\n<h1>예외(Exception) 처리는 어떻게?</h1>\n<p>Spring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.</p>\n<ol>\n<li>Controller 레벨에서 처리</li>\n<li>Global 레벨에서 처리</li>\n<li>HandlerExceptionResolver를 이용한 처리</li>\n</ol>\n<h1>Controller 레벨에서의 처리</h1>\n<p>Spring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.<br>\n<code>@ExceptionHandler</code> 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.</p>\n<p>예제 코드</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo2.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(path=<span class=\"string\">\"/exception/demo\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">occurDemoException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DemoException(); <span class=\"comment\">//occur DemoException (RuntimeException)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(path=<span class=\"string\">\"/exception/demo2\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">occurDemoException2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DemoException(); <span class=\"comment\">//occur DemoException (RuntimeException)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value=DemoException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoException</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">        log.error(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"/error/404\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DemoController내에서 발생한 DemoException에 대해서는 <code>handleDemoException</code> 메소드에서 모두 처리를 해준다.</p>\n<ul>\n<li>Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면<code>@ExceptionHandler</code> 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.</li>\n<li>Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.</li>\n</ul>\n<p>Spring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.</p>\n<h1>Global 레벨에서의 처리</h1>\n<p>만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?<br>\n위의 방식 처럼 Controller 별로 <code>@ExceptionHandler</code> 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.<br>\nSpring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.</p>\n<ul>\n<li><code>@ControllerAdvice</code> - Exception 처리 후 Error Page등을 통해 처리가 가능하다.</li>\n<li><code>@RestControllerAdvice</code>\n<ul>\n<li>REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)</li>\n<li>@RestControllerAdvice = @ControllerAdvice + @ResponseBody</li>\n</ul>\n</li>\n</ul>\n<p>위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.</p>\n<p><strong>주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!</strong></p>\n<p>예제 코드</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@ControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoControllerAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리</span></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value = DemoException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoExceptionForGlobal</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">        log.error(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"/error/404\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>여기서 궁금한 점…</h2>\n<p>Controller 클래스 내에 <code>@ExceptionHandler</code>, <code>@ControllerAdvice</code> 클래스 내의 <code>@ExceptionHandler</code> 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?</p>\n<p>실험을 해보았다.<br>\n준비물은 아래와 같다.</p>\n<ol>\n<li>DemoException을 throw하는 DemoController1, DemoController2</li>\n<li>DemoController1에서는 DemoException에 대해 <code>@ExceptionHandler</code>를 구현하였다.</li>\n<li>DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.</li>\n<li>전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고<br>\n<code>@ExceptionHandler</code>를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.</li>\n</ol>\n<h3>Test-Case</h3>\n<ol>\n<li>DemoController1 -&gt; throw DemoException</li>\n<li>DemoController2 -&gt; throw DemoException</li>\n</ol>\n<h3>어떤 결과가 나왔을까?</h3>\n<ol>\n<li>\n<p>DemoController1 -&gt; throw DemoException</p>\n<ul>\n<li>예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.</li>\n<li>예외처리가 끝난 후 404페이지가 리턴 되었다.</li>\n<li><code>@ControllerAdvice내의 @ExceptionHandler</code>는 실행 되지 않았다.</li>\n</ul>\n<p><strong>=&gt; <strong>@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.</strong><br>\n더 상위로 Exception을 throw하더라도 <code>@ControllerAdvice의 @ExceptionHandler</code>에서 예외처리를 하지 않는다.</strong></p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>DemoController2 -&gt; throw DemoException</p>\n<ul>\n<li>예상대로 DemoControllerAdvice 내의 <code>@ExceptionHandler</code> 메소드에서 예외처리가 되었다.</li>\n<li>DemoController2에는 <code>@ExceptionHandler</code>가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.</li>\n</ul>\n</li>\n</ol>\n<h1>HandlerExceptionResolver를 이용한 처리</h1>\n<p>HandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.<br>\n<code>DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것</code>이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.<br>\n(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)</p>\n<p>HandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.web.servlet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.lang.Nullable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandlerExceptionResolver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"function\">ModelAndView <span class=\"title\">resolveException</span><span class=\"params\">(HttpServletRequest var1, HttpServletResponse var2, @Nullable Object var3, Exception var4)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.<br>\n사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.<br>\nSpring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.</p>\n<p>Dispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.</p>\n<ol>\n<li>ExceptionHandlerExceptionResolver</li>\n<li>ResponseStatusExceptionResolver</li>\n<li>DefaultHandlerExceptionResolver</li>\n</ol>\n<p>순으로 Resolver가 실행된다.</p>\n<p><img src=\"./image-20180831234615081.png\" alt=\"image-20180831234615081\"></p>\n<h2>ExceptionHandlerExceptionResolver</h2>\n<p>Spring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.<br>\n위에서 사용한 <code>@ExceptionHandler</code> 어노테이션에 대한 Resolver 클래스이다.</p>\n<h2>ResponseStatusExceptionResolver</h2>\n<p>ResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다.<br>\n특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.</p>\n<p>사용 예제 (@ExceptionHandler와 함께 사용)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseStatus</span>(value = HttpStatus.FORBIDDEN, reason = <span class=\"string\">\"Permission Denied\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ExceptionHandler</span>(value=DemoException.class)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoException</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">    log.error(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"/error/403\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"./image-20180831235454808.png\" alt=\"image-20180831235454808\"></p>\n<p>위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.<br>\n(403에 대한 페이지는 못만들었다 ^^;)</p>\n<h2>DefaultHandlerExceptionResolver</h2>\n<p>DispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 <code>DefaultHandlerExceptionResolver</code>에서 예외처리를 해준다.</p>\n<p>DefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.<br>\n각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다.</p>\n<ul>\n<li>Request URL에 맞는 Controller를 못찾는 경우 ==&gt; 404 Not Found</li>\n<li>Controller 메소드 실행 중 예외가 발생하는 경우 ==&gt; 500 Internal Server error</li>\n<li>Controller의 파라미터 형식이 잘못된 경우 ==&gt; 400 Bad Request</li>\n</ul>\n<h2>SimpleMappingExceptionResolver</h2>\n<p>SimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.<br>\nException별로 error-page를 매핑할 수 있는 기능을 제공한다.</p>\n<p>설정방법은 2가지로 설명하도록 하겠다.</p>\n<ol>\n<li>Java config 방식</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> WebMvcConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=“customMappingExceptionResolver”)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SimpleMappingExceptionResolver <span class=\"title\">customMappingExceptionResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \tSimpleMappingExceptionResolver r = <span class=\"keyword\">new</span> SimpleMappingExceptionResolver();</span><br><span class=\"line\"></span><br><span class=\"line\">        Properties mappings = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        mappings.setProperty(<span class=\"string\">\"DatabaseException\"</span>, <span class=\"string\">\"databaseError\"</span>);</span><br><span class=\"line\">        mappings.setProperty(<span class=\"string\">\"DemoException\"</span>, <span class=\"string\">\"demoError\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        r.setExceptionMappings(mappings);  </span><br><span class=\"line\">        r.setDefaultErrorView(<span class=\"string\">\"default-error-page\"</span>);    </span><br><span class=\"line\">        r.setExceptionAttribute(<span class=\"string\">\"ex\"</span>);     </span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>xml 방식</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"simpleMappingExceptionResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionMappings\"</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span> </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"DatabaseException\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"databaseError\"</span>/&gt;</span> </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"DemoException\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"demoError\"</span>/&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"defaultErrorView\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"error\"</span>/&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionAttribute\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"ex\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.<br>\n근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?</p>\n<h1>다시 한번 Spring MVC를 보자 (자꾸 보게되네?)</h1>\n<p><img src=\"./spring-mvc-request.jpg\" alt=\"spring-mvc-request\"></p>\n<p>Spring MVC의 대한 처리는 99프로가 <code>Dispatcher Servlet</code>에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.<br>\n하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 <code>HandlerExceptionResolver</code>의 처리를 받을 수 없다. 이럴때는 어떡할건가?<br>\n지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.</p>\n<h1>Filter에서 예외가 발생하면?</h1>\n<p>filter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.</p>\n<p>Filter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.</p>\n<ul>\n<li>web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현</li>\n<li>Filter 내부에서 try-catch 구문을 통해 예외 발생 시, <code>request.getRequestDispatcher(String)</code>를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.<br>\n(웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.<br>\nInterceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)</li>\n</ul>\n<h1>참조</h1>\n<p><a href=\"https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc\" target=\"_blank\" rel=\"noopener\">https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc</a><br>\n<a href=\"https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver\" target=\"_blank\" rel=\"noopener\">https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver</a><br>\n<a href=\"http://www.nextree.co.kr/p3239/\" target=\"_blank\" rel=\"noopener\">http://www.nextree.co.kr/p3239/</a><br>\n<a href=\"http://springsource.tistory.com/7\" target=\"_blank\" rel=\"noopener\">http://springsource.tistory.com/7</a><br>\n<a href=\"http://stewie38.tistory.com/59\" target=\"_blank\" rel=\"noopener\">http://stewie38.tistory.com/59</a><br>\n<a href=\"https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/\" target=\"_blank\" rel=\"noopener\">https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</a></p>\n"},{"title":"Servlet이란?","catalog":true,"date":"2018-09-01T04:50:06.000Z","subtitle":"Servlet.. 항상 이름만 들어본 그대여","header-img":null,"Categories":["Spring"],"typora-root-url":"./2018-09-01-servlet","typora-copy-images-to":"./2018-09-01-servlet","_content":"\n![servlet](./servlet.png)\n\n# 들어가며\n\n약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, \"이렇게 코딩하면 이렇게 동작하네~\" 라는 생각만 가지고 개발을 해왔었다. 근 1~2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 \"이게 이래서 이렇게 동작하는구나~\" 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.\n\n최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.\n\n\n<br/>\n\n# Servlet\n\nServlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데... 이제와서 알아보게 되었다.\n\nServlet의 정의에 대해 찾아보게 되었다. (출처 : [wikipedia](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF))\n\n>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 \"서블릿\"이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.\n\n결국은 `웹 서버에서 돌아가는 Java 코드`라는 뜻이다.\nJava 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.\n`HttpServlet` 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.\n\n\n\n## **Servlet의 특징**\n\n* Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술\n* 흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.\n* 클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.\n* Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.\n  (doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)\n* 클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다. \n  (WAS 내의 Thread pool의 Thread 객체를 이용한다.)\n* Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다\n  (내부적으로 Sington을 구현하고 있지는 않다고한다.)\n  여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.\n* 요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.\n  (오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)\n* `MVC에서 컨트롤러로 이용됨..` 이라고 다른 블로그에 많이들 써있는데..\n  솔직히 맞는 얘기가 아니라고 생각한다.\n  Spring MVC에서 Servlet이 하던 역할을 Controller단에서 @RequestMapping 어노테이션을 이용해 서블릿의 기능과 유사하게 만들어 놓은 것 뿐이다.\n  실제 URL-Pattern에 따른 Servlet-mapping 방식과 @RequestMapping 어노테이션을 이용한 mappingHandler처리 시, 유사하게 만들어 놓은 것 뿐이라는 의미이다.\n  따라서 Spring MVC에서 서블릿이 컨트롤러로 이용된다는 것은 엄연히 틀린 말이다.\n\n\n\n<br/>\n\n# Servlet Container\n\nServlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?\n당연히 있다. WAS라고 불리우는 프로그램이 있다.\nJava 진영에서 자주 사용하는 WAS는 단연 으뜸으로 `Apache Tomcat`이 있다. \n(다른거로는 `Jeus`나, `jBoss` 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)\n\nWAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.\n\n* Web Server (apache, nginx)와의 통신 지원\n  * 클라이언트 요청(Request)에 대한 Socket 통신 지원\n\n* Servlet Lifecycle 관리\n\n* Client 접근 URL에 대한 Servlet Mapping \n* 클라이언트 요청(Request)에 대한 멀티 스레드 관리\n* 선언적인 보안관리\n  * 보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.\n  * Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문\n  * DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.\n    대표적인 예로 Spring Security가 있다.\n\n\n\n\n<br/>\n\n# Servlet LifeCycle\n\n![Servlet-life-cycle](./Servlet-life-cycle.png)\n\nServlet의 LifeCycle은 3단계로 이루어 진다.\n\n* init() \n  *  WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.\n  * 주로 Servlet 객체에 대한 초기화 로직을 작성한다.\n  * 실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고\n    다시 서블릿 생성과 동시에 init()이 실행\n* service()\n  * Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.\n    (doGet(), doPost(), doPut(), doDel())\n* destroy()\n  * WAS shutdown 시 호출 된다.\n  * 주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다\n  * 자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.\n\n\n<br/>\n\n# Servlet 설정하기\n\n## Servlet class 생성하기\n\n~~~java\npackage com.example.springstudy.demo3.servlet;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@Slf4j\n@WebServlet(name=\"demoServlet\", url-pattern=\"/servlet/demo\")\npublic class DemoServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        log.info(\"doGet() 실행실행실행!!!\");\n        Thread thread = Thread.currentThread();\n        log.info(\"Thread ID : \" + thread.getId());\n        super.doGet(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n\n    @Override\n    public void destroy() {\n        log.info(\"Servlet destroy()\");\n        super.destroy();\n    }\n\n    @Override\n    public void init() throws ServletException {\n        log.info(\"Servlet init()\");\n        super.init();\n    }\n}\n\n~~~\n\n@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.\n(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)\n\n기본적으로 Servlet 클래스 생성은 `HttpServlet` 클래스를 상속 받아 생성한다.\nHttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.\n\n\n\n## web.xml 기반 설정\n\n~~~xml\n<servlet>\n     <servlet-name>demoServlet</servlet-name>\n     <servlet-class>com.example.springstudy.demo3.servlet.DemoServlet</servlet-class>\n</servlet>\n\n<servlet-mapping>\n    <servlet-name>demoServlet</servlet-name> \n    <url-pattern>/servlet/demo</url-pattern> \n</servlet-mapping>\n~~~\n\nweb.xml에 servlet 클래스를 선언하고 <servlet-mapping> 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.\n\n\n\n## Java Config 기반 설정\n\n~~~java\npackage com.example.springstudy.demo3.config;\n\nimport com.example.springstudy.demo3.servlet.DemoServlet;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class DemoServletConfig {\n\n    @Bean\n    public ServletRegistrationBean demoServletRegistrationBean() {\n        ServletRegistrationBean demoServletRegistrationBean = new ServletRegistrationBean();\n        demoServletRegistrationBean.setServlet(new DemoServlet());\n        demoServletRegistrationBean.addUrlMappings(\"/servlet/demo\");\n        return demoServletRegistrationBean;\n    }\n}\n\n~~~\n\n@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.\nServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.\n\n\n\n\n<br/>\n\n# JSP vs Servlet\n\n**JSP와 Servlet의 차이점**\n\n* JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태\n* Servlet은 html 태그가 out.println(\"<html>\") 형태로 들어간 형태\n\n\n\n## JSP -> Servlet 변환 과정\n\n![jspToServlet](./jspToServlet.jpeg)\n\n\n\nServlet의 최종 형태는 out.println(\"<html>\") 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.\n\n\n\n# 참조\n\nhttp://mangkyu.tistory.com/14\nhttp://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\nhttp://til0804.tistory.com/25","source":"_posts/2018-09-01-servlet.md","raw":"---\ntitle: Servlet이란?\ncatalog: true\ndate: 2018-09-01 13:50:06\nsubtitle: Servlet.. 항상 이름만 들어본 그대여\nheader-img:\nCategories:\n - Spring\ntags: \n - Spring\n - J2EE\ntypora-root-url: ./2018-09-01-servlet\ntypora-copy-images-to: ./2018-09-01-servlet\n---\n\n![servlet](./servlet.png)\n\n# 들어가며\n\n약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, \"이렇게 코딩하면 이렇게 동작하네~\" 라는 생각만 가지고 개발을 해왔었다. 근 1~2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 \"이게 이래서 이렇게 동작하는구나~\" 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.\n\n최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.\n\n\n<br/>\n\n# Servlet\n\nServlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데... 이제와서 알아보게 되었다.\n\nServlet의 정의에 대해 찾아보게 되었다. (출처 : [wikipedia](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF))\n\n>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 \"서블릿\"이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.\n\n결국은 `웹 서버에서 돌아가는 Java 코드`라는 뜻이다.\nJava 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.\n`HttpServlet` 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.\n\n\n\n## **Servlet의 특징**\n\n* Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술\n* 흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.\n* 클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.\n* Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.\n  (doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)\n* 클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다. \n  (WAS 내의 Thread pool의 Thread 객체를 이용한다.)\n* Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다\n  (내부적으로 Sington을 구현하고 있지는 않다고한다.)\n  여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.\n* 요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.\n  (오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)\n* `MVC에서 컨트롤러로 이용됨..` 이라고 다른 블로그에 많이들 써있는데..\n  솔직히 맞는 얘기가 아니라고 생각한다.\n  Spring MVC에서 Servlet이 하던 역할을 Controller단에서 @RequestMapping 어노테이션을 이용해 서블릿의 기능과 유사하게 만들어 놓은 것 뿐이다.\n  실제 URL-Pattern에 따른 Servlet-mapping 방식과 @RequestMapping 어노테이션을 이용한 mappingHandler처리 시, 유사하게 만들어 놓은 것 뿐이라는 의미이다.\n  따라서 Spring MVC에서 서블릿이 컨트롤러로 이용된다는 것은 엄연히 틀린 말이다.\n\n\n\n<br/>\n\n# Servlet Container\n\nServlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?\n당연히 있다. WAS라고 불리우는 프로그램이 있다.\nJava 진영에서 자주 사용하는 WAS는 단연 으뜸으로 `Apache Tomcat`이 있다. \n(다른거로는 `Jeus`나, `jBoss` 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)\n\nWAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.\n\n* Web Server (apache, nginx)와의 통신 지원\n  * 클라이언트 요청(Request)에 대한 Socket 통신 지원\n\n* Servlet Lifecycle 관리\n\n* Client 접근 URL에 대한 Servlet Mapping \n* 클라이언트 요청(Request)에 대한 멀티 스레드 관리\n* 선언적인 보안관리\n  * 보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.\n  * Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문\n  * DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.\n    대표적인 예로 Spring Security가 있다.\n\n\n\n\n<br/>\n\n# Servlet LifeCycle\n\n![Servlet-life-cycle](./Servlet-life-cycle.png)\n\nServlet의 LifeCycle은 3단계로 이루어 진다.\n\n* init() \n  *  WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.\n  * 주로 Servlet 객체에 대한 초기화 로직을 작성한다.\n  * 실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고\n    다시 서블릿 생성과 동시에 init()이 실행\n* service()\n  * Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.\n    (doGet(), doPost(), doPut(), doDel())\n* destroy()\n  * WAS shutdown 시 호출 된다.\n  * 주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다\n  * 자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.\n\n\n<br/>\n\n# Servlet 설정하기\n\n## Servlet class 생성하기\n\n~~~java\npackage com.example.springstudy.demo3.servlet;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@Slf4j\n@WebServlet(name=\"demoServlet\", url-pattern=\"/servlet/demo\")\npublic class DemoServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        log.info(\"doGet() 실행실행실행!!!\");\n        Thread thread = Thread.currentThread();\n        log.info(\"Thread ID : \" + thread.getId());\n        super.doGet(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n\n    @Override\n    public void destroy() {\n        log.info(\"Servlet destroy()\");\n        super.destroy();\n    }\n\n    @Override\n    public void init() throws ServletException {\n        log.info(\"Servlet init()\");\n        super.init();\n    }\n}\n\n~~~\n\n@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.\n(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)\n\n기본적으로 Servlet 클래스 생성은 `HttpServlet` 클래스를 상속 받아 생성한다.\nHttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.\n\n\n\n## web.xml 기반 설정\n\n~~~xml\n<servlet>\n     <servlet-name>demoServlet</servlet-name>\n     <servlet-class>com.example.springstudy.demo3.servlet.DemoServlet</servlet-class>\n</servlet>\n\n<servlet-mapping>\n    <servlet-name>demoServlet</servlet-name> \n    <url-pattern>/servlet/demo</url-pattern> \n</servlet-mapping>\n~~~\n\nweb.xml에 servlet 클래스를 선언하고 <servlet-mapping> 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.\n\n\n\n## Java Config 기반 설정\n\n~~~java\npackage com.example.springstudy.demo3.config;\n\nimport com.example.springstudy.demo3.servlet.DemoServlet;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class DemoServletConfig {\n\n    @Bean\n    public ServletRegistrationBean demoServletRegistrationBean() {\n        ServletRegistrationBean demoServletRegistrationBean = new ServletRegistrationBean();\n        demoServletRegistrationBean.setServlet(new DemoServlet());\n        demoServletRegistrationBean.addUrlMappings(\"/servlet/demo\");\n        return demoServletRegistrationBean;\n    }\n}\n\n~~~\n\n@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.\nServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.\n\n\n\n\n<br/>\n\n# JSP vs Servlet\n\n**JSP와 Servlet의 차이점**\n\n* JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태\n* Servlet은 html 태그가 out.println(\"<html>\") 형태로 들어간 형태\n\n\n\n## JSP -> Servlet 변환 과정\n\n![jspToServlet](./jspToServlet.jpeg)\n\n\n\nServlet의 최종 형태는 out.println(\"<html>\") 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.\n\n\n\n# 참조\n\nhttp://mangkyu.tistory.com/14\nhttp://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\nhttp://til0804.tistory.com/25","slug":"2018-09-01-servlet","published":1,"updated":"2018-09-01T08:39:18.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjniq3koi000gu0yab5q93u6i","content":"<p><img src=\"./servlet.png\" alt=\"servlet\"></p>\n<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, “이렇게 코딩하면 이렇게 동작하네~” 라는 생각만 가지고 개발을 해왔었다. 근 1~2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 “이게 이래서 이렇게 동작하는구나~” 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.</p>\n<p>최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.</p>\n<br>\n<h1><span id=\"servlet\">Servlet</span></h1>\n<p>Servlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데… 이제와서 알아보게 되었다.</p>\n<p>Servlet의 정의에 대해 찾아보게 되었다. (출처 : <a href=\"https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF\" target=\"_blank\" rel=\"noopener\">wikipedia</a>)</p>\n<blockquote>\n<p>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 &quot;서블릿&quot;이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.</p>\n</blockquote>\n<p>결국은 <code>웹 서버에서 돌아가는 Java 코드</code>라는 뜻이다.<br>\nJava 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.<br>\n<code>HttpServlet</code> 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.</p>\n<h2><span id=\"servlet의-특징\"><strong>Servlet의 특징</strong></span></h2>\n<ul>\n<li>Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술</li>\n<li>흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.</li>\n<li>클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.</li>\n<li>Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.<br>\n(doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)</li>\n<li>클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다.<br>\n(WAS 내의 Thread pool의 Thread 객체를 이용한다.)</li>\n<li>Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다<br>\n(내부적으로 Sington을 구현하고 있지는 않다고한다.)<br>\n여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.</li>\n<li>요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.<br>\n(오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)</li>\n<li><code>MVC에서 컨트롤러로 이용됨..</code> 이라고 다른 블로그에 많이들 써있는데…<br>\n솔직히 맞는 얘기가 아니라고 생각한다.<br>\nSpring MVC에서 Servlet이 하던 역할을 Controller단에서 @RequestMapping 어노테이션을 이용해 서블릿의 기능과 유사하게 만들어 놓은 것 뿐이다.<br>\n실제 URL-Pattern에 따른 Servlet-mapping 방식과 @RequestMapping 어노테이션을 이용한 mappingHandler처리 시, 유사하게 만들어 놓은 것 뿐이라는 의미이다.<br>\n따라서 Spring MVC에서 서블릿이 컨트롤러로 이용된다는 것은 엄연히 틀린 말이다.</li>\n</ul>\n<br>\n<h1><span id=\"servlet-container\">Servlet Container</span></h1>\n<p>Servlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?<br>\n당연히 있다. WAS라고 불리우는 프로그램이 있다.<br>\nJava 진영에서 자주 사용하는 WAS는 단연 으뜸으로 <code>Apache Tomcat</code>이 있다.<br>\n(다른거로는 <code>Jeus</code>나, <code>jBoss</code> 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)</p>\n<p>WAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.</p>\n<ul>\n<li>\n<p>Web Server (apache, nginx)와의 통신 지원</p>\n<ul>\n<li>클라이언트 요청(Request)에 대한 Socket 통신 지원</li>\n</ul>\n</li>\n<li>\n<p>Servlet Lifecycle 관리</p>\n</li>\n<li>\n<p>Client 접근 URL에 대한 Servlet Mapping</p>\n</li>\n<li>\n<p>클라이언트 요청(Request)에 대한 멀티 스레드 관리</p>\n</li>\n<li>\n<p>선언적인 보안관리</p>\n<ul>\n<li>보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.</li>\n<li>Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문</li>\n<li>DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.<br>\n대표적인 예로 Spring Security가 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h1><span id=\"servlet-lifecycle\">Servlet LifeCycle</span></h1>\n<p><img src=\"./Servlet-life-cycle.png\" alt=\"Servlet-life-cycle\"></p>\n<p>Servlet의 LifeCycle은 3단계로 이루어 진다.</p>\n<ul>\n<li>init()\n<ul>\n<li>WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.</li>\n<li>주로 Servlet 객체에 대한 초기화 로직을 작성한다.</li>\n<li>실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고<br>\n다시 서블릿 생성과 동시에 init()이 실행</li>\n</ul>\n</li>\n<li>service()\n<ul>\n<li>Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.<br>\n(doGet(), doPost(), doPut(), doDel())</li>\n</ul>\n</li>\n<li>destroy()\n<ul>\n<li>WAS shutdown 시 호출 된다.</li>\n<li>주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다</li>\n<li>자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h1><span id=\"servlet-설정하기\">Servlet 설정하기</span></h1>\n<h2><span id=\"servlet-class-생성하기\">Servlet class 생성하기</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo3.servlet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@WebServlet</span>(name=<span class=\"string\">\"demoServlet\"</span>, url-pattern=<span class=\"string\">\"/servlet/demo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"doGet() 실행실행실행!!!\"</span>);</span><br><span class=\"line\">        Thread thread = Thread.currentThread();</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Thread ID : \"</span> + thread.getId());</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doGet(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doPost(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Servlet destroy()\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Servlet init()\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.<br>\n(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)</p>\n<p>기본적으로 Servlet 클래스 생성은 <code>HttpServlet</code> 클래스를 상속 받아 생성한다.<br>\nHttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.</p>\n<h2><span id=\"webxml-기반-설정\">web.xml 기반 설정</span></h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.example.springstudy.demo3.servlet.DemoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/servlet/demo<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>web.xml에 servlet 클래스를 선언하고 <servlet-mapping> 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.</servlet-mapping></p>\n<h2><span id=\"java-config-기반-설정\">Java Config 기반 설정</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo3.servlet.DemoServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServletConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServletRegistrationBean <span class=\"title\">demoServletRegistrationBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ServletRegistrationBean demoServletRegistrationBean = <span class=\"keyword\">new</span> ServletRegistrationBean();</span><br><span class=\"line\">        demoServletRegistrationBean.setServlet(<span class=\"keyword\">new</span> DemoServlet());</span><br><span class=\"line\">        demoServletRegistrationBean.addUrlMappings(<span class=\"string\">\"/servlet/demo\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> demoServletRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.<br>\nServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.</p>\n<br>\n<h1><span id=\"jsp-vs-servlet\">JSP vs Servlet</span></h1>\n<p><strong>JSP와 Servlet의 차이점</strong></p>\n<ul>\n<li>JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태</li>\n<li>Servlet은 html 태그가 out.println(&quot;<html>&quot;) 형태로 들어간 형태</html></li>\n</ul>\n<h2><span id=\"jsp-gt-servlet-변환-과정\">JSP -&gt; Servlet 변환 과정</span></h2>\n<p><img src=\"./jspToServlet.jpeg\" alt=\"jspToServlet\"></p>\n<p>Servlet의 최종 형태는 out.println(&quot;<html>&quot;) 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.</html></p>\n<h1><span id=\"참조\">참조</span></h1>\n<p><a href=\"http://mangkyu.tistory.com/14\" target=\"_blank\" rel=\"noopener\">http://mangkyu.tistory.com/14</a><br>\n<a href=\"http://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" target=\"_blank\" rel=\"noopener\">http://breath91.tistory.com/entry/Servlet-이란-무엇인가</a><br>\n<a href=\"http://til0804.tistory.com/25\" target=\"_blank\" rel=\"noopener\">http://til0804.tistory.com/25</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"./servlet.png\" alt=\"servlet\"></p>\n<h1>들어가며</h1>\n<p>약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, “이렇게 코딩하면 이렇게 동작하네~” 라는 생각만 가지고 개발을 해왔었다. 근 1~2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 “이게 이래서 이렇게 동작하는구나~” 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.</p>\n<p>최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.</p>\n<br>\n<h1>Servlet</h1>\n<p>Servlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데… 이제와서 알아보게 되었다.</p>\n<p>Servlet의 정의에 대해 찾아보게 되었다. (출처 : <a href=\"https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF\" target=\"_blank\" rel=\"noopener\">wikipedia</a>)</p>\n<blockquote>\n<p>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 &quot;서블릿&quot;이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.</p>\n</blockquote>\n<p>결국은 <code>웹 서버에서 돌아가는 Java 코드</code>라는 뜻이다.<br>\nJava 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.<br>\n<code>HttpServlet</code> 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.</p>\n<h2><strong>Servlet의 특징</strong></h2>\n<ul>\n<li>Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술</li>\n<li>흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.</li>\n<li>클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.</li>\n<li>Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.<br>\n(doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)</li>\n<li>클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다.<br>\n(WAS 내의 Thread pool의 Thread 객체를 이용한다.)</li>\n<li>Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다<br>\n(내부적으로 Sington을 구현하고 있지는 않다고한다.)<br>\n여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.</li>\n<li>요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.<br>\n(오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)</li>\n<li><code>MVC에서 컨트롤러로 이용됨..</code> 이라고 다른 블로그에 많이들 써있는데…<br>\n솔직히 맞는 얘기가 아니라고 생각한다.<br>\nSpring MVC에서 Servlet이 하던 역할을 Controller단에서 @RequestMapping 어노테이션을 이용해 서블릿의 기능과 유사하게 만들어 놓은 것 뿐이다.<br>\n실제 URL-Pattern에 따른 Servlet-mapping 방식과 @RequestMapping 어노테이션을 이용한 mappingHandler처리 시, 유사하게 만들어 놓은 것 뿐이라는 의미이다.<br>\n따라서 Spring MVC에서 서블릿이 컨트롤러로 이용된다는 것은 엄연히 틀린 말이다.</li>\n</ul>\n<br>\n<h1>Servlet Container</h1>\n<p>Servlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?<br>\n당연히 있다. WAS라고 불리우는 프로그램이 있다.<br>\nJava 진영에서 자주 사용하는 WAS는 단연 으뜸으로 <code>Apache Tomcat</code>이 있다.<br>\n(다른거로는 <code>Jeus</code>나, <code>jBoss</code> 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)</p>\n<p>WAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.</p>\n<ul>\n<li>\n<p>Web Server (apache, nginx)와의 통신 지원</p>\n<ul>\n<li>클라이언트 요청(Request)에 대한 Socket 통신 지원</li>\n</ul>\n</li>\n<li>\n<p>Servlet Lifecycle 관리</p>\n</li>\n<li>\n<p>Client 접근 URL에 대한 Servlet Mapping</p>\n</li>\n<li>\n<p>클라이언트 요청(Request)에 대한 멀티 스레드 관리</p>\n</li>\n<li>\n<p>선언적인 보안관리</p>\n<ul>\n<li>보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.</li>\n<li>Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문</li>\n<li>DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.<br>\n대표적인 예로 Spring Security가 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h1>Servlet LifeCycle</h1>\n<p><img src=\"./Servlet-life-cycle.png\" alt=\"Servlet-life-cycle\"></p>\n<p>Servlet의 LifeCycle은 3단계로 이루어 진다.</p>\n<ul>\n<li>init()\n<ul>\n<li>WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.</li>\n<li>주로 Servlet 객체에 대한 초기화 로직을 작성한다.</li>\n<li>실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고<br>\n다시 서블릿 생성과 동시에 init()이 실행</li>\n</ul>\n</li>\n<li>service()\n<ul>\n<li>Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.<br>\n(doGet(), doPost(), doPut(), doDel())</li>\n</ul>\n</li>\n<li>destroy()\n<ul>\n<li>WAS shutdown 시 호출 된다.</li>\n<li>주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다</li>\n<li>자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h1>Servlet 설정하기</h1>\n<h2>Servlet class 생성하기</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo3.servlet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@WebServlet</span>(name=<span class=\"string\">\"demoServlet\"</span>, url-pattern=<span class=\"string\">\"/servlet/demo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"doGet() 실행실행실행!!!\"</span>);</span><br><span class=\"line\">        Thread thread = Thread.currentThread();</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Thread ID : \"</span> + thread.getId());</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doGet(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doPost(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Servlet destroy()\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Servlet init()\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.<br>\n(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)</p>\n<p>기본적으로 Servlet 클래스 생성은 <code>HttpServlet</code> 클래스를 상속 받아 생성한다.<br>\nHttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.</p>\n<h2>web.xml 기반 설정</h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.example.springstudy.demo3.servlet.DemoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/servlet/demo<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>web.xml에 servlet 클래스를 선언하고 <servlet-mapping> 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.</servlet-mapping></p>\n<h2>Java Config 기반 설정</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo3.servlet.DemoServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServletConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServletRegistrationBean <span class=\"title\">demoServletRegistrationBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ServletRegistrationBean demoServletRegistrationBean = <span class=\"keyword\">new</span> ServletRegistrationBean();</span><br><span class=\"line\">        demoServletRegistrationBean.setServlet(<span class=\"keyword\">new</span> DemoServlet());</span><br><span class=\"line\">        demoServletRegistrationBean.addUrlMappings(<span class=\"string\">\"/servlet/demo\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> demoServletRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.<br>\nServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.</p>\n<br>\n<h1>JSP vs Servlet</h1>\n<p><strong>JSP와 Servlet의 차이점</strong></p>\n<ul>\n<li>JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태</li>\n<li>Servlet은 html 태그가 out.println(&quot;<html>&quot;) 형태로 들어간 형태</html></li>\n</ul>\n<h2>JSP -&gt; Servlet 변환 과정</h2>\n<p><img src=\"./jspToServlet.jpeg\" alt=\"jspToServlet\"></p>\n<p>Servlet의 최종 형태는 out.println(&quot;<html>&quot;) 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.</html></p>\n<h1>참조</h1>\n<p><a href=\"http://mangkyu.tistory.com/14\" target=\"_blank\" rel=\"noopener\">http://mangkyu.tistory.com/14</a><br>\n<a href=\"http://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" target=\"_blank\" rel=\"noopener\">http://breath91.tistory.com/entry/Servlet-이란-무엇인가</a><br>\n<a href=\"http://til0804.tistory.com/25\" target=\"_blank\" rel=\"noopener\">http://til0804.tistory.com/25</a></p>\n"},{"title":"Java Exception","catalog":true,"date":"2018-08-29T15:07:03.000Z","subtitle":"Java의 기본 예외처리","header-img":null,"Categories":["Java"],"typora-root-url":"./2018-08-29-java-exception","typora-copy-images-to":"./2018-08-29-java-exception","_content":"\n\n# 들어가며\n\nJava/Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.\n예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.\n이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.\n\n\n\n# 에러(Error)와 예외(Exception)\n\n![Exception-Class](./Exception-Class.png)\n\nJava에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.\nException은 또 2가지 종류로 구분 할 수 있다.\n\n* Error \n  * 주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.\n  * 주로 `복구 불가능한 상황`에 대해 사용한다.\n  * 주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.\n  * 관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.\n    (어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)\n* Checked Exception \n  * 점검지정 예외\n  * Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.\n  * 예외처리를 하지 않을 시, `컴파일 오류가 발생`\n  * 주로 `복구 가능한 상황`에 Checked Exception을 사용한다.\n  * Custom Checked Exception을 만들 경우 `Exception` 클래스를 상속하여 만든다.\n* Unchecked Exception\n  * 무점검 예외\n  * 프로그래밍 오류를 표현하는 경우 사용\n  * 개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.\n  * 주로 `복구 불가능한 상황`에 대해 사용한다.\n  * Custom Unchecked Exception을 만들 경우 `RuntimeException` 클래스를 상속하여 만든다\n\n\n\n## 추가적으로..\n\n개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.\n아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.\nChecked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.\n지원자가 했던 \"Checked Exception 절대 쓰지 말자!\" \"Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!\"라는 의견도 어느정도는 맞는 소리이다.\n새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의....로 간다고 하면 밑에서 부터 계속 throw..throw.. 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다. \n다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.\n\n\n\n# Java에서의 기본적인 예외처리\n\n## try-catch-finally\n\ntry-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.\n프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.\n\n~~~java\ntry {\n    //핵심 로직 수행\n} catch(Exception e) {\n    //예외 발생 시, 예외에 대한 처리\n} finally {\n   //try block, catch block 실행 후 반드시 실행하는 로직\n   //주로 자원에 대한 해제 로직이 추가된다. \n}\n~~~\n\n\n\n## try-catch-resources\n\nJava 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.\n\n~~~java\ntry (InputStream is = new FileInputStream(file)) { \n     //try block이 종료 되면 InputStream에 대한 close() 메소드를 실행\n     //핵심 로직 수행\n} catch (Exception e) {\n    //예외 발생 시, 예외에 대한 처리\n}\n~~~\n\n\n\n## Multi catch\n\nJava 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.\n\n~~~java\ntry (InputStream is = new FileInputStream(file)) { \n     //try block이 종료 되면 InputStream에 대한 close() 메소드를 실행\n     //핵심 로직 수행\n} catch (NullPointerException | ArrayIndexBoundException e) {\n    //예외 발생 시, 예외에 대한 처리\n}\n~~~\n\n\n\n# Exception Handling\n\nChecked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.\n\n* Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기\n* try-catch구문을 통한 예외처리를 하도록 유도\n\n보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.\n하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.\n\n\n\n# Anti Pattern\n\n1. Exception을 무시 하지 말 것\n2. exception.printStackTrace()는 쓰는게 아니다.\n3. 반복문 내에서는 Checked Exception에 대한 처리는 지양하자\n\n\n\n## Exception을 무시 하지 말 것 \n\n간혹 코드를 보다 보면..\n\n~~~java\ntry {\n    //열심히 작성\n    veryHardDo();\n} catch (Exception e) {\n    //아무것도 안해요~\n}\n~~~\n\n이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고.. 막상 catch구문에 작성할 코드는 없어보이고... 할 때 저런 코드들이 나오게 된다.\n이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고.. 왜 에러나는지 모르는 코드가 되어버린다. \n되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자.. (로그라도 남겨줘 ㅜㅜ)\n\n\n\n## exception.printStackTrace()는 쓰는게 아니다.\n\nexception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)\n하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.\n\n\n\n## 반복문 내에서는 Checked Exception에 대한 처리는 지양하자\n\n~~~java\nfor (String item : items) {\n    try {\n        insert(item);\n    }catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n~~~\n\n반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.\n이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.\n\n\n\n# 참조\n\nEffective Java 2nd Edition (Joshua Bloch)\n가장 빨리 만나는 자바8 (카이 호스트만)","source":"_posts/2018-08-29-java-exception.md","raw":"---\ntitle: Java Exception\ncatalog: true\ndate: 2018-08-30 00:07:03\nsubtitle: Java의 기본 예외처리\nheader-img:\nCategories:\n - Java\ntags: \n - Java\ntypora-root-url: ./2018-08-29-java-exception\ntypora-copy-images-to: ./2018-08-29-java-exception\n---\n\n\n# 들어가며\n\nJava/Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.\n예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.\n이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.\n\n\n\n# 에러(Error)와 예외(Exception)\n\n![Exception-Class](./Exception-Class.png)\n\nJava에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.\nException은 또 2가지 종류로 구분 할 수 있다.\n\n* Error \n  * 주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.\n  * 주로 `복구 불가능한 상황`에 대해 사용한다.\n  * 주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.\n  * 관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.\n    (어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)\n* Checked Exception \n  * 점검지정 예외\n  * Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.\n  * 예외처리를 하지 않을 시, `컴파일 오류가 발생`\n  * 주로 `복구 가능한 상황`에 Checked Exception을 사용한다.\n  * Custom Checked Exception을 만들 경우 `Exception` 클래스를 상속하여 만든다.\n* Unchecked Exception\n  * 무점검 예외\n  * 프로그래밍 오류를 표현하는 경우 사용\n  * 개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.\n  * 주로 `복구 불가능한 상황`에 대해 사용한다.\n  * Custom Unchecked Exception을 만들 경우 `RuntimeException` 클래스를 상속하여 만든다\n\n\n\n## 추가적으로..\n\n개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.\n아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.\nChecked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.\n지원자가 했던 \"Checked Exception 절대 쓰지 말자!\" \"Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!\"라는 의견도 어느정도는 맞는 소리이다.\n새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의....로 간다고 하면 밑에서 부터 계속 throw..throw.. 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다. \n다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.\n\n\n\n# Java에서의 기본적인 예외처리\n\n## try-catch-finally\n\ntry-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.\n프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.\n\n~~~java\ntry {\n    //핵심 로직 수행\n} catch(Exception e) {\n    //예외 발생 시, 예외에 대한 처리\n} finally {\n   //try block, catch block 실행 후 반드시 실행하는 로직\n   //주로 자원에 대한 해제 로직이 추가된다. \n}\n~~~\n\n\n\n## try-catch-resources\n\nJava 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.\n\n~~~java\ntry (InputStream is = new FileInputStream(file)) { \n     //try block이 종료 되면 InputStream에 대한 close() 메소드를 실행\n     //핵심 로직 수행\n} catch (Exception e) {\n    //예외 발생 시, 예외에 대한 처리\n}\n~~~\n\n\n\n## Multi catch\n\nJava 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.\n\n~~~java\ntry (InputStream is = new FileInputStream(file)) { \n     //try block이 종료 되면 InputStream에 대한 close() 메소드를 실행\n     //핵심 로직 수행\n} catch (NullPointerException | ArrayIndexBoundException e) {\n    //예외 발생 시, 예외에 대한 처리\n}\n~~~\n\n\n\n# Exception Handling\n\nChecked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.\n\n* Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기\n* try-catch구문을 통한 예외처리를 하도록 유도\n\n보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.\n하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.\n\n\n\n# Anti Pattern\n\n1. Exception을 무시 하지 말 것\n2. exception.printStackTrace()는 쓰는게 아니다.\n3. 반복문 내에서는 Checked Exception에 대한 처리는 지양하자\n\n\n\n## Exception을 무시 하지 말 것 \n\n간혹 코드를 보다 보면..\n\n~~~java\ntry {\n    //열심히 작성\n    veryHardDo();\n} catch (Exception e) {\n    //아무것도 안해요~\n}\n~~~\n\n이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고.. 막상 catch구문에 작성할 코드는 없어보이고... 할 때 저런 코드들이 나오게 된다.\n이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고.. 왜 에러나는지 모르는 코드가 되어버린다. \n되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자.. (로그라도 남겨줘 ㅜㅜ)\n\n\n\n## exception.printStackTrace()는 쓰는게 아니다.\n\nexception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)\n하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.\n\n\n\n## 반복문 내에서는 Checked Exception에 대한 처리는 지양하자\n\n~~~java\nfor (String item : items) {\n    try {\n        insert(item);\n    }catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n~~~\n\n반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.\n이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.\n\n\n\n# 참조\n\nEffective Java 2nd Edition (Joshua Bloch)\n가장 빨리 만나는 자바8 (카이 호스트만)","slug":"2018-08-29-java-exception","published":1,"updated":"2018-08-31T15:30:56.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjniq3koq000ju0yaapesoq3x","content":"<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>Java/Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.<br>\n예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.<br>\n이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.</p>\n<h1><span id=\"에러error와-예외exception\">에러(Error)와 예외(Exception)</span></h1>\n<p><img src=\"./Exception-Class.png\" alt=\"Exception-Class\"></p>\n<p>Java에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.<br>\nException은 또 2가지 종류로 구분 할 수 있다.</p>\n<ul>\n<li>Error\n<ul>\n<li>주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.</li>\n<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>\n<li>주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.</li>\n<li>관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.<br>\n(어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)</li>\n</ul>\n</li>\n<li>Checked Exception\n<ul>\n<li>점검지정 예외</li>\n<li>Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.</li>\n<li>예외처리를 하지 않을 시, <code>컴파일 오류가 발생</code></li>\n<li>주로 <code>복구 가능한 상황</code>에 Checked Exception을 사용한다.</li>\n<li>Custom Checked Exception을 만들 경우 <code>Exception</code> 클래스를 상속하여 만든다.</li>\n</ul>\n</li>\n<li>Unchecked Exception\n<ul>\n<li>무점검 예외</li>\n<li>프로그래밍 오류를 표현하는 경우 사용</li>\n<li>개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.</li>\n<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>\n<li>Custom Unchecked Exception을 만들 경우 <code>RuntimeException</code> 클래스를 상속하여 만든다</li>\n</ul>\n</li>\n</ul>\n<h2><span id=\"추가적으로\">추가적으로…</span></h2>\n<p>개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.<br>\n아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.<br>\nChecked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.<br>\n지원자가 했던 “Checked Exception 절대 쓰지 말자!” &quot;Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!&quot;라는 의견도 어느정도는 맞는 소리이다.<br>\n새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의…로 간다고 하면 밑에서 부터 계속 throw…throw… 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다.<br>\n다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.</p>\n<h1><span id=\"java에서의-기본적인-예외처리\">Java에서의 기본적인 예외처리</span></h1>\n<h2><span id=\"try-catch-finally\">try-catch-finally</span></h2>\n<p>try-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.<br>\n프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//try block, catch block 실행 후 반드시 실행하는 로직</span></span><br><span class=\"line\">   <span class=\"comment\">//주로 자원에 대한 해제 로직이 추가된다. </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"try-catch-resources\">try-catch-resources</span></h2>\n<p>Java 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream is = <span class=\"keyword\">new</span> FileInputStream(file)) &#123; </span><br><span class=\"line\">     <span class=\"comment\">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class=\"line\">     <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"multi-catch\">Multi catch</span></h2>\n<p>Java 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream is = <span class=\"keyword\">new</span> FileInputStream(file)) &#123; </span><br><span class=\"line\">     <span class=\"comment\">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class=\"line\">     <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (NullPointerException | ArrayIndexBoundException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"exception-handling\">Exception Handling</span></h1>\n<p>Checked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.</p>\n<ul>\n<li>Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기</li>\n<li>try-catch구문을 통한 예외처리를 하도록 유도</li>\n</ul>\n<p>보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.<br>\n하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.</p>\n<h1><span id=\"anti-pattern\">Anti Pattern</span></h1>\n<ol>\n<li>Exception을 무시 하지 말 것</li>\n<li>exception.printStackTrace()는 쓰는게 아니다.</li>\n<li>반복문 내에서는 Checked Exception에 대한 처리는 지양하자</li>\n</ol>\n<h2><span id=\"exception을-무시-하지-말-것\">Exception을 무시 하지 말 것</span></h2>\n<p>간혹 코드를 보다 보면…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//열심히 작성</span></span><br><span class=\"line\">    veryHardDo();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//아무것도 안해요~</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고… 막상 catch구문에 작성할 코드는 없어보이고… 할 때 저런 코드들이 나오게 된다.<br>\n이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고… 왜 에러나는지 모르는 코드가 되어버린다.<br>\n되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자… (로그라도 남겨줘 ㅜㅜ)</p>\n<h2><span id=\"exceptionprintstacktrace는-쓰는게-아니다\">exception.printStackTrace()는 쓰는게 아니다.</span></h2>\n<p>exception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)<br>\n하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.</p>\n<h2><span id=\"반복문-내에서는-checked-exception에-대한-처리는-지양하자\">반복문 내에서는 Checked Exception에 대한 처리는 지양하자</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (String item : items) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        insert(item);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.<br>\n이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.</p>\n<h1><span id=\"참조\">참조</span></h1>\n<p>Effective Java 2nd Edition (Joshua Bloch)<br>\n가장 빨리 만나는 자바8 (카이 호스트만)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>Java/Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.<br>\n예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.<br>\n이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.</p>\n<h1>에러(Error)와 예외(Exception)</h1>\n<p><img src=\"./Exception-Class.png\" alt=\"Exception-Class\"></p>\n<p>Java에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.<br>\nException은 또 2가지 종류로 구분 할 수 있다.</p>\n<ul>\n<li>Error\n<ul>\n<li>주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.</li>\n<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>\n<li>주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.</li>\n<li>관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.<br>\n(어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)</li>\n</ul>\n</li>\n<li>Checked Exception\n<ul>\n<li>점검지정 예외</li>\n<li>Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.</li>\n<li>예외처리를 하지 않을 시, <code>컴파일 오류가 발생</code></li>\n<li>주로 <code>복구 가능한 상황</code>에 Checked Exception을 사용한다.</li>\n<li>Custom Checked Exception을 만들 경우 <code>Exception</code> 클래스를 상속하여 만든다.</li>\n</ul>\n</li>\n<li>Unchecked Exception\n<ul>\n<li>무점검 예외</li>\n<li>프로그래밍 오류를 표현하는 경우 사용</li>\n<li>개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.</li>\n<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>\n<li>Custom Unchecked Exception을 만들 경우 <code>RuntimeException</code> 클래스를 상속하여 만든다</li>\n</ul>\n</li>\n</ul>\n<h2>추가적으로…</h2>\n<p>개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.<br>\n아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.<br>\nChecked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.<br>\n지원자가 했던 “Checked Exception 절대 쓰지 말자!” &quot;Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!&quot;라는 의견도 어느정도는 맞는 소리이다.<br>\n새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의…로 간다고 하면 밑에서 부터 계속 throw…throw… 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다.<br>\n다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.</p>\n<h1>Java에서의 기본적인 예외처리</h1>\n<h2>try-catch-finally</h2>\n<p>try-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.<br>\n프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//try block, catch block 실행 후 반드시 실행하는 로직</span></span><br><span class=\"line\">   <span class=\"comment\">//주로 자원에 대한 해제 로직이 추가된다. </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>try-catch-resources</h2>\n<p>Java 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream is = <span class=\"keyword\">new</span> FileInputStream(file)) &#123; </span><br><span class=\"line\">     <span class=\"comment\">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class=\"line\">     <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Multi catch</h2>\n<p>Java 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream is = <span class=\"keyword\">new</span> FileInputStream(file)) &#123; </span><br><span class=\"line\">     <span class=\"comment\">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class=\"line\">     <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (NullPointerException | ArrayIndexBoundException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>Exception Handling</h1>\n<p>Checked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.</p>\n<ul>\n<li>Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기</li>\n<li>try-catch구문을 통한 예외처리를 하도록 유도</li>\n</ul>\n<p>보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.<br>\n하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.</p>\n<h1>Anti Pattern</h1>\n<ol>\n<li>Exception을 무시 하지 말 것</li>\n<li>exception.printStackTrace()는 쓰는게 아니다.</li>\n<li>반복문 내에서는 Checked Exception에 대한 처리는 지양하자</li>\n</ol>\n<h2>Exception을 무시 하지 말 것</h2>\n<p>간혹 코드를 보다 보면…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//열심히 작성</span></span><br><span class=\"line\">    veryHardDo();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//아무것도 안해요~</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고… 막상 catch구문에 작성할 코드는 없어보이고… 할 때 저런 코드들이 나오게 된다.<br>\n이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고… 왜 에러나는지 모르는 코드가 되어버린다.<br>\n되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자… (로그라도 남겨줘 ㅜㅜ)</p>\n<h2>exception.printStackTrace()는 쓰는게 아니다.</h2>\n<p>exception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)<br>\n하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.</p>\n<h2>반복문 내에서는 Checked Exception에 대한 처리는 지양하자</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (String item : items) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        insert(item);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.<br>\n이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.</p>\n<h1>참조</h1>\n<p>Effective Java 2nd Edition (Joshua Bloch)<br>\n가장 빨리 만나는 자바8 (카이 호스트만)</p>\n"},{"title":"Spring IoC & DI(1) - IoC 등장배경(과정)","subtitle":"IoC/DI의 발전과정","header-img":null,"catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-09-12-spring-ioc","typora-copy-images-to":"./2018-09-12-spring-ioc","date":"2018-09-21T14:33:21.000Z","_content":"\n\n\n# IoC 등장배경\n\nIoC의 등장배경을 알기 위해서는 EJB나 Spring과 같은 프레임워크를 사용하기 이전 시대의 개발 방식에 대해 얘기를 해야한다.\n온고지신(?)이라 하였던가.. IoC를 이해하기 위해 옛날이야기를 해보도록 하겠다.\n\n태초에 Java로 만든 프로그램은 main()이라는 메소드에서 시작이 되었다.\nmain() 메소드 내에서 필요한 클래스를 개발자가 직접 코드내에서 생성하여 사용하였다. \n어떠한 프로그램을 만들던지 간에 프로그램에는 `모델(Model)`이라는 개념이 생겨나게 된다.\n이렇게 만들어진 클래스 간에서는 `관계(Relation)`과 `의존성(Dependency)`가 생기게 된다. \n\n`의존성이란?` A클래스에서 B클래스의 기능을 사용할 때 클래스A는 클래스B에 의존적이다 라고 하며\nA --> B 라고 표현한다 (UML에서는 클래스 간의 Dependency를 점선으로 표현한다.)\n즉, B클래스의 기능이 변하게 되면 A클래스에도 영향이 생긴다는 말로 직역할 수 있다.\n\n이해를 돕기위해 급식을 받는 학생에 대한 예제를 들어보겠다.\n(이 학교는 아침/점심/저녁을 다 주는 좋은 학교이다)\n\n\n\n## 클래스 -> 클래스 호출 관계\n\n![image-20180921143924788](./image-20180921143924788.png)\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eatBreakfast();\n        restaurant.eatLunch();\n        restaurant.eatDinner();\n\t}\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eatBreakfast() {\n        Breakfast breakfast = new Breakfast();\n        System.out.println(breakfast.getInfo() + \"을 먹었습니다.\");\n    }\n    \n    public void eatLunch() {\n        Lunch lunch = new Lunch();\n        System.out.println(lunch.getInfo() + \"을 먹었습니다.\");\n    }\n    \n    public void eatDinner() {\n        Dinner dinner = new Dinner();\n        System.out.println(dinner.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\nStudent 클래스는 밥을 먹기위해 Restaurant클래스를 new로 생성하였다.\nRestaurant클래스 내에서는 아침/점심/저녁을 먹을 수 있도록 각각 Breakfast, Lunch, Dinner클래스를 new로 생성하였다.\n위의 의존성에 대해 위 예제를 풀어보면 Student는 Restaurant에 대해 의존적이다. (Student ---> Restaurant)\nStudent클래스에서 Restaurant클래스를 생성하여 밥을 먹기 때문이다. 만약에 Restaurant 클래스에서 밥을 못먹게 하면\nStudent클래스는 정상적으로 밥을 먹는 기능을 수행할 수 없다.\nRestaurant클래스는 Breakfast/Lunch/Dinner에 대해 의존적이다.\n각각의 메소드에서 Breakfast/Lunch/Dinner클래스를 생성하여 밥을 먹는 행위를 하도록 하고있다.\n\n가만히 보게 되면 의존성에 대한 공통점을 발견할 수 있다.\n그것은 바로 `new`이다. `클래스 내에서의 new는 곧 의존성을 의미`하게 된다. new로 생성한 클래스가 문제가 생기면 사용을 하는 클래스의 기능에도 문제가 생기기 떄문이다.\n\n따라서 **프로그래밍의 의존성은 new이다** 로 간단하게 정의를 내릴 수 있겠다.\n\n\n\n## 클래스 -> 인터페이스(interface) -> 클래스 구조\n\n클래스 내에서 클래스를 생성하여 호출 하는 경우에는 변경에 많은 비용이 발생하게 된다.\n만약에 학교에서 야식까지 먹어가며 밤을 새는 경우에는 야식이라는 의존성을 또 추가하게 된다.\n뿐만 아니라 Breakfast/Lunch/Dinner 클래스에 변경이 생기는 경우에도 Restaurant 클래스는 영향을 받게 된다.\n\n이와 같은 문제를 쪼금 더 편하게 해결 할 수 있게 Java에서는 interface라는게 있다.\n(개인적으로 Service나 Repository 같은 클래스들을 생성 할 때 웬만하면 interface를 선언하는 편이다.)\n\n차후에 Mock객체 생성하기도 좋고, 요구사항이 변경 되었을 때 유연하게 대응 할 수 있어 개인적으로는 Interface를 자주 사용하는 편이다.\n\nBreakfast/Lunch/Dinner클래스를 자세히 보면… getInfo() 메소드가 공통적으로 쓰이고 있다.\n(getInfo메소드는 식단에 대한 정보이다.)\n따라서 하나의 interface로 Breakfast/Lunch/Dinner클래스를 추상화 할 수 있다.\n그렇게 되면 eat이라는 메소드 하나만으로도 아침~저녁을 먹을 수 있는 기능을 구현할 수 있다.\n위에서 말로 한 얘기를 코드로 풀어보면..\n\n![image-20180921145310488](./image-20180921145310488.png)\n\n\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eat(new Breakfast());\n        restaurant.eat(new Lunch());\n        restaurant.eat(new Dinner());\n\t}\n}\n~~~\n\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\n위의 클래스 -> 클래스 간의 Dependency 구조보다는 interface를 사용하므로써 많이 결합도가 완화된 모습이다.\n이전에는 Restaurant 클래스가 Break/Lunch/Dinner에 대해 모두 Dependency를 가지고 가는 구조여서 결합도가 강한 형태였는데, interface를 사용하여 결합도를 많이 약화 시켰다.\n\n자세히 보면 `Student클래스에서 Break/Lunch/Dinner를 생성하여 Restaurant에 주입`해 주었다.\n이러한 모습이 향후 DI의 개념과 비슷한 개념으로 발전하게 된다.\nRestaurant입장에서는 개발자가 생성한 객체가 아닌 `외부로 부터 주입받은 형태`로 Break/Lunch/Dinner에 대해 사용을 하기 때문이다.\n이 부분을 잘 이해하면 차후 IoC와 DI를 이해하는데 크게 도움이 된다.\n\n\n\n## 클래스 -> 팩토리(factory) 패턴\n\n디자인 패턴 중에는 팩토리(Factory) 패턴이라는 구현 방식이 있다.\n팩토리 패턴에 대해 간단하게 설명하자면, 객체의 상태(State) 또는 구분자(Type)을 통해 필요한 객체를 Return 해주는 패턴이다. 위에서 설명한 클래스 -> 인터페이스 방식을 차용하여 한 단계 더 Wrapping한 개념이라고 생각하면 편하다.\n팩토리 패턴을 이용하면 아예 `개발자에게 객체 생성에 대한 권한을 주지 않겠다! `를 구현 할 수 있게 된다.\n**개발자가 객체 생성을 직접 하지 않고도 시스템에 요청하여 원하는 객체를 얻어낼 수 있다.** <-- 이 내용은 DL(Dependency Lookup)과 비슷한 개념으로 통할 수 있을 것 같다.\n\n팩토리 패턴으로 만든 코드를 만들게 된다면, 아래와 같이 만들 수 있을 것이다.\n\n![image-20180921153027741](./image-20180921153027741.png)\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eat(EatFactory.get(Meal.BREAKFAST));\n        restaurant.eat(EatFactory.get(Meal.LUNCH));\n        restaurant.eat(EatFactory.get(Meal.DINNER));\n\t}\n}\n~~~\n~~~java\npublic enum Meal {\n   BREAKFAST, LUNCH, DINNER;\n}\n~~~\n~~~java\npublic class EatFactory() {\n    public static Eatable get(Meal meal) {\n        switch(meal) {\n            case BREAKFAST : return new Breakfast();\n            case LUNCH : return new Lunch();\n            case DINNER : return new Dinner();\n            default: throw new IllegalArgumentException(\"Not using Meal Type\");\n        }\n    }\n}\n~~~\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\n\n\n이제 개발자가 개발하는 코드에서 Breakfast/Lunch/Dinner에 대한 Dependency는 완전히 제거 되었다.\n야식이라는 식사 메뉴가 추가되어도 Meal enum에 야식 항목을 추가하고, EatFactory에 야식에 대한 case만 추가 해 주면 \nStudent 클래스는 유연하게 추가된 기능에 대해 대처가 가능하다.\n\n\n\n## IoC 패턴\n\nIoC패턴을 알기 전에 IoC에 대해 간단히 설명하자면.. \n기능을 담당하는 POJO class를 프로그램 시작 시, IoC 컨테이너에 Bean이라는 이름으로 객체를 생성해 둔다.\n이렇게 싱글톤으로 생성된 객체들을 필요한 시점에 IoC 컨테이너에서 의존성을 가지는 객체에 직접 주입을 해주는 패턴을 IoC패턴이라 한다.\n\n쉽게 말하면 객체의 멤버에 대한 상태가 없고(stateless) 기능의 역할을 담은 클래스들을 1개씩 IoC컨테이너라는 상자에 담아두고, 의존성 객체가 필요한 경우 IoC컨테이너에서 필요한 객체를 주입해준다. 라고 생각하면 편할 것 같다.\n객체에 대해 new 생성자를 통해 객체를 생성할 필요가 없으니, 메모리적인 낭비가 없다는 장점이 있을 뿐 더러 개발자에게 객체 관리에 대한 미시적인 역할을 맡기지 않아도 되는 장점이 있다. 자세한 내용은 다음 장에 기술하도록 하겠다.\n\n위의 내용을 Spring을 사용한 개발이라고 한다면... 아래와 같이 코드를 짤 수 있겠다.\n\n~~~java\n@SpringBootApplication(scanBasePackages = \"com.example.ioc\")\npublic class Student {\n    \n    @Autowired\n    private Restaurant restaurant;\n    @Autowired\n    private EatFactory eatFactory;\n    \n    public static void main(String[] args) {\n        \n\t\tSpringApplication.run(SpringStudyApplication.class, args);\n        //식사 시작\n        restaurant.eat(eatFactory.get(Meal.BREAKFAST));\n        restaurant.eat(eatFactory.get(Meal.LUNCH));\n        restaurant.eat(eatFactory.get(Meal.DINNER));\n\t}\n}\n~~~\n~~~java\npublic enum Meal {\n   BREAKFAST, LUNCH, DINNER;\n}\n~~~\n~~~java\n@Component\npublic class EatFactory() {\n\t\n    @Autowired @Qualifier(\"breakfast\")\n    private Eatable breakfast;\n    @Autowired @Qualifier(\"lunch\")\n    private Eatable lunch;\n    @Autowired @Qualifier(\"dinner\")\n    private Eatable dinner;\n    \n    public Eatable get(Meal meal) {\n        switch(meal) {\n            case BREAKFAST : breakfast;\n            case LUNCH : lunch;\n            case DINNER : dinner;\n            default: throw new IllegalArgumentException(\"Not using Meal Type\");\n        }\n    }\n}\n~~~\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\n@Service\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\nSpring에서는 component-scan이라는 기능을 통해 @Component 어노테이션이 붙은 클래스는 IoC 컨테이너에 Bean으로써 자동 등록 해준다. 이러한 Bean은 @Autowired / @Inject 와 같은 어노테이션을 통해 클래스에 주입을 해줄 수 있다.\n이렇게 되면 개발자가 new를 통해 의존성을 강제화 하지 않고 프레임워크가 이 역할을 대신 수행해 준다.\n\n개발자가 객체 생성과 의존성 주입에 대한 역할을 대신 해준다 \nInversion of Control (객체 관리과 의존성 관리를 시스템에서 해준다 : 제어의 역전) 이라고 불리게 되었다.\n\n\n\n# 참조\n\nhttp://www.javajigi.net/pages/viewpage.action?pageId=3664&focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\n토비의 스프링 VOL.2 Spring IoC","source":"_posts/2018-09-12-spring-ioc.md","raw":"---\ntitle: Spring IoC & DI(1) - IoC 등장배경(과정)\nsubtitle: IoC/DI의 발전과정\nheader-img:\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\ntypora-root-url: ./2018-09-12-spring-ioc\ntypora-copy-images-to: ./2018-09-12-spring-ioc\ndate: 2018-09-21 23:33:21\n---\n\n\n\n# IoC 등장배경\n\nIoC의 등장배경을 알기 위해서는 EJB나 Spring과 같은 프레임워크를 사용하기 이전 시대의 개발 방식에 대해 얘기를 해야한다.\n온고지신(?)이라 하였던가.. IoC를 이해하기 위해 옛날이야기를 해보도록 하겠다.\n\n태초에 Java로 만든 프로그램은 main()이라는 메소드에서 시작이 되었다.\nmain() 메소드 내에서 필요한 클래스를 개발자가 직접 코드내에서 생성하여 사용하였다. \n어떠한 프로그램을 만들던지 간에 프로그램에는 `모델(Model)`이라는 개념이 생겨나게 된다.\n이렇게 만들어진 클래스 간에서는 `관계(Relation)`과 `의존성(Dependency)`가 생기게 된다. \n\n`의존성이란?` A클래스에서 B클래스의 기능을 사용할 때 클래스A는 클래스B에 의존적이다 라고 하며\nA --> B 라고 표현한다 (UML에서는 클래스 간의 Dependency를 점선으로 표현한다.)\n즉, B클래스의 기능이 변하게 되면 A클래스에도 영향이 생긴다는 말로 직역할 수 있다.\n\n이해를 돕기위해 급식을 받는 학생에 대한 예제를 들어보겠다.\n(이 학교는 아침/점심/저녁을 다 주는 좋은 학교이다)\n\n\n\n## 클래스 -> 클래스 호출 관계\n\n![image-20180921143924788](./image-20180921143924788.png)\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eatBreakfast();\n        restaurant.eatLunch();\n        restaurant.eatDinner();\n\t}\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eatBreakfast() {\n        Breakfast breakfast = new Breakfast();\n        System.out.println(breakfast.getInfo() + \"을 먹었습니다.\");\n    }\n    \n    public void eatLunch() {\n        Lunch lunch = new Lunch();\n        System.out.println(lunch.getInfo() + \"을 먹었습니다.\");\n    }\n    \n    public void eatDinner() {\n        Dinner dinner = new Dinner();\n        System.out.println(dinner.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\nStudent 클래스는 밥을 먹기위해 Restaurant클래스를 new로 생성하였다.\nRestaurant클래스 내에서는 아침/점심/저녁을 먹을 수 있도록 각각 Breakfast, Lunch, Dinner클래스를 new로 생성하였다.\n위의 의존성에 대해 위 예제를 풀어보면 Student는 Restaurant에 대해 의존적이다. (Student ---> Restaurant)\nStudent클래스에서 Restaurant클래스를 생성하여 밥을 먹기 때문이다. 만약에 Restaurant 클래스에서 밥을 못먹게 하면\nStudent클래스는 정상적으로 밥을 먹는 기능을 수행할 수 없다.\nRestaurant클래스는 Breakfast/Lunch/Dinner에 대해 의존적이다.\n각각의 메소드에서 Breakfast/Lunch/Dinner클래스를 생성하여 밥을 먹는 행위를 하도록 하고있다.\n\n가만히 보게 되면 의존성에 대한 공통점을 발견할 수 있다.\n그것은 바로 `new`이다. `클래스 내에서의 new는 곧 의존성을 의미`하게 된다. new로 생성한 클래스가 문제가 생기면 사용을 하는 클래스의 기능에도 문제가 생기기 떄문이다.\n\n따라서 **프로그래밍의 의존성은 new이다** 로 간단하게 정의를 내릴 수 있겠다.\n\n\n\n## 클래스 -> 인터페이스(interface) -> 클래스 구조\n\n클래스 내에서 클래스를 생성하여 호출 하는 경우에는 변경에 많은 비용이 발생하게 된다.\n만약에 학교에서 야식까지 먹어가며 밤을 새는 경우에는 야식이라는 의존성을 또 추가하게 된다.\n뿐만 아니라 Breakfast/Lunch/Dinner 클래스에 변경이 생기는 경우에도 Restaurant 클래스는 영향을 받게 된다.\n\n이와 같은 문제를 쪼금 더 편하게 해결 할 수 있게 Java에서는 interface라는게 있다.\n(개인적으로 Service나 Repository 같은 클래스들을 생성 할 때 웬만하면 interface를 선언하는 편이다.)\n\n차후에 Mock객체 생성하기도 좋고, 요구사항이 변경 되었을 때 유연하게 대응 할 수 있어 개인적으로는 Interface를 자주 사용하는 편이다.\n\nBreakfast/Lunch/Dinner클래스를 자세히 보면… getInfo() 메소드가 공통적으로 쓰이고 있다.\n(getInfo메소드는 식단에 대한 정보이다.)\n따라서 하나의 interface로 Breakfast/Lunch/Dinner클래스를 추상화 할 수 있다.\n그렇게 되면 eat이라는 메소드 하나만으로도 아침~저녁을 먹을 수 있는 기능을 구현할 수 있다.\n위에서 말로 한 얘기를 코드로 풀어보면..\n\n![image-20180921145310488](./image-20180921145310488.png)\n\n\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eat(new Breakfast());\n        restaurant.eat(new Lunch());\n        restaurant.eat(new Dinner());\n\t}\n}\n~~~\n\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\n위의 클래스 -> 클래스 간의 Dependency 구조보다는 interface를 사용하므로써 많이 결합도가 완화된 모습이다.\n이전에는 Restaurant 클래스가 Break/Lunch/Dinner에 대해 모두 Dependency를 가지고 가는 구조여서 결합도가 강한 형태였는데, interface를 사용하여 결합도를 많이 약화 시켰다.\n\n자세히 보면 `Student클래스에서 Break/Lunch/Dinner를 생성하여 Restaurant에 주입`해 주었다.\n이러한 모습이 향후 DI의 개념과 비슷한 개념으로 발전하게 된다.\nRestaurant입장에서는 개발자가 생성한 객체가 아닌 `외부로 부터 주입받은 형태`로 Break/Lunch/Dinner에 대해 사용을 하기 때문이다.\n이 부분을 잘 이해하면 차후 IoC와 DI를 이해하는데 크게 도움이 된다.\n\n\n\n## 클래스 -> 팩토리(factory) 패턴\n\n디자인 패턴 중에는 팩토리(Factory) 패턴이라는 구현 방식이 있다.\n팩토리 패턴에 대해 간단하게 설명하자면, 객체의 상태(State) 또는 구분자(Type)을 통해 필요한 객체를 Return 해주는 패턴이다. 위에서 설명한 클래스 -> 인터페이스 방식을 차용하여 한 단계 더 Wrapping한 개념이라고 생각하면 편하다.\n팩토리 패턴을 이용하면 아예 `개발자에게 객체 생성에 대한 권한을 주지 않겠다! `를 구현 할 수 있게 된다.\n**개발자가 객체 생성을 직접 하지 않고도 시스템에 요청하여 원하는 객체를 얻어낼 수 있다.** <-- 이 내용은 DL(Dependency Lookup)과 비슷한 개념으로 통할 수 있을 것 같다.\n\n팩토리 패턴으로 만든 코드를 만들게 된다면, 아래와 같이 만들 수 있을 것이다.\n\n![image-20180921153027741](./image-20180921153027741.png)\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eat(EatFactory.get(Meal.BREAKFAST));\n        restaurant.eat(EatFactory.get(Meal.LUNCH));\n        restaurant.eat(EatFactory.get(Meal.DINNER));\n\t}\n}\n~~~\n~~~java\npublic enum Meal {\n   BREAKFAST, LUNCH, DINNER;\n}\n~~~\n~~~java\npublic class EatFactory() {\n    public static Eatable get(Meal meal) {\n        switch(meal) {\n            case BREAKFAST : return new Breakfast();\n            case LUNCH : return new Lunch();\n            case DINNER : return new Dinner();\n            default: throw new IllegalArgumentException(\"Not using Meal Type\");\n        }\n    }\n}\n~~~\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\n\n\n이제 개발자가 개발하는 코드에서 Breakfast/Lunch/Dinner에 대한 Dependency는 완전히 제거 되었다.\n야식이라는 식사 메뉴가 추가되어도 Meal enum에 야식 항목을 추가하고, EatFactory에 야식에 대한 case만 추가 해 주면 \nStudent 클래스는 유연하게 추가된 기능에 대해 대처가 가능하다.\n\n\n\n## IoC 패턴\n\nIoC패턴을 알기 전에 IoC에 대해 간단히 설명하자면.. \n기능을 담당하는 POJO class를 프로그램 시작 시, IoC 컨테이너에 Bean이라는 이름으로 객체를 생성해 둔다.\n이렇게 싱글톤으로 생성된 객체들을 필요한 시점에 IoC 컨테이너에서 의존성을 가지는 객체에 직접 주입을 해주는 패턴을 IoC패턴이라 한다.\n\n쉽게 말하면 객체의 멤버에 대한 상태가 없고(stateless) 기능의 역할을 담은 클래스들을 1개씩 IoC컨테이너라는 상자에 담아두고, 의존성 객체가 필요한 경우 IoC컨테이너에서 필요한 객체를 주입해준다. 라고 생각하면 편할 것 같다.\n객체에 대해 new 생성자를 통해 객체를 생성할 필요가 없으니, 메모리적인 낭비가 없다는 장점이 있을 뿐 더러 개발자에게 객체 관리에 대한 미시적인 역할을 맡기지 않아도 되는 장점이 있다. 자세한 내용은 다음 장에 기술하도록 하겠다.\n\n위의 내용을 Spring을 사용한 개발이라고 한다면... 아래와 같이 코드를 짤 수 있겠다.\n\n~~~java\n@SpringBootApplication(scanBasePackages = \"com.example.ioc\")\npublic class Student {\n    \n    @Autowired\n    private Restaurant restaurant;\n    @Autowired\n    private EatFactory eatFactory;\n    \n    public static void main(String[] args) {\n        \n\t\tSpringApplication.run(SpringStudyApplication.class, args);\n        //식사 시작\n        restaurant.eat(eatFactory.get(Meal.BREAKFAST));\n        restaurant.eat(eatFactory.get(Meal.LUNCH));\n        restaurant.eat(eatFactory.get(Meal.DINNER));\n\t}\n}\n~~~\n~~~java\npublic enum Meal {\n   BREAKFAST, LUNCH, DINNER;\n}\n~~~\n~~~java\n@Component\npublic class EatFactory() {\n\t\n    @Autowired @Qualifier(\"breakfast\")\n    private Eatable breakfast;\n    @Autowired @Qualifier(\"lunch\")\n    private Eatable lunch;\n    @Autowired @Qualifier(\"dinner\")\n    private Eatable dinner;\n    \n    public Eatable get(Meal meal) {\n        switch(meal) {\n            case BREAKFAST : breakfast;\n            case LUNCH : lunch;\n            case DINNER : dinner;\n            default: throw new IllegalArgumentException(\"Not using Meal Type\");\n        }\n    }\n}\n~~~\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\n@Service\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\nSpring에서는 component-scan이라는 기능을 통해 @Component 어노테이션이 붙은 클래스는 IoC 컨테이너에 Bean으로써 자동 등록 해준다. 이러한 Bean은 @Autowired / @Inject 와 같은 어노테이션을 통해 클래스에 주입을 해줄 수 있다.\n이렇게 되면 개발자가 new를 통해 의존성을 강제화 하지 않고 프레임워크가 이 역할을 대신 수행해 준다.\n\n개발자가 객체 생성과 의존성 주입에 대한 역할을 대신 해준다 \nInversion of Control (객체 관리과 의존성 관리를 시스템에서 해준다 : 제어의 역전) 이라고 불리게 되었다.\n\n\n\n# 참조\n\nhttp://www.javajigi.net/pages/viewpage.action?pageId=3664&focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\n토비의 스프링 VOL.2 Spring IoC","slug":"2018-09-12-spring-ioc","published":1,"updated":"2018-09-22T08:58:20.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjniq3kp0000ku0yaywyrqn6o","content":"<h1><span id=\"ioc-등장배경\">IoC 등장배경</span></h1>\n<p>IoC의 등장배경을 알기 위해서는 EJB나 Spring과 같은 프레임워크를 사용하기 이전 시대의 개발 방식에 대해 얘기를 해야한다.<br>\n온고지신(?)이라 하였던가… IoC를 이해하기 위해 옛날이야기를 해보도록 하겠다.</p>\n<p>태초에 Java로 만든 프로그램은 main()이라는 메소드에서 시작이 되었다.<br>\nmain() 메소드 내에서 필요한 클래스를 개발자가 직접 코드내에서 생성하여 사용하였다.<br>\n어떠한 프로그램을 만들던지 간에 프로그램에는 <code>모델(Model)</code>이라는 개념이 생겨나게 된다.<br>\n이렇게 만들어진 클래스 간에서는 <code>관계(Relation)</code>과 <code>의존성(Dependency)</code>가 생기게 된다.</p>\n<p><code>의존성이란?</code> A클래스에서 B클래스의 기능을 사용할 때 클래스A는 클래스B에 의존적이다 라고 하며<br>\nA --&gt; B 라고 표현한다 (UML에서는 클래스 간의 Dependency를 점선으로 표현한다.)<br>\n즉, B클래스의 기능이 변하게 되면 A클래스에도 영향이 생긴다는 말로 직역할 수 있다.</p>\n<p>이해를 돕기위해 급식을 받는 학생에 대한 예제를 들어보겠다.<br>\n(이 학교는 아침/점심/저녁을 다 주는 좋은 학교이다)</p>\n<h2><span id=\"클래스-gt-클래스-호출-관계\">클래스 -&gt; 클래스 호출 관계</span></h2>\n<p><img src=\"./image-20180921143924788.png\" alt=\"image-20180921143924788\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eatBreakfast();</span><br><span class=\"line\">        restaurant.eatLunch();</span><br><span class=\"line\">        restaurant.eatDinner();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatBreakfast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Breakfast breakfast = <span class=\"keyword\">new</span> Breakfast();</span><br><span class=\"line\">        System.out.println(breakfast.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatLunch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Lunch lunch = <span class=\"keyword\">new</span> Lunch();</span><br><span class=\"line\">        System.out.println(lunch.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatDinner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Dinner dinner = <span class=\"keyword\">new</span> Dinner();</span><br><span class=\"line\">        System.out.println(dinner.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Student 클래스는 밥을 먹기위해 Restaurant클래스를 new로 생성하였다.<br>\nRestaurant클래스 내에서는 아침/점심/저녁을 먹을 수 있도록 각각 Breakfast, Lunch, Dinner클래스를 new로 생성하였다.<br>\n위의 의존성에 대해 위 예제를 풀어보면 Student는 Restaurant에 대해 의존적이다. (Student —&gt; Restaurant)<br>\nStudent클래스에서 Restaurant클래스를 생성하여 밥을 먹기 때문이다. 만약에 Restaurant 클래스에서 밥을 못먹게 하면<br>\nStudent클래스는 정상적으로 밥을 먹는 기능을 수행할 수 없다.<br>\nRestaurant클래스는 Breakfast/Lunch/Dinner에 대해 의존적이다.<br>\n각각의 메소드에서 Breakfast/Lunch/Dinner클래스를 생성하여 밥을 먹는 행위를 하도록 하고있다.</p>\n<p>가만히 보게 되면 의존성에 대한 공통점을 발견할 수 있다.<br>\n그것은 바로 <code>new</code>이다. <code>클래스 내에서의 new는 곧 의존성을 의미</code>하게 된다. new로 생성한 클래스가 문제가 생기면 사용을 하는 클래스의 기능에도 문제가 생기기 떄문이다.</p>\n<p>따라서 <strong>프로그래밍의 의존성은 new이다</strong> 로 간단하게 정의를 내릴 수 있겠다.</p>\n<h2><span id=\"클래스-gt-인터페이스interface-gt-클래스-구조\">클래스 -&gt; 인터페이스(interface) -&gt; 클래스 구조</span></h2>\n<p>클래스 내에서 클래스를 생성하여 호출 하는 경우에는 변경에 많은 비용이 발생하게 된다.<br>\n만약에 학교에서 야식까지 먹어가며 밤을 새는 경우에는 야식이라는 의존성을 또 추가하게 된다.<br>\n뿐만 아니라 Breakfast/Lunch/Dinner 클래스에 변경이 생기는 경우에도 Restaurant 클래스는 영향을 받게 된다.</p>\n<p>이와 같은 문제를 쪼금 더 편하게 해결 할 수 있게 Java에서는 interface라는게 있다.<br>\n(개인적으로 Service나 Repository 같은 클래스들을 생성 할 때 웬만하면 interface를 선언하는 편이다.)</p>\n<p>차후에 Mock객체 생성하기도 좋고, 요구사항이 변경 되었을 때 유연하게 대응 할 수 있어 개인적으로는 Interface를 자주 사용하는 편이다.</p>\n<p>Breakfast/Lunch/Dinner클래스를 자세히 보면… getInfo() 메소드가 공통적으로 쓰이고 있다.<br>\n(getInfo메소드는 식단에 대한 정보이다.)<br>\n따라서 하나의 interface로 Breakfast/Lunch/Dinner클래스를 추상화 할 수 있다.<br>\n그렇게 되면 eat이라는 메소드 하나만으로도 아침~저녁을 먹을 수 있는 기능을 구현할 수 있다.<br>\n위에서 말로 한 얘기를 코드로 풀어보면…</p>\n<p><img src=\"./image-20180921145310488.png\" alt=\"image-20180921145310488\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Breakfast());</span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Lunch());</span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Dinner());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 클래스 -&gt; 클래스 간의 Dependency 구조보다는 interface를 사용하므로써 많이 결합도가 완화된 모습이다.<br>\n이전에는 Restaurant 클래스가 Break/Lunch/Dinner에 대해 모두 Dependency를 가지고 가는 구조여서 결합도가 강한 형태였는데, interface를 사용하여 결합도를 많이 약화 시켰다.</p>\n<p>자세히 보면 <code>Student클래스에서 Break/Lunch/Dinner를 생성하여 Restaurant에 주입</code>해 주었다.<br>\n이러한 모습이 향후 DI의 개념과 비슷한 개념으로 발전하게 된다.<br>\nRestaurant입장에서는 개발자가 생성한 객체가 아닌 <code>외부로 부터 주입받은 형태</code>로 Break/Lunch/Dinner에 대해 사용을 하기 때문이다.<br>\n이 부분을 잘 이해하면 차후 IoC와 DI를 이해하는데 크게 도움이 된다.</p>\n<h2><span id=\"클래스-gt-팩토리factory-패턴\">클래스 -&gt; 팩토리(factory) 패턴</span></h2>\n<p>디자인 패턴 중에는 팩토리(Factory) 패턴이라는 구현 방식이 있다.<br>\n팩토리 패턴에 대해 간단하게 설명하자면, 객체의 상태(State) 또는 구분자(Type)을 통해 필요한 객체를 Return 해주는 패턴이다. 위에서 설명한 클래스 -&gt; 인터페이스 방식을 차용하여 한 단계 더 Wrapping한 개념이라고 생각하면 편하다.<br>\n팩토리 패턴을 이용하면 아예 <code>개발자에게 객체 생성에 대한 권한을 주지 않겠다!</code>를 구현 할 수 있게 된다.<br>\n<strong>개발자가 객체 생성을 직접 하지 않고도 시스템에 요청하여 원하는 객체를 얻어낼 수 있다.</strong> &lt;-- 이 내용은 DL(Dependency Lookup)과 비슷한 개념으로 통할 수 있을 것 같다.</p>\n<p>팩토리 패턴으로 만든 코드를 만들게 된다면, 아래와 같이 만들 수 있을 것이다.</p>\n<p><img src=\"./image-20180921153027741.png\" alt=\"image-20180921153027741\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.BREAKFAST));</span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.LUNCH));</span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.DINNER));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Meal &#123;</span><br><span class=\"line\">   BREAKFAST, LUNCH, DINNER;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">EatFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Eatable <span class=\"title\">get</span><span class=\"params\">(Meal meal)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(meal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BREAKFAST : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Breakfast();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LUNCH : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Lunch();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> DINNER : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Dinner();</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Not using Meal Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 개발자가 개발하는 코드에서 Breakfast/Lunch/Dinner에 대한 Dependency는 완전히 제거 되었다.<br>\n야식이라는 식사 메뉴가 추가되어도 Meal enum에 야식 항목을 추가하고, EatFactory에 야식에 대한 case만 추가 해 주면<br>\nStudent 클래스는 유연하게 추가된 기능에 대해 대처가 가능하다.</p>\n<h2><span id=\"ioc-패턴\">IoC 패턴</span></h2>\n<p>IoC패턴을 알기 전에 IoC에 대해 간단히 설명하자면…<br>\n기능을 담당하는 POJO class를 프로그램 시작 시, IoC 컨테이너에 Bean이라는 이름으로 객체를 생성해 둔다.<br>\n이렇게 싱글톤으로 생성된 객체들을 필요한 시점에 IoC 컨테이너에서 의존성을 가지는 객체에 직접 주입을 해주는 패턴을 IoC패턴이라 한다.</p>\n<p>쉽게 말하면 객체의 멤버에 대한 상태가 없고(stateless) 기능의 역할을 담은 클래스들을 1개씩 IoC컨테이너라는 상자에 담아두고, 의존성 객체가 필요한 경우 IoC컨테이너에서 필요한 객체를 주입해준다. 라고 생각하면 편할 것 같다.<br>\n객체에 대해 new 생성자를 통해 객체를 생성할 필요가 없으니, 메모리적인 낭비가 없다는 장점이 있을 뿐 더러 개발자에게 객체 관리에 대한 미시적인 역할을 맡기지 않아도 되는 장점이 있다. 자세한 내용은 다음 장에 기술하도록 하겠다.</p>\n<p>위의 내용을 Spring을 사용한 개발이라고 한다면… 아래와 같이 코드를 짤 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span>(scanBasePackages = <span class=\"string\">\"com.example.ioc\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Restaurant restaurant;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EatFactory eatFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\tSpringApplication.run(SpringStudyApplication.class, args);</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.BREAKFAST));</span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.LUNCH));</span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.DINNER));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Meal &#123;</span><br><span class=\"line\">   BREAKFAST, LUNCH, DINNER;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">EatFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"breakfast\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable breakfast;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"lunch\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable lunch;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"dinner\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable dinner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Eatable <span class=\"title\">get</span><span class=\"params\">(Meal meal)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(meal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BREAKFAST : breakfast;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LUNCH : lunch;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> DINNER : dinner;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Not using Meal Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Spring에서는 component-scan이라는 기능을 통해 @Component 어노테이션이 붙은 클래스는 IoC 컨테이너에 Bean으로써 자동 등록 해준다. 이러한 Bean은 @Autowired / @Inject 와 같은 어노테이션을 통해 클래스에 주입을 해줄 수 있다.<br>\n이렇게 되면 개발자가 new를 통해 의존성을 강제화 하지 않고 프레임워크가 이 역할을 대신 수행해 준다.</p>\n<p>개발자가 객체 생성과 의존성 주입에 대한 역할을 대신 해준다<br>\nInversion of Control (객체 관리과 의존성 관리를 시스템에서 해준다 : 제어의 역전) 이라고 불리게 되었다.</p>\n<h1><span id=\"참조\">참조</span></h1>\n<p><a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring프레임워크소개와IoC및SpringIoC의개념-2.1IoC란무엇인가%3F</a><br>\n<a href=\"http://wiki.javajigi.net/pages/viewpage.action?pageId=281\" target=\"_blank\" rel=\"noopener\">http://wiki.javajigi.net/pages/viewpage.action?pageId=281</a><br>\n<a href=\"https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/</a><br>\n<a href=\"https://okky.kr/article/415474\" target=\"_blank\" rel=\"noopener\">https://okky.kr/article/415474</a><br>\n<a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=68\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=68</a><br>\n<a href=\"http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1</a><br>\n<a href=\"http://isstory83.tistory.com/91\" target=\"_blank\" rel=\"noopener\">http://isstory83.tistory.com/91</a><br>\n토비의 스프링 VOL.2 Spring IoC</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>IoC 등장배경</h1>\n<p>IoC의 등장배경을 알기 위해서는 EJB나 Spring과 같은 프레임워크를 사용하기 이전 시대의 개발 방식에 대해 얘기를 해야한다.<br>\n온고지신(?)이라 하였던가… IoC를 이해하기 위해 옛날이야기를 해보도록 하겠다.</p>\n<p>태초에 Java로 만든 프로그램은 main()이라는 메소드에서 시작이 되었다.<br>\nmain() 메소드 내에서 필요한 클래스를 개발자가 직접 코드내에서 생성하여 사용하였다.<br>\n어떠한 프로그램을 만들던지 간에 프로그램에는 <code>모델(Model)</code>이라는 개념이 생겨나게 된다.<br>\n이렇게 만들어진 클래스 간에서는 <code>관계(Relation)</code>과 <code>의존성(Dependency)</code>가 생기게 된다.</p>\n<p><code>의존성이란?</code> A클래스에서 B클래스의 기능을 사용할 때 클래스A는 클래스B에 의존적이다 라고 하며<br>\nA --&gt; B 라고 표현한다 (UML에서는 클래스 간의 Dependency를 점선으로 표현한다.)<br>\n즉, B클래스의 기능이 변하게 되면 A클래스에도 영향이 생긴다는 말로 직역할 수 있다.</p>\n<p>이해를 돕기위해 급식을 받는 학생에 대한 예제를 들어보겠다.<br>\n(이 학교는 아침/점심/저녁을 다 주는 좋은 학교이다)</p>\n<h2>클래스 -&gt; 클래스 호출 관계</h2>\n<p><img src=\"./image-20180921143924788.png\" alt=\"image-20180921143924788\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eatBreakfast();</span><br><span class=\"line\">        restaurant.eatLunch();</span><br><span class=\"line\">        restaurant.eatDinner();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatBreakfast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Breakfast breakfast = <span class=\"keyword\">new</span> Breakfast();</span><br><span class=\"line\">        System.out.println(breakfast.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatLunch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Lunch lunch = <span class=\"keyword\">new</span> Lunch();</span><br><span class=\"line\">        System.out.println(lunch.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatDinner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Dinner dinner = <span class=\"keyword\">new</span> Dinner();</span><br><span class=\"line\">        System.out.println(dinner.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Student 클래스는 밥을 먹기위해 Restaurant클래스를 new로 생성하였다.<br>\nRestaurant클래스 내에서는 아침/점심/저녁을 먹을 수 있도록 각각 Breakfast, Lunch, Dinner클래스를 new로 생성하였다.<br>\n위의 의존성에 대해 위 예제를 풀어보면 Student는 Restaurant에 대해 의존적이다. (Student —&gt; Restaurant)<br>\nStudent클래스에서 Restaurant클래스를 생성하여 밥을 먹기 때문이다. 만약에 Restaurant 클래스에서 밥을 못먹게 하면<br>\nStudent클래스는 정상적으로 밥을 먹는 기능을 수행할 수 없다.<br>\nRestaurant클래스는 Breakfast/Lunch/Dinner에 대해 의존적이다.<br>\n각각의 메소드에서 Breakfast/Lunch/Dinner클래스를 생성하여 밥을 먹는 행위를 하도록 하고있다.</p>\n<p>가만히 보게 되면 의존성에 대한 공통점을 발견할 수 있다.<br>\n그것은 바로 <code>new</code>이다. <code>클래스 내에서의 new는 곧 의존성을 의미</code>하게 된다. new로 생성한 클래스가 문제가 생기면 사용을 하는 클래스의 기능에도 문제가 생기기 떄문이다.</p>\n<p>따라서 <strong>프로그래밍의 의존성은 new이다</strong> 로 간단하게 정의를 내릴 수 있겠다.</p>\n<h2>클래스 -&gt; 인터페이스(interface) -&gt; 클래스 구조</h2>\n<p>클래스 내에서 클래스를 생성하여 호출 하는 경우에는 변경에 많은 비용이 발생하게 된다.<br>\n만약에 학교에서 야식까지 먹어가며 밤을 새는 경우에는 야식이라는 의존성을 또 추가하게 된다.<br>\n뿐만 아니라 Breakfast/Lunch/Dinner 클래스에 변경이 생기는 경우에도 Restaurant 클래스는 영향을 받게 된다.</p>\n<p>이와 같은 문제를 쪼금 더 편하게 해결 할 수 있게 Java에서는 interface라는게 있다.<br>\n(개인적으로 Service나 Repository 같은 클래스들을 생성 할 때 웬만하면 interface를 선언하는 편이다.)</p>\n<p>차후에 Mock객체 생성하기도 좋고, 요구사항이 변경 되었을 때 유연하게 대응 할 수 있어 개인적으로는 Interface를 자주 사용하는 편이다.</p>\n<p>Breakfast/Lunch/Dinner클래스를 자세히 보면… getInfo() 메소드가 공통적으로 쓰이고 있다.<br>\n(getInfo메소드는 식단에 대한 정보이다.)<br>\n따라서 하나의 interface로 Breakfast/Lunch/Dinner클래스를 추상화 할 수 있다.<br>\n그렇게 되면 eat이라는 메소드 하나만으로도 아침~저녁을 먹을 수 있는 기능을 구현할 수 있다.<br>\n위에서 말로 한 얘기를 코드로 풀어보면…</p>\n<p><img src=\"./image-20180921145310488.png\" alt=\"image-20180921145310488\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Breakfast());</span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Lunch());</span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Dinner());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 클래스 -&gt; 클래스 간의 Dependency 구조보다는 interface를 사용하므로써 많이 결합도가 완화된 모습이다.<br>\n이전에는 Restaurant 클래스가 Break/Lunch/Dinner에 대해 모두 Dependency를 가지고 가는 구조여서 결합도가 강한 형태였는데, interface를 사용하여 결합도를 많이 약화 시켰다.</p>\n<p>자세히 보면 <code>Student클래스에서 Break/Lunch/Dinner를 생성하여 Restaurant에 주입</code>해 주었다.<br>\n이러한 모습이 향후 DI의 개념과 비슷한 개념으로 발전하게 된다.<br>\nRestaurant입장에서는 개발자가 생성한 객체가 아닌 <code>외부로 부터 주입받은 형태</code>로 Break/Lunch/Dinner에 대해 사용을 하기 때문이다.<br>\n이 부분을 잘 이해하면 차후 IoC와 DI를 이해하는데 크게 도움이 된다.</p>\n<h2>클래스 -&gt; 팩토리(factory) 패턴</h2>\n<p>디자인 패턴 중에는 팩토리(Factory) 패턴이라는 구현 방식이 있다.<br>\n팩토리 패턴에 대해 간단하게 설명하자면, 객체의 상태(State) 또는 구분자(Type)을 통해 필요한 객체를 Return 해주는 패턴이다. 위에서 설명한 클래스 -&gt; 인터페이스 방식을 차용하여 한 단계 더 Wrapping한 개념이라고 생각하면 편하다.<br>\n팩토리 패턴을 이용하면 아예 <code>개발자에게 객체 생성에 대한 권한을 주지 않겠다!</code>를 구현 할 수 있게 된다.<br>\n<strong>개발자가 객체 생성을 직접 하지 않고도 시스템에 요청하여 원하는 객체를 얻어낼 수 있다.</strong> &lt;-- 이 내용은 DL(Dependency Lookup)과 비슷한 개념으로 통할 수 있을 것 같다.</p>\n<p>팩토리 패턴으로 만든 코드를 만들게 된다면, 아래와 같이 만들 수 있을 것이다.</p>\n<p><img src=\"./image-20180921153027741.png\" alt=\"image-20180921153027741\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.BREAKFAST));</span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.LUNCH));</span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.DINNER));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Meal &#123;</span><br><span class=\"line\">   BREAKFAST, LUNCH, DINNER;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">EatFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Eatable <span class=\"title\">get</span><span class=\"params\">(Meal meal)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(meal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BREAKFAST : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Breakfast();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LUNCH : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Lunch();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> DINNER : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Dinner();</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Not using Meal Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 개발자가 개발하는 코드에서 Breakfast/Lunch/Dinner에 대한 Dependency는 완전히 제거 되었다.<br>\n야식이라는 식사 메뉴가 추가되어도 Meal enum에 야식 항목을 추가하고, EatFactory에 야식에 대한 case만 추가 해 주면<br>\nStudent 클래스는 유연하게 추가된 기능에 대해 대처가 가능하다.</p>\n<h2>IoC 패턴</h2>\n<p>IoC패턴을 알기 전에 IoC에 대해 간단히 설명하자면…<br>\n기능을 담당하는 POJO class를 프로그램 시작 시, IoC 컨테이너에 Bean이라는 이름으로 객체를 생성해 둔다.<br>\n이렇게 싱글톤으로 생성된 객체들을 필요한 시점에 IoC 컨테이너에서 의존성을 가지는 객체에 직접 주입을 해주는 패턴을 IoC패턴이라 한다.</p>\n<p>쉽게 말하면 객체의 멤버에 대한 상태가 없고(stateless) 기능의 역할을 담은 클래스들을 1개씩 IoC컨테이너라는 상자에 담아두고, 의존성 객체가 필요한 경우 IoC컨테이너에서 필요한 객체를 주입해준다. 라고 생각하면 편할 것 같다.<br>\n객체에 대해 new 생성자를 통해 객체를 생성할 필요가 없으니, 메모리적인 낭비가 없다는 장점이 있을 뿐 더러 개발자에게 객체 관리에 대한 미시적인 역할을 맡기지 않아도 되는 장점이 있다. 자세한 내용은 다음 장에 기술하도록 하겠다.</p>\n<p>위의 내용을 Spring을 사용한 개발이라고 한다면… 아래와 같이 코드를 짤 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span>(scanBasePackages = <span class=\"string\">\"com.example.ioc\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Restaurant restaurant;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EatFactory eatFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\tSpringApplication.run(SpringStudyApplication.class, args);</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.BREAKFAST));</span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.LUNCH));</span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.DINNER));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Meal &#123;</span><br><span class=\"line\">   BREAKFAST, LUNCH, DINNER;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">EatFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"breakfast\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable breakfast;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"lunch\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable lunch;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"dinner\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable dinner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Eatable <span class=\"title\">get</span><span class=\"params\">(Meal meal)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(meal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BREAKFAST : breakfast;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LUNCH : lunch;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> DINNER : dinner;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Not using Meal Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Spring에서는 component-scan이라는 기능을 통해 @Component 어노테이션이 붙은 클래스는 IoC 컨테이너에 Bean으로써 자동 등록 해준다. 이러한 Bean은 @Autowired / @Inject 와 같은 어노테이션을 통해 클래스에 주입을 해줄 수 있다.<br>\n이렇게 되면 개발자가 new를 통해 의존성을 강제화 하지 않고 프레임워크가 이 역할을 대신 수행해 준다.</p>\n<p>개발자가 객체 생성과 의존성 주입에 대한 역할을 대신 해준다<br>\nInversion of Control (객체 관리과 의존성 관리를 시스템에서 해준다 : 제어의 역전) 이라고 불리게 되었다.</p>\n<h1>참조</h1>\n<p><a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring프레임워크소개와IoC및SpringIoC의개념-2.1IoC란무엇인가%3F</a><br>\n<a href=\"http://wiki.javajigi.net/pages/viewpage.action?pageId=281\" target=\"_blank\" rel=\"noopener\">http://wiki.javajigi.net/pages/viewpage.action?pageId=281</a><br>\n<a href=\"https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/</a><br>\n<a href=\"https://okky.kr/article/415474\" target=\"_blank\" rel=\"noopener\">https://okky.kr/article/415474</a><br>\n<a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=68\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=68</a><br>\n<a href=\"http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1</a><br>\n<a href=\"http://isstory83.tistory.com/91\" target=\"_blank\" rel=\"noopener\">http://isstory83.tistory.com/91</a><br>\n토비의 스프링 VOL.2 Spring IoC</p>\n"},{"title":"Spring IoC & DI(2)","subtitle":"Spring IoC와 DI","catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-09-21-spring-ioc-2","typora-copy-images-to":"./2018-09-21-spring-ioc-2","date":"2018-09-22T08:00:54.000Z","header-img":null,"_content":"\n# IoC란?\n\nInversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.\n보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.\n하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며\n개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.\n\n따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여\n제어의 역전 (Inversion of Control)이라 불린다.\n\n\n\n# Container가 도데체 뭐람?\n\n![containers](./containers.jpg)\n\n\n\n개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다. \nSpring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등.. Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까? \n위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다. \n이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.\n컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는.. 컨테이너를 생각하는 것이 도움이 될 것 같다.\n실제 프레임워크에서의 컨테이너도 같은 역할을 한다. \n\n**이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체**라고 할 수 있다. \n\n위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면\n\n서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,\n외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.\n\nSpring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.\n\n\n\n# DI란?\n\nDI란 Dependency Injection의 의미로 IoC를 구현한 대표적인 예야\nPojo 객체내의 종속적인 객체를 IoC Container에서 직접 객체를 Injection해주는 걸 의미해\n스프링 개발에서는 99프로 DI방식을 통해 개발자가 직접 필요한 객체를 선언하지 않고 \nIoC Container에서 넣어줘서 사용해 —> 이거는 Bean 초기화시에 이루어져\nDL (Dependency Lookup) 이라는 기능도 있는데 이거는 거의 사용하지는 않아\n이 기능은 IoC Container에서 Bean의 메타정보를 이용해서 개발자가 Bean을 직접 찾는 행위야\n\nDI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.\nDI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.\n개념 자체는 `IoC의 형태 중 하나`라고 볼 수 있다.\n\nDI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.\n클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.\n\n\n\nSpring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며\n객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.\n\n1. Constructor Injection\n2. Dependency Constructor Injection\n3. Setter Injection\n4. Field Injection\n\n\n\n# 의존성 주입 Annotation\n\nSpring/Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.\n\n* @Autowired\n  * Spring에서 지원하는 Annotation\n  * `Type`에 맞춰서 주입이 된다.\n  * Interface에 상응하는 Bean이 2개 이상 인 경우에는 `@Qualifier(\"beanName\")을 혼용`하여 \n    필요한 Bean객체를 주입한다.\n* @Inject\n  * Java에서 지원하는 Annotation\n  * `Type`에 맞춰서 주입이 된다.\n* @Resource\n  * Java에서 지원하는 Annotation\n  * `이름`에 맞춰서 주입이 된다.\n\nSpring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject/@Resource를 사용하면 문제는 없을 것이나.. 대부분은 @Autowired를 사용한다.\n\n\n\n# DI 구현방식\n\n## Constructor Injection\n\n생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.\n이 방법은 xml 설정 시에 유용한 방법이다.\n객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    \n    @Autowired\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\n~~~xml\n<bean id=\"userRepository\" class=\"com.example.user.UserRepository\"></bean>\n<bean id=\"userService\", class=\"com.example.user.UserService\">\n\t<construct-args>\n        <ref bean=\"userRepository\"></ref>\n    </construct-args>\n</bean>\n~~~\n\n\n\n## Extension Constructor Injection\n\nSpring 4에 추가된 DI방법이다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\nUserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.\n어찌보면 당연한 내용 같은데...  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.\n\n\n\n~~~java\n@AllArgsConstructor\npublic Class UserService {\n    private UserRepository userRepository;\n}\n~~~\n\n\n\n## Setter Injection\n\nSetter를 통해 DI하는 방법이다.\n이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    \n    @Autowired\n    public setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\n\n\n## Field Injection\n\nSpring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.\n아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.\n\n~~~java\npublic Class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}\n~~~\n\n\n\n# 용어 설명\n\n* Bean\n  * Spring Container에 등록 되는 POJO객체 \n  * Spring Application의 Component들이 등록 된다.\n  * 기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.\n* Bean Factory\n  * Spring IoC를 담당하는 핵심 컨테이너\n  * Bean에 대한 등록/생성/조회/소멸을 관리한다.\n  * BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.\n  * 대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)\n* Application Context\n  * BeanFactory 인터페이스의 구현체 ()\n    * 정확히는 ListableBeanFactory\n    * Bean을 Listable하게 보관하는 인터페이스를 말한다.\n  * BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.\n    * ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.\n    * ApplicationEventPublisher - 이벤트 발생을 관장한다.\n    * MessageSource - properties파일을 통해 다국어 설정이 가능\n    * BeanLifecycle - Bean의 초기화, 소멸을 담당한다.\n* Configuration Meta Data \n  * Application Context에서 IoC 설정을 위해 사용되는 메타정보\n  * 컨테이너에 어떤 기능을 세팅할때 사용\n  * Bean 생성/구성할 경우에도 사용\n  * @Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능\n\n\n\n# Bean 등록 방법\n\n## Component-Scan\n\nSpring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.\nSpring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.\n분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에 \n불필요한 메모리 할당이 이루어질 수 있다.\n그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 `가장 많이 하는 설정`이 아닐까 싶다.\n\n* @Component 종류\n  * @Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)\n  * @Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)\n  * @Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)\n  * @Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)\n\n\n\n## Servlet-Context.xml\n\n기존 Bean 생성을 xml로 등록하는 방식이다.\n이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만...\n보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.\n위에서 언급한 `Component-scan`을 주로 사용하는 것이 좋다.\n\n~~~xml\n <bean name=\"beanNameViewResolver\" class=\"org.springframework.web.servlet.view.BeanNameViewResolver\">\n        <property name=\"order\" value=\"1\"/>\n    </bean>\n    <bean name=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/views/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n        <property name=\"order\" value=\"2\"/>\n    </bean>\n~~~\n\n\n\n## @Configuration\n\nxml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.\n뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.\nBean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 `@Bean` 어노테이션을 붙여주면 된다.\n\n~~~java\n@Configuration\npublic class UserConfig {\n    @Bean\n    public UserService userService() { //메소드 명이 기본적으로 Bean Name으로 추가된다.\n        return new UserService();\n    }\n}\n~~~\n\nJava Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우 \n아주 유용한 방법이라 할 수 있겠다.\n\n\n\n# Bean 생명주기\n\nSpring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.\nBean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.\n\nBean 생명주기 처리를 하는 방법은 3가지 방식이 있다.\n\n1. InitializingBean, DisposableBean 인터페이스 구현\n2. Bean정의 시 , 메소드 지정\n3. @PostConstruct, @PreDestroy Annotation 사용\n\n\n\n## InitializingBean, DisposableBean 인터페이스 구현\n\nInitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시 \n기능을 확장 할 수 있다.\n\nInitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에\nSpring에 종속적이게 된다.\n\n~~~java\npublic class TestBeanClass implements InitializingBean, DisposableBean{\n\t\n    private Connection conn;\n    \n    @Override\n    public void afterPropertiesSet() throws Exception {\n        //자원의 할당 처리\n        conn = DBConnectionCaller.getConnection();\n        System.out.println(\"bean 생성 및 초기화 : afterPropertiesSet() 호출됨\");\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        //주로 할당된 자원의 해제를 한다.\n        if(conn != null) conn.close();\n        System.out.println(\"bean 소멸 : destroy 호출됨\");\n    }\n}\n\n~~~\n\n\n\n## Bean정의 시 , 메소드 지정\n\n~~~xml\n<bean id=\"testBean\" class=\"com.example.TestBeanClass\"                      \n   init-method=\"init\" destroy-method=\"destroy\"/>\n~~~\n\n* xml설정 파일 <bean>에서 **init-method** 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출\n* xml설정 파일 <bean>에서 **destroy-method** 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출\n\n\n\n## @PostConstruct, @PreDestroy Annotation 사용\n\n~~~java\npublic class TestBeanClass {be\n\t\n    private Connection conn;\n    \n    @PostConstruct\n    public void init() {\n        //자원의 할당 처리\n        conn = DBConnectionCaller.getConnection();\n        System.out.println(\"bean 생성 및 초기화\");\n    }\n\n    @PreDestroy\n    public void destroy() {\n        //주로 할당된 자원의 해제를 한다.\n        if(conn != null) conn.close();\n        System.out.println(\"bean 소멸\");\n    }\n}\n~~~\n\n@PostConstuct, @PreDestroy 은 `JSR-250 Annotation` 기반이다 (한마디로 자바기반)\n따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.\n\n\n\n@PostConstuct, @PreDestroy 을 사용하기 위해서는\n`<annotation-config/> `설정이나, `@AnnotationDrivenConfig `어노테이션을 붙여줘야 한다.\n\n\n\n# Bean Scope\n\nhttps://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html 을 참고함\n\n* Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.\n* Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.\n* Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용\n* Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.\n  (이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)\n* Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다. \n\n\n\n# 참조\n\nhttp://www.javajigi.net/pages/viewpage.action?pageId=3664&focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\nhttps://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3\n토비의 스프링 VOL.2 Spring IoC","source":"_posts/2018-09-21-spring-ioc-2.md","raw":"---\ntitle: Spring IoC & DI(2)\nsubtitle: Spring IoC와 DI\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\ntypora-root-url: ./2018-09-21-spring-ioc-2\ntypora-copy-images-to: ./2018-09-21-spring-ioc-2\ndate: 2018-09-22 17:00:54\nheader-img:\n---\n\n# IoC란?\n\nInversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.\n보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.\n하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며\n개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.\n\n따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여\n제어의 역전 (Inversion of Control)이라 불린다.\n\n\n\n# Container가 도데체 뭐람?\n\n![containers](./containers.jpg)\n\n\n\n개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다. \nSpring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등.. Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까? \n위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다. \n이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.\n컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는.. 컨테이너를 생각하는 것이 도움이 될 것 같다.\n실제 프레임워크에서의 컨테이너도 같은 역할을 한다. \n\n**이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체**라고 할 수 있다. \n\n위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면\n\n서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,\n외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.\n\nSpring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.\n\n\n\n# DI란?\n\nDI란 Dependency Injection의 의미로 IoC를 구현한 대표적인 예야\nPojo 객체내의 종속적인 객체를 IoC Container에서 직접 객체를 Injection해주는 걸 의미해\n스프링 개발에서는 99프로 DI방식을 통해 개발자가 직접 필요한 객체를 선언하지 않고 \nIoC Container에서 넣어줘서 사용해 —> 이거는 Bean 초기화시에 이루어져\nDL (Dependency Lookup) 이라는 기능도 있는데 이거는 거의 사용하지는 않아\n이 기능은 IoC Container에서 Bean의 메타정보를 이용해서 개발자가 Bean을 직접 찾는 행위야\n\nDI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.\nDI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.\n개념 자체는 `IoC의 형태 중 하나`라고 볼 수 있다.\n\nDI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.\n클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.\n\n\n\nSpring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며\n객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.\n\n1. Constructor Injection\n2. Dependency Constructor Injection\n3. Setter Injection\n4. Field Injection\n\n\n\n# 의존성 주입 Annotation\n\nSpring/Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.\n\n* @Autowired\n  * Spring에서 지원하는 Annotation\n  * `Type`에 맞춰서 주입이 된다.\n  * Interface에 상응하는 Bean이 2개 이상 인 경우에는 `@Qualifier(\"beanName\")을 혼용`하여 \n    필요한 Bean객체를 주입한다.\n* @Inject\n  * Java에서 지원하는 Annotation\n  * `Type`에 맞춰서 주입이 된다.\n* @Resource\n  * Java에서 지원하는 Annotation\n  * `이름`에 맞춰서 주입이 된다.\n\nSpring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject/@Resource를 사용하면 문제는 없을 것이나.. 대부분은 @Autowired를 사용한다.\n\n\n\n# DI 구현방식\n\n## Constructor Injection\n\n생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.\n이 방법은 xml 설정 시에 유용한 방법이다.\n객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    \n    @Autowired\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\n~~~xml\n<bean id=\"userRepository\" class=\"com.example.user.UserRepository\"></bean>\n<bean id=\"userService\", class=\"com.example.user.UserService\">\n\t<construct-args>\n        <ref bean=\"userRepository\"></ref>\n    </construct-args>\n</bean>\n~~~\n\n\n\n## Extension Constructor Injection\n\nSpring 4에 추가된 DI방법이다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\nUserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.\n어찌보면 당연한 내용 같은데...  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.\n\n\n\n~~~java\n@AllArgsConstructor\npublic Class UserService {\n    private UserRepository userRepository;\n}\n~~~\n\n\n\n## Setter Injection\n\nSetter를 통해 DI하는 방법이다.\n이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    \n    @Autowired\n    public setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\n\n\n## Field Injection\n\nSpring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.\n아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.\n\n~~~java\npublic Class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}\n~~~\n\n\n\n# 용어 설명\n\n* Bean\n  * Spring Container에 등록 되는 POJO객체 \n  * Spring Application의 Component들이 등록 된다.\n  * 기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.\n* Bean Factory\n  * Spring IoC를 담당하는 핵심 컨테이너\n  * Bean에 대한 등록/생성/조회/소멸을 관리한다.\n  * BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.\n  * 대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)\n* Application Context\n  * BeanFactory 인터페이스의 구현체 ()\n    * 정확히는 ListableBeanFactory\n    * Bean을 Listable하게 보관하는 인터페이스를 말한다.\n  * BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.\n    * ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.\n    * ApplicationEventPublisher - 이벤트 발생을 관장한다.\n    * MessageSource - properties파일을 통해 다국어 설정이 가능\n    * BeanLifecycle - Bean의 초기화, 소멸을 담당한다.\n* Configuration Meta Data \n  * Application Context에서 IoC 설정을 위해 사용되는 메타정보\n  * 컨테이너에 어떤 기능을 세팅할때 사용\n  * Bean 생성/구성할 경우에도 사용\n  * @Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능\n\n\n\n# Bean 등록 방법\n\n## Component-Scan\n\nSpring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.\nSpring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.\n분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에 \n불필요한 메모리 할당이 이루어질 수 있다.\n그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 `가장 많이 하는 설정`이 아닐까 싶다.\n\n* @Component 종류\n  * @Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)\n  * @Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)\n  * @Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)\n  * @Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)\n\n\n\n## Servlet-Context.xml\n\n기존 Bean 생성을 xml로 등록하는 방식이다.\n이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만...\n보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.\n위에서 언급한 `Component-scan`을 주로 사용하는 것이 좋다.\n\n~~~xml\n <bean name=\"beanNameViewResolver\" class=\"org.springframework.web.servlet.view.BeanNameViewResolver\">\n        <property name=\"order\" value=\"1\"/>\n    </bean>\n    <bean name=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/views/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n        <property name=\"order\" value=\"2\"/>\n    </bean>\n~~~\n\n\n\n## @Configuration\n\nxml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.\n뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.\nBean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 `@Bean` 어노테이션을 붙여주면 된다.\n\n~~~java\n@Configuration\npublic class UserConfig {\n    @Bean\n    public UserService userService() { //메소드 명이 기본적으로 Bean Name으로 추가된다.\n        return new UserService();\n    }\n}\n~~~\n\nJava Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우 \n아주 유용한 방법이라 할 수 있겠다.\n\n\n\n# Bean 생명주기\n\nSpring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.\nBean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.\n\nBean 생명주기 처리를 하는 방법은 3가지 방식이 있다.\n\n1. InitializingBean, DisposableBean 인터페이스 구현\n2. Bean정의 시 , 메소드 지정\n3. @PostConstruct, @PreDestroy Annotation 사용\n\n\n\n## InitializingBean, DisposableBean 인터페이스 구현\n\nInitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시 \n기능을 확장 할 수 있다.\n\nInitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에\nSpring에 종속적이게 된다.\n\n~~~java\npublic class TestBeanClass implements InitializingBean, DisposableBean{\n\t\n    private Connection conn;\n    \n    @Override\n    public void afterPropertiesSet() throws Exception {\n        //자원의 할당 처리\n        conn = DBConnectionCaller.getConnection();\n        System.out.println(\"bean 생성 및 초기화 : afterPropertiesSet() 호출됨\");\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        //주로 할당된 자원의 해제를 한다.\n        if(conn != null) conn.close();\n        System.out.println(\"bean 소멸 : destroy 호출됨\");\n    }\n}\n\n~~~\n\n\n\n## Bean정의 시 , 메소드 지정\n\n~~~xml\n<bean id=\"testBean\" class=\"com.example.TestBeanClass\"                      \n   init-method=\"init\" destroy-method=\"destroy\"/>\n~~~\n\n* xml설정 파일 <bean>에서 **init-method** 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출\n* xml설정 파일 <bean>에서 **destroy-method** 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출\n\n\n\n## @PostConstruct, @PreDestroy Annotation 사용\n\n~~~java\npublic class TestBeanClass {be\n\t\n    private Connection conn;\n    \n    @PostConstruct\n    public void init() {\n        //자원의 할당 처리\n        conn = DBConnectionCaller.getConnection();\n        System.out.println(\"bean 생성 및 초기화\");\n    }\n\n    @PreDestroy\n    public void destroy() {\n        //주로 할당된 자원의 해제를 한다.\n        if(conn != null) conn.close();\n        System.out.println(\"bean 소멸\");\n    }\n}\n~~~\n\n@PostConstuct, @PreDestroy 은 `JSR-250 Annotation` 기반이다 (한마디로 자바기반)\n따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.\n\n\n\n@PostConstuct, @PreDestroy 을 사용하기 위해서는\n`<annotation-config/> `설정이나, `@AnnotationDrivenConfig `어노테이션을 붙여줘야 한다.\n\n\n\n# Bean Scope\n\nhttps://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html 을 참고함\n\n* Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.\n* Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.\n* Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용\n* Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.\n  (이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)\n* Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다. \n\n\n\n# 참조\n\nhttp://www.javajigi.net/pages/viewpage.action?pageId=3664&focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\nhttps://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3\n토비의 스프링 VOL.2 Spring IoC","slug":"2018-09-21-spring-ioc-2","published":1,"updated":"2018-09-22T08:58:20.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjniq3kp8000mu0ya5qxzt46t","content":"<h1><span id=\"ioc란\">IoC란?</span></h1>\n<p>Inversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.<br>\n보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.<br>\n하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며<br>\n개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.</p>\n<p>따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여<br>\n제어의 역전 (Inversion of Control)이라 불린다.</p>\n<h1><span id=\"container가-도데체-뭐람\">Container가 도데체 뭐람?</span></h1>\n<p><img src=\"./containers.jpg\" alt=\"containers\"></p>\n<p>개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다.<br>\nSpring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등… Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까?<br>\n위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다.<br>\n이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.<br>\n컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는… 컨테이너를 생각하는 것이 도움이 될 것 같다.<br>\n실제 프레임워크에서의 컨테이너도 같은 역할을 한다.</p>\n<p><strong>이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체</strong>라고 할 수 있다.</p>\n<p>위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면</p>\n<p>서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,<br>\n외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.</p>\n<p>Spring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.</p>\n<h1><span id=\"di란\">DI란?</span></h1>\n<p>DI란 Dependency Injection의 의미로 IoC를 구현한 대표적인 예야<br>\nPojo 객체내의 종속적인 객체를 IoC Container에서 직접 객체를 Injection해주는 걸 의미해<br>\n스프링 개발에서는 99프로 DI방식을 통해 개발자가 직접 필요한 객체를 선언하지 않고<br>\nIoC Container에서 넣어줘서 사용해 —&gt; 이거는 Bean 초기화시에 이루어져<br>\nDL (Dependency Lookup) 이라는 기능도 있는데 이거는 거의 사용하지는 않아<br>\n이 기능은 IoC Container에서 Bean의 메타정보를 이용해서 개발자가 Bean을 직접 찾는 행위야</p>\n<p>DI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.<br>\nDI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.<br>\n개념 자체는 <code>IoC의 형태 중 하나</code>라고 볼 수 있다.</p>\n<p>DI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.<br>\n클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.</p>\n<p>Spring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며<br>\n객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.</p>\n<ol>\n<li>Constructor Injection</li>\n<li>Dependency Constructor Injection</li>\n<li>Setter Injection</li>\n<li>Field Injection</li>\n</ol>\n<h1><span id=\"의존성-주입-annotation\">의존성 주입 Annotation</span></h1>\n<p>Spring/Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.</p>\n<ul>\n<li>@Autowired\n<ul>\n<li>Spring에서 지원하는 Annotation</li>\n<li><code>Type</code>에 맞춰서 주입이 된다.</li>\n<li>Interface에 상응하는 Bean이 2개 이상 인 경우에는 <code>@Qualifier(&quot;beanName&quot;)을 혼용</code>하여<br>\n필요한 Bean객체를 주입한다.</li>\n</ul>\n</li>\n<li>@Inject\n<ul>\n<li>Java에서 지원하는 Annotation</li>\n<li><code>Type</code>에 맞춰서 주입이 된다.</li>\n</ul>\n</li>\n<li>@Resource\n<ul>\n<li>Java에서 지원하는 Annotation</li>\n<li><code>이름</code>에 맞춰서 주입이 된다.</li>\n</ul>\n</li>\n</ul>\n<p>Spring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject/@Resource를 사용하면 문제는 없을 것이나… 대부분은 @Autowired를 사용한다.</p>\n<h1><span id=\"di-구현방식\">DI 구현방식</span></h1>\n<h2><span id=\"constructor-injection\">Constructor Injection</span></h2>\n<p>생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.<br>\n이 방법은 xml 설정 시에 유용한 방법이다.<br>\n객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userRepository\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.user.UserRepository\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span>, <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.user.UserService\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">construct-args</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userRepository\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ref</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">construct-args</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"extension-constructor-injection\">Extension Constructor Injection</span></h2>\n<p>Spring 4에 추가된 DI방법이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>UserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.<br>\n어찌보면 당연한 내용 같은데…  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"setter-injection\">Setter Injection</span></h2>\n<p>Setter를 통해 DI하는 방법이다.<br>\n이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">setUserRepository</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"field-injection\">Field Injection</span></h2>\n<p>Spring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.<br>\n아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"용어-설명\">용어 설명</span></h1>\n<ul>\n<li>Bean\n<ul>\n<li>Spring Container에 등록 되는 POJO객체</li>\n<li>Spring Application의 Component들이 등록 된다.</li>\n<li>기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.</li>\n</ul>\n</li>\n<li>Bean Factory\n<ul>\n<li>Spring IoC를 담당하는 핵심 컨테이너</li>\n<li>Bean에 대한 등록/생성/조회/소멸을 관리한다.</li>\n<li>BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.</li>\n<li>대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)</li>\n</ul>\n</li>\n<li>Application Context\n<ul>\n<li>BeanFactory 인터페이스의 구현체 ()\n<ul>\n<li>정확히는 ListableBeanFactory</li>\n<li>Bean을 Listable하게 보관하는 인터페이스를 말한다.</li>\n</ul>\n</li>\n<li>BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.\n<ul>\n<li>ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.</li>\n<li>ApplicationEventPublisher - 이벤트 발생을 관장한다.</li>\n<li>MessageSource - properties파일을 통해 다국어 설정이 가능</li>\n<li>BeanLifecycle - Bean의 초기화, 소멸을 담당한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Configuration Meta Data\n<ul>\n<li>Application Context에서 IoC 설정을 위해 사용되는 메타정보</li>\n<li>컨테이너에 어떤 기능을 세팅할때 사용</li>\n<li>Bean 생성/구성할 경우에도 사용</li>\n<li>@Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능</li>\n</ul>\n</li>\n</ul>\n<h1><span id=\"bean-등록-방법\">Bean 등록 방법</span></h1>\n<h2><span id=\"component-scan\">Component-Scan</span></h2>\n<p>Spring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.<br>\nSpring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.<br>\n분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에<br>\n불필요한 메모리 할당이 이루어질 수 있다.<br>\n그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 <code>가장 많이 하는 설정</code>이 아닐까 싶다.</p>\n<ul>\n<li>@Component 종류\n<ul>\n<li>@Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)</li>\n<li>@Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)</li>\n<li>@Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)</li>\n<li>@Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)</li>\n</ul>\n</li>\n</ul>\n<h2><span id=\"servlet-contextxml\">Servlet-Context.xml</span></h2>\n<p>기존 Bean 생성을 xml로 등록하는 방식이다.<br>\n이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만…<br>\n보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.<br>\n위에서 언급한 <code>Component-scan</code>을 주로 사용하는 것이 좋다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"beanNameViewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.BeanNameViewResolver\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"order\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"internalResourceViewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/WEB-INF/views/\"</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"order\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"2\"</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"configuration\">@Configuration</span></h2>\n<p>xml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.<br>\n뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.<br>\nBean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 <code>@Bean</code> 어노테이션을 붙여주면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserService <span class=\"title\">userService</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//메소드 명이 기본적으로 Bean Name으로 추가된다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserService();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우<br>\n아주 유용한 방법이라 할 수 있겠다.</p>\n<h1><span id=\"bean-생명주기\">Bean 생명주기</span></h1>\n<p>Spring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.<br>\nBean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.</p>\n<p>Bean 생명주기 처리를 하는 방법은 3가지 방식이 있다.</p>\n<ol>\n<li>InitializingBean, DisposableBean 인터페이스 구현</li>\n<li>Bean정의 시 , 메소드 지정</li>\n<li>@PostConstruct, @PreDestroy Annotation 사용</li>\n</ol>\n<h2><span id=\"initializingbean-disposablebean-인터페이스-구현\">InitializingBean, DisposableBean 인터페이스 구현</span></h2>\n<p>InitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시<br>\n기능을 확장 할 수 있다.</p>\n<p>InitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에<br>\nSpring에 종속적이게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBeanClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span>, <span class=\"title\">DisposableBean</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection conn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//자원의 할당 처리</span></span><br><span class=\"line\">        conn = DBConnectionCaller.getConnection();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 생성 및 초기화 : afterPropertiesSet() 호출됨\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//주로 할당된 자원의 해제를 한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) conn.close();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 소멸 : destroy 호출됨\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"bean정의-시-메소드-지정\">Bean정의 시 , 메소드 지정</span></h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.TestBeanClass\"</span>                      </span></span><br><span class=\"line\"><span class=\"tag\">   <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"destroy\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>xml설정 파일 <bean>에서 <strong>init-method</strong> 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출</bean></li>\n<li>xml설정 파일 <bean>에서 <strong>destroy-method</strong> 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출</bean></li>\n</ul>\n<h2><span id=\"postconstruct-predestroy-annotation-사용\">@PostConstruct, @PreDestroy Annotation 사용</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBeanClass</span> </span>&#123;be</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection conn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//자원의 할당 처리</span></span><br><span class=\"line\">        conn = DBConnectionCaller.getConnection();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 생성 및 초기화\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//주로 할당된 자원의 해제를 한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) conn.close();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 소멸\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@PostConstuct, @PreDestroy 은 <code>JSR-250 Annotation</code> 기반이다 (한마디로 자바기반)<br>\n따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.</p>\n<p>@PostConstuct, @PreDestroy 을 사용하기 위해서는<br>\n<code>&lt;annotation-config/&gt;</code>설정이나, <code>@AnnotationDrivenConfig</code>어노테이션을 붙여줘야 한다.</p>\n<h1><span id=\"bean-scope\">Bean Scope</span></h1>\n<p><a href=\"https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html</a> 을 참고함</p>\n<ul>\n<li>Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.</li>\n<li>Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.</li>\n<li>Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용</li>\n<li>Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.<br>\n(이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)</li>\n<li>Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다.</li>\n</ul>\n<h1><span id=\"참조\">참조</span></h1>\n<p><a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring프레임워크소개와IoC및SpringIoC의개념-2.1IoC란무엇인가%3F</a><br>\n<a href=\"http://wiki.javajigi.net/pages/viewpage.action?pageId=281\" target=\"_blank\" rel=\"noopener\">http://wiki.javajigi.net/pages/viewpage.action?pageId=281</a><br>\n<a href=\"https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/</a><br>\n<a href=\"https://okky.kr/article/415474\" target=\"_blank\" rel=\"noopener\">https://okky.kr/article/415474</a><br>\n<a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=68\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=68</a><br>\n<a href=\"http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1</a><br>\n<a href=\"http://isstory83.tistory.com/91\" target=\"_blank\" rel=\"noopener\">http://isstory83.tistory.com/91</a><br>\n<a href=\"https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3\" target=\"_blank\" rel=\"noopener\">https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3</a><br>\n토비의 스프링 VOL.2 Spring IoC</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>IoC란?</h1>\n<p>Inversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.<br>\n보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.<br>\n하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며<br>\n개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.</p>\n<p>따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여<br>\n제어의 역전 (Inversion of Control)이라 불린다.</p>\n<h1>Container가 도데체 뭐람?</h1>\n<p><img src=\"./containers.jpg\" alt=\"containers\"></p>\n<p>개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다.<br>\nSpring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등… Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까?<br>\n위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다.<br>\n이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.<br>\n컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는… 컨테이너를 생각하는 것이 도움이 될 것 같다.<br>\n실제 프레임워크에서의 컨테이너도 같은 역할을 한다.</p>\n<p><strong>이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체</strong>라고 할 수 있다.</p>\n<p>위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면</p>\n<p>서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,<br>\n외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.</p>\n<p>Spring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.</p>\n<h1>DI란?</h1>\n<p>DI란 Dependency Injection의 의미로 IoC를 구현한 대표적인 예야<br>\nPojo 객체내의 종속적인 객체를 IoC Container에서 직접 객체를 Injection해주는 걸 의미해<br>\n스프링 개발에서는 99프로 DI방식을 통해 개발자가 직접 필요한 객체를 선언하지 않고<br>\nIoC Container에서 넣어줘서 사용해 —&gt; 이거는 Bean 초기화시에 이루어져<br>\nDL (Dependency Lookup) 이라는 기능도 있는데 이거는 거의 사용하지는 않아<br>\n이 기능은 IoC Container에서 Bean의 메타정보를 이용해서 개발자가 Bean을 직접 찾는 행위야</p>\n<p>DI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.<br>\nDI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.<br>\n개념 자체는 <code>IoC의 형태 중 하나</code>라고 볼 수 있다.</p>\n<p>DI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.<br>\n클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.</p>\n<p>Spring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며<br>\n객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.</p>\n<ol>\n<li>Constructor Injection</li>\n<li>Dependency Constructor Injection</li>\n<li>Setter Injection</li>\n<li>Field Injection</li>\n</ol>\n<h1>의존성 주입 Annotation</h1>\n<p>Spring/Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.</p>\n<ul>\n<li>@Autowired\n<ul>\n<li>Spring에서 지원하는 Annotation</li>\n<li><code>Type</code>에 맞춰서 주입이 된다.</li>\n<li>Interface에 상응하는 Bean이 2개 이상 인 경우에는 <code>@Qualifier(&quot;beanName&quot;)을 혼용</code>하여<br>\n필요한 Bean객체를 주입한다.</li>\n</ul>\n</li>\n<li>@Inject\n<ul>\n<li>Java에서 지원하는 Annotation</li>\n<li><code>Type</code>에 맞춰서 주입이 된다.</li>\n</ul>\n</li>\n<li>@Resource\n<ul>\n<li>Java에서 지원하는 Annotation</li>\n<li><code>이름</code>에 맞춰서 주입이 된다.</li>\n</ul>\n</li>\n</ul>\n<p>Spring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject/@Resource를 사용하면 문제는 없을 것이나… 대부분은 @Autowired를 사용한다.</p>\n<h1>DI 구현방식</h1>\n<h2>Constructor Injection</h2>\n<p>생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.<br>\n이 방법은 xml 설정 시에 유용한 방법이다.<br>\n객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userRepository\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.user.UserRepository\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span>, <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.user.UserService\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">construct-args</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userRepository\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ref</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">construct-args</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2>Extension Constructor Injection</h2>\n<p>Spring 4에 추가된 DI방법이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>UserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.<br>\n어찌보면 당연한 내용 같은데…  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Setter Injection</h2>\n<p>Setter를 통해 DI하는 방법이다.<br>\n이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">setUserRepository</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Field Injection</h2>\n<p>Spring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.<br>\n아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>용어 설명</h1>\n<ul>\n<li>Bean\n<ul>\n<li>Spring Container에 등록 되는 POJO객체</li>\n<li>Spring Application의 Component들이 등록 된다.</li>\n<li>기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.</li>\n</ul>\n</li>\n<li>Bean Factory\n<ul>\n<li>Spring IoC를 담당하는 핵심 컨테이너</li>\n<li>Bean에 대한 등록/생성/조회/소멸을 관리한다.</li>\n<li>BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.</li>\n<li>대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)</li>\n</ul>\n</li>\n<li>Application Context\n<ul>\n<li>BeanFactory 인터페이스의 구현체 ()\n<ul>\n<li>정확히는 ListableBeanFactory</li>\n<li>Bean을 Listable하게 보관하는 인터페이스를 말한다.</li>\n</ul>\n</li>\n<li>BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.\n<ul>\n<li>ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.</li>\n<li>ApplicationEventPublisher - 이벤트 발생을 관장한다.</li>\n<li>MessageSource - properties파일을 통해 다국어 설정이 가능</li>\n<li>BeanLifecycle - Bean의 초기화, 소멸을 담당한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Configuration Meta Data\n<ul>\n<li>Application Context에서 IoC 설정을 위해 사용되는 메타정보</li>\n<li>컨테이너에 어떤 기능을 세팅할때 사용</li>\n<li>Bean 생성/구성할 경우에도 사용</li>\n<li>@Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능</li>\n</ul>\n</li>\n</ul>\n<h1>Bean 등록 방법</h1>\n<h2>Component-Scan</h2>\n<p>Spring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.<br>\nSpring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.<br>\n분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에<br>\n불필요한 메모리 할당이 이루어질 수 있다.<br>\n그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 <code>가장 많이 하는 설정</code>이 아닐까 싶다.</p>\n<ul>\n<li>@Component 종류\n<ul>\n<li>@Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)</li>\n<li>@Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)</li>\n<li>@Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)</li>\n<li>@Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)</li>\n</ul>\n</li>\n</ul>\n<h2>Servlet-Context.xml</h2>\n<p>기존 Bean 생성을 xml로 등록하는 방식이다.<br>\n이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만…<br>\n보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.<br>\n위에서 언급한 <code>Component-scan</code>을 주로 사용하는 것이 좋다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"beanNameViewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.BeanNameViewResolver\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"order\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"internalResourceViewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/WEB-INF/views/\"</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"order\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"2\"</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2>@Configuration</h2>\n<p>xml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.<br>\n뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.<br>\nBean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 <code>@Bean</code> 어노테이션을 붙여주면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserService <span class=\"title\">userService</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//메소드 명이 기본적으로 Bean Name으로 추가된다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserService();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우<br>\n아주 유용한 방법이라 할 수 있겠다.</p>\n<h1>Bean 생명주기</h1>\n<p>Spring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.<br>\nBean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.</p>\n<p>Bean 생명주기 처리를 하는 방법은 3가지 방식이 있다.</p>\n<ol>\n<li>InitializingBean, DisposableBean 인터페이스 구현</li>\n<li>Bean정의 시 , 메소드 지정</li>\n<li>@PostConstruct, @PreDestroy Annotation 사용</li>\n</ol>\n<h2>InitializingBean, DisposableBean 인터페이스 구현</h2>\n<p>InitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시<br>\n기능을 확장 할 수 있다.</p>\n<p>InitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에<br>\nSpring에 종속적이게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBeanClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span>, <span class=\"title\">DisposableBean</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection conn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//자원의 할당 처리</span></span><br><span class=\"line\">        conn = DBConnectionCaller.getConnection();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 생성 및 초기화 : afterPropertiesSet() 호출됨\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//주로 할당된 자원의 해제를 한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) conn.close();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 소멸 : destroy 호출됨\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Bean정의 시 , 메소드 지정</h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.TestBeanClass\"</span>                      </span></span><br><span class=\"line\"><span class=\"tag\">   <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"destroy\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>xml설정 파일 <bean>에서 <strong>init-method</strong> 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출</bean></li>\n<li>xml설정 파일 <bean>에서 <strong>destroy-method</strong> 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출</bean></li>\n</ul>\n<h2>@PostConstruct, @PreDestroy Annotation 사용</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBeanClass</span> </span>&#123;be</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection conn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//자원의 할당 처리</span></span><br><span class=\"line\">        conn = DBConnectionCaller.getConnection();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 생성 및 초기화\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//주로 할당된 자원의 해제를 한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) conn.close();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 소멸\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@PostConstuct, @PreDestroy 은 <code>JSR-250 Annotation</code> 기반이다 (한마디로 자바기반)<br>\n따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.</p>\n<p>@PostConstuct, @PreDestroy 을 사용하기 위해서는<br>\n<code>&lt;annotation-config/&gt;</code>설정이나, <code>@AnnotationDrivenConfig</code>어노테이션을 붙여줘야 한다.</p>\n<h1>Bean Scope</h1>\n<p><a href=\"https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html</a> 을 참고함</p>\n<ul>\n<li>Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.</li>\n<li>Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.</li>\n<li>Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용</li>\n<li>Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.<br>\n(이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)</li>\n<li>Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다.</li>\n</ul>\n<h1>참조</h1>\n<p><a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring프레임워크소개와IoC및SpringIoC의개념-2.1IoC란무엇인가%3F</a><br>\n<a href=\"http://wiki.javajigi.net/pages/viewpage.action?pageId=281\" target=\"_blank\" rel=\"noopener\">http://wiki.javajigi.net/pages/viewpage.action?pageId=281</a><br>\n<a href=\"https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/</a><br>\n<a href=\"https://okky.kr/article/415474\" target=\"_blank\" rel=\"noopener\">https://okky.kr/article/415474</a><br>\n<a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=68\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=68</a><br>\n<a href=\"http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1</a><br>\n<a href=\"http://isstory83.tistory.com/91\" target=\"_blank\" rel=\"noopener\">http://isstory83.tistory.com/91</a><br>\n<a href=\"https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3\" target=\"_blank\" rel=\"noopener\">https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3</a><br>\n토비의 스프링 VOL.2 Spring IoC</p>\n"},{"title":"Application-Context와 Servlet-Context","subtitle":"AOP가 적용되지 않아서...","catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-10-21-spring-context","typora-copy-images-to":"./2018-10-21-spring-context","date":"2018-10-21T08:00:54.000Z","header-img":null,"_content":"\n\n\n# 들어가며\n\n회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.\n문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.\ncore가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,\n각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.\nBean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.\n\n이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.\n\n\n\n# Web Application Context\n\n![img](./99A34C3359FEAA8410.png)\n\n\n\n## Application Context\n\n* Web Application 최상단에 위치하고 있는 Context\n* Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context\n* Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한\n  설정정보를 담은 파일 (Bean 선언 등..)\n* Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)\n* 특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)\n* 서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.\n* **Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.**\n\n\n\n## Servlet-Context (servlet-context.xml)\n\n* Servlet 단위로 생성되는 context\n* Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일\n  (Interceptor, Bean생성, ViewResolver등..)\n* URL설정이 있는 Bean을 생성 (@Controller, Interceptor)\n* Application Context를 자신의 부모 Context로 사용한다.\n* Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,\n  Servlet Context에 선언된 Bean을 사용한다.\n* Bean 찾는 순서 \n  * Servlet Context에서 먼저 찾는다.\n  * 만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.\n* **Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.**\n\n\n\n# web.xml 설정 살펴보기\n\n## web.xml 이란\n\n서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.\n여기서 서블릿 클래스를 등록하는 곳의 이름을 `Web application deployment descriptor`라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 `web.xml`이다. `web.xml` 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.\n\nDD는 WAS 구동 시 `/WEB-INF` 디렉토리에 존재하는 `web.xml`을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n <!-- The definition of the Root Spring Container shared by all Servlets and Filters -->\n      <!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 -->\n      <context-param>  \n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/spring/applicationContext.xml</param-value>\n      </context-param>\n      \n      <!-- Creates the Spring Container shared by all Servlets and Filters -->\n      <!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 -->\n      <listener>\n          <listener-class>\n              org.springframework.web.context.ContextLoaderListener\n          </listener-class>\n      </listener>\n    \n      <!-- Processes application requests -->\n      <servlet> \n          <servlet-name>dispatcherServlet</servlet-name>\n          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \n          <init-param>\n              <param-name>contextConfigLocation</param-name> \n              <param-value>\n                  <!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 -->\n                  /WEB-INF/spring/appServlet/servlet-context.xml\n              </param-value>\n          </init-param>\n          <load-on-startup>1</load-on-startup>\n      </servlet>\n            \n    <!-- dispatcherServlet 대한 url-pattern을 정의 \n        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 -->\n      <servlet-mapping>  \n            <servlet-name>dispatcherServlet</servlet-name>\n            <url-pattern>/</url-pattern>\n      </servlet-mapping>\n</web-app>\n~~~\n\n\n\n# 그래서 Context 설정은 어떻게 쓰냐?\n\nSpring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.\n\n* Application Context\n  * 공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등..)\n  * 각 Servlet에서 공유할 수 있는 Bean\n* Servlet Context\n  * Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등..)\n\n가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.\n각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.\n\n\n\nApplicationContext.xml\n\n~~~xml\n<context:component-scan base-package=\"com.myapp.core, com.myapp.app\">\n    <!-- Component-scan대상에서 @Controller annotation Class는 제외한다. -->\n    <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> \n</context:component-scan>\n~~~\n\n\n\nServlet-Context.xml\n\n~~~xml\n<context:component-scan base-package=\"com.myapp.app\" use-default-filters=\"false\">\n    <!-- Component-scan대상은 @Controller annotation Class만 scan한다. -->\n    <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> \n</context:component-scan>\n~~~\n\nServlet-Context.xml 설정 시, `use-default-filters` 속성을 `false`로 처리 하였다.\n`use-default-filters` 속성은 원래 `default가 true`인데, \n@Compont Annotation(@Controller, @Service, @Repository등..) 의 `클래스를 자동으로 Bean으로 등록해 주는 filter속성`이다. \n따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.\n\n\n\n# 참조\n\n* http://hoonmaro.tistory.com/31\n* https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html","source":"_posts/2018-10-21-spring-context.md","raw":"---\ntitle: Application-Context와 Servlet-Context\nsubtitle: AOP가 적용되지 않아서...\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\n  - WAS\ntypora-root-url: ./2018-10-21-spring-context\ntypora-copy-images-to: ./2018-10-21-spring-context\ndate: 2018-10-21 17:00:54\nheader-img:\n---\n\n\n\n# 들어가며\n\n회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.\n문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.\ncore가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,\n각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.\nBean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.\n\n이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.\n\n\n\n# Web Application Context\n\n![img](./99A34C3359FEAA8410.png)\n\n\n\n## Application Context\n\n* Web Application 최상단에 위치하고 있는 Context\n* Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context\n* Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한\n  설정정보를 담은 파일 (Bean 선언 등..)\n* Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)\n* 특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)\n* 서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.\n* **Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.**\n\n\n\n## Servlet-Context (servlet-context.xml)\n\n* Servlet 단위로 생성되는 context\n* Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일\n  (Interceptor, Bean생성, ViewResolver등..)\n* URL설정이 있는 Bean을 생성 (@Controller, Interceptor)\n* Application Context를 자신의 부모 Context로 사용한다.\n* Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,\n  Servlet Context에 선언된 Bean을 사용한다.\n* Bean 찾는 순서 \n  * Servlet Context에서 먼저 찾는다.\n  * 만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.\n* **Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.**\n\n\n\n# web.xml 설정 살펴보기\n\n## web.xml 이란\n\n서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.\n여기서 서블릿 클래스를 등록하는 곳의 이름을 `Web application deployment descriptor`라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 `web.xml`이다. `web.xml` 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.\n\nDD는 WAS 구동 시 `/WEB-INF` 디렉토리에 존재하는 `web.xml`을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n <!-- The definition of the Root Spring Container shared by all Servlets and Filters -->\n      <!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 -->\n      <context-param>  \n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/spring/applicationContext.xml</param-value>\n      </context-param>\n      \n      <!-- Creates the Spring Container shared by all Servlets and Filters -->\n      <!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 -->\n      <listener>\n          <listener-class>\n              org.springframework.web.context.ContextLoaderListener\n          </listener-class>\n      </listener>\n    \n      <!-- Processes application requests -->\n      <servlet> \n          <servlet-name>dispatcherServlet</servlet-name>\n          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \n          <init-param>\n              <param-name>contextConfigLocation</param-name> \n              <param-value>\n                  <!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 -->\n                  /WEB-INF/spring/appServlet/servlet-context.xml\n              </param-value>\n          </init-param>\n          <load-on-startup>1</load-on-startup>\n      </servlet>\n            \n    <!-- dispatcherServlet 대한 url-pattern을 정의 \n        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 -->\n      <servlet-mapping>  \n            <servlet-name>dispatcherServlet</servlet-name>\n            <url-pattern>/</url-pattern>\n      </servlet-mapping>\n</web-app>\n~~~\n\n\n\n# 그래서 Context 설정은 어떻게 쓰냐?\n\nSpring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.\n\n* Application Context\n  * 공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등..)\n  * 각 Servlet에서 공유할 수 있는 Bean\n* Servlet Context\n  * Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등..)\n\n가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.\n각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.\n\n\n\nApplicationContext.xml\n\n~~~xml\n<context:component-scan base-package=\"com.myapp.core, com.myapp.app\">\n    <!-- Component-scan대상에서 @Controller annotation Class는 제외한다. -->\n    <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> \n</context:component-scan>\n~~~\n\n\n\nServlet-Context.xml\n\n~~~xml\n<context:component-scan base-package=\"com.myapp.app\" use-default-filters=\"false\">\n    <!-- Component-scan대상은 @Controller annotation Class만 scan한다. -->\n    <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> \n</context:component-scan>\n~~~\n\nServlet-Context.xml 설정 시, `use-default-filters` 속성을 `false`로 처리 하였다.\n`use-default-filters` 속성은 원래 `default가 true`인데, \n@Compont Annotation(@Controller, @Service, @Repository등..) 의 `클래스를 자동으로 Bean으로 등록해 주는 filter속성`이다. \n따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.\n\n\n\n# 참조\n\n* http://hoonmaro.tistory.com/31\n* https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html","slug":"2018-10-21-spring-context","published":1,"updated":"2018-10-21T09:40:14.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjniq3kph000ou0yahumvbthn","content":"<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.<br>\n문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.<br>\ncore가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,<br>\n각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.<br>\nBean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.</p>\n<p>이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.</p>\n<h1><span id=\"web-application-context\">Web Application Context</span></h1>\n<p><img src=\"./99A34C3359FEAA8410.png\" alt=\"img\"></p>\n<h2><span id=\"application-context\">Application Context</span></h2>\n<ul>\n<li>Web Application 최상단에 위치하고 있는 Context</li>\n<li>Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context</li>\n<li>Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한<br>\n설정정보를 담은 파일 (Bean 선언 등…)</li>\n<li>Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)</li>\n<li>특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)</li>\n<li>서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.</li>\n<li><strong>Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.</strong></li>\n</ul>\n<h2><span id=\"servlet-context-servlet-contextxml\">Servlet-Context (servlet-context.xml)</span></h2>\n<ul>\n<li>Servlet 단위로 생성되는 context</li>\n<li>Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일<br>\n(Interceptor, Bean생성, ViewResolver등…)</li>\n<li>URL설정이 있는 Bean을 생성 (@Controller, Interceptor)</li>\n<li>Application Context를 자신의 부모 Context로 사용한다.</li>\n<li>Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,<br>\nServlet Context에 선언된 Bean을 사용한다.</li>\n<li>Bean 찾는 순서\n<ul>\n<li>Servlet Context에서 먼저 찾는다.</li>\n<li>만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.</li>\n</ul>\n</li>\n<li><strong>Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.</strong></li>\n</ul>\n<h1><span id=\"webxml-설정-살펴보기\">web.xml 설정 살펴보기</span></h1>\n<h2><span id=\"webxml-이란\">web.xml 이란</span></h2>\n<p>서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.<br>\n여기서 서블릿 클래스를 등록하는 곳의 이름을 <code>Web application deployment descriptor</code>라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 <code>web.xml</code>이다. <code>web.xml</code> 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.</p>\n<p>DD는 WAS 구동 시 <code>/WEB-INF</code> 디렉토리에 존재하는 <code>web.xml</code>을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span>&gt;</span></span><br><span class=\"line\"> <span class=\"comment\">&lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>/WEB-INF/spring/applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">              org.springframework.web.context.ContextLoaderListener</span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Processes application requests --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"comment\">&lt;!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 --&gt;</span></span><br><span class=\"line\">                  /WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dispatcherServlet 대한 url-pattern을 정의 </span></span><br><span class=\"line\"><span class=\"comment\">        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"그래서-context-설정은-어떻게-쓰냐\">그래서 Context 설정은 어떻게 쓰냐?</span></h1>\n<p>Spring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.</p>\n<ul>\n<li>Application Context\n<ul>\n<li>공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등…)</li>\n<li>각 Servlet에서 공유할 수 있는 Bean</li>\n</ul>\n</li>\n<li>Servlet Context\n<ul>\n<li>Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등…)</li>\n</ul>\n</li>\n</ul>\n<p>가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.<br>\n각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.</p>\n<p>ApplicationContext.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.myapp.core, com.myapp.app\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Component-scan대상에서 @Controller annotation Class는 제외한다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:exclude-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Controller\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Servlet-Context.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.myapp.app\"</span> <span class=\"attr\">use-default-filters</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Component-scan대상은 @Controller annotation Class만 scan한다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Controller\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Servlet-Context.xml 설정 시, <code>use-default-filters</code> 속성을 <code>false</code>로 처리 하였다.<br>\n<code>use-default-filters</code> 속성은 원래 <code>default가 true</code>인데,<br>\n@Compont Annotation(@Controller, @Service, @Repository등…) 의 <code>클래스를 자동으로 Bean으로 등록해 주는 filter속성</code>이다.<br>\n따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.</p>\n<h1><span id=\"참조\">참조</span></h1>\n<ul>\n<li><a href=\"http://hoonmaro.tistory.com/31\" target=\"_blank\" rel=\"noopener\">http://hoonmaro.tistory.com/31</a></li>\n<li><a href=\"https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html\" target=\"_blank\" rel=\"noopener\">https://plus4070.github.io/nhn entertainment devdays/Web.xml.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.<br>\n문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.<br>\ncore가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,<br>\n각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.<br>\nBean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.</p>\n<p>이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.</p>\n<h1>Web Application Context</h1>\n<p><img src=\"./99A34C3359FEAA8410.png\" alt=\"img\"></p>\n<h2>Application Context</h2>\n<ul>\n<li>Web Application 최상단에 위치하고 있는 Context</li>\n<li>Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context</li>\n<li>Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한<br>\n설정정보를 담은 파일 (Bean 선언 등…)</li>\n<li>Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)</li>\n<li>특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)</li>\n<li>서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.</li>\n<li><strong>Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.</strong></li>\n</ul>\n<h2>Servlet-Context (servlet-context.xml)</h2>\n<ul>\n<li>Servlet 단위로 생성되는 context</li>\n<li>Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일<br>\n(Interceptor, Bean생성, ViewResolver등…)</li>\n<li>URL설정이 있는 Bean을 생성 (@Controller, Interceptor)</li>\n<li>Application Context를 자신의 부모 Context로 사용한다.</li>\n<li>Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,<br>\nServlet Context에 선언된 Bean을 사용한다.</li>\n<li>Bean 찾는 순서\n<ul>\n<li>Servlet Context에서 먼저 찾는다.</li>\n<li>만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.</li>\n</ul>\n</li>\n<li><strong>Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.</strong></li>\n</ul>\n<h1>web.xml 설정 살펴보기</h1>\n<h2>web.xml 이란</h2>\n<p>서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.<br>\n여기서 서블릿 클래스를 등록하는 곳의 이름을 <code>Web application deployment descriptor</code>라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 <code>web.xml</code>이다. <code>web.xml</code> 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.</p>\n<p>DD는 WAS 구동 시 <code>/WEB-INF</code> 디렉토리에 존재하는 <code>web.xml</code>을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span>&gt;</span></span><br><span class=\"line\"> <span class=\"comment\">&lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>/WEB-INF/spring/applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">              org.springframework.web.context.ContextLoaderListener</span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Processes application requests --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"comment\">&lt;!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 --&gt;</span></span><br><span class=\"line\">                  /WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dispatcherServlet 대한 url-pattern을 정의 </span></span><br><span class=\"line\"><span class=\"comment\">        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1>그래서 Context 설정은 어떻게 쓰냐?</h1>\n<p>Spring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.</p>\n<ul>\n<li>Application Context\n<ul>\n<li>공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등…)</li>\n<li>각 Servlet에서 공유할 수 있는 Bean</li>\n</ul>\n</li>\n<li>Servlet Context\n<ul>\n<li>Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등…)</li>\n</ul>\n</li>\n</ul>\n<p>가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.<br>\n각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.</p>\n<p>ApplicationContext.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.myapp.core, com.myapp.app\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Component-scan대상에서 @Controller annotation Class는 제외한다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:exclude-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Controller\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Servlet-Context.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.myapp.app\"</span> <span class=\"attr\">use-default-filters</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Component-scan대상은 @Controller annotation Class만 scan한다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Controller\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Servlet-Context.xml 설정 시, <code>use-default-filters</code> 속성을 <code>false</code>로 처리 하였다.<br>\n<code>use-default-filters</code> 속성은 원래 <code>default가 true</code>인데,<br>\n@Compont Annotation(@Controller, @Service, @Repository등…) 의 <code>클래스를 자동으로 Bean으로 등록해 주는 filter속성</code>이다.<br>\n따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.</p>\n<h1>참조</h1>\n<ul>\n<li><a href=\"http://hoonmaro.tistory.com/31\" target=\"_blank\" rel=\"noopener\">http://hoonmaro.tistory.com/31</a></li>\n<li><a href=\"https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html\" target=\"_blank\" rel=\"noopener\">https://plus4070.github.io/nhn entertainment devdays/Web.xml.html</a></li>\n</ul>\n"},{"layout":"posts","title":"@Import와 @ImportResource Annotation","date":"2018-10-21T09:53:38.000Z","subtitle":"xml을 Java Config로 변경하기","catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-10-21-java-config-import","typora-copy-images-to":"./2018-10-21-java-config-import","_content":"\n\n\n# 들어가며\n\n회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.\n아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고 \n최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.\n그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.\n\n\n\n# @Import\n\n@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.\n사용하는 개념은 기존에 xml 파일을 import하는.. <import /> 구분과 동일하게 사용된다.\n\n예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면..\n\n\n\n**RedisClusterConfig**\n\n~~~java\n@Configuration\n@Import(value = RedisShardsConfig.class) // Redis Shard정보에 대한 Config이다.\npublic class RedisClusterConfig {\n\n\t@Autowired\n\t@Qualifier(\"redisConfig\")\n\tprivate Properties redisConfig;\n\n\t@Bean\n\tpublic GenericObjectPoolConfig jedisPoolConfig() {\n\t\tJedisPoolConfig poolConfig = new JedisPoolConfig();\n\t    poolConfig.setMaxTotal(redisConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setMaxIdle(commonConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setMinIdle(commonConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setNumTestsPerEvictionRun(2);\n\t\tpoolConfig.setTestOnBorrow(true);\n\t\tpoolConfig.setTestOnReturn(false);\n\t\tpoolConfig.setTestWhileIdle(true);\n\t\tpoolConfig.setTimeBetweenEvictionRunsMillis(300000);\n\t\treturn poolConfig;\n\t}\n    \n    //따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.\n\t@Bean\n\tpublic ShardedJedisPool masterShardedPool(GenericObjectPoolConfig jedisPoolConfig, List<JedisShardInfo> redisMasterShards) {\n\t\treturn new ShardedJedisPool(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);\n\t}\n\n\t@Bean\n\tpublic ShardedJedisPool slaveShardedPool(GenericObjectPoolConfig jedisPoolConfig, List<JedisShardInfo> redisSlaveShards) {\n\t\treturn new ShardedJedisPool(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);\n\t}\n}\n~~~\n\n\n\n**RedisShardsConfig.java**\n\n~~~java\n@Configuration\npublic class RedisShardsConfig {\n\n    @Autowired\n\t@Qualifier(\"redisConfig\")\n\tprivate Properties redisConfig;\n    \n\t@Bean\n\tpublic List<JedisShardInfo> redisMasterShards() {\n        \n        String url = redisConfig.getProperty(\"redis.cluster.url\");\n        //Integer 형변환 생략함...(길어져서 안보임)\n        Integer masterPort1 = redisConfig.getProperty(\"redis.cluster.master.port1\");\n        Integer masterPort2 = redisConfig.getProperty(\"redis.cluster.master.port2\");\n        Integer masterPort3 = redisConfig.getProperty(\"redis.cluster.master.port3\");\n        \n        String masterShardKey1 = redisConfig.getProperty(\"redis.cluster.master.key1\");\n        String masterShardKey2 = redisConfig.getProperty(\"redis.cluster.master.key2\");\n        String masterShardKey3 = redisConfig.getProperty(\"redis.cluster.master.key3\");\n        \n\t\treturn new ArrayList<JedisShardInfo>() {\n\t\t\t{\n\t\t\t\tadd(new JedisShardInfo(url, masterPort1, masterShardKey1));\n\t\t\t\tadd(new JedisShardInfo(url, masterPort2, masterShardKey2));\n\t\t\t\tadd(new JedisShardInfo(url, masterPort3, masterShardKey3));\n\t\t\t}\n\t\t};\n\t}\n\n\t@Bean\n\tpublic List<JedisShardInfo> redisSlaveShards() {\n        \n        String url = redisConfig.getProperty(\"redis.cluster.url\");\n        //Integer 형변환 생략함...(길어져서 안보임)\n        Integer slavePort1 = redisConfig.getProperty(\"redis.cluster.slave.port1\");\n        Integer slavePort2 = redisConfig.getProperty(\"redis.cluster.slave.port2\");\n        Integer slavePort3 = redisConfig.getProperty(\"redis.cluster.slave.port3\");\n        \n        String slaveShardKey1 = redisConfig.getProperty(\"redis.cluster.slave.key1\");\n        String slaveShardKey2 = redisConfig.getProperty(\"redis.cluster.slave.key2\");\n        String slaveShardKey3 = redisConfig.getProperty(\"redis.cluster.slave.key3\");\n        \n\t\treturn new ArrayList<JedisShardInfo>() {\n\t\t\t{\n\t\t\t\tadd(new JedisShardInfo(url, slavePort1, slaveShardKey1));\n\t\t\t\tadd(new JedisShardInfo(url, slavePort2, slaveShardKey2));\n\t\t\t\tadd(new JedisShardInfo(url, slavePort3, slaveShardKey3));\n\t\t\t}\n\t\t};\n\t}\n}\n~~~\n\n\n\nRedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.\nRedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다. \n이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.\n이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.\nxml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.\n\n\n\n# @ImportResource\n\n모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들...)\n\n그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.\n사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.\n\n예시는 아래와 같다.\n\n\n\n~~~java\n@Configuration\n@ImportResource(value = {\n\t\t\"classpath:applicationContextForExternalMember.xml\",    //External-Member\n\t\t\"classpath*:applicationContextForExternalAPI.xml\",      //External-API\n\t\t\"classpath*:applicationContextForExternalLogger.xml\"    //External-Logger\n})\npublic class ExternalConfig {\n}\n~~~\n\n 위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.","source":"_posts/2018-10-21-java-config-import.md","raw":"---\nlayout: posts\ntitle: \"@Import와 @ImportResource Annotation\"\ndate: 2018-10-21 18:53:38\nsubtitle: xml을 Java Config로 변경하기\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\n  - Java-Config\ntypora-root-url: ./2018-10-21-java-config-import\ntypora-copy-images-to: ./2018-10-21-java-config-import\n---\n\n\n\n# 들어가며\n\n회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.\n아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고 \n최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.\n그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.\n\n\n\n# @Import\n\n@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.\n사용하는 개념은 기존에 xml 파일을 import하는.. <import /> 구분과 동일하게 사용된다.\n\n예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면..\n\n\n\n**RedisClusterConfig**\n\n~~~java\n@Configuration\n@Import(value = RedisShardsConfig.class) // Redis Shard정보에 대한 Config이다.\npublic class RedisClusterConfig {\n\n\t@Autowired\n\t@Qualifier(\"redisConfig\")\n\tprivate Properties redisConfig;\n\n\t@Bean\n\tpublic GenericObjectPoolConfig jedisPoolConfig() {\n\t\tJedisPoolConfig poolConfig = new JedisPoolConfig();\n\t    poolConfig.setMaxTotal(redisConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setMaxIdle(commonConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setMinIdle(commonConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setNumTestsPerEvictionRun(2);\n\t\tpoolConfig.setTestOnBorrow(true);\n\t\tpoolConfig.setTestOnReturn(false);\n\t\tpoolConfig.setTestWhileIdle(true);\n\t\tpoolConfig.setTimeBetweenEvictionRunsMillis(300000);\n\t\treturn poolConfig;\n\t}\n    \n    //따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.\n\t@Bean\n\tpublic ShardedJedisPool masterShardedPool(GenericObjectPoolConfig jedisPoolConfig, List<JedisShardInfo> redisMasterShards) {\n\t\treturn new ShardedJedisPool(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);\n\t}\n\n\t@Bean\n\tpublic ShardedJedisPool slaveShardedPool(GenericObjectPoolConfig jedisPoolConfig, List<JedisShardInfo> redisSlaveShards) {\n\t\treturn new ShardedJedisPool(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);\n\t}\n}\n~~~\n\n\n\n**RedisShardsConfig.java**\n\n~~~java\n@Configuration\npublic class RedisShardsConfig {\n\n    @Autowired\n\t@Qualifier(\"redisConfig\")\n\tprivate Properties redisConfig;\n    \n\t@Bean\n\tpublic List<JedisShardInfo> redisMasterShards() {\n        \n        String url = redisConfig.getProperty(\"redis.cluster.url\");\n        //Integer 형변환 생략함...(길어져서 안보임)\n        Integer masterPort1 = redisConfig.getProperty(\"redis.cluster.master.port1\");\n        Integer masterPort2 = redisConfig.getProperty(\"redis.cluster.master.port2\");\n        Integer masterPort3 = redisConfig.getProperty(\"redis.cluster.master.port3\");\n        \n        String masterShardKey1 = redisConfig.getProperty(\"redis.cluster.master.key1\");\n        String masterShardKey2 = redisConfig.getProperty(\"redis.cluster.master.key2\");\n        String masterShardKey3 = redisConfig.getProperty(\"redis.cluster.master.key3\");\n        \n\t\treturn new ArrayList<JedisShardInfo>() {\n\t\t\t{\n\t\t\t\tadd(new JedisShardInfo(url, masterPort1, masterShardKey1));\n\t\t\t\tadd(new JedisShardInfo(url, masterPort2, masterShardKey2));\n\t\t\t\tadd(new JedisShardInfo(url, masterPort3, masterShardKey3));\n\t\t\t}\n\t\t};\n\t}\n\n\t@Bean\n\tpublic List<JedisShardInfo> redisSlaveShards() {\n        \n        String url = redisConfig.getProperty(\"redis.cluster.url\");\n        //Integer 형변환 생략함...(길어져서 안보임)\n        Integer slavePort1 = redisConfig.getProperty(\"redis.cluster.slave.port1\");\n        Integer slavePort2 = redisConfig.getProperty(\"redis.cluster.slave.port2\");\n        Integer slavePort3 = redisConfig.getProperty(\"redis.cluster.slave.port3\");\n        \n        String slaveShardKey1 = redisConfig.getProperty(\"redis.cluster.slave.key1\");\n        String slaveShardKey2 = redisConfig.getProperty(\"redis.cluster.slave.key2\");\n        String slaveShardKey3 = redisConfig.getProperty(\"redis.cluster.slave.key3\");\n        \n\t\treturn new ArrayList<JedisShardInfo>() {\n\t\t\t{\n\t\t\t\tadd(new JedisShardInfo(url, slavePort1, slaveShardKey1));\n\t\t\t\tadd(new JedisShardInfo(url, slavePort2, slaveShardKey2));\n\t\t\t\tadd(new JedisShardInfo(url, slavePort3, slaveShardKey3));\n\t\t\t}\n\t\t};\n\t}\n}\n~~~\n\n\n\nRedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.\nRedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다. \n이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.\n이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.\nxml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.\n\n\n\n# @ImportResource\n\n모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들...)\n\n그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.\n사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.\n\n예시는 아래와 같다.\n\n\n\n~~~java\n@Configuration\n@ImportResource(value = {\n\t\t\"classpath:applicationContextForExternalMember.xml\",    //External-Member\n\t\t\"classpath*:applicationContextForExternalAPI.xml\",      //External-API\n\t\t\"classpath*:applicationContextForExternalLogger.xml\"    //External-Logger\n})\npublic class ExternalConfig {\n}\n~~~\n\n 위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.","slug":"2018-10-21-java-config-import","published":1,"updated":"2018-10-21T10:28:15.034Z","_id":"cjniqb73a0003uzyag70uet06","comments":1,"photos":[],"link":"","content":"<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.<br>\n아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고<br>\n최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.<br>\n그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.</p>\n<h1><span id=\"import\">@Import</span></h1>\n<p>@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.<br>\n사용하는 개념은 기존에 xml 파일을 import하는… <import> 구분과 동일하게 사용된다.</import></p>\n<p>예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면…</p>\n<p><strong>RedisClusterConfig</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(value = RedisShardsConfig.class) <span class=\"comment\">// Redis Shard정보에 대한 Config이다.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisClusterConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"redisConfig\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Properties redisConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> GenericObjectPoolConfig <span class=\"title\">jedisPoolConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tJedisPoolConfig poolConfig = <span class=\"keyword\">new</span> JedisPoolConfig();</span><br><span class=\"line\">\t    poolConfig.setMaxTotal(redisConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setMaxIdle(commonConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setMinIdle(commonConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setNumTestsPerEvictionRun(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestOnReturn(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestWhileIdle(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTimeBetweenEvictionRunsMillis(<span class=\"number\">300000</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> poolConfig;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ShardedJedisPool <span class=\"title\">masterShardedPool</span><span class=\"params\">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisMasterShards)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ShardedJedisPool(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ShardedJedisPool <span class=\"title\">slaveShardedPool</span><span class=\"params\">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisSlaveShards)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ShardedJedisPool(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>RedisShardsConfig.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisShardsConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"redisConfig\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Properties redisConfig;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;JedisShardInfo&gt; <span class=\"title\">redisMasterShards</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String url = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.url\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class=\"line\">        Integer masterPort1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port1\"</span>);</span><br><span class=\"line\">        Integer masterPort2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port2\"</span>);</span><br><span class=\"line\">        Integer masterPort3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        String masterShardKey1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key1\"</span>);</span><br><span class=\"line\">        String masterShardKey2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key2\"</span>);</span><br><span class=\"line\">        String masterShardKey3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort1, masterShardKey1));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort2, masterShardKey2));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort3, masterShardKey3));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;JedisShardInfo&gt; <span class=\"title\">redisSlaveShards</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String url = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.url\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class=\"line\">        Integer slavePort1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port1\"</span>);</span><br><span class=\"line\">        Integer slavePort2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port2\"</span>);</span><br><span class=\"line\">        Integer slavePort3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        String slaveShardKey1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key1\"</span>);</span><br><span class=\"line\">        String slaveShardKey2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key2\"</span>);</span><br><span class=\"line\">        String slaveShardKey3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort1, slaveShardKey1));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort2, slaveShardKey2));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort3, slaveShardKey3));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.<br>\nRedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다.<br>\n이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.<br>\n이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.<br>\nxml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.</p>\n<h1><span id=\"importresource\">@ImportResource</span></h1>\n<p>모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들…)</p>\n<p>그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.<br>\n사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.</p>\n<p>예시는 아래와 같다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource</span>(value = &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath:applicationContextForExternalMember.xml\"</span>,    <span class=\"comment\">//External-Member</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath*:applicationContextForExternalAPI.xml\"</span>,      <span class=\"comment\">//External-API</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath*:applicationContextForExternalLogger.xml\"</span>    <span class=\"comment\">//External-Logger</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExternalConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.<br>\n아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고<br>\n최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.<br>\n그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.</p>\n<h1>@Import</h1>\n<p>@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.<br>\n사용하는 개념은 기존에 xml 파일을 import하는… <import> 구분과 동일하게 사용된다.</import></p>\n<p>예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면…</p>\n<p><strong>RedisClusterConfig</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(value = RedisShardsConfig.class) <span class=\"comment\">// Redis Shard정보에 대한 Config이다.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisClusterConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"redisConfig\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Properties redisConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> GenericObjectPoolConfig <span class=\"title\">jedisPoolConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tJedisPoolConfig poolConfig = <span class=\"keyword\">new</span> JedisPoolConfig();</span><br><span class=\"line\">\t    poolConfig.setMaxTotal(redisConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setMaxIdle(commonConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setMinIdle(commonConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setNumTestsPerEvictionRun(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestOnReturn(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestWhileIdle(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTimeBetweenEvictionRunsMillis(<span class=\"number\">300000</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> poolConfig;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ShardedJedisPool <span class=\"title\">masterShardedPool</span><span class=\"params\">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisMasterShards)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ShardedJedisPool(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ShardedJedisPool <span class=\"title\">slaveShardedPool</span><span class=\"params\">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisSlaveShards)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ShardedJedisPool(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>RedisShardsConfig.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisShardsConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"redisConfig\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Properties redisConfig;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;JedisShardInfo&gt; <span class=\"title\">redisMasterShards</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String url = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.url\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class=\"line\">        Integer masterPort1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port1\"</span>);</span><br><span class=\"line\">        Integer masterPort2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port2\"</span>);</span><br><span class=\"line\">        Integer masterPort3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        String masterShardKey1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key1\"</span>);</span><br><span class=\"line\">        String masterShardKey2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key2\"</span>);</span><br><span class=\"line\">        String masterShardKey3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort1, masterShardKey1));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort2, masterShardKey2));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort3, masterShardKey3));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;JedisShardInfo&gt; <span class=\"title\">redisSlaveShards</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String url = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.url\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class=\"line\">        Integer slavePort1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port1\"</span>);</span><br><span class=\"line\">        Integer slavePort2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port2\"</span>);</span><br><span class=\"line\">        Integer slavePort3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        String slaveShardKey1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key1\"</span>);</span><br><span class=\"line\">        String slaveShardKey2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key2\"</span>);</span><br><span class=\"line\">        String slaveShardKey3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort1, slaveShardKey1));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort2, slaveShardKey2));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort3, slaveShardKey3));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.<br>\nRedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다.<br>\n이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.<br>\n이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.<br>\nxml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.</p>\n<h1>@ImportResource</h1>\n<p>모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들…)</p>\n<p>그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.<br>\n사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.</p>\n<p>예시는 아래와 같다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource</span>(value = &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath:applicationContextForExternalMember.xml\"</span>,    <span class=\"comment\">//External-Member</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath*:applicationContextForExternalAPI.xml\"</span>,      <span class=\"comment\">//External-API</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath*:applicationContextForExternalLogger.xml\"</span>    <span class=\"comment\">//External-Logger</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExternalConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.</p>\n"}],"PostAsset":[{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide setting.png","slug":"ide setting.png","post":"cjniq3kn40007u0yavuz4re5s","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide-setting.png","slug":"ide-setting.png","post":"cjniq3kn40007u0yavuz4re5s","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide설정.png","slug":"ide설정.png","post":"cjniq3kn40007u0yavuz4re5s","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/image-20180831235454808.png","slug":"image-20180831235454808.png","post":"cjniq3ko0000fu0yayb0e87cb","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921153027741.png","slug":"image-20180921153027741.png","post":"cjniq3kp0000ku0yaywyrqn6o","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/image-20180831234615081.png","slug":"image-20180831234615081.png","post":"cjniq3ko0000fu0yayb0e87cb","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-29-java-exception/Exception-Class.png","slug":"Exception-Class.png","post":"cjniq3koq000ju0yaapesoq3x","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-21-spring-ioc-2/containers.jpg","slug":"containers.jpg","post":"cjniq3kp8000mu0ya5qxzt46t","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-21-spring-context/99A34C3359FEAA8410.png","slug":"99A34C3359FEAA8410.png","post":"cjniq3kph000ou0yahumvbthn","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor/filter-chain.gif","slug":"filter-chain.gif","post":"cjniq3knh000au0yaodzzadr0","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor/spring-request-lifecycle.jpg","slug":"spring-request-lifecycle.jpg","post":"cjniq3knh000au0yaodzzadr0","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet/Front-controller-pattern.png","slug":"Front-controller-pattern.png","post":"cjniq3knl000cu0ya6ckht259","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet/dispatcher-servlet-lifecycle.jpg","slug":"dispatcher-servlet-lifecycle.jpg","post":"cjniq3knl000cu0ya6ckht259","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/Dispatch-Seq.jpg","slug":"Dispatch-Seq.jpg","post":"cjniq3kn70008u0yau0i3ve6l","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/RequestMappingHandlerAdapter.png","slug":"RequestMappingHandlerAdapter.png","post":"cjniq3kn70008u0yau0i3ve6l","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/argument-resolver-result.png","slug":"argument-resolver-result.png","post":"cjniq3kn70008u0yau0i3ve6l","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-01-servlet/Servlet-life-cycle.png","slug":"Servlet-life-cycle.png","post":"cjniq3koi000gu0yab5q93u6i","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-01-servlet/jspToServlet.jpeg","slug":"jspToServlet.jpeg","post":"cjniq3koi000gu0yab5q93u6i","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-01-servlet/servlet.png","slug":"servlet.png","post":"cjniq3koi000gu0yab5q93u6i","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/Exception-Class.png","slug":"Exception-Class.png","post":"cjniq3ko0000fu0yayb0e87cb","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/spring-mvc-request.jpg","slug":"spring-mvc-request.jpg","post":"cjniq3ko0000fu0yayb0e87cb","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ipv4.png","slug":"ipv4.png","post":"cjniq3kn40007u0yavuz4re5s","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ipv6.png","slug":"ipv6.png","post":"cjniq3kn40007u0yavuz4re5s","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921142925583.png","slug":"image-20180921142925583.png","post":"cjniq3kp0000ku0yaywyrqn6o","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921142928480.png","slug":"image-20180921142928480.png","post":"cjniq3kp0000ku0yaywyrqn6o","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921143924788.png","slug":"image-20180921143924788.png","post":"cjniq3kp0000ku0yaywyrqn6o","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921145310488.png","slug":"image-20180921145310488.png","post":"cjniq3kp0000ku0yaywyrqn6o","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjniq3kn40007u0yavuz4re5s","tag_id":"cjniq3kna0009u0ya48xrng81","_id":"cjniq3knx000eu0yarmyzndvk"},{"post_id":"cjniq3kn70008u0yau0i3ve6l","tag_id":"cjniq3kna0009u0ya48xrng81","_id":"cjniq3kop000iu0ya2l2pnjwo"},{"post_id":"cjniq3kp0000ku0yaywyrqn6o","tag_id":"cjniq3kna0009u0ya48xrng81","_id":"cjniq3kph000nu0yal4a9ci97"},{"post_id":"cjniq3kp8000mu0ya5qxzt46t","tag_id":"cjniq3kna0009u0ya48xrng81","_id":"cjniq3kpj000qu0yabvvfle1o"},{"post_id":"cjniq3knh000au0yaodzzadr0","tag_id":"cjniq3kna0009u0ya48xrng81","_id":"cjniq3kpj000ru0yagoio1cs6"},{"post_id":"cjniq3knh000au0yaodzzadr0","tag_id":"cjniq3kp1000lu0yauisghj33","_id":"cjniq3kpj000tu0yaml10kqxv"},{"post_id":"cjniq3knl000cu0ya6ckht259","tag_id":"cjniq3kna0009u0ya48xrng81","_id":"cjniq3kpj000uu0yai1gwp1ls"},{"post_id":"cjniq3knl000cu0ya6ckht259","tag_id":"cjniq3kpj000pu0yafmz545zq","_id":"cjniq3kpk000wu0yaiydtv190"},{"post_id":"cjniq3ko0000fu0yayb0e87cb","tag_id":"cjniq3kna0009u0ya48xrng81","_id":"cjniq3kpk000xu0yaak1n7p9j"},{"post_id":"cjniq3ko0000fu0yayb0e87cb","tag_id":"cjniq3kp1000lu0yauisghj33","_id":"cjniq3kpl000yu0yaomg3q2ux"},{"post_id":"cjniq3koi000gu0yab5q93u6i","tag_id":"cjniq3kna0009u0ya48xrng81","_id":"cjniq3kpl0010u0yapieeckrk"},{"post_id":"cjniq3koi000gu0yab5q93u6i","tag_id":"cjniq3kpk000vu0ya90s9romu","_id":"cjniq3kpl0011u0yaiamti4n9"},{"post_id":"cjniq3koq000ju0yaapesoq3x","tag_id":"cjniq3kpl000zu0yawwro7s7n","_id":"cjniq3kpl0013u0yaddh3av68"},{"post_id":"cjniq3kph000ou0yahumvbthn","tag_id":"cjniq3kna0009u0ya48xrng81","_id":"cjniq3kpm0014u0ya63vgm6mv"},{"post_id":"cjniq3kph000ou0yahumvbthn","tag_id":"cjniq3kpl0012u0yajqe0u04m","_id":"cjniq3kpm0015u0ya33w1tpki"},{"post_id":"cjniqb73a0003uzyag70uet06","tag_id":"cjniq3kna0009u0ya48xrng81","_id":"cjniqb73c0004uzyarfyn7urc"},{"post_id":"cjniqb73a0003uzyag70uet06","tag_id":"cjniq71g40001uuyait4b2fqs","_id":"cjniqb73c0005uzya1j3jc474"}],"Tag":[{"name":"Spring","_id":"cjniq3kna0009u0ya48xrng81"},{"name":"Spring Core","_id":"cjniq3kp1000lu0yauisghj33"},{"name":"core","_id":"cjniq3kpj000pu0yafmz545zq"},{"name":"J2EE","_id":"cjniq3kpk000vu0ya90s9romu"},{"name":"Java","_id":"cjniq3kpl000zu0yawwro7s7n"},{"name":"WAS","_id":"cjniq3kpl0012u0yajqe0u04m"},{"name":"Java-Config","_id":"cjniq71g40001uuyait4b2fqs"}]}}