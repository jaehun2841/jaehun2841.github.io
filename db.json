{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/googleb6989b051cadc23a.html","path":"googleb6989b051cadc23a.html","modified":0,"renderable":0},{"_id":"source/naver06b931b9a92d9d3d74ae0c39217e61a6.html","path":"naver06b931b9a92d9d3d74ae0c39217e61a6.html","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/melody/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/melody/source/js/hexo-theme-melody.js","path":"js/hexo-theme-melody.js","modified":0,"renderable":1},{"_id":"themes/melody/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/melody/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/melody/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/melody/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/melody/source/js/copy.js","path":"js/copy.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/fireworks.js","path":"js/fireworks.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/head.js","path":"js/head.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/scroll.js","path":"js/scroll.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/transition.js","path":"js/transition.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/anime.min.js","path":"js/third-party/anime.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","path":"js/third-party/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.min.js","path":"js/third-party/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","path":"js/third-party/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.min.js","path":"js/third-party/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","path":"js/third-party/reveal/markdown.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","path":"js/third-party/reveal/marked.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","path":"js/third-party/reveal/math.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","path":"js/third-party/reveal/notes.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","path":"js/third-party/reveal/zoom.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","path":"js/third-party/reveal/head.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","path":"js/third-party/reveal/reveal.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","path":"js/third-party/reveal/highlight.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"8fd730ec9fe935cb51ddc9f0a1ae5e5f0c2ca919","modified":1545482377693},{"_id":"source/404.md","hash":"e1b324a2960603dffa13d9cc431e2c18b179bc7d","modified":1545476248705},{"_id":"source/CNAME","hash":"1dfdd576ea7d7b762128ec2c90801bcda66bcf09","modified":1545476248705},{"_id":"source/googleb6989b051cadc23a.html","hash":"9112b0956896de444cec8ceed3613e54bd5f5960","modified":1545481805359},{"_id":"source/naver06b931b9a92d9d3d74ae0c39217e61a6.html","hash":"3c9a2eb1ba1d6c67e9b6947fa36e5eaad723831b","modified":1545482938707},{"_id":"source/robots.txt","hash":"03f5fd7e89c6aca4e5c67b5b2242a9b0310f1f70","modified":1545483103172},{"_id":"themes/melody/.eslintignore","hash":"55f36fe3be2270ae2746eddbb2982e4e1472bc31","modified":1545468816710},{"_id":"themes/melody/.eslintrc","hash":"cfcd1b454efdd6cc1a0d43be7bc79027b84531f7","modified":1545468816711},{"_id":"themes/melody/.gitignore","hash":"7ed73f0edfb682b12a42070fd2730d5d712ec2fa","modified":1545468816711},{"_id":"themes/melody/.travis.demo.yml","hash":"4482d40a58a035ef96888dfc4ed96c861b8f78a5","modified":1545468816711},{"_id":"themes/melody/LICENSE","hash":"c372b56b7553dafd2d8a8abf12d0dd71b4e2bfc0","modified":1545468816712},{"_id":"themes/melody/README.md","hash":"a3053d735e36ad9f9a588a1d130e21b54683553c","modified":1545468816712},{"_id":"themes/melody/_config.yml","hash":"ab669a6ae992684a392cc17222c4bffa35b09fdc","modified":1545473773143},{"_id":"themes/melody/package.json","hash":"495095311146f977731de6ad30d608505f9c423f","modified":1545468816721},{"_id":"themes/melody/stylus_format.json","hash":"2fbe63b06901d202773457d7ce658ab6aa85d02b","modified":1545468816737},{"_id":"themes/melody/scripts/hexo-plugins.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545468816721},{"_id":"source/_data/melody.yml","hash":"948bed3cbfa927650647253f011b84a3569b5202","modified":1546707897026},{"_id":"source/about/index.md","hash":"54ffc05e694cda8607487a0e1d05bf38fbd14963","modified":1543303412407},{"_id":"source/archive/index.md","hash":"279ff19668395f5c6b26417da99d2c1f3ecd5886","modified":1543303412408},{"_id":"source/categories/index.md","hash":"e5f6af6f3a9be4e1493be10d66d323ac979ce7b8","modified":1545476248707},{"_id":"source/_posts/.DS_Store","hash":"99922dba981b12468724b0569c5d90dc1ca8650d","modified":1546857192120},{"_id":"source/_posts/2018-07-15-spring-aop.md","hash":"b2416e01e18a07908eb9983f2792c1a47ca173e2","modified":1543303412352},{"_id":"source/_posts/2018-07-20-spring-aop2.md","hash":"47fed6344f090ef86329a1114640afd668d328ee","modified":1543303412353},{"_id":"source/_posts/2018-07-21-spring-aop3.md","hash":"f9ee48b62b7e238213e643ca4b1f98c3c9c557fa","modified":1543303412353},{"_id":"source/_posts/2018-07-22-spring-aop4.md","hash":"a04545bdb9b27330fc63adf73bcca59129396fb8","modified":1543303412353},{"_id":"source/_posts/2018-07-24-spring-aop5.md","hash":"244f3300ca2f2610da52abedc1b29dc82b0fcfd5","modified":1543303412353},{"_id":"source/_posts/2018-08-10-httprequest-client-ip.md","hash":"3828a9d80ea5beb9f0348adc359eeb73c9728474","modified":1543303412354},{"_id":"source/_posts/2018-08-10-spring-argument-resolver.md","hash":"5ccaaba3637ce3eb22d5eb4eb796e2daf1e9b51c","modified":1543303412359},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet.md","hash":"31fd90d36ec76907d8ca9708a84690e86f3faa73","modified":1543303412363},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor.md","hash":"668125a8a615eb222a744caef8963d8a9a3d45be","modified":1543303412364},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception.md","hash":"6a4831c905f03bf985978ce75e75624c8a72cb77","modified":1543303412365},{"_id":"source/_posts/2018-08-29-java-exception.md","hash":"823c4e7364092fdcb3c05d65e5d5f2adb46f667e","modified":1543303412369},{"_id":"source/_posts/2018-09-01-servlet.md","hash":"7e7fe53b730a53f7475690bdc13e869aba4233b3","modified":1545476310510},{"_id":"source/_posts/2018-09-12-spring-ioc.md","hash":"3bdcfbfa9b0dc0e52bc1bc57d093e183b6375708","modified":1543303412371},{"_id":"source/_posts/2018-09-21-spring-ioc-2.md","hash":"c82ec3a2ef1964441b8ea15319016ac979ffe439","modified":1543303412375},{"_id":"source/_posts/2018-10-03-spring-ehcache.md","hash":"fcc1e0de33d16711cbb936df876284594db880f1","modified":1545476315335},{"_id":"source/_posts/2018-10-21-java-config-import.md","hash":"adbb213bd6f1d5bf09d7bdfaf5eeb40f3841af51","modified":1543303412380},{"_id":"source/_posts/2018-10-21-spring-context.md","hash":"c7d0baa58fcca09953bc2f1c05d1827930587e9a","modified":1543303412380},{"_id":"source/_posts/2018-11-04-ehcache-config-for-springboot.md","hash":"8a6af63923ece161c8db98b82364661c6fdce215","modified":1543303412381},{"_id":"source/_posts/2018-11-04-ehcache-config-for-springframework.md","hash":"1c465c63386e2fb807c20a6959900f2ba88d613b","modified":1543303412382},{"_id":"source/_posts/2018-11-21-spel-expression.md","hash":"5d069c8c4e2c9efbb425e565764d0fdada936761","modified":1543303412382},{"_id":"source/_posts/2018-11-25-docker-1.md","hash":"8fc172004d4c7e4b47605a57e0f2b7a89397e888","modified":1544258194232},{"_id":"source/_posts/2018-11-25-spel-expression-2.md","hash":"6a504181692ee9c91fd00f64fa3c141be248eae9","modified":1543303412394},{"_id":"source/_posts/2018-11-28-docker-2.md","hash":"48b2e77ce6b235e0de5a9110ad65c56e2907e571","modified":1544258189329},{"_id":"source/_posts/2018-12-01-docker-3.md","hash":"c9e9b2f63cebd29a5e190625e5be7828c6c1dfa8","modified":1544258185490},{"_id":"source/_posts/2018-12-01-docker-4.md","hash":"3d5d9bc5ddeab50fcd4e46b3a699419fa94e0551","modified":1544257975264},{"_id":"source/_posts/2018-12-01-docker-5.md","hash":"4866b6c38606fae2b8baca63b7171470a1c4fcfc","modified":1544257975265},{"_id":"source/_posts/2018-12-01-docker-6.md","hash":"c103ac3c9dd88684ab51fa39c9e94ee5c27ddda2","modified":1544257975273},{"_id":"source/_posts/2018-12-02-docker-7.md","hash":"99e83303fae310202eeba2684c7a31a67c5fa4b0","modified":1544257975280},{"_id":"source/_posts/2018-12-02-docker-8.md","hash":"8e6f88526320e2627414fb092cd668ec71d7a4d6","modified":1544257975287},{"_id":"source/_posts/2018-12-03-docker-10.md","hash":"eede1238361315058f79a691365f620fb8f38b40","modified":1544257975298},{"_id":"source/_posts/2018-12-03-redis-stats.md","hash":"b5060888096cb4264a720e3ec294b7242d6243fa","modified":1544257975318},{"_id":"source/_posts/2018-12-07-docker-11.md","hash":"2035c2565d8a18b385a8feb28275d9d805d8622d","modified":1544257975323},{"_id":"source/_posts/2018-12-16-remind.md","hash":"aa29330905a3ae545115ddd75c93faea98f3ed57","modified":1545475827360},{"_id":"source/_posts/2018-12-30-mybatis-returnInstanceForEmptyRow.md","hash":"c3d92387c0f58223cadb24b8d93a805554361110","modified":1546157641173},{"_id":"source/_posts/effective-java-item1.md","hash":"bfc3ee9898c7a550691897a27e2b462023eec17d","modified":1546867929406},{"_id":"source/_posts/effective-java-item10.md","hash":"d3ceb15243dacb5ada30b0eeb8a9312e5b9134b8","modified":1547379511426},{"_id":"source/_posts/effective-java-item11.md","hash":"c9777dbc181d3239294bd9bc9b1856311f6532b6","modified":1547379511426},{"_id":"source/_posts/effective-java-item12.md","hash":"eeb33bd3aec7b8551f9c849cf516b780b35421e5","modified":1547379511427},{"_id":"source/_posts/effective-java-item13.md","hash":"fb334b540761ef7e1506697ac5dfbd778f24dbb7","modified":1547379511427},{"_id":"source/_posts/effective-java-item14.md","hash":"65430110fe8d6bbb11b1e818086611627b856f96","modified":1547379712703},{"_id":"source/_posts/effective-java-item15.md","hash":"37e7aa111edf193237fb7ef6874f589e4a3d69f1","modified":1548679585349},{"_id":"source/_posts/effective-java-item16.md","hash":"4a7f2ef31a7aa882bd7322bb57349fa10e20b3ef","modified":1548679585349},{"_id":"source/_posts/effective-java-item17.md","hash":"3d2a759115d2d34a25e04f1d4be47b622e2911c1","modified":1548679585349},{"_id":"source/_posts/effective-java-item2.md","hash":"a17350870861fdd9fbeb74bb69f5da3351c902d8","modified":1546867929406},{"_id":"source/_posts/effective-java-item3.md","hash":"721af741fc5ec1c360f03c32582e061631a6e8a9","modified":1546867929407},{"_id":"source/_posts/effective-java-item31.md","hash":"01c296ab075e87ed4d2902c9f21373711061a4a1","modified":1548679573572},{"_id":"source/_posts/effective-java-item32.md","hash":"96af87a1202c976c31564d847f23a8795fe17f6c","modified":1548759580321},{"_id":"source/_posts/effective-java-item4.md","hash":"e2ab1fea3eb8bda174f6f0bdd0a43ba080ab710b","modified":1546867929407},{"_id":"source/_posts/effective-java-item5.md","hash":"541654ec36a718355b7c329fa663c1bb78889e1e","modified":1546867929407},{"_id":"source/_posts/effective-java-item6.md","hash":"b33c1d9239ae791ac05001ac50f81e1ebce8fcf9","modified":1546867929407},{"_id":"source/_posts/effective-java-item7.md","hash":"a43ea08c7733abf36f7f8af5f27779be172dfc34","modified":1546867929408},{"_id":"source/_posts/effective-java-item8.md","hash":"06f0c9c256d1bdc98757251f74de6c5d8df236c6","modified":1546867929408},{"_id":"source/_posts/effective-java-item9.md","hash":"a8db4c5e1b2fcbf42ff23d58e015bcbbfb5f0d79","modified":1546867929408},{"_id":"source/_posts/java-object-copy.md","hash":"8ee65fc0c6383be48f9ee470040b896f1db42a35","modified":1547379511427},{"_id":"source/tags/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1545473001053},{"_id":"source/tags/index.md","hash":"ff11912b61115e8710b077f6821359301fc95d62","modified":1545476248708},{"_id":"themes/melody/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1545468816705},{"_id":"themes/melody/.git/config","hash":"dbc9583c30072395a2108cf3384f87973212d53c","modified":1545468816707},{"_id":"themes/melody/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1545468812852},{"_id":"themes/melody/.git/index","hash":"ac36bb52911a0ad574ac6e0b87c917505bdf715a","modified":1547312896371},{"_id":"themes/melody/.git/packed-refs","hash":"4b833d2d7cd3998194a70b678ea3418fd0fc4451","modified":1545468816703},{"_id":"themes/melody/.github/ISSUE_TEMPLATE.md","hash":"c5f14119189d9930fd7afd6e8822592fcd314ecf","modified":1545468816711},{"_id":"themes/melody/.vscode/launch.json","hash":"3098e8e395a33fa130747d2fd104a21278f266a6","modified":1545468816711},{"_id":"themes/melody/.vscode/settings.json","hash":"2e4acade0812cbeaf1363971c696a1d52d4f05ba","modified":1545468816711},{"_id":"themes/melody/languages/default.yml","hash":"f50471d72cd682673affd4b8ced45ffbcb528d3a","modified":1545468816712},{"_id":"themes/melody/languages/en.yml","hash":"f50471d72cd682673affd4b8ced45ffbcb528d3a","modified":1545468816713},{"_id":"themes/melody/languages/zh-Hans.yml","hash":"5e29425c8fdf9ff42818ea9cd852d7e63bc074d0","modified":1545468816713},{"_id":"themes/melody/layout/archive.pug","hash":"2133e9f369dac19b9f843fc956521f864ace7567","modified":1545468816713},{"_id":"themes/melody/layout/category.pug","hash":"ea5f82d69e586f293f428f3b237c17bf873b4f03","modified":1545468816713},{"_id":"themes/melody/layout/gallery.pug","hash":"c083a7bbf5f46305daed74632aef3403b7d94dc7","modified":1545468816713},{"_id":"themes/melody/layout/index.pug","hash":"5e969c09fa5902829ad0b14c0af8d432bd4c7078","modified":1545468816720},{"_id":"themes/melody/layout/page.pug","hash":"6bb4336f74784679ac3f8691b0cce427f2282e02","modified":1545468816720},{"_id":"themes/melody/layout/post.pug","hash":"84268639485e56638f07805f65b965caf69c201a","modified":1545468816720},{"_id":"themes/melody/layout/slides.pug","hash":"1e84a92d5b854dd233e0b511d59c1cd7c8d647a1","modified":1545468816720},{"_id":"themes/melody/layout/tag.pug","hash":"ca333911bc97bc9d3eba6e1bc05e96b209ecedfb","modified":1545468816720},{"_id":"themes/melody/scripts/gallery-tag.js","hash":"74e2e95f8daec619578f4b7dd1ed77cd5907f37e","modified":1545468816721},{"_id":"themes/melody/scripts/replace-config.js","hash":"7476015a4e091203c3048c5377ec5d67439520fa","modified":1545468816721},{"_id":"themes/melody/source/favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1545468816725},{"_id":"themes/melody/source/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545468816726},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/Dispatch-Seq.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1543303412359},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/argument-resolver-result.png","hash":"cd37d456fa0edc6c814db3e9a2cdfe77ebf11fa9","modified":1543303412362},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet/Front-controller-pattern.png","hash":"62befacb5ce536303e605341fc7dbf103172526d","modified":1543303412363},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor/filter-chain.gif","hash":"e9bbc8316a3611e64194628fb5f2d524be1ccf56","modified":1543303412364},{"_id":"source/_posts/2018-09-01-servlet/Servlet-life-cycle.png","hash":"25e5eba2e087ee76504a5ac69e0541dd5f97b020","modified":1543303412370},{"_id":"source/_posts/2018-09-01-servlet/jspToServlet.jpeg","hash":"df8c145eca3f082d95dd99d3e391406f75b7ea21","modified":1543303412371},{"_id":"source/_posts/2018-09-01-servlet/servlet.png","hash":"fcd04673f2b14d367a6c6dd3f97fdb6f8a348476","modified":1543303412371},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921142925583.png","hash":"66ef48b35f6b60d2788ea4aba67dd00b5bc481e3","modified":1543303412372},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921142928480.png","hash":"66ef48b35f6b60d2788ea4aba67dd00b5bc481e3","modified":1543303412372},{"_id":"source/_posts/2018-10-03-spring-ehcache/17110B4350CC5EC51D-20181011233534455.jpeg","hash":"cf45ea68e69cb2fe93b744283c00e6a4f26e1ed4","modified":1543303412377},{"_id":"source/_posts/2018-10-03-spring-ehcache/17110B4350CC5EC51D.jpeg","hash":"cf45ea68e69cb2fe93b744283c00e6a4f26e1ed4","modified":1543303412378},{"_id":"source/_posts/2018-10-03-spring-ehcache/EHCACHE.png","hash":"c57ac4d44f0068d9bc08c350ad8b40d9603574ec","modified":1543303412378},{"_id":"source/_posts/2018-11-25-docker-1/docker-logo.png","hash":"de9a2af4d09e151d367db146df980b33a7fdc63f","modified":1544257975255},{"_id":"source/_posts/2018-11-28-docker-2/docker-permission.png","hash":"51131b8ff5e6726a157e42eb65ea18c2b0ec3942","modified":1544257975261},{"_id":"source/_posts/2018-11-28-docker-2/sudo-docker.png","hash":"581b0ee3bc92733ca6f80f6a54ffab6ad31acf47","modified":1544257975263},{"_id":"source/_posts/2018-12-01-docker-5/docker-bridge-2.PNG","hash":"2512c39cc226d4e05ae794907b97e7d6e44a8761","modified":1544257975265},{"_id":"source/_posts/2018-12-01-docker-5/docker0-interface.PNG","hash":"2d428ea97af6669a0a4d1028cdbe6f95a135f744","modified":1544257975268},{"_id":"source/_posts/2018-12-01-docker-5/httpd.PNG","hash":"500c3df0646b0e75899bfe190ae8b96c75659a8e","modified":1544257975268},{"_id":"source/_posts/2018-12-01-docker-5/none.PNG","hash":"da2ba5a819657d541f5d0e95dbe4c520931b0727","modified":1544257975271},{"_id":"source/_posts/2018-12-01-docker-5/redis1.PNG","hash":"e6efda0548f75f771d1a8d7b20be99fb8692e13d","modified":1544257975272},{"_id":"source/_posts/2018-12-01-docker-5/redis2.PNG","hash":"79fdbb784fc48aab811ed72d04bf35f08ac0fc1a","modified":1544257975273},{"_id":"source/_posts/2018-12-01-docker-6/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1543746764272},{"_id":"source/_posts/2018-12-01-docker-6/redis-replication-3746317.PNG","hash":"8caa36e87414247064714936b9af876d874aca35","modified":1544257975276},{"_id":"source/_posts/2018-12-01-docker-6/redis-replication2-3746337.PNG","hash":"5cde66124d7038ba1a83d24669ca3355fd1a0989","modified":1544257975276},{"_id":"source/_posts/2018-12-01-docker-7/Redis-failover-2.PNG","hash":"bb74a8e222ba9a0a562d8690f870f1040629e40c","modified":1544257975279},{"_id":"source/_posts/2018-12-01-docker-7/sentinel.PNG","hash":"fe37b42c26a4db9830a7127f04da31af3c90df3c","modified":1544257975280},{"_id":"source/_posts/2018-12-02-docker-7/Redis-failover-1.PNG","hash":"adc978cd9eecc1f8a0a47d34380ce22ae966357a","modified":1544257975281},{"_id":"source/_posts/2018-12-02-docker-7/Redis-failover-2.PNG","hash":"bb74a8e222ba9a0a562d8690f870f1040629e40c","modified":1544257975282},{"_id":"source/_posts/2018-12-02-docker-7/redis-failover-3-3748019.PNG","hash":"e1cdc97e0c0ed35f11696c8973748f81c287fd92","modified":1544257975282},{"_id":"source/_posts/2018-12-02-docker-7/redis-failover-3.PNG","hash":"e1cdc97e0c0ed35f11696c8973748f81c287fd92","modified":1544257975283},{"_id":"source/_posts/2018-12-02-docker-7/redis-failover-4.PNG","hash":"330b09dd521316edf16b5c414e04e13edc065737","modified":1544257975283},{"_id":"source/_posts/2018-12-02-docker-7/sentinel.PNG","hash":"fe37b42c26a4db9830a7127f04da31af3c90df3c","modified":1544257975287},{"_id":"source/_posts/2018-12-03-docker-10/cluster-add-node-slave.PNG","hash":"e7bb488dc166dddb71884469f1ab2fb753d37eb0","modified":1544257975301},{"_id":"source/_posts/2018-12-03-docker-10/cluster-add.PNG","hash":"943e466193e86100be4fab4da3b9ad24b0206415","modified":1544257975302},{"_id":"source/_posts/2018-12-03-docker-10/cluster-nodes.png","hash":"37bbc99a5ee8993f6f3cd8a2d2ad01f041a366ca","modified":1544257975303},{"_id":"source/_posts/2018-12-03-docker-10/cluster-keys-command.PNG","hash":"3dbb7daf0afe49dde718afe0ce3dd40b424dc13b","modified":1544257975303},{"_id":"source/_posts/2018-12-03-docker-10/cluster-setting.PNG","hash":"bf70eb41b2e2eae6efeee0577ecb0eaf9512eb48","modified":1544257975305},{"_id":"source/_posts/2018-12-03-docker-10/cluster-setting2.PNG","hash":"27a637923d165e7241b84a5ff6905de8c31a3416","modified":1544257975306},{"_id":"source/_posts/2018-12-03-docker-10/failover-1.png","hash":"c80825e762bd45ded53053f0f2bd524bee905662","modified":1544257975307},{"_id":"source/_posts/2018-12-03-docker-10/failover2.png","hash":"33dc8caa5294b26c312a4649ba55f881ec173b92","modified":1544257975307},{"_id":"source/_posts/2018-12-03-docker-10/master-del-fail.png","hash":"b0bb322e93303d86c39db47a4dd602f9b9a60965","modified":1544257975308},{"_id":"source/_posts/2018-12-03-docker-10/master-del-success.png","hash":"c8cfb7a9cb151ab40e0ff562e09a9b62c53bfb6e","modified":1544257975308},{"_id":"source/_posts/2018-12-03-docker-10/master-down.png","hash":"95320a81532f8af28eb5d283dbda5a199d93ded3","modified":1544257975309},{"_id":"source/_posts/2018-12-03-docker-10/new-redis-cluster.PNG","hash":"8b8169360cdcafa875651ec878a47654f07121ba","modified":1544257975310},{"_id":"source/_posts/2018-12-03-docker-10/new-redis-cluster2.PNG","hash":"6981767ae02254569491068467f620b7c6759ca2","modified":1544257975311},{"_id":"source/_posts/2018-12-03-docker-10/reshard-test-1-3831920.PNG","hash":"4c43d69370b02825abd08e47385aabc351e6d479","modified":1544257975312},{"_id":"source/_posts/2018-12-03-docker-10/reshard-test-1.PNG","hash":"4c43d69370b02825abd08e47385aabc351e6d479","modified":1544257975312},{"_id":"source/_posts/2018-12-03-docker-10/reshard-test-3.PNG","hash":"9fda0eac90672348ad9bc547765508984dd1292a","modified":1544257975315},{"_id":"source/_posts/2018-12-03-docker-10/slave-add-result.png","hash":"34f8cf92d1688f9910d3848ce06b1030782f5873","modified":1544257975315},{"_id":"source/_posts/2018-12-03-docker-10/slave-del-result.png","hash":"b1caf48dfd7bed8572acdeba9eda425a628f2a4a","modified":1544257975316},{"_id":"source/_posts/2018-12-03-docker-10/slave-del.png","hash":"4055cbb30be190704f4ff6ff65141c59583a582d","modified":1544257975317},{"_id":"source/_posts/2018-12-03-docker-10/sub-reshard.PNG","hash":"6c0733bbb8d107faea29f0037cd690ff7f589785","modified":1544257975318},{"_id":"source/_posts/2018-12-03-redis-stats/redis-stat-web2.PNG","hash":"b20a8a2345327e68a2e111e8f81a1e043acd0205","modified":1544257975323},{"_id":"source/_posts/2018-12-03-redis-stats/redis-stat-web.PNG","hash":"613514acb2e69f6fc74001816f83e79a33091507","modified":1544257975322},{"_id":"source/_posts/2018-12-30-mybatis-returnInstanceForEmptyRow/all_element_are_null.png","hash":"bab9af461169b64821fe5c5abd1c75207782463f","modified":1546155833296},{"_id":"source/_posts/java-object-copy/clone.jpg","hash":"fa9a14cc4aef02365781de7561dae80c940c4c56","modified":1547379511428},{"_id":"themes/melody/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1545468812852},{"_id":"themes/melody/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1545468812852},{"_id":"themes/melody/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1545468812853},{"_id":"themes/melody/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1545468812853},{"_id":"themes/melody/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1545468812853},{"_id":"themes/melody/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1545468812852},{"_id":"themes/melody/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1545468812852},{"_id":"themes/melody/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1545468812854},{"_id":"themes/melody/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1545468812853},{"_id":"themes/melody/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1545468812853},{"_id":"themes/melody/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1545468812854},{"_id":"themes/melody/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1545468812852},{"_id":"themes/melody/.git/logs/HEAD","hash":"b05e2f542a26596d8e044a34783a282252c2e92b","modified":1545468816706},{"_id":"themes/melody/layout/includes/additional-js.pug","hash":"307400d70a7dd259bfa38074ca8f4a2173f8a8b4","modified":1545468816714},{"_id":"themes/melody/layout/includes/config.pug","hash":"b55265d49832decb34d57f222deb64f04cc9aa12","modified":1545468816715},{"_id":"themes/melody/layout/includes/footer.pug","hash":"0e9f1778f021f1c205f0b1be83014fba576797af","modified":1545468816716},{"_id":"themes/melody/layout/includes/head.pug","hash":"4e301e441c5279795eca1d8c088905a48d40a9ad","modified":1545468816716},{"_id":"themes/melody/layout/includes/header.pug","hash":"cba312acd94934596e2f6b70f20cfb63c7099b88","modified":1545468816716},{"_id":"themes/melody/layout/includes/layout.pug","hash":"a5ce123fcfc0b8b441e73822d8a764f389e4790d","modified":1545468816716},{"_id":"themes/melody/layout/includes/nav.pug","hash":"f6aa2a23675700098ebcb4e8c991e69da8aefdea","modified":1545468816717},{"_id":"themes/melody/layout/includes/pagination.pug","hash":"556d055e2f0c30d41ec16ef7943bd3227afcdfd1","modified":1545468816717},{"_id":"themes/melody/layout/includes/recent-posts.pug","hash":"aefcb3462d1b9ed2fb8d16414a4f580fc4e7a4e7","modified":1545468816717},{"_id":"themes/melody/layout/includes/sidebar.pug","hash":"9035d96124b936a3592d1b0ff7ece938884ba46e","modified":1545468816719},{"_id":"themes/melody/source/css/index.styl","hash":"111ec52cde3e5fae92cf61dc2a1bd8726b3aa8f9","modified":1545468816725},{"_id":"themes/melody/source/css/var.styl","hash":"bd6ea71543a39a4b255db5281f591f04a81feb5d","modified":1545468816725},{"_id":"themes/melody/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1545468816725},{"_id":"themes/melody/source/img/avatar.png","hash":"a44601fac9a81dd7e392d05ea5ddc65c96b051df","modified":1545468816726},{"_id":"themes/melody/source/js/copy.js","hash":"cfae08721664d19cf0059172b994c0a2e253d334","modified":1545468816726},{"_id":"themes/melody/source/js/fancybox.js","hash":"0c2c506559129a5108893cf054b9aa46fe878fc3","modified":1545468816726},{"_id":"themes/melody/source/js/fireworks.js","hash":"5e3da1344966d5d6328a410cad69e92297699f3b","modified":1545468816726},{"_id":"themes/melody/source/js/head.js","hash":"212a32f824cadea0167bf4204c9714df5b7e5f5d","modified":1545468816726},{"_id":"themes/melody/source/js/scroll.js","hash":"73d57e7cf9921ba5724ad48b8d0e8b25dbce059f","modified":1545468816727},{"_id":"themes/melody/source/js/sidebar.js","hash":"a42109c5a69dedc87e1aaf8cb2383fd43069677e","modified":1545468816727},{"_id":"themes/melody/source/js/transition.js","hash":"998c3bb6523a248d4dd4d747510c03a914a6378d","modified":1545468816736},{"_id":"themes/melody/source/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1545468816736},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ipv4.png","hash":"bee74710d25633b4e34472e1ed796ca6ea9c6c60","modified":1543303412358},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ipv6.png","hash":"b48a91102ad1481ef1d0c7a87ba774a255a1a780","modified":1543303412359},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet/dispatcher-servlet-lifecycle.jpg","hash":"52c983fadcf1cb7a6121885ea13a0944d9b4131f","modified":1543303412363},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor/spring-request-lifecycle.jpg","hash":"45c54cf5ba571c2061920fa1222af49a4520cb32","modified":1543303412365},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/Exception-Class.png","hash":"97084943599629350623ab0ef20e32d22ced4500","modified":1543303412366},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/spring-mvc-request.jpg","hash":"45c54cf5ba571c2061920fa1222af49a4520cb32","modified":1543303412368},{"_id":"source/_posts/2018-08-29-java-exception/Exception-Class.png","hash":"97084943599629350623ab0ef20e32d22ced4500","modified":1543303412370},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921143924788.png","hash":"bca18bb1036005442c3ca623245d2419b1863a9f","modified":1543303412373},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921145310488.png","hash":"a81cb156dfd22d05f43af23f97fac1da7c27356f","modified":1543303412374},{"_id":"source/_posts/2018-10-03-spring-ehcache/ehcache-test.png","hash":"74382a7c336c655f52b0d2e6228ebc592f366772","modified":1543303412378},{"_id":"source/_posts/2018-10-21-spring-context/99A34C3359FEAA8410.png","hash":"cb676e0e077ede3f019018de47abe2e4e5ecfc4d","modified":1543303412381},{"_id":"source/_posts/2018-11-25-docker-1/vm-vs-docker.png","hash":"dbf080e55157d1c9ab8cca4939b9d2b3dd788e9b","modified":1544257975259},{"_id":"source/_posts/2018-11-28-docker-2/image-layer.png","hash":"02393659e78c4a5526e707f9a10797c7f2f77cb3","modified":1544257975262},{"_id":"source/_posts/2018-12-01-docker-5/docker-bridge-mode.png","hash":"30abd93dd2d442d4da4615cf2c96f38a79ca9081","modified":1544257975267},{"_id":"source/_posts/2018-12-01-docker-6/Redis-Cluster-archi.PNG","hash":"0c7cba61e8351fe4c46bc5fba33586193ebe8726","modified":1544257975275},{"_id":"source/_posts/2018-12-01-docker-7/Redis-failover-1.PNG","hash":"adc978cd9eecc1f8a0a47d34380ce22ae966357a","modified":1544257975278},{"_id":"source/_posts/2018-12-02-docker-7/redis-failover-log.PNG","hash":"a25b711b7eb1fb6659addd966af94c27b45db486","modified":1544257975285},{"_id":"source/_posts/2018-12-02-docker-7/redis-sentinel-log.PNG","hash":"40d7f53247ef2dcf9d02db8d97d85bfe1f88d7d1","modified":1544257975286},{"_id":"source/_posts/2018-12-02-docker-8/Redis-Cluster-archi.PNG","hash":"0c7cba61e8351fe4c46bc5fba33586193ebe8726","modified":1544257975288},{"_id":"source/_posts/2018-12-02-docker-8/haproxy1.PNG","hash":"d4d0af03783ca3e8da00842f2fd23bccb6919cbc","modified":1544257975291},{"_id":"source/_posts/2018-12-02-docker-8/haproxy2.PNG","hash":"dfa6b8a155832b435d70df3bc036bb950abfcc3b","modified":1544257975292},{"_id":"source/_posts/2018-12-02-docker-8/haproxy3.PNG","hash":"d5fd25e2ef9cf9745fabe811fbdb46adac5190a0","modified":1544257975294},{"_id":"source/_posts/2018-12-02-docker-8/haproxy6.PNG","hash":"600320f2da578db9355462a3dc5c587b8f7e8c8c","modified":1544257975298},{"_id":"source/_posts/2018-12-02-docker-8/haproxy4.PNG","hash":"3f10ed3c3d7284db4d3b74853b7e43f868984995","modified":1544257975295},{"_id":"source/_posts/2018-12-02-docker-8/haproxy5.PNG","hash":"d39cb3683621f01b23250ba471d656abb8866c77","modified":1544257975296},{"_id":"source/_posts/2018-12-03-docker-10/Redis-Cluster-archi.PNG","hash":"0c7cba61e8351fe4c46bc5fba33586193ebe8726","modified":1544257975299},{"_id":"source/_posts/2018-12-03-docker-10/reshard-test-2-3832564.PNG","hash":"065f4285bd73df4fb449ca1cd4dce88edb930a09","modified":1544257975314},{"_id":"source/_posts/2018-12-03-docker-10/reshard-test-2.PNG","hash":"065f4285bd73df4fb449ca1cd4dce88edb930a09","modified":1544257975314},{"_id":"source/_posts/2018-12-03-redis-stats/redis-stat-1.PNG","hash":"eec4d8b756f4f566d55fac8ce447589f1dc061d3","modified":1544257975321},{"_id":"themes/melody/layout/includes/gallery/script.pug","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545468816716},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide setting.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1543303412355},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide-setting.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1543303412356},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide설정.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1543303412357},{"_id":"themes/melody/.git/objects/pack/pack-0dd03432b2c7b331d0b61f4b8f911cc99730ec24.idx","hash":"a7c0788adb6b3145dd286d2b3c602ed8a351eb4d","modified":1545468816697},{"_id":"themes/melody/.git/refs/heads/master","hash":"f4ee9a2e59bf336ef09f72930f16eddb82e1ea9f","modified":1545468816706},{"_id":"themes/melody/layout/includes/comments/disqus.pug","hash":"989de5ed05fb462e5a46601eb41ab3963b4d4e9d","modified":1545468816714},{"_id":"themes/melody/layout/includes/comments/gitalk.pug","hash":"86bdbc4a52024c3573bea27817394dd118b70a26","modified":1545468816714},{"_id":"themes/melody/layout/includes/comments/gitment.pug","hash":"4a9e172c2b7a9f6f1f8c313d0d45266de828f209","modified":1545468816714},{"_id":"themes/melody/layout/includes/comments/index.pug","hash":"6c16214e5945142e5f3b58e7694397e26f28849d","modified":1545468816714},{"_id":"themes/melody/layout/includes/comments/laibili.pug","hash":"97de1d1fb0459e7a2394ac2f5e449adf9b6986cb","modified":1545468816715},{"_id":"themes/melody/layout/includes/comments/valine.pug","hash":"e87eca6aed5a7e234a8acaa93e08ed674cb1531e","modified":1545468816715},{"_id":"themes/melody/layout/includes/count/busuanzi.pug","hash":"43fd52287adef41dc083738e25f24390d72b572c","modified":1545468816715},{"_id":"themes/melody/layout/includes/gallery/layout.pug","hash":"8ff96c4f9afb416c5fc586c9585ae51cb6129529","modified":1545468816716},{"_id":"themes/melody/layout/includes/mixins/article-sort.pug","hash":"da7572fcc4aac6b63a651a3320e5d853ea07b347","modified":1545468816717},{"_id":"themes/melody/layout/includes/mixins/slide.pug","hash":"91975f700b20131ab4df4d2ea3e1acc8bf2d3eef","modified":1545468816717},{"_id":"themes/melody/layout/includes/search/algolia.pug","hash":"44d5a061df53a276d22b3855652645d90117d0b6","modified":1545468816718},{"_id":"themes/melody/layout/includes/search/index.pug","hash":"b01828b37d789797aeb5433f1705cff3c540a4d5","modified":1545468816718},{"_id":"themes/melody/layout/includes/search/local-search.pug","hash":"f88070a84379bc06fb385e1193448fae6a8a54e1","modified":1545468816718},{"_id":"themes/melody/layout/includes/share/add-this.pug","hash":"17a11c1c36c9078639c2a82628ce5fc6584daffb","modified":1545468816718},{"_id":"themes/melody/layout/includes/share/index.pug","hash":"65ea837388ddf806f89c3b9082ceb31776dc6be5","modified":1545468816718},{"_id":"themes/melody/layout/includes/share/share-js.pug","hash":"f428b3bbc7a22d176098826c5e0aadf32b47f865","modified":1545468816719},{"_id":"themes/melody/layout/includes/slide/layout.pug","hash":"6b24f298d442e409c1149e4c1df38efce0453883","modified":1545468816719},{"_id":"themes/melody/layout/includes/slide/script.pug","hash":"c35c2af397f41bb858070032c702e8503371fd07","modified":1545468816719},{"_id":"themes/melody/layout/includes/third-party/mathjax.pug","hash":"035656871566bdcb8c45d3a0fe0b0835c524eb11","modified":1545468816719},{"_id":"themes/melody/source/css/_global/index.styl","hash":"be8558033858fa050d7efb1ff2ed1956d54c2a56","modified":1545468816722},{"_id":"themes/melody/source/css/_highlight/diff.styl","hash":"b0079f6da761935b720d70dafd826ef62fad86d2","modified":1545468816722},{"_id":"themes/melody/source/css/_highlight/highlight.styl","hash":"67a26d07cf8f2dca0a28521728aeecabb740669c","modified":1545468816722},{"_id":"themes/melody/source/css/_highlight/theme.styl","hash":"7d85860927afa1d93b4a39febff3d95a73de4c36","modified":1545468816722},{"_id":"themes/melody/source/css/_layout/comments.styl","hash":"e58602aad6792f1a5dbda0677ecb04d21ac10e97","modified":1545468816722},{"_id":"themes/melody/source/css/_layout/footer.styl","hash":"a72a6bb4477c18a14a2b779db183df22b4cba272","modified":1545468816723},{"_id":"themes/melody/source/css/_layout/head.styl","hash":"f8c4bdd331907b6156be7309f7404ea5df38f302","modified":1545468816723},{"_id":"themes/melody/source/css/_layout/pagination.styl","hash":"a3f52d1f7ff1eaead8df016b2a4def6f7b4e9559","modified":1545468816723},{"_id":"themes/melody/source/css/_layout/sidebar.styl","hash":"e8315401a6c791d00617c031be01f45df70fe7fd","modified":1545468816724},{"_id":"themes/melody/source/css/_search/algolia.styl","hash":"534e5641e3efe2452db95cc25ec8da0111ceadcf","modified":1545468816724},{"_id":"themes/melody/source/css/_search/index.styl","hash":"63cae4465ac54b71361c1795206534c7f2e6e5b1","modified":1545468816724},{"_id":"themes/melody/source/css/_search/local-search.styl","hash":"d7970b385265fef782cdcaaf4fe68a2217625467","modified":1545468816724},{"_id":"themes/melody/source/css/_third-party/jquery.fancybox.min.css","hash":"f9c94ec04062a1bfe1ef894c49e6ec33fa121778","modified":1545468816724},{"_id":"themes/melody/source/css/_third-party/normalize.min.css","hash":"e12eef6d6811c132f4f2fcf6c936be384191bcaf","modified":1545468816725},{"_id":"themes/melody/source/js/search/algolia.js","hash":"8d2cc7ac4a015563344a3981c3040d308489935c","modified":1545468816727},{"_id":"themes/melody/source/js/search/local-search.js","hash":"56a92344aee6427345af106aa44b8555f9429b96","modified":1545468816727},{"_id":"themes/melody/source/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1545468816728},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1545468816729},{"_id":"themes/melody/source/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1545468816736},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1545468816736},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/image-20180831235454808.png","hash":"752c481b2880b9ff4af53dc1f2ee4a2b0306528e","modified":1543303412368},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921153027741.png","hash":"b3ff77f45cfabe97517baee545932baf63ae11dd","modified":1543303412375},{"_id":"source/_posts/2018-10-03-spring-ehcache/test-result.png","hash":"fbede59e379c89cf5c6630de0e22779923a59af2","modified":1543303412380},{"_id":"source/_posts/2018-11-28-docker-2/redis-versions.png","hash":"1d272b044ddb91ca4661553b0a3d43fffc4354dd","modified":1544257975263},{"_id":"source/_posts/2018-12-01-docker-5/ip.PNG","hash":"38b668d6101e33291dafedd8813e8eaf3a6c56fd","modified":1544257975270},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1543303412405},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1543303412407},{"_id":"themes/melody/source/css/_layout/page.styl","hash":"79d551beaea2458abcedbf585618b9fa8d3d22e5","modified":1545468816723},{"_id":"themes/melody/source/css/_layout/post.styl","hash":"8658737ba289559077c5233b491e424cd5ddca5e","modified":1545468816723},{"_id":"themes/melody/source/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1545468816729},{"_id":"themes/melody/.git/logs/refs/heads/master","hash":"b05e2f542a26596d8e044a34783a282252c2e92b","modified":1545468816706},{"_id":"themes/melody/.git/refs/remotes/origin/HEAD","hash":"2c142208129b78a4616cbb6798f96f4fb3580296","modified":1545468816705},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","hash":"859d70cd7c459819b90fe27afb940d16ecff6614","modified":1545468816734},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","hash":"37f3186f93ec854f56bf745a5988a89225e8da6c","modified":1545468816734},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1545468816734},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","hash":"4bb2925b111467791fdef3c4e4b41993d59ce90f","modified":1545468816735},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","hash":"aca47bf417d451c4d364c6eb287a230e4b462b17","modified":1545468816735},{"_id":"source/_posts/2018-11-28-docker-2/docker-hub.png","hash":"1ff9c745f8651f651c2f83529af792b4851689fc","modified":1544257975261},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","hash":"8c9495c76d5aa00d3dfb88653c362fba9f10cbb2","modified":1545468816730},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","hash":"d8377a86451712488dea87caf5acbf8e97aa991f","modified":1545468816735},{"_id":"themes/melody/.git/logs/refs/remotes/origin/HEAD","hash":"8c4679866e2ae24609e389a8bc9a3d87401a11d3","modified":1545468816705},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/image-20180831234615081.png","hash":"c80e8087b73e4f149b9ab607a76187a6fc9fdf17","modified":1543303412367},{"_id":"source/_posts/2018-11-25-docker-1/docker-image.png","hash":"3bd173b53ce8a8491633389df24444f0cd0fe579","modified":1544257975255},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/RequestMappingHandlerAdapter.png","hash":"71751889b49d402fe29355c7ea9bb172ead4b95c","modified":1543303412362},{"_id":"source/_posts/2018-09-21-spring-ioc-2/containers.jpg","hash":"b51257292a3497e4adcdf5560a7f09f7f1a8b5a6","modified":1543303412377},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","hash":"10dd530e712a67f25cf27845213c0f28d2fe9e4d","modified":1545468816734},{"_id":"source/_posts/2018-11-25-docker-1/docking-image.png","hash":"6b64b14f241d12e7e2b9d9dd24bfff05af593a95","modified":1544257975258},{"_id":"themes/melody/.git/objects/pack/pack-0dd03432b2c7b331d0b61f4b8f911cc99730ec24.pack","hash":"6966c4027150aaeeb387bd174bbbe0be91953434","modified":1545468816696},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1543303412403},{"_id":"public/rss2.xml","hash":"6fc5839a92a9f149fd8eabbf388d603fa66ad7d2","modified":1548759587866},{"_id":"public/post-sitemap.xml","hash":"47e5d2e76af45d3b11ce98251577e77fa4b0b30f","modified":1548759587888},{"_id":"public/page-sitemap.xml","hash":"b27509022f4f1cff0536d418694378a487fba5e3","modified":1548679628427},{"_id":"public/tag-sitemap.xml","hash":"94090396fde972a6f9e34743349c462b39a6bcda","modified":1548759587889},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1548679628427},{"_id":"public/sitemap.xml","hash":"17f3814a0d56275671ffb546781d2adde9c12807","modified":1548759587889},{"_id":"public/archive/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548679628447},{"_id":"public/404.html","hash":"12abd648f3a173b8e45198a171e40069942c28ac","modified":1548679628447},{"_id":"public/about/index.html","hash":"e5f7fccf2c1010934e3270fce083a116eec8c838","modified":1548679628447},{"_id":"public/categories/index.html","hash":"8fcfb9ec354aceb38274a7cfe74f2db463044db6","modified":1548679628447},{"_id":"public/tags/index.html","hash":"0f8175516b29b3b48e5cf854c4234c67f3a8ff72","modified":1548679628447},{"_id":"public/2019/01/20/effective-java-item16/index.html","hash":"4a6e82ee67265c587b55d27b623e44975fa2e838","modified":1548679628447},{"_id":"public/2019/01/13/java-object-copy/index.html","hash":"cd3cf26b7a8782df98d71adf6b38495f2afa4c07","modified":1548679628447},{"_id":"public/2019/01/08/effective-java-item9/index.html","hash":"6746bc3c0356d1d49d9ec973ef0767f7bf49f5e7","modified":1548679628447},{"_id":"public/2019/01/08/effective-java-item8/index.html","hash":"73109473830ea61d38f1f6404c5f8e8feb9c7d66","modified":1548679628447},{"_id":"public/2019/01/07/effective-java-item5/index.html","hash":"1dabecd46f294365b9c36521b92fb3e4d04c041e","modified":1548679628447},{"_id":"public/2019/01/07/effective-java-item4/index.html","hash":"6a82a6d246fa06538b17bc92164ccac7146f71e3","modified":1548679628447},{"_id":"public/2018/12/07/2018-12-07-docker-11/index.html","hash":"fe96bbe7e2374b9d3020848958038ce75a024b87","modified":1548679628448},{"_id":"public/2018/12/03/2018-12-03-redis-stats/index.html","hash":"ebe4fa13bac51de5823c73b24fc54ed9845f1c9f","modified":1548679628448},{"_id":"public/2018/12/01/2018-12-01-docker-5/index.html","hash":"1f249588c0054b28aa1c1846bf2cad83cdd2de1e","modified":1548679628448},{"_id":"public/2018/11/25/2018-11-25-docker-1/index.html","hash":"57e56b572197178bd7e35138f5057050e01716e4","modified":1548679628448},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/index.html","hash":"6a7bd05902c9f6269cf9c570918d76e5a2074ed3","modified":1548679628448},{"_id":"public/2018/07/20/2018-07-20-spring-aop2/index.html","hash":"f1e8d74d4acc9d14f47c9917cce3f9f59bc9c628","modified":1548679628448},{"_id":"public/2018/07/15/2018-07-15-spring-aop/index.html","hash":"66bd6f342d60cc67de0d16c5cec413c38ff44055","modified":1548679628448},{"_id":"public/index.html","hash":"3ca84a9c0ae95b4cdba59c2b0d253a656f7b7233","modified":1548679628448},{"_id":"public/archives/2/index.html","hash":"b1873fe32747f0ef9cce1c984e3570be87d79a36","modified":1548679628448},{"_id":"public/archives/3/index.html","hash":"bfc34319232c806d5481962840059ef904aa3b2a","modified":1548679628448},{"_id":"public/archives/4/index.html","hash":"68f7c73cf222176bfb3f070e99068f05357928ec","modified":1548679628448},{"_id":"public/archives/5/index.html","hash":"2978b0c7ef11a5b2f297f405763b2356d5e74ebf","modified":1548679628448},{"_id":"public/archives/6/index.html","hash":"46cfc47f6ba5bfb6a28f466bde06d8842b8e0d73","modified":1548679628448},{"_id":"public/archives/index.html","hash":"2de1718b1f64364ed3e0950df0fe5f4629c03520","modified":1548679628448},{"_id":"public/archives/archives/2/index.html","hash":"5af2a43672797ba85cbd4b300e4202a3f6c8212b","modified":1548679628448},{"_id":"public/archives/archives/3/index.html","hash":"fefefed606b3af90e3d5eb57733b9be68dd4d543","modified":1548679628448},{"_id":"public/archives/archives/4/index.html","hash":"f835b976ab035eeb0b42cd9981cf9efcf13dae69","modified":1548679628448},{"_id":"public/archives/archives/5/index.html","hash":"e00537bdcd2af5e828b1fd38cec2c1c77036e77b","modified":1548679628449},{"_id":"public/archives/archives/6/index.html","hash":"22a1d304802e4bce69ffb86cabe8dd07734ff284","modified":1548679628449},{"_id":"public/archives/2018/index.html","hash":"07f96413a2c47f7c49081e17bf65b567507ab508","modified":1548679628449},{"_id":"public/archives/2018/archives/2/index.html","hash":"5ada62d86091d75bcca98f597ecb00a550aea465","modified":1548679628449},{"_id":"public/archives/2018/archives/3/index.html","hash":"0a49056594feefcd731e49ef23f4f0e84ea80bdc","modified":1548679628449},{"_id":"public/archives/2018/archives/4/index.html","hash":"6625da332b59d81c69ae4bab8c82ad4cfa003cb4","modified":1548679628449},{"_id":"public/archives/2018/07/index.html","hash":"fdaeed119b627b8ec82baccffdd0d94891845c3c","modified":1548679628449},{"_id":"public/archives/2018/08/index.html","hash":"0a440a2d24c12bd48385481975de48a8e25539c1","modified":1548679628449},{"_id":"public/archives/2018/09/index.html","hash":"1f6a445b8cff1473c0927f38fd04d41a0973e2c5","modified":1548679628449},{"_id":"public/archives/2018/10/index.html","hash":"f44713a62a8a592fb2b1f60f9711e2958dc028db","modified":1548679628449},{"_id":"public/archives/2018/11/index.html","hash":"0f35cf72b33b6f4012e257cfe026a12044f88c14","modified":1548679628449},{"_id":"public/archives/2018/12/index.html","hash":"f234a2fc112ec555921c5aa8b1c00f78c702ba4c","modified":1548679628449},{"_id":"public/archives/2018/12/archives/2/index.html","hash":"a8ee2116ad9677c65bd62e4566be5527b45d70af","modified":1548679628449},{"_id":"public/archives/2019/index.html","hash":"33542a8b13daa773ae5a429ee8ac61c10659c94a","modified":1548679628449},{"_id":"public/archives/2019/archives/2/index.html","hash":"2b19f6e14cca9eae655e72a502e36aec7a22c40d","modified":1548679628449},{"_id":"public/archives/2019/01/index.html","hash":"ac2c9551948ecfda2894ba7a6ab6954fb22e70a8","modified":1548679628449},{"_id":"public/archives/2019/01/archives/2/index.html","hash":"ea6f8f55d2fbc23dd0434d882a8f5ee83d4b4135","modified":1548679628449},{"_id":"public/tags/Spring/index.html","hash":"cc4b045cf87fedfdf61d4502f680d4ef77840ea3","modified":1548679628449},{"_id":"public/tags/Spring/archives/2/index.html","hash":"01ab0ed84a7548021a988e14acfaa89aee0a006c","modified":1548679628449},{"_id":"public/tags/Java-Config/index.html","hash":"cd5ec4e0f52d78b4f30b657fb8b16dbb01b54e39","modified":1548679628449},{"_id":"public/tags/WAS/index.html","hash":"2d82dfdb9edf5e3be864f4c4ccbcd040ce425a76","modified":1548679628449},{"_id":"public/tags/Spring-Boot/index.html","hash":"88c888e183b8d161748a37bb445b60cf078945c2","modified":1548679628449},{"_id":"public/tags/EHCache/index.html","hash":"9df495ca0dd80d9059b39529108225740b7e828d","modified":1548679628449},{"_id":"public/tags/Docker/index.html","hash":"c20f86659eedd656f2e55f8918e4d2957b9c46e6","modified":1548679628450},{"_id":"public/tags/Docker/archives/2/index.html","hash":"544598b922e8a470352992fb0bfdc49e3f3b6658","modified":1548679628450},{"_id":"public/tags/Mybatis/index.html","hash":"26f8445f77b3b37889b4fba4d8e168c57153b28a","modified":1548679628450},{"_id":"public/tags/Effective-Java/index.html","hash":"36a4e6ce80ded25e47e807da1d9fb4a827157ee7","modified":1548679628450},{"_id":"public/tags/Effective-Java/archives/2/index.html","hash":"045fd4ee36ee0f6bad77190d40c9257080d5783b","modified":1548679628450},{"_id":"public/tags/Java/index.html","hash":"87cc467cfd1d663cab6ae41fd2ab855236d63b38","modified":1548679628450},{"_id":"public/tags/core/index.html","hash":"282df818d5bc07b8efc870de3cbe684258774062","modified":1548679628450},{"_id":"public/tags/Spring-Core/index.html","hash":"a20ce386339aab8a5503229cca8d1c564927a4fa","modified":1548679628450},{"_id":"public/tags/J2EE/index.html","hash":"d5d24be68f1b713514b8433230ec6060f19bc95d","modified":1548679628450},{"_id":"public/tags/SpEL/index.html","hash":"3743058080831e4e59f73c0beaf470712c1a870a","modified":1548679628450},{"_id":"public/tags/2018-remind/index.html","hash":"287c9fe7ce9bd869fb0b7b157af13ecaacd56475","modified":1548679628450},{"_id":"public/2019/01/28/effective-java-item32/index.html","hash":"ccc48ee3542ddbcd8beba28f02fc98fa9dd2eea1","modified":1548759587897},{"_id":"public/2019/01/26/effective-java-item31/index.html","hash":"55526caefb00ada54ff6c412062549e2c1d62707","modified":1548679628450},{"_id":"public/2019/01/20/effective-java-item17/index.html","hash":"63886c4721103147025ea0faa5b4affd64543792","modified":1548679628450},{"_id":"public/2019/01/19/effective-java-item15/index.html","hash":"79e2c1cbc92913f0e7baeb1f5becab43a3e5dcef","modified":1548679628450},{"_id":"public/2019/01/13/effective-java-item14/index.html","hash":"ff00cf75c5090f3482bdd412cbaaeab41a5bf578","modified":1548679628450},{"_id":"public/2019/01/13/effective-java-item13/index.html","hash":"447d0c38e44e909fa02a12ba74274932ed2278d3","modified":1548679628450},{"_id":"public/2019/01/13/effective-java-item12/index.html","hash":"daf8d37e07e41ae1a6c94c892e9810cd9c930464","modified":1548679628450},{"_id":"public/2019/01/12/effective-java-item11/index.html","hash":"70b18d1fc2f17fe278fe3e2ac0b97a321144b97b","modified":1548679628450},{"_id":"public/2019/01/10/effective-java-item10/index.html","hash":"359414cbe58bb03be8db229fd34582bbfba32a59","modified":1548679628450},{"_id":"public/2019/01/07/effective-java-item7/index.html","hash":"9ad5935aff10a48707463691afcda6e8fcd51a1f","modified":1548679628451},{"_id":"public/2019/01/07/effective-java-item6/index.html","hash":"02d5761bf5e913dbc7349029b1af0bd0b3f86790","modified":1548679628451},{"_id":"public/2019/01/07/effective-java-item3/index.html","hash":"1bbb6e8fd4c458e4e179f9e95703e80acd9bed19","modified":1548679628451},{"_id":"public/2019/01/06/effective-java-item2/index.html","hash":"d1403e2f59ebaf483af75a00d01cebdd3d375f45","modified":1548679628451},{"_id":"public/2019/01/06/effective-java-item1/index.html","hash":"5d148bd44b9b87efa2330e687a4ca9df0c3940ac","modified":1548679628451},{"_id":"public/2018/12/30/2018-12-30-mybatis-returnInstanceForEmptyRow/index.html","hash":"055a312d2d5f2bfe1d7b0c156f22c27fce7086bd","modified":1548679628451},{"_id":"public/2018/12/16/2018-12-16-remind/index.html","hash":"7ffc197973b6e644944d7ef3d506dc04ce5e6408","modified":1548679628451},{"_id":"public/2018/12/03/2018-12-03-docker-10/index.html","hash":"00381e2e695452c4d7e38da843a98aace1671628","modified":1548679628451},{"_id":"public/2018/12/02/2018-12-02-docker-8/index.html","hash":"c3289b8d07c9f5b4310a0bd869fe78f7b07494f8","modified":1548679628451},{"_id":"public/2018/12/02/2018-12-02-docker-7/index.html","hash":"e65a97df61d948173aa531f94745d416e89dd3fc","modified":1548679628451},{"_id":"public/2018/12/01/2018-12-01-docker-6/index.html","hash":"353c0f72201233067ce70a94c1d8f61886f4bd3d","modified":1548679628451},{"_id":"public/2018/12/01/2018-12-01-docker-4/index.html","hash":"f1feb1d4ebbcaa5509aaffae3c2329dc6c1f88b7","modified":1548679628451},{"_id":"public/2018/12/01/2018-12-01-docker-3/index.html","hash":"8a2746f48a0efe2ed11b19ecccd4ccd97f84e466","modified":1548679628451},{"_id":"public/2018/11/28/2018-11-28-docker-2/index.html","hash":"8a51e6deff13bd613c9b7791a4b7bbd227790072","modified":1548679628451},{"_id":"public/2018/11/25/2018-11-25-spel-expression-2/index.html","hash":"925c2b437c89195842609d0c64d4b7ec2abbcd47","modified":1548679628451},{"_id":"public/2018/11/21/2018-11-21-spel-expression/index.html","hash":"b2e35df5a3b10002d0585a3866958ee009855f11","modified":1548679628451},{"_id":"public/2018/11/07/2018-11-04-ehcache-config-for-springboot/index.html","hash":"000b460abbe91527abbf7658ed4249a2e34688ff","modified":1548679628451},{"_id":"public/2018/11/07/2018-11-04-ehcache-config-for-springframework/index.html","hash":"c61fd89657fcb73b7226d46e04804e11da8fa89f","modified":1548679628452},{"_id":"public/2018/11/07/2018-10-03-spring-ehcache/index.html","hash":"b18e5845f0273e8a4989a9d8fcee60fca3574abf","modified":1548679628452},{"_id":"public/2018/10/21/2018-10-21-java-config-import/index.html","hash":"135bf97c8bc9fa4c9dd8f7e68aa3889e5bceb934","modified":1548679628452},{"_id":"public/2018/10/21/2018-10-21-spring-context/index.html","hash":"f4801f897a8caa2c7d5c31b1f9c9726e75e3da09","modified":1548679628452},{"_id":"public/2018/09/22/2018-09-21-spring-ioc-2/index.html","hash":"ceeb7e20a4c2256fa69df560391c11cf83b663be","modified":1548679628452},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/index.html","hash":"a58d15a674f46b11173a4d934122d7f8dde691b5","modified":1548679628452},{"_id":"public/2018/09/01/2018-09-01-servlet/index.html","hash":"fafef7fa0f93c59fd4ae33d4ffe6225e9e592e53","modified":1548679628452},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/index.html","hash":"0d12239821f407db8fabdaadda1d139aa3563a7f","modified":1548679628452},{"_id":"public/2018/08/30/2018-08-29-java-exception/index.html","hash":"2c69626aaa4891619f7525e8db4d56fe3d02a100","modified":1548679628452},{"_id":"public/2018/08/25/2018-08-18-spring-filter-interceptor/index.html","hash":"1ac99a6b6f8d97d815315c93a48a261e92b59864","modified":1548679628452},{"_id":"public/2018/08/11/2018-08-11-spring-dispatcher-servlet/index.html","hash":"70cea42760335328b57a9ecf6229363bc662cb20","modified":1548679628452},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/index.html","hash":"394788193533d66fca5cbceec1b0235488cf9403","modified":1548679628452},{"_id":"public/2018/07/24/2018-07-24-spring-aop5/index.html","hash":"852e83174b7ecfde82cfe562719961f924d53611","modified":1548679628452},{"_id":"public/2018/07/22/2018-07-22-spring-aop4/index.html","hash":"f9b92f94ba0755e5776e5fd5aa63b9dd14f08a6a","modified":1548679628452},{"_id":"public/2018/07/21/2018-07-21-spring-aop3/index.html","hash":"a945bd09bd161410e7924d4c26287ea0d9b095d0","modified":1548679628452},{"_id":"public/googleb6989b051cadc23a.html","hash":"9112b0956896de444cec8ceed3613e54bd5f5960","modified":1548679628464},{"_id":"public/naver06b931b9a92d9d3d74ae0c39217e61a6.html","hash":"3c9a2eb1ba1d6c67e9b6947fa36e5eaad723831b","modified":1548679628464},{"_id":"public/CNAME","hash":"1dfdd576ea7d7b762128ec2c90801bcda66bcf09","modified":1548679628465},{"_id":"public/robots.txt","hash":"03f5fd7e89c6aca4e5c67b5b2242a9b0310f1f70","modified":1548679628465},{"_id":"public/favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1548679628465},{"_id":"public/img/avatar.png","hash":"a44601fac9a81dd7e392d05ea5ddc65c96b051df","modified":1548679628465},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1548679628465},{"_id":"public/2018/10/21/2018-10-21-spring-context/99A34C3359FEAA8410.png","hash":"cb676e0e077ede3f019018de47abe2e4e5ecfc4d","modified":1548679628465},{"_id":"public/2019/01/13/java-object-copy/clone.jpg","hash":"fa9a14cc4aef02365781de7561dae80c940c4c56","modified":1548679628465},{"_id":"public/2018/12/30/2018-12-30-mybatis-returnInstanceForEmptyRow/all_element_are_null.png","hash":"bab9af461169b64821fe5c5abd1c75207782463f","modified":1548679628465},{"_id":"public/2018/12/03/2018-12-03-redis-stats/redis-stat-1.PNG","hash":"eec4d8b756f4f566d55fac8ce447589f1dc061d3","modified":1548679628465},{"_id":"public/2018/12/03/2018-12-03-redis-stats/redis-stat-web.PNG","hash":"613514acb2e69f6fc74001816f83e79a33091507","modified":1548679628465},{"_id":"public/2018/12/03/2018-12-03-redis-stats/redis-stat-web2.PNG","hash":"b20a8a2345327e68a2e111e8f81a1e043acd0205","modified":1548679628465},{"_id":"public/2018/11/25/2018-11-25-docker-1/docker-logo.png","hash":"de9a2af4d09e151d367db146df980b33a7fdc63f","modified":1548679628466},{"_id":"public/2018/12/01/2018-12-01-docker-5/docker-bridge-2.PNG","hash":"2512c39cc226d4e05ae794907b97e7d6e44a8761","modified":1548679628466},{"_id":"public/2018/12/01/2018-12-01-docker-5/httpd.PNG","hash":"500c3df0646b0e75899bfe190ae8b96c75659a8e","modified":1548679628466},{"_id":"public/2018/12/01/2018-12-01-docker-5/docker0-interface.PNG","hash":"2d428ea97af6669a0a4d1028cdbe6f95a135f744","modified":1548679628466},{"_id":"public/2018/12/01/2018-12-01-docker-5/redis1.PNG","hash":"e6efda0548f75f771d1a8d7b20be99fb8692e13d","modified":1548679628466},{"_id":"public/2018/12/01/2018-12-01-docker-5/none.PNG","hash":"da2ba5a819657d541f5d0e95dbe4c520931b0727","modified":1548679628466},{"_id":"public/2018/12/01/2018-12-01-docker-5/redis2.PNG","hash":"79fdbb784fc48aab811ed72d04bf35f08ac0fc1a","modified":1548679628466},{"_id":"public/2018/08/11/2018-08-11-spring-dispatcher-servlet/Front-controller-pattern.png","hash":"62befacb5ce536303e605341fc7dbf103172526d","modified":1548679628466},{"_id":"public/2018/08/25/2018-08-18-spring-filter-interceptor/filter-chain.gif","hash":"e9bbc8316a3611e64194628fb5f2d524be1ccf56","modified":1548679628466},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/Dispatch-Seq.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1548679628466},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/argument-resolver-result.png","hash":"cd37d456fa0edc6c814db3e9a2cdfe77ebf11fa9","modified":1548679628466},{"_id":"public/2018/09/01/2018-09-01-servlet/Servlet-life-cycle.png","hash":"25e5eba2e087ee76504a5ac69e0541dd5f97b020","modified":1548679628466},{"_id":"public/2018/09/01/2018-09-01-servlet/jspToServlet.jpeg","hash":"df8c145eca3f082d95dd99d3e391406f75b7ea21","modified":1548679628466},{"_id":"public/2018/09/01/2018-09-01-servlet/servlet.png","hash":"fcd04673f2b14d367a6c6dd3f97fdb6f8a348476","modified":1548679628466},{"_id":"public/2018/12/01/2018-12-01-docker-6/redis-replication-3746317.PNG","hash":"8caa36e87414247064714936b9af876d874aca35","modified":1548679628466},{"_id":"public/2018/12/01/2018-12-01-docker-6/redis-replication2-3746337.PNG","hash":"5cde66124d7038ba1a83d24669ca3355fd1a0989","modified":1548679628467},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921142925583.png","hash":"66ef48b35f6b60d2788ea4aba67dd00b5bc481e3","modified":1548679628467},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921142928480.png","hash":"66ef48b35f6b60d2788ea4aba67dd00b5bc481e3","modified":1548679628467},{"_id":"public/2018/11/28/2018-11-28-docker-2/docker-permission.png","hash":"51131b8ff5e6726a157e42eb65ea18c2b0ec3942","modified":1548679628467},{"_id":"public/2018/11/28/2018-11-28-docker-2/sudo-docker.png","hash":"581b0ee3bc92733ca6f80f6a54ffab6ad31acf47","modified":1548679628467},{"_id":"public/2018/12/02/2018-12-02-docker-7/Redis-failover-2.PNG","hash":"bb74a8e222ba9a0a562d8690f870f1040629e40c","modified":1548679628467},{"_id":"public/2018/12/02/2018-12-02-docker-7/Redis-failover-1.PNG","hash":"adc978cd9eecc1f8a0a47d34380ce22ae966357a","modified":1548679628467},{"_id":"public/2018/12/02/2018-12-02-docker-7/redis-failover-3-3748019.PNG","hash":"e1cdc97e0c0ed35f11696c8973748f81c287fd92","modified":1548679628467},{"_id":"public/2018/12/02/2018-12-02-docker-7/redis-failover-3.PNG","hash":"e1cdc97e0c0ed35f11696c8973748f81c287fd92","modified":1548679628467},{"_id":"public/2018/12/02/2018-12-02-docker-7/redis-failover-4.PNG","hash":"330b09dd521316edf16b5c414e04e13edc065737","modified":1548679628467},{"_id":"public/2018/12/02/2018-12-02-docker-7/sentinel.PNG","hash":"fe37b42c26a4db9830a7127f04da31af3c90df3c","modified":1548679628467},{"_id":"public/2018/12/03/2018-12-03-docker-10/cluster-add-node-slave.PNG","hash":"e7bb488dc166dddb71884469f1ab2fb753d37eb0","modified":1548679628467},{"_id":"public/2018/12/03/2018-12-03-docker-10/cluster-add.PNG","hash":"943e466193e86100be4fab4da3b9ad24b0206415","modified":1548679628467},{"_id":"public/2018/12/03/2018-12-03-docker-10/cluster-keys-command.PNG","hash":"3dbb7daf0afe49dde718afe0ce3dd40b424dc13b","modified":1548679628467},{"_id":"public/2018/12/03/2018-12-03-docker-10/cluster-nodes.png","hash":"37bbc99a5ee8993f6f3cd8a2d2ad01f041a366ca","modified":1548679628467},{"_id":"public/2018/12/03/2018-12-03-docker-10/cluster-setting.PNG","hash":"bf70eb41b2e2eae6efeee0577ecb0eaf9512eb48","modified":1548679628467},{"_id":"public/2018/12/03/2018-12-03-docker-10/cluster-setting2.PNG","hash":"27a637923d165e7241b84a5ff6905de8c31a3416","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/failover2.png","hash":"33dc8caa5294b26c312a4649ba55f881ec173b92","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/failover-1.png","hash":"c80825e762bd45ded53053f0f2bd524bee905662","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/master-del-fail.png","hash":"b0bb322e93303d86c39db47a4dd602f9b9a60965","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/master-del-success.png","hash":"c8cfb7a9cb151ab40e0ff562e09a9b62c53bfb6e","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/master-down.png","hash":"95320a81532f8af28eb5d283dbda5a199d93ded3","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/new-redis-cluster.PNG","hash":"8b8169360cdcafa875651ec878a47654f07121ba","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/new-redis-cluster2.PNG","hash":"6981767ae02254569491068467f620b7c6759ca2","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/reshard-test-1-3831920.PNG","hash":"4c43d69370b02825abd08e47385aabc351e6d479","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/reshard-test-1.PNG","hash":"4c43d69370b02825abd08e47385aabc351e6d479","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/reshard-test-3.PNG","hash":"9fda0eac90672348ad9bc547765508984dd1292a","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/slave-add-result.png","hash":"34f8cf92d1688f9910d3848ce06b1030782f5873","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/slave-del.png","hash":"4055cbb30be190704f4ff6ff65141c59583a582d","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/slave-del-result.png","hash":"b1caf48dfd7bed8572acdeba9eda425a628f2a4a","modified":1548679628468},{"_id":"public/2018/11/07/2018-10-03-spring-ehcache/17110B4350CC5EC51D-20181011233534455.jpeg","hash":"cf45ea68e69cb2fe93b744283c00e6a4f26e1ed4","modified":1548679628468},{"_id":"public/2018/12/03/2018-12-03-docker-10/sub-reshard.PNG","hash":"6c0733bbb8d107faea29f0037cd690ff7f589785","modified":1548679628468},{"_id":"public/2018/11/07/2018-10-03-spring-ehcache/17110B4350CC5EC51D.jpeg","hash":"cf45ea68e69cb2fe93b744283c00e6a4f26e1ed4","modified":1548679628469},{"_id":"public/2018/11/07/2018-10-03-spring-ehcache/EHCACHE.png","hash":"c57ac4d44f0068d9bc08c350ad8b40d9603574ec","modified":1548679628469},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ipv4.png","hash":"bee74710d25633b4e34472e1ed796ca6ea9c6c60","modified":1548679628898},{"_id":"public/2018/11/25/2018-11-25-docker-1/vm-vs-docker.png","hash":"dbf080e55157d1c9ab8cca4939b9d2b3dd788e9b","modified":1548679628899},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ipv6.png","hash":"b48a91102ad1481ef1d0c7a87ba774a255a1a780","modified":1548679628899},{"_id":"public/2018/12/01/2018-12-01-docker-5/docker-bridge-mode.png","hash":"30abd93dd2d442d4da4615cf2c96f38a79ca9081","modified":1548679628899},{"_id":"public/2018/08/30/2018-08-29-java-exception/Exception-Class.png","hash":"97084943599629350623ab0ef20e32d22ced4500","modified":1548679628899},{"_id":"public/2018/08/11/2018-08-11-spring-dispatcher-servlet/dispatcher-servlet-lifecycle.jpg","hash":"52c983fadcf1cb7a6121885ea13a0944d9b4131f","modified":1548679628900},{"_id":"public/2018/08/25/2018-08-18-spring-filter-interceptor/spring-request-lifecycle.jpg","hash":"45c54cf5ba571c2061920fa1222af49a4520cb32","modified":1548679628900},{"_id":"public/2018/12/01/2018-12-01-docker-6/Redis-Cluster-archi.PNG","hash":"0c7cba61e8351fe4c46bc5fba33586193ebe8726","modified":1548679628900},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/Exception-Class.png","hash":"97084943599629350623ab0ef20e32d22ced4500","modified":1548679628900},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/spring-mvc-request.jpg","hash":"45c54cf5ba571c2061920fa1222af49a4520cb32","modified":1548679628900},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921143924788.png","hash":"bca18bb1036005442c3ca623245d2419b1863a9f","modified":1548679628900},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921145310488.png","hash":"a81cb156dfd22d05f43af23f97fac1da7c27356f","modified":1548679628900},{"_id":"public/2018/11/28/2018-11-28-docker-2/image-layer.png","hash":"02393659e78c4a5526e707f9a10797c7f2f77cb3","modified":1548679628900},{"_id":"public/2018/12/02/2018-12-02-docker-8/Redis-Cluster-archi.PNG","hash":"0c7cba61e8351fe4c46bc5fba33586193ebe8726","modified":1548679628900},{"_id":"public/2018/12/02/2018-12-02-docker-8/haproxy1.PNG","hash":"d4d0af03783ca3e8da00842f2fd23bccb6919cbc","modified":1548679628900},{"_id":"public/2018/12/02/2018-12-02-docker-8/haproxy2.PNG","hash":"dfa6b8a155832b435d70df3bc036bb950abfcc3b","modified":1548679628900},{"_id":"public/2018/12/02/2018-12-02-docker-8/haproxy3.PNG","hash":"d5fd25e2ef9cf9745fabe811fbdb46adac5190a0","modified":1548679628900},{"_id":"public/2018/12/02/2018-12-02-docker-8/haproxy4.PNG","hash":"3f10ed3c3d7284db4d3b74853b7e43f868984995","modified":1548679628901},{"_id":"public/2018/12/02/2018-12-02-docker-8/haproxy5.PNG","hash":"d39cb3683621f01b23250ba471d656abb8866c77","modified":1548679628901},{"_id":"public/2018/12/02/2018-12-02-docker-8/haproxy6.PNG","hash":"600320f2da578db9355462a3dc5c587b8f7e8c8c","modified":1548679628902},{"_id":"public/2018/12/02/2018-12-02-docker-7/redis-failover-log.PNG","hash":"a25b711b7eb1fb6659addd966af94c27b45db486","modified":1548679628902},{"_id":"public/2018/12/02/2018-12-02-docker-7/redis-sentinel-log.PNG","hash":"40d7f53247ef2dcf9d02db8d97d85bfe1f88d7d1","modified":1548679628902},{"_id":"public/2018/12/03/2018-12-03-docker-10/Redis-Cluster-archi.PNG","hash":"0c7cba61e8351fe4c46bc5fba33586193ebe8726","modified":1548679628902},{"_id":"public/2018/12/03/2018-12-03-docker-10/reshard-test-2-3832564.PNG","hash":"065f4285bd73df4fb449ca1cd4dce88edb930a09","modified":1548679628902},{"_id":"public/2018/12/03/2018-12-03-docker-10/reshard-test-2.PNG","hash":"065f4285bd73df4fb449ca1cd4dce88edb930a09","modified":1548679628902},{"_id":"public/2018/11/07/2018-10-03-spring-ehcache/ehcache-test.png","hash":"74382a7c336c655f52b0d2e6228ebc592f366772","modified":1548679628902},{"_id":"public/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548679628912},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548679628912},{"_id":"public/js/copy.js","hash":"cfae08721664d19cf0059172b994c0a2e253d334","modified":1548679628912},{"_id":"public/js/fancybox.js","hash":"0c2c506559129a5108893cf054b9aa46fe878fc3","modified":1548679628912},{"_id":"public/js/fireworks.js","hash":"5e3da1344966d5d6328a410cad69e92297699f3b","modified":1548679628912},{"_id":"public/js/scroll.js","hash":"73d57e7cf9921ba5724ad48b8d0e8b25dbce059f","modified":1548679628912},{"_id":"public/js/head.js","hash":"212a32f824cadea0167bf4204c9714df5b7e5f5d","modified":1548679628913},{"_id":"public/js/sidebar.js","hash":"a42109c5a69dedc87e1aaf8cb2383fd43069677e","modified":1548679628913},{"_id":"public/js/transition.js","hash":"998c3bb6523a248d4dd4d747510c03a914a6378d","modified":1548679628913},{"_id":"public/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1548679628913},{"_id":"public/js/search/algolia.js","hash":"8d2cc7ac4a015563344a3981c3040d308489935c","modified":1548679628913},{"_id":"public/js/search/local-search.js","hash":"56a92344aee6427345af106aa44b8555f9429b96","modified":1548679628913},{"_id":"public/js/third-party/reveal/markdown.min.js","hash":"859d70cd7c459819b90fe27afb940d16ecff6614","modified":1548679628913},{"_id":"public/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1548679628913},{"_id":"public/js/third-party/reveal/notes.min.js","hash":"4bb2925b111467791fdef3c4e4b41993d59ce90f","modified":1548679628913},{"_id":"public/js/third-party/reveal/zoom.min.js","hash":"aca47bf417d451c4d364c6eb287a230e4b462b17","modified":1548679628913},{"_id":"public/css/index.css","hash":"c1bb6568b09579dc23c838061307ea4407f611a5","modified":1548679628913},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ide setting.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1548679628913},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ide-setting.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1548679628913},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ide설정.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1548679628913},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/image-20180831235454808.png","hash":"752c481b2880b9ff4af53dc1f2ee4a2b0306528e","modified":1548679628913},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921153027741.png","hash":"b3ff77f45cfabe97517baee545932baf63ae11dd","modified":1548679628913},{"_id":"public/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1548679628925},{"_id":"public/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1548679628925},{"_id":"public/js/third-party/reveal/head.min.js","hash":"95c9de30444117adbbb3218070fda00af187a76a","modified":1548679628926},{"_id":"public/2018/11/28/2018-11-28-docker-2/redis-versions.png","hash":"1d272b044ddb91ca4661553b0a3d43fffc4354dd","modified":1548679628926},{"_id":"public/2018/11/07/2018-10-03-spring-ehcache/test-result.png","hash":"fbede59e379c89cf5c6630de0e22779923a59af2","modified":1548679628926},{"_id":"public/js/third-party/reveal/marked.min.js","hash":"37f3186f93ec854f56bf745a5988a89225e8da6c","modified":1548679628933},{"_id":"public/2018/12/01/2018-12-01-docker-5/ip.PNG","hash":"38b668d6101e33291dafedd8813e8eaf3a6c56fd","modified":1548679628933},{"_id":"public/2018/11/28/2018-11-28-docker-2/docker-hub.png","hash":"1ff9c745f8651f651c2f83529af792b4851689fc","modified":1548679628933},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/image-20180831234615081.png","hash":"c80e8087b73e4f149b9ab607a76187a6fc9fdf17","modified":1548679628933},{"_id":"public/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1548679628953},{"_id":"public/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1548679628963},{"_id":"public/js/third-party/reveal/reveal.min.js","hash":"d8377a86451712488dea87caf5acbf8e97aa991f","modified":1548679628963},{"_id":"public/2018/09/22/2018-09-21-spring-ioc-2/containers.jpg","hash":"b51257292a3497e4adcdf5560a7f09f7f1a8b5a6","modified":1548679628963},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/RequestMappingHandlerAdapter.png","hash":"71751889b49d402fe29355c7ea9bb172ead4b95c","modified":1548679628963},{"_id":"public/2018/11/25/2018-11-25-docker-1/docker-image.png","hash":"3bd173b53ce8a8491633389df24444f0cd0fe579","modified":1548679628984},{"_id":"public/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1548679628991},{"_id":"public/2018/11/25/2018-11-25-docker-1/docking-image.png","hash":"6b64b14f241d12e7e2b9d9dd24bfff05af593a95","modified":1548679629009},{"_id":"public/js/third-party/reveal/highlight.min.js","hash":"10dd530e712a67f25cf27845213c0f28d2fe9e4d","modified":1548679629020}],"Category":[],"Data":[{"_id":"melody","data":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}],"Page":[{"layout":"404","description":"제대로 된 주소는 아니네요~","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"제대로 된 주소는 아니네요~\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2018-12-22T10:57:28.705Z","updated":"2018-12-22T10:57:28.705Z","path":"404.html","title":"","comments":1,"_id":"cjrgbv2pl0000cr1t6auy960c","content":"","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T19:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n> 개발 공부 열심히!!\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n> 개발 공부 열심히!!\n","updated":"2018-11-27T07:23:32.407Z","path":"about/index.html","_id":"cjrgbv2r10001cr1tl1mqazuv","content":"<blockquote>\n<p>개발 공부 열심히!!</p>\n</blockquote>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<blockquote>\n<p>개발 공부 열심히!!</p>\n</blockquote>\n"},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T11:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2018-11-27T07:23:32.408Z","path":"archive/index.html","_id":"cjrgbv2r60003cr1tkyovw6yt","content":"","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":""},{"title":"Categories","type":"categories","header-img":"img/home-bg.jpg","date":"2018-12-22T09:41:04.000Z","description":null,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\nheader-img: img/home-bg.jpg\ndate: 2018-12-22 18:41:04\ndescription:\n---\n","updated":"2018-12-22T10:57:28.707Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjrgbv2r80005cr1tikv6lyhl","content":"","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","type":"tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ntype: \"tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2018-12-22T10:57:28.708Z","updated":"2018-12-22T10:57:28.708Z","path":"tags/index.html","comments":1,"_id":"cjrgbv2ra0007cr1t11i1nm3s","content":"","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"Spring AOP (1)","subtitle":"1. AOP를 사용해야 하는 이유","date":"2018-07-15T13:28:13.000Z","background":"/img/posts/06.jpg","_content":"\n\n\n개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다. \nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.\n\n\n\n# 들어가면서..\n\n\n\n정리하고자 하는 내용\n\n1. AOP를 사용해야하는 이유\n2. AOP에서 사용되는 용어 정리\n3. \u0010Spring AOP\n4. AspectJ\n5. Custom Annotation\n\n\n\n내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.\n\n\n\n# 1. AOP를 사용 해야 하는 이유\n\n## AOP란?\n\n AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.\n\n예를 들어 결제를 담당하는 소스가 있다고 할 때\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n~~~\n\n\n\n위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.\n\n여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.\n\n이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.\n\n그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이 \n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.\n\n\n\nAOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    return response;\n}\n~~~\n\n\n\n~~~java\n@Aspect\n@Component\npublic class PaymentLogAdvisor {\n    \n    @Autowired\n    private PaymentLogRepository paymentLogRepository;\n    \n    @AfterReturning(\"execution(* com.example.payment.doPayment*(..))\", returning=\"paymentResponse\")\n    public void afterPayment(JoinPoint jp, PaymentResponse paymentResponse) {\n        Object[] args = jp.getArgs();\n        if(args.length == 0) {\n            throw new illegalArgumentException(\"argument is none\");\n        }\n        \n        if(!(args[0] instanceof PaymentRequest)) {\n            throw new Exception(\"argument is not PaymentRequest Type\");\n        }\n        \n        PaymentRequest paymentRequest = (PaymentRequest) args[0];\n        \n        //결제 로그 삽입\n        paymentLogRepository.insert(paymentRequest, paymentResponse);\n    }\n}\n~~~\n\n","source":"_posts/2018-07-15-spring-aop.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (1)\"\nsubtitle: \"1. AOP를 사용해야 하는 이유\"\ndate:   2018-07-15 22:28:13 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n\n\n개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다. \nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.\n\n\n\n# 들어가면서..\n\n\n\n정리하고자 하는 내용\n\n1. AOP를 사용해야하는 이유\n2. AOP에서 사용되는 용어 정리\n3. \u0010Spring AOP\n4. AspectJ\n5. Custom Annotation\n\n\n\n내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.\n\n\n\n# 1. AOP를 사용 해야 하는 이유\n\n## AOP란?\n\n AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.\n\n예를 들어 결제를 담당하는 소스가 있다고 할 때\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n~~~\n\n\n\n위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.\n\n여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.\n\n이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.\n\n그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이 \n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.\n\n\n\nAOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    return response;\n}\n~~~\n\n\n\n~~~java\n@Aspect\n@Component\npublic class PaymentLogAdvisor {\n    \n    @Autowired\n    private PaymentLogRepository paymentLogRepository;\n    \n    @AfterReturning(\"execution(* com.example.payment.doPayment*(..))\", returning=\"paymentResponse\")\n    public void afterPayment(JoinPoint jp, PaymentResponse paymentResponse) {\n        Object[] args = jp.getArgs();\n        if(args.length == 0) {\n            throw new illegalArgumentException(\"argument is none\");\n        }\n        \n        if(!(args[0] instanceof PaymentRequest)) {\n            throw new Exception(\"argument is not PaymentRequest Type\");\n        }\n        \n        PaymentRequest paymentRequest = (PaymentRequest) args[0];\n        \n        //결제 로그 삽입\n        paymentLogRepository.insert(paymentRequest, paymentResponse);\n    }\n}\n~~~\n\n","slug":"2018-07-15-spring-aop","published":1,"updated":"2018-11-27T07:23:32.352Z","comments":1,"photos":[],"link":"","_id":"cjrgbv2r20002cr1t6xj6xe2r","content":"<p>개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다.\nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.</p>\n<h1 id=\"들어가면서\">들어가면서..</h1>\n<p>정리하고자 하는 내용</p>\n<ol>\n<li>AOP를 사용해야하는 이유</li>\n<li>AOP에서 사용되는 용어 정리</li>\n<li>\u0010Spring AOP</li>\n<li>AspectJ</li>\n<li>Custom Annotation</li>\n</ol>\n<p>내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.</p>\n<h1 id=\"1-aop를-사용-해야-하는-이유\">1. AOP를 사용 해야 하는 이유</h1>\n<h2 id=\"aop란\">AOP란?</h2>\n<p>AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.</p>\n<p>예를 들어 결제를 담당하는 소스가 있다고 할 때</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.</p>\n<p>여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.</p>\n<p>이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.</p>\n<p>그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이\n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.</p>\n<p>AOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PaymentLogAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PaymentLogRepository paymentLogRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning</span>(<span class=\"string\">\"execution(* com.example.payment.doPayment*(..))\"</span>, returning=<span class=\"string\">\"paymentResponse\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPayment</span><span class=\"params\">(JoinPoint jp, PaymentResponse paymentResponse)</span> </span>&#123;</span><br><span class=\"line\">        Object[] args = jp.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> illegalArgumentException(<span class=\"string\">\"argument is none\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(args[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> PaymentRequest)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"argument is not PaymentRequest Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        PaymentRequest paymentRequest = (PaymentRequest) args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//결제 로그 삽입</span></span><br><span class=\"line\">        paymentLogRepository.insert(paymentRequest, paymentResponse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<p>개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다.\nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.</p>\n<h1>들어가면서..</h1>\n<p>정리하고자 하는 내용</p>\n<ol>\n<li>AOP를 사용해야하는 이유</li>\n<li>AOP에서 사용되는 용어 정리</li>\n<li>\u0010Spring AOP</li>\n<li>AspectJ</li>\n<li>Custom Annotation</li>\n</ol>\n<p>내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.</p>\n<h1>1. AOP를 사용 해야 하는 이유</h1>\n<h2>AOP란?</h2>\n<p>AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.</p>\n<p>예를 들어 결제를 담당하는 소스가 있다고 할 때</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.</p>\n<p>여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.</p>\n<p>이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.</p>\n<p>그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이\n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.</p>\n<p>AOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PaymentLogAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PaymentLogRepository paymentLogRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning</span>(<span class=\"string\">\"execution(* com.example.payment.doPayment*(..))\"</span>, returning=<span class=\"string\">\"paymentResponse\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPayment</span><span class=\"params\">(JoinPoint jp, PaymentResponse paymentResponse)</span> </span>&#123;</span><br><span class=\"line\">        Object[] args = jp.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> illegalArgumentException(<span class=\"string\">\"argument is none\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(args[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> PaymentRequest)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"argument is not PaymentRequest Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        PaymentRequest paymentRequest = (PaymentRequest) args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//결제 로그 삽입</span></span><br><span class=\"line\">        paymentLogRepository.insert(paymentRequest, paymentResponse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"layout":"post","title":"Spring AOP (2)","subtitle":"2. AOP에서 사용되는 용어 정리","date":"2018-07-20T14:06:13.000Z","background":"/img/posts/06.jpg","_content":"\n앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.\n\n여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.\n\n\n\n# AOP(Aspect Oriented Programming) 란?\n\n## AOP의 등장배경\n\n AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.  \n\n 수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.\n\n 하지만 객체지향 프로그래밍 방식에도 헛점은 있었다. \n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. `횡단 관심사 (CrossCutting Concerns)`이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.\n\n\n\n## AOP의 개념\n\n 실제 핵심 로직(Core Concern)을 수행하면서 발생하는 `횡단 관심사 (CrossCutting Concerns)` 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.\n\n![횡단관심사와 핵심로직](https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png)\n\nAOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.\n\nAOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다. \nAspect를 정의 하자면, \n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다. \n\n이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.\n\n\n\n# AOP 에서 사용되는 용어들\n\n## Join Point\n\n말그대로 Join + Point이다. `횡단관심사(Cross Cutting Concern)` 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.\n\n## Advice\n\n`횡단관심사(Cross Cutting Concern)` 으로 분리 된 로직에 대한 코드\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어\n\n## Point Cut\n\n말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어\n\n## Weaving\n\nAdvice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.\n방법에 따라 \n* 런타임 시, Proxy로 생성하며 코드를 합치는 방법\n* 컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법\n이 있다.\n\n## Aspect\n\n여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.\n보안, 트랜잭션, 로깅등이 대표적인 예이다.\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.\n\n## Target\n\n핵심 로직을 구현하는 클래스 또는 객체\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.\n\n## Advisor\n\nAdvice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.\n\n\n\n------\n\n참고\n\nhttps://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttp://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106","source":"_posts/2018-07-20-spring-aop2.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (2)\"\nsubtitle: \"2. AOP에서 사용되는 용어 정리\"\ndate:   2018-07-20 23:06:13 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.\n\n여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.\n\n\n\n# AOP(Aspect Oriented Programming) 란?\n\n## AOP의 등장배경\n\n AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.  \n\n 수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.\n\n 하지만 객체지향 프로그래밍 방식에도 헛점은 있었다. \n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. `횡단 관심사 (CrossCutting Concerns)`이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.\n\n\n\n## AOP의 개념\n\n 실제 핵심 로직(Core Concern)을 수행하면서 발생하는 `횡단 관심사 (CrossCutting Concerns)` 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.\n\n![횡단관심사와 핵심로직](https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png)\n\nAOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.\n\nAOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다. \nAspect를 정의 하자면, \n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다. \n\n이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.\n\n\n\n# AOP 에서 사용되는 용어들\n\n## Join Point\n\n말그대로 Join + Point이다. `횡단관심사(Cross Cutting Concern)` 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.\n\n## Advice\n\n`횡단관심사(Cross Cutting Concern)` 으로 분리 된 로직에 대한 코드\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어\n\n## Point Cut\n\n말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어\n\n## Weaving\n\nAdvice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.\n방법에 따라 \n* 런타임 시, Proxy로 생성하며 코드를 합치는 방법\n* 컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법\n이 있다.\n\n## Aspect\n\n여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.\n보안, 트랜잭션, 로깅등이 대표적인 예이다.\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.\n\n## Target\n\n핵심 로직을 구현하는 클래스 또는 객체\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.\n\n## Advisor\n\nAdvice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.\n\n\n\n------\n\n참고\n\nhttps://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttp://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106","slug":"2018-07-20-spring-aop2","published":1,"updated":"2018-11-27T07:23:32.353Z","comments":1,"photos":[],"link":"","_id":"cjrgbv2r60004cr1tak9ev5e1","content":"<p>앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.</p>\n<p>여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.</p>\n<h1 id=\"aopaspect-oriented-programming-란\">AOP(Aspect Oriented Programming) 란?</h1>\n<h2 id=\"aop의-등장배경\">AOP의 등장배경</h2>\n<p>AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.</p>\n<p>수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.</p>\n<p>하지만 객체지향 프로그래밍 방식에도 헛점은 있었다.\n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. <code>횡단 관심사 (CrossCutting Concerns)</code>이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.</p>\n<h2 id=\"aop의-개념\">AOP의 개념</h2>\n<p>실제 핵심 로직(Core Concern)을 수행하면서 발생하는 <code>횡단 관심사 (CrossCutting Concerns)</code> 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.</p>\n<p><img src=\"https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png\" alt=\"횡단관심사와 핵심로직\"></p>\n<p>AOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.</p>\n<p>AOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다.\nAspect를 정의 하자면,\n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다.</p>\n<p>이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.</p>\n<h1 id=\"aop-에서-사용되는-용어들\">AOP 에서 사용되는 용어들</h1>\n<h2 id=\"join-point\">Join Point</h2>\n<p>말그대로 Join + Point이다. <code>횡단관심사(Cross Cutting Concern)</code> 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.</p>\n<h2 id=\"advice\">Advice</h2>\n<p><code>횡단관심사(Cross Cutting Concern)</code> 으로 분리 된 로직에 대한 코드\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어</p>\n<h2 id=\"point-cut\">Point Cut</h2>\n<p>말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어</p>\n<h2 id=\"weaving\">Weaving</h2>\n<p>Advice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.\n방법에 따라</p>\n<ul>\n<li>런타임 시, Proxy로 생성하며 코드를 합치는 방법</li>\n<li>컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법\n이 있다.</li>\n</ul>\n<h2 id=\"aspect\">Aspect</h2>\n<p>여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.\n보안, 트랜잭션, 로깅등이 대표적인 예이다.\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.</p>\n<h2 id=\"target\">Target</h2>\n<p>핵심 로직을 구현하는 클래스 또는 객체\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.</p>\n<h2 id=\"advisor\">Advisor</h2>\n<p>Advice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.</p>\n<hr>\n<p>참고</p>\n<p>https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD</p>\n<p>http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</p>\n<p>http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<p>앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.</p>\n<p>여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.</p>\n<h1>AOP(Aspect Oriented Programming) 란?</h1>\n<h2>AOP의 등장배경</h2>\n<p>AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.</p>\n<p>수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.</p>\n<p>하지만 객체지향 프로그래밍 방식에도 헛점은 있었다.\n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. <code>횡단 관심사 (CrossCutting Concerns)</code>이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.</p>\n<h2>AOP의 개념</h2>\n<p>실제 핵심 로직(Core Concern)을 수행하면서 발생하는 <code>횡단 관심사 (CrossCutting Concerns)</code> 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.</p>\n<p><img src=\"https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png\" alt=\"횡단관심사와 핵심로직\"></p>\n<p>AOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.</p>\n<p>AOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다.\nAspect를 정의 하자면,\n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다.</p>\n<p>이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.</p>\n<h1>AOP 에서 사용되는 용어들</h1>\n<h2>Join Point</h2>\n<p>말그대로 Join + Point이다. <code>횡단관심사(Cross Cutting Concern)</code> 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.</p>\n<h2>Advice</h2>\n<p><code>횡단관심사(Cross Cutting Concern)</code> 으로 분리 된 로직에 대한 코드\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어</p>\n<h2>Point Cut</h2>\n<p>말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어</p>\n<h2>Weaving</h2>\n<p>Advice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.\n방법에 따라</p>\n<ul>\n<li>런타임 시, Proxy로 생성하며 코드를 합치는 방법</li>\n<li>컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법\n이 있다.</li>\n</ul>\n<h2>Aspect</h2>\n<p>여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.\n보안, 트랜잭션, 로깅등이 대표적인 예이다.\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.</p>\n<h2>Target</h2>\n<p>핵심 로직을 구현하는 클래스 또는 객체\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.</p>\n<h2>Advisor</h2>\n<p>Advice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.</p>\n<hr>\n<p>참고</p>\n<p>https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD</p>\n<p>http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</p>\n<p>http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106</p>\n"},{"layout":"post","title":"Spring AOP (5)","subtitle":"5. Custom Annotation Pointcut","date":"2018-07-24T14:14:33.000Z","background":"/img/posts/06.jpg","_content":"\n\n\nAOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.\n아래의 리뷰와 같다.\n\n![AOP코드리뷰](/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP코드리뷰.png)\n\n메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.\n\n이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.\n\n\n\n# Custom Annotation\n\nAPI에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.\n\n\n\n## Annotation 생성하기\n\n~~~java\nimport java.lang.annotation.*;\n\n@Inherited  //Annotation의 상속이 가능함 \n@Documented //JavaDoc 문서 추가 가능\n@Retention(RetentionPolicy.RUNTIME) // 컴파일 이후에도 JVM에 의해서 참조가 가능\n//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효\n//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)\n@Target({\n        ElementType.PACKAGE,         // 패키지 선언시\n        ElementType.TYPE,            // 타입 선언시\n        ElementType.CONSTRUCTOR,     // 생성자 선언시\n        ElementType.FIELD,           // 멤버 변수 선언시\n        ElementType.METHOD,          // 메소드 선언시\n        ElementType.ANNOTATION_TYPE, // 어노테이션 타입 선언시\n        ElementType.LOCAL_VARIABLE,  // 지역 변수 선언시\n        ElementType.PARAMETER,       // 매개 변수 선언시\n        ElementType.TYPE_PARAMETER,  // 매개 변수 타입 선언시\n        ElementType.TYPE_USE         // 타입 사용시\n})\npublic @interface CustomAnnotation {  //interface에 @를 붙여주면 Annotation으로 등록\n    /* enum 타입을 선언할 수 있습니다. */\n    public enum Quality {BAD, GOOD, VERYGOOD}\n    /* String은 기본 자료형은 아니지만 사용 가능합니다. */\n    String value();\n    /* 배열 형태로도 사용할 수 있습니다. */\n    int[] values();\n    /* enum 형태를 사용하는 방법입니다. */\n    Quality quality() default Quality.GOOD;\n}\n~~~\n\n\n\n## Annotation Pointcut 지정하기\n\n예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.\n\n~~~java\npackage com.example.aopexam;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.ComponentScan;\n\n@SpringBootApplication\n//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능\n@ComponentScan(value={\"com.example.aopexam\", \"com.example.custom.annotation\"})\npublic class AopExamApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AopExamApplication.class, args);\n    }\n}\n\n~~~\n\n~~~java\npackage com.example.aopexam;\n\nimport com.example.custom.annotation.CustomLog;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api/aop-test\")\npublic class ApiController {\n\n    @Autowired\n    private ApiService apiService;\n\n    @GetMapping\n    @CustomLog //get 메소드에 @CustomLog추가\n    public void getTest() {\n        apiService.method(ApiType.GET);\n    }\n\n    @PostMapping\n    public void postTest() {\n        apiService.method(ApiType.POST);\n    }\n\n    @PutMapping\n    public void putTest() {\n        apiService.method(ApiType.PUT);\n    }\n\n    @DeleteMapping\n    public void deleteTest() {\n        apiService.method(ApiType.DELETE);\n    }\n\n}\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD) //메소드 어노테이션 적용\npublic @interface CustomLog {\n}\n\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@EnableAspectJAutoProxy(proxyTargetClass = true) //cglib 사용 -> class기반 proxy생성\n@Component\npublic class CustomLogAdvisor {\n\n    //Annotation을 기준으로 pointcut설정\n    @Pointcut(\"@annotation(com.example.custom.annotation.CustomLog)\")\n    public void customLogPointcut() {\n    }\n\n    @Before(value=\"customLogPointcut()\")\n    public void pringLog() {\n        System.out.println(\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\");\n    }\n}\n~~~\n\n~~~log\nhttp://localhost:8080/api/aop-test\n\n메소드 실행 전 무조건 이 로그를 보게 될 것이야...\n[ApiService.method] apiType : GET\n~~~\n\n","source":"_posts/2018-07-24-spring-aop5.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (5)\"\nsubtitle: \"5. Custom Annotation Pointcut\"\ndate:   2018-07-24 23:14:33 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n\n\nAOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.\n아래의 리뷰와 같다.\n\n![AOP코드리뷰](/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP코드리뷰.png)\n\n메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.\n\n이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.\n\n\n\n# Custom Annotation\n\nAPI에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.\n\n\n\n## Annotation 생성하기\n\n~~~java\nimport java.lang.annotation.*;\n\n@Inherited  //Annotation의 상속이 가능함 \n@Documented //JavaDoc 문서 추가 가능\n@Retention(RetentionPolicy.RUNTIME) // 컴파일 이후에도 JVM에 의해서 참조가 가능\n//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효\n//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)\n@Target({\n        ElementType.PACKAGE,         // 패키지 선언시\n        ElementType.TYPE,            // 타입 선언시\n        ElementType.CONSTRUCTOR,     // 생성자 선언시\n        ElementType.FIELD,           // 멤버 변수 선언시\n        ElementType.METHOD,          // 메소드 선언시\n        ElementType.ANNOTATION_TYPE, // 어노테이션 타입 선언시\n        ElementType.LOCAL_VARIABLE,  // 지역 변수 선언시\n        ElementType.PARAMETER,       // 매개 변수 선언시\n        ElementType.TYPE_PARAMETER,  // 매개 변수 타입 선언시\n        ElementType.TYPE_USE         // 타입 사용시\n})\npublic @interface CustomAnnotation {  //interface에 @를 붙여주면 Annotation으로 등록\n    /* enum 타입을 선언할 수 있습니다. */\n    public enum Quality {BAD, GOOD, VERYGOOD}\n    /* String은 기본 자료형은 아니지만 사용 가능합니다. */\n    String value();\n    /* 배열 형태로도 사용할 수 있습니다. */\n    int[] values();\n    /* enum 형태를 사용하는 방법입니다. */\n    Quality quality() default Quality.GOOD;\n}\n~~~\n\n\n\n## Annotation Pointcut 지정하기\n\n예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.\n\n~~~java\npackage com.example.aopexam;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.ComponentScan;\n\n@SpringBootApplication\n//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능\n@ComponentScan(value={\"com.example.aopexam\", \"com.example.custom.annotation\"})\npublic class AopExamApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AopExamApplication.class, args);\n    }\n}\n\n~~~\n\n~~~java\npackage com.example.aopexam;\n\nimport com.example.custom.annotation.CustomLog;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api/aop-test\")\npublic class ApiController {\n\n    @Autowired\n    private ApiService apiService;\n\n    @GetMapping\n    @CustomLog //get 메소드에 @CustomLog추가\n    public void getTest() {\n        apiService.method(ApiType.GET);\n    }\n\n    @PostMapping\n    public void postTest() {\n        apiService.method(ApiType.POST);\n    }\n\n    @PutMapping\n    public void putTest() {\n        apiService.method(ApiType.PUT);\n    }\n\n    @DeleteMapping\n    public void deleteTest() {\n        apiService.method(ApiType.DELETE);\n    }\n\n}\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD) //메소드 어노테이션 적용\npublic @interface CustomLog {\n}\n\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@EnableAspectJAutoProxy(proxyTargetClass = true) //cglib 사용 -> class기반 proxy생성\n@Component\npublic class CustomLogAdvisor {\n\n    //Annotation을 기준으로 pointcut설정\n    @Pointcut(\"@annotation(com.example.custom.annotation.CustomLog)\")\n    public void customLogPointcut() {\n    }\n\n    @Before(value=\"customLogPointcut()\")\n    public void pringLog() {\n        System.out.println(\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\");\n    }\n}\n~~~\n\n~~~log\nhttp://localhost:8080/api/aop-test\n\n메소드 실행 전 무조건 이 로그를 보게 될 것이야...\n[ApiService.method] apiType : GET\n~~~\n\n","slug":"2018-07-24-spring-aop5","published":1,"updated":"2018-11-27T07:23:32.353Z","comments":1,"photos":[],"link":"","_id":"cjrgbv2r90006cr1ti1twnyr1","content":"<p>AOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.\n아래의 리뷰와 같다.</p>\n<p><img src=\"/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2.png\" alt=\"AOP코드리뷰\"></p>\n<p>메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.</p>\n<p>이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.</p>\n<h1 id=\"custom-annotation\">Custom Annotation</h1>\n<p>API에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.</p>\n<h2 id=\"annotation-생성하기\">Annotation 생성하기</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span>  <span class=\"comment\">//Annotation의 상속이 가능함 </span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span> <span class=\"comment\">//JavaDoc 문서 추가 가능</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME) <span class=\"comment\">// 컴파일 이후에도 JVM에 의해서 참조가 가능</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;</span><br><span class=\"line\">        ElementType.PACKAGE,         <span class=\"comment\">// 패키지 선언시</span></span><br><span class=\"line\">        ElementType.TYPE,            <span class=\"comment\">// 타입 선언시</span></span><br><span class=\"line\">        ElementType.CONSTRUCTOR,     <span class=\"comment\">// 생성자 선언시</span></span><br><span class=\"line\">        ElementType.FIELD,           <span class=\"comment\">// 멤버 변수 선언시</span></span><br><span class=\"line\">        ElementType.METHOD,          <span class=\"comment\">// 메소드 선언시</span></span><br><span class=\"line\">        ElementType.ANNOTATION_TYPE, <span class=\"comment\">// 어노테이션 타입 선언시</span></span><br><span class=\"line\">        ElementType.LOCAL_VARIABLE,  <span class=\"comment\">// 지역 변수 선언시</span></span><br><span class=\"line\">        ElementType.PARAMETER,       <span class=\"comment\">// 매개 변수 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_PARAMETER,  <span class=\"comment\">// 매개 변수 타입 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_USE         <span class=\"comment\">// 타입 사용시</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomAnnotation &#123;  <span class=\"comment\">//interface에 @를 붙여주면 Annotation으로 등록</span></span><br><span class=\"line\">    <span class=\"comment\">/* enum 타입을 선언할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Quality &#123;BAD, GOOD, VERYGOOD&#125;</span><br><span class=\"line\">    <span class=\"comment\">/* String은 기본 자료형은 아니지만 사용 가능합니다. */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 배열 형태로도 사용할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] values();</span><br><span class=\"line\">    <span class=\"comment\">/* enum 형태를 사용하는 방법입니다. */</span></span><br><span class=\"line\">    <span class=\"function\">Quality <span class=\"title\">quality</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Quality.GOOD</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"annotation-pointcut-지정하기\">Annotation Pointcut 지정하기</h2>\n<p>예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(value=&#123;<span class=\"string\">\"com.example.aopexam\"</span>, <span class=\"string\">\"com.example.custom.annotation\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AopExamApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(AopExamApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.custom.annotation.CustomLog;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/api/aop-test\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiService apiService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@CustomLog</span> <span class=\"comment\">//get 메소드에 @CustomLog추가</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.GET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.POST);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.PUT);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.DELETE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.ElementType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD) <span class=\"comment\">//메소드 어노테이션 적용</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomLog &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class=\"keyword\">true</span>) <span class=\"comment\">//cglib 사용 -&gt; class기반 proxy생성</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomLogAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Annotation을 기준으로 pointcut설정</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@annotation(com.example.custom.annotation.CustomLog)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">customLogPointcut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(value=<span class=\"string\">\"customLogPointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pringLog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/api/aop-test</span><br><span class=\"line\"></span><br><span class=\"line\">메소드 실행 전 무조건 이 로그를 보게 될 것이야...</span><br><span class=\"line\">[ApiService.method] apiType : GET</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<p>AOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.\n아래의 리뷰와 같다.</p>\n<p><img src=\"/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2.png\" alt=\"AOP코드리뷰\"></p>\n<p>메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.</p>\n<p>이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.</p>\n<h1>Custom Annotation</h1>\n<p>API에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.</p>\n<h2>Annotation 생성하기</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span>  <span class=\"comment\">//Annotation의 상속이 가능함 </span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span> <span class=\"comment\">//JavaDoc 문서 추가 가능</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME) <span class=\"comment\">// 컴파일 이후에도 JVM에 의해서 참조가 가능</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;</span><br><span class=\"line\">        ElementType.PACKAGE,         <span class=\"comment\">// 패키지 선언시</span></span><br><span class=\"line\">        ElementType.TYPE,            <span class=\"comment\">// 타입 선언시</span></span><br><span class=\"line\">        ElementType.CONSTRUCTOR,     <span class=\"comment\">// 생성자 선언시</span></span><br><span class=\"line\">        ElementType.FIELD,           <span class=\"comment\">// 멤버 변수 선언시</span></span><br><span class=\"line\">        ElementType.METHOD,          <span class=\"comment\">// 메소드 선언시</span></span><br><span class=\"line\">        ElementType.ANNOTATION_TYPE, <span class=\"comment\">// 어노테이션 타입 선언시</span></span><br><span class=\"line\">        ElementType.LOCAL_VARIABLE,  <span class=\"comment\">// 지역 변수 선언시</span></span><br><span class=\"line\">        ElementType.PARAMETER,       <span class=\"comment\">// 매개 변수 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_PARAMETER,  <span class=\"comment\">// 매개 변수 타입 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_USE         <span class=\"comment\">// 타입 사용시</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomAnnotation &#123;  <span class=\"comment\">//interface에 @를 붙여주면 Annotation으로 등록</span></span><br><span class=\"line\">    <span class=\"comment\">/* enum 타입을 선언할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Quality &#123;BAD, GOOD, VERYGOOD&#125;</span><br><span class=\"line\">    <span class=\"comment\">/* String은 기본 자료형은 아니지만 사용 가능합니다. */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 배열 형태로도 사용할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] values();</span><br><span class=\"line\">    <span class=\"comment\">/* enum 형태를 사용하는 방법입니다. */</span></span><br><span class=\"line\">    <span class=\"function\">Quality <span class=\"title\">quality</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Quality.GOOD</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>Annotation Pointcut 지정하기</h2>\n<p>예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(value=&#123;<span class=\"string\">\"com.example.aopexam\"</span>, <span class=\"string\">\"com.example.custom.annotation\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AopExamApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(AopExamApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.custom.annotation.CustomLog;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/api/aop-test\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiService apiService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@CustomLog</span> <span class=\"comment\">//get 메소드에 @CustomLog추가</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.GET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.POST);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.PUT);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.DELETE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.ElementType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD) <span class=\"comment\">//메소드 어노테이션 적용</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomLog &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class=\"keyword\">true</span>) <span class=\"comment\">//cglib 사용 -&gt; class기반 proxy생성</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomLogAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Annotation을 기준으로 pointcut설정</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@annotation(com.example.custom.annotation.CustomLog)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">customLogPointcut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(value=<span class=\"string\">\"customLogPointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pringLog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/api/aop-test</span><br><span class=\"line\"></span><br><span class=\"line\">메소드 실행 전 무조건 이 로그를 보게 될 것이야...</span><br><span class=\"line\">[ApiService.method] apiType : GET</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Spring에서 Client IP구하기","catalog":true,"date":"2018-08-10T13:24:23.000Z","subtitle":null,"header-img":null,"typora-root-url":"./2018-08-10-httprequest-client-ip","typora-copy-images-to":"./2018-08-10-httprequest-client-ip","_content":"\n\n\n# HttpServletRequest에서 IP 구하기\n\n회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다. \n\n생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.\n\nHttpServletRequest에서 IP를 구하는 소스는 아래와 같다.\n\n이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 ([Spring Argument Resolver](https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/))\n\n~~~java\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            //Proxy 서버인 경우\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            //Weblogic 서버인 경우\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n~~~\n\n\n\n보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.\n구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.\n\n\n\n\n\n# IPv6 형식으로 나오는 IP를 IPv4로 변환\n\n위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.\n\n![ipv6](./ipv6.png)\n\n \n\n예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다. \n\n\n IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.\n\n1. Tomcat인 경우\n   1. $CATALINA_HOME\\bin\\catalina.bat(.sh) 을 찾는다.\n   2. `:noJuliConfig, :noJuliManager` 를 검색한다. \n   3. JAVA_OPTS에 `-Djava.net.preferIPv4Stack=true` 를 추가한다.\n\n~~~shell\nif not \"%LOGGING_CONFIG%\" == \"\" goto noJuliConfig\nset LOGGING_CONFIG=-Dnop\nif not exist \"%CATALINA_BASE%\\conf\\logging.properties\" goto noJuliConfig\nset LOGGING_CONFIG=-Djava.util.logging.config.file=\"%CATALINA_BASE%\\conf\\logging.properties\"\n:noJuliConfig\nset JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true\n\nif not \"%LOGGING_MANAGER%\" == \"\" goto noJuliManager\nset LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager\n:noJuliManager\nset JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true\n~~~\n\n\n\n2. 개발 환경에서 VM 속성 추가 하기\n   1. 사용 중인 IDE에서 VM Options에 `-Djava.net.preferIPv4Stack=true` 를 추가한다.\n\n![ide-setting](./ide-setting.png)\n\n\n\n확인 결과\n\n![ipv4](./ipv4.png)\n\n\n\n127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.\n\n\n\n# 참고\n\nhttp://all-record.tistory.com/168\nhttp://www.leafcats.com/35\nhttp://ooz.co.kr/138","source":"_posts/2018-08-10-httprequest-client-ip.md","raw":"---\ntitle: Spring에서 Client IP구하기\ncatalog: true\ndate: 2018-08-10 22:24:23\nsubtitle:\nheader-img:\ntags: Spring\ntypora-root-url: ./2018-08-10-httprequest-client-ip\ntypora-copy-images-to: ./2018-08-10-httprequest-client-ip\n---\n\n\n\n# HttpServletRequest에서 IP 구하기\n\n회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다. \n\n생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.\n\nHttpServletRequest에서 IP를 구하는 소스는 아래와 같다.\n\n이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 ([Spring Argument Resolver](https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/))\n\n~~~java\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            //Proxy 서버인 경우\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            //Weblogic 서버인 경우\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n~~~\n\n\n\n보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.\n구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.\n\n\n\n\n\n# IPv6 형식으로 나오는 IP를 IPv4로 변환\n\n위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.\n\n![ipv6](./ipv6.png)\n\n \n\n예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다. \n\n\n IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.\n\n1. Tomcat인 경우\n   1. $CATALINA_HOME\\bin\\catalina.bat(.sh) 을 찾는다.\n   2. `:noJuliConfig, :noJuliManager` 를 검색한다. \n   3. JAVA_OPTS에 `-Djava.net.preferIPv4Stack=true` 를 추가한다.\n\n~~~shell\nif not \"%LOGGING_CONFIG%\" == \"\" goto noJuliConfig\nset LOGGING_CONFIG=-Dnop\nif not exist \"%CATALINA_BASE%\\conf\\logging.properties\" goto noJuliConfig\nset LOGGING_CONFIG=-Djava.util.logging.config.file=\"%CATALINA_BASE%\\conf\\logging.properties\"\n:noJuliConfig\nset JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true\n\nif not \"%LOGGING_MANAGER%\" == \"\" goto noJuliManager\nset LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager\n:noJuliManager\nset JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true\n~~~\n\n\n\n2. 개발 환경에서 VM 속성 추가 하기\n   1. 사용 중인 IDE에서 VM Options에 `-Djava.net.preferIPv4Stack=true` 를 추가한다.\n\n![ide-setting](./ide-setting.png)\n\n\n\n확인 결과\n\n![ipv4](./ipv4.png)\n\n\n\n127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.\n\n\n\n# 참고\n\nhttp://all-record.tistory.com/168\nhttp://www.leafcats.com/35\nhttp://ooz.co.kr/138","slug":"2018-08-10-httprequest-client-ip","published":1,"updated":"2018-11-27T07:23:32.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2rb0008cr1trwjpe3de","content":"<h1 id=\"httpservletrequest에서-ip-구하기\">HttpServletRequest에서 IP 구하기</h1>\n<p>회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다.</p>\n<p>생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.</p>\n<p>HttpServletRequest에서 IP를 구하는 소스는 아래와 같다.</p>\n<p>이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 (<a href=\"https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/\">Spring Argument Resolver</a>)</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Proxy 서버인 경우</span></span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Weblogic 서버인 경우</span></span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getRemoteAddr();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.\n구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.</p>\n<h1 id=\"ipv6-형식으로-나오는-ip를-ipv4로-변환\">IPv6 형식으로 나오는 IP를 IPv4로 변환</h1>\n<p>위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.</p>\n<p><img src=\"./ipv6.png\" alt=\"ipv6\"></p>\n<p>예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다.</p>\n<p>IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.</p>\n<ol>\n<li>Tomcat인 경우\n<ol>\n<li>$CATALINA_HOME\\bin\\catalina.bat(.sh) 을 찾는다.</li>\n<li><code>:noJuliConfig, :noJuliManager</code> 를 검색한다.</li>\n<li>JAVA_OPTS에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>\n</ol>\n</li>\n</ol>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if not \"%LOGGING_CONFIG%\" == \"\" goto noJuliConfig</span><br><span class=\"line\">set LOGGING_CONFIG=-Dnop</span><br><span class=\"line\">if not exist \"%CATALINA_BASE%\\conf\\logging.properties\" goto noJuliConfig</span><br><span class=\"line\">set LOGGING_CONFIG=-Djava.util.logging.config.file=\"%CATALINA_BASE%\\conf\\logging.properties\"</span><br><span class=\"line\">:noJuliConfig</span><br><span class=\"line\">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true</span><br><span class=\"line\"></span><br><span class=\"line\">if not \"%LOGGING_MANAGER%\" == \"\" goto noJuliManager</span><br><span class=\"line\">set LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class=\"line\">:noJuliManager</span><br><span class=\"line\">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>개발 환경에서 VM 속성 추가 하기\n<ol>\n<li>사용 중인 IDE에서 VM Options에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"./ide-setting.png\" alt=\"ide-setting\"></p>\n<p>확인 결과</p>\n<p><img src=\"./ipv4.png\" alt=\"ipv4\"></p>\n<p>127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.</p>\n<h1 id=\"참고\">참고</h1>\n<p>http://all-record.tistory.com/168\nhttp://www.leafcats.com/35\nhttp://ooz.co.kr/138</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>HttpServletRequest에서 IP 구하기</h1>\n<p>회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다.</p>\n<p>생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.</p>\n<p>HttpServletRequest에서 IP를 구하는 소스는 아래와 같다.</p>\n<p>이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 (<a href=\"https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/\">Spring Argument Resolver</a>)</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Proxy 서버인 경우</span></span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Weblogic 서버인 경우</span></span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getRemoteAddr();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.\n구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.</p>\n<h1>IPv6 형식으로 나오는 IP를 IPv4로 변환</h1>\n<p>위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.</p>\n<p><img src=\"./ipv6.png\" alt=\"ipv6\"></p>\n<p>예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다.</p>\n<p>IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.</p>\n<ol>\n<li>Tomcat인 경우\n<ol>\n<li>$CATALINA_HOME\\bin\\catalina.bat(.sh) 을 찾는다.</li>\n<li><code>:noJuliConfig, :noJuliManager</code> 를 검색한다.</li>\n<li>JAVA_OPTS에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>\n</ol>\n</li>\n</ol>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if not \"%LOGGING_CONFIG%\" == \"\" goto noJuliConfig</span><br><span class=\"line\">set LOGGING_CONFIG=-Dnop</span><br><span class=\"line\">if not exist \"%CATALINA_BASE%\\conf\\logging.properties\" goto noJuliConfig</span><br><span class=\"line\">set LOGGING_CONFIG=-Djava.util.logging.config.file=\"%CATALINA_BASE%\\conf\\logging.properties\"</span><br><span class=\"line\">:noJuliConfig</span><br><span class=\"line\">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true</span><br><span class=\"line\"></span><br><span class=\"line\">if not \"%LOGGING_MANAGER%\" == \"\" goto noJuliManager</span><br><span class=\"line\">set LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class=\"line\">:noJuliManager</span><br><span class=\"line\">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>개발 환경에서 VM 속성 추가 하기\n<ol>\n<li>사용 중인 IDE에서 VM Options에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"./ide-setting.png\" alt=\"ide-setting\"></p>\n<p>확인 결과</p>\n<p><img src=\"./ipv4.png\" alt=\"ipv4\"></p>\n<p>127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.</p>\n<h1>참고</h1>\n<p>http://all-record.tistory.com/168\nhttp://www.leafcats.com/35\nhttp://ooz.co.kr/138</p>\n"},{"layout":"posts","title":"@Import와 @ImportResource Annotation","date":"2018-10-21T09:53:38.000Z","subtitle":"xml을 Java Config로 변경하기","catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-10-21-java-config-import","typora-copy-images-to":"./2018-10-21-java-config-import","_content":"\n\n\n# 들어가며\n\n회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.\n아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고 \n최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.\n그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.\n\n\n\n# @Import\n\n@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.\n사용하는 개념은 기존에 xml 파일을 import하는.. <import /> 구분과 동일하게 사용된다.\n\n예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면..\n\n\n\n**RedisClusterConfig**\n\n~~~java\n@Configuration\n@Import(value = RedisShardsConfig.class) // Redis Shard정보에 대한 Config이다.\npublic class RedisClusterConfig {\n\n\t@Autowired\n\t@Qualifier(\"redisConfig\")\n\tprivate Properties redisConfig;\n\n\t@Bean\n\tpublic GenericObjectPoolConfig jedisPoolConfig() {\n\t\tJedisPoolConfig poolConfig = new JedisPoolConfig();\n\t    poolConfig.setMaxTotal(redisConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setMaxIdle(commonConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setMinIdle(commonConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setNumTestsPerEvictionRun(2);\n\t\tpoolConfig.setTestOnBorrow(true);\n\t\tpoolConfig.setTestOnReturn(false);\n\t\tpoolConfig.setTestWhileIdle(true);\n\t\tpoolConfig.setTimeBetweenEvictionRunsMillis(300000);\n\t\treturn poolConfig;\n\t}\n    \n    //따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.\n\t@Bean\n\tpublic ShardedJedisPool masterShardedPool(GenericObjectPoolConfig jedisPoolConfig, List<JedisShardInfo> redisMasterShards) {\n\t\treturn new ShardedJedisPool(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);\n\t}\n\n\t@Bean\n\tpublic ShardedJedisPool slaveShardedPool(GenericObjectPoolConfig jedisPoolConfig, List<JedisShardInfo> redisSlaveShards) {\n\t\treturn new ShardedJedisPool(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);\n\t}\n}\n~~~\n\n\n\n**RedisShardsConfig.java**\n\n~~~java\n@Configuration\npublic class RedisShardsConfig {\n\n    @Autowired\n\t@Qualifier(\"redisConfig\")\n\tprivate Properties redisConfig;\n    \n\t@Bean\n\tpublic List<JedisShardInfo> redisMasterShards() {\n        \n        String url = redisConfig.getProperty(\"redis.cluster.url\");\n        //Integer 형변환 생략함...(길어져서 안보임)\n        Integer masterPort1 = redisConfig.getProperty(\"redis.cluster.master.port1\");\n        Integer masterPort2 = redisConfig.getProperty(\"redis.cluster.master.port2\");\n        Integer masterPort3 = redisConfig.getProperty(\"redis.cluster.master.port3\");\n        \n        String masterShardKey1 = redisConfig.getProperty(\"redis.cluster.master.key1\");\n        String masterShardKey2 = redisConfig.getProperty(\"redis.cluster.master.key2\");\n        String masterShardKey3 = redisConfig.getProperty(\"redis.cluster.master.key3\");\n        \n\t\treturn new ArrayList<JedisShardInfo>() {\n\t\t\t{\n\t\t\t\tadd(new JedisShardInfo(url, masterPort1, masterShardKey1));\n\t\t\t\tadd(new JedisShardInfo(url, masterPort2, masterShardKey2));\n\t\t\t\tadd(new JedisShardInfo(url, masterPort3, masterShardKey3));\n\t\t\t}\n\t\t};\n\t}\n\n\t@Bean\n\tpublic List<JedisShardInfo> redisSlaveShards() {\n        \n        String url = redisConfig.getProperty(\"redis.cluster.url\");\n        //Integer 형변환 생략함...(길어져서 안보임)\n        Integer slavePort1 = redisConfig.getProperty(\"redis.cluster.slave.port1\");\n        Integer slavePort2 = redisConfig.getProperty(\"redis.cluster.slave.port2\");\n        Integer slavePort3 = redisConfig.getProperty(\"redis.cluster.slave.port3\");\n        \n        String slaveShardKey1 = redisConfig.getProperty(\"redis.cluster.slave.key1\");\n        String slaveShardKey2 = redisConfig.getProperty(\"redis.cluster.slave.key2\");\n        String slaveShardKey3 = redisConfig.getProperty(\"redis.cluster.slave.key3\");\n        \n\t\treturn new ArrayList<JedisShardInfo>() {\n\t\t\t{\n\t\t\t\tadd(new JedisShardInfo(url, slavePort1, slaveShardKey1));\n\t\t\t\tadd(new JedisShardInfo(url, slavePort2, slaveShardKey2));\n\t\t\t\tadd(new JedisShardInfo(url, slavePort3, slaveShardKey3));\n\t\t\t}\n\t\t};\n\t}\n}\n~~~\n\n\n\nRedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.\nRedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다. \n이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.\n이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.\nxml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.\n\n\n\n# @ImportResource\n\n모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들...)\n\n그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.\n사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.\n\n예시는 아래와 같다.\n\n\n\n~~~java\n@Configuration\n@ImportResource(value = {\n\t\t\"classpath:applicationContextForExternalMember.xml\",    //External-Member\n\t\t\"classpath*:applicationContextForExternalAPI.xml\",      //External-API\n\t\t\"classpath*:applicationContextForExternalLogger.xml\"    //External-Logger\n})\npublic class ExternalConfig {\n}\n~~~\n\n 위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.","source":"_posts/2018-10-21-java-config-import.md","raw":"---\nlayout: posts\ntitle: \"@Import와 @ImportResource Annotation\"\ndate: 2018-10-21 18:53:38\nsubtitle: xml을 Java Config로 변경하기\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\n  - Java-Config\ntypora-root-url: ./2018-10-21-java-config-import\ntypora-copy-images-to: ./2018-10-21-java-config-import\n---\n\n\n\n# 들어가며\n\n회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.\n아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고 \n최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.\n그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.\n\n\n\n# @Import\n\n@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.\n사용하는 개념은 기존에 xml 파일을 import하는.. <import /> 구분과 동일하게 사용된다.\n\n예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면..\n\n\n\n**RedisClusterConfig**\n\n~~~java\n@Configuration\n@Import(value = RedisShardsConfig.class) // Redis Shard정보에 대한 Config이다.\npublic class RedisClusterConfig {\n\n\t@Autowired\n\t@Qualifier(\"redisConfig\")\n\tprivate Properties redisConfig;\n\n\t@Bean\n\tpublic GenericObjectPoolConfig jedisPoolConfig() {\n\t\tJedisPoolConfig poolConfig = new JedisPoolConfig();\n\t    poolConfig.setMaxTotal(redisConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setMaxIdle(commonConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setMinIdle(commonConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setNumTestsPerEvictionRun(2);\n\t\tpoolConfig.setTestOnBorrow(true);\n\t\tpoolConfig.setTestOnReturn(false);\n\t\tpoolConfig.setTestWhileIdle(true);\n\t\tpoolConfig.setTimeBetweenEvictionRunsMillis(300000);\n\t\treturn poolConfig;\n\t}\n    \n    //따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.\n\t@Bean\n\tpublic ShardedJedisPool masterShardedPool(GenericObjectPoolConfig jedisPoolConfig, List<JedisShardInfo> redisMasterShards) {\n\t\treturn new ShardedJedisPool(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);\n\t}\n\n\t@Bean\n\tpublic ShardedJedisPool slaveShardedPool(GenericObjectPoolConfig jedisPoolConfig, List<JedisShardInfo> redisSlaveShards) {\n\t\treturn new ShardedJedisPool(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);\n\t}\n}\n~~~\n\n\n\n**RedisShardsConfig.java**\n\n~~~java\n@Configuration\npublic class RedisShardsConfig {\n\n    @Autowired\n\t@Qualifier(\"redisConfig\")\n\tprivate Properties redisConfig;\n    \n\t@Bean\n\tpublic List<JedisShardInfo> redisMasterShards() {\n        \n        String url = redisConfig.getProperty(\"redis.cluster.url\");\n        //Integer 형변환 생략함...(길어져서 안보임)\n        Integer masterPort1 = redisConfig.getProperty(\"redis.cluster.master.port1\");\n        Integer masterPort2 = redisConfig.getProperty(\"redis.cluster.master.port2\");\n        Integer masterPort3 = redisConfig.getProperty(\"redis.cluster.master.port3\");\n        \n        String masterShardKey1 = redisConfig.getProperty(\"redis.cluster.master.key1\");\n        String masterShardKey2 = redisConfig.getProperty(\"redis.cluster.master.key2\");\n        String masterShardKey3 = redisConfig.getProperty(\"redis.cluster.master.key3\");\n        \n\t\treturn new ArrayList<JedisShardInfo>() {\n\t\t\t{\n\t\t\t\tadd(new JedisShardInfo(url, masterPort1, masterShardKey1));\n\t\t\t\tadd(new JedisShardInfo(url, masterPort2, masterShardKey2));\n\t\t\t\tadd(new JedisShardInfo(url, masterPort3, masterShardKey3));\n\t\t\t}\n\t\t};\n\t}\n\n\t@Bean\n\tpublic List<JedisShardInfo> redisSlaveShards() {\n        \n        String url = redisConfig.getProperty(\"redis.cluster.url\");\n        //Integer 형변환 생략함...(길어져서 안보임)\n        Integer slavePort1 = redisConfig.getProperty(\"redis.cluster.slave.port1\");\n        Integer slavePort2 = redisConfig.getProperty(\"redis.cluster.slave.port2\");\n        Integer slavePort3 = redisConfig.getProperty(\"redis.cluster.slave.port3\");\n        \n        String slaveShardKey1 = redisConfig.getProperty(\"redis.cluster.slave.key1\");\n        String slaveShardKey2 = redisConfig.getProperty(\"redis.cluster.slave.key2\");\n        String slaveShardKey3 = redisConfig.getProperty(\"redis.cluster.slave.key3\");\n        \n\t\treturn new ArrayList<JedisShardInfo>() {\n\t\t\t{\n\t\t\t\tadd(new JedisShardInfo(url, slavePort1, slaveShardKey1));\n\t\t\t\tadd(new JedisShardInfo(url, slavePort2, slaveShardKey2));\n\t\t\t\tadd(new JedisShardInfo(url, slavePort3, slaveShardKey3));\n\t\t\t}\n\t\t};\n\t}\n}\n~~~\n\n\n\nRedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.\nRedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다. \n이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.\n이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.\nxml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.\n\n\n\n# @ImportResource\n\n모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들...)\n\n그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.\n사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.\n\n예시는 아래와 같다.\n\n\n\n~~~java\n@Configuration\n@ImportResource(value = {\n\t\t\"classpath:applicationContextForExternalMember.xml\",    //External-Member\n\t\t\"classpath*:applicationContextForExternalAPI.xml\",      //External-API\n\t\t\"classpath*:applicationContextForExternalLogger.xml\"    //External-Logger\n})\npublic class ExternalConfig {\n}\n~~~\n\n 위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.","slug":"2018-10-21-java-config-import","published":1,"updated":"2018-11-27T07:23:32.380Z","comments":1,"photos":[],"link":"","_id":"cjrgbv2rf0009cr1tl647nrew","content":"<h1 id=\"들어가며\">들어가며</h1>\n<p>회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.\n아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고\n최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.\n그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.</p>\n<h1 id=\"import\">@Import</h1>\n<p>@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.\n사용하는 개념은 기존에 xml 파일을 import하는.. &lt;import /&gt; 구분과 동일하게 사용된다.</p>\n<p>예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면..</p>\n<p><strong>RedisClusterConfig</strong></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(value = RedisShardsConfig.class) <span class=\"comment\">// Redis Shard정보에 대한 Config이다.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisClusterConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"redisConfig\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Properties redisConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> GenericObjectPoolConfig <span class=\"title\">jedisPoolConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tJedisPoolConfig poolConfig = <span class=\"keyword\">new</span> JedisPoolConfig();</span><br><span class=\"line\">\t    poolConfig.setMaxTotal(redisConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setMaxIdle(commonConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setMinIdle(commonConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setNumTestsPerEvictionRun(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestOnReturn(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestWhileIdle(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTimeBetweenEvictionRunsMillis(<span class=\"number\">300000</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> poolConfig;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ShardedJedisPool <span class=\"title\">masterShardedPool</span><span class=\"params\">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisMasterShards)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ShardedJedisPool(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ShardedJedisPool <span class=\"title\">slaveShardedPool</span><span class=\"params\">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisSlaveShards)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ShardedJedisPool(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>RedisShardsConfig.java</strong></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisShardsConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"redisConfig\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Properties redisConfig;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;JedisShardInfo&gt; <span class=\"title\">redisMasterShards</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String url = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.url\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class=\"line\">        Integer masterPort1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port1\"</span>);</span><br><span class=\"line\">        Integer masterPort2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port2\"</span>);</span><br><span class=\"line\">        Integer masterPort3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        String masterShardKey1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key1\"</span>);</span><br><span class=\"line\">        String masterShardKey2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key2\"</span>);</span><br><span class=\"line\">        String masterShardKey3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort1, masterShardKey1));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort2, masterShardKey2));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort3, masterShardKey3));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;JedisShardInfo&gt; <span class=\"title\">redisSlaveShards</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String url = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.url\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class=\"line\">        Integer slavePort1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port1\"</span>);</span><br><span class=\"line\">        Integer slavePort2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port2\"</span>);</span><br><span class=\"line\">        Integer slavePort3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        String slaveShardKey1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key1\"</span>);</span><br><span class=\"line\">        String slaveShardKey2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key2\"</span>);</span><br><span class=\"line\">        String slaveShardKey3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort1, slaveShardKey1));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort2, slaveShardKey2));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort3, slaveShardKey3));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>RedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.\nRedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다.\n이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.\n이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.\nxml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.</p>\n<h1 id=\"importresource\">@ImportResource</h1>\n<p>모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들...)</p>\n<p>그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.\n사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.</p>\n<p>예시는 아래와 같다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource</span>(value = &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath:applicationContextForExternalMember.xml\"</span>,    <span class=\"comment\">//External-Member</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath*:applicationContextForExternalAPI.xml\"</span>,      <span class=\"comment\">//External-API</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath*:applicationContextForExternalLogger.xml\"</span>    <span class=\"comment\">//External-Logger</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExternalConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.\n아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고\n최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.\n그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.</p>\n<h1>@Import</h1>\n<p>@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.\n사용하는 개념은 기존에 xml 파일을 import하는.. &lt;import /&gt; 구분과 동일하게 사용된다.</p>\n<p>예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면..</p>\n<p><strong>RedisClusterConfig</strong></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(value = RedisShardsConfig.class) <span class=\"comment\">// Redis Shard정보에 대한 Config이다.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisClusterConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"redisConfig\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Properties redisConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> GenericObjectPoolConfig <span class=\"title\">jedisPoolConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tJedisPoolConfig poolConfig = <span class=\"keyword\">new</span> JedisPoolConfig();</span><br><span class=\"line\">\t    poolConfig.setMaxTotal(redisConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setMaxIdle(commonConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setMinIdle(commonConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setNumTestsPerEvictionRun(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestOnReturn(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestWhileIdle(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTimeBetweenEvictionRunsMillis(<span class=\"number\">300000</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> poolConfig;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ShardedJedisPool <span class=\"title\">masterShardedPool</span><span class=\"params\">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisMasterShards)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ShardedJedisPool(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ShardedJedisPool <span class=\"title\">slaveShardedPool</span><span class=\"params\">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisSlaveShards)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ShardedJedisPool(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>RedisShardsConfig.java</strong></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisShardsConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"redisConfig\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Properties redisConfig;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;JedisShardInfo&gt; <span class=\"title\">redisMasterShards</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String url = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.url\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class=\"line\">        Integer masterPort1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port1\"</span>);</span><br><span class=\"line\">        Integer masterPort2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port2\"</span>);</span><br><span class=\"line\">        Integer masterPort3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        String masterShardKey1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key1\"</span>);</span><br><span class=\"line\">        String masterShardKey2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key2\"</span>);</span><br><span class=\"line\">        String masterShardKey3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort1, masterShardKey1));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort2, masterShardKey2));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort3, masterShardKey3));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;JedisShardInfo&gt; <span class=\"title\">redisSlaveShards</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String url = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.url\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class=\"line\">        Integer slavePort1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port1\"</span>);</span><br><span class=\"line\">        Integer slavePort2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port2\"</span>);</span><br><span class=\"line\">        Integer slavePort3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        String slaveShardKey1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key1\"</span>);</span><br><span class=\"line\">        String slaveShardKey2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key2\"</span>);</span><br><span class=\"line\">        String slaveShardKey3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort1, slaveShardKey1));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort2, slaveShardKey2));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort3, slaveShardKey3));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>RedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.\nRedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다.\n이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.\n이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.\nxml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.</p>\n<h1>@ImportResource</h1>\n<p>모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들...)</p>\n<p>그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.\n사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.</p>\n<p>예시는 아래와 같다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource</span>(value = &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath:applicationContextForExternalMember.xml\"</span>,    <span class=\"comment\">//External-Member</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath*:applicationContextForExternalAPI.xml\"</span>,      <span class=\"comment\">//External-API</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath*:applicationContextForExternalLogger.xml\"</span>    <span class=\"comment\">//External-Logger</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExternalConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.</p>\n"},{"title":"Application-Context와 Servlet-Context","subtitle":"AOP가 적용되지 않아서...","catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-10-21-spring-context","typora-copy-images-to":"./2018-10-21-spring-context","date":"2018-10-21T08:00:54.000Z","header-img":null,"_content":"\n\n\n# 들어가며\n\n회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.\n문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.\ncore가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,\n각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.\nBean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.\n\n이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.\n\n\n\n# Web Application Context\n\n![img](./99A34C3359FEAA8410.png)\n\n\n\n## Application Context\n\n* Web Application 최상단에 위치하고 있는 Context\n* Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context\n* Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한\n  설정정보를 담은 파일 (Bean 선언 등..)\n* Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)\n* 특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)\n* 서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.\n* **Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.**\n\n\n\n## Servlet-Context (servlet-context.xml)\n\n* Servlet 단위로 생성되는 context\n* Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일\n  (Interceptor, Bean생성, ViewResolver등..)\n* URL설정이 있는 Bean을 생성 (@Controller, Interceptor)\n* Application Context를 자신의 부모 Context로 사용한다.\n* Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,\n  Servlet Context에 선언된 Bean을 사용한다.\n* Bean 찾는 순서 \n  * Servlet Context에서 먼저 찾는다.\n  * 만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.\n* **Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.**\n\n\n\n# web.xml 설정 살펴보기\n\n## web.xml 이란\n\n서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.\n여기서 서블릿 클래스를 등록하는 곳의 이름을 `Web application deployment descriptor`라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 `web.xml`이다. `web.xml` 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.\n\nDD는 WAS 구동 시 `/WEB-INF` 디렉토리에 존재하는 `web.xml`을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n <!-- The definition of the Root Spring Container shared by all Servlets and Filters -->\n      <!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 -->\n      <context-param>  \n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/spring/applicationContext.xml</param-value>\n      </context-param>\n      \n      <!-- Creates the Spring Container shared by all Servlets and Filters -->\n      <!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 -->\n      <listener>\n          <listener-class>\n              org.springframework.web.context.ContextLoaderListener\n          </listener-class>\n      </listener>\n    \n      <!-- Processes application requests -->\n      <servlet> \n          <servlet-name>dispatcherServlet</servlet-name>\n          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \n          <init-param>\n              <param-name>contextConfigLocation</param-name> \n              <param-value>\n                  <!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 -->\n                  /WEB-INF/spring/appServlet/servlet-context.xml\n              </param-value>\n          </init-param>\n          <load-on-startup>1</load-on-startup>\n      </servlet>\n            \n    <!-- dispatcherServlet 대한 url-pattern을 정의 \n        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 -->\n      <servlet-mapping>  \n            <servlet-name>dispatcherServlet</servlet-name>\n            <url-pattern>/</url-pattern>\n      </servlet-mapping>\n</web-app>\n~~~\n\n\n\n# 그래서 Context 설정은 어떻게 쓰냐?\n\nSpring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.\n\n* Application Context\n  * 공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등..)\n  * 각 Servlet에서 공유할 수 있는 Bean\n* Servlet Context\n  * Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등..)\n\n가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.\n각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.\n\n\n\nApplicationContext.xml\n\n~~~xml\n<context:component-scan base-package=\"com.myapp.core, com.myapp.app\">\n    <!-- Component-scan대상에서 @Controller annotation Class는 제외한다. -->\n    <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> \n</context:component-scan>\n~~~\n\n\n\nServlet-Context.xml\n\n~~~xml\n<context:component-scan base-package=\"com.myapp.app\" use-default-filters=\"false\">\n    <!-- Component-scan대상은 @Controller annotation Class만 scan한다. -->\n    <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> \n</context:component-scan>\n~~~\n\nServlet-Context.xml 설정 시, `use-default-filters` 속성을 `false`로 처리 하였다.\n`use-default-filters` 속성은 원래 `default가 true`인데, \n@Compont Annotation(@Controller, @Service, @Repository등..) 의 `클래스를 자동으로 Bean으로 등록해 주는 filter속성`이다. \n따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.\n\n\n\n# 참조\n\n* http://hoonmaro.tistory.com/31\n* https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html","source":"_posts/2018-10-21-spring-context.md","raw":"---\ntitle: Application-Context와 Servlet-Context\nsubtitle: AOP가 적용되지 않아서...\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\n  - WAS\ntypora-root-url: ./2018-10-21-spring-context\ntypora-copy-images-to: ./2018-10-21-spring-context\ndate: 2018-10-21 17:00:54\nheader-img:\n---\n\n\n\n# 들어가며\n\n회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.\n문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.\ncore가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,\n각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.\nBean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.\n\n이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.\n\n\n\n# Web Application Context\n\n![img](./99A34C3359FEAA8410.png)\n\n\n\n## Application Context\n\n* Web Application 최상단에 위치하고 있는 Context\n* Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context\n* Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한\n  설정정보를 담은 파일 (Bean 선언 등..)\n* Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)\n* 특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)\n* 서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.\n* **Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.**\n\n\n\n## Servlet-Context (servlet-context.xml)\n\n* Servlet 단위로 생성되는 context\n* Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일\n  (Interceptor, Bean생성, ViewResolver등..)\n* URL설정이 있는 Bean을 생성 (@Controller, Interceptor)\n* Application Context를 자신의 부모 Context로 사용한다.\n* Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,\n  Servlet Context에 선언된 Bean을 사용한다.\n* Bean 찾는 순서 \n  * Servlet Context에서 먼저 찾는다.\n  * 만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.\n* **Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.**\n\n\n\n# web.xml 설정 살펴보기\n\n## web.xml 이란\n\n서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.\n여기서 서블릿 클래스를 등록하는 곳의 이름을 `Web application deployment descriptor`라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 `web.xml`이다. `web.xml` 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.\n\nDD는 WAS 구동 시 `/WEB-INF` 디렉토리에 존재하는 `web.xml`을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n <!-- The definition of the Root Spring Container shared by all Servlets and Filters -->\n      <!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 -->\n      <context-param>  \n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/spring/applicationContext.xml</param-value>\n      </context-param>\n      \n      <!-- Creates the Spring Container shared by all Servlets and Filters -->\n      <!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 -->\n      <listener>\n          <listener-class>\n              org.springframework.web.context.ContextLoaderListener\n          </listener-class>\n      </listener>\n    \n      <!-- Processes application requests -->\n      <servlet> \n          <servlet-name>dispatcherServlet</servlet-name>\n          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \n          <init-param>\n              <param-name>contextConfigLocation</param-name> \n              <param-value>\n                  <!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 -->\n                  /WEB-INF/spring/appServlet/servlet-context.xml\n              </param-value>\n          </init-param>\n          <load-on-startup>1</load-on-startup>\n      </servlet>\n            \n    <!-- dispatcherServlet 대한 url-pattern을 정의 \n        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 -->\n      <servlet-mapping>  \n            <servlet-name>dispatcherServlet</servlet-name>\n            <url-pattern>/</url-pattern>\n      </servlet-mapping>\n</web-app>\n~~~\n\n\n\n# 그래서 Context 설정은 어떻게 쓰냐?\n\nSpring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.\n\n* Application Context\n  * 공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등..)\n  * 각 Servlet에서 공유할 수 있는 Bean\n* Servlet Context\n  * Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등..)\n\n가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.\n각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.\n\n\n\nApplicationContext.xml\n\n~~~xml\n<context:component-scan base-package=\"com.myapp.core, com.myapp.app\">\n    <!-- Component-scan대상에서 @Controller annotation Class는 제외한다. -->\n    <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> \n</context:component-scan>\n~~~\n\n\n\nServlet-Context.xml\n\n~~~xml\n<context:component-scan base-package=\"com.myapp.app\" use-default-filters=\"false\">\n    <!-- Component-scan대상은 @Controller annotation Class만 scan한다. -->\n    <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> \n</context:component-scan>\n~~~\n\nServlet-Context.xml 설정 시, `use-default-filters` 속성을 `false`로 처리 하였다.\n`use-default-filters` 속성은 원래 `default가 true`인데, \n@Compont Annotation(@Controller, @Service, @Repository등..) 의 `클래스를 자동으로 Bean으로 등록해 주는 filter속성`이다. \n따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.\n\n\n\n# 참조\n\n* http://hoonmaro.tistory.com/31\n* https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html","slug":"2018-10-21-spring-context","published":1,"updated":"2018-11-27T07:23:32.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2ro000bcr1tqqpki2w0","content":"<h1 id=\"들어가며\">들어가며</h1>\n<p>회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.\n문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.\ncore가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,\n각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.\nBean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.</p>\n<p>이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.</p>\n<h1 id=\"web-application-context\">Web Application Context</h1>\n<p><img src=\"./99A34C3359FEAA8410.png\" alt=\"img\"></p>\n<h2 id=\"application-context\">Application Context</h2>\n<ul>\n<li>Web Application 최상단에 위치하고 있는 Context</li>\n<li>Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context</li>\n<li>Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한\n설정정보를 담은 파일 (Bean 선언 등..)</li>\n<li>Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)</li>\n<li>특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)</li>\n<li>서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.</li>\n<li><strong>Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.</strong></li>\n</ul>\n<h2 id=\"servlet-context-servlet-contextxml\">Servlet-Context (servlet-context.xml)</h2>\n<ul>\n<li>Servlet 단위로 생성되는 context</li>\n<li>Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일\n(Interceptor, Bean생성, ViewResolver등..)</li>\n<li>URL설정이 있는 Bean을 생성 (@Controller, Interceptor)</li>\n<li>Application Context를 자신의 부모 Context로 사용한다.</li>\n<li>Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,\nServlet Context에 선언된 Bean을 사용한다.</li>\n<li>Bean 찾는 순서\n<ul>\n<li>Servlet Context에서 먼저 찾는다.</li>\n<li>만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.</li>\n</ul>\n</li>\n<li><strong>Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.</strong></li>\n</ul>\n<h1 id=\"webxml-설정-살펴보기\">web.xml 설정 살펴보기</h1>\n<h2 id=\"webxml-이란\">web.xml 이란</h2>\n<p>서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.\n여기서 서블릿 클래스를 등록하는 곳의 이름을 <code>Web application deployment descriptor</code>라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 <code>web.xml</code>이다. <code>web.xml</code> 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.</p>\n<p>DD는 WAS 구동 시 <code>/WEB-INF</code> 디렉토리에 존재하는 <code>web.xml</code>을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span>&gt;</span></span><br><span class=\"line\"> <span class=\"comment\">&lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>/WEB-INF/spring/applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">              org.springframework.web.context.ContextLoaderListener</span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Processes application requests --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"comment\">&lt;!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 --&gt;</span></span><br><span class=\"line\">                  /WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dispatcherServlet 대한 url-pattern을 정의 </span></span><br><span class=\"line\"><span class=\"comment\">        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"그래서-context-설정은-어떻게-쓰냐\">그래서 Context 설정은 어떻게 쓰냐?</h1>\n<p>Spring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.</p>\n<ul>\n<li>Application Context\n<ul>\n<li>공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등..)</li>\n<li>각 Servlet에서 공유할 수 있는 Bean</li>\n</ul>\n</li>\n<li>Servlet Context\n<ul>\n<li>Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등..)</li>\n</ul>\n</li>\n</ul>\n<p>가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.\n각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.</p>\n<p>ApplicationContext.xml</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.myapp.core, com.myapp.app\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Component-scan대상에서 @Controller annotation Class는 제외한다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:exclude-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Controller\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>Servlet-Context.xml</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.myapp.app\"</span> <span class=\"attr\">use-default-filters</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Component-scan대상은 @Controller annotation Class만 scan한다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Controller\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>Servlet-Context.xml 설정 시, <code>use-default-filters</code> 속성을 <code>false</code>로 처리 하였다.\n<code>use-default-filters</code> 속성은 원래 <code>default가 true</code>인데,\n@Compont Annotation(@Controller, @Service, @Repository등..) 의 <code>클래스를 자동으로 Bean으로 등록해 주는 filter속성</code>이다.\n따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.</p>\n<h1 id=\"참조\">참조</h1>\n<ul>\n<li>http://hoonmaro.tistory.com/31</li>\n<li>https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.\n문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.\ncore가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,\n각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.\nBean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.</p>\n<p>이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.</p>\n<h1>Web Application Context</h1>\n<p><img src=\"./99A34C3359FEAA8410.png\" alt=\"img\"></p>\n<h2>Application Context</h2>\n<ul>\n<li>Web Application 최상단에 위치하고 있는 Context</li>\n<li>Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context</li>\n<li>Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한\n설정정보를 담은 파일 (Bean 선언 등..)</li>\n<li>Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)</li>\n<li>특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)</li>\n<li>서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.</li>\n<li><strong>Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.</strong></li>\n</ul>\n<h2>Servlet-Context (servlet-context.xml)</h2>\n<ul>\n<li>Servlet 단위로 생성되는 context</li>\n<li>Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일\n(Interceptor, Bean생성, ViewResolver등..)</li>\n<li>URL설정이 있는 Bean을 생성 (@Controller, Interceptor)</li>\n<li>Application Context를 자신의 부모 Context로 사용한다.</li>\n<li>Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,\nServlet Context에 선언된 Bean을 사용한다.</li>\n<li>Bean 찾는 순서\n<ul>\n<li>Servlet Context에서 먼저 찾는다.</li>\n<li>만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.</li>\n</ul>\n</li>\n<li><strong>Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.</strong></li>\n</ul>\n<h1>web.xml 설정 살펴보기</h1>\n<h2>web.xml 이란</h2>\n<p>서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.\n여기서 서블릿 클래스를 등록하는 곳의 이름을 <code>Web application deployment descriptor</code>라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 <code>web.xml</code>이다. <code>web.xml</code> 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.</p>\n<p>DD는 WAS 구동 시 <code>/WEB-INF</code> 디렉토리에 존재하는 <code>web.xml</code>을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span>&gt;</span></span><br><span class=\"line\"> <span class=\"comment\">&lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>/WEB-INF/spring/applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">              org.springframework.web.context.ContextLoaderListener</span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Processes application requests --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"comment\">&lt;!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 --&gt;</span></span><br><span class=\"line\">                  /WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dispatcherServlet 대한 url-pattern을 정의 </span></span><br><span class=\"line\"><span class=\"comment\">        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h1>그래서 Context 설정은 어떻게 쓰냐?</h1>\n<p>Spring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.</p>\n<ul>\n<li>Application Context\n<ul>\n<li>공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등..)</li>\n<li>각 Servlet에서 공유할 수 있는 Bean</li>\n</ul>\n</li>\n<li>Servlet Context\n<ul>\n<li>Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등..)</li>\n</ul>\n</li>\n</ul>\n<p>가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.\n각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.</p>\n<p>ApplicationContext.xml</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.myapp.core, com.myapp.app\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Component-scan대상에서 @Controller annotation Class는 제외한다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:exclude-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Controller\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>Servlet-Context.xml</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.myapp.app\"</span> <span class=\"attr\">use-default-filters</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Component-scan대상은 @Controller annotation Class만 scan한다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Controller\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>Servlet-Context.xml 설정 시, <code>use-default-filters</code> 속성을 <code>false</code>로 처리 하였다.\n<code>use-default-filters</code> 속성은 원래 <code>default가 true</code>인데,\n@Compont Annotation(@Controller, @Service, @Repository등..) 의 <code>클래스를 자동으로 Bean으로 등록해 주는 filter속성</code>이다.\n따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.</p>\n<h1>참조</h1>\n<ul>\n<li>http://hoonmaro.tistory.com/31</li>\n<li>https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html</li>\n</ul>\n"},{"title":"EHCache 설정방법 (Spring Boot)","catalog":true,"Categories":["Spring"],"typora-root-url":"2018-11-04-ehcache-config-for-springboot","typora-copy-images-to":"2018-11-04-ehcache-config-for-springboot","date":"2018-11-07T14:38:43.000Z","header-img":null,"_content":"\n# EHCache 설정하기\n\n설정 순서는 아래와 같다.\n\n1. Maven Dependency 설정\n2. Ehcache.xml 작성 (ehcache 설정파일)\n3. @EnableCaching 설정\n\n\n\n# Maven Dependency 설정\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n    <version>2.10.6</version>\n</dependency>\n```\n\n# Ehcache.xml 작성 (ehcache 설정파일)\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         maxBytesLocalHeap=\"300M\" <!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 -->\n         updateCheck=\"false\">\n\n    <!-- 임시저장 경로를 설정 -->\n    <diskStore path=\"java.io.tmpdir\" />\n    <!-- \n        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,\n        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색\n        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환\n    -->\n    <sizeOfPolicy maxDepth=\"100000\" maxDepthExceededBehavior=\"continue\"/>\n\n   <!-- default Cache 설정 (반드시 선언해야 하는 Cache) -->\n    <defaultCache\n            eternal=\"false\"\n            timeToIdleSeconds=\"0\"\n            timeToLiveSeconds=\"1200\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n\n    <!-- 사용하고자 하는 캐시 별 설정 -->\n    <cache name=\"LocalCacheData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n\n   <cache name=\"AuthMemberList\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n</ehcache>\n~~~\n\n* defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)\n* cache는 하나의 캐시를 사용할 때마다 구현\n* name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.\n\n| 속성                            | 설명 | Default |\n| ------------------------------- | ---- | ------------------------------- |\n| name                            | 코드에서 사용할 캐시 name | 필수 |\n|  maxEntriesLocalHeap                                   |메모리에 생성 될 최대 캐시 갯수| 0 |\n|  maxEntriesLocalDisk                                  |디스크에 생성 될 최대 캐시 갯수| 0 |\n| eternal                         | 영속성 캐시 설정 (지워지는 캐시인지?) <br />external = \"true\"이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨 | false |\n| timeToIdleSecond                | 해당 초동안 캐시가 호출 되지 않으면 삭제 | 0 |\n| timeToLiveSeconds               | 해당 초가 지나면 캐시가 삭제 | 0 |\n| overflowToDisk                  | 오버플로우 된 항목에 대해 disk에 저장할 지 여부 | false |\n| diskPersistent                  | 캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정 | false |\n| diskExpiryThreadIntervalSeconds | Disk Expiry 스레드의 작업 수행 간격 설정 | 0 |\n| memoryStoreEvictionPolicy | 캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br />LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br />LFU : 호출 빈도가 가장 적은 캐시를 삭제<br />FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제 | LRU |\n\n \n\n\n#@EnableCaching 설정 \n\n~~~java\n@Configuration\n@EnableCaching(proxyTargetClass = true, mode = AdviceMode.PROXY)\npublic class EHCacheConfig {\n    @Bean\n    public EhCacheManagerFactoryBean ehCacheManagerFactoryBean() {\n        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = new EhCacheManagerFactoryBean();\n        ehCacheManagerFactoryBean.setConfigLocation(new ClassPathResource(\"config/ehcache.xml\"));\n        ehCacheManagerFactoryBean.setShared(true);\n        return ehCacheManagerFactoryBean;\n    }\n\n    @Bean\n    public EhCacheCacheManager ehCacheCacheManager(EhCacheManagerFactoryBean ehCacheManagerFactoryBean) {\n        EhCacheCacheManager ehCacheCacheManager = new EhCacheCacheManager();\n        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());\n        return ehCacheCacheManager;\n    }\n}\n~~~\n\n* @EnableCaching Annotation은 `<cache:annotation-driven>`와 마찬가지로 어노테이션 기반 캐시를 사용 할 수 있는 설정\n* 내부적으로 Spring AOP를 통해 @Cacheable, @CacheEvict와 같은 어노테이션을 Pointcut으로 이용해서 Cache기능을 구현하는 듯 하다.\n* proxyTargetClass : class 기반 프록시를 생성함을 의미 (CGLIB라이브러리에 대한 의존성 필요)\n* Mode : 어떤 Advisor 모듈을 선택할지에 대한 설정 \n  * PROXY : Spring AOP Proxy방식을 이용\n  * ASPECTJ : LTW, CTW기능을 이용한 위빙","source":"_posts/2018-11-04-ehcache-config-for-springboot.md","raw":"---\ntitle: EHCache 설정방법 (Spring Boot)\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\n  - Spring Boot\n  - EHCache\ntypora-root-url: 2018-11-04-ehcache-config-for-springboot\ntypora-copy-images-to: 2018-11-04-ehcache-config-for-springboot\ndate: 2018-11-07 23:38:43\nheader-img:\n---\n\n# EHCache 설정하기\n\n설정 순서는 아래와 같다.\n\n1. Maven Dependency 설정\n2. Ehcache.xml 작성 (ehcache 설정파일)\n3. @EnableCaching 설정\n\n\n\n# Maven Dependency 설정\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n    <version>2.10.6</version>\n</dependency>\n```\n\n# Ehcache.xml 작성 (ehcache 설정파일)\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         maxBytesLocalHeap=\"300M\" <!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 -->\n         updateCheck=\"false\">\n\n    <!-- 임시저장 경로를 설정 -->\n    <diskStore path=\"java.io.tmpdir\" />\n    <!-- \n        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,\n        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색\n        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환\n    -->\n    <sizeOfPolicy maxDepth=\"100000\" maxDepthExceededBehavior=\"continue\"/>\n\n   <!-- default Cache 설정 (반드시 선언해야 하는 Cache) -->\n    <defaultCache\n            eternal=\"false\"\n            timeToIdleSeconds=\"0\"\n            timeToLiveSeconds=\"1200\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n\n    <!-- 사용하고자 하는 캐시 별 설정 -->\n    <cache name=\"LocalCacheData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n\n   <cache name=\"AuthMemberList\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n</ehcache>\n~~~\n\n* defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)\n* cache는 하나의 캐시를 사용할 때마다 구현\n* name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.\n\n| 속성                            | 설명 | Default |\n| ------------------------------- | ---- | ------------------------------- |\n| name                            | 코드에서 사용할 캐시 name | 필수 |\n|  maxEntriesLocalHeap                                   |메모리에 생성 될 최대 캐시 갯수| 0 |\n|  maxEntriesLocalDisk                                  |디스크에 생성 될 최대 캐시 갯수| 0 |\n| eternal                         | 영속성 캐시 설정 (지워지는 캐시인지?) <br />external = \"true\"이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨 | false |\n| timeToIdleSecond                | 해당 초동안 캐시가 호출 되지 않으면 삭제 | 0 |\n| timeToLiveSeconds               | 해당 초가 지나면 캐시가 삭제 | 0 |\n| overflowToDisk                  | 오버플로우 된 항목에 대해 disk에 저장할 지 여부 | false |\n| diskPersistent                  | 캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정 | false |\n| diskExpiryThreadIntervalSeconds | Disk Expiry 스레드의 작업 수행 간격 설정 | 0 |\n| memoryStoreEvictionPolicy | 캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br />LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br />LFU : 호출 빈도가 가장 적은 캐시를 삭제<br />FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제 | LRU |\n\n \n\n\n#@EnableCaching 설정 \n\n~~~java\n@Configuration\n@EnableCaching(proxyTargetClass = true, mode = AdviceMode.PROXY)\npublic class EHCacheConfig {\n    @Bean\n    public EhCacheManagerFactoryBean ehCacheManagerFactoryBean() {\n        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = new EhCacheManagerFactoryBean();\n        ehCacheManagerFactoryBean.setConfigLocation(new ClassPathResource(\"config/ehcache.xml\"));\n        ehCacheManagerFactoryBean.setShared(true);\n        return ehCacheManagerFactoryBean;\n    }\n\n    @Bean\n    public EhCacheCacheManager ehCacheCacheManager(EhCacheManagerFactoryBean ehCacheManagerFactoryBean) {\n        EhCacheCacheManager ehCacheCacheManager = new EhCacheCacheManager();\n        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());\n        return ehCacheCacheManager;\n    }\n}\n~~~\n\n* @EnableCaching Annotation은 `<cache:annotation-driven>`와 마찬가지로 어노테이션 기반 캐시를 사용 할 수 있는 설정\n* 내부적으로 Spring AOP를 통해 @Cacheable, @CacheEvict와 같은 어노테이션을 Pointcut으로 이용해서 Cache기능을 구현하는 듯 하다.\n* proxyTargetClass : class 기반 프록시를 생성함을 의미 (CGLIB라이브러리에 대한 의존성 필요)\n* Mode : 어떤 Advisor 모듈을 선택할지에 대한 설정 \n  * PROXY : Spring AOP Proxy방식을 이용\n  * ASPECTJ : LTW, CTW기능을 이용한 위빙","slug":"2018-11-04-ehcache-config-for-springboot","published":1,"updated":"2018-11-27T07:23:32.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2rr000ccr1tn2vmhkx8","content":"<h1 id=\"ehcache-설정하기\">EHCache 설정하기</h1>\n<p>설정 순서는 아래와 같다.</p>\n<ol>\n<li>Maven Dependency 설정</li>\n<li>Ehcache.xml 작성 (ehcache 설정파일)</li>\n<li>@EnableCaching 설정</li>\n</ol>\n<h1 id=\"maven-dependency-설정\">Maven Dependency 설정</h1>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.sf.ehcache<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ehcache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.10.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"ehcachexml-작성-ehcache-설정파일\">Ehcache.xml 작성 (ehcache 설정파일)</h1>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://ehcache.org/ehcache.xsd\"</span></span></span><br><span class=\"line\">         maxBytesLocalHeap=\"300M\" &lt;!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 --&gt;</span><br><span class=\"line\">         updateCheck=\"false\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 임시저장 경로를 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sizeOfPolicy</span> <span class=\"attr\">maxDepth</span>=<span class=\"string\">\"100000\"</span> <span class=\"attr\">maxDepthExceededBehavior</span>=<span class=\"string\">\"continue\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">&lt;!-- default Cache 설정 (반드시 선언해야 하는 Cache) --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultCache</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">defaultCache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 사용하고자 하는 캐시 별 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"LocalCacheData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"AuthMemberList\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)</li>\n<li>cache는 하나의 캐시를 사용할 때마다 구현</li>\n<li>name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>코드에서 사용할 캐시 name</td>\n<td>필수</td>\n</tr>\n<tr>\n<td>maxEntriesLocalHeap</td>\n<td>메모리에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>maxEntriesLocalDisk</td>\n<td>디스크에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>eternal</td>\n<td>영속성 캐시 설정 (지워지는 캐시인지?) &lt;br /&gt;external = &quot;true&quot;이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨</td>\n<td>false</td>\n</tr>\n<tr>\n<td>timeToIdleSecond</td>\n<td>해당 초동안 캐시가 호출 되지 않으면 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>timeToLiveSeconds</td>\n<td>해당 초가 지나면 캐시가 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>overflowToDisk</td>\n<td>오버플로우 된 항목에 대해 disk에 저장할 지 여부</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskPersistent</td>\n<td>캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskExpiryThreadIntervalSeconds</td>\n<td>Disk Expiry 스레드의 작업 수행 간격 설정</td>\n<td>0</td>\n</tr>\n<tr>\n<td>memoryStoreEvictionPolicy</td>\n<td>캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정&lt;br /&gt;LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제&lt;br /&gt;LFU : 호출 빈도가 가장 적은 캐시를 삭제&lt;br /&gt;FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제</td>\n<td>LRU</td>\n</tr>\n</tbody>\n</table>\n<p>#@EnableCaching 설정</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>, mode = AdviceMode.PROXY)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheManagerFactoryBean <span class=\"title\">ehCacheManagerFactoryBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = <span class=\"keyword\">new</span> EhCacheManagerFactoryBean();</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setConfigLocation(<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">\"config/ehcache.xml\"</span>));</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setShared(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheManagerFactoryBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheCacheManager <span class=\"title\">ehCacheCacheManager</span><span class=\"params\">(EhCacheManagerFactoryBean ehCacheManagerFactoryBean)</span> </span>&#123;</span><br><span class=\"line\">        EhCacheCacheManager ehCacheCacheManager = <span class=\"keyword\">new</span> EhCacheCacheManager();</span><br><span class=\"line\">        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheCacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>@EnableCaching Annotation은 <code>&lt;cache:annotation-driven&gt;</code>와 마찬가지로 어노테이션 기반 캐시를 사용 할 수 있는 설정</li>\n<li>내부적으로 Spring AOP를 통해 @Cacheable, @CacheEvict와 같은 어노테이션을 Pointcut으로 이용해서 Cache기능을 구현하는 듯 하다.</li>\n<li>proxyTargetClass : class 기반 프록시를 생성함을 의미 (CGLIB라이브러리에 대한 의존성 필요)</li>\n<li>Mode : 어떤 Advisor 모듈을 선택할지에 대한 설정\n<ul>\n<li>PROXY : Spring AOP Proxy방식을 이용</li>\n<li>ASPECTJ : LTW, CTW기능을 이용한 위빙</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>EHCache 설정하기</h1>\n<p>설정 순서는 아래와 같다.</p>\n<ol>\n<li>Maven Dependency 설정</li>\n<li>Ehcache.xml 작성 (ehcache 설정파일)</li>\n<li>@EnableCaching 설정</li>\n</ol>\n<h1>Maven Dependency 설정</h1>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.sf.ehcache<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ehcache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.10.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h1>Ehcache.xml 작성 (ehcache 설정파일)</h1>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://ehcache.org/ehcache.xsd\"</span></span></span><br><span class=\"line\">         maxBytesLocalHeap=\"300M\" &lt;!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 --&gt;</span><br><span class=\"line\">         updateCheck=\"false\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 임시저장 경로를 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sizeOfPolicy</span> <span class=\"attr\">maxDepth</span>=<span class=\"string\">\"100000\"</span> <span class=\"attr\">maxDepthExceededBehavior</span>=<span class=\"string\">\"continue\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">&lt;!-- default Cache 설정 (반드시 선언해야 하는 Cache) --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultCache</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">defaultCache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 사용하고자 하는 캐시 별 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"LocalCacheData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"AuthMemberList\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)</li>\n<li>cache는 하나의 캐시를 사용할 때마다 구현</li>\n<li>name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>코드에서 사용할 캐시 name</td>\n<td>필수</td>\n</tr>\n<tr>\n<td>maxEntriesLocalHeap</td>\n<td>메모리에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>maxEntriesLocalDisk</td>\n<td>디스크에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>eternal</td>\n<td>영속성 캐시 설정 (지워지는 캐시인지?) &lt;br /&gt;external = &quot;true&quot;이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨</td>\n<td>false</td>\n</tr>\n<tr>\n<td>timeToIdleSecond</td>\n<td>해당 초동안 캐시가 호출 되지 않으면 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>timeToLiveSeconds</td>\n<td>해당 초가 지나면 캐시가 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>overflowToDisk</td>\n<td>오버플로우 된 항목에 대해 disk에 저장할 지 여부</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskPersistent</td>\n<td>캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskExpiryThreadIntervalSeconds</td>\n<td>Disk Expiry 스레드의 작업 수행 간격 설정</td>\n<td>0</td>\n</tr>\n<tr>\n<td>memoryStoreEvictionPolicy</td>\n<td>캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정&lt;br /&gt;LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제&lt;br /&gt;LFU : 호출 빈도가 가장 적은 캐시를 삭제&lt;br /&gt;FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제</td>\n<td>LRU</td>\n</tr>\n</tbody>\n</table>\n<p>#@EnableCaching 설정</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>, mode = AdviceMode.PROXY)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheManagerFactoryBean <span class=\"title\">ehCacheManagerFactoryBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = <span class=\"keyword\">new</span> EhCacheManagerFactoryBean();</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setConfigLocation(<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">\"config/ehcache.xml\"</span>));</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setShared(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheManagerFactoryBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheCacheManager <span class=\"title\">ehCacheCacheManager</span><span class=\"params\">(EhCacheManagerFactoryBean ehCacheManagerFactoryBean)</span> </span>&#123;</span><br><span class=\"line\">        EhCacheCacheManager ehCacheCacheManager = <span class=\"keyword\">new</span> EhCacheCacheManager();</span><br><span class=\"line\">        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheCacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>@EnableCaching Annotation은 <code>&lt;cache:annotation-driven&gt;</code>와 마찬가지로 어노테이션 기반 캐시를 사용 할 수 있는 설정</li>\n<li>내부적으로 Spring AOP를 통해 @Cacheable, @CacheEvict와 같은 어노테이션을 Pointcut으로 이용해서 Cache기능을 구현하는 듯 하다.</li>\n<li>proxyTargetClass : class 기반 프록시를 생성함을 의미 (CGLIB라이브러리에 대한 의존성 필요)</li>\n<li>Mode : 어떤 Advisor 모듈을 선택할지에 대한 설정\n<ul>\n<li>PROXY : Spring AOP Proxy방식을 이용</li>\n<li>ASPECTJ : LTW, CTW기능을 이용한 위빙</li>\n</ul>\n</li>\n</ul>\n"},{"title":"EHCache 설정방법 (Spring Framework)","subtitle":null,"catalog":true,"Categories":["Spring"],"typora-root-url":"2018-11-04-ehcache-config-for-springframework","typora-copy-images-to":"2018-11-04-ehcache-config-for-springframework","date":"2018-11-07T14:38:22.000Z","header-img":null,"_content":"\n# EHCache 설정하기\n\n설정 순서는 아래와 같다.\n\n1. Maven Dependency 설정\n2. Ehcache.xml 작성 (ehcache 설정파일)\n3. CacheManager 설정 (xml)\n\n\n\n# Maven Dependency 설정\n\n~~~xml\n<!-- EHCache 모듈 (블로그 작성 시점에서 2.10.6이 최신이다.) -->\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n    <version>2.10.6</version> \n</dependency>\n\n<!-- Spring Caching Interface -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>4.3.20.RELEASE</version>\n</dependency>\n\n<!-- EHCache Support 모듈, 다른 Caching 지원모듈 -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context-support</artifactId>\n    <version>4.3.20.RELEASE</version>\n</dependency>\n~~~\n\n\n\n# ehcache.xml 작성\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         maxBytesLocalHeap=\"300M\" <!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 -->\n         updateCheck=\"false\">\n\n    <!-- 임시저장 경로를 설정 -->\n    <diskStore path=\"java.io.tmpdir\" />\n    <!-- \n        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,\n        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색\n        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환\n    -->\n    <sizeOfPolicy maxDepth=\"100000\" maxDepthExceededBehavior=\"continue\"/>\n\n   <!-- default Cache 설정 (반드시 선언해야 하는 Cache) -->\n    <defaultCache\n            eternal=\"false\"\n            timeToIdleSeconds=\"0\"\n            timeToLiveSeconds=\"1200\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n\n    <!-- 사용하고자 하는 캐시 별 설정 -->\n    <cache name=\"LocalCacheData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n\n   <cache name=\"AuthMemberList\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n</ehcache>\n~~~\n\n- defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)\n- cache는 하나의 캐시를 사용할 때마다 구현\n- name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.\n\n| 속성                            | 설명                                                         | Default |\n| ------------------------------- | ------------------------------------------------------------ | ------- |\n| name                            | 코드에서 사용할 캐시 name                                    | 필수    |\n| maxEntriesLocalHeap             | 메모리에 생성 될 최대 캐시 갯수                              | 0       |\n| maxEntriesLocalDisk             | 디스크에 생성 될 최대 캐시 갯수                              | 0       |\n| eternal                         | 영속성 캐시 설정 (지워지는 캐시인지?) <br />external = \"true\"이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨 | false   |\n| timeToIdleSecond                | 해당 초동안 캐시가 호출 되지 않으면 삭제                     | 0       |\n| timeToLiveSeconds               | 해당 초가 지나면 캐시가 삭제                                 | 0       |\n| overflowToDisk                  | 오버플로우 된 항목에 대해 disk에 저장할 지 여부              | false   |\n| diskPersistent                  | 캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정   | false   |\n| diskExpiryThreadIntervalSeconds | Disk Expiry 스레드의 작업 수행 간격 설정                     | 0       |\n| memoryStoreEvictionPolicy       | 캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br />LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br />LFU : 호출 빈도가 가장 적은 캐시를 삭제<br />FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제 | LRU     |\n\n \n\n# CacheManager Bean 설정\n\n~~~xml\nz<!-- Annotation 기반 캐시 사용 (@Cacheable, @CacheEvict..) -->\n<cache:annotation-driven/>\n\n<!-- EHCache 기반 CacheManager 설정 -->\n<bean id=\"cacheManager\" class=\"org.springframework.cache.ehcache.EhCacheCacheManager\">\n    <property name=\"cacheManager\" ref=\"ehcache\"/>\n</bean>\n\n<!-- ehcache.xml 설정 로드 -->\n<bean id=\"ehcache\" class=\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\">\n    <property name=\"configLocation\" value=\"classpath:config/ehcache.xml\"/>\n    <property name=\"shared\" value=\"true\"/>\n</bean>\n~~~\n\n\n\n# 참고\n\n* https://github.com/skoh/common/blob/master/common-web/src/main/resources/ehcache.xml\n* https://www.mkyong.com/spring/spring-caching-and-ehcache-example/\n* http://hyeooona825.tistory.com/86\n* http://blog.naver.com/PostView.nhn?blogId=kyung778&logNo=60164009610","source":"_posts/2018-11-04-ehcache-config-for-springframework.md","raw":"---\ntitle: EHCache 설정방법 (Spring framework)\nsubtitle:\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\n  - EHCache\ntypora-root-url: 2018-11-04-ehcache-config-for-springframework\ntypora-copy-images-to: 2018-11-04-ehcache-config-for-springframework\ndate: 2018-11-07 23:38:22\nheader-img:\n---\n\n# EHCache 설정하기\n\n설정 순서는 아래와 같다.\n\n1. Maven Dependency 설정\n2. Ehcache.xml 작성 (ehcache 설정파일)\n3. CacheManager 설정 (xml)\n\n\n\n# Maven Dependency 설정\n\n~~~xml\n<!-- EHCache 모듈 (블로그 작성 시점에서 2.10.6이 최신이다.) -->\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n    <version>2.10.6</version> \n</dependency>\n\n<!-- Spring Caching Interface -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>4.3.20.RELEASE</version>\n</dependency>\n\n<!-- EHCache Support 모듈, 다른 Caching 지원모듈 -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context-support</artifactId>\n    <version>4.3.20.RELEASE</version>\n</dependency>\n~~~\n\n\n\n# ehcache.xml 작성\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         maxBytesLocalHeap=\"300M\" <!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 -->\n         updateCheck=\"false\">\n\n    <!-- 임시저장 경로를 설정 -->\n    <diskStore path=\"java.io.tmpdir\" />\n    <!-- \n        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,\n        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색\n        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환\n    -->\n    <sizeOfPolicy maxDepth=\"100000\" maxDepthExceededBehavior=\"continue\"/>\n\n   <!-- default Cache 설정 (반드시 선언해야 하는 Cache) -->\n    <defaultCache\n            eternal=\"false\"\n            timeToIdleSeconds=\"0\"\n            timeToLiveSeconds=\"1200\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n\n    <!-- 사용하고자 하는 캐시 별 설정 -->\n    <cache name=\"LocalCacheData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n\n   <cache name=\"AuthMemberList\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n</ehcache>\n~~~\n\n- defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)\n- cache는 하나의 캐시를 사용할 때마다 구현\n- name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.\n\n| 속성                            | 설명                                                         | Default |\n| ------------------------------- | ------------------------------------------------------------ | ------- |\n| name                            | 코드에서 사용할 캐시 name                                    | 필수    |\n| maxEntriesLocalHeap             | 메모리에 생성 될 최대 캐시 갯수                              | 0       |\n| maxEntriesLocalDisk             | 디스크에 생성 될 최대 캐시 갯수                              | 0       |\n| eternal                         | 영속성 캐시 설정 (지워지는 캐시인지?) <br />external = \"true\"이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨 | false   |\n| timeToIdleSecond                | 해당 초동안 캐시가 호출 되지 않으면 삭제                     | 0       |\n| timeToLiveSeconds               | 해당 초가 지나면 캐시가 삭제                                 | 0       |\n| overflowToDisk                  | 오버플로우 된 항목에 대해 disk에 저장할 지 여부              | false   |\n| diskPersistent                  | 캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정   | false   |\n| diskExpiryThreadIntervalSeconds | Disk Expiry 스레드의 작업 수행 간격 설정                     | 0       |\n| memoryStoreEvictionPolicy       | 캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br />LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br />LFU : 호출 빈도가 가장 적은 캐시를 삭제<br />FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제 | LRU     |\n\n \n\n# CacheManager Bean 설정\n\n~~~xml\nz<!-- Annotation 기반 캐시 사용 (@Cacheable, @CacheEvict..) -->\n<cache:annotation-driven/>\n\n<!-- EHCache 기반 CacheManager 설정 -->\n<bean id=\"cacheManager\" class=\"org.springframework.cache.ehcache.EhCacheCacheManager\">\n    <property name=\"cacheManager\" ref=\"ehcache\"/>\n</bean>\n\n<!-- ehcache.xml 설정 로드 -->\n<bean id=\"ehcache\" class=\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\">\n    <property name=\"configLocation\" value=\"classpath:config/ehcache.xml\"/>\n    <property name=\"shared\" value=\"true\"/>\n</bean>\n~~~\n\n\n\n# 참고\n\n* https://github.com/skoh/common/blob/master/common-web/src/main/resources/ehcache.xml\n* https://www.mkyong.com/spring/spring-caching-and-ehcache-example/\n* http://hyeooona825.tistory.com/86\n* http://blog.naver.com/PostView.nhn?blogId=kyung778&logNo=60164009610","slug":"2018-11-04-ehcache-config-for-springframework","published":1,"updated":"2018-11-27T07:23:32.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2rs000dcr1ti03ghftm","content":"<h1 id=\"ehcache-설정하기\">EHCache 설정하기</h1>\n<p>설정 순서는 아래와 같다.</p>\n<ol>\n<li>Maven Dependency 설정</li>\n<li>Ehcache.xml 작성 (ehcache 설정파일)</li>\n<li>CacheManager 설정 (xml)</li>\n</ol>\n<h1 id=\"maven-dependency-설정\">Maven Dependency 설정</h1>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- EHCache 모듈 (블로그 작성 시점에서 2.10.6이 최신이다.) --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.sf.ehcache<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ehcache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.10.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Spring Caching Interface --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.3.20.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- EHCache Support 모듈, 다른 Caching 지원모듈 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context-support<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.3.20.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"ehcachexml-작성\">ehcache.xml 작성</h1>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://ehcache.org/ehcache.xsd\"</span></span></span><br><span class=\"line\">         maxBytesLocalHeap=\"300M\" &lt;!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 --&gt;</span><br><span class=\"line\">         updateCheck=\"false\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 임시저장 경로를 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sizeOfPolicy</span> <span class=\"attr\">maxDepth</span>=<span class=\"string\">\"100000\"</span> <span class=\"attr\">maxDepthExceededBehavior</span>=<span class=\"string\">\"continue\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">&lt;!-- default Cache 설정 (반드시 선언해야 하는 Cache) --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultCache</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">defaultCache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 사용하고자 하는 캐시 별 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"LocalCacheData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"AuthMemberList\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)</li>\n<li>cache는 하나의 캐시를 사용할 때마다 구현</li>\n<li>name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>코드에서 사용할 캐시 name</td>\n<td>필수</td>\n</tr>\n<tr>\n<td>maxEntriesLocalHeap</td>\n<td>메모리에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>maxEntriesLocalDisk</td>\n<td>디스크에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>eternal</td>\n<td>영속성 캐시 설정 (지워지는 캐시인지?) &lt;br /&gt;external = &quot;true&quot;이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨</td>\n<td>false</td>\n</tr>\n<tr>\n<td>timeToIdleSecond</td>\n<td>해당 초동안 캐시가 호출 되지 않으면 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>timeToLiveSeconds</td>\n<td>해당 초가 지나면 캐시가 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>overflowToDisk</td>\n<td>오버플로우 된 항목에 대해 disk에 저장할 지 여부</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskPersistent</td>\n<td>캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskExpiryThreadIntervalSeconds</td>\n<td>Disk Expiry 스레드의 작업 수행 간격 설정</td>\n<td>0</td>\n</tr>\n<tr>\n<td>memoryStoreEvictionPolicy</td>\n<td>캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정&lt;br /&gt;LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제&lt;br /&gt;LFU : 호출 빈도가 가장 적은 캐시를 삭제&lt;br /&gt;FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제</td>\n<td>LRU</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"cachemanager-bean-설정\">CacheManager Bean 설정</h1>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z<span class=\"comment\">&lt;!-- Annotation 기반 캐시 사용 (@Cacheable, @CacheEvict..) --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">cache:annotation-driven</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- EHCache 기반 CacheManager 설정 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cacheManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.cache.ehcache.EhCacheCacheManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cacheManager\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"ehcache\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- ehcache.xml 설정 로드 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ehcache\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"configLocation\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"classpath:config/ehcache.xml\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"shared\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>https://github.com/skoh/common/blob/master/common-web/src/main/resources/ehcache.xml</li>\n<li>https://www.mkyong.com/spring/spring-caching-and-ehcache-example/</li>\n<li>http://hyeooona825.tistory.com/86</li>\n<li>http://blog.naver.com/PostView.nhn?blogId=kyung778&amp;logNo=60164009610</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>EHCache 설정하기</h1>\n<p>설정 순서는 아래와 같다.</p>\n<ol>\n<li>Maven Dependency 설정</li>\n<li>Ehcache.xml 작성 (ehcache 설정파일)</li>\n<li>CacheManager 설정 (xml)</li>\n</ol>\n<h1>Maven Dependency 설정</h1>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- EHCache 모듈 (블로그 작성 시점에서 2.10.6이 최신이다.) --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.sf.ehcache<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ehcache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.10.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Spring Caching Interface --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.3.20.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- EHCache Support 모듈, 다른 Caching 지원모듈 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context-support<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.3.20.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h1>ehcache.xml 작성</h1>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://ehcache.org/ehcache.xsd\"</span></span></span><br><span class=\"line\">         maxBytesLocalHeap=\"300M\" &lt;!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 --&gt;</span><br><span class=\"line\">         updateCheck=\"false\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 임시저장 경로를 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sizeOfPolicy</span> <span class=\"attr\">maxDepth</span>=<span class=\"string\">\"100000\"</span> <span class=\"attr\">maxDepthExceededBehavior</span>=<span class=\"string\">\"continue\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">&lt;!-- default Cache 설정 (반드시 선언해야 하는 Cache) --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultCache</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">defaultCache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 사용하고자 하는 캐시 별 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"LocalCacheData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"AuthMemberList\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)</li>\n<li>cache는 하나의 캐시를 사용할 때마다 구현</li>\n<li>name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>코드에서 사용할 캐시 name</td>\n<td>필수</td>\n</tr>\n<tr>\n<td>maxEntriesLocalHeap</td>\n<td>메모리에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>maxEntriesLocalDisk</td>\n<td>디스크에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>eternal</td>\n<td>영속성 캐시 설정 (지워지는 캐시인지?) &lt;br /&gt;external = &quot;true&quot;이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨</td>\n<td>false</td>\n</tr>\n<tr>\n<td>timeToIdleSecond</td>\n<td>해당 초동안 캐시가 호출 되지 않으면 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>timeToLiveSeconds</td>\n<td>해당 초가 지나면 캐시가 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>overflowToDisk</td>\n<td>오버플로우 된 항목에 대해 disk에 저장할 지 여부</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskPersistent</td>\n<td>캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskExpiryThreadIntervalSeconds</td>\n<td>Disk Expiry 스레드의 작업 수행 간격 설정</td>\n<td>0</td>\n</tr>\n<tr>\n<td>memoryStoreEvictionPolicy</td>\n<td>캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정&lt;br /&gt;LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제&lt;br /&gt;LFU : 호출 빈도가 가장 적은 캐시를 삭제&lt;br /&gt;FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제</td>\n<td>LRU</td>\n</tr>\n</tbody>\n</table>\n<h1>CacheManager Bean 설정</h1>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z<span class=\"comment\">&lt;!-- Annotation 기반 캐시 사용 (@Cacheable, @CacheEvict..) --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">cache:annotation-driven</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- EHCache 기반 CacheManager 설정 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cacheManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.cache.ehcache.EhCacheCacheManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cacheManager\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"ehcache\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- ehcache.xml 설정 로드 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ehcache\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"configLocation\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"classpath:config/ehcache.xml\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"shared\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h1>참고</h1>\n<ul>\n<li>https://github.com/skoh/common/blob/master/common-web/src/main/resources/ehcache.xml</li>\n<li>https://www.mkyong.com/spring/spring-caching-and-ehcache-example/</li>\n<li>http://hyeooona825.tistory.com/86</li>\n<li>http://blog.naver.com/PostView.nhn?blogId=kyung778&amp;logNo=60164009610</li>\n</ul>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (1) Docker란 무엇인가?","date":"2018-11-25T09:51:22.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-11-25-docker-1","typora-copy-images-to":"2018-11-25-docker-1","_content":"\n\n\n# Docker란 무엇인가?\n\n![docker-logo](./docker-logo.png)\n\nDocker란 **Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼** 입니다.\n\n위의 Docker 이미지처럼 선박에 화물을 수송하는 이미지를 떠올리면 이해하기가 쉬운데, 실제 선박에는 자동차, 오토바이, 전자제품등 여러 물건을 담을 수 있습니다.\n\n선박에 대한 이미지를 유지한 채, Web Service 운영환경을 생각해 보면..\nWeb Service 운영환경을 구성하기 위해서는 Web Application이 구동 될 수 있는 WAS와 DataBase가 필요합니다.\n\n이 2가지 프로그램을 Docker라는 선박에 담는다고 생각해 봅시다.\n그 다음 우리가 배포할 서버를 항구(Port)라고 생각하고, \n각 서버에 Web Service 운영환경을 싣고 있는 선박을 정착 시켜 서버에서 접근가능한 서비스로 이용할 수 있습니다. 따라서 어떤 서버에서도 Docker만 설치되어 있다면, 다양한 `프로그램과 실행환경을 추상화 하여 동일한 인터페이스를 제공`하고 서버관리를 쉽고 단순하게 만들어 줄 수 있습니다.\n\nDocker에서는 `Image`와 `Container`라는 개념을 사용하는데, 이 두 가지 개념에 대해 알아보도록 하겠습니다.\n\n\n\n# Docker Image\n\n![docker-image](./docker-image.png)\n\nDocker Image는 우리가 사용할 프로그램을 추상화 한 개념입니다.\n\nImage에는 Container 실행에 필요한 파일(redis.conf, redis.log...., docker-entrypoing.sh등)등을 포함하고,\n설정값(port, env, data directory등) 정보를 포함하고 있습니다.\n`1개의 이미지`를 바탕으로` 여러 개의 컨테이너`를 만들 수 있습니다. \n(ex. 하나의 Redis 이미지를 바탕으로 3개의 Redis Container를 구성하여 Cluster환경을 구성할 수 있습니다.)\n이 내용을 좀 더 쉽게 이해하자면, 한번 쯤은 WM에 Linux를 설치 해 본 경험이 있을텐데, Linux를 설치 하기 위해선 linux.iso 파일이 필요 합니다.\n이때 iso파일이 Linux를 구성하기 위한 파일과 설정 정보를 담고 있고 VM에 Linux를 설치 할 수 있게 해줍니다.\n여기서 `iso파일`을 `Image`라고 생각하고, `VM위에 설치되는 리눅스`를 `Container`라고 이해 할 수 있겠습니다.\n\nDocker를 이용한 운영 배포 시, 이미지를 `Docker Hub`라는 곳에 올려 각 서버에서 받아 사용할 수 있습니다. \n(Docker Hub는 github나 maven repository 같은 클라우드 저장소 같은 개념으로 이해 하시면 됩니다.)\n\n\n\n# Docker Container\n\nContainer란, **프로그램의 실행에 필요한 실행환경을 독립적으로 운용할 수 있도록, 다른 실행환경과의 간섭을 막고 독립성을 확보해 주는 운영체제 수준의 격리 기술**을 의미합니다.\n\n이러한 격리된 환경이 필요한 경우를 생각해 볼 수 있는데, 극단적인 예시로 Java 1.6 환경에서만 실행되는 프로그램과 Java 1.8이상 환경에서만 실행 되는 프로그램을 하나의 서버에 설치한다고 가정하겠습니다.\n\n프로그램이 실행 되기 위해서는 운영체제에 설치 된 라이브러리의 대해 의존성을 가질 수 밖에 없는데, 하나의 OS에서 Java Version에 대한 격리 환경을 가지게 하는 것은 상당히 번거로운 일입니다.\n이러한 경우 Docker를 사용하면 격리된 구역에서 실행 환경을 만들어 줄 수 있기 때문에 타 시스템에 영향을 주지 않고 안정적으로 운영환경을 구성 할 수 있습니다.\n\nDocker을 처음 공부할 때 Image와 Container 관계가 무척이나 헷갈렸는데.. 예시를 통해 이해해 보겠습니다.\nImage는 실행 환경에 대한 파일과 설정 정보를 담고 있다고 했습니다. 그리고 프로그램을 추상화 한 개념이라고 하였습니다.\n이는 Java의 Class와 같은 개념으로 인식 할 수 있습니다.\nContainer는 Image를 기반으로 생성된 격리 된 실행환경이라 했습니다. 그리고 Container를 실행 할 경우 파라미터를 통해 Container 내부 설정정보를 변경 할 수도 있습니다.\n이는 Class를 바탕으로 만들어진 Instance의 개념으로 이해 할 수 있습니다.\n이처럼 Java의 Class와 Instance의 관계로 이해한다면, Docker에서의 Image와 Container 관계에 대해 어렵지 않게 이해 할 수 있을 것 같습니다.\n\n![docking-image](./docking-image.png)\n\n도킹에 성공한 Container는 Host OS에 설치 된 프로그램 처럼 사용할 수 있다.\n\n\n\n# Docker vs Virtual Machine\n\n위에서 설명하길 \"Docker란 **Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼**입니다.\" 라고 이야기 하였습니다.\n가상화라고 하면 대표적인 예가 Virtual Machine 즉 VM을 떠올릴 수 있는데요.\n\nVM과 Docker는 몇가지 차이점이 있습니다.\n먼저 그림으로 그 구조를 확인해 보겠습니다.\n\n![vm-vs-docker](./vm-vs-docker.png)\n\n먼저 VM의 가상화 방식은 기존의 `Host OS위에 Hyper Visor를 이용`하여 가상화 OS를 띄우는 방식으로 많이 구현했습니다.\n주로 Windows에서 VMWare, Virtual Box, Hyper-V등 가상화 도구를 이용해 Guest OS를 설치하고 그 OS 위에 우리가 사용하고자 하는 프로그램을 설치하여 사용하였습니다.\n\n이러한 방식은 `완벽한 수준의 격리`이며, Host OS에서 Guest OS의 프로그램을 직접적으로 제어할 수 없습니다\n또한 Host OS에서 할당한 자원(Resource)밖에 사용할 수 없기 때문에 Host OS에서도 가상 OS에 점유한 자원을 유동적으로 사용할 수 없어 낭비가 생깁니다.\n\n반면에 Container 방식은 **기존의 Host OS위에 Docker를 이용하여 해당 프로그램의 의존성 라이브러리(프로그램 구동에 필요한 라이브러리)만 가지고 Container가 생성**됩니다. 그렇기에 `최소한의 용량으로 이미지를 구성` 할 수 있습니다.\nVM에서 사용되는 OS나 Kernel이 없기 때문에 부팅을 할 필요도 없으며, Host OS의 Resource 또한 유동적으로 사용할 수 있어 자원관리가 효율적입니다.\n\n단순히 프로세스를 격리시키는 것이기 때문에 `VM에 비해 매우 빠르게 동작`합니다.\n단점인 부분은 **Host OS에 종속적인 부분이 있습니다.** \nVM방식의 경우 각각의 OS에 대한 독립성을 가지고 있어, Host OS에 대해 독립적입니다. (예를들어 Host OS가 리눅스이고, Guest OS가 Windows인 경우, MSSQL을 Guest OS에서 사용할 수 있다)\n하지만 Container방식은 Host OS의 자원을 기반으로 생성 되기 때문에 `Host OS에서 작동할 수 없는 프로그램은 Container 내부에서 작동 할 수 없습니다.`\n\n\n\n# Docker for XX\n\nDocker는 리눅스 컨테이너 기반으로 동작하지만 최근 Windows와 Mac에 대해서도 Docker를 지원하고 있습니다.\n하지만 Linux기반 Docker와 조금 차이점이 있습니다.\n아무래도 Linux 기반 컨테이너이기 때문에 Windows에서는 Hyper-V에 리눅스를 설치하여 연동되게 되어있습니다.\n이 경우 Host OS가 Windows가 되는 것이 아니라, Hyper-V의 리눅스가 Host OS가 되는 것이기 때문에 Hyper-V에 할당된 메모리와 디스크 용량을 기반으로 자원을 활용하게 됩니다.\nLinux가 아닌 다른 운영체제에서 Docker 설치 시 유의해야 할 부분입니다.\n\n\n\n# 참고\n\n* <http://www.sauru.so/blog/getting-started-with-docker/>\n\n* <http://www.sauru.so/blog/getting-started-with-docker/>     \n* <https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html>\n\n* <https://www.docker.com/enterprise-edition#/platform>\n\n","source":"_posts/2018-11-25-docker-1.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (1) Docker란 무엇인가?\ndate: 2018-11-25 18:51:22\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-11-25-docker-1\ntypora-copy-images-to: 2018-11-25-docker-1\n---\n\n\n\n# Docker란 무엇인가?\n\n![docker-logo](./docker-logo.png)\n\nDocker란 **Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼** 입니다.\n\n위의 Docker 이미지처럼 선박에 화물을 수송하는 이미지를 떠올리면 이해하기가 쉬운데, 실제 선박에는 자동차, 오토바이, 전자제품등 여러 물건을 담을 수 있습니다.\n\n선박에 대한 이미지를 유지한 채, Web Service 운영환경을 생각해 보면..\nWeb Service 운영환경을 구성하기 위해서는 Web Application이 구동 될 수 있는 WAS와 DataBase가 필요합니다.\n\n이 2가지 프로그램을 Docker라는 선박에 담는다고 생각해 봅시다.\n그 다음 우리가 배포할 서버를 항구(Port)라고 생각하고, \n각 서버에 Web Service 운영환경을 싣고 있는 선박을 정착 시켜 서버에서 접근가능한 서비스로 이용할 수 있습니다. 따라서 어떤 서버에서도 Docker만 설치되어 있다면, 다양한 `프로그램과 실행환경을 추상화 하여 동일한 인터페이스를 제공`하고 서버관리를 쉽고 단순하게 만들어 줄 수 있습니다.\n\nDocker에서는 `Image`와 `Container`라는 개념을 사용하는데, 이 두 가지 개념에 대해 알아보도록 하겠습니다.\n\n\n\n# Docker Image\n\n![docker-image](./docker-image.png)\n\nDocker Image는 우리가 사용할 프로그램을 추상화 한 개념입니다.\n\nImage에는 Container 실행에 필요한 파일(redis.conf, redis.log...., docker-entrypoing.sh등)등을 포함하고,\n설정값(port, env, data directory등) 정보를 포함하고 있습니다.\n`1개의 이미지`를 바탕으로` 여러 개의 컨테이너`를 만들 수 있습니다. \n(ex. 하나의 Redis 이미지를 바탕으로 3개의 Redis Container를 구성하여 Cluster환경을 구성할 수 있습니다.)\n이 내용을 좀 더 쉽게 이해하자면, 한번 쯤은 WM에 Linux를 설치 해 본 경험이 있을텐데, Linux를 설치 하기 위해선 linux.iso 파일이 필요 합니다.\n이때 iso파일이 Linux를 구성하기 위한 파일과 설정 정보를 담고 있고 VM에 Linux를 설치 할 수 있게 해줍니다.\n여기서 `iso파일`을 `Image`라고 생각하고, `VM위에 설치되는 리눅스`를 `Container`라고 이해 할 수 있겠습니다.\n\nDocker를 이용한 운영 배포 시, 이미지를 `Docker Hub`라는 곳에 올려 각 서버에서 받아 사용할 수 있습니다. \n(Docker Hub는 github나 maven repository 같은 클라우드 저장소 같은 개념으로 이해 하시면 됩니다.)\n\n\n\n# Docker Container\n\nContainer란, **프로그램의 실행에 필요한 실행환경을 독립적으로 운용할 수 있도록, 다른 실행환경과의 간섭을 막고 독립성을 확보해 주는 운영체제 수준의 격리 기술**을 의미합니다.\n\n이러한 격리된 환경이 필요한 경우를 생각해 볼 수 있는데, 극단적인 예시로 Java 1.6 환경에서만 실행되는 프로그램과 Java 1.8이상 환경에서만 실행 되는 프로그램을 하나의 서버에 설치한다고 가정하겠습니다.\n\n프로그램이 실행 되기 위해서는 운영체제에 설치 된 라이브러리의 대해 의존성을 가질 수 밖에 없는데, 하나의 OS에서 Java Version에 대한 격리 환경을 가지게 하는 것은 상당히 번거로운 일입니다.\n이러한 경우 Docker를 사용하면 격리된 구역에서 실행 환경을 만들어 줄 수 있기 때문에 타 시스템에 영향을 주지 않고 안정적으로 운영환경을 구성 할 수 있습니다.\n\nDocker을 처음 공부할 때 Image와 Container 관계가 무척이나 헷갈렸는데.. 예시를 통해 이해해 보겠습니다.\nImage는 실행 환경에 대한 파일과 설정 정보를 담고 있다고 했습니다. 그리고 프로그램을 추상화 한 개념이라고 하였습니다.\n이는 Java의 Class와 같은 개념으로 인식 할 수 있습니다.\nContainer는 Image를 기반으로 생성된 격리 된 실행환경이라 했습니다. 그리고 Container를 실행 할 경우 파라미터를 통해 Container 내부 설정정보를 변경 할 수도 있습니다.\n이는 Class를 바탕으로 만들어진 Instance의 개념으로 이해 할 수 있습니다.\n이처럼 Java의 Class와 Instance의 관계로 이해한다면, Docker에서의 Image와 Container 관계에 대해 어렵지 않게 이해 할 수 있을 것 같습니다.\n\n![docking-image](./docking-image.png)\n\n도킹에 성공한 Container는 Host OS에 설치 된 프로그램 처럼 사용할 수 있다.\n\n\n\n# Docker vs Virtual Machine\n\n위에서 설명하길 \"Docker란 **Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼**입니다.\" 라고 이야기 하였습니다.\n가상화라고 하면 대표적인 예가 Virtual Machine 즉 VM을 떠올릴 수 있는데요.\n\nVM과 Docker는 몇가지 차이점이 있습니다.\n먼저 그림으로 그 구조를 확인해 보겠습니다.\n\n![vm-vs-docker](./vm-vs-docker.png)\n\n먼저 VM의 가상화 방식은 기존의 `Host OS위에 Hyper Visor를 이용`하여 가상화 OS를 띄우는 방식으로 많이 구현했습니다.\n주로 Windows에서 VMWare, Virtual Box, Hyper-V등 가상화 도구를 이용해 Guest OS를 설치하고 그 OS 위에 우리가 사용하고자 하는 프로그램을 설치하여 사용하였습니다.\n\n이러한 방식은 `완벽한 수준의 격리`이며, Host OS에서 Guest OS의 프로그램을 직접적으로 제어할 수 없습니다\n또한 Host OS에서 할당한 자원(Resource)밖에 사용할 수 없기 때문에 Host OS에서도 가상 OS에 점유한 자원을 유동적으로 사용할 수 없어 낭비가 생깁니다.\n\n반면에 Container 방식은 **기존의 Host OS위에 Docker를 이용하여 해당 프로그램의 의존성 라이브러리(프로그램 구동에 필요한 라이브러리)만 가지고 Container가 생성**됩니다. 그렇기에 `최소한의 용량으로 이미지를 구성` 할 수 있습니다.\nVM에서 사용되는 OS나 Kernel이 없기 때문에 부팅을 할 필요도 없으며, Host OS의 Resource 또한 유동적으로 사용할 수 있어 자원관리가 효율적입니다.\n\n단순히 프로세스를 격리시키는 것이기 때문에 `VM에 비해 매우 빠르게 동작`합니다.\n단점인 부분은 **Host OS에 종속적인 부분이 있습니다.** \nVM방식의 경우 각각의 OS에 대한 독립성을 가지고 있어, Host OS에 대해 독립적입니다. (예를들어 Host OS가 리눅스이고, Guest OS가 Windows인 경우, MSSQL을 Guest OS에서 사용할 수 있다)\n하지만 Container방식은 Host OS의 자원을 기반으로 생성 되기 때문에 `Host OS에서 작동할 수 없는 프로그램은 Container 내부에서 작동 할 수 없습니다.`\n\n\n\n# Docker for XX\n\nDocker는 리눅스 컨테이너 기반으로 동작하지만 최근 Windows와 Mac에 대해서도 Docker를 지원하고 있습니다.\n하지만 Linux기반 Docker와 조금 차이점이 있습니다.\n아무래도 Linux 기반 컨테이너이기 때문에 Windows에서는 Hyper-V에 리눅스를 설치하여 연동되게 되어있습니다.\n이 경우 Host OS가 Windows가 되는 것이 아니라, Hyper-V의 리눅스가 Host OS가 되는 것이기 때문에 Hyper-V에 할당된 메모리와 디스크 용량을 기반으로 자원을 활용하게 됩니다.\nLinux가 아닌 다른 운영체제에서 Docker 설치 시 유의해야 할 부분입니다.\n\n\n\n# 참고\n\n* <http://www.sauru.so/blog/getting-started-with-docker/>\n\n* <http://www.sauru.so/blog/getting-started-with-docker/>     \n* <https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html>\n\n* <https://www.docker.com/enterprise-edition#/platform>\n\n","slug":"2018-11-25-docker-1","published":1,"updated":"2018-12-08T08:36:34.232Z","comments":1,"photos":[],"link":"","_id":"cjrgbv2rv000gcr1tbqm8jpqc","content":"<h1 id=\"docker란-무엇인가\">Docker란 무엇인가?</h1>\n<p><img src=\"./docker-logo.png\" alt=\"docker-logo\"></p>\n<p>Docker란 <strong>Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼</strong> 입니다.</p>\n<p>위의 Docker 이미지처럼 선박에 화물을 수송하는 이미지를 떠올리면 이해하기가 쉬운데, 실제 선박에는 자동차, 오토바이, 전자제품등 여러 물건을 담을 수 있습니다.</p>\n<p>선박에 대한 이미지를 유지한 채, Web Service 운영환경을 생각해 보면..\nWeb Service 운영환경을 구성하기 위해서는 Web Application이 구동 될 수 있는 WAS와 DataBase가 필요합니다.</p>\n<p>이 2가지 프로그램을 Docker라는 선박에 담는다고 생각해 봅시다.\n그 다음 우리가 배포할 서버를 항구(Port)라고 생각하고,\n각 서버에 Web Service 운영환경을 싣고 있는 선박을 정착 시켜 서버에서 접근가능한 서비스로 이용할 수 있습니다. 따라서 어떤 서버에서도 Docker만 설치되어 있다면, 다양한 <code>프로그램과 실행환경을 추상화 하여 동일한 인터페이스를 제공</code>하고 서버관리를 쉽고 단순하게 만들어 줄 수 있습니다.</p>\n<p>Docker에서는 <code>Image</code>와 <code>Container</code>라는 개념을 사용하는데, 이 두 가지 개념에 대해 알아보도록 하겠습니다.</p>\n<h1 id=\"docker-image\">Docker Image</h1>\n<p><img src=\"./docker-image.png\" alt=\"docker-image\"></p>\n<p>Docker Image는 우리가 사용할 프로그램을 추상화 한 개념입니다.</p>\n<p>Image에는 Container 실행에 필요한 파일(redis.conf, redis.log...., docker-entrypoing.sh등)등을 포함하고,\n설정값(port, env, data directory등) 정보를 포함하고 있습니다.\n<code>1개의 이미지</code>를 바탕으로<code>여러 개의 컨테이너</code>를 만들 수 있습니다.\n(ex. 하나의 Redis 이미지를 바탕으로 3개의 Redis Container를 구성하여 Cluster환경을 구성할 수 있습니다.)\n이 내용을 좀 더 쉽게 이해하자면, 한번 쯤은 WM에 Linux를 설치 해 본 경험이 있을텐데, Linux를 설치 하기 위해선 linux.iso 파일이 필요 합니다.\n이때 iso파일이 Linux를 구성하기 위한 파일과 설정 정보를 담고 있고 VM에 Linux를 설치 할 수 있게 해줍니다.\n여기서 <code>iso파일</code>을 <code>Image</code>라고 생각하고, <code>VM위에 설치되는 리눅스</code>를 <code>Container</code>라고 이해 할 수 있겠습니다.</p>\n<p>Docker를 이용한 운영 배포 시, 이미지를 <code>Docker Hub</code>라는 곳에 올려 각 서버에서 받아 사용할 수 있습니다.\n(Docker Hub는 github나 maven repository 같은 클라우드 저장소 같은 개념으로 이해 하시면 됩니다.)</p>\n<h1 id=\"docker-container\">Docker Container</h1>\n<p>Container란, <strong>프로그램의 실행에 필요한 실행환경을 독립적으로 운용할 수 있도록, 다른 실행환경과의 간섭을 막고 독립성을 확보해 주는 운영체제 수준의 격리 기술</strong>을 의미합니다.</p>\n<p>이러한 격리된 환경이 필요한 경우를 생각해 볼 수 있는데, 극단적인 예시로 Java 1.6 환경에서만 실행되는 프로그램과 Java 1.8이상 환경에서만 실행 되는 프로그램을 하나의 서버에 설치한다고 가정하겠습니다.</p>\n<p>프로그램이 실행 되기 위해서는 운영체제에 설치 된 라이브러리의 대해 의존성을 가질 수 밖에 없는데, 하나의 OS에서 Java Version에 대한 격리 환경을 가지게 하는 것은 상당히 번거로운 일입니다.\n이러한 경우 Docker를 사용하면 격리된 구역에서 실행 환경을 만들어 줄 수 있기 때문에 타 시스템에 영향을 주지 않고 안정적으로 운영환경을 구성 할 수 있습니다.</p>\n<p>Docker을 처음 공부할 때 Image와 Container 관계가 무척이나 헷갈렸는데.. 예시를 통해 이해해 보겠습니다.\nImage는 실행 환경에 대한 파일과 설정 정보를 담고 있다고 했습니다. 그리고 프로그램을 추상화 한 개념이라고 하였습니다.\n이는 Java의 Class와 같은 개념으로 인식 할 수 있습니다.\nContainer는 Image를 기반으로 생성된 격리 된 실행환경이라 했습니다. 그리고 Container를 실행 할 경우 파라미터를 통해 Container 내부 설정정보를 변경 할 수도 있습니다.\n이는 Class를 바탕으로 만들어진 Instance의 개념으로 이해 할 수 있습니다.\n이처럼 Java의 Class와 Instance의 관계로 이해한다면, Docker에서의 Image와 Container 관계에 대해 어렵지 않게 이해 할 수 있을 것 같습니다.</p>\n<p><img src=\"./docking-image.png\" alt=\"docking-image\"></p>\n<p>도킹에 성공한 Container는 Host OS에 설치 된 프로그램 처럼 사용할 수 있다.</p>\n<h1 id=\"docker-vs-virtual-machine\">Docker vs Virtual Machine</h1>\n<p>위에서 설명하길 &quot;Docker란 <strong>Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼</strong>입니다.&quot; 라고 이야기 하였습니다.\n가상화라고 하면 대표적인 예가 Virtual Machine 즉 VM을 떠올릴 수 있는데요.</p>\n<p>VM과 Docker는 몇가지 차이점이 있습니다.\n먼저 그림으로 그 구조를 확인해 보겠습니다.</p>\n<p><img src=\"./vm-vs-docker.png\" alt=\"vm-vs-docker\"></p>\n<p>먼저 VM의 가상화 방식은 기존의 <code>Host OS위에 Hyper Visor를 이용</code>하여 가상화 OS를 띄우는 방식으로 많이 구현했습니다.\n주로 Windows에서 VMWare, Virtual Box, Hyper-V등 가상화 도구를 이용해 Guest OS를 설치하고 그 OS 위에 우리가 사용하고자 하는 프로그램을 설치하여 사용하였습니다.</p>\n<p>이러한 방식은 <code>완벽한 수준의 격리</code>이며, Host OS에서 Guest OS의 프로그램을 직접적으로 제어할 수 없습니다\n또한 Host OS에서 할당한 자원(Resource)밖에 사용할 수 없기 때문에 Host OS에서도 가상 OS에 점유한 자원을 유동적으로 사용할 수 없어 낭비가 생깁니다.</p>\n<p>반면에 Container 방식은 <strong>기존의 Host OS위에 Docker를 이용하여 해당 프로그램의 의존성 라이브러리(프로그램 구동에 필요한 라이브러리)만 가지고 Container가 생성</strong>됩니다. 그렇기에 <code>최소한의 용량으로 이미지를 구성</code> 할 수 있습니다.\nVM에서 사용되는 OS나 Kernel이 없기 때문에 부팅을 할 필요도 없으며, Host OS의 Resource 또한 유동적으로 사용할 수 있어 자원관리가 효율적입니다.</p>\n<p>단순히 프로세스를 격리시키는 것이기 때문에 <code>VM에 비해 매우 빠르게 동작</code>합니다.\n단점인 부분은 <strong>Host OS에 종속적인 부분이 있습니다.</strong>\nVM방식의 경우 각각의 OS에 대한 독립성을 가지고 있어, Host OS에 대해 독립적입니다. (예를들어 Host OS가 리눅스이고, Guest OS가 Windows인 경우, MSSQL을 Guest OS에서 사용할 수 있다)\n하지만 Container방식은 Host OS의 자원을 기반으로 생성 되기 때문에 <code>Host OS에서 작동할 수 없는 프로그램은 Container 내부에서 작동 할 수 없습니다.</code></p>\n<h1 id=\"docker-for-xx\">Docker for XX</h1>\n<p>Docker는 리눅스 컨테이너 기반으로 동작하지만 최근 Windows와 Mac에 대해서도 Docker를 지원하고 있습니다.\n하지만 Linux기반 Docker와 조금 차이점이 있습니다.\n아무래도 Linux 기반 컨테이너이기 때문에 Windows에서는 Hyper-V에 리눅스를 설치하여 연동되게 되어있습니다.\n이 경우 Host OS가 Windows가 되는 것이 아니라, Hyper-V의 리눅스가 Host OS가 되는 것이기 때문에 Hyper-V에 할당된 메모리와 디스크 용량을 기반으로 자원을 활용하게 됩니다.\nLinux가 아닌 다른 운영체제에서 Docker 설치 시 유의해야 할 부분입니다.</p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>\n<p><a href=\"http://www.sauru.so/blog/getting-started-with-docker/\" target=\"_blank\" rel=\"noopener\">http://www.sauru.so/blog/getting-started-with-docker/</a></p>\n</li>\n<li>\n<p><a href=\"http://www.sauru.so/blog/getting-started-with-docker/\" target=\"_blank\" rel=\"noopener\">http://www.sauru.so/blog/getting-started-with-docker/</a></p>\n</li>\n<li>\n<p><a href=\"https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html\" target=\"_blank\" rel=\"noopener\">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p>\n</li>\n<li>\n<p><a href=\"https://www.docker.com/enterprise-edition#/platform\" target=\"_blank\" rel=\"noopener\">https://www.docker.com/enterprise-edition#/platform</a></p>\n</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>Docker란 무엇인가?</h1>\n<p><img src=\"./docker-logo.png\" alt=\"docker-logo\"></p>\n<p>Docker란 <strong>Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼</strong> 입니다.</p>\n<p>위의 Docker 이미지처럼 선박에 화물을 수송하는 이미지를 떠올리면 이해하기가 쉬운데, 실제 선박에는 자동차, 오토바이, 전자제품등 여러 물건을 담을 수 있습니다.</p>\n<p>선박에 대한 이미지를 유지한 채, Web Service 운영환경을 생각해 보면..\nWeb Service 운영환경을 구성하기 위해서는 Web Application이 구동 될 수 있는 WAS와 DataBase가 필요합니다.</p>\n<p>이 2가지 프로그램을 Docker라는 선박에 담는다고 생각해 봅시다.\n그 다음 우리가 배포할 서버를 항구(Port)라고 생각하고,\n각 서버에 Web Service 운영환경을 싣고 있는 선박을 정착 시켜 서버에서 접근가능한 서비스로 이용할 수 있습니다. 따라서 어떤 서버에서도 Docker만 설치되어 있다면, 다양한 <code>프로그램과 실행환경을 추상화 하여 동일한 인터페이스를 제공</code>하고 서버관리를 쉽고 단순하게 만들어 줄 수 있습니다.</p>\n<p>Docker에서는 <code>Image</code>와 <code>Container</code>라는 개념을 사용하는데, 이 두 가지 개념에 대해 알아보도록 하겠습니다.</p>\n<h1>Docker Image</h1>\n<p><img src=\"./docker-image.png\" alt=\"docker-image\"></p>\n<p>Docker Image는 우리가 사용할 프로그램을 추상화 한 개념입니다.</p>\n<p>Image에는 Container 실행에 필요한 파일(redis.conf, redis.log...., docker-entrypoing.sh등)등을 포함하고,\n설정값(port, env, data directory등) 정보를 포함하고 있습니다.\n<code>1개의 이미지</code>를 바탕으로<code>여러 개의 컨테이너</code>를 만들 수 있습니다.\n(ex. 하나의 Redis 이미지를 바탕으로 3개의 Redis Container를 구성하여 Cluster환경을 구성할 수 있습니다.)\n이 내용을 좀 더 쉽게 이해하자면, 한번 쯤은 WM에 Linux를 설치 해 본 경험이 있을텐데, Linux를 설치 하기 위해선 linux.iso 파일이 필요 합니다.\n이때 iso파일이 Linux를 구성하기 위한 파일과 설정 정보를 담고 있고 VM에 Linux를 설치 할 수 있게 해줍니다.\n여기서 <code>iso파일</code>을 <code>Image</code>라고 생각하고, <code>VM위에 설치되는 리눅스</code>를 <code>Container</code>라고 이해 할 수 있겠습니다.</p>\n<p>Docker를 이용한 운영 배포 시, 이미지를 <code>Docker Hub</code>라는 곳에 올려 각 서버에서 받아 사용할 수 있습니다.\n(Docker Hub는 github나 maven repository 같은 클라우드 저장소 같은 개념으로 이해 하시면 됩니다.)</p>\n<h1>Docker Container</h1>\n<p>Container란, <strong>프로그램의 실행에 필요한 실행환경을 독립적으로 운용할 수 있도록, 다른 실행환경과의 간섭을 막고 독립성을 확보해 주는 운영체제 수준의 격리 기술</strong>을 의미합니다.</p>\n<p>이러한 격리된 환경이 필요한 경우를 생각해 볼 수 있는데, 극단적인 예시로 Java 1.6 환경에서만 실행되는 프로그램과 Java 1.8이상 환경에서만 실행 되는 프로그램을 하나의 서버에 설치한다고 가정하겠습니다.</p>\n<p>프로그램이 실행 되기 위해서는 운영체제에 설치 된 라이브러리의 대해 의존성을 가질 수 밖에 없는데, 하나의 OS에서 Java Version에 대한 격리 환경을 가지게 하는 것은 상당히 번거로운 일입니다.\n이러한 경우 Docker를 사용하면 격리된 구역에서 실행 환경을 만들어 줄 수 있기 때문에 타 시스템에 영향을 주지 않고 안정적으로 운영환경을 구성 할 수 있습니다.</p>\n<p>Docker을 처음 공부할 때 Image와 Container 관계가 무척이나 헷갈렸는데.. 예시를 통해 이해해 보겠습니다.\nImage는 실행 환경에 대한 파일과 설정 정보를 담고 있다고 했습니다. 그리고 프로그램을 추상화 한 개념이라고 하였습니다.\n이는 Java의 Class와 같은 개념으로 인식 할 수 있습니다.\nContainer는 Image를 기반으로 생성된 격리 된 실행환경이라 했습니다. 그리고 Container를 실행 할 경우 파라미터를 통해 Container 내부 설정정보를 변경 할 수도 있습니다.\n이는 Class를 바탕으로 만들어진 Instance의 개념으로 이해 할 수 있습니다.\n이처럼 Java의 Class와 Instance의 관계로 이해한다면, Docker에서의 Image와 Container 관계에 대해 어렵지 않게 이해 할 수 있을 것 같습니다.</p>\n<p><img src=\"./docking-image.png\" alt=\"docking-image\"></p>\n<p>도킹에 성공한 Container는 Host OS에 설치 된 프로그램 처럼 사용할 수 있다.</p>\n<h1>Docker vs Virtual Machine</h1>\n<p>위에서 설명하길 &quot;Docker란 <strong>Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼</strong>입니다.&quot; 라고 이야기 하였습니다.\n가상화라고 하면 대표적인 예가 Virtual Machine 즉 VM을 떠올릴 수 있는데요.</p>\n<p>VM과 Docker는 몇가지 차이점이 있습니다.\n먼저 그림으로 그 구조를 확인해 보겠습니다.</p>\n<p><img src=\"./vm-vs-docker.png\" alt=\"vm-vs-docker\"></p>\n<p>먼저 VM의 가상화 방식은 기존의 <code>Host OS위에 Hyper Visor를 이용</code>하여 가상화 OS를 띄우는 방식으로 많이 구현했습니다.\n주로 Windows에서 VMWare, Virtual Box, Hyper-V등 가상화 도구를 이용해 Guest OS를 설치하고 그 OS 위에 우리가 사용하고자 하는 프로그램을 설치하여 사용하였습니다.</p>\n<p>이러한 방식은 <code>완벽한 수준의 격리</code>이며, Host OS에서 Guest OS의 프로그램을 직접적으로 제어할 수 없습니다\n또한 Host OS에서 할당한 자원(Resource)밖에 사용할 수 없기 때문에 Host OS에서도 가상 OS에 점유한 자원을 유동적으로 사용할 수 없어 낭비가 생깁니다.</p>\n<p>반면에 Container 방식은 <strong>기존의 Host OS위에 Docker를 이용하여 해당 프로그램의 의존성 라이브러리(프로그램 구동에 필요한 라이브러리)만 가지고 Container가 생성</strong>됩니다. 그렇기에 <code>최소한의 용량으로 이미지를 구성</code> 할 수 있습니다.\nVM에서 사용되는 OS나 Kernel이 없기 때문에 부팅을 할 필요도 없으며, Host OS의 Resource 또한 유동적으로 사용할 수 있어 자원관리가 효율적입니다.</p>\n<p>단순히 프로세스를 격리시키는 것이기 때문에 <code>VM에 비해 매우 빠르게 동작</code>합니다.\n단점인 부분은 <strong>Host OS에 종속적인 부분이 있습니다.</strong>\nVM방식의 경우 각각의 OS에 대한 독립성을 가지고 있어, Host OS에 대해 독립적입니다. (예를들어 Host OS가 리눅스이고, Guest OS가 Windows인 경우, MSSQL을 Guest OS에서 사용할 수 있다)\n하지만 Container방식은 Host OS의 자원을 기반으로 생성 되기 때문에 <code>Host OS에서 작동할 수 없는 프로그램은 Container 내부에서 작동 할 수 없습니다.</code></p>\n<h1>Docker for XX</h1>\n<p>Docker는 리눅스 컨테이너 기반으로 동작하지만 최근 Windows와 Mac에 대해서도 Docker를 지원하고 있습니다.\n하지만 Linux기반 Docker와 조금 차이점이 있습니다.\n아무래도 Linux 기반 컨테이너이기 때문에 Windows에서는 Hyper-V에 리눅스를 설치하여 연동되게 되어있습니다.\n이 경우 Host OS가 Windows가 되는 것이 아니라, Hyper-V의 리눅스가 Host OS가 되는 것이기 때문에 Hyper-V에 할당된 메모리와 디스크 용량을 기반으로 자원을 활용하게 됩니다.\nLinux가 아닌 다른 운영체제에서 Docker 설치 시 유의해야 할 부분입니다.</p>\n<h1>참고</h1>\n<ul>\n<li>\n<p><a href=\"http://www.sauru.so/blog/getting-started-with-docker/\" target=\"_blank\" rel=\"noopener\">http://www.sauru.so/blog/getting-started-with-docker/</a></p>\n</li>\n<li>\n<p><a href=\"http://www.sauru.so/blog/getting-started-with-docker/\" target=\"_blank\" rel=\"noopener\">http://www.sauru.so/blog/getting-started-with-docker/</a></p>\n</li>\n<li>\n<p><a href=\"https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html\" target=\"_blank\" rel=\"noopener\">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p>\n</li>\n<li>\n<p><a href=\"https://www.docker.com/enterprise-edition#/platform\" target=\"_blank\" rel=\"noopener\">https://www.docker.com/enterprise-edition#/platform</a></p>\n</li>\n</ul>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (5) Docker Network구조","date":"2018-12-01T08:25:03.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-12-01-docker-5","typora-copy-images-to":"2018-12-01-docker-5","_content":"\n# Docker Network 모드\n\nDocker에서 제공하는 Network 모드는 총 4개 입니다. \n(추가적으로 2개의 모드가 더 있습니다. Overlay, Macvlan 모드가 있지만 Docker Swarm과 관련된 내용이므로 이번 장에서는 기술 하지 않겠습니다.)\n\n* Bridge 모드\n* Container 모드 (이것도 Bridge 모드의 일종)\n* Host 모드\n* none 모드\n\n이번 장에서는 위 Network 모드에 대해 알아보도록 하겠습니다.\n\n\n\n# Bridge 모드\n\nDocker에서 network 설정을 별도로 하지 않으면 Default로 작용하는 모드입니다.\nDocker가 설치되면 docker0라는 네트워크 인터페이스가 생성됩니다. (Virtual Interface)\n\n![docker-bridge-mode](./docker-bridge-mode.png)\n\n위는 docker0 인터페이스를 바탕으로 각 Container와 Bridge 형식으로 엮어진 모습입니다.\n\n![docker-bridge-2](./docker-bridge-2.PNG)\n\nHost OS에서 network interface를 검색해 보면 docker0라는 virtual interface를 확인할 수 있습니다.\n\n>**docker0 interface의 특징**\n>\n>*  IP는 자동으로 172.17.0.1로 설정\n>*  IP는 DHCP로 할당받는 것이 아닌 Docker 내부로직에 의해 결정\n>*  docker0는 virtual ethernet bridge\n>*  L2 통신 기반\n\n`\"docker bridge 모드는 같은 host 내에서만 사용 가능하다.\"` 라는 제약이 있다.\n즉, 다른 host(다른서버)와의 docker와는 통신이 불가능합니다. \n왜냐하면 다른 서버가 docker0 인터페이스의 외부에 있기 때문에 그렇습니다.\n\n\n\n# docker0 interface와 Container의 연결 방식\n\n![docker0-interface](./docker0-interface.PNG)\n\n위 이미지를 보면, 현재 Docker를 이용하여 redis와 nginx를 설치한 상태입니다.\n두 번째 명령을 보면 brctl명령으로 docker0 interface에 연결된 interfaces가 2개 보입니다.\n\n* veth062947b\n* veth3b5bdll\n\ncontainer 2개가 bridge 방식으로 연결 되어 있기 때문에 veth~하는 interface가 생성되어있습니다.\n위에 그림에서 보듯이 veth와 각 container 내부의 eth0 interface와 연결되어 있습니다.\n\n![ip](./ip.PNG)\n\nRedis Container에 대해 docker inspect 명령을 날려보았습니다.\n네트워크 설정 부분이 아래에 나오는데 Network 부분을 보시면 Gateway는 172.17.0.1이라 되어 있습니다.\n이 ip 주소는 docker0 interface의 ip주소입니다.\n따라서 docker0의 bridge로 연결되어 172.17.0.2라는 내부 ip를 가진 Container로 생성된 것입니다.\n\n\n\n# Container 모드 (이것도 Bridge 모드의 일부)\n\nContainer 모드는 다른 Container의 네트워크 리소스를 같이 쓰는? 개념입니다.\n\n먼저 httpd를 설치하고..\n그다음에 redis를 설치하여 httpd의 container 정보를 가지고 net설정을 해주었습니다.\n\n```sh\ndocker run -d httpd\ndocker run -d --net=container:(httpd의 containerId) redis\n```\n\n![httpd](./httpd.PNG)\n\n위 이미지(httpd에 대한 정보)를 보면 docker0 interface를 이용하고 bridge 모드로 설정되어 있습니다.\n\n\n\n![redis1](./redis1.PNG)\n\n하지만, Redis의 Network 정보를 보면 텅텅 비어있습니다.\n이는 docker0 interface를 통해 네트워크 설정이 bind 되지 않았다는 의미입니다.\n\n\n\n약간 위로 올려보면\n\n![redis2](./redis2.PNG)\n\nNetworkMode에 httpd의 container 자원을 사용하여 접근하는 것을 알 수 있습니다.\n다른 docker image 중 내부 명령어로 ip addr을 지원하는 image가 있다면\n\n```sh\ndocker exec <container ID> ip addr show\n```\n\n위 명령을 통해 Mac Address가 Container자원을 할당한 Container의 Mac Address와 같음을 알 수 있습니다.\n\n\n\n# Host 모드\n\nHost 모드는 docker0 interface를 사용하지 않고 Host OS의 네트워크 자원을 사용합니다.\nbridge 형식으로 사용하지 않기 때문에 brctl show docker0 명령으로 검색해도 interfaces에 나타나지 않습니다.\n**Bridge를 쓰지 않기 때문에 Container에서 `Port를 노출하지 않는 경우 사용할 수가 없는 점`을 유의 해야 합니다.**\n(Redis Cluster를 구성 할 때에도 Redis에서는 Cluster모드 구현 시, docker bridge mode를 지원하지 않기 때문에 host로 설정했었습니다.)\n\n```sh\ndocker run --net=host -p \"6515\" #이렇게 옵션을 추가해주면 됩니다. (port는 문자열로!)\n```\n\n```yml\n#또는 docker-compose.yml 파일에서\nredis:\n  network_mode: host #이 처럼 표기하시면 됩니다.\n```\n\n\n\n# none 모드\n\n--net=none 옵션으로 Container 생성 시, 격리된 네트워크 영역을 갖기는 하지만 network 인터페이스가 없는 Container가 생성 됩니다.\n\n아래의 코드로 테스트를 해보았습니다.\n\n```sh\ndocker run --net=none -d httpd\ndocker exec httpd ip addr show\n```\n\n![none](./none.PNG)\n\n검색되는 내부 네트워크 인터페이스가 없습니다.\n\n>**none으로 처리하는 이유**\nnetwork mode를 none으로 하는 경우는 보통 사용자 정의 interface를 사용할 때 입니다.\nnetwork 환경을 깔끔하게 만든 다음에 사용자 정의 interface를 적용하기 위함입니다.\n\n\n\n# 참고\n\n* http://bluese05.tistory.com/38\n* https://docs.docker.com/network/network-tutorial-standalone/#use-the-default-bridge-network\n* https://docs.docker.com/network/network-tutorial-host/","source":"_posts/2018-12-01-docker-5.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (5) Docker Network구조\ndate: 2018-12-01 17:25:03\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-12-01-docker-5\ntypora-copy-images-to: 2018-12-01-docker-5\n---\n\n# Docker Network 모드\n\nDocker에서 제공하는 Network 모드는 총 4개 입니다. \n(추가적으로 2개의 모드가 더 있습니다. Overlay, Macvlan 모드가 있지만 Docker Swarm과 관련된 내용이므로 이번 장에서는 기술 하지 않겠습니다.)\n\n* Bridge 모드\n* Container 모드 (이것도 Bridge 모드의 일종)\n* Host 모드\n* none 모드\n\n이번 장에서는 위 Network 모드에 대해 알아보도록 하겠습니다.\n\n\n\n# Bridge 모드\n\nDocker에서 network 설정을 별도로 하지 않으면 Default로 작용하는 모드입니다.\nDocker가 설치되면 docker0라는 네트워크 인터페이스가 생성됩니다. (Virtual Interface)\n\n![docker-bridge-mode](./docker-bridge-mode.png)\n\n위는 docker0 인터페이스를 바탕으로 각 Container와 Bridge 형식으로 엮어진 모습입니다.\n\n![docker-bridge-2](./docker-bridge-2.PNG)\n\nHost OS에서 network interface를 검색해 보면 docker0라는 virtual interface를 확인할 수 있습니다.\n\n>**docker0 interface의 특징**\n>\n>*  IP는 자동으로 172.17.0.1로 설정\n>*  IP는 DHCP로 할당받는 것이 아닌 Docker 내부로직에 의해 결정\n>*  docker0는 virtual ethernet bridge\n>*  L2 통신 기반\n\n`\"docker bridge 모드는 같은 host 내에서만 사용 가능하다.\"` 라는 제약이 있다.\n즉, 다른 host(다른서버)와의 docker와는 통신이 불가능합니다. \n왜냐하면 다른 서버가 docker0 인터페이스의 외부에 있기 때문에 그렇습니다.\n\n\n\n# docker0 interface와 Container의 연결 방식\n\n![docker0-interface](./docker0-interface.PNG)\n\n위 이미지를 보면, 현재 Docker를 이용하여 redis와 nginx를 설치한 상태입니다.\n두 번째 명령을 보면 brctl명령으로 docker0 interface에 연결된 interfaces가 2개 보입니다.\n\n* veth062947b\n* veth3b5bdll\n\ncontainer 2개가 bridge 방식으로 연결 되어 있기 때문에 veth~하는 interface가 생성되어있습니다.\n위에 그림에서 보듯이 veth와 각 container 내부의 eth0 interface와 연결되어 있습니다.\n\n![ip](./ip.PNG)\n\nRedis Container에 대해 docker inspect 명령을 날려보았습니다.\n네트워크 설정 부분이 아래에 나오는데 Network 부분을 보시면 Gateway는 172.17.0.1이라 되어 있습니다.\n이 ip 주소는 docker0 interface의 ip주소입니다.\n따라서 docker0의 bridge로 연결되어 172.17.0.2라는 내부 ip를 가진 Container로 생성된 것입니다.\n\n\n\n# Container 모드 (이것도 Bridge 모드의 일부)\n\nContainer 모드는 다른 Container의 네트워크 리소스를 같이 쓰는? 개념입니다.\n\n먼저 httpd를 설치하고..\n그다음에 redis를 설치하여 httpd의 container 정보를 가지고 net설정을 해주었습니다.\n\n```sh\ndocker run -d httpd\ndocker run -d --net=container:(httpd의 containerId) redis\n```\n\n![httpd](./httpd.PNG)\n\n위 이미지(httpd에 대한 정보)를 보면 docker0 interface를 이용하고 bridge 모드로 설정되어 있습니다.\n\n\n\n![redis1](./redis1.PNG)\n\n하지만, Redis의 Network 정보를 보면 텅텅 비어있습니다.\n이는 docker0 interface를 통해 네트워크 설정이 bind 되지 않았다는 의미입니다.\n\n\n\n약간 위로 올려보면\n\n![redis2](./redis2.PNG)\n\nNetworkMode에 httpd의 container 자원을 사용하여 접근하는 것을 알 수 있습니다.\n다른 docker image 중 내부 명령어로 ip addr을 지원하는 image가 있다면\n\n```sh\ndocker exec <container ID> ip addr show\n```\n\n위 명령을 통해 Mac Address가 Container자원을 할당한 Container의 Mac Address와 같음을 알 수 있습니다.\n\n\n\n# Host 모드\n\nHost 모드는 docker0 interface를 사용하지 않고 Host OS의 네트워크 자원을 사용합니다.\nbridge 형식으로 사용하지 않기 때문에 brctl show docker0 명령으로 검색해도 interfaces에 나타나지 않습니다.\n**Bridge를 쓰지 않기 때문에 Container에서 `Port를 노출하지 않는 경우 사용할 수가 없는 점`을 유의 해야 합니다.**\n(Redis Cluster를 구성 할 때에도 Redis에서는 Cluster모드 구현 시, docker bridge mode를 지원하지 않기 때문에 host로 설정했었습니다.)\n\n```sh\ndocker run --net=host -p \"6515\" #이렇게 옵션을 추가해주면 됩니다. (port는 문자열로!)\n```\n\n```yml\n#또는 docker-compose.yml 파일에서\nredis:\n  network_mode: host #이 처럼 표기하시면 됩니다.\n```\n\n\n\n# none 모드\n\n--net=none 옵션으로 Container 생성 시, 격리된 네트워크 영역을 갖기는 하지만 network 인터페이스가 없는 Container가 생성 됩니다.\n\n아래의 코드로 테스트를 해보았습니다.\n\n```sh\ndocker run --net=none -d httpd\ndocker exec httpd ip addr show\n```\n\n![none](./none.PNG)\n\n검색되는 내부 네트워크 인터페이스가 없습니다.\n\n>**none으로 처리하는 이유**\nnetwork mode를 none으로 하는 경우는 보통 사용자 정의 interface를 사용할 때 입니다.\nnetwork 환경을 깔끔하게 만든 다음에 사용자 정의 interface를 적용하기 위함입니다.\n\n\n\n# 참고\n\n* http://bluese05.tistory.com/38\n* https://docs.docker.com/network/network-tutorial-standalone/#use-the-default-bridge-network\n* https://docs.docker.com/network/network-tutorial-host/","slug":"2018-12-01-docker-5","published":1,"updated":"2018-12-08T08:32:55.265Z","comments":1,"photos":[],"link":"","_id":"cjrgbv2rw000hcr1twf83zmm5","content":"<h1 id=\"docker-network-모드\">Docker Network 모드</h1>\n<p>Docker에서 제공하는 Network 모드는 총 4개 입니다.\n(추가적으로 2개의 모드가 더 있습니다. Overlay, Macvlan 모드가 있지만 Docker Swarm과 관련된 내용이므로 이번 장에서는 기술 하지 않겠습니다.)</p>\n<ul>\n<li>Bridge 모드</li>\n<li>Container 모드 (이것도 Bridge 모드의 일종)</li>\n<li>Host 모드</li>\n<li>none 모드</li>\n</ul>\n<p>이번 장에서는 위 Network 모드에 대해 알아보도록 하겠습니다.</p>\n<h1 id=\"bridge-모드\">Bridge 모드</h1>\n<p>Docker에서 network 설정을 별도로 하지 않으면 Default로 작용하는 모드입니다.\nDocker가 설치되면 docker0라는 네트워크 인터페이스가 생성됩니다. (Virtual Interface)</p>\n<p><img src=\"./docker-bridge-mode.png\" alt=\"docker-bridge-mode\"></p>\n<p>위는 docker0 인터페이스를 바탕으로 각 Container와 Bridge 형식으로 엮어진 모습입니다.</p>\n<p><img src=\"./docker-bridge-2.PNG\" alt=\"docker-bridge-2\"></p>\n<p>Host OS에서 network interface를 검색해 보면 docker0라는 virtual interface를 확인할 수 있습니다.</p>\n<blockquote>\n<p><strong>docker0 interface의 특징</strong></p>\n<ul>\n<li>IP는 자동으로 172.17.0.1로 설정</li>\n<li>IP는 DHCP로 할당받는 것이 아닌 Docker 내부로직에 의해 결정</li>\n<li>docker0는 virtual ethernet bridge</li>\n<li>L2 통신 기반</li>\n</ul>\n</blockquote>\n<p><code>&quot;docker bridge 모드는 같은 host 내에서만 사용 가능하다.&quot;</code> 라는 제약이 있다.\n즉, 다른 host(다른서버)와의 docker와는 통신이 불가능합니다.\n왜냐하면 다른 서버가 docker0 인터페이스의 외부에 있기 때문에 그렇습니다.</p>\n<h1 id=\"docker0-interface와-container의-연결-방식\">docker0 interface와 Container의 연결 방식</h1>\n<p><img src=\"./docker0-interface.PNG\" alt=\"docker0-interface\"></p>\n<p>위 이미지를 보면, 현재 Docker를 이용하여 redis와 nginx를 설치한 상태입니다.\n두 번째 명령을 보면 brctl명령으로 docker0 interface에 연결된 interfaces가 2개 보입니다.</p>\n<ul>\n<li>veth062947b</li>\n<li>veth3b5bdll</li>\n</ul>\n<p>container 2개가 bridge 방식으로 연결 되어 있기 때문에 veth~하는 interface가 생성되어있습니다.\n위에 그림에서 보듯이 veth와 각 container 내부의 eth0 interface와 연결되어 있습니다.</p>\n<p><img src=\"./ip.PNG\" alt=\"ip\"></p>\n<p>Redis Container에 대해 docker inspect 명령을 날려보았습니다.\n네트워크 설정 부분이 아래에 나오는데 Network 부분을 보시면 Gateway는 172.17.0.1이라 되어 있습니다.\n이 ip 주소는 docker0 interface의 ip주소입니다.\n따라서 docker0의 bridge로 연결되어 172.17.0.2라는 내부 ip를 가진 Container로 생성된 것입니다.</p>\n<h1 id=\"container-모드-이것도-bridge-모드의-일부\">Container 모드 (이것도 Bridge 모드의 일부)</h1>\n<p>Container 모드는 다른 Container의 네트워크 리소스를 같이 쓰는? 개념입니다.</p>\n<p>먼저 httpd를 설치하고..\n그다음에 redis를 설치하여 httpd의 container 정보를 가지고 net설정을 해주었습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d httpd</span><br><span class=\"line\">docker run -d --net=container:(httpd의 containerId) redis</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./httpd.PNG\" alt=\"httpd\"></p>\n<p>위 이미지(httpd에 대한 정보)를 보면 docker0 interface를 이용하고 bridge 모드로 설정되어 있습니다.</p>\n<p><img src=\"./redis1.PNG\" alt=\"redis1\"></p>\n<p>하지만, Redis의 Network 정보를 보면 텅텅 비어있습니다.\n이는 docker0 interface를 통해 네트워크 설정이 bind 되지 않았다는 의미입니다.</p>\n<p>약간 위로 올려보면</p>\n<p><img src=\"./redis2.PNG\" alt=\"redis2\"></p>\n<p>NetworkMode에 httpd의 container 자원을 사용하여 접근하는 것을 알 수 있습니다.\n다른 docker image 중 내부 명령어로 ip addr을 지원하는 image가 있다면</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> &lt;container ID&gt; ip addr show</span><br></pre></td></tr></table></figure></p>\n<p>위 명령을 통해 Mac Address가 Container자원을 할당한 Container의 Mac Address와 같음을 알 수 있습니다.</p>\n<h1 id=\"host-모드\">Host 모드</h1>\n<p>Host 모드는 docker0 interface를 사용하지 않고 Host OS의 네트워크 자원을 사용합니다.\nbridge 형식으로 사용하지 않기 때문에 brctl show docker0 명령으로 검색해도 interfaces에 나타나지 않습니다.\n<strong>Bridge를 쓰지 않기 때문에 Container에서 <code>Port를 노출하지 않는 경우 사용할 수가 없는 점</code>을 유의 해야 합니다.</strong>\n(Redis Cluster를 구성 할 때에도 Redis에서는 Cluster모드 구현 시, docker bridge mode를 지원하지 않기 때문에 host로 설정했었습니다.)</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --net=host -p <span class=\"string\">\"6515\"</span> <span class=\"comment\">#이렇게 옵션을 추가해주면 됩니다. (port는 문자열로!)</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#또는 docker-compose.yml 파일에서</span></span><br><span class=\"line\"><span class=\"attr\">redis:</span></span><br><span class=\"line\"><span class=\"attr\">  network_mode:</span> <span class=\"string\">host</span> <span class=\"comment\">#이 처럼 표기하시면 됩니다.</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"none-모드\">none 모드</h1>\n<p>--net=none 옵션으로 Container 생성 시, 격리된 네트워크 영역을 갖기는 하지만 network 인터페이스가 없는 Container가 생성 됩니다.</p>\n<p>아래의 코드로 테스트를 해보았습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --net=none -d httpd</span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> httpd ip addr show</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./none.PNG\" alt=\"none\"></p>\n<p>검색되는 내부 네트워크 인터페이스가 없습니다.</p>\n<blockquote>\n<p><strong>none으로 처리하는 이유</strong>\nnetwork mode를 none으로 하는 경우는 보통 사용자 정의 interface를 사용할 때 입니다.\nnetwork 환경을 깔끔하게 만든 다음에 사용자 정의 interface를 적용하기 위함입니다.</p>\n</blockquote>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>http://bluese05.tistory.com/38</li>\n<li>https://docs.docker.com/network/network-tutorial-standalone/#use-the-default-bridge-network</li>\n<li>https://docs.docker.com/network/network-tutorial-host/</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>Docker Network 모드</h1>\n<p>Docker에서 제공하는 Network 모드는 총 4개 입니다.\n(추가적으로 2개의 모드가 더 있습니다. Overlay, Macvlan 모드가 있지만 Docker Swarm과 관련된 내용이므로 이번 장에서는 기술 하지 않겠습니다.)</p>\n<ul>\n<li>Bridge 모드</li>\n<li>Container 모드 (이것도 Bridge 모드의 일종)</li>\n<li>Host 모드</li>\n<li>none 모드</li>\n</ul>\n<p>이번 장에서는 위 Network 모드에 대해 알아보도록 하겠습니다.</p>\n<h1>Bridge 모드</h1>\n<p>Docker에서 network 설정을 별도로 하지 않으면 Default로 작용하는 모드입니다.\nDocker가 설치되면 docker0라는 네트워크 인터페이스가 생성됩니다. (Virtual Interface)</p>\n<p><img src=\"./docker-bridge-mode.png\" alt=\"docker-bridge-mode\"></p>\n<p>위는 docker0 인터페이스를 바탕으로 각 Container와 Bridge 형식으로 엮어진 모습입니다.</p>\n<p><img src=\"./docker-bridge-2.PNG\" alt=\"docker-bridge-2\"></p>\n<p>Host OS에서 network interface를 검색해 보면 docker0라는 virtual interface를 확인할 수 있습니다.</p>\n<blockquote>\n<p><strong>docker0 interface의 특징</strong></p>\n<ul>\n<li>IP는 자동으로 172.17.0.1로 설정</li>\n<li>IP는 DHCP로 할당받는 것이 아닌 Docker 내부로직에 의해 결정</li>\n<li>docker0는 virtual ethernet bridge</li>\n<li>L2 통신 기반</li>\n</ul>\n</blockquote>\n<p><code>&quot;docker bridge 모드는 같은 host 내에서만 사용 가능하다.&quot;</code> 라는 제약이 있다.\n즉, 다른 host(다른서버)와의 docker와는 통신이 불가능합니다.\n왜냐하면 다른 서버가 docker0 인터페이스의 외부에 있기 때문에 그렇습니다.</p>\n<h1>docker0 interface와 Container의 연결 방식</h1>\n<p><img src=\"./docker0-interface.PNG\" alt=\"docker0-interface\"></p>\n<p>위 이미지를 보면, 현재 Docker를 이용하여 redis와 nginx를 설치한 상태입니다.\n두 번째 명령을 보면 brctl명령으로 docker0 interface에 연결된 interfaces가 2개 보입니다.</p>\n<ul>\n<li>veth062947b</li>\n<li>veth3b5bdll</li>\n</ul>\n<p>container 2개가 bridge 방식으로 연결 되어 있기 때문에 veth~하는 interface가 생성되어있습니다.\n위에 그림에서 보듯이 veth와 각 container 내부의 eth0 interface와 연결되어 있습니다.</p>\n<p><img src=\"./ip.PNG\" alt=\"ip\"></p>\n<p>Redis Container에 대해 docker inspect 명령을 날려보았습니다.\n네트워크 설정 부분이 아래에 나오는데 Network 부분을 보시면 Gateway는 172.17.0.1이라 되어 있습니다.\n이 ip 주소는 docker0 interface의 ip주소입니다.\n따라서 docker0의 bridge로 연결되어 172.17.0.2라는 내부 ip를 가진 Container로 생성된 것입니다.</p>\n<h1>Container 모드 (이것도 Bridge 모드의 일부)</h1>\n<p>Container 모드는 다른 Container의 네트워크 리소스를 같이 쓰는? 개념입니다.</p>\n<p>먼저 httpd를 설치하고..\n그다음에 redis를 설치하여 httpd의 container 정보를 가지고 net설정을 해주었습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d httpd</span><br><span class=\"line\">docker run -d --net=container:(httpd의 containerId) redis</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./httpd.PNG\" alt=\"httpd\"></p>\n<p>위 이미지(httpd에 대한 정보)를 보면 docker0 interface를 이용하고 bridge 모드로 설정되어 있습니다.</p>\n<p><img src=\"./redis1.PNG\" alt=\"redis1\"></p>\n<p>하지만, Redis의 Network 정보를 보면 텅텅 비어있습니다.\n이는 docker0 interface를 통해 네트워크 설정이 bind 되지 않았다는 의미입니다.</p>\n<p>약간 위로 올려보면</p>\n<p><img src=\"./redis2.PNG\" alt=\"redis2\"></p>\n<p>NetworkMode에 httpd의 container 자원을 사용하여 접근하는 것을 알 수 있습니다.\n다른 docker image 중 내부 명령어로 ip addr을 지원하는 image가 있다면</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> &lt;container ID&gt; ip addr show</span><br></pre></td></tr></table></figure></p>\n<p>위 명령을 통해 Mac Address가 Container자원을 할당한 Container의 Mac Address와 같음을 알 수 있습니다.</p>\n<h1>Host 모드</h1>\n<p>Host 모드는 docker0 interface를 사용하지 않고 Host OS의 네트워크 자원을 사용합니다.\nbridge 형식으로 사용하지 않기 때문에 brctl show docker0 명령으로 검색해도 interfaces에 나타나지 않습니다.\n<strong>Bridge를 쓰지 않기 때문에 Container에서 <code>Port를 노출하지 않는 경우 사용할 수가 없는 점</code>을 유의 해야 합니다.</strong>\n(Redis Cluster를 구성 할 때에도 Redis에서는 Cluster모드 구현 시, docker bridge mode를 지원하지 않기 때문에 host로 설정했었습니다.)</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --net=host -p <span class=\"string\">\"6515\"</span> <span class=\"comment\">#이렇게 옵션을 추가해주면 됩니다. (port는 문자열로!)</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#또는 docker-compose.yml 파일에서</span></span><br><span class=\"line\"><span class=\"attr\">redis:</span></span><br><span class=\"line\"><span class=\"attr\">  network_mode:</span> <span class=\"string\">host</span> <span class=\"comment\">#이 처럼 표기하시면 됩니다.</span></span><br></pre></td></tr></table></figure></p>\n<h1>none 모드</h1>\n<p>--net=none 옵션으로 Container 생성 시, 격리된 네트워크 영역을 갖기는 하지만 network 인터페이스가 없는 Container가 생성 됩니다.</p>\n<p>아래의 코드로 테스트를 해보았습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --net=none -d httpd</span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> httpd ip addr show</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./none.PNG\" alt=\"none\"></p>\n<p>검색되는 내부 네트워크 인터페이스가 없습니다.</p>\n<blockquote>\n<p><strong>none으로 처리하는 이유</strong>\nnetwork mode를 none으로 하는 경우는 보통 사용자 정의 interface를 사용할 때 입니다.\nnetwork 환경을 깔끔하게 만든 다음에 사용자 정의 interface를 적용하기 위함입니다.</p>\n</blockquote>\n<h1>참고</h1>\n<ul>\n<li>http://bluese05.tistory.com/38</li>\n<li>https://docs.docker.com/network/network-tutorial-standalone/#use-the-default-bridge-network</li>\n<li>https://docs.docker.com/network/network-tutorial-host/</li>\n</ul>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (9) Redis-Stats을 이용한 모니터링","date":"2018-12-03T06:04:50.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-12-03-redis-stats","typora-copy-images-to":"2018-12-03-redis-stats","_content":"\n# Redis-stats\n\nRedis-stat은 대표적인 `오픈소스 Redis 모니터링 도구`입니다.\n\nRuby 기반으로 동작하는 프로그램이며, Ruby만 설치되어 있다면 설치가 간편하고 Web 또는 Console로 Redis 서버를 모니터링 할 수 있습니다.\n비슷한 모니터링 도구로 Redmon, RedisLive등이 있지만.. Redis 4이상 버전을 아직 지원하지 않아서 Redis-stat으로 설치 해보게 되었습니다.\n\n\n# Redis-stats 설치하기\n## Install Dependency\n```sh\nyum install -y gcc-c++ patch readline readline-devel zlib zlib-devel openssl-devel make\nyum install -y bzip2 autoconf automake libtool bison iconv-devel sqlite-devel libyaml-devel libffi-devel\n```\n\n\n\n## Install RVM (Ruby Version Manager)\n\n```sh\ncurl -sSL https://rvm.io/mpapis.asc | gpg --import\ncurl -L get.rvm.io | bash -s stable\n```\n\n\n\n## Setup RVM Environment\n\n```sh\nsource /etc/profile.d/rvm.sh\nrvm reload\n```\n\n\n\n## Install Ruby 2.3.3\n\n```sh\nrvm install 2.3.3\n```\n\n\n\n## Set Default Ruby Version\n\n```sh\nrvm list\nrvm use 2.3.3 --default\n```\n\n\n\n## Setup Redis-stat\n\n```sh\ngem install redis-stat\n```\n\n\n\n# Redis-stat 실행하기\n\nRedis-stat은 Web에서 조회하는 방법과 Console에서 조회하는 방법이 있습니다.\n두 가지 형태의 모니터링 방법과 속성에 대해 알아보겠습니다.\n\n\n\n## Redis-stat 옵션\n\n| **명령어**                                     | **설명**                                                     | **비고**                                        |\n| ---------------------------------------------- | ------------------------------------------------------------ | ----------------------------------------------- |\n| redis-stat 1                                   | localhost:6379 1초 간격으로 조회                             |                                                 |\n| redis-stat 1 10                                | localhost:6379 1초 간격으로 10회 조회                        |                                                 |\n| redis-stat --verbose                           | localhost:6379 2초 간격으로 보여주기                         |                                                 |\n| redis-stat 192.168.0.2:6379 192.168.0.2:6380 5 | 192.168.0.2:6379 192.168.0.2:6380서버를 5초 간격으로 보여주기 |                                                 |\n| redis-stat --csv=/temp/redis-log.csv           | csv파일 남기기                                               |                                                 |\n| redis-stat --daemon --server 8888              | daemon 모드로 실행 port 8888번으로 접속 시, Web Monitoring mode로 작동 | daemon과 server는 반드시 같이 사용해야하는 옵션 |\n| redis-stat -a (--auth) password                | -a 또는 --auth 옵션을 통해 requirepass 비밀번호 설정         |                                                 |\n\n\n\n## Redis-stat (Console Monitoring)\n\n```sh\n#192.168.137.101 서버의 6379~6381 포트 정보를 조회\nredis-stat 1 -a password1234 \\\n192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381\n```\n\n![redis-stat-1](./redis-stat-1.PNG)\n\n\n\n## Redis-stat (Web Monitoring)\n\n```sh\n\n# CentOs 방화벽 포트 open\nfirewall-cmd --permanent --zone=public --add-port 8888/tcp\nfirewall-cmd --reload\n \n#192.168.137.101 서버의 6379~6381 포트 정보를 조회\nredis-stat 1 -a <requirepass> \\\n192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381 \\\n--daemon --server=8888\n```\n\n\n\n## 192.168.137.104:8888 서버로 접속\n\n![redis-stat-web](./redis-stat-web.PNG)\n\n![redis-stat-web2](./redis-stat-web2.PNG)\n\n\n\n# 아쉬운 점\n\n1. 그 당시의 모니터링만 가능하다. (별도 저장소가 없기 때문) -> 이전 로그를 보기 위해선 CSV 파일을 남기는 것이 최선\n2. 보고자 하는 정보가 적다. 기본적으로 메모리 사용량, Client 수 Key Size정도는 제공을 하지만 다른 툴에서는 더 많은 정보가 제공되는 것 같다.\n\n\n# 참고\n\n* <https://github.com/junegunn/redis-stat>","source":"_posts/2018-12-03-redis-stats.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (9) Redis-stats을 이용한 모니터링\ndate: 2018-12-03 15:04:50\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-12-03-redis-stats\ntypora-copy-images-to: 2018-12-03-redis-stats\n---\n\n# Redis-stats\n\nRedis-stat은 대표적인 `오픈소스 Redis 모니터링 도구`입니다.\n\nRuby 기반으로 동작하는 프로그램이며, Ruby만 설치되어 있다면 설치가 간편하고 Web 또는 Console로 Redis 서버를 모니터링 할 수 있습니다.\n비슷한 모니터링 도구로 Redmon, RedisLive등이 있지만.. Redis 4이상 버전을 아직 지원하지 않아서 Redis-stat으로 설치 해보게 되었습니다.\n\n\n# Redis-stats 설치하기\n## Install Dependency\n```sh\nyum install -y gcc-c++ patch readline readline-devel zlib zlib-devel openssl-devel make\nyum install -y bzip2 autoconf automake libtool bison iconv-devel sqlite-devel libyaml-devel libffi-devel\n```\n\n\n\n## Install RVM (Ruby Version Manager)\n\n```sh\ncurl -sSL https://rvm.io/mpapis.asc | gpg --import\ncurl -L get.rvm.io | bash -s stable\n```\n\n\n\n## Setup RVM Environment\n\n```sh\nsource /etc/profile.d/rvm.sh\nrvm reload\n```\n\n\n\n## Install Ruby 2.3.3\n\n```sh\nrvm install 2.3.3\n```\n\n\n\n## Set Default Ruby Version\n\n```sh\nrvm list\nrvm use 2.3.3 --default\n```\n\n\n\n## Setup Redis-stat\n\n```sh\ngem install redis-stat\n```\n\n\n\n# Redis-stat 실행하기\n\nRedis-stat은 Web에서 조회하는 방법과 Console에서 조회하는 방법이 있습니다.\n두 가지 형태의 모니터링 방법과 속성에 대해 알아보겠습니다.\n\n\n\n## Redis-stat 옵션\n\n| **명령어**                                     | **설명**                                                     | **비고**                                        |\n| ---------------------------------------------- | ------------------------------------------------------------ | ----------------------------------------------- |\n| redis-stat 1                                   | localhost:6379 1초 간격으로 조회                             |                                                 |\n| redis-stat 1 10                                | localhost:6379 1초 간격으로 10회 조회                        |                                                 |\n| redis-stat --verbose                           | localhost:6379 2초 간격으로 보여주기                         |                                                 |\n| redis-stat 192.168.0.2:6379 192.168.0.2:6380 5 | 192.168.0.2:6379 192.168.0.2:6380서버를 5초 간격으로 보여주기 |                                                 |\n| redis-stat --csv=/temp/redis-log.csv           | csv파일 남기기                                               |                                                 |\n| redis-stat --daemon --server 8888              | daemon 모드로 실행 port 8888번으로 접속 시, Web Monitoring mode로 작동 | daemon과 server는 반드시 같이 사용해야하는 옵션 |\n| redis-stat -a (--auth) password                | -a 또는 --auth 옵션을 통해 requirepass 비밀번호 설정         |                                                 |\n\n\n\n## Redis-stat (Console Monitoring)\n\n```sh\n#192.168.137.101 서버의 6379~6381 포트 정보를 조회\nredis-stat 1 -a password1234 \\\n192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381\n```\n\n![redis-stat-1](./redis-stat-1.PNG)\n\n\n\n## Redis-stat (Web Monitoring)\n\n```sh\n\n# CentOs 방화벽 포트 open\nfirewall-cmd --permanent --zone=public --add-port 8888/tcp\nfirewall-cmd --reload\n \n#192.168.137.101 서버의 6379~6381 포트 정보를 조회\nredis-stat 1 -a <requirepass> \\\n192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381 \\\n--daemon --server=8888\n```\n\n\n\n## 192.168.137.104:8888 서버로 접속\n\n![redis-stat-web](./redis-stat-web.PNG)\n\n![redis-stat-web2](./redis-stat-web2.PNG)\n\n\n\n# 아쉬운 점\n\n1. 그 당시의 모니터링만 가능하다. (별도 저장소가 없기 때문) -> 이전 로그를 보기 위해선 CSV 파일을 남기는 것이 최선\n2. 보고자 하는 정보가 적다. 기본적으로 메모리 사용량, Client 수 Key Size정도는 제공을 하지만 다른 툴에서는 더 많은 정보가 제공되는 것 같다.\n\n\n# 참고\n\n* <https://github.com/junegunn/redis-stat>","slug":"2018-12-03-redis-stats","published":1,"updated":"2018-12-08T08:32:55.318Z","comments":1,"photos":[],"link":"","_id":"cjrgbv2ry000jcr1tokvfqok9","content":"<h1 id=\"redis-stats\">Redis-stats</h1>\n<p>Redis-stat은 대표적인 <code>오픈소스 Redis 모니터링 도구</code>입니다.</p>\n<p>Ruby 기반으로 동작하는 프로그램이며, Ruby만 설치되어 있다면 설치가 간편하고 Web 또는 Console로 Redis 서버를 모니터링 할 수 있습니다.\n비슷한 모니터링 도구로 Redmon, RedisLive등이 있지만.. Redis 4이상 버전을 아직 지원하지 않아서 Redis-stat으로 설치 해보게 되었습니다.</p>\n<h1 id=\"redis-stats-설치하기\">Redis-stats 설치하기</h1>\n<h2 id=\"install-dependency\">Install Dependency</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y gcc-c++ patch readline readline-devel zlib zlib-devel openssl-devel make</span><br><span class=\"line\">yum install -y bzip2 autoconf automake libtool bison iconv-devel sqlite-devel libyaml-devel libffi-devel</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"install-rvm-ruby-version-manager\">Install RVM (Ruby Version Manager)</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -sSL https://rvm.io/mpapis.asc | gpg --import</span><br><span class=\"line\">curl -L get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"setup-rvm-environment\">Setup RVM Environment</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile.d/rvm.sh</span><br><span class=\"line\">rvm reload</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"install-ruby-233\">Install Ruby 2.3.3</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.3.3</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"set-default-ruby-version\">Set Default Ruby Version</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm list</span><br><span class=\"line\">rvm use 2.3.3 --default</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"setup-redis-stat\">Setup Redis-stat</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install redis-stat</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"redis-stat-실행하기\">Redis-stat 실행하기</h1>\n<p>Redis-stat은 Web에서 조회하는 방법과 Console에서 조회하는 방법이 있습니다.\n두 가지 형태의 모니터링 방법과 속성에 대해 알아보겠습니다.</p>\n<h2 id=\"redis-stat-옵션\">Redis-stat 옵션</h2>\n<table>\n<thead>\n<tr>\n<th><strong>명령어</strong></th>\n<th><strong>설명</strong></th>\n<th><strong>비고</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>redis-stat 1</td>\n<td>localhost:6379 1초 간격으로 조회</td>\n<td></td>\n</tr>\n<tr>\n<td>redis-stat 1 10</td>\n<td>localhost:6379 1초 간격으로 10회 조회</td>\n<td></td>\n</tr>\n<tr>\n<td>redis-stat --verbose</td>\n<td>localhost:6379 2초 간격으로 보여주기</td>\n<td></td>\n</tr>\n<tr>\n<td>redis-stat 192.168.0.2:6379 192.168.0.2:6380 5</td>\n<td>192.168.0.2:6379 192.168.0.2:6380서버를 5초 간격으로 보여주기</td>\n<td></td>\n</tr>\n<tr>\n<td>redis-stat --csv=/temp/redis-log.csv</td>\n<td>csv파일 남기기</td>\n<td></td>\n</tr>\n<tr>\n<td>redis-stat --daemon --server 8888</td>\n<td>daemon 모드로 실행 port 8888번으로 접속 시, Web Monitoring mode로 작동</td>\n<td>daemon과 server는 반드시 같이 사용해야하는 옵션</td>\n</tr>\n<tr>\n<td>redis-stat -a (--auth) password</td>\n<td>-a 또는 --auth 옵션을 통해 requirepass 비밀번호 설정</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"redis-stat-console-monitoring\">Redis-stat (Console Monitoring)</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#192.168.137.101 서버의 6379~6381 포트 정보를 조회</span></span><br><span class=\"line\">redis-stat 1 -a password1234 \\</span><br><span class=\"line\">192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./redis-stat-1.PNG\" alt=\"redis-stat-1\"></p>\n<h2 id=\"redis-stat-web-monitoring\">Redis-stat (Web Monitoring)</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CentOs 방화벽 포트 open</span></span><br><span class=\"line\">firewall-cmd --permanent --zone=public --add-port 8888/tcp</span><br><span class=\"line\">firewall-cmd --reload</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#192.168.137.101 서버의 6379~6381 포트 정보를 조회</span></span><br><span class=\"line\">redis-stat 1 -a &lt;requirepass&gt; \\</span><br><span class=\"line\">192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381 \\</span><br><span class=\"line\">--daemon --server=8888</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1921681371048888-서버로-접속\">192.168.137.104:8888 서버로 접속</h2>\n<p><img src=\"./redis-stat-web.PNG\" alt=\"redis-stat-web\"></p>\n<p><img src=\"./redis-stat-web2.PNG\" alt=\"redis-stat-web2\"></p>\n<h1 id=\"아쉬운-점\">아쉬운 점</h1>\n<ol>\n<li>그 당시의 모니터링만 가능하다. (별도 저장소가 없기 때문) -&gt; 이전 로그를 보기 위해선 CSV 파일을 남기는 것이 최선</li>\n<li>보고자 하는 정보가 적다. 기본적으로 메모리 사용량, Client 수 Key Size정도는 제공을 하지만 다른 툴에서는 더 많은 정보가 제공되는 것 같다.</li>\n</ol>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li><a href=\"https://github.com/junegunn/redis-stat\" target=\"_blank\" rel=\"noopener\">https://github.com/junegunn/redis-stat</a></li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>Redis-stats</h1>\n<p>Redis-stat은 대표적인 <code>오픈소스 Redis 모니터링 도구</code>입니다.</p>\n<p>Ruby 기반으로 동작하는 프로그램이며, Ruby만 설치되어 있다면 설치가 간편하고 Web 또는 Console로 Redis 서버를 모니터링 할 수 있습니다.\n비슷한 모니터링 도구로 Redmon, RedisLive등이 있지만.. Redis 4이상 버전을 아직 지원하지 않아서 Redis-stat으로 설치 해보게 되었습니다.</p>\n<h1>Redis-stats 설치하기</h1>\n<h2>Install Dependency</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y gcc-c++ patch readline readline-devel zlib zlib-devel openssl-devel make</span><br><span class=\"line\">yum install -y bzip2 autoconf automake libtool bison iconv-devel sqlite-devel libyaml-devel libffi-devel</span><br></pre></td></tr></table></figure></p>\n<h2>Install RVM (Ruby Version Manager)</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -sSL https://rvm.io/mpapis.asc | gpg --import</span><br><span class=\"line\">curl -L get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure></p>\n<h2>Setup RVM Environment</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile.d/rvm.sh</span><br><span class=\"line\">rvm reload</span><br></pre></td></tr></table></figure></p>\n<h2>Install Ruby 2.3.3</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.3.3</span><br></pre></td></tr></table></figure></p>\n<h2>Set Default Ruby Version</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm list</span><br><span class=\"line\">rvm use 2.3.3 --default</span><br></pre></td></tr></table></figure></p>\n<h2>Setup Redis-stat</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install redis-stat</span><br></pre></td></tr></table></figure></p>\n<h1>Redis-stat 실행하기</h1>\n<p>Redis-stat은 Web에서 조회하는 방법과 Console에서 조회하는 방법이 있습니다.\n두 가지 형태의 모니터링 방법과 속성에 대해 알아보겠습니다.</p>\n<h2>Redis-stat 옵션</h2>\n<table>\n<thead>\n<tr>\n<th><strong>명령어</strong></th>\n<th><strong>설명</strong></th>\n<th><strong>비고</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>redis-stat 1</td>\n<td>localhost:6379 1초 간격으로 조회</td>\n<td></td>\n</tr>\n<tr>\n<td>redis-stat 1 10</td>\n<td>localhost:6379 1초 간격으로 10회 조회</td>\n<td></td>\n</tr>\n<tr>\n<td>redis-stat --verbose</td>\n<td>localhost:6379 2초 간격으로 보여주기</td>\n<td></td>\n</tr>\n<tr>\n<td>redis-stat 192.168.0.2:6379 192.168.0.2:6380 5</td>\n<td>192.168.0.2:6379 192.168.0.2:6380서버를 5초 간격으로 보여주기</td>\n<td></td>\n</tr>\n<tr>\n<td>redis-stat --csv=/temp/redis-log.csv</td>\n<td>csv파일 남기기</td>\n<td></td>\n</tr>\n<tr>\n<td>redis-stat --daemon --server 8888</td>\n<td>daemon 모드로 실행 port 8888번으로 접속 시, Web Monitoring mode로 작동</td>\n<td>daemon과 server는 반드시 같이 사용해야하는 옵션</td>\n</tr>\n<tr>\n<td>redis-stat -a (--auth) password</td>\n<td>-a 또는 --auth 옵션을 통해 requirepass 비밀번호 설정</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2>Redis-stat (Console Monitoring)</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#192.168.137.101 서버의 6379~6381 포트 정보를 조회</span></span><br><span class=\"line\">redis-stat 1 -a password1234 \\</span><br><span class=\"line\">192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./redis-stat-1.PNG\" alt=\"redis-stat-1\"></p>\n<h2>Redis-stat (Web Monitoring)</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CentOs 방화벽 포트 open</span></span><br><span class=\"line\">firewall-cmd --permanent --zone=public --add-port 8888/tcp</span><br><span class=\"line\">firewall-cmd --reload</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#192.168.137.101 서버의 6379~6381 포트 정보를 조회</span></span><br><span class=\"line\">redis-stat 1 -a &lt;requirepass&gt; \\</span><br><span class=\"line\">192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381 \\</span><br><span class=\"line\">--daemon --server=8888</span><br></pre></td></tr></table></figure></p>\n<h2>192.168.137.104:8888 서버로 접속</h2>\n<p><img src=\"./redis-stat-web.PNG\" alt=\"redis-stat-web\"></p>\n<p><img src=\"./redis-stat-web2.PNG\" alt=\"redis-stat-web2\"></p>\n<h1>아쉬운 점</h1>\n<ol>\n<li>그 당시의 모니터링만 가능하다. (별도 저장소가 없기 때문) -&gt; 이전 로그를 보기 위해선 CSV 파일을 남기는 것이 최선</li>\n<li>보고자 하는 정보가 적다. 기본적으로 메모리 사용량, Client 수 Key Size정도는 제공을 하지만 다른 툴에서는 더 많은 정보가 제공되는 것 같다.</li>\n</ol>\n<h1>참고</h1>\n<ul>\n<li><a href=\"https://github.com/junegunn/redis-stat\" target=\"_blank\" rel=\"noopener\">https://github.com/junegunn/redis-stat</a></li>\n</ul>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (11) Redis-Cli Docker로 사용하기","date":"2018-12-07T12:08:14.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-12-07-docker-11","typora-copy-images-to":"2018-12-07-docker-11","_content":"\n# 들어가며\n\nRedis를 운영하다 보면 redis-cli를 주로 사용하게 되는데\n항상 docker exec 명령을 통해 docker container 내의 redis-cli를 사용하여 불편한 점이 많았습니다.\n\n찾아보니 간단하게 Docker로 Redis-cli를 사용할 방법이 있어 기록을 남기게 되었습니다.\n\n\n\n# Docker로 Redis-cli 접속하기\n\n```sh\nsudo docker run -it \\                                  \n                --rm \\ \n                --net host \\ \n                redis:5.0.0-alpine redis-cli \\\n                -a \"<password>\" \\\n                -p <port>\n```\n\n* it 옵션 : container와 conversation이 가능한 옵션\n* rm옵션 : container가 종료되면 container를 삭제\n* net옵션 : network 옵션 \n* redis:5.0.0-alpine redis-cli : redis:5.0.0-alpine이미지의 redis-cli를 사용\n* a 옵션 : redis에서 requirepass를 사용하는 경우 password를 적어준다.\n* p 옵션 : 접속 port\n* h 옵션 : 접속하고자 하는 host (옵션 안주면 127.0.0.1로 접속한다)\n\n\n\n# Docker Redis-cli로 cluster 설정하기\n\n```sh\nsudo docker run -it \\                                  \n                --rm \\ \n                --net host \\ \n                redis:5.0.0-alpine redis-cli \\\n                -a \"<password>\"\n                --cluster create host:port host:port host:port  \\  //master host&port\n                 host:port host:port host:port \\ //slave host&port\n                --cluster-replicas 1 \n```\n\n* --cluster : cluster mode 명령어 수행\n* create : cluster 생성 명령\n* --cluster-replicas 1 : Redis Replication 명령, Master node 1개당 Slave node 1개를 의미","source":"_posts/2018-12-07-docker-11.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (11) redis-cli Docker로 사용하기\ndate: 2018-12-07 21:08:14\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-12-07-docker-11\ntypora-copy-images-to: 2018-12-07-docker-11\n---\n\n# 들어가며\n\nRedis를 운영하다 보면 redis-cli를 주로 사용하게 되는데\n항상 docker exec 명령을 통해 docker container 내의 redis-cli를 사용하여 불편한 점이 많았습니다.\n\n찾아보니 간단하게 Docker로 Redis-cli를 사용할 방법이 있어 기록을 남기게 되었습니다.\n\n\n\n# Docker로 Redis-cli 접속하기\n\n```sh\nsudo docker run -it \\                                  \n                --rm \\ \n                --net host \\ \n                redis:5.0.0-alpine redis-cli \\\n                -a \"<password>\" \\\n                -p <port>\n```\n\n* it 옵션 : container와 conversation이 가능한 옵션\n* rm옵션 : container가 종료되면 container를 삭제\n* net옵션 : network 옵션 \n* redis:5.0.0-alpine redis-cli : redis:5.0.0-alpine이미지의 redis-cli를 사용\n* a 옵션 : redis에서 requirepass를 사용하는 경우 password를 적어준다.\n* p 옵션 : 접속 port\n* h 옵션 : 접속하고자 하는 host (옵션 안주면 127.0.0.1로 접속한다)\n\n\n\n# Docker Redis-cli로 cluster 설정하기\n\n```sh\nsudo docker run -it \\                                  \n                --rm \\ \n                --net host \\ \n                redis:5.0.0-alpine redis-cli \\\n                -a \"<password>\"\n                --cluster create host:port host:port host:port  \\  //master host&port\n                 host:port host:port host:port \\ //slave host&port\n                --cluster-replicas 1 \n```\n\n* --cluster : cluster mode 명령어 수행\n* create : cluster 생성 명령\n* --cluster-replicas 1 : Redis Replication 명령, Master node 1개당 Slave node 1개를 의미","slug":"2018-12-07-docker-11","published":1,"updated":"2018-12-08T08:32:55.323Z","comments":1,"photos":[],"link":"","_id":"cjrgbv2rz000kcr1tcxo6jk01","content":"<h1 id=\"들어가며\">들어가며</h1>\n<p>Redis를 운영하다 보면 redis-cli를 주로 사용하게 되는데\n항상 docker exec 명령을 통해 docker container 내의 redis-cli를 사용하여 불편한 점이 많았습니다.</p>\n<p>찾아보니 간단하게 Docker로 Redis-cli를 사용할 방법이 있어 기록을 남기게 되었습니다.</p>\n<h1 id=\"docker로-redis-cli-접속하기\">Docker로 Redis-cli 접속하기</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -it \\                                  </span><br><span class=\"line\">                --rm \\ </span><br><span class=\"line\">                --net host \\ </span><br><span class=\"line\">                redis:5.0.0-alpine redis-cli \\</span><br><span class=\"line\">                -a <span class=\"string\">\"&lt;password&gt;\"</span> \\</span><br><span class=\"line\">                -p &lt;port&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>it 옵션 : container와 conversation이 가능한 옵션</li>\n<li>rm옵션 : container가 종료되면 container를 삭제</li>\n<li>net옵션 : network 옵션</li>\n<li>redis:5.0.0-alpine redis-cli : redis:5.0.0-alpine이미지의 redis-cli를 사용</li>\n<li>a 옵션 : redis에서 requirepass를 사용하는 경우 password를 적어준다.</li>\n<li>p 옵션 : 접속 port</li>\n<li>h 옵션 : 접속하고자 하는 host (옵션 안주면 127.0.0.1로 접속한다)</li>\n</ul>\n<h1 id=\"docker-redis-cli로-cluster-설정하기\">Docker Redis-cli로 cluster 설정하기</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -it \\                                  </span><br><span class=\"line\">                --rm \\ </span><br><span class=\"line\">                --net host \\ </span><br><span class=\"line\">                redis:5.0.0-alpine redis-cli \\</span><br><span class=\"line\">                -a <span class=\"string\">\"&lt;password&gt;\"</span></span><br><span class=\"line\">                --cluster create host:port host:port host:port  \\  //master host&amp;port</span><br><span class=\"line\">                 host:port host:port host:port \\ //slave host&amp;port</span><br><span class=\"line\">                --cluster-replicas 1</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>--cluster : cluster mode 명령어 수행</li>\n<li>create : cluster 생성 명령</li>\n<li>--cluster-replicas 1 : Redis Replication 명령, Master node 1개당 Slave node 1개를 의미</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>Redis를 운영하다 보면 redis-cli를 주로 사용하게 되는데\n항상 docker exec 명령을 통해 docker container 내의 redis-cli를 사용하여 불편한 점이 많았습니다.</p>\n<p>찾아보니 간단하게 Docker로 Redis-cli를 사용할 방법이 있어 기록을 남기게 되었습니다.</p>\n<h1>Docker로 Redis-cli 접속하기</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -it \\                                  </span><br><span class=\"line\">                --rm \\ </span><br><span class=\"line\">                --net host \\ </span><br><span class=\"line\">                redis:5.0.0-alpine redis-cli \\</span><br><span class=\"line\">                -a <span class=\"string\">\"&lt;password&gt;\"</span> \\</span><br><span class=\"line\">                -p &lt;port&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>it 옵션 : container와 conversation이 가능한 옵션</li>\n<li>rm옵션 : container가 종료되면 container를 삭제</li>\n<li>net옵션 : network 옵션</li>\n<li>redis:5.0.0-alpine redis-cli : redis:5.0.0-alpine이미지의 redis-cli를 사용</li>\n<li>a 옵션 : redis에서 requirepass를 사용하는 경우 password를 적어준다.</li>\n<li>p 옵션 : 접속 port</li>\n<li>h 옵션 : 접속하고자 하는 host (옵션 안주면 127.0.0.1로 접속한다)</li>\n</ul>\n<h1>Docker Redis-cli로 cluster 설정하기</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -it \\                                  </span><br><span class=\"line\">                --rm \\ </span><br><span class=\"line\">                --net host \\ </span><br><span class=\"line\">                redis:5.0.0-alpine redis-cli \\</span><br><span class=\"line\">                -a <span class=\"string\">\"&lt;password&gt;\"</span></span><br><span class=\"line\">                --cluster create host:port host:port host:port  \\  //master host&amp;port</span><br><span class=\"line\">                 host:port host:port host:port \\ //slave host&amp;port</span><br><span class=\"line\">                --cluster-replicas 1</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>--cluster : cluster mode 명령어 수행</li>\n<li>create : cluster 생성 명령</li>\n<li>--cluster-replicas 1 : Redis Replication 명령, Master node 1개당 Slave node 1개를 의미</li>\n</ul>\n"},{"title":"Mybatis 조회 시, All Element Are Null 이슈","catalog":true,"Categories":["Spring","Mybatis"],"typora-root-url":"2018-12-30-mybatis-returnInstanceForEmptyRow","typora-copy-images-to":"2018-12-30-mybatis-returnInstanceForEmptyRow","date":"2018-12-30T05:55:24.000Z","subtitle":null,"header-img":null,"_content":"\n# 들어가며\n사내 시스템 운영 중, SMS를 전송해 주는 부분에서 장애가 발생 하였다.  \n어디에선가 NullPointer Exception이 발생하고 있었다. stacktrace기준으로 추적해 보니,\nMybatis를 통해 데이터를 조회 한다음 데이터를 가공하는 과정에서 NullPointerException이 발생하고 있었다.  \n일단 디버깅 이전에 코드를 봤다. 아무리 생각해도 null이 발생하지 않을 것 같았다.\n\n실제 코드를 돌려보았다.\n![all_elememt_are_null 에러](./all_element_are_null.png)\n\n이 메세지는 무엇?  \n구글에 검색해 보니 List내의 모든 Element의 reference가 null인 것이었다.  \n그래서 size는 있지만, 가르키는 instance가 없기 때문에 Nullpointer Exception이 발생하고 있었다.\n\n일단은 조회된 모든 컬럼이 null이면 mybatis에는 null을 리턴해 주는건가? 라는 심증만 가지고\n절대 null이 될 수 없는 id 컬럼을 조회컬럼에 추가해 주었다.  \n(쿼리내에 outer join의 여파로 null만 나오는 쿼리였다.)  \n일단은 id 컬럼을 추가 해주니, 정상적으로 id만 값이 있고 다른 property는 모두 null인 객체가 생성되었다.  \n일단 이렇게 이슈를 종료하고자 했지만, 너무 찝찝했다\n\n아니 왜? 모든 컬럼이 null이면 왜 객체 생성을 안하지? 우리가 원하는건 null이 아닐텐데...  \n하물며 이런상황에 앞서 조회된 내용에 대해 null 체크를 할 생각을 하니 끔찍했다.\n\n분명 설정이 있으리라 생각하고 mybatis 사이트를 뒤져보았다.\n뒤져보니 요런게 있었다.\n\n## returnInstanceForEmptyRow\n>\tMyBatis, by default, returns null when all the columns of a returned row are NULL. When this setting is enabled, MyBatis returns an empty instance instead. Note that it is also applied to nested results (i.e. collectioin and association). Since: 3.4.2\n\n한 마디로 mybatis option중에는 `returnInstanceForEmptyRow` 이란 옵션이 있는데, 모든 컬럼이 null이면 row를 null로 리턴해 준단다. (이런 ㅡㅡ)  \n근데 설정 옵션이 true이면 null 대신에 모든 값이 null인 인스턴스를 반환해주고 false이면 null을 반환해 준다고 한다.  \n하지만 default옵션이 false이기 때문에 아무 설정도 안한 회사소스에서는 당연히 null이 리턴되게 된다.  \n`이 옵션은 mybatis 3.4.2부터 지원한다` (회사에서는 mybatis/3.4.2이상 버전을 사용하고 있다.)\n\n# Test 코드\n\n테스트 환경은 아래와 같이 설정해 보았다\n* Spring Boot\n* Mybatis\n* H2DB\n\n## 환경 설정\n\npom.xml\n```xml\n<!-- MyBatis -->\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>1.3.2</version>\n</dependency>\n\n<dependency>\n    <groupId>com.h2database</groupId>\n    <artifactId>h2</artifactId>\n    <scope>runtime</scope>\n</dependency>\n\n<dependency>\n    <groupId>org.hsqldb</groupId>\n    <artifactId>hsqldb</artifactId>\n</dependency>\n```\n\napplication.properties\n```properties\n#Datasource\nspring.datasource.url=jdbc:h2:mem:test\nspring.datasource.initialization-mode=always\nspring.datasource.username=sa\nspring.datasource.password=\nspring.datasource.driver-class-name=org.h2.Driver\n\n#h2 setting\nspring.h2.console.enabled=true\nspring.h2.console.path=/h2-console\n\n# Mybatis Setting\nmybatis.mapper-locations=classpath*:mapper/**/*SqlMap.xml\nmybatis.configuration.map-underscore-to-camel-case=true\nmybatis.configuration.return-instance-for-empty-row=false\n```\n\nschema.sql\n```sql\nCREATE TABLE test (\n    id INTEGER AUTO_INCREMENT primary key NOT NULL,\n    name VARCHAR(30),\n    description VARCHAR(255),\n);\n```\n\ndata.sql\n```sql\nINSERT INTO test(id, name, description) values (1, NULL, NULL);\n```\n\nTestRepository.java\n```java\n@Mapper\n@Repository\npublic interface TestRepository {\n\n    List<TestDTO> getTestAll();\n}\n```\nTestSqlMap.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.example.springstudy.demo6.TestRepository\">\n    <select id=\"getTestAll\" resultType=\"com.example.springstudy.demo6.TestDTO\">\n        select name, description from test\n    </select>\n</mapper>\n```\n\nMybatisConfig.java\n```java\n@Configuration\n@MapperScan(basePackages = \"com.example.springstudy.demo6\")\npublic class MybatisConfig {\n}\n```\n\n\n## Test Case\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class MybatisTest {\n\n    @Autowired\n    private SqlSessionFactoryBean sqlSessionFactoryBean;\n\n    @TestConfiguration\n    public static class TestContext {\n\n        @Bean\n        public DataSource dataSource() {\n            return new EmbeddedDatabaseBuilder()\n                    .setType(EmbeddedDatabaseType.H2)\n                    .addDefaultScripts()\n                    .build();\n        }\n\n        @Bean\n        public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) throws Exception {\n            SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();\n            sqlSessionFactoryBean.setDataSource(dataSource);\n            sqlSessionFactoryBean.getObject()\n            \t\t         .getConfiguration()\n                                 .setMapUnderscoreToCamelCase(true);\n                                 \n            sqlSessionFactoryBean.setMapperLocations(new ClassPathResource[]{new ClassPathResource(\"mapper/TestSqlMap.xml\")});\n            return sqlSessionFactoryBean;\n        }\n    }\n\n    /**\n     * returnInstanceForEmptyRow 설정이 false일때,\n     * 모든 컬럼의 데이터가 null인 경우, List내의 항목이 null이 되는 경우 테스트\n     * @throws Exception\n     */\n    @Test\n    public void all_element_null_test_returnInstanceForEmptyRow_false() throws Exception {\n\n        sqlSessionFactoryBean.getObject()\n                             .getConfiguration()\n                             .setReturnInstanceForEmptyRow(false);\n\n        List<TestDTO> tests = sqlSessionFactoryBean.getObject()\n                .openSession()\n                .getMapper(TestRepository.class)\n                .getTestAll();\n\n\t//모든 항목이 null인 경우, List내의 Element가 null이 되므로 제거 된다\n        tests.removeIf(Objects::isNull);\n        assertThat(tests).isEmpty();\n    }\n\n    /**\n     * returnInstanceForEmptyRow 설정이 true일때,\n     * 모든 컬럼의 데이터가 null인 경우, 모든 property가 null인 인스턴스가 생성되는지에 대한 테스트\n     * @throws Exception\n     */\n    @Test\n    public void all_element_null_test_returnInstanceForEmptyRow_true() throws Exception {\n\n        sqlSessionFactoryBean.getObject()\n                             .getConfiguration()\n                             .setReturnInstanceForEmptyRow(true);\n\n        List<TestDTO> tests = sqlSessionFactoryBean.getObject()\n                .openSession()\n                .getMapper(TestRepository.class)\n                .getTestAll();\n\n        //모든 항목이 null인 경우, List내의 Element가 Empty 인스턴스를 가르키므로\n        //제거되지 않는다.\n        tests.removeIf(Objects::isNull);\n        assertThat(tests).isNotEmpty();\n    }\n}\n```\n\n테스트 코드 실행 결과 returnInstanceForEmptyRow = true로 설정 할 경우, empty 객체가 나와 내가 생각한 대로 사용할 수 있게 되었다.\n\n# returnInstanceForEmptyRow 옵션 설정 방법\n## mybatisConfig.xml\n```xml\n<configuration>\n\t<settings>\n\t\t<setting name=\"returnInstanceForEmptyRow\" value=\"true\"/>\n\t</settings>\n</configurtion>\n```\n## application.properties\n```properties\nmybatis.configuration.return-instance-for-empty-row=true\n```\n# 참고\n* http://www.mybatis.org/mybatis-3/configuration.html\n\n","source":"_posts/2018-12-30-mybatis-returnInstanceForEmptyRow.md","raw":"---\ntitle: Mybatis 조회 시, All element are null 이슈\ncatalog: true\nCategories:\n  - Spring\n  - Mybatis\ntags:\n  - Spring\n  - Mybatis\ntypora-root-url: 2018-12-30-mybatis-returnInstanceForEmptyRow\ntypora-copy-images-to: 2018-12-30-mybatis-returnInstanceForEmptyRow\ndate: 2018-12-30 14:55:24\nsubtitle:\nheader-img:\n---\n\n# 들어가며\n사내 시스템 운영 중, SMS를 전송해 주는 부분에서 장애가 발생 하였다.  \n어디에선가 NullPointer Exception이 발생하고 있었다. stacktrace기준으로 추적해 보니,\nMybatis를 통해 데이터를 조회 한다음 데이터를 가공하는 과정에서 NullPointerException이 발생하고 있었다.  \n일단 디버깅 이전에 코드를 봤다. 아무리 생각해도 null이 발생하지 않을 것 같았다.\n\n실제 코드를 돌려보았다.\n![all_elememt_are_null 에러](./all_element_are_null.png)\n\n이 메세지는 무엇?  \n구글에 검색해 보니 List내의 모든 Element의 reference가 null인 것이었다.  \n그래서 size는 있지만, 가르키는 instance가 없기 때문에 Nullpointer Exception이 발생하고 있었다.\n\n일단은 조회된 모든 컬럼이 null이면 mybatis에는 null을 리턴해 주는건가? 라는 심증만 가지고\n절대 null이 될 수 없는 id 컬럼을 조회컬럼에 추가해 주었다.  \n(쿼리내에 outer join의 여파로 null만 나오는 쿼리였다.)  \n일단은 id 컬럼을 추가 해주니, 정상적으로 id만 값이 있고 다른 property는 모두 null인 객체가 생성되었다.  \n일단 이렇게 이슈를 종료하고자 했지만, 너무 찝찝했다\n\n아니 왜? 모든 컬럼이 null이면 왜 객체 생성을 안하지? 우리가 원하는건 null이 아닐텐데...  \n하물며 이런상황에 앞서 조회된 내용에 대해 null 체크를 할 생각을 하니 끔찍했다.\n\n분명 설정이 있으리라 생각하고 mybatis 사이트를 뒤져보았다.\n뒤져보니 요런게 있었다.\n\n## returnInstanceForEmptyRow\n>\tMyBatis, by default, returns null when all the columns of a returned row are NULL. When this setting is enabled, MyBatis returns an empty instance instead. Note that it is also applied to nested results (i.e. collectioin and association). Since: 3.4.2\n\n한 마디로 mybatis option중에는 `returnInstanceForEmptyRow` 이란 옵션이 있는데, 모든 컬럼이 null이면 row를 null로 리턴해 준단다. (이런 ㅡㅡ)  \n근데 설정 옵션이 true이면 null 대신에 모든 값이 null인 인스턴스를 반환해주고 false이면 null을 반환해 준다고 한다.  \n하지만 default옵션이 false이기 때문에 아무 설정도 안한 회사소스에서는 당연히 null이 리턴되게 된다.  \n`이 옵션은 mybatis 3.4.2부터 지원한다` (회사에서는 mybatis/3.4.2이상 버전을 사용하고 있다.)\n\n# Test 코드\n\n테스트 환경은 아래와 같이 설정해 보았다\n* Spring Boot\n* Mybatis\n* H2DB\n\n## 환경 설정\n\npom.xml\n```xml\n<!-- MyBatis -->\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>1.3.2</version>\n</dependency>\n\n<dependency>\n    <groupId>com.h2database</groupId>\n    <artifactId>h2</artifactId>\n    <scope>runtime</scope>\n</dependency>\n\n<dependency>\n    <groupId>org.hsqldb</groupId>\n    <artifactId>hsqldb</artifactId>\n</dependency>\n```\n\napplication.properties\n```properties\n#Datasource\nspring.datasource.url=jdbc:h2:mem:test\nspring.datasource.initialization-mode=always\nspring.datasource.username=sa\nspring.datasource.password=\nspring.datasource.driver-class-name=org.h2.Driver\n\n#h2 setting\nspring.h2.console.enabled=true\nspring.h2.console.path=/h2-console\n\n# Mybatis Setting\nmybatis.mapper-locations=classpath*:mapper/**/*SqlMap.xml\nmybatis.configuration.map-underscore-to-camel-case=true\nmybatis.configuration.return-instance-for-empty-row=false\n```\n\nschema.sql\n```sql\nCREATE TABLE test (\n    id INTEGER AUTO_INCREMENT primary key NOT NULL,\n    name VARCHAR(30),\n    description VARCHAR(255),\n);\n```\n\ndata.sql\n```sql\nINSERT INTO test(id, name, description) values (1, NULL, NULL);\n```\n\nTestRepository.java\n```java\n@Mapper\n@Repository\npublic interface TestRepository {\n\n    List<TestDTO> getTestAll();\n}\n```\nTestSqlMap.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.example.springstudy.demo6.TestRepository\">\n    <select id=\"getTestAll\" resultType=\"com.example.springstudy.demo6.TestDTO\">\n        select name, description from test\n    </select>\n</mapper>\n```\n\nMybatisConfig.java\n```java\n@Configuration\n@MapperScan(basePackages = \"com.example.springstudy.demo6\")\npublic class MybatisConfig {\n}\n```\n\n\n## Test Case\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class MybatisTest {\n\n    @Autowired\n    private SqlSessionFactoryBean sqlSessionFactoryBean;\n\n    @TestConfiguration\n    public static class TestContext {\n\n        @Bean\n        public DataSource dataSource() {\n            return new EmbeddedDatabaseBuilder()\n                    .setType(EmbeddedDatabaseType.H2)\n                    .addDefaultScripts()\n                    .build();\n        }\n\n        @Bean\n        public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) throws Exception {\n            SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();\n            sqlSessionFactoryBean.setDataSource(dataSource);\n            sqlSessionFactoryBean.getObject()\n            \t\t         .getConfiguration()\n                                 .setMapUnderscoreToCamelCase(true);\n                                 \n            sqlSessionFactoryBean.setMapperLocations(new ClassPathResource[]{new ClassPathResource(\"mapper/TestSqlMap.xml\")});\n            return sqlSessionFactoryBean;\n        }\n    }\n\n    /**\n     * returnInstanceForEmptyRow 설정이 false일때,\n     * 모든 컬럼의 데이터가 null인 경우, List내의 항목이 null이 되는 경우 테스트\n     * @throws Exception\n     */\n    @Test\n    public void all_element_null_test_returnInstanceForEmptyRow_false() throws Exception {\n\n        sqlSessionFactoryBean.getObject()\n                             .getConfiguration()\n                             .setReturnInstanceForEmptyRow(false);\n\n        List<TestDTO> tests = sqlSessionFactoryBean.getObject()\n                .openSession()\n                .getMapper(TestRepository.class)\n                .getTestAll();\n\n\t//모든 항목이 null인 경우, List내의 Element가 null이 되므로 제거 된다\n        tests.removeIf(Objects::isNull);\n        assertThat(tests).isEmpty();\n    }\n\n    /**\n     * returnInstanceForEmptyRow 설정이 true일때,\n     * 모든 컬럼의 데이터가 null인 경우, 모든 property가 null인 인스턴스가 생성되는지에 대한 테스트\n     * @throws Exception\n     */\n    @Test\n    public void all_element_null_test_returnInstanceForEmptyRow_true() throws Exception {\n\n        sqlSessionFactoryBean.getObject()\n                             .getConfiguration()\n                             .setReturnInstanceForEmptyRow(true);\n\n        List<TestDTO> tests = sqlSessionFactoryBean.getObject()\n                .openSession()\n                .getMapper(TestRepository.class)\n                .getTestAll();\n\n        //모든 항목이 null인 경우, List내의 Element가 Empty 인스턴스를 가르키므로\n        //제거되지 않는다.\n        tests.removeIf(Objects::isNull);\n        assertThat(tests).isNotEmpty();\n    }\n}\n```\n\n테스트 코드 실행 결과 returnInstanceForEmptyRow = true로 설정 할 경우, empty 객체가 나와 내가 생각한 대로 사용할 수 있게 되었다.\n\n# returnInstanceForEmptyRow 옵션 설정 방법\n## mybatisConfig.xml\n```xml\n<configuration>\n\t<settings>\n\t\t<setting name=\"returnInstanceForEmptyRow\" value=\"true\"/>\n\t</settings>\n</configurtion>\n```\n## application.properties\n```properties\nmybatis.configuration.return-instance-for-empty-row=true\n```\n# 참고\n* http://www.mybatis.org/mybatis-3/configuration.html\n\n","slug":"2018-12-30-mybatis-returnInstanceForEmptyRow","published":1,"updated":"2018-12-30T08:14:01.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2s0000mcr1tdmkqo6xp","content":"<h1 id=\"들어가며\">들어가며</h1>\n<p>사내 시스템 운영 중, SMS를 전송해 주는 부분에서 장애가 발생 하였다.<br>\n어디에선가 NullPointer Exception이 발생하고 있었다. stacktrace기준으로 추적해 보니,\nMybatis를 통해 데이터를 조회 한다음 데이터를 가공하는 과정에서 NullPointerException이 발생하고 있었다.<br>\n일단 디버깅 이전에 코드를 봤다. 아무리 생각해도 null이 발생하지 않을 것 같았다.</p>\n<p>실제 코드를 돌려보았다.\n<img src=\"./all_element_are_null.png\" alt=\"all_elememt_are_null 에러\"></p>\n<p>이 메세지는 무엇?<br>\n구글에 검색해 보니 List내의 모든 Element의 reference가 null인 것이었다.<br>\n그래서 size는 있지만, 가르키는 instance가 없기 때문에 Nullpointer Exception이 발생하고 있었다.</p>\n<p>일단은 조회된 모든 컬럼이 null이면 mybatis에는 null을 리턴해 주는건가? 라는 심증만 가지고\n절대 null이 될 수 없는 id 컬럼을 조회컬럼에 추가해 주었다.<br>\n(쿼리내에 outer join의 여파로 null만 나오는 쿼리였다.)<br>\n일단은 id 컬럼을 추가 해주니, 정상적으로 id만 값이 있고 다른 property는 모두 null인 객체가 생성되었다.<br>\n일단 이렇게 이슈를 종료하고자 했지만, 너무 찝찝했다</p>\n<p>아니 왜? 모든 컬럼이 null이면 왜 객체 생성을 안하지? 우리가 원하는건 null이 아닐텐데...<br>\n하물며 이런상황에 앞서 조회된 내용에 대해 null 체크를 할 생각을 하니 끔찍했다.</p>\n<p>분명 설정이 있으리라 생각하고 mybatis 사이트를 뒤져보았다.\n뒤져보니 요런게 있었다.</p>\n<h2 id=\"returninstanceforemptyrow\">returnInstanceForEmptyRow</h2>\n<blockquote>\n<p>MyBatis, by default, returns null when all the columns of a returned row are NULL. When this setting is enabled, MyBatis returns an empty instance instead. Note that it is also applied to nested results (i.e. collectioin and association). Since: 3.4.2</p>\n</blockquote>\n<p>한 마디로 mybatis option중에는 <code>returnInstanceForEmptyRow</code> 이란 옵션이 있는데, 모든 컬럼이 null이면 row를 null로 리턴해 준단다. (이런 ㅡㅡ)<br>\n근데 설정 옵션이 true이면 null 대신에 모든 값이 null인 인스턴스를 반환해주고 false이면 null을 반환해 준다고 한다.<br>\n하지만 default옵션이 false이기 때문에 아무 설정도 안한 회사소스에서는 당연히 null이 리턴되게 된다.<br>\n<code>이 옵션은 mybatis 3.4.2부터 지원한다</code> (회사에서는 mybatis/3.4.2이상 버전을 사용하고 있다.)</p>\n<h1 id=\"test-코드\">Test 코드</h1>\n<p>테스트 환경은 아래와 같이 설정해 보았다</p>\n<ul>\n<li>Spring Boot</li>\n<li>Mybatis</li>\n<li>H2DB</li>\n</ul>\n<h2 id=\"환경-설정\">환경 설정</h2>\n<p>pom.xml\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- MyBatis --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.spring.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.h2database<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>h2<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.hsqldb<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>hsqldb<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>application.properties\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#Datasource</span><br><span class=\"line\">spring.datasource.url=jdbc:h2:mem:test</span><br><span class=\"line\">spring.datasource.initialization-mode=always</span><br><span class=\"line\">spring.datasource.username=sa</span><br><span class=\"line\">spring.datasource.password=</span><br><span class=\"line\">spring.datasource.driver-class-name=org.h2.Driver</span><br><span class=\"line\"></span><br><span class=\"line\">#h2 setting</span><br><span class=\"line\">spring.h2.console.enabled=true</span><br><span class=\"line\">spring.h2.console.path=/h2-console</span><br><span class=\"line\"></span><br><span class=\"line\"># Mybatis Setting</span><br><span class=\"line\">mybatis.mapper-locations=classpath*:mapper/**/*SqlMap.xml</span><br><span class=\"line\">mybatis.configuration.map-underscore-to-camel-case=true</span><br><span class=\"line\">mybatis.configuration.return-instance-for-empty-row=false</span><br></pre></td></tr></table></figure></p>\n<p>schema.sql\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">test</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">INTEGER</span> AUTO_INCREMENT primary <span class=\"keyword\">key</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>),</span><br><span class=\"line\">    description <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>data.sql\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">test</span>(<span class=\"keyword\">id</span>, <span class=\"keyword\">name</span>, description) <span class=\"keyword\">values</span> (<span class=\"number\">1</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure></p>\n<p>TestRepository.java\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestRepository</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">List&lt;TestDTO&gt; <span class=\"title\">getTestAll</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>TestSqlMap.xml\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"com.example.springstudy.demo6.TestRepository\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"getTestAll\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.example.springstudy.demo6.TestDTO\"</span>&gt;</span></span><br><span class=\"line\">        select name, description from test</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>MybatisConfig.java\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@MapperScan</span>(basePackages = <span class=\"string\">\"com.example.springstudy.demo6\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MybatisConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"test-case\">Test Case</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MybatisTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SqlSessionFactoryBean sqlSessionFactoryBean;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@TestConfiguration</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestContext</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Bean</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EmbeddedDatabaseBuilder()</span><br><span class=\"line\">                    .setType(EmbeddedDatabaseType.H2)</span><br><span class=\"line\">                    .addDefaultScripts()</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Bean</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactoryBean <span class=\"title\">sqlSessionFactoryBean</span><span class=\"params\">(DataSource dataSource)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            SqlSessionFactoryBean sqlSessionFactoryBean = <span class=\"keyword\">new</span> SqlSessionFactoryBean();</span><br><span class=\"line\">            sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class=\"line\">            sqlSessionFactoryBean.getObject()</span><br><span class=\"line\">            \t\t         .getConfiguration()</span><br><span class=\"line\">                                 .setMapUnderscoreToCamelCase(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                                 </span><br><span class=\"line\">            sqlSessionFactoryBean.setMapperLocations(<span class=\"keyword\">new</span> ClassPathResource[]&#123;<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">\"mapper/TestSqlMap.xml\"</span>)&#125;);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sqlSessionFactoryBean;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * returnInstanceForEmptyRow 설정이 false일때,</span></span><br><span class=\"line\"><span class=\"comment\">     * 모든 컬럼의 데이터가 null인 경우, List내의 항목이 null이 되는 경우 테스트</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">all_element_null_test_returnInstanceForEmptyRow_false</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        sqlSessionFactoryBean.getObject()</span><br><span class=\"line\">                             .getConfiguration()</span><br><span class=\"line\">                             .setReturnInstanceForEmptyRow(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;TestDTO&gt; tests = sqlSessionFactoryBean.getObject()</span><br><span class=\"line\">                .openSession()</span><br><span class=\"line\">                .getMapper(TestRepository.class)</span><br><span class=\"line\">                .getTestAll();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//모든 항목이 null인 경우, List내의 Element가 null이 되므로 제거 된다</span></span><br><span class=\"line\">        tests.removeIf(Objects::isNull);</span><br><span class=\"line\">        assertThat(tests).isEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * returnInstanceForEmptyRow 설정이 true일때,</span></span><br><span class=\"line\"><span class=\"comment\">     * 모든 컬럼의 데이터가 null인 경우, 모든 property가 null인 인스턴스가 생성되는지에 대한 테스트</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">all_element_null_test_returnInstanceForEmptyRow_true</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        sqlSessionFactoryBean.getObject()</span><br><span class=\"line\">                             .getConfiguration()</span><br><span class=\"line\">                             .setReturnInstanceForEmptyRow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;TestDTO&gt; tests = sqlSessionFactoryBean.getObject()</span><br><span class=\"line\">                .openSession()</span><br><span class=\"line\">                .getMapper(TestRepository.class)</span><br><span class=\"line\">                .getTestAll();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//모든 항목이 null인 경우, List내의 Element가 Empty 인스턴스를 가르키므로</span></span><br><span class=\"line\">        <span class=\"comment\">//제거되지 않는다.</span></span><br><span class=\"line\">        tests.removeIf(Objects::isNull);</span><br><span class=\"line\">        assertThat(tests).isNotEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>테스트 코드 실행 결과 returnInstanceForEmptyRow = true로 설정 할 경우, empty 객체가 나와 내가 생각한 대로 사용할 수 있게 되었다.</p>\n<h1 id=\"returninstanceforemptyrow-옵션-설정-방법\">returnInstanceForEmptyRow 옵션 설정 방법</h1>\n<h2 id=\"mybatisconfigxml\">mybatisConfig.xml</h2>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">\"returnInstanceForEmptyRow\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configurtion</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"applicationproperties\">application.properties</h2>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mybatis.configuration.return-instance-for-empty-row=true</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>http://www.mybatis.org/mybatis-3/configuration.html</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>사내 시스템 운영 중, SMS를 전송해 주는 부분에서 장애가 발생 하였다.<br>\n어디에선가 NullPointer Exception이 발생하고 있었다. stacktrace기준으로 추적해 보니,\nMybatis를 통해 데이터를 조회 한다음 데이터를 가공하는 과정에서 NullPointerException이 발생하고 있었다.<br>\n일단 디버깅 이전에 코드를 봤다. 아무리 생각해도 null이 발생하지 않을 것 같았다.</p>\n<p>실제 코드를 돌려보았다.\n<img src=\"./all_element_are_null.png\" alt=\"all_elememt_are_null 에러\"></p>\n<p>이 메세지는 무엇?<br>\n구글에 검색해 보니 List내의 모든 Element의 reference가 null인 것이었다.<br>\n그래서 size는 있지만, 가르키는 instance가 없기 때문에 Nullpointer Exception이 발생하고 있었다.</p>\n<p>일단은 조회된 모든 컬럼이 null이면 mybatis에는 null을 리턴해 주는건가? 라는 심증만 가지고\n절대 null이 될 수 없는 id 컬럼을 조회컬럼에 추가해 주었다.<br>\n(쿼리내에 outer join의 여파로 null만 나오는 쿼리였다.)<br>\n일단은 id 컬럼을 추가 해주니, 정상적으로 id만 값이 있고 다른 property는 모두 null인 객체가 생성되었다.<br>\n일단 이렇게 이슈를 종료하고자 했지만, 너무 찝찝했다</p>\n<p>아니 왜? 모든 컬럼이 null이면 왜 객체 생성을 안하지? 우리가 원하는건 null이 아닐텐데...<br>\n하물며 이런상황에 앞서 조회된 내용에 대해 null 체크를 할 생각을 하니 끔찍했다.</p>\n<p>분명 설정이 있으리라 생각하고 mybatis 사이트를 뒤져보았다.\n뒤져보니 요런게 있었다.</p>\n<h2>returnInstanceForEmptyRow</h2>\n<blockquote>\n<p>MyBatis, by default, returns null when all the columns of a returned row are NULL. When this setting is enabled, MyBatis returns an empty instance instead. Note that it is also applied to nested results (i.e. collectioin and association). Since: 3.4.2</p>\n</blockquote>\n<p>한 마디로 mybatis option중에는 <code>returnInstanceForEmptyRow</code> 이란 옵션이 있는데, 모든 컬럼이 null이면 row를 null로 리턴해 준단다. (이런 ㅡㅡ)<br>\n근데 설정 옵션이 true이면 null 대신에 모든 값이 null인 인스턴스를 반환해주고 false이면 null을 반환해 준다고 한다.<br>\n하지만 default옵션이 false이기 때문에 아무 설정도 안한 회사소스에서는 당연히 null이 리턴되게 된다.<br>\n<code>이 옵션은 mybatis 3.4.2부터 지원한다</code> (회사에서는 mybatis/3.4.2이상 버전을 사용하고 있다.)</p>\n<h1>Test 코드</h1>\n<p>테스트 환경은 아래와 같이 설정해 보았다</p>\n<ul>\n<li>Spring Boot</li>\n<li>Mybatis</li>\n<li>H2DB</li>\n</ul>\n<h2>환경 설정</h2>\n<p>pom.xml\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- MyBatis --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.spring.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.h2database<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>h2<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.hsqldb<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>hsqldb<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>application.properties\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#Datasource</span><br><span class=\"line\">spring.datasource.url=jdbc:h2:mem:test</span><br><span class=\"line\">spring.datasource.initialization-mode=always</span><br><span class=\"line\">spring.datasource.username=sa</span><br><span class=\"line\">spring.datasource.password=</span><br><span class=\"line\">spring.datasource.driver-class-name=org.h2.Driver</span><br><span class=\"line\"></span><br><span class=\"line\">#h2 setting</span><br><span class=\"line\">spring.h2.console.enabled=true</span><br><span class=\"line\">spring.h2.console.path=/h2-console</span><br><span class=\"line\"></span><br><span class=\"line\"># Mybatis Setting</span><br><span class=\"line\">mybatis.mapper-locations=classpath*:mapper/**/*SqlMap.xml</span><br><span class=\"line\">mybatis.configuration.map-underscore-to-camel-case=true</span><br><span class=\"line\">mybatis.configuration.return-instance-for-empty-row=false</span><br></pre></td></tr></table></figure></p>\n<p>schema.sql\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">test</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">INTEGER</span> AUTO_INCREMENT primary <span class=\"keyword\">key</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>),</span><br><span class=\"line\">    description <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>data.sql\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">test</span>(<span class=\"keyword\">id</span>, <span class=\"keyword\">name</span>, description) <span class=\"keyword\">values</span> (<span class=\"number\">1</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure></p>\n<p>TestRepository.java\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestRepository</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">List&lt;TestDTO&gt; <span class=\"title\">getTestAll</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>TestSqlMap.xml\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"com.example.springstudy.demo6.TestRepository\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"getTestAll\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.example.springstudy.demo6.TestDTO\"</span>&gt;</span></span><br><span class=\"line\">        select name, description from test</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>MybatisConfig.java\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@MapperScan</span>(basePackages = <span class=\"string\">\"com.example.springstudy.demo6\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MybatisConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>Test Case</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MybatisTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SqlSessionFactoryBean sqlSessionFactoryBean;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@TestConfiguration</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestContext</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Bean</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EmbeddedDatabaseBuilder()</span><br><span class=\"line\">                    .setType(EmbeddedDatabaseType.H2)</span><br><span class=\"line\">                    .addDefaultScripts()</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Bean</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactoryBean <span class=\"title\">sqlSessionFactoryBean</span><span class=\"params\">(DataSource dataSource)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            SqlSessionFactoryBean sqlSessionFactoryBean = <span class=\"keyword\">new</span> SqlSessionFactoryBean();</span><br><span class=\"line\">            sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class=\"line\">            sqlSessionFactoryBean.getObject()</span><br><span class=\"line\">            \t\t         .getConfiguration()</span><br><span class=\"line\">                                 .setMapUnderscoreToCamelCase(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                                 </span><br><span class=\"line\">            sqlSessionFactoryBean.setMapperLocations(<span class=\"keyword\">new</span> ClassPathResource[]&#123;<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">\"mapper/TestSqlMap.xml\"</span>)&#125;);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sqlSessionFactoryBean;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * returnInstanceForEmptyRow 설정이 false일때,</span></span><br><span class=\"line\"><span class=\"comment\">     * 모든 컬럼의 데이터가 null인 경우, List내의 항목이 null이 되는 경우 테스트</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">all_element_null_test_returnInstanceForEmptyRow_false</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        sqlSessionFactoryBean.getObject()</span><br><span class=\"line\">                             .getConfiguration()</span><br><span class=\"line\">                             .setReturnInstanceForEmptyRow(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;TestDTO&gt; tests = sqlSessionFactoryBean.getObject()</span><br><span class=\"line\">                .openSession()</span><br><span class=\"line\">                .getMapper(TestRepository.class)</span><br><span class=\"line\">                .getTestAll();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//모든 항목이 null인 경우, List내의 Element가 null이 되므로 제거 된다</span></span><br><span class=\"line\">        tests.removeIf(Objects::isNull);</span><br><span class=\"line\">        assertThat(tests).isEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * returnInstanceForEmptyRow 설정이 true일때,</span></span><br><span class=\"line\"><span class=\"comment\">     * 모든 컬럼의 데이터가 null인 경우, 모든 property가 null인 인스턴스가 생성되는지에 대한 테스트</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">all_element_null_test_returnInstanceForEmptyRow_true</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        sqlSessionFactoryBean.getObject()</span><br><span class=\"line\">                             .getConfiguration()</span><br><span class=\"line\">                             .setReturnInstanceForEmptyRow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;TestDTO&gt; tests = sqlSessionFactoryBean.getObject()</span><br><span class=\"line\">                .openSession()</span><br><span class=\"line\">                .getMapper(TestRepository.class)</span><br><span class=\"line\">                .getTestAll();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//모든 항목이 null인 경우, List내의 Element가 Empty 인스턴스를 가르키므로</span></span><br><span class=\"line\">        <span class=\"comment\">//제거되지 않는다.</span></span><br><span class=\"line\">        tests.removeIf(Objects::isNull);</span><br><span class=\"line\">        assertThat(tests).isNotEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>테스트 코드 실행 결과 returnInstanceForEmptyRow = true로 설정 할 경우, empty 객체가 나와 내가 생각한 대로 사용할 수 있게 되었다.</p>\n<h1>returnInstanceForEmptyRow 옵션 설정 방법</h1>\n<h2>mybatisConfig.xml</h2>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">\"returnInstanceForEmptyRow\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configurtion</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2>application.properties</h2>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mybatis.configuration.return-instance-for-empty-row=true</span><br></pre></td></tr></table></figure></p>\n<h1>참고</h1>\n<ul>\n<li>http://www.mybatis.org/mybatis-3/configuration.html</li>\n</ul>\n"},{"title":"Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item1","typora-copy-images-to":"effective-java-item1","date":"2019-01-06T08:42:25.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\n개발자가 클래스의 인스턴스를 생성하는 방법은 new 키워드를 통한 생성자 호출이다.  \n이외에도 생성자와 별도로 정적 팩터리 메서드를 이용해서 메서드 내부에서 생성자나, 이미 생성된 인스턴스를 반환하여 클라이언트 코드에서 인스턴스를 사용 할 수 있다.\n\n# 정적(Static) 팩터리 메서드가 좋은 점\n## 이름을 가질 수 있다.\n생성자의 파라미터 시그니처만으로는 어떤 객체를 반환 할 지에 대한 특성을 이해하기 어렵다.  \n하지만, 정적 팩터리 메서드의 경우는 메서드 이름으로 충분히 유추 할 수 있기 때문에 가독성이 좋아진다.\n\n\n## 호출 될 때 마다 인스턴스를 생성하지 않아도 된다.\nnew를 통해 인스턴스를 생성하게 되면, 불필요한 중복 객체를 생성할 가능성이 많이진다.  \n하나의 객체를 이용해 캐싱하고 쓰는 경우 정적 팩터리 메서드를 사용하는 게 장점이 될 수 있다.\n\n대표적으로 Boolean에 대한 예시가 있다.  \n매번 new Boolean(false)처럼 사용을 하면 사용할 때 마다 중복되는 Boolean 객체를 생성하게 된다.  \n\n하지만 대충 이런식으로 정적 팩터리 메서드를 제공하는 경우\n```java\nClass Boolean{\n  private static final Boolean FLASE = new Boolean(false);\n  private static final Boolean.TRUE = new Boolean(true);\n\n  public static valueOf(boolean b) {\n    return b ? TRUE : FALSE;\n  }\n}\n```\n쓸 데 없는 boolean 객체를 만들지 않아도 되기 때문에 메모리 관리 측면에서 유리하다.  \n또한 객체를 싱글턴(singleton)으로 제공할 수 있고, 인스턴스화 불가로 만들 수 도 있다.  \n> 반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제 할 수 있다.  \n이런 클래스를 **인스턴스 통제(instance-controlled) 클래스**라 한다.\n\n\n## 반환타입의 하위타입 객체(Child)를 반환 할 수 있다.\n인터페이스를 사용해 하위타입 객체를 반환 할 수 있다. 인터페이스 기반 프레임워크의 핵심 기술이라고 볼 수 있다.  \nSpringFramework를 사용하는 경우에도 유용하게 사용 할 수 있다.  \n아래와 같은 예시 코드를 보자\n\n```java\nprivate PaymentService kakaoPaymentService;\nprivate PaymentService naverPaymentService;\nprivate PaymentService paycoPaymentService;\nprivate PaymentService rocketPaymentService;\n\npublic PaymentService getType(PaymentType payentType) {\n  case KAKAO: return kakaoPaymentService;\n  case NAVER: return naverPaymentService;\n  case PAYCO: return paycoPaymentService;\n  case ROCKET: return rocketPaymentService;\n  default: throw new IllegalArgumentException();\n}\n```\n외부 결제 모듈을 사용한다고 가정 했을 때 이런식으로 Interface를 통한 하위타입 객체를 제공할 수 있다.\n\n## 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환 할 수 있다.\nEnumSet 클래스는 public 생성자 없이 오직 정적 팩터리 메서드만 제공한다.  \nOpenJDK에서는 원소가 64개 이하이면 원소들을 long변수 하나로 관리하는 RegularEnumSet의 인스턴스를 리턴하고,  \n65개 이상이면 long배열로 관리하는 JumboEnumSet의 인스턴스를 반환한다.\n\n클라이언트는 EnumSet 객체이면 되기 때문에 무슨객체가 리턴되든 알 필요가 없다. \n\n## 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.\n이러한 유연함은 Service Provider 프레임워크의 근간이 된다.\n대표적인 예로 JDBC가 있다.\n1. DriverManager.registerDriver() 메서드로 각 DBMS별 Driver를 설정한다. (제공자 등록 API)  \n2. DriverManager.getConnection() 메서드로 DB 커넥션 객체를 받는다. (service access API)\n3. Connection Interface는 DBMS 별로 동작을 구현하여 사용할 수 있다. (service Interface)\n\n위와 같이 동작하게 된다면 차후에 다른 DBMS가 나오더라도 같은 Interface를 사용하여 기존과 동일하게 사용이 가능하다.\n\n# 정적(Static) 팩터리 메서드의 단점\n## 상속을 하려면 public/protected 생성자가 필요하다.\n상속을 하기 위해서는 public/protected 생성자가 필요하니, 정적 팩터리 메서드만 제공하면 하위클래스를 만들 수가 없다.\n> 컬렉션 프레임 워크의 유틸리티 구현 클래스는 private 생성자만 제공하므로 상속이 불가하다.  \n이러한 제약은 상속보다 컴포지션을 사용하도록 유도되어 오히려 더 장점으로 작용한다.\n\n## 정적 팩터리 메서드는 개발자가 찾기 어렵다.\n생성자 처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화 할 방법을 찾아야 한다.\n\n# 정적(static) 팩터리 메서드 명명 규칙\n* from - 매개변수를 하나만 받아서 해당 타입의 인스턴스를 반환하는 메서드\n  * 예시) Date date = Date.from(dateStr);\n* of - 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드\n  * 예시) Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);\n* valueOf - from과 of의 더 자세한 버전\n  * BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);\n* instance(getInstance) - 매개변수를 받는다면, 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지 않는다.\n  * StackWalker luke = StackWalker.getInstance(options);\n* create(newInstance) - instance/getInstance와 같지만, 매번 새로운 인스턴스를 반환함을 보장한다.\n* get(Type) - getInstance와 맥락은 같으나 특정 Type을 반환할 때 사용\n  * Steak steak = Food.getSteak(Meet.BEEF);\n* new(Type) - newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스의 팩터리 메서드를 정의 할 때 사용\n  * Steak steak = Food.newSteak(Meet.BEEF);\n* (Type) - getType, newType의 같결한 버전\n  * Steak steak = Food.steak(Meet.BEEF);\n\n# 요약\n정적 팩터리 메서드는 각각의 쓰임새가 있으니, 장단점을 잘 인식하고 쓰는게 좋다.  \n대부분의 경우가 정적 팩터리 메서드로 인스턴스를 생성하는게 유리하니 무작정 public 생성자만 사용하는 습관은 고치는게 좋다.\n# 참고\n* Effective Java 3rd Edition - Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라","source":"_posts/effective-java-item1.md","raw":"---\ntitle: Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item1\ntypora-copy-images-to: effective-java-item1\ndate: 2019-01-06 17:42:25\nsubtitle:\nheader-img:\n---\n\n# 서론\n개발자가 클래스의 인스턴스를 생성하는 방법은 new 키워드를 통한 생성자 호출이다.  \n이외에도 생성자와 별도로 정적 팩터리 메서드를 이용해서 메서드 내부에서 생성자나, 이미 생성된 인스턴스를 반환하여 클라이언트 코드에서 인스턴스를 사용 할 수 있다.\n\n# 정적(Static) 팩터리 메서드가 좋은 점\n## 이름을 가질 수 있다.\n생성자의 파라미터 시그니처만으로는 어떤 객체를 반환 할 지에 대한 특성을 이해하기 어렵다.  \n하지만, 정적 팩터리 메서드의 경우는 메서드 이름으로 충분히 유추 할 수 있기 때문에 가독성이 좋아진다.\n\n\n## 호출 될 때 마다 인스턴스를 생성하지 않아도 된다.\nnew를 통해 인스턴스를 생성하게 되면, 불필요한 중복 객체를 생성할 가능성이 많이진다.  \n하나의 객체를 이용해 캐싱하고 쓰는 경우 정적 팩터리 메서드를 사용하는 게 장점이 될 수 있다.\n\n대표적으로 Boolean에 대한 예시가 있다.  \n매번 new Boolean(false)처럼 사용을 하면 사용할 때 마다 중복되는 Boolean 객체를 생성하게 된다.  \n\n하지만 대충 이런식으로 정적 팩터리 메서드를 제공하는 경우\n```java\nClass Boolean{\n  private static final Boolean FLASE = new Boolean(false);\n  private static final Boolean.TRUE = new Boolean(true);\n\n  public static valueOf(boolean b) {\n    return b ? TRUE : FALSE;\n  }\n}\n```\n쓸 데 없는 boolean 객체를 만들지 않아도 되기 때문에 메모리 관리 측면에서 유리하다.  \n또한 객체를 싱글턴(singleton)으로 제공할 수 있고, 인스턴스화 불가로 만들 수 도 있다.  \n> 반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제 할 수 있다.  \n이런 클래스를 **인스턴스 통제(instance-controlled) 클래스**라 한다.\n\n\n## 반환타입의 하위타입 객체(Child)를 반환 할 수 있다.\n인터페이스를 사용해 하위타입 객체를 반환 할 수 있다. 인터페이스 기반 프레임워크의 핵심 기술이라고 볼 수 있다.  \nSpringFramework를 사용하는 경우에도 유용하게 사용 할 수 있다.  \n아래와 같은 예시 코드를 보자\n\n```java\nprivate PaymentService kakaoPaymentService;\nprivate PaymentService naverPaymentService;\nprivate PaymentService paycoPaymentService;\nprivate PaymentService rocketPaymentService;\n\npublic PaymentService getType(PaymentType payentType) {\n  case KAKAO: return kakaoPaymentService;\n  case NAVER: return naverPaymentService;\n  case PAYCO: return paycoPaymentService;\n  case ROCKET: return rocketPaymentService;\n  default: throw new IllegalArgumentException();\n}\n```\n외부 결제 모듈을 사용한다고 가정 했을 때 이런식으로 Interface를 통한 하위타입 객체를 제공할 수 있다.\n\n## 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환 할 수 있다.\nEnumSet 클래스는 public 생성자 없이 오직 정적 팩터리 메서드만 제공한다.  \nOpenJDK에서는 원소가 64개 이하이면 원소들을 long변수 하나로 관리하는 RegularEnumSet의 인스턴스를 리턴하고,  \n65개 이상이면 long배열로 관리하는 JumboEnumSet의 인스턴스를 반환한다.\n\n클라이언트는 EnumSet 객체이면 되기 때문에 무슨객체가 리턴되든 알 필요가 없다. \n\n## 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.\n이러한 유연함은 Service Provider 프레임워크의 근간이 된다.\n대표적인 예로 JDBC가 있다.\n1. DriverManager.registerDriver() 메서드로 각 DBMS별 Driver를 설정한다. (제공자 등록 API)  \n2. DriverManager.getConnection() 메서드로 DB 커넥션 객체를 받는다. (service access API)\n3. Connection Interface는 DBMS 별로 동작을 구현하여 사용할 수 있다. (service Interface)\n\n위와 같이 동작하게 된다면 차후에 다른 DBMS가 나오더라도 같은 Interface를 사용하여 기존과 동일하게 사용이 가능하다.\n\n# 정적(Static) 팩터리 메서드의 단점\n## 상속을 하려면 public/protected 생성자가 필요하다.\n상속을 하기 위해서는 public/protected 생성자가 필요하니, 정적 팩터리 메서드만 제공하면 하위클래스를 만들 수가 없다.\n> 컬렉션 프레임 워크의 유틸리티 구현 클래스는 private 생성자만 제공하므로 상속이 불가하다.  \n이러한 제약은 상속보다 컴포지션을 사용하도록 유도되어 오히려 더 장점으로 작용한다.\n\n## 정적 팩터리 메서드는 개발자가 찾기 어렵다.\n생성자 처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화 할 방법을 찾아야 한다.\n\n# 정적(static) 팩터리 메서드 명명 규칙\n* from - 매개변수를 하나만 받아서 해당 타입의 인스턴스를 반환하는 메서드\n  * 예시) Date date = Date.from(dateStr);\n* of - 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드\n  * 예시) Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);\n* valueOf - from과 of의 더 자세한 버전\n  * BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);\n* instance(getInstance) - 매개변수를 받는다면, 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지 않는다.\n  * StackWalker luke = StackWalker.getInstance(options);\n* create(newInstance) - instance/getInstance와 같지만, 매번 새로운 인스턴스를 반환함을 보장한다.\n* get(Type) - getInstance와 맥락은 같으나 특정 Type을 반환할 때 사용\n  * Steak steak = Food.getSteak(Meet.BEEF);\n* new(Type) - newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스의 팩터리 메서드를 정의 할 때 사용\n  * Steak steak = Food.newSteak(Meet.BEEF);\n* (Type) - getType, newType의 같결한 버전\n  * Steak steak = Food.steak(Meet.BEEF);\n\n# 요약\n정적 팩터리 메서드는 각각의 쓰임새가 있으니, 장단점을 잘 인식하고 쓰는게 좋다.  \n대부분의 경우가 정적 팩터리 메서드로 인스턴스를 생성하는게 유리하니 무작정 public 생성자만 사용하는 습관은 고치는게 좋다.\n# 참고\n* Effective Java 3rd Edition - Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라","slug":"effective-java-item1","published":1,"updated":"2019-01-07T13:32:09.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2s1000ocr1t3f4rnrxo","content":"<h1 id=\"서론\">서론</h1>\n<p>개발자가 클래스의 인스턴스를 생성하는 방법은 new 키워드를 통한 생성자 호출이다.<br>\n이외에도 생성자와 별도로 정적 팩터리 메서드를 이용해서 메서드 내부에서 생성자나, 이미 생성된 인스턴스를 반환하여 클라이언트 코드에서 인스턴스를 사용 할 수 있다.</p>\n<h1 id=\"정적static-팩터리-메서드가-좋은-점\">정적(Static) 팩터리 메서드가 좋은 점</h1>\n<h2 id=\"이름을-가질-수-있다\">이름을 가질 수 있다.</h2>\n<p>생성자의 파라미터 시그니처만으로는 어떤 객체를 반환 할 지에 대한 특성을 이해하기 어렵다.<br>\n하지만, 정적 팩터리 메서드의 경우는 메서드 이름으로 충분히 유추 할 수 있기 때문에 가독성이 좋아진다.</p>\n<h2 id=\"호출-될-때-마다-인스턴스를-생성하지-않아도-된다\">호출 될 때 마다 인스턴스를 생성하지 않아도 된다.</h2>\n<p>new를 통해 인스턴스를 생성하게 되면, 불필요한 중복 객체를 생성할 가능성이 많이진다.<br>\n하나의 객체를 이용해 캐싱하고 쓰는 경우 정적 팩터리 메서드를 사용하는 게 장점이 될 수 있다.</p>\n<p>대표적으로 Boolean에 대한 예시가 있다.<br>\n매번 new Boolean(false)처럼 사용을 하면 사용할 때 마다 중복되는 Boolean 객체를 생성하게 된다.</p>\n<p>하지만 대충 이런식으로 정적 팩터리 메서드를 제공하는 경우\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class Boolean&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Boolean FLASE = <span class=\"keyword\">new</span> Boolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Boolean.TRUE = <span class=\"keyword\">new</span> Boolean(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b ? TRUE : FALSE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>쓸 데 없는 boolean 객체를 만들지 않아도 되기 때문에 메모리 관리 측면에서 유리하다.<br>\n또한 객체를 싱글턴(singleton)으로 제공할 수 있고, 인스턴스화 불가로 만들 수 도 있다.</p>\n<blockquote>\n<p>반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제 할 수 있다.<br>\n이런 클래스를 <strong>인스턴스 통제(instance-controlled) 클래스</strong>라 한다.</p>\n</blockquote>\n<h2 id=\"반환타입의-하위타입-객체child를-반환-할-수-있다\">반환타입의 하위타입 객체(Child)를 반환 할 수 있다.</h2>\n<p>인터페이스를 사용해 하위타입 객체를 반환 할 수 있다. 인터페이스 기반 프레임워크의 핵심 기술이라고 볼 수 있다.<br>\nSpringFramework를 사용하는 경우에도 유용하게 사용 할 수 있다.<br>\n아래와 같은 예시 코드를 보자</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> PaymentService kakaoPaymentService;</span><br><span class=\"line\"><span class=\"keyword\">private</span> PaymentService naverPaymentService;</span><br><span class=\"line\"><span class=\"keyword\">private</span> PaymentService paycoPaymentService;</span><br><span class=\"line\"><span class=\"keyword\">private</span> PaymentService rocketPaymentService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentService <span class=\"title\">getType</span><span class=\"params\">(PaymentType payentType)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> KAKAO: <span class=\"keyword\">return</span> kakaoPaymentService;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> NAVER: <span class=\"keyword\">return</span> naverPaymentService;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> PAYCO: <span class=\"keyword\">return</span> paycoPaymentService;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> ROCKET: <span class=\"keyword\">return</span> rocketPaymentService;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>외부 결제 모듈을 사용한다고 가정 했을 때 이런식으로 Interface를 통한 하위타입 객체를 제공할 수 있다.</p>\n<h2 id=\"입력-매개변수에-따라-매번-다른-클래스의-객체를-반환-할-수-있다\">입력 매개변수에 따라 매번 다른 클래스의 객체를 반환 할 수 있다.</h2>\n<p>EnumSet 클래스는 public 생성자 없이 오직 정적 팩터리 메서드만 제공한다.<br>\nOpenJDK에서는 원소가 64개 이하이면 원소들을 long변수 하나로 관리하는 RegularEnumSet의 인스턴스를 리턴하고,<br>\n65개 이상이면 long배열로 관리하는 JumboEnumSet의 인스턴스를 반환한다.</p>\n<p>클라이언트는 EnumSet 객체이면 되기 때문에 무슨객체가 리턴되든 알 필요가 없다.</p>\n<h2 id=\"정적-팩터리-메서드를-작성하는-시점에는-반환할-객체의-클래스가-존재하지-않아도-된다\">정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.</h2>\n<p>이러한 유연함은 Service Provider 프레임워크의 근간이 된다.\n대표적인 예로 JDBC가 있다.</p>\n<ol>\n<li>DriverManager.registerDriver() 메서드로 각 DBMS별 Driver를 설정한다. (제공자 등록 API)</li>\n<li>DriverManager.getConnection() 메서드로 DB 커넥션 객체를 받는다. (service access API)</li>\n<li>Connection Interface는 DBMS 별로 동작을 구현하여 사용할 수 있다. (service Interface)</li>\n</ol>\n<p>위와 같이 동작하게 된다면 차후에 다른 DBMS가 나오더라도 같은 Interface를 사용하여 기존과 동일하게 사용이 가능하다.</p>\n<h1 id=\"정적static-팩터리-메서드의-단점\">정적(Static) 팩터리 메서드의 단점</h1>\n<h2 id=\"상속을-하려면-publicprotected-생성자가-필요하다\">상속을 하려면 public/protected 생성자가 필요하다.</h2>\n<p>상속을 하기 위해서는 public/protected 생성자가 필요하니, 정적 팩터리 메서드만 제공하면 하위클래스를 만들 수가 없다.</p>\n<blockquote>\n<p>컬렉션 프레임 워크의 유틸리티 구현 클래스는 private 생성자만 제공하므로 상속이 불가하다.<br>\n이러한 제약은 상속보다 컴포지션을 사용하도록 유도되어 오히려 더 장점으로 작용한다.</p>\n</blockquote>\n<h2 id=\"정적-팩터리-메서드는-개발자가-찾기-어렵다\">정적 팩터리 메서드는 개발자가 찾기 어렵다.</h2>\n<p>생성자 처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화 할 방법을 찾아야 한다.</p>\n<h1 id=\"정적static-팩터리-메서드-명명-규칙\">정적(static) 팩터리 메서드 명명 규칙</h1>\n<ul>\n<li>from - 매개변수를 하나만 받아서 해당 타입의 인스턴스를 반환하는 메서드\n<ul>\n<li>예시) Date date = Date.from(dateStr);</li>\n</ul>\n</li>\n<li>of - 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드\n<ul>\n<li>예시) Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</li>\n</ul>\n</li>\n<li>valueOf - from과 of의 더 자세한 버전\n<ul>\n<li>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</li>\n</ul>\n</li>\n<li>instance(getInstance) - 매개변수를 받는다면, 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지 않는다.\n<ul>\n<li>StackWalker luke = StackWalker.getInstance(options);</li>\n</ul>\n</li>\n<li>create(newInstance) - instance/getInstance와 같지만, 매번 새로운 인스턴스를 반환함을 보장한다.</li>\n<li>get(Type) - getInstance와 맥락은 같으나 특정 Type을 반환할 때 사용\n<ul>\n<li>Steak steak = Food.getSteak(Meet.BEEF);</li>\n</ul>\n</li>\n<li>new(Type) - newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스의 팩터리 메서드를 정의 할 때 사용\n<ul>\n<li>Steak steak = Food.newSteak(Meet.BEEF);</li>\n</ul>\n</li>\n<li>(Type) - getType, newType의 같결한 버전\n<ul>\n<li>Steak steak = Food.steak(Meet.BEEF);</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"요약\">요약</h1>\n<p>정적 팩터리 메서드는 각각의 쓰임새가 있으니, 장단점을 잘 인식하고 쓰는게 좋다.<br>\n대부분의 경우가 정적 팩터리 메서드로 인스턴스를 생성하는게 유리하니 무작정 public 생성자만 사용하는 습관은 고치는게 좋다.</p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>개발자가 클래스의 인스턴스를 생성하는 방법은 new 키워드를 통한 생성자 호출이다.<br>\n이외에도 생성자와 별도로 정적 팩터리 메서드를 이용해서 메서드 내부에서 생성자나, 이미 생성된 인스턴스를 반환하여 클라이언트 코드에서 인스턴스를 사용 할 수 있다.</p>\n<h1>정적(Static) 팩터리 메서드가 좋은 점</h1>\n<h2>이름을 가질 수 있다.</h2>\n<p>생성자의 파라미터 시그니처만으로는 어떤 객체를 반환 할 지에 대한 특성을 이해하기 어렵다.<br>\n하지만, 정적 팩터리 메서드의 경우는 메서드 이름으로 충분히 유추 할 수 있기 때문에 가독성이 좋아진다.</p>\n<h2>호출 될 때 마다 인스턴스를 생성하지 않아도 된다.</h2>\n<p>new를 통해 인스턴스를 생성하게 되면, 불필요한 중복 객체를 생성할 가능성이 많이진다.<br>\n하나의 객체를 이용해 캐싱하고 쓰는 경우 정적 팩터리 메서드를 사용하는 게 장점이 될 수 있다.</p>\n<p>대표적으로 Boolean에 대한 예시가 있다.<br>\n매번 new Boolean(false)처럼 사용을 하면 사용할 때 마다 중복되는 Boolean 객체를 생성하게 된다.</p>\n<p>하지만 대충 이런식으로 정적 팩터리 메서드를 제공하는 경우\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class Boolean&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Boolean FLASE = <span class=\"keyword\">new</span> Boolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Boolean.TRUE = <span class=\"keyword\">new</span> Boolean(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b ? TRUE : FALSE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>쓸 데 없는 boolean 객체를 만들지 않아도 되기 때문에 메모리 관리 측면에서 유리하다.<br>\n또한 객체를 싱글턴(singleton)으로 제공할 수 있고, 인스턴스화 불가로 만들 수 도 있다.</p>\n<blockquote>\n<p>반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제 할 수 있다.<br>\n이런 클래스를 <strong>인스턴스 통제(instance-controlled) 클래스</strong>라 한다.</p>\n</blockquote>\n<h2>반환타입의 하위타입 객체(Child)를 반환 할 수 있다.</h2>\n<p>인터페이스를 사용해 하위타입 객체를 반환 할 수 있다. 인터페이스 기반 프레임워크의 핵심 기술이라고 볼 수 있다.<br>\nSpringFramework를 사용하는 경우에도 유용하게 사용 할 수 있다.<br>\n아래와 같은 예시 코드를 보자</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> PaymentService kakaoPaymentService;</span><br><span class=\"line\"><span class=\"keyword\">private</span> PaymentService naverPaymentService;</span><br><span class=\"line\"><span class=\"keyword\">private</span> PaymentService paycoPaymentService;</span><br><span class=\"line\"><span class=\"keyword\">private</span> PaymentService rocketPaymentService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentService <span class=\"title\">getType</span><span class=\"params\">(PaymentType payentType)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> KAKAO: <span class=\"keyword\">return</span> kakaoPaymentService;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> NAVER: <span class=\"keyword\">return</span> naverPaymentService;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> PAYCO: <span class=\"keyword\">return</span> paycoPaymentService;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> ROCKET: <span class=\"keyword\">return</span> rocketPaymentService;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>외부 결제 모듈을 사용한다고 가정 했을 때 이런식으로 Interface를 통한 하위타입 객체를 제공할 수 있다.</p>\n<h2>입력 매개변수에 따라 매번 다른 클래스의 객체를 반환 할 수 있다.</h2>\n<p>EnumSet 클래스는 public 생성자 없이 오직 정적 팩터리 메서드만 제공한다.<br>\nOpenJDK에서는 원소가 64개 이하이면 원소들을 long변수 하나로 관리하는 RegularEnumSet의 인스턴스를 리턴하고,<br>\n65개 이상이면 long배열로 관리하는 JumboEnumSet의 인스턴스를 반환한다.</p>\n<p>클라이언트는 EnumSet 객체이면 되기 때문에 무슨객체가 리턴되든 알 필요가 없다.</p>\n<h2>정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.</h2>\n<p>이러한 유연함은 Service Provider 프레임워크의 근간이 된다.\n대표적인 예로 JDBC가 있다.</p>\n<ol>\n<li>DriverManager.registerDriver() 메서드로 각 DBMS별 Driver를 설정한다. (제공자 등록 API)</li>\n<li>DriverManager.getConnection() 메서드로 DB 커넥션 객체를 받는다. (service access API)</li>\n<li>Connection Interface는 DBMS 별로 동작을 구현하여 사용할 수 있다. (service Interface)</li>\n</ol>\n<p>위와 같이 동작하게 된다면 차후에 다른 DBMS가 나오더라도 같은 Interface를 사용하여 기존과 동일하게 사용이 가능하다.</p>\n<h1>정적(Static) 팩터리 메서드의 단점</h1>\n<h2>상속을 하려면 public/protected 생성자가 필요하다.</h2>\n<p>상속을 하기 위해서는 public/protected 생성자가 필요하니, 정적 팩터리 메서드만 제공하면 하위클래스를 만들 수가 없다.</p>\n<blockquote>\n<p>컬렉션 프레임 워크의 유틸리티 구현 클래스는 private 생성자만 제공하므로 상속이 불가하다.<br>\n이러한 제약은 상속보다 컴포지션을 사용하도록 유도되어 오히려 더 장점으로 작용한다.</p>\n</blockquote>\n<h2>정적 팩터리 메서드는 개발자가 찾기 어렵다.</h2>\n<p>생성자 처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화 할 방법을 찾아야 한다.</p>\n<h1>정적(static) 팩터리 메서드 명명 규칙</h1>\n<ul>\n<li>from - 매개변수를 하나만 받아서 해당 타입의 인스턴스를 반환하는 메서드\n<ul>\n<li>예시) Date date = Date.from(dateStr);</li>\n</ul>\n</li>\n<li>of - 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드\n<ul>\n<li>예시) Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</li>\n</ul>\n</li>\n<li>valueOf - from과 of의 더 자세한 버전\n<ul>\n<li>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</li>\n</ul>\n</li>\n<li>instance(getInstance) - 매개변수를 받는다면, 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지 않는다.\n<ul>\n<li>StackWalker luke = StackWalker.getInstance(options);</li>\n</ul>\n</li>\n<li>create(newInstance) - instance/getInstance와 같지만, 매번 새로운 인스턴스를 반환함을 보장한다.</li>\n<li>get(Type) - getInstance와 맥락은 같으나 특정 Type을 반환할 때 사용\n<ul>\n<li>Steak steak = Food.getSteak(Meet.BEEF);</li>\n</ul>\n</li>\n<li>new(Type) - newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스의 팩터리 메서드를 정의 할 때 사용\n<ul>\n<li>Steak steak = Food.newSteak(Meet.BEEF);</li>\n</ul>\n</li>\n<li>(Type) - getType, newType의 같결한 버전\n<ul>\n<li>Steak steak = Food.steak(Meet.BEEF);</li>\n</ul>\n</li>\n</ul>\n<h1>요약</h1>\n<p>정적 팩터리 메서드는 각각의 쓰임새가 있으니, 장단점을 잘 인식하고 쓰는게 좋다.<br>\n대부분의 경우가 정적 팩터리 메서드로 인스턴스를 생성하는게 유리하니 무작정 public 생성자만 사용하는 습관은 고치는게 좋다.</p>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라</li>\n</ul>\n"},{"title":"Item 12. toString을 항상 재정의하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item12","typora-copy-images-to":"effective-java-item12","date":"2019-01-13T05:59:25.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\nObject의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.  \n이 메서드는 `PhoneNumber@adbbd`처럼 단순히 **클래스이름@16진수로_표현한_해시코드**를 반환할 뿐이다.  \ntoString의 일반 규약에 따르면, `간결하면서 사람이 읽기 쉬운 형태의 유익한 정보`를 반환해야 한다.  \ntoString의 규악은 `모든 하위클래스에서 이 메서드를 재정의하라`라고 하고 있다.\n\n# toString을 재정의 해야하는 이유\n* toString을 잘 구현한 클래스는 사용하기 편하고, 그 클래스에 대해 디버깅 하기 쉽다.\n  * map객체를 출력하는 경우 `{Jenny=PhoneNumber@addbb}` 보다는 `{Jenney=707-867-5308}`이라는 메세지가 가독서이 좋다.\n* 실전에서는 toString메서드를 재작성 할 때, 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.\n* toString을 구현할 때면 반환값의 포맷을 문서화 할 지 정해야 한다.\n  * 포맷을 명시하면, 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다.\n  * 포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.\n  * 단, 포맷을 한번 명시하면, 평생 그 포맷에 얽매이게 된다.\n  * 포맷을 명시하지 않는다면 다음 릴리즈에 포맷을 변경할 수 있는 유연성을 더 가져갈 수 있다.\n* 포맷을 명시하든 아니든, 개발자의 의도는 명확히 밝혀야 한다.\n* toString이 반환한 값에 대해 포함된 정보를 얻어올 수 있는 API를 제공하자\n  * toString에 있는 getter를 제공하지 않는다면, 클라이언트에서 toString을 파싱하여 사용할 지도 모른다.\n\n## 포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.\n```java\n\n@RunWith(JUnit4.class)\npublic class ToStringTest {\n\n    @Test\n    public void toString테스트() {\n        String phoneNumber = \"707-908-9999\";\n        assertEquals(PhoneNumber.parse(phoneNumber), new PhoneNumber(707, 908, 9999));\n    }\n\n    @Test(expected = UnknownFormatConversionException.class)\n    public void 파싱문자열_오류_테스트() {\n        String phoneNumber = \"707-908\";\n        assertEquals(PhoneNumber.parse(phoneNumber), new PhoneNumber(707, 908, null));\n    }\n\n\n    @NoArgsConstructor\n    @AllArgsConstructor\n    @Builder\n    public static class PhoneNumber{\n        private Integer areaCode;\n        private Integer prefix;\n        private Integer lineNum;\n\n        private static final Pattern phoneNumberPattern = Pattern.compile(\"^\\\\d{3}-\\\\d{3}-\\\\d{4}$\");\n\n        @Override\n        public boolean equals(Object o) {\n            if(!(o instanceof PhoneNumber)) {\n                return false;\n            }\n\n            PhoneNumber pn = (PhoneNumber) o;\n            return this.areaCode.equals(pn.areaCode)\n                    && this.prefix.equals(pn.prefix)\n                    && this.lineNum.equals(pn.lineNum);\n        }\n\n        @Override\n        public int hashCode() {\n            int result = Integer.hashCode(areaCode);\n            result = 31 * result + Integer.hashCode(prefix);\n            result = 31 * result + Integer.hashCode(lineNum);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%03d-%03d-%04d\", areaCode, prefix, lineNum);\n        }\n\n        public static PhoneNumber parse(String phoneNumber) {\n\n            if(!phoneNumberPattern.matcher(phoneNumber).find()) {\n                throw new UnknownFormatConversionException(phoneNumber + \" cannot be parsed\");\n            }\n\n            String[] numbers = phoneNumber.split(\"-\");\n            return PhoneNumber.builder()\n                    .areaCode(Integer.parseInt(numbers[0]))\n                    .prefix(Integer.parseInt(numbers[1]))\n                    .lineNum(Integer.parseInt(numbers[2]))\n                    .build();\n        }\n    }\n```\n\n# toString을 따로 재정의 안해도 되는 경우\n* 정적 Utils 클래스는 따로 재정의 하지 않아도 된다.\n(객체의 상태(state)를 가지는 클래스가 아니기 떄문)\n* enum 타입 또한 이미 완벽한 toString을 제공한다.\n* 대다수의 컬렉션 구현체는 추상 컬렉션 클래스(AbstractMap, AbstractSet등)의 toString 메서드를 상속하여 쓴다.\n* 라이브러리를 통해 자동생성하자\n  * 구글의 @Autovalue\n  * Lombok의 @ToString\n  * 위의 라이브러리들을 이용해 자동생성하는 편이 더 간편하다.\n\n# 참고\n* Effective Java 3rd Edition - Item 12. toString을 항상 재정의하라","source":"_posts/effective-java-item12.md","raw":"---\ntitle: Item 12. toString을 항상 재정의하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item12\ntypora-copy-images-to: effective-java-item12\ndate: 2019-01-13 14:59:25\nsubtitle:\nheader-img:\n---\n\n# 서론\nObject의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.  \n이 메서드는 `PhoneNumber@adbbd`처럼 단순히 **클래스이름@16진수로_표현한_해시코드**를 반환할 뿐이다.  \ntoString의 일반 규약에 따르면, `간결하면서 사람이 읽기 쉬운 형태의 유익한 정보`를 반환해야 한다.  \ntoString의 규악은 `모든 하위클래스에서 이 메서드를 재정의하라`라고 하고 있다.\n\n# toString을 재정의 해야하는 이유\n* toString을 잘 구현한 클래스는 사용하기 편하고, 그 클래스에 대해 디버깅 하기 쉽다.\n  * map객체를 출력하는 경우 `{Jenny=PhoneNumber@addbb}` 보다는 `{Jenney=707-867-5308}`이라는 메세지가 가독서이 좋다.\n* 실전에서는 toString메서드를 재작성 할 때, 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.\n* toString을 구현할 때면 반환값의 포맷을 문서화 할 지 정해야 한다.\n  * 포맷을 명시하면, 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다.\n  * 포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.\n  * 단, 포맷을 한번 명시하면, 평생 그 포맷에 얽매이게 된다.\n  * 포맷을 명시하지 않는다면 다음 릴리즈에 포맷을 변경할 수 있는 유연성을 더 가져갈 수 있다.\n* 포맷을 명시하든 아니든, 개발자의 의도는 명확히 밝혀야 한다.\n* toString이 반환한 값에 대해 포함된 정보를 얻어올 수 있는 API를 제공하자\n  * toString에 있는 getter를 제공하지 않는다면, 클라이언트에서 toString을 파싱하여 사용할 지도 모른다.\n\n## 포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.\n```java\n\n@RunWith(JUnit4.class)\npublic class ToStringTest {\n\n    @Test\n    public void toString테스트() {\n        String phoneNumber = \"707-908-9999\";\n        assertEquals(PhoneNumber.parse(phoneNumber), new PhoneNumber(707, 908, 9999));\n    }\n\n    @Test(expected = UnknownFormatConversionException.class)\n    public void 파싱문자열_오류_테스트() {\n        String phoneNumber = \"707-908\";\n        assertEquals(PhoneNumber.parse(phoneNumber), new PhoneNumber(707, 908, null));\n    }\n\n\n    @NoArgsConstructor\n    @AllArgsConstructor\n    @Builder\n    public static class PhoneNumber{\n        private Integer areaCode;\n        private Integer prefix;\n        private Integer lineNum;\n\n        private static final Pattern phoneNumberPattern = Pattern.compile(\"^\\\\d{3}-\\\\d{3}-\\\\d{4}$\");\n\n        @Override\n        public boolean equals(Object o) {\n            if(!(o instanceof PhoneNumber)) {\n                return false;\n            }\n\n            PhoneNumber pn = (PhoneNumber) o;\n            return this.areaCode.equals(pn.areaCode)\n                    && this.prefix.equals(pn.prefix)\n                    && this.lineNum.equals(pn.lineNum);\n        }\n\n        @Override\n        public int hashCode() {\n            int result = Integer.hashCode(areaCode);\n            result = 31 * result + Integer.hashCode(prefix);\n            result = 31 * result + Integer.hashCode(lineNum);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%03d-%03d-%04d\", areaCode, prefix, lineNum);\n        }\n\n        public static PhoneNumber parse(String phoneNumber) {\n\n            if(!phoneNumberPattern.matcher(phoneNumber).find()) {\n                throw new UnknownFormatConversionException(phoneNumber + \" cannot be parsed\");\n            }\n\n            String[] numbers = phoneNumber.split(\"-\");\n            return PhoneNumber.builder()\n                    .areaCode(Integer.parseInt(numbers[0]))\n                    .prefix(Integer.parseInt(numbers[1]))\n                    .lineNum(Integer.parseInt(numbers[2]))\n                    .build();\n        }\n    }\n```\n\n# toString을 따로 재정의 안해도 되는 경우\n* 정적 Utils 클래스는 따로 재정의 하지 않아도 된다.\n(객체의 상태(state)를 가지는 클래스가 아니기 떄문)\n* enum 타입 또한 이미 완벽한 toString을 제공한다.\n* 대다수의 컬렉션 구현체는 추상 컬렉션 클래스(AbstractMap, AbstractSet등)의 toString 메서드를 상속하여 쓴다.\n* 라이브러리를 통해 자동생성하자\n  * 구글의 @Autovalue\n  * Lombok의 @ToString\n  * 위의 라이브러리들을 이용해 자동생성하는 편이 더 간편하다.\n\n# 참고\n* Effective Java 3rd Edition - Item 12. toString을 항상 재정의하라","slug":"effective-java-item12","published":1,"updated":"2019-01-13T11:38:31.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2s2000rcr1ttebuk4gy","content":"<h1 id=\"서론\">서론</h1>\n<p>Object의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.<br>\n이 메서드는 <code>PhoneNumber@adbbd</code>처럼 단순히 <strong>클래스이름@16진수로_표현한_해시코드</strong>를 반환할 뿐이다.<br>\ntoString의 일반 규약에 따르면, <code>간결하면서 사람이 읽기 쉬운 형태의 유익한 정보</code>를 반환해야 한다.<br>\ntoString의 규악은 <code>모든 하위클래스에서 이 메서드를 재정의하라</code>라고 하고 있다.</p>\n<h1 id=\"tostring을-재정의-해야하는-이유\">toString을 재정의 해야하는 이유</h1>\n<ul>\n<li>toString을 잘 구현한 클래스는 사용하기 편하고, 그 클래스에 대해 디버깅 하기 쉽다.\n<ul>\n<li>map객체를 출력하는 경우 <code>{Jenny=PhoneNumber@addbb}</code> 보다는 <code>{Jenney=707-867-5308}</code>이라는 메세지가 가독서이 좋다.</li>\n</ul>\n</li>\n<li>실전에서는 toString메서드를 재작성 할 때, 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.</li>\n<li>toString을 구현할 때면 반환값의 포맷을 문서화 할 지 정해야 한다.\n<ul>\n<li>포맷을 명시하면, 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다.</li>\n<li>포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</li>\n<li>단, 포맷을 한번 명시하면, 평생 그 포맷에 얽매이게 된다.</li>\n<li>포맷을 명시하지 않는다면 다음 릴리즈에 포맷을 변경할 수 있는 유연성을 더 가져갈 수 있다.</li>\n</ul>\n</li>\n<li>포맷을 명시하든 아니든, 개발자의 의도는 명확히 밝혀야 한다.</li>\n<li>toString이 반환한 값에 대해 포함된 정보를 얻어올 수 있는 API를 제공하자\n<ul>\n<li>toString에 있는 getter를 제공하지 않는다면, 클라이언트에서 toString을 파싱하여 사용할 지도 모른다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"포맷을-명시하기로-했으면-명시한-포맷에-맞는-문자열과-객체를-상호전환-할-수-있는-정적-팩터리나-생성자를-함께-제공하면-좋다\">포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(JUnit4.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToStringTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> toString테스트() &#123;</span><br><span class=\"line\">        String phoneNumber = <span class=\"string\">\"707-908-9999\"</span>;</span><br><span class=\"line\">        assertEquals(PhoneNumber.parse(phoneNumber), <span class=\"keyword\">new</span> PhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">908</span>, <span class=\"number\">9999</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span>(expected = UnknownFormatConversionException.class)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 파싱문자열_오류_테스트() &#123;</span><br><span class=\"line\">        String phoneNumber = <span class=\"string\">\"707-908\"</span>;</span><br><span class=\"line\">        assertEquals(PhoneNumber.parse(phoneNumber), <span class=\"keyword\">new</span> PhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">908</span>, <span class=\"keyword\">null</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\">    <span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\">    <span class=\"meta\">@Builder</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneNumber</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Integer areaCode;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Integer prefix;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Integer lineNum;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Pattern phoneNumberPattern = Pattern.compile(<span class=\"string\">\"^\\\\d&#123;3&#125;-\\\\d&#123;3&#125;-\\\\d&#123;4&#125;$\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> PhoneNumber)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            PhoneNumber pn = (PhoneNumber) o;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.areaCode.equals(pn.areaCode)</span><br><span class=\"line\">                    &amp;&amp; <span class=\"keyword\">this</span>.prefix.equals(pn.prefix)</span><br><span class=\"line\">                    &amp;&amp; <span class=\"keyword\">this</span>.lineNum.equals(pn.lineNum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> result = Integer.hashCode(areaCode);</span><br><span class=\"line\">            result = <span class=\"number\">31</span> * result + Integer.hashCode(prefix);</span><br><span class=\"line\">            result = <span class=\"number\">31</span> * result + Integer.hashCode(lineNum);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> String.format(<span class=\"string\">\"%03d-%03d-%04d\"</span>, areaCode, prefix, lineNum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PhoneNumber <span class=\"title\">parse</span><span class=\"params\">(String phoneNumber)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!phoneNumberPattern.matcher(phoneNumber).find()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnknownFormatConversionException(phoneNumber + <span class=\"string\">\" cannot be parsed\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            String[] numbers = phoneNumber.split(<span class=\"string\">\"-\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> PhoneNumber.builder()</span><br><span class=\"line\">                    .areaCode(Integer.parseInt(numbers[<span class=\"number\">0</span>]))</span><br><span class=\"line\">                    .prefix(Integer.parseInt(numbers[<span class=\"number\">1</span>]))</span><br><span class=\"line\">                    .lineNum(Integer.parseInt(numbers[<span class=\"number\">2</span>]))</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"tostring을-따로-재정의-안해도-되는-경우\">toString을 따로 재정의 안해도 되는 경우</h1>\n<ul>\n<li>정적 Utils 클래스는 따로 재정의 하지 않아도 된다.\n(객체의 상태(state)를 가지는 클래스가 아니기 떄문)</li>\n<li>enum 타입 또한 이미 완벽한 toString을 제공한다.</li>\n<li>대다수의 컬렉션 구현체는 추상 컬렉션 클래스(AbstractMap, AbstractSet등)의 toString 메서드를 상속하여 쓴다.</li>\n<li>라이브러리를 통해 자동생성하자\n<ul>\n<li>구글의 @Autovalue</li>\n<li>Lombok의 @ToString</li>\n<li>위의 라이브러리들을 이용해 자동생성하는 편이 더 간편하다.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 12. toString을 항상 재정의하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>Object의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.<br>\n이 메서드는 <code>PhoneNumber@adbbd</code>처럼 단순히 <strong>클래스이름@16진수로_표현한_해시코드</strong>를 반환할 뿐이다.<br>\ntoString의 일반 규약에 따르면, <code>간결하면서 사람이 읽기 쉬운 형태의 유익한 정보</code>를 반환해야 한다.<br>\ntoString의 규악은 <code>모든 하위클래스에서 이 메서드를 재정의하라</code>라고 하고 있다.</p>\n<h1>toString을 재정의 해야하는 이유</h1>\n<ul>\n<li>toString을 잘 구현한 클래스는 사용하기 편하고, 그 클래스에 대해 디버깅 하기 쉽다.\n<ul>\n<li>map객체를 출력하는 경우 <code>{Jenny=PhoneNumber@addbb}</code> 보다는 <code>{Jenney=707-867-5308}</code>이라는 메세지가 가독서이 좋다.</li>\n</ul>\n</li>\n<li>실전에서는 toString메서드를 재작성 할 때, 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.</li>\n<li>toString을 구현할 때면 반환값의 포맷을 문서화 할 지 정해야 한다.\n<ul>\n<li>포맷을 명시하면, 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다.</li>\n<li>포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</li>\n<li>단, 포맷을 한번 명시하면, 평생 그 포맷에 얽매이게 된다.</li>\n<li>포맷을 명시하지 않는다면 다음 릴리즈에 포맷을 변경할 수 있는 유연성을 더 가져갈 수 있다.</li>\n</ul>\n</li>\n<li>포맷을 명시하든 아니든, 개발자의 의도는 명확히 밝혀야 한다.</li>\n<li>toString이 반환한 값에 대해 포함된 정보를 얻어올 수 있는 API를 제공하자\n<ul>\n<li>toString에 있는 getter를 제공하지 않는다면, 클라이언트에서 toString을 파싱하여 사용할 지도 모른다.</li>\n</ul>\n</li>\n</ul>\n<h2>포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(JUnit4.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToStringTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> toString테스트() &#123;</span><br><span class=\"line\">        String phoneNumber = <span class=\"string\">\"707-908-9999\"</span>;</span><br><span class=\"line\">        assertEquals(PhoneNumber.parse(phoneNumber), <span class=\"keyword\">new</span> PhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">908</span>, <span class=\"number\">9999</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span>(expected = UnknownFormatConversionException.class)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 파싱문자열_오류_테스트() &#123;</span><br><span class=\"line\">        String phoneNumber = <span class=\"string\">\"707-908\"</span>;</span><br><span class=\"line\">        assertEquals(PhoneNumber.parse(phoneNumber), <span class=\"keyword\">new</span> PhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">908</span>, <span class=\"keyword\">null</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\">    <span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\">    <span class=\"meta\">@Builder</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneNumber</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Integer areaCode;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Integer prefix;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Integer lineNum;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Pattern phoneNumberPattern = Pattern.compile(<span class=\"string\">\"^\\\\d&#123;3&#125;-\\\\d&#123;3&#125;-\\\\d&#123;4&#125;$\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> PhoneNumber)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            PhoneNumber pn = (PhoneNumber) o;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.areaCode.equals(pn.areaCode)</span><br><span class=\"line\">                    &amp;&amp; <span class=\"keyword\">this</span>.prefix.equals(pn.prefix)</span><br><span class=\"line\">                    &amp;&amp; <span class=\"keyword\">this</span>.lineNum.equals(pn.lineNum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> result = Integer.hashCode(areaCode);</span><br><span class=\"line\">            result = <span class=\"number\">31</span> * result + Integer.hashCode(prefix);</span><br><span class=\"line\">            result = <span class=\"number\">31</span> * result + Integer.hashCode(lineNum);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> String.format(<span class=\"string\">\"%03d-%03d-%04d\"</span>, areaCode, prefix, lineNum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PhoneNumber <span class=\"title\">parse</span><span class=\"params\">(String phoneNumber)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!phoneNumberPattern.matcher(phoneNumber).find()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnknownFormatConversionException(phoneNumber + <span class=\"string\">\" cannot be parsed\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            String[] numbers = phoneNumber.split(<span class=\"string\">\"-\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> PhoneNumber.builder()</span><br><span class=\"line\">                    .areaCode(Integer.parseInt(numbers[<span class=\"number\">0</span>]))</span><br><span class=\"line\">                    .prefix(Integer.parseInt(numbers[<span class=\"number\">1</span>]))</span><br><span class=\"line\">                    .lineNum(Integer.parseInt(numbers[<span class=\"number\">2</span>]))</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h1>toString을 따로 재정의 안해도 되는 경우</h1>\n<ul>\n<li>정적 Utils 클래스는 따로 재정의 하지 않아도 된다.\n(객체의 상태(state)를 가지는 클래스가 아니기 떄문)</li>\n<li>enum 타입 또한 이미 완벽한 toString을 제공한다.</li>\n<li>대다수의 컬렉션 구현체는 추상 컬렉션 클래스(AbstractMap, AbstractSet등)의 toString 메서드를 상속하여 쓴다.</li>\n<li>라이브러리를 통해 자동생성하자\n<ul>\n<li>구글의 @Autovalue</li>\n<li>Lombok의 @ToString</li>\n<li>위의 라이브러리들을 이용해 자동생성하는 편이 더 간편하다.</li>\n</ul>\n</li>\n</ul>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 12. toString을 항상 재정의하라</li>\n</ul>\n"},{"title":"Item 14. Comparable을 구현할지 고려하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item14","typora-copy-images-to":"effective-java-item14","date":"2019-01-13T10:26:38.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\nComparable을 구현하는 이유는 클래스의 인스턴스들간의 Ordering을 목적으로 구현하는 클래스이다.  \n따라서 Comparable을 구현한 클래스에 대한 배열은 다음처럼 손쉽게 정렬 할 수 있다.\n\n```java\nArrays.sort(arr);\n```\n\n사실상 자바 플랫폼 라이브러리의 모든 값 클래스와 열거타입은 Compareable을 구현했다.  \n알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면, 반드시 Comparable 인터페이스를 구현하자\n\n# compareTo 메서드 규약\n\n이 객체와 주어진 객체의 순서를 비교한다.  \n이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 리턴한다.  \n이 객체와 비교할 수 없는 타입이 주어지면 ClassCaseException을 던진다.\n\n## 대칭성\n* Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == (y.compareTo(x)) * (-1)을 만족해야 한다.\n* 따라서 x.compareTo(y)가 예외를 던지는 경우, y.compareTo(x)도 예외를 던져야 한다.\n\n## 추이성\n* Comparable을 구현한 클래스는 모든 x, y, z에 대해 x.compareTo(y) > 0 이고 y.compareTo(z)이면, x.compareTo(z)를 만족해야 한다.\n\n## 반사성\n* Comparable을 구현한 클래스 z는 x.compareTo(y) == 0 이면, sgn(x.compareTo(z)) == sgn(y.compareTo(z))를 만족해야 한다.\n\n## equals \n* Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == 0 이면, x.equals(y)를 만족하는 것이 좋다. (권고사항은 아니다.)  \n이 권고를 지키지 않으려면, `주의: 이 클래스의 순서는 equals 메서드와 일관되지 않다.`라고 명시해 주자.\n\n# equals와 compareTo 차이점\ncompareTo 규약 4번째의 예시로 BigDecimal 클래스가 있다.  \nnew Decimal(\"1.0\")과 new Decimal(\"1.00\")이 있다고 할 때 두 객체를 HashSet<Decimal>에 담게 되면 size는 2개가 된다.  \n하지만 TreeSet<Decimal>에 담게 되면 size는 1개가 된다.  \n\n왜 이런 결과가 나올까?  \nHashSet에서는 equals를 기반으로 비교하기 때문에 new Decimal(\"1.0\")과 new Decimal(\"1.00\")은 서로 다른 객체이다. 그렇기 때문에 size가 2개가 된다.  \n하지만 TreeSet에서는 객체에 대한 동치성 비교를 compareTo로 하기 때문에 new Decimal(\"1.0\")과 new Decimal(\"1.00\")의 compareTo는 0을 리턴한다.  \n따라서 같은 객체로 인식하여 size가 1개가 된다.\n\n# compareTo 안티패턴\ncompareTo 메서드에서 관계연산자 (`<` 와 `>`)를 사용하지 말아야 한다.  \n대신 Type.compare(T t1, T t2)를 사용하여 비교하는 것이 좋다.\n\n안티 패턴 코드\n```java\npublic int compareTo (int x, int y) {\n  return x < y ? 1 : (x == y) ? 0 : -1;\n}\n```\n\nhashcode의 차를 이용한 비교는 안된다. (추이성에 위배된다.)\n\n```java\nstatic Comparator<Object> hashCodeOrder = new Comparator<>() {\n  (Object o1, Object o2) -> o1.hashCode() - o2.hashCode();\n}\n```\n위의 코드 처럼 실행하면, 정수 overflow를 일으키거나 IEEE754 부동소수점 계산방식에 따른 오류를 발생 시킬 수 있다.  \n따라서 아래 코드로 고쳐서 사용하는 것이 좋다.\n```java\nstatic Comparator<Object> hashCodeOrder = new Comparator<>() {\n  (Object o1, Object o2) -> Integer.compare(o1.hashCode(), o2.hashCode())\n}\n```\n```java\nstatic Comparator<Object> hashCodeOrder = Comparator.comparingInt(o -> o.hashCode());\n```\n\n# 사용 예제\n## 기본 타입 필드가 여러 개 일때 비교자\n```java\npublic int compareTo(PhoneNumber pn) {\n  int result = Short.compare(this.areaCode, pn.areaCode);\n  if(result == 0) {\n    result = Short.compare(this.prefix, pn.prefix);\n    if(result == 0) {\n      result = Short.compare(this.line\n      Num, pn.lineNum);\n    }\n  }\n}\n```\n필드의 정렬 우선순위를 정해 같은 값이 있을 때 마다 조건을 추가한다.\n\n## 비교자 생성 메서드를 이용한 비교자\n```java\nprivate static final Comparator<PhoneNumber> COMPARATOR \n                        = comparingInt((PhoneNumber pn) -> pn.areaCode)  \n                                      .thenComparingInt(pn -> pn.prefix)  \n                                      .thenComparingInt(pn -> pn.lineNum)\n```\ncomparingInt라는 static 메서드를 import하여 사용하고, 2번째 조건 부터 thenComparingInt를 사용하여 비교자를 추가 할 수 있다.  \n최초 사용 시, PhoneNumber pn을 사용하여 람다식에서 타입을 추론 할 수 있도록 코드를 추가 하였다.  \nthenComparingInt부터는 자바 컴파일러가 충분히 타입을 추론 할 수 있으므로 명시적으로 지정하지 않았다.  \nLong타입과 Double타입에 대해서는 각각 comparingLong, thenComparingLong과 comparingDouble, thenComparingDouble이 별도로 있다.\n\n\n# 참고\n* Effective Java 3rd Edition - Item 14. Comparable을 구현할지 고려하라\n","source":"_posts/effective-java-item14.md","raw":"---\ntitle: Item 14. Comparable을 구현할지 고려하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item14\ntypora-copy-images-to: effective-java-item14\ndate: 2019-01-13 19:26:38\nsubtitle:\nheader-img:\n---\n\n# 서론\nComparable을 구현하는 이유는 클래스의 인스턴스들간의 Ordering을 목적으로 구현하는 클래스이다.  \n따라서 Comparable을 구현한 클래스에 대한 배열은 다음처럼 손쉽게 정렬 할 수 있다.\n\n```java\nArrays.sort(arr);\n```\n\n사실상 자바 플랫폼 라이브러리의 모든 값 클래스와 열거타입은 Compareable을 구현했다.  \n알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면, 반드시 Comparable 인터페이스를 구현하자\n\n# compareTo 메서드 규약\n\n이 객체와 주어진 객체의 순서를 비교한다.  \n이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 리턴한다.  \n이 객체와 비교할 수 없는 타입이 주어지면 ClassCaseException을 던진다.\n\n## 대칭성\n* Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == (y.compareTo(x)) * (-1)을 만족해야 한다.\n* 따라서 x.compareTo(y)가 예외를 던지는 경우, y.compareTo(x)도 예외를 던져야 한다.\n\n## 추이성\n* Comparable을 구현한 클래스는 모든 x, y, z에 대해 x.compareTo(y) > 0 이고 y.compareTo(z)이면, x.compareTo(z)를 만족해야 한다.\n\n## 반사성\n* Comparable을 구현한 클래스 z는 x.compareTo(y) == 0 이면, sgn(x.compareTo(z)) == sgn(y.compareTo(z))를 만족해야 한다.\n\n## equals \n* Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == 0 이면, x.equals(y)를 만족하는 것이 좋다. (권고사항은 아니다.)  \n이 권고를 지키지 않으려면, `주의: 이 클래스의 순서는 equals 메서드와 일관되지 않다.`라고 명시해 주자.\n\n# equals와 compareTo 차이점\ncompareTo 규약 4번째의 예시로 BigDecimal 클래스가 있다.  \nnew Decimal(\"1.0\")과 new Decimal(\"1.00\")이 있다고 할 때 두 객체를 HashSet<Decimal>에 담게 되면 size는 2개가 된다.  \n하지만 TreeSet<Decimal>에 담게 되면 size는 1개가 된다.  \n\n왜 이런 결과가 나올까?  \nHashSet에서는 equals를 기반으로 비교하기 때문에 new Decimal(\"1.0\")과 new Decimal(\"1.00\")은 서로 다른 객체이다. 그렇기 때문에 size가 2개가 된다.  \n하지만 TreeSet에서는 객체에 대한 동치성 비교를 compareTo로 하기 때문에 new Decimal(\"1.0\")과 new Decimal(\"1.00\")의 compareTo는 0을 리턴한다.  \n따라서 같은 객체로 인식하여 size가 1개가 된다.\n\n# compareTo 안티패턴\ncompareTo 메서드에서 관계연산자 (`<` 와 `>`)를 사용하지 말아야 한다.  \n대신 Type.compare(T t1, T t2)를 사용하여 비교하는 것이 좋다.\n\n안티 패턴 코드\n```java\npublic int compareTo (int x, int y) {\n  return x < y ? 1 : (x == y) ? 0 : -1;\n}\n```\n\nhashcode의 차를 이용한 비교는 안된다. (추이성에 위배된다.)\n\n```java\nstatic Comparator<Object> hashCodeOrder = new Comparator<>() {\n  (Object o1, Object o2) -> o1.hashCode() - o2.hashCode();\n}\n```\n위의 코드 처럼 실행하면, 정수 overflow를 일으키거나 IEEE754 부동소수점 계산방식에 따른 오류를 발생 시킬 수 있다.  \n따라서 아래 코드로 고쳐서 사용하는 것이 좋다.\n```java\nstatic Comparator<Object> hashCodeOrder = new Comparator<>() {\n  (Object o1, Object o2) -> Integer.compare(o1.hashCode(), o2.hashCode())\n}\n```\n```java\nstatic Comparator<Object> hashCodeOrder = Comparator.comparingInt(o -> o.hashCode());\n```\n\n# 사용 예제\n## 기본 타입 필드가 여러 개 일때 비교자\n```java\npublic int compareTo(PhoneNumber pn) {\n  int result = Short.compare(this.areaCode, pn.areaCode);\n  if(result == 0) {\n    result = Short.compare(this.prefix, pn.prefix);\n    if(result == 0) {\n      result = Short.compare(this.line\n      Num, pn.lineNum);\n    }\n  }\n}\n```\n필드의 정렬 우선순위를 정해 같은 값이 있을 때 마다 조건을 추가한다.\n\n## 비교자 생성 메서드를 이용한 비교자\n```java\nprivate static final Comparator<PhoneNumber> COMPARATOR \n                        = comparingInt((PhoneNumber pn) -> pn.areaCode)  \n                                      .thenComparingInt(pn -> pn.prefix)  \n                                      .thenComparingInt(pn -> pn.lineNum)\n```\ncomparingInt라는 static 메서드를 import하여 사용하고, 2번째 조건 부터 thenComparingInt를 사용하여 비교자를 추가 할 수 있다.  \n최초 사용 시, PhoneNumber pn을 사용하여 람다식에서 타입을 추론 할 수 있도록 코드를 추가 하였다.  \nthenComparingInt부터는 자바 컴파일러가 충분히 타입을 추론 할 수 있으므로 명시적으로 지정하지 않았다.  \nLong타입과 Double타입에 대해서는 각각 comparingLong, thenComparingLong과 comparingDouble, thenComparingDouble이 별도로 있다.\n\n\n# 참고\n* Effective Java 3rd Edition - Item 14. Comparable을 구현할지 고려하라\n","slug":"effective-java-item14","published":1,"updated":"2019-01-13T11:41:52.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2s3000scr1tealiyhfh","content":"<h1 id=\"서론\">서론</h1>\n<p>Comparable을 구현하는 이유는 클래스의 인스턴스들간의 Ordering을 목적으로 구현하는 클래스이다.<br>\n따라서 Comparable을 구현한 클래스에 대한 배열은 다음처럼 손쉽게 정렬 할 수 있다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.sort(arr);</span><br></pre></td></tr></table></figure></p>\n<p>사실상 자바 플랫폼 라이브러리의 모든 값 클래스와 열거타입은 Compareable을 구현했다.<br>\n알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면, 반드시 Comparable 인터페이스를 구현하자</p>\n<h1 id=\"compareto-메서드-규약\">compareTo 메서드 규약</h1>\n<p>이 객체와 주어진 객체의 순서를 비교한다.<br>\n이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 리턴한다.<br>\n이 객체와 비교할 수 없는 타입이 주어지면 ClassCaseException을 던진다.</p>\n<h2 id=\"대칭성\">대칭성</h2>\n<ul>\n<li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == (y.compareTo(x)) * (-1)을 만족해야 한다.</li>\n<li>따라서 x.compareTo(y)가 예외를 던지는 경우, y.compareTo(x)도 예외를 던져야 한다.</li>\n</ul>\n<h2 id=\"추이성\">추이성</h2>\n<ul>\n<li>Comparable을 구현한 클래스는 모든 x, y, z에 대해 x.compareTo(y) &gt; 0 이고 y.compareTo(z)이면, x.compareTo(z)를 만족해야 한다.</li>\n</ul>\n<h2 id=\"반사성\">반사성</h2>\n<ul>\n<li>Comparable을 구현한 클래스 z는 x.compareTo(y) == 0 이면, sgn(x.compareTo(z)) == sgn(y.compareTo(z))를 만족해야 한다.</li>\n</ul>\n<h2 id=\"equals\">equals</h2>\n<ul>\n<li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == 0 이면, x.equals(y)를 만족하는 것이 좋다. (권고사항은 아니다.)<br>\n이 권고를 지키지 않으려면, <code>주의: 이 클래스의 순서는 equals 메서드와 일관되지 않다.</code>라고 명시해 주자.</li>\n</ul>\n<h1 id=\"equals와-compareto-차이점\">equals와 compareTo 차이점</h1>\n<p>compareTo 규약 4번째의 예시로 BigDecimal 클래스가 있다.<br>\nnew Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)이 있다고 할 때 두 객체를 HashSet&lt;Decimal&gt;에 담게 되면 size는 2개가 된다.<br>\n하지만 TreeSet&lt;Decimal&gt;에 담게 되면 size는 1개가 된다.</p>\n<p>왜 이런 결과가 나올까?<br>\nHashSet에서는 equals를 기반으로 비교하기 때문에 new Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)은 서로 다른 객체이다. 그렇기 때문에 size가 2개가 된다.<br>\n하지만 TreeSet에서는 객체에 대한 동치성 비교를 compareTo로 하기 때문에 new Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)의 compareTo는 0을 리턴한다.<br>\n따라서 같은 객체로 인식하여 size가 1개가 된다.</p>\n<h1 id=\"compareto-안티패턴\">compareTo 안티패턴</h1>\n<p>compareTo 메서드에서 관계연산자 (<code>&lt;</code> 와 <code>&gt;</code>)를 사용하지 말아야 한다.<br>\n대신 Type.compare(T t1, T t2)를 사용하여 비교하는 것이 좋다.</p>\n<p>안티 패턴 코드\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span> <span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt; y ? <span class=\"number\">1</span> : (x == y) ? <span class=\"number\">0</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>hashcode의 차를 이용한 비교는 안된다. (추이성에 위배된다.)</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class=\"keyword\">new</span> Comparator&lt;&gt;() &#123;</span><br><span class=\"line\">  (Object o1, Object o2) -&gt; o1.hashCode() - o2.hashCode();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 코드 처럼 실행하면, 정수 overflow를 일으키거나 IEEE754 부동소수점 계산방식에 따른 오류를 발생 시킬 수 있다.<br>\n따라서 아래 코드로 고쳐서 사용하는 것이 좋다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class=\"keyword\">new</span> Comparator&lt;&gt;() &#123;</span><br><span class=\"line\">  (Object o1, Object o2) -&gt; Integer.compare(o1.hashCode(), o2.hashCode())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"사용-예제\">사용 예제</h1>\n<h2 id=\"기본-타입-필드가-여러-개-일때-비교자\">기본 타입 필드가 여러 개 일때 비교자</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(PhoneNumber pn)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result = Short.compare(<span class=\"keyword\">this</span>.areaCode, pn.areaCode);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    result = Short.compare(<span class=\"keyword\">this</span>.prefix, pn.prefix);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      result = Short.compare(<span class=\"keyword\">this</span>.line</span><br><span class=\"line\">      Num, pn.lineNum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>필드의 정렬 우선순위를 정해 같은 값이 있을 때 마다 조건을 추가한다.</p>\n<h2 id=\"비교자-생성-메서드를-이용한-비교자\">비교자 생성 메서드를 이용한 비교자</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR </span><br><span class=\"line\">                        = comparingInt((PhoneNumber pn) -&gt; pn.areaCode)  </span><br><span class=\"line\">                                      .thenComparingInt(pn -&gt; pn.prefix)  </span><br><span class=\"line\">                                      .thenComparingInt(pn -&gt; pn.lineNum)</span><br></pre></td></tr></table></figure></p>\n<p>comparingInt라는 static 메서드를 import하여 사용하고, 2번째 조건 부터 thenComparingInt를 사용하여 비교자를 추가 할 수 있다.<br>\n최초 사용 시, PhoneNumber pn을 사용하여 람다식에서 타입을 추론 할 수 있도록 코드를 추가 하였다.<br>\nthenComparingInt부터는 자바 컴파일러가 충분히 타입을 추론 할 수 있으므로 명시적으로 지정하지 않았다.<br>\nLong타입과 Double타입에 대해서는 각각 comparingLong, thenComparingLong과 comparingDouble, thenComparingDouble이 별도로 있다.</p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 14. Comparable을 구현할지 고려하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>Comparable을 구현하는 이유는 클래스의 인스턴스들간의 Ordering을 목적으로 구현하는 클래스이다.<br>\n따라서 Comparable을 구현한 클래스에 대한 배열은 다음처럼 손쉽게 정렬 할 수 있다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.sort(arr);</span><br></pre></td></tr></table></figure></p>\n<p>사실상 자바 플랫폼 라이브러리의 모든 값 클래스와 열거타입은 Compareable을 구현했다.<br>\n알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면, 반드시 Comparable 인터페이스를 구현하자</p>\n<h1>compareTo 메서드 규약</h1>\n<p>이 객체와 주어진 객체의 순서를 비교한다.<br>\n이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 리턴한다.<br>\n이 객체와 비교할 수 없는 타입이 주어지면 ClassCaseException을 던진다.</p>\n<h2>대칭성</h2>\n<ul>\n<li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == (y.compareTo(x)) * (-1)을 만족해야 한다.</li>\n<li>따라서 x.compareTo(y)가 예외를 던지는 경우, y.compareTo(x)도 예외를 던져야 한다.</li>\n</ul>\n<h2>추이성</h2>\n<ul>\n<li>Comparable을 구현한 클래스는 모든 x, y, z에 대해 x.compareTo(y) &gt; 0 이고 y.compareTo(z)이면, x.compareTo(z)를 만족해야 한다.</li>\n</ul>\n<h2>반사성</h2>\n<ul>\n<li>Comparable을 구현한 클래스 z는 x.compareTo(y) == 0 이면, sgn(x.compareTo(z)) == sgn(y.compareTo(z))를 만족해야 한다.</li>\n</ul>\n<h2>equals</h2>\n<ul>\n<li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == 0 이면, x.equals(y)를 만족하는 것이 좋다. (권고사항은 아니다.)<br>\n이 권고를 지키지 않으려면, <code>주의: 이 클래스의 순서는 equals 메서드와 일관되지 않다.</code>라고 명시해 주자.</li>\n</ul>\n<h1>equals와 compareTo 차이점</h1>\n<p>compareTo 규약 4번째의 예시로 BigDecimal 클래스가 있다.<br>\nnew Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)이 있다고 할 때 두 객체를 HashSet&lt;Decimal&gt;에 담게 되면 size는 2개가 된다.<br>\n하지만 TreeSet&lt;Decimal&gt;에 담게 되면 size는 1개가 된다.</p>\n<p>왜 이런 결과가 나올까?<br>\nHashSet에서는 equals를 기반으로 비교하기 때문에 new Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)은 서로 다른 객체이다. 그렇기 때문에 size가 2개가 된다.<br>\n하지만 TreeSet에서는 객체에 대한 동치성 비교를 compareTo로 하기 때문에 new Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)의 compareTo는 0을 리턴한다.<br>\n따라서 같은 객체로 인식하여 size가 1개가 된다.</p>\n<h1>compareTo 안티패턴</h1>\n<p>compareTo 메서드에서 관계연산자 (<code>&lt;</code> 와 <code>&gt;</code>)를 사용하지 말아야 한다.<br>\n대신 Type.compare(T t1, T t2)를 사용하여 비교하는 것이 좋다.</p>\n<p>안티 패턴 코드\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span> <span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt; y ? <span class=\"number\">1</span> : (x == y) ? <span class=\"number\">0</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>hashcode의 차를 이용한 비교는 안된다. (추이성에 위배된다.)</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class=\"keyword\">new</span> Comparator&lt;&gt;() &#123;</span><br><span class=\"line\">  (Object o1, Object o2) -&gt; o1.hashCode() - o2.hashCode();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 코드 처럼 실행하면, 정수 overflow를 일으키거나 IEEE754 부동소수점 계산방식에 따른 오류를 발생 시킬 수 있다.<br>\n따라서 아래 코드로 고쳐서 사용하는 것이 좋다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class=\"keyword\">new</span> Comparator&lt;&gt;() &#123;</span><br><span class=\"line\">  (Object o1, Object o2) -&gt; Integer.compare(o1.hashCode(), o2.hashCode())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());</span><br></pre></td></tr></table></figure></p>\n<h1>사용 예제</h1>\n<h2>기본 타입 필드가 여러 개 일때 비교자</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(PhoneNumber pn)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result = Short.compare(<span class=\"keyword\">this</span>.areaCode, pn.areaCode);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    result = Short.compare(<span class=\"keyword\">this</span>.prefix, pn.prefix);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      result = Short.compare(<span class=\"keyword\">this</span>.line</span><br><span class=\"line\">      Num, pn.lineNum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>필드의 정렬 우선순위를 정해 같은 값이 있을 때 마다 조건을 추가한다.</p>\n<h2>비교자 생성 메서드를 이용한 비교자</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR </span><br><span class=\"line\">                        = comparingInt((PhoneNumber pn) -&gt; pn.areaCode)  </span><br><span class=\"line\">                                      .thenComparingInt(pn -&gt; pn.prefix)  </span><br><span class=\"line\">                                      .thenComparingInt(pn -&gt; pn.lineNum)</span><br></pre></td></tr></table></figure></p>\n<p>comparingInt라는 static 메서드를 import하여 사용하고, 2번째 조건 부터 thenComparingInt를 사용하여 비교자를 추가 할 수 있다.<br>\n최초 사용 시, PhoneNumber pn을 사용하여 람다식에서 타입을 추론 할 수 있도록 코드를 추가 하였다.<br>\nthenComparingInt부터는 자바 컴파일러가 충분히 타입을 추론 할 수 있으므로 명시적으로 지정하지 않았다.<br>\nLong타입과 Double타입에 대해서는 각각 comparingLong, thenComparingLong과 comparingDouble, thenComparingDouble이 별도로 있다.</p>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 14. Comparable을 구현할지 고려하라</li>\n</ul>\n"},{"title":"Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item16","typora-copy-images-to":"effective-java-item16","date":"2019-01-20T08:53:54.000Z","subtitle":null,"header-img":null,"_content":"\n# 퇴보한 클래스\n```java\nclass Point {\n  public double x;\n  public double y;\n}\n```\n이런 클래스는 데이터 필드에 직접 접근하여 수정이 가능하다. 따라서 캡슐화의 이점을 제공하지 못한다. \n* API를 수정하지 않고는 내부 표현을 바꿀 수 없다.\n* 불변식을 보장할 수 없다.\n* 외부에서 필드에 접근할 때 부수 작업을 수행 할 수도 없다.\n  (예를들면, x값 조회 시, Comma case로 리턴하는 식의?)\n\n# 흔하게 만드는 캡슐레이션\n```java\nclass Point {\n  private double x;\n  private double y;\n\n  public Point (double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public double getX() { return x; }\n  public double getY() { return y; }\n\n  public void setX(double x) { this.x = x; }\n  public void setY(double y) { this.y = y; }\n}\n```\n* public 클래스라면 반드시 이정도의 접근자와 수정자를 만드는 정도는 해야된다.  \n* 클래스 내부 표현 방식을 언제든지 바꿀 수 있는 유연성을 제공해야 한다.\n* package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다해도 문제가 없다.\n  * 같은 패키지안에서 특정이유 때문에 사용하던가, 톱레벨 클래스에서만 접근 할 것이기 때문이다.\n\n# 요약\n* public 클래스는 절대 가변 필드를 노출해선 안된다.\n* 불변 필드라면 노출해도 덜위험 하지만 그래도 하지 말아라.\n* package-private 클래스, 톱 레벨 클래스에서는 노출하는 편이 나을 수도 있다. (글쎄..?)\n\n# 참고\n* Effective Java 3rd Edition - Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라\n","source":"_posts/effective-java-item16.md","raw":"---\ntitle: Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item16\ntypora-copy-images-to: effective-java-item16\ndate: 2019-01-20 17:53:54\nsubtitle:\nheader-img:\n---\n\n# 퇴보한 클래스\n```java\nclass Point {\n  public double x;\n  public double y;\n}\n```\n이런 클래스는 데이터 필드에 직접 접근하여 수정이 가능하다. 따라서 캡슐화의 이점을 제공하지 못한다. \n* API를 수정하지 않고는 내부 표현을 바꿀 수 없다.\n* 불변식을 보장할 수 없다.\n* 외부에서 필드에 접근할 때 부수 작업을 수행 할 수도 없다.\n  (예를들면, x값 조회 시, Comma case로 리턴하는 식의?)\n\n# 흔하게 만드는 캡슐레이션\n```java\nclass Point {\n  private double x;\n  private double y;\n\n  public Point (double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public double getX() { return x; }\n  public double getY() { return y; }\n\n  public void setX(double x) { this.x = x; }\n  public void setY(double y) { this.y = y; }\n}\n```\n* public 클래스라면 반드시 이정도의 접근자와 수정자를 만드는 정도는 해야된다.  \n* 클래스 내부 표현 방식을 언제든지 바꿀 수 있는 유연성을 제공해야 한다.\n* package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다해도 문제가 없다.\n  * 같은 패키지안에서 특정이유 때문에 사용하던가, 톱레벨 클래스에서만 접근 할 것이기 때문이다.\n\n# 요약\n* public 클래스는 절대 가변 필드를 노출해선 안된다.\n* 불변 필드라면 노출해도 덜위험 하지만 그래도 하지 말아라.\n* package-private 클래스, 톱 레벨 클래스에서는 노출하는 편이 나을 수도 있다. (글쎄..?)\n\n# 참고\n* Effective Java 3rd Edition - Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라\n","slug":"effective-java-item16","published":1,"updated":"2019-01-28T12:46:25.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2s4000ucr1tug53tbvg","content":"<h1 id=\"퇴보한-클래스\">퇴보한 클래스</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이런 클래스는 데이터 필드에 직접 접근하여 수정이 가능하다. 따라서 캡슐화의 이점을 제공하지 못한다.</p>\n<ul>\n<li>API를 수정하지 않고는 내부 표현을 바꿀 수 없다.</li>\n<li>불변식을 보장할 수 없다.</li>\n<li>외부에서 필드에 접근할 때 부수 작업을 수행 할 수도 없다.\n(예를들면, x값 조회 시, Comma case로 리턴하는 식의?)</li>\n</ul>\n<h1 id=\"흔하게-만드는-캡슐레이션\">흔하게 만드는 캡슐레이션</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span> <span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> x; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getY</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setX</span><span class=\"params\">(<span class=\"keyword\">double</span> x)</span> </span>&#123; <span class=\"keyword\">this</span>.x = x; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setY</span><span class=\"params\">(<span class=\"keyword\">double</span> y)</span> </span>&#123; <span class=\"keyword\">this</span>.y = y; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>public 클래스라면 반드시 이정도의 접근자와 수정자를 만드는 정도는 해야된다.</li>\n<li>클래스 내부 표현 방식을 언제든지 바꿀 수 있는 유연성을 제공해야 한다.</li>\n<li>package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다해도 문제가 없다.\n<ul>\n<li>같은 패키지안에서 특정이유 때문에 사용하던가, 톱레벨 클래스에서만 접근 할 것이기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"요약\">요약</h1>\n<ul>\n<li>public 클래스는 절대 가변 필드를 노출해선 안된다.</li>\n<li>불변 필드라면 노출해도 덜위험 하지만 그래도 하지 말아라.</li>\n<li>package-private 클래스, 톱 레벨 클래스에서는 노출하는 편이 나을 수도 있다. (글쎄..?)</li>\n</ul>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>퇴보한 클래스</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이런 클래스는 데이터 필드에 직접 접근하여 수정이 가능하다. 따라서 캡슐화의 이점을 제공하지 못한다.</p>\n<ul>\n<li>API를 수정하지 않고는 내부 표현을 바꿀 수 없다.</li>\n<li>불변식을 보장할 수 없다.</li>\n<li>외부에서 필드에 접근할 때 부수 작업을 수행 할 수도 없다.\n(예를들면, x값 조회 시, Comma case로 리턴하는 식의?)</li>\n</ul>\n<h1>흔하게 만드는 캡슐레이션</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span> <span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> x; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getY</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setX</span><span class=\"params\">(<span class=\"keyword\">double</span> x)</span> </span>&#123; <span class=\"keyword\">this</span>.x = x; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setY</span><span class=\"params\">(<span class=\"keyword\">double</span> y)</span> </span>&#123; <span class=\"keyword\">this</span>.y = y; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>public 클래스라면 반드시 이정도의 접근자와 수정자를 만드는 정도는 해야된다.</li>\n<li>클래스 내부 표현 방식을 언제든지 바꿀 수 있는 유연성을 제공해야 한다.</li>\n<li>package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다해도 문제가 없다.\n<ul>\n<li>같은 패키지안에서 특정이유 때문에 사용하던가, 톱레벨 클래스에서만 접근 할 것이기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<h1>요약</h1>\n<ul>\n<li>public 클래스는 절대 가변 필드를 노출해선 안된다.</li>\n<li>불변 필드라면 노출해도 덜위험 하지만 그래도 하지 말아라.</li>\n<li>package-private 클래스, 톱 레벨 클래스에서는 노출하는 편이 나을 수도 있다. (글쎄..?)</li>\n</ul>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라</li>\n</ul>\n"},{"title":"Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item2","typora-copy-images-to":"effective-java-item2","date":"2019-01-06T10:40:34.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\n정적 팩터리 메서드 팩터리와 생성자에는 똑같은 제약이 하나 있다.  \n선택적 매개변수가 많을 경우에 적절하게 대응하기 어렵다는 점이다.  \n매개변수가 3~4개까지는 어떻게 해보겠지만 엄청 많은 경우에는 생성자를 이용해 객체를 생성하는 과정부터가 곤욕이다.\n\n아래의 예시를 보자\n```java\n\nclass NutritionFacts {\n\n  private final int servingSize;\n  private final int servings;\n  private final int calories;\n  private final int fat;\n  private final int sodium;\n  private final int carbohydrate;\n\n  public NutritionFacts() {\n  }\n\n  public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbonhydrate) {\n    this.servingSize = servingSize;    //필수\n    this.servings = servings;          //필수\n    this.calories = calories;          //선택\n    this.fat = fat;                    //선택\n    this.sodium = sodium;              //선택\n    this.carbohydrate = carbohydrate;  //선택\n  }\n}\n```\n매개변수가 int만 6개로 이루어져 있다.  \n그리고 default value가 정해져 있지 않기 때문에, servingSize 같은 변수는 정의하기 싫으면 0으로 해야할 지, 아니면 최소값이 있을지 알기가 어렵다.  \n그리고 매개변수 선언 순서가 바뀌면 의도하지 않은 객체가 생성되기 때문에 코딩 할 때 매우 주의를 요해야 한다.\n\n# 점층적 생성자 패턴\n위와 같은 문제를 조금이나마 해결해 보려는 노력이 점층적 생성자 패턴이다.\n```java\nclass NutritionFacts {\n\n  private final int servingSize;\n  private final int servings;\n  private final int calories;\n  private final int fat;\n  private final int sodium;\n  private final int carbohydrate;\n\n  public NutritionFacts() {\n  }\n\n  public NutritionFacts(int servingSize, int servings) {\n    this.servingSize = servingSize;    //필수\n    this.servings = servings;          //필수\n  }\n\n   public NutritionFacts(int servingSize, int servings, int calories) {\n     this(servingSize, servings);\n     this.calories = calories;\n  }\n\n   public NutritionFacts(int servingSize, int servings, int calories, int fat) {\n     this(servingSize, servings, calories);\n     this.fat = fat;     \n  }\n\n  public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbonhydrate) {\n    this.servingSize = servingSize;    //필수\n    this.servings = servings;          //필수\n    this.calories = calories;          //선택\n    this.fat = fat;                    //선택\n    this.sodium = sodium;              //선택\n    this.carbohydrate = carbohydrate;  //선택\n  }\n}\n```\n\n이것도 선택사항에 대해 하나의 방법으로 작용할 수 있지만, 코드가 길어지고 가독성이 떨어지게 된다.  \n실제로 매개변수의 위치에 따라 의도하지 않은 객체가 생성될 수 있기 때문에 주의를 요해야 하는 코드이다.\n\n# Java Beans 패턴\n```java\nclass NutritionFacts {\n\n  private final int servingSize = -1; \n  private final int servings = -1;\n  private final int calories = 0;\n  private final int fat = 0;\n  private final int sodium = 0;\n  private final int carbohydrate = 0;\n\n  public NutritionFacts() {}\n\n  public void setServingSize(int servingSize) {\n    this.servingSize = servingSize;\n  }\n  public void setServings(int servings) {\n    this.servings = servings;\n  }\n  public void setCalories(int calories) {\n    this.calories = calories;\n  }\n  public void setFat(int fat) {\n    this.fat = fat;\n  }\n  public void setSodium(int sodium) {\n    this.sodium = sodium;\n  }\n  public void setCarboHydrate(int carbohydrate) {\n    this.carbohydrate = carbohydrate;\n  }\n```\n```java\n\nNutritionFacts nutritionFacts = new NutritionFacts();\n\nnutritionFacts.setServingSize(240);\nnutritionFacts.setServings(8);\nnutritionFacts.setCalories(100);\nnutritionFacts.setFat(20);\nnutritionFacts.setSodium(35);\nnutritionFacts.setCarboHydrate(27);\n```\n자바 빈즈 패턴에서는 객체 하나를 만드느느데 메서드를 여러개 호출 해야한다.  객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.  \n또한 객체의 불변셩이 깨지게 되어 코드에서 버그를 생성할 수 있다.\n\n# Builder 패턴\n```java\nclass NutritionFacts {\n\n  private final int servingSize;\n  private final int servings;\n  private final int calories;\n  private final int fat;\n  private final int sodium;\n  private final int carbohydrate;\n\n  public static class Builder {\n    private final int servingSize;\n    private final int servings;\n    private final int calories = 0;\n    private final int fat = 0;\n    private final int sodium = 0;\n    private final int carbohydrate = 0;\n\n    public Builder(int servingSize, int servings) {\n      this.servingSize = servingSize;    //필수\n      this.servings = servings;          //필수\n    }\n\n    public Builder calories(int calories) {\n      this.calories = calories;\n    }\n    public Builder fat(int fat) {\n      this.fat = fat;\n    }\n    public Builder sodium(int sodium) {\n      this.sodium = sodium;\n    }\n    public Builder carbohydrate(int carbohydrate) {\n      this.carbohydrate = carbohydrate;\n    }\n\n    public NutritionFacts build() {\n      return new NutritionFacts(this);\n    }\n\n    private NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbonhydrate) {\n      this.servingSize = servingSize;    //필수\n      this.servings = servings;          //필수\n      this.calories = calories;          //선택\n      this.fat = fat;                    //선택\n      this.sodium = sodium;              //선택\n      this.carbohydrate = carbohydrate;  //선택\n    }\n  }\n```\n\n```java\n  NutritionFacts nutritionFacts = new NutritionFacts.Builder(240, 8)\n                                                    .calories(100).sodium(35).carbohydrate(27).build()\n```\n빌더 패턴은 (파이썬과 스칼라에 있는) 명명된 선택적 매개변수를 흉내낸 것이다.  \n이런 식으로 하면 Java Beans 패턴의 set 역할을 해주면서 build()를 호출 하는 시점에 변수를 freezing 시켜 불변식을 유지 할 수 있다.\n하지만 시간이 지날 수록 매개 변수가 늘어날 가능성이 있음을 항상 주의 해야 한다.\n\n\n# 참고\n* Effective Java 3rd Edition - Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라","source":"_posts/effective-java-item2.md","raw":"---\ntitle: Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item2\ntypora-copy-images-to: effective-java-item2\ndate: 2019-01-06 19:40:34\nsubtitle:\nheader-img:\n---\n\n# 서론\n정적 팩터리 메서드 팩터리와 생성자에는 똑같은 제약이 하나 있다.  \n선택적 매개변수가 많을 경우에 적절하게 대응하기 어렵다는 점이다.  \n매개변수가 3~4개까지는 어떻게 해보겠지만 엄청 많은 경우에는 생성자를 이용해 객체를 생성하는 과정부터가 곤욕이다.\n\n아래의 예시를 보자\n```java\n\nclass NutritionFacts {\n\n  private final int servingSize;\n  private final int servings;\n  private final int calories;\n  private final int fat;\n  private final int sodium;\n  private final int carbohydrate;\n\n  public NutritionFacts() {\n  }\n\n  public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbonhydrate) {\n    this.servingSize = servingSize;    //필수\n    this.servings = servings;          //필수\n    this.calories = calories;          //선택\n    this.fat = fat;                    //선택\n    this.sodium = sodium;              //선택\n    this.carbohydrate = carbohydrate;  //선택\n  }\n}\n```\n매개변수가 int만 6개로 이루어져 있다.  \n그리고 default value가 정해져 있지 않기 때문에, servingSize 같은 변수는 정의하기 싫으면 0으로 해야할 지, 아니면 최소값이 있을지 알기가 어렵다.  \n그리고 매개변수 선언 순서가 바뀌면 의도하지 않은 객체가 생성되기 때문에 코딩 할 때 매우 주의를 요해야 한다.\n\n# 점층적 생성자 패턴\n위와 같은 문제를 조금이나마 해결해 보려는 노력이 점층적 생성자 패턴이다.\n```java\nclass NutritionFacts {\n\n  private final int servingSize;\n  private final int servings;\n  private final int calories;\n  private final int fat;\n  private final int sodium;\n  private final int carbohydrate;\n\n  public NutritionFacts() {\n  }\n\n  public NutritionFacts(int servingSize, int servings) {\n    this.servingSize = servingSize;    //필수\n    this.servings = servings;          //필수\n  }\n\n   public NutritionFacts(int servingSize, int servings, int calories) {\n     this(servingSize, servings);\n     this.calories = calories;\n  }\n\n   public NutritionFacts(int servingSize, int servings, int calories, int fat) {\n     this(servingSize, servings, calories);\n     this.fat = fat;     \n  }\n\n  public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbonhydrate) {\n    this.servingSize = servingSize;    //필수\n    this.servings = servings;          //필수\n    this.calories = calories;          //선택\n    this.fat = fat;                    //선택\n    this.sodium = sodium;              //선택\n    this.carbohydrate = carbohydrate;  //선택\n  }\n}\n```\n\n이것도 선택사항에 대해 하나의 방법으로 작용할 수 있지만, 코드가 길어지고 가독성이 떨어지게 된다.  \n실제로 매개변수의 위치에 따라 의도하지 않은 객체가 생성될 수 있기 때문에 주의를 요해야 하는 코드이다.\n\n# Java Beans 패턴\n```java\nclass NutritionFacts {\n\n  private final int servingSize = -1; \n  private final int servings = -1;\n  private final int calories = 0;\n  private final int fat = 0;\n  private final int sodium = 0;\n  private final int carbohydrate = 0;\n\n  public NutritionFacts() {}\n\n  public void setServingSize(int servingSize) {\n    this.servingSize = servingSize;\n  }\n  public void setServings(int servings) {\n    this.servings = servings;\n  }\n  public void setCalories(int calories) {\n    this.calories = calories;\n  }\n  public void setFat(int fat) {\n    this.fat = fat;\n  }\n  public void setSodium(int sodium) {\n    this.sodium = sodium;\n  }\n  public void setCarboHydrate(int carbohydrate) {\n    this.carbohydrate = carbohydrate;\n  }\n```\n```java\n\nNutritionFacts nutritionFacts = new NutritionFacts();\n\nnutritionFacts.setServingSize(240);\nnutritionFacts.setServings(8);\nnutritionFacts.setCalories(100);\nnutritionFacts.setFat(20);\nnutritionFacts.setSodium(35);\nnutritionFacts.setCarboHydrate(27);\n```\n자바 빈즈 패턴에서는 객체 하나를 만드느느데 메서드를 여러개 호출 해야한다.  객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.  \n또한 객체의 불변셩이 깨지게 되어 코드에서 버그를 생성할 수 있다.\n\n# Builder 패턴\n```java\nclass NutritionFacts {\n\n  private final int servingSize;\n  private final int servings;\n  private final int calories;\n  private final int fat;\n  private final int sodium;\n  private final int carbohydrate;\n\n  public static class Builder {\n    private final int servingSize;\n    private final int servings;\n    private final int calories = 0;\n    private final int fat = 0;\n    private final int sodium = 0;\n    private final int carbohydrate = 0;\n\n    public Builder(int servingSize, int servings) {\n      this.servingSize = servingSize;    //필수\n      this.servings = servings;          //필수\n    }\n\n    public Builder calories(int calories) {\n      this.calories = calories;\n    }\n    public Builder fat(int fat) {\n      this.fat = fat;\n    }\n    public Builder sodium(int sodium) {\n      this.sodium = sodium;\n    }\n    public Builder carbohydrate(int carbohydrate) {\n      this.carbohydrate = carbohydrate;\n    }\n\n    public NutritionFacts build() {\n      return new NutritionFacts(this);\n    }\n\n    private NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbonhydrate) {\n      this.servingSize = servingSize;    //필수\n      this.servings = servings;          //필수\n      this.calories = calories;          //선택\n      this.fat = fat;                    //선택\n      this.sodium = sodium;              //선택\n      this.carbohydrate = carbohydrate;  //선택\n    }\n  }\n```\n\n```java\n  NutritionFacts nutritionFacts = new NutritionFacts.Builder(240, 8)\n                                                    .calories(100).sodium(35).carbohydrate(27).build()\n```\n빌더 패턴은 (파이썬과 스칼라에 있는) 명명된 선택적 매개변수를 흉내낸 것이다.  \n이런 식으로 하면 Java Beans 패턴의 set 역할을 해주면서 build()를 호출 하는 시점에 변수를 freezing 시켜 불변식을 유지 할 수 있다.\n하지만 시간이 지날 수록 매개 변수가 늘어날 가능성이 있음을 항상 주의 해야 한다.\n\n\n# 참고\n* Effective Java 3rd Edition - Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라","slug":"effective-java-item2","published":1,"updated":"2019-01-07T13:32:09.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2s5000wcr1tnbjymsd5","content":"<h1 id=\"서론\">서론</h1>\n<p>정적 팩터리 메서드 팩터리와 생성자에는 똑같은 제약이 하나 있다.<br>\n선택적 매개변수가 많을 경우에 적절하게 대응하기 어렵다는 점이다.<br>\n매개변수가 3~4개까지는 어떻게 해보겠지만 엄청 많은 경우에는 생성자를 이용해 객체를 생성하는 과정부터가 곤욕이다.</p>\n<p>아래의 예시를 보자\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NutritionFacts</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories, <span class=\"keyword\">int</span> fat, <span class=\"keyword\">int</span> sodium, <span class=\"keyword\">int</span> carbonhydrate)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servingSize = servingSize;    <span class=\"comment\">//필수</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servings = servings;          <span class=\"comment\">//필수</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.calories = calories;          <span class=\"comment\">//선택</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fat = fat;                    <span class=\"comment\">//선택</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sodium = sodium;              <span class=\"comment\">//선택</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.carbohydrate = carbohydrate;  <span class=\"comment\">//선택</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>매개변수가 int만 6개로 이루어져 있다.<br>\n그리고 default value가 정해져 있지 않기 때문에, servingSize 같은 변수는 정의하기 싫으면 0으로 해야할 지, 아니면 최소값이 있을지 알기가 어렵다.<br>\n그리고 매개변수 선언 순서가 바뀌면 의도하지 않은 객체가 생성되기 때문에 코딩 할 때 매우 주의를 요해야 한다.</p>\n<h1 id=\"점층적-생성자-패턴\">점층적 생성자 패턴</h1>\n<p>위와 같은 문제를 조금이나마 해결해 보려는 노력이 점층적 생성자 패턴이다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NutritionFacts</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servingSize = servingSize;    <span class=\"comment\">//필수</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servings = servings;          <span class=\"comment\">//필수</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>(servingSize, servings);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.calories = calories;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories, <span class=\"keyword\">int</span> fat)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>(servingSize, servings, calories);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.fat = fat;     </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories, <span class=\"keyword\">int</span> fat, <span class=\"keyword\">int</span> sodium, <span class=\"keyword\">int</span> carbonhydrate)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servingSize = servingSize;    <span class=\"comment\">//필수</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servings = servings;          <span class=\"comment\">//필수</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.calories = calories;          <span class=\"comment\">//선택</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fat = fat;                    <span class=\"comment\">//선택</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sodium = sodium;              <span class=\"comment\">//선택</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.carbohydrate = carbohydrate;  <span class=\"comment\">//선택</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이것도 선택사항에 대해 하나의 방법으로 작용할 수 있지만, 코드가 길어지고 가독성이 떨어지게 된다.<br>\n실제로 매개변수의 위치에 따라 의도하지 않은 객체가 생성될 수 있기 때문에 주의를 요해야 하는 코드이다.</p>\n<h1 id=\"java-beans-패턴\">Java Beans 패턴</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NutritionFacts</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize = -<span class=\"number\">1</span>; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setServingSize</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servingSize = servingSize;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setServings</span><span class=\"params\">(<span class=\"keyword\">int</span> servings)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servings = servings;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCalories</span><span class=\"params\">(<span class=\"keyword\">int</span> calories)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.calories = calories;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFat</span><span class=\"params\">(<span class=\"keyword\">int</span> fat)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fat = fat;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSodium</span><span class=\"params\">(<span class=\"keyword\">int</span> sodium)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sodium = sodium;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCarboHydrate</span><span class=\"params\">(<span class=\"keyword\">int</span> carbohydrate)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.carbohydrate = carbohydrate;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">NutritionFacts nutritionFacts = <span class=\"keyword\">new</span> NutritionFacts();</span><br><span class=\"line\"></span><br><span class=\"line\">nutritionFacts.setServingSize(<span class=\"number\">240</span>);</span><br><span class=\"line\">nutritionFacts.setServings(<span class=\"number\">8</span>);</span><br><span class=\"line\">nutritionFacts.setCalories(<span class=\"number\">100</span>);</span><br><span class=\"line\">nutritionFacts.setFat(<span class=\"number\">20</span>);</span><br><span class=\"line\">nutritionFacts.setSodium(<span class=\"number\">35</span>);</span><br><span class=\"line\">nutritionFacts.setCarboHydrate(<span class=\"number\">27</span>);</span><br></pre></td></tr></table></figure></p>\n<p>자바 빈즈 패턴에서는 객체 하나를 만드느느데 메서드를 여러개 호출 해야한다.  객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.<br>\n또한 객체의 불변셩이 깨지게 되어 코드에서 버그를 생성할 수 있다.</p>\n<h1 id=\"builder-패턴\">Builder 패턴</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NutritionFacts</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.servingSize = servingSize;    <span class=\"comment\">//필수</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.servings = servings;          <span class=\"comment\">//필수</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">calories</span><span class=\"params\">(<span class=\"keyword\">int</span> calories)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.calories = calories;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">fat</span><span class=\"params\">(<span class=\"keyword\">int</span> fat)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.fat = fat;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">sodium</span><span class=\"params\">(<span class=\"keyword\">int</span> sodium)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sodium = sodium;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">carbohydrate</span><span class=\"params\">(<span class=\"keyword\">int</span> carbohydrate)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.carbohydrate = carbohydrate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> NutritionFacts <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NutritionFacts(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories, <span class=\"keyword\">int</span> fat, <span class=\"keyword\">int</span> sodium, <span class=\"keyword\">int</span> carbonhydrate)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.servingSize = servingSize;    <span class=\"comment\">//필수</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.servings = servings;          <span class=\"comment\">//필수</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.calories = calories;          <span class=\"comment\">//선택</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.fat = fat;                    <span class=\"comment\">//선택</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sodium = sodium;              <span class=\"comment\">//선택</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.carbohydrate = carbohydrate;  <span class=\"comment\">//선택</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NutritionFacts nutritionFacts = <span class=\"keyword\">new</span> NutritionFacts.Builder(<span class=\"number\">240</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">                                                  .calories(<span class=\"number\">100</span>).sodium(<span class=\"number\">35</span>).carbohydrate(<span class=\"number\">27</span>).build()</span><br></pre></td></tr></table></figure></p>\n<p>빌더 패턴은 (파이썬과 스칼라에 있는) 명명된 선택적 매개변수를 흉내낸 것이다.<br>\n이런 식으로 하면 Java Beans 패턴의 set 역할을 해주면서 build()를 호출 하는 시점에 변수를 freezing 시켜 불변식을 유지 할 수 있다.\n하지만 시간이 지날 수록 매개 변수가 늘어날 가능성이 있음을 항상 주의 해야 한다.</p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>정적 팩터리 메서드 팩터리와 생성자에는 똑같은 제약이 하나 있다.<br>\n선택적 매개변수가 많을 경우에 적절하게 대응하기 어렵다는 점이다.<br>\n매개변수가 3~4개까지는 어떻게 해보겠지만 엄청 많은 경우에는 생성자를 이용해 객체를 생성하는 과정부터가 곤욕이다.</p>\n<p>아래의 예시를 보자\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NutritionFacts</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories, <span class=\"keyword\">int</span> fat, <span class=\"keyword\">int</span> sodium, <span class=\"keyword\">int</span> carbonhydrate)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servingSize = servingSize;    <span class=\"comment\">//필수</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servings = servings;          <span class=\"comment\">//필수</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.calories = calories;          <span class=\"comment\">//선택</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fat = fat;                    <span class=\"comment\">//선택</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sodium = sodium;              <span class=\"comment\">//선택</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.carbohydrate = carbohydrate;  <span class=\"comment\">//선택</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>매개변수가 int만 6개로 이루어져 있다.<br>\n그리고 default value가 정해져 있지 않기 때문에, servingSize 같은 변수는 정의하기 싫으면 0으로 해야할 지, 아니면 최소값이 있을지 알기가 어렵다.<br>\n그리고 매개변수 선언 순서가 바뀌면 의도하지 않은 객체가 생성되기 때문에 코딩 할 때 매우 주의를 요해야 한다.</p>\n<h1>점층적 생성자 패턴</h1>\n<p>위와 같은 문제를 조금이나마 해결해 보려는 노력이 점층적 생성자 패턴이다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NutritionFacts</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servingSize = servingSize;    <span class=\"comment\">//필수</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servings = servings;          <span class=\"comment\">//필수</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>(servingSize, servings);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.calories = calories;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories, <span class=\"keyword\">int</span> fat)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>(servingSize, servings, calories);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.fat = fat;     </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories, <span class=\"keyword\">int</span> fat, <span class=\"keyword\">int</span> sodium, <span class=\"keyword\">int</span> carbonhydrate)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servingSize = servingSize;    <span class=\"comment\">//필수</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servings = servings;          <span class=\"comment\">//필수</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.calories = calories;          <span class=\"comment\">//선택</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fat = fat;                    <span class=\"comment\">//선택</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sodium = sodium;              <span class=\"comment\">//선택</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.carbohydrate = carbohydrate;  <span class=\"comment\">//선택</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이것도 선택사항에 대해 하나의 방법으로 작용할 수 있지만, 코드가 길어지고 가독성이 떨어지게 된다.<br>\n실제로 매개변수의 위치에 따라 의도하지 않은 객체가 생성될 수 있기 때문에 주의를 요해야 하는 코드이다.</p>\n<h1>Java Beans 패턴</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NutritionFacts</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize = -<span class=\"number\">1</span>; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setServingSize</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servingSize = servingSize;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setServings</span><span class=\"params\">(<span class=\"keyword\">int</span> servings)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.servings = servings;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCalories</span><span class=\"params\">(<span class=\"keyword\">int</span> calories)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.calories = calories;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFat</span><span class=\"params\">(<span class=\"keyword\">int</span> fat)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fat = fat;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSodium</span><span class=\"params\">(<span class=\"keyword\">int</span> sodium)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sodium = sodium;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCarboHydrate</span><span class=\"params\">(<span class=\"keyword\">int</span> carbohydrate)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.carbohydrate = carbohydrate;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">NutritionFacts nutritionFacts = <span class=\"keyword\">new</span> NutritionFacts();</span><br><span class=\"line\"></span><br><span class=\"line\">nutritionFacts.setServingSize(<span class=\"number\">240</span>);</span><br><span class=\"line\">nutritionFacts.setServings(<span class=\"number\">8</span>);</span><br><span class=\"line\">nutritionFacts.setCalories(<span class=\"number\">100</span>);</span><br><span class=\"line\">nutritionFacts.setFat(<span class=\"number\">20</span>);</span><br><span class=\"line\">nutritionFacts.setSodium(<span class=\"number\">35</span>);</span><br><span class=\"line\">nutritionFacts.setCarboHydrate(<span class=\"number\">27</span>);</span><br></pre></td></tr></table></figure></p>\n<p>자바 빈즈 패턴에서는 객체 하나를 만드느느데 메서드를 여러개 호출 해야한다.  객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.<br>\n또한 객체의 불변셩이 깨지게 되어 코드에서 버그를 생성할 수 있다.</p>\n<h1>Builder 패턴</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NutritionFacts</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.servingSize = servingSize;    <span class=\"comment\">//필수</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.servings = servings;          <span class=\"comment\">//필수</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">calories</span><span class=\"params\">(<span class=\"keyword\">int</span> calories)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.calories = calories;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">fat</span><span class=\"params\">(<span class=\"keyword\">int</span> fat)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.fat = fat;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">sodium</span><span class=\"params\">(<span class=\"keyword\">int</span> sodium)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sodium = sodium;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">carbohydrate</span><span class=\"params\">(<span class=\"keyword\">int</span> carbohydrate)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.carbohydrate = carbohydrate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> NutritionFacts <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NutritionFacts(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories, <span class=\"keyword\">int</span> fat, <span class=\"keyword\">int</span> sodium, <span class=\"keyword\">int</span> carbonhydrate)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.servingSize = servingSize;    <span class=\"comment\">//필수</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.servings = servings;          <span class=\"comment\">//필수</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.calories = calories;          <span class=\"comment\">//선택</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.fat = fat;                    <span class=\"comment\">//선택</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sodium = sodium;              <span class=\"comment\">//선택</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.carbohydrate = carbohydrate;  <span class=\"comment\">//선택</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NutritionFacts nutritionFacts = <span class=\"keyword\">new</span> NutritionFacts.Builder(<span class=\"number\">240</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">                                                  .calories(<span class=\"number\">100</span>).sodium(<span class=\"number\">35</span>).carbohydrate(<span class=\"number\">27</span>).build()</span><br></pre></td></tr></table></figure></p>\n<p>빌더 패턴은 (파이썬과 스칼라에 있는) 명명된 선택적 매개변수를 흉내낸 것이다.<br>\n이런 식으로 하면 Java Beans 패턴의 set 역할을 해주면서 build()를 호출 하는 시점에 변수를 freezing 시켜 불변식을 유지 할 수 있다.\n하지만 시간이 지날 수록 매개 변수가 늘어날 가능성이 있음을 항상 주의 해야 한다.</p>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라</li>\n</ul>\n"},{"title":"Item 17. 변경 가능성을 최소화하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item17","typora-copy-images-to":"effective-java-item17","date":"2019-01-20T08:53:58.000Z","subtitle":null,"header-img":null,"_content":"\n# 불변 클래스(immutable class)란?\n* 인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다.  \n* 불변 클래스의 인스턴스는 객체가 생성되는 시점에 초기화되고 소멸이 될 때까지 값이 변경되지 않는다.  \n* 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉽다.\n* 값이 변경되지 않으니 오류가 발생할 일도 적고 안전하다.\n\n# 불변 클래스를 만들기 위한 5가지 조건\n## 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.\n* 쉽게 말해 setter나, 필드 정보를 변경하는 메서드를 제공하지 않는다.\n## 클래스를 확장 할 수 없도록 한다.\n* 클래스를 final로 선언한다.\n* 모든 생성자는 private으로 만들고 생성자 정적 팩터리 메서드를 제공한다.\n* 정적 팩터리 메서드는 유연성을 제공한다.\n* 다음 릴리즈에서 Boolean처럼 `캐싱`을 이용해 성능을 끌어올릴 수도 있다.\n\n```java\n@NoArgsConstructor(access = AccessLevel.PRIVATE)\n@AllArgsConstructor(access = AccessLevel.PRIVATE, staticName=\"of\")\npublic class Member {\n  private String name;\n  private int age;\n}\n```\n## 모든 필드를 final로 선언한다.\n```java\n@AllArgsConstructor(access = AccessLevel.PRIVATE, staticName=\"of\")\npublic class Member {\n  private final String name;\n  private final int age;\n}\n```\n* 필드에 대해 수정을 막겠다는 설계자의 의도를 보여준다. - final클래스는 생성자에서 딱 `1회 초기화` 할 수 있기 때문이다.\n* 인스턴스에 대한 동기화(syncronized)처리 없이도 다른 스레드에서 문제없이 처리 된다.\n\n## 모든 필드를 private로 선언한다.\n* 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근하여 수정하는 일을 막는다.\n* public final로만 처리해도 되지만, 그 안의 내용을 바꿀 수 있고 다 릴리즈에서 내부 표현을 변경하지 못하므로 사용하지 않는게 좋다.\n\n## 자신(객체) 이외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.\n* 클라이언트에서 인스턴스 내에 가변 객체의 참조를 얻을 수 없게 해야한다. - Collection에 대한 getter를 제공하면 안된다!\n* 생성자, 접근자(getter), readObject 메서드에서 모두 `방어적 복사`를 수행해야 한다.\n\n# 함수형 프로그래밍\n* 피연산자에 함수를 적용해 결과를 반환하는 프로그래밍 기법\n* 피연산자에 대해 연산하지만 피연산자는 값이 변하지 않음 \n(캡처 - 피연산자는 사실상 final)\n* 코드의 불변이 영역이 되는 비율이 높아져 안전하다.\n\n# 불변 객체의 장점\n* 불변 객체는 생성 시점부터 소멸될 때 까지 변하지 않는다. - 서비스 로직에 더 안전하다.\n* 불변 객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요가 없다. - 스레드에 따라 값이 변하지 않기 때문이다.\n* 불변 객체는 안심하고 공유 할 수 있다. - 불변 클래스라면 최대한 재사용 하라 (캐싱)\n* 불변 객체는 방어적 복사본이 필요없다 - 바뀌지 않으므로 방어할 일이 없다.\n* 불변 객체는 clone메서드를 제공하지 않는게 좋다. - 의미가 없다.\n* 불변 객체를 key로 하면 이점이 많다.\n  * Map의 key\n  * Set의 원소\n* 불변 객체는 그 자체로 실패 원자성을 제공한다.\n  * 메서드에서 예외가 발생하더라도 객체의 변경내용이 없다.\n* 불변 객체끼리는 자유롭게 내부 데이터를 공유 할 수 있다.\n  * BigInteger 클래스에서 mag는 크기를 나타내는 배열\n  * signum은 부호를 나타내는 int 필드\n  * mag는 배열이지만 불변이므로 방어적 복사본을 만들지 않고 원래 객체의 mag를 써도 된다.\n  \n```java\n    /**\n     * Returns a BigInteger whose value is {@code (-this)}.\n     *\n     * @return {@code -this}\n     */\n    public BigInteger negate() {\n        return new BigInteger(this.mag, -this.signum);\n    }\n```\n* 불변 객체는 값이 다르면 반드시 독립된 객체로 만들어야 한다.\n\n# 요약\n* 접근자(getter)를 제공한다고 습관처럼 수정자(setter)를 만들지 말자\n  * 꼭 필요한 경우가 아니라면 클래스는 불변이어야 한다.\n  * 장점이 훨씬많고, 단점이라면 잠재적 성능저하 뿐이다.\n* 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한 줄이자\n  * 객체가 가질 수 있는 상태를 제한하면, 예외를 예측하기 쉽고, 오류가 생길 가능성이 줄어든다.\n  * 꼭 변경할 필드가 아닌 필드는 final로 선언하자 - 웬만하면 final로 해야한다.\n* 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.\n  * 확실한 이유가 없다면, 생성자와 정적팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안된다.\n  * 특히! 객체를 재활용할 목적으로 상태를 다시 초기화 하는 메서드도 안된다.\n  * 복잡성만 커지고 성능 이점은 거의 없다.\n\n# 참고\n* Effective Java 3rd Edition - Item 17. 변경 가능성을 최소화하라","source":"_posts/effective-java-item17.md","raw":"---\ntitle: Item 17. 변경 가능성을 최소화하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item17\ntypora-copy-images-to: effective-java-item17\ndate: 2019-01-20 17:53:58\nsubtitle:\nheader-img:\n---\n\n# 불변 클래스(immutable class)란?\n* 인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다.  \n* 불변 클래스의 인스턴스는 객체가 생성되는 시점에 초기화되고 소멸이 될 때까지 값이 변경되지 않는다.  \n* 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉽다.\n* 값이 변경되지 않으니 오류가 발생할 일도 적고 안전하다.\n\n# 불변 클래스를 만들기 위한 5가지 조건\n## 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.\n* 쉽게 말해 setter나, 필드 정보를 변경하는 메서드를 제공하지 않는다.\n## 클래스를 확장 할 수 없도록 한다.\n* 클래스를 final로 선언한다.\n* 모든 생성자는 private으로 만들고 생성자 정적 팩터리 메서드를 제공한다.\n* 정적 팩터리 메서드는 유연성을 제공한다.\n* 다음 릴리즈에서 Boolean처럼 `캐싱`을 이용해 성능을 끌어올릴 수도 있다.\n\n```java\n@NoArgsConstructor(access = AccessLevel.PRIVATE)\n@AllArgsConstructor(access = AccessLevel.PRIVATE, staticName=\"of\")\npublic class Member {\n  private String name;\n  private int age;\n}\n```\n## 모든 필드를 final로 선언한다.\n```java\n@AllArgsConstructor(access = AccessLevel.PRIVATE, staticName=\"of\")\npublic class Member {\n  private final String name;\n  private final int age;\n}\n```\n* 필드에 대해 수정을 막겠다는 설계자의 의도를 보여준다. - final클래스는 생성자에서 딱 `1회 초기화` 할 수 있기 때문이다.\n* 인스턴스에 대한 동기화(syncronized)처리 없이도 다른 스레드에서 문제없이 처리 된다.\n\n## 모든 필드를 private로 선언한다.\n* 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근하여 수정하는 일을 막는다.\n* public final로만 처리해도 되지만, 그 안의 내용을 바꿀 수 있고 다 릴리즈에서 내부 표현을 변경하지 못하므로 사용하지 않는게 좋다.\n\n## 자신(객체) 이외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.\n* 클라이언트에서 인스턴스 내에 가변 객체의 참조를 얻을 수 없게 해야한다. - Collection에 대한 getter를 제공하면 안된다!\n* 생성자, 접근자(getter), readObject 메서드에서 모두 `방어적 복사`를 수행해야 한다.\n\n# 함수형 프로그래밍\n* 피연산자에 함수를 적용해 결과를 반환하는 프로그래밍 기법\n* 피연산자에 대해 연산하지만 피연산자는 값이 변하지 않음 \n(캡처 - 피연산자는 사실상 final)\n* 코드의 불변이 영역이 되는 비율이 높아져 안전하다.\n\n# 불변 객체의 장점\n* 불변 객체는 생성 시점부터 소멸될 때 까지 변하지 않는다. - 서비스 로직에 더 안전하다.\n* 불변 객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요가 없다. - 스레드에 따라 값이 변하지 않기 때문이다.\n* 불변 객체는 안심하고 공유 할 수 있다. - 불변 클래스라면 최대한 재사용 하라 (캐싱)\n* 불변 객체는 방어적 복사본이 필요없다 - 바뀌지 않으므로 방어할 일이 없다.\n* 불변 객체는 clone메서드를 제공하지 않는게 좋다. - 의미가 없다.\n* 불변 객체를 key로 하면 이점이 많다.\n  * Map의 key\n  * Set의 원소\n* 불변 객체는 그 자체로 실패 원자성을 제공한다.\n  * 메서드에서 예외가 발생하더라도 객체의 변경내용이 없다.\n* 불변 객체끼리는 자유롭게 내부 데이터를 공유 할 수 있다.\n  * BigInteger 클래스에서 mag는 크기를 나타내는 배열\n  * signum은 부호를 나타내는 int 필드\n  * mag는 배열이지만 불변이므로 방어적 복사본을 만들지 않고 원래 객체의 mag를 써도 된다.\n  \n```java\n    /**\n     * Returns a BigInteger whose value is {@code (-this)}.\n     *\n     * @return {@code -this}\n     */\n    public BigInteger negate() {\n        return new BigInteger(this.mag, -this.signum);\n    }\n```\n* 불변 객체는 값이 다르면 반드시 독립된 객체로 만들어야 한다.\n\n# 요약\n* 접근자(getter)를 제공한다고 습관처럼 수정자(setter)를 만들지 말자\n  * 꼭 필요한 경우가 아니라면 클래스는 불변이어야 한다.\n  * 장점이 훨씬많고, 단점이라면 잠재적 성능저하 뿐이다.\n* 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한 줄이자\n  * 객체가 가질 수 있는 상태를 제한하면, 예외를 예측하기 쉽고, 오류가 생길 가능성이 줄어든다.\n  * 꼭 변경할 필드가 아닌 필드는 final로 선언하자 - 웬만하면 final로 해야한다.\n* 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.\n  * 확실한 이유가 없다면, 생성자와 정적팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안된다.\n  * 특히! 객체를 재활용할 목적으로 상태를 다시 초기화 하는 메서드도 안된다.\n  * 복잡성만 커지고 성능 이점은 거의 없다.\n\n# 참고\n* Effective Java 3rd Edition - Item 17. 변경 가능성을 최소화하라","slug":"effective-java-item17","published":1,"updated":"2019-01-28T12:46:25.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2s6000zcr1thilkibt4","content":"<h1 id=\"불변-클래스immutable-class란\">불변 클래스(immutable class)란?</h1>\n<ul>\n<li>인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다.</li>\n<li>불변 클래스의 인스턴스는 객체가 생성되는 시점에 초기화되고 소멸이 될 때까지 값이 변경되지 않는다.</li>\n<li>불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉽다.</li>\n<li>값이 변경되지 않으니 오류가 발생할 일도 적고 안전하다.</li>\n</ul>\n<h1 id=\"불변-클래스를-만들기-위한-5가지-조건\">불변 클래스를 만들기 위한 5가지 조건</h1>\n<h2 id=\"객체의-상태를-변경하는-메서드변경자를-제공하지-않는다\">객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.</h2>\n<ul>\n<li>쉽게 말해 setter나, 필드 정보를 변경하는 메서드를 제공하지 않는다.</li>\n</ul>\n<h2 id=\"클래스를-확장-할-수-없도록-한다\">클래스를 확장 할 수 없도록 한다.</h2>\n<ul>\n<li>클래스를 final로 선언한다.</li>\n<li>모든 생성자는 private으로 만들고 생성자 정적 팩터리 메서드를 제공한다.</li>\n<li>정적 팩터리 메서드는 유연성을 제공한다.</li>\n<li>다음 릴리즈에서 Boolean처럼 <code>캐싱</code>을 이용해 성능을 끌어올릴 수도 있다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span>(access = AccessLevel.PRIVATE, staticName=<span class=\"string\">\"of\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"모든-필드를-final로-선언한다\">모든 필드를 final로 선언한다.</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span>(access = AccessLevel.PRIVATE, staticName=<span class=\"string\">\"of\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>필드에 대해 수정을 막겠다는 설계자의 의도를 보여준다. - final클래스는 생성자에서 딱 <code>1회 초기화</code> 할 수 있기 때문이다.</li>\n<li>인스턴스에 대한 동기화(syncronized)처리 없이도 다른 스레드에서 문제없이 처리 된다.</li>\n</ul>\n<h2 id=\"모든-필드를-private로-선언한다\">모든 필드를 private로 선언한다.</h2>\n<ul>\n<li>필드가 참조하는 가변 객체를 클라이언트에서 직접 접근하여 수정하는 일을 막는다.</li>\n<li>public final로만 처리해도 되지만, 그 안의 내용을 바꿀 수 있고 다 릴리즈에서 내부 표현을 변경하지 못하므로 사용하지 않는게 좋다.</li>\n</ul>\n<h2 id=\"자신객체-이외에는-내부의-가변-컴포넌트에-접근-할-수-없도록-한다\">자신(객체) 이외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.</h2>\n<ul>\n<li>클라이언트에서 인스턴스 내에 가변 객체의 참조를 얻을 수 없게 해야한다. - Collection에 대한 getter를 제공하면 안된다!</li>\n<li>생성자, 접근자(getter), readObject 메서드에서 모두 <code>방어적 복사</code>를 수행해야 한다.</li>\n</ul>\n<h1 id=\"함수형-프로그래밍\">함수형 프로그래밍</h1>\n<ul>\n<li>피연산자에 함수를 적용해 결과를 반환하는 프로그래밍 기법</li>\n<li>피연산자에 대해 연산하지만 피연산자는 값이 변하지 않음\n(캡처 - 피연산자는 사실상 final)</li>\n<li>코드의 불변이 영역이 되는 비율이 높아져 안전하다.</li>\n</ul>\n<h1 id=\"불변-객체의-장점\">불변 객체의 장점</h1>\n<ul>\n<li>불변 객체는 생성 시점부터 소멸될 때 까지 변하지 않는다. - 서비스 로직에 더 안전하다.</li>\n<li>불변 객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요가 없다. - 스레드에 따라 값이 변하지 않기 때문이다.</li>\n<li>불변 객체는 안심하고 공유 할 수 있다. - 불변 클래스라면 최대한 재사용 하라 (캐싱)</li>\n<li>불변 객체는 방어적 복사본이 필요없다 - 바뀌지 않으므로 방어할 일이 없다.</li>\n<li>불변 객체는 clone메서드를 제공하지 않는게 좋다. - 의미가 없다.</li>\n<li>불변 객체를 key로 하면 이점이 많다.\n<ul>\n<li>Map의 key</li>\n<li>Set의 원소</li>\n</ul>\n</li>\n<li>불변 객체는 그 자체로 실패 원자성을 제공한다.\n<ul>\n<li>메서드에서 예외가 발생하더라도 객체의 변경내용이 없다.</li>\n</ul>\n</li>\n<li>불변 객체끼리는 자유롭게 내부 데이터를 공유 할 수 있다.\n<ul>\n<li>BigInteger 클래스에서 mag는 크기를 나타내는 배열</li>\n<li>signum은 부호를 나타내는 int 필드</li>\n<li>mag는 배열이지만 불변이므로 방어적 복사본을 만들지 않고 원래 객체의 mag를 써도 된다.</li>\n</ul>\n</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a BigInteger whose value is &#123;<span class=\"doctag\">@code</span> (-this)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> -this&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> BigInteger <span class=\"title\">negate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BigInteger(<span class=\"keyword\">this</span>.mag, -<span class=\"keyword\">this</span>.signum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>불변 객체는 값이 다르면 반드시 독립된 객체로 만들어야 한다.</li>\n</ul>\n<h1 id=\"요약\">요약</h1>\n<ul>\n<li>접근자(getter)를 제공한다고 습관처럼 수정자(setter)를 만들지 말자\n<ul>\n<li>꼭 필요한 경우가 아니라면 클래스는 불변이어야 한다.</li>\n<li>장점이 훨씬많고, 단점이라면 잠재적 성능저하 뿐이다.</li>\n</ul>\n</li>\n<li>불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한 줄이자\n<ul>\n<li>객체가 가질 수 있는 상태를 제한하면, 예외를 예측하기 쉽고, 오류가 생길 가능성이 줄어든다.</li>\n<li>꼭 변경할 필드가 아닌 필드는 final로 선언하자 - 웬만하면 final로 해야한다.</li>\n</ul>\n</li>\n<li>생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.\n<ul>\n<li>확실한 이유가 없다면, 생성자와 정적팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안된다.</li>\n<li>특히! 객체를 재활용할 목적으로 상태를 다시 초기화 하는 메서드도 안된다.</li>\n<li>복잡성만 커지고 성능 이점은 거의 없다.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 17. 변경 가능성을 최소화하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>불변 클래스(immutable class)란?</h1>\n<ul>\n<li>인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다.</li>\n<li>불변 클래스의 인스턴스는 객체가 생성되는 시점에 초기화되고 소멸이 될 때까지 값이 변경되지 않는다.</li>\n<li>불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉽다.</li>\n<li>값이 변경되지 않으니 오류가 발생할 일도 적고 안전하다.</li>\n</ul>\n<h1>불변 클래스를 만들기 위한 5가지 조건</h1>\n<h2>객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.</h2>\n<ul>\n<li>쉽게 말해 setter나, 필드 정보를 변경하는 메서드를 제공하지 않는다.</li>\n</ul>\n<h2>클래스를 확장 할 수 없도록 한다.</h2>\n<ul>\n<li>클래스를 final로 선언한다.</li>\n<li>모든 생성자는 private으로 만들고 생성자 정적 팩터리 메서드를 제공한다.</li>\n<li>정적 팩터리 메서드는 유연성을 제공한다.</li>\n<li>다음 릴리즈에서 Boolean처럼 <code>캐싱</code>을 이용해 성능을 끌어올릴 수도 있다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span>(access = AccessLevel.PRIVATE, staticName=<span class=\"string\">\"of\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>모든 필드를 final로 선언한다.</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span>(access = AccessLevel.PRIVATE, staticName=<span class=\"string\">\"of\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>필드에 대해 수정을 막겠다는 설계자의 의도를 보여준다. - final클래스는 생성자에서 딱 <code>1회 초기화</code> 할 수 있기 때문이다.</li>\n<li>인스턴스에 대한 동기화(syncronized)처리 없이도 다른 스레드에서 문제없이 처리 된다.</li>\n</ul>\n<h2>모든 필드를 private로 선언한다.</h2>\n<ul>\n<li>필드가 참조하는 가변 객체를 클라이언트에서 직접 접근하여 수정하는 일을 막는다.</li>\n<li>public final로만 처리해도 되지만, 그 안의 내용을 바꿀 수 있고 다 릴리즈에서 내부 표현을 변경하지 못하므로 사용하지 않는게 좋다.</li>\n</ul>\n<h2>자신(객체) 이외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.</h2>\n<ul>\n<li>클라이언트에서 인스턴스 내에 가변 객체의 참조를 얻을 수 없게 해야한다. - Collection에 대한 getter를 제공하면 안된다!</li>\n<li>생성자, 접근자(getter), readObject 메서드에서 모두 <code>방어적 복사</code>를 수행해야 한다.</li>\n</ul>\n<h1>함수형 프로그래밍</h1>\n<ul>\n<li>피연산자에 함수를 적용해 결과를 반환하는 프로그래밍 기법</li>\n<li>피연산자에 대해 연산하지만 피연산자는 값이 변하지 않음\n(캡처 - 피연산자는 사실상 final)</li>\n<li>코드의 불변이 영역이 되는 비율이 높아져 안전하다.</li>\n</ul>\n<h1>불변 객체의 장점</h1>\n<ul>\n<li>불변 객체는 생성 시점부터 소멸될 때 까지 변하지 않는다. - 서비스 로직에 더 안전하다.</li>\n<li>불변 객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요가 없다. - 스레드에 따라 값이 변하지 않기 때문이다.</li>\n<li>불변 객체는 안심하고 공유 할 수 있다. - 불변 클래스라면 최대한 재사용 하라 (캐싱)</li>\n<li>불변 객체는 방어적 복사본이 필요없다 - 바뀌지 않으므로 방어할 일이 없다.</li>\n<li>불변 객체는 clone메서드를 제공하지 않는게 좋다. - 의미가 없다.</li>\n<li>불변 객체를 key로 하면 이점이 많다.\n<ul>\n<li>Map의 key</li>\n<li>Set의 원소</li>\n</ul>\n</li>\n<li>불변 객체는 그 자체로 실패 원자성을 제공한다.\n<ul>\n<li>메서드에서 예외가 발생하더라도 객체의 변경내용이 없다.</li>\n</ul>\n</li>\n<li>불변 객체끼리는 자유롭게 내부 데이터를 공유 할 수 있다.\n<ul>\n<li>BigInteger 클래스에서 mag는 크기를 나타내는 배열</li>\n<li>signum은 부호를 나타내는 int 필드</li>\n<li>mag는 배열이지만 불변이므로 방어적 복사본을 만들지 않고 원래 객체의 mag를 써도 된다.</li>\n</ul>\n</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a BigInteger whose value is &#123;<span class=\"doctag\">@code</span> (-this)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> -this&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> BigInteger <span class=\"title\">negate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BigInteger(<span class=\"keyword\">this</span>.mag, -<span class=\"keyword\">this</span>.signum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>불변 객체는 값이 다르면 반드시 독립된 객체로 만들어야 한다.</li>\n</ul>\n<h1>요약</h1>\n<ul>\n<li>접근자(getter)를 제공한다고 습관처럼 수정자(setter)를 만들지 말자\n<ul>\n<li>꼭 필요한 경우가 아니라면 클래스는 불변이어야 한다.</li>\n<li>장점이 훨씬많고, 단점이라면 잠재적 성능저하 뿐이다.</li>\n</ul>\n</li>\n<li>불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한 줄이자\n<ul>\n<li>객체가 가질 수 있는 상태를 제한하면, 예외를 예측하기 쉽고, 오류가 생길 가능성이 줄어든다.</li>\n<li>꼭 변경할 필드가 아닌 필드는 final로 선언하자 - 웬만하면 final로 해야한다.</li>\n</ul>\n</li>\n<li>생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.\n<ul>\n<li>확실한 이유가 없다면, 생성자와 정적팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안된다.</li>\n<li>특히! 객체를 재활용할 목적으로 상태를 다시 초기화 하는 메서드도 안된다.</li>\n<li>복잡성만 커지고 성능 이점은 거의 없다.</li>\n</ul>\n</li>\n</ul>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 17. 변경 가능성을 최소화하라</li>\n</ul>\n"},{"title":"Item 3. Private 생성자나 열거 타입으로 싱글턴임을 보증하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item3","typora-copy-images-to":"effective-java-item3","date":"2019-01-07T10:34:19.000Z","subtitle":null,"header-img":null,"_content":"\n# 싱글턴이란?\n싱글턴 객체란 Application내에서 단 1개의 인스턴스만 생성할 수 있는 클래스를 의미한다.  \n시스템에서 유일성을 보장하기 위해 1개만 만들어야 하는 경우도 있고, 시스템 구조 상 1개 이상이 되면 개념적으로 맞지 않는 상황도 있기 때문이다.\n\n# 싱글턴을 만드는 방법\n## private 생성자 + static 객체\nprivate 생성자를 통해 내부에서만 객체를 생성 할 수 있도록 하고,\npublic static final 키워드를 이용해 static 변수로 1개의 인스턴스만 제공하는 방식이다.\n\n```java\npublic class Elvis {\n  public static final Elvis INSTANCE = new Elvis();\n  private Elvis() {}\n}\n```\n\n사용자가 Elvis 객체를 클라이언트에서 사용하기 위해서는  \n외부로 노출 된 생성자가 없기 때문에 Elvis.INSTANCE의 형태로 사용해야만 한다.  \n최초로 INSTANCE 변수가 초기화 될 때 private 생성자를 통해 단 한번 인스턴스가 생성되게 된다.\n> 하지만, Java의 Reflection기능을 이용하여, AccessibleObject.setAccessible(true)를 이용하면 private 생성자를 호출 할 수 있다.  \n(이런 부분은 논외로 한다.)  여차하면 두번째 호출 부터 Exception을 발생 시켜 싱글턴을 보장할 수 있도록 방어로직을 심을 수 있다.\n\n\n## 정적 팩터리 메서드\n위의 private 생성자 + static 객체에서 조금 진화된 형태가 클래스에서 정적 팩터리 메서드를 제공하는 case이다.\n\n```java\npublic class Elvis {\n  private static final Elvis INSTANCE = new Elvis();\n  private Elvis() {}\n  public static Elvis getInstance() {\n    return INSTANCE;\n  }\n}\n```\n1. 지금은 싱글턴 객체를 리턴하는 정적 메서드이지만, 향후 필요에 따라 변경될 수 있는 확장성을 가지고 있다.\n특정 파라미터나, 특정 스레드에는 다른 인스턴스를 리턴한다던지에 대해 확장과 변경에 열려 있는 장점이 있다.\n\n2. 원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.\n3. 정적 팩터리 메서드의 참조를 공급자(Supplier)로 만들 수 있다.\n\n\n```java\npublic class Elvis {\n  private static final Elvis INSTANCE = new Elvis();\n  private Elvis() {}\n  public static Elvis getInstance() {\n    return INSTANCE;\n  }\n\n  public static Supplier<Elvis> get() {\n    return () -> INSTANCE;\n  }\n}\n```\n\n## 열거 타입(Enum)을 이용한 싱글턴 객체 생성\n```java\npublic enum Elvis {\n  INSTANCE;\n}\n```\n1번째 예시와 비슷하지만 가장 안전하고 좋은 방법이다.\n복잡한 직렬화 상황이나, 리플렉션 공격에도 안전하다.  \n단, 만들려는 싱글턴이 Enum이외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다.  \n(열거 타입이 다른 인터페이스를 구현하도록 하는 건 가능.)\n\n\n# 싱글턴 객체의 직렬화\n싱글턴 클래스를 직렬화 하기 위해서는 Serializable을 구현한다고 선언하는 것 만으로는 부족하다.  \n모든 인스턴스 필드에 transient 예약어를 붙여 직렬화를 막은 다음 readResolve 메서드를 제공해야 한다.  \n이렇게 하지 않으면 역직렬화 시점에 새로운 인스턴스가 생성 된다.\n\n```java\n\npublic class Elvis implements Serializable {\n  private static final Elvis INSTANCE = new Elvis();\n  private Elvis() {}\n  public static Elvis getInstance() {\n    return INSTANCE;\n  }\n\n  //역직렬화가 되어 새로운 인스턴스가 생성되더라도, \n  //클래스간 공유 변수인 static 변수를 이용하면 싱글턴을 보장 할 수 있다.\n  // 새로운 인스턴스는 GC에 의해 UnReachable 형태로 판별되어 제거된다.\n  public Object readResolve() {\n    return INSTANCE;\n  }\n}\n```\n\n# 참고\n* Effective Java 3rd Edition - Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라\n","source":"_posts/effective-java-item3.md","raw":"---\ntitle: Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item3\ntypora-copy-images-to: effective-java-item3\ndate: 2019-01-07 19:34:19\nsubtitle:\nheader-img:\n---\n\n# 싱글턴이란?\n싱글턴 객체란 Application내에서 단 1개의 인스턴스만 생성할 수 있는 클래스를 의미한다.  \n시스템에서 유일성을 보장하기 위해 1개만 만들어야 하는 경우도 있고, 시스템 구조 상 1개 이상이 되면 개념적으로 맞지 않는 상황도 있기 때문이다.\n\n# 싱글턴을 만드는 방법\n## private 생성자 + static 객체\nprivate 생성자를 통해 내부에서만 객체를 생성 할 수 있도록 하고,\npublic static final 키워드를 이용해 static 변수로 1개의 인스턴스만 제공하는 방식이다.\n\n```java\npublic class Elvis {\n  public static final Elvis INSTANCE = new Elvis();\n  private Elvis() {}\n}\n```\n\n사용자가 Elvis 객체를 클라이언트에서 사용하기 위해서는  \n외부로 노출 된 생성자가 없기 때문에 Elvis.INSTANCE의 형태로 사용해야만 한다.  \n최초로 INSTANCE 변수가 초기화 될 때 private 생성자를 통해 단 한번 인스턴스가 생성되게 된다.\n> 하지만, Java의 Reflection기능을 이용하여, AccessibleObject.setAccessible(true)를 이용하면 private 생성자를 호출 할 수 있다.  \n(이런 부분은 논외로 한다.)  여차하면 두번째 호출 부터 Exception을 발생 시켜 싱글턴을 보장할 수 있도록 방어로직을 심을 수 있다.\n\n\n## 정적 팩터리 메서드\n위의 private 생성자 + static 객체에서 조금 진화된 형태가 클래스에서 정적 팩터리 메서드를 제공하는 case이다.\n\n```java\npublic class Elvis {\n  private static final Elvis INSTANCE = new Elvis();\n  private Elvis() {}\n  public static Elvis getInstance() {\n    return INSTANCE;\n  }\n}\n```\n1. 지금은 싱글턴 객체를 리턴하는 정적 메서드이지만, 향후 필요에 따라 변경될 수 있는 확장성을 가지고 있다.\n특정 파라미터나, 특정 스레드에는 다른 인스턴스를 리턴한다던지에 대해 확장과 변경에 열려 있는 장점이 있다.\n\n2. 원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.\n3. 정적 팩터리 메서드의 참조를 공급자(Supplier)로 만들 수 있다.\n\n\n```java\npublic class Elvis {\n  private static final Elvis INSTANCE = new Elvis();\n  private Elvis() {}\n  public static Elvis getInstance() {\n    return INSTANCE;\n  }\n\n  public static Supplier<Elvis> get() {\n    return () -> INSTANCE;\n  }\n}\n```\n\n## 열거 타입(Enum)을 이용한 싱글턴 객체 생성\n```java\npublic enum Elvis {\n  INSTANCE;\n}\n```\n1번째 예시와 비슷하지만 가장 안전하고 좋은 방법이다.\n복잡한 직렬화 상황이나, 리플렉션 공격에도 안전하다.  \n단, 만들려는 싱글턴이 Enum이외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다.  \n(열거 타입이 다른 인터페이스를 구현하도록 하는 건 가능.)\n\n\n# 싱글턴 객체의 직렬화\n싱글턴 클래스를 직렬화 하기 위해서는 Serializable을 구현한다고 선언하는 것 만으로는 부족하다.  \n모든 인스턴스 필드에 transient 예약어를 붙여 직렬화를 막은 다음 readResolve 메서드를 제공해야 한다.  \n이렇게 하지 않으면 역직렬화 시점에 새로운 인스턴스가 생성 된다.\n\n```java\n\npublic class Elvis implements Serializable {\n  private static final Elvis INSTANCE = new Elvis();\n  private Elvis() {}\n  public static Elvis getInstance() {\n    return INSTANCE;\n  }\n\n  //역직렬화가 되어 새로운 인스턴스가 생성되더라도, \n  //클래스간 공유 변수인 static 변수를 이용하면 싱글턴을 보장 할 수 있다.\n  // 새로운 인스턴스는 GC에 의해 UnReachable 형태로 판별되어 제거된다.\n  public Object readResolve() {\n    return INSTANCE;\n  }\n}\n```\n\n# 참고\n* Effective Java 3rd Edition - Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라\n","slug":"effective-java-item3","published":1,"updated":"2019-01-07T13:32:09.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2s70010cr1tpgdmgz6n","content":"<h1 id=\"싱글턴이란\">싱글턴이란?</h1>\n<p>싱글턴 객체란 Application내에서 단 1개의 인스턴스만 생성할 수 있는 클래스를 의미한다.<br>\n시스템에서 유일성을 보장하기 위해 1개만 만들어야 하는 경우도 있고, 시스템 구조 상 1개 이상이 되면 개념적으로 맞지 않는 상황도 있기 때문이다.</p>\n<h1 id=\"싱글턴을-만드는-방법\">싱글턴을 만드는 방법</h1>\n<h2 id=\"private-생성자-static-객체\">private 생성자 + static 객체</h2>\n<p>private 생성자를 통해 내부에서만 객체를 생성 할 수 있도록 하고,\npublic static final 키워드를 이용해 static 변수로 1개의 인스턴스만 제공하는 방식이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>사용자가 Elvis 객체를 클라이언트에서 사용하기 위해서는<br>\n외부로 노출 된 생성자가 없기 때문에 Elvis.INSTANCE의 형태로 사용해야만 한다.<br>\n최초로 INSTANCE 변수가 초기화 될 때 private 생성자를 통해 단 한번 인스턴스가 생성되게 된다.</p>\n<blockquote>\n<p>하지만, Java의 Reflection기능을 이용하여, AccessibleObject.setAccessible(true)를 이용하면 private 생성자를 호출 할 수 있다.<br>\n(이런 부분은 논외로 한다.)  여차하면 두번째 호출 부터 Exception을 발생 시켜 싱글턴을 보장할 수 있도록 방어로직을 심을 수 있다.</p>\n</blockquote>\n<h2 id=\"정적-팩터리-메서드\">정적 팩터리 메서드</h2>\n<p>위의 private 생성자 + static 객체에서 조금 진화된 형태가 클래스에서 정적 팩터리 메서드를 제공하는 case이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Elvis <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>\n<p>지금은 싱글턴 객체를 리턴하는 정적 메서드이지만, 향후 필요에 따라 변경될 수 있는 확장성을 가지고 있다.\n특정 파라미터나, 특정 스레드에는 다른 인스턴스를 리턴한다던지에 대해 확장과 변경에 열려 있는 장점이 있다.</p>\n</li>\n<li>\n<p>원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.</p>\n</li>\n<li>\n<p>정적 팩터리 메서드의 참조를 공급자(Supplier)로 만들 수 있다.</p>\n</li>\n</ol>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Elvis <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Supplier&lt;Elvis&gt; <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> () -&gt; INSTANCE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"열거-타입enum을-이용한-싱글턴-객체-생성\">열거 타입(Enum)을 이용한 싱글턴 객체 생성</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Elvis &#123;</span><br><span class=\"line\">  INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1번째 예시와 비슷하지만 가장 안전하고 좋은 방법이다.\n복잡한 직렬화 상황이나, 리플렉션 공격에도 안전하다.<br>\n단, 만들려는 싱글턴이 Enum이외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다.<br>\n(열거 타입이 다른 인터페이스를 구현하도록 하는 건 가능.)</p>\n<h1 id=\"싱글턴-객체의-직렬화\">싱글턴 객체의 직렬화</h1>\n<p>싱글턴 클래스를 직렬화 하기 위해서는 Serializable을 구현한다고 선언하는 것 만으로는 부족하다.<br>\n모든 인스턴스 필드에 transient 예약어를 붙여 직렬화를 막은 다음 readResolve 메서드를 제공해야 한다.<br>\n이렇게 하지 않으면 역직렬화 시점에 새로운 인스턴스가 생성 된다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Elvis <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//역직렬화가 되어 새로운 인스턴스가 생성되더라도, </span></span><br><span class=\"line\">  <span class=\"comment\">//클래스간 공유 변수인 static 변수를 이용하면 싱글턴을 보장 할 수 있다.</span></span><br><span class=\"line\">  <span class=\"comment\">// 새로운 인스턴스는 GC에 의해 UnReachable 형태로 판별되어 제거된다.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>싱글턴이란?</h1>\n<p>싱글턴 객체란 Application내에서 단 1개의 인스턴스만 생성할 수 있는 클래스를 의미한다.<br>\n시스템에서 유일성을 보장하기 위해 1개만 만들어야 하는 경우도 있고, 시스템 구조 상 1개 이상이 되면 개념적으로 맞지 않는 상황도 있기 때문이다.</p>\n<h1>싱글턴을 만드는 방법</h1>\n<h2>private 생성자 + static 객체</h2>\n<p>private 생성자를 통해 내부에서만 객체를 생성 할 수 있도록 하고,\npublic static final 키워드를 이용해 static 변수로 1개의 인스턴스만 제공하는 방식이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>사용자가 Elvis 객체를 클라이언트에서 사용하기 위해서는<br>\n외부로 노출 된 생성자가 없기 때문에 Elvis.INSTANCE의 형태로 사용해야만 한다.<br>\n최초로 INSTANCE 변수가 초기화 될 때 private 생성자를 통해 단 한번 인스턴스가 생성되게 된다.</p>\n<blockquote>\n<p>하지만, Java의 Reflection기능을 이용하여, AccessibleObject.setAccessible(true)를 이용하면 private 생성자를 호출 할 수 있다.<br>\n(이런 부분은 논외로 한다.)  여차하면 두번째 호출 부터 Exception을 발생 시켜 싱글턴을 보장할 수 있도록 방어로직을 심을 수 있다.</p>\n</blockquote>\n<h2>정적 팩터리 메서드</h2>\n<p>위의 private 생성자 + static 객체에서 조금 진화된 형태가 클래스에서 정적 팩터리 메서드를 제공하는 case이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Elvis <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>\n<p>지금은 싱글턴 객체를 리턴하는 정적 메서드이지만, 향후 필요에 따라 변경될 수 있는 확장성을 가지고 있다.\n특정 파라미터나, 특정 스레드에는 다른 인스턴스를 리턴한다던지에 대해 확장과 변경에 열려 있는 장점이 있다.</p>\n</li>\n<li>\n<p>원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.</p>\n</li>\n<li>\n<p>정적 팩터리 메서드의 참조를 공급자(Supplier)로 만들 수 있다.</p>\n</li>\n</ol>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Elvis <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Supplier&lt;Elvis&gt; <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> () -&gt; INSTANCE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>열거 타입(Enum)을 이용한 싱글턴 객체 생성</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Elvis &#123;</span><br><span class=\"line\">  INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1번째 예시와 비슷하지만 가장 안전하고 좋은 방법이다.\n복잡한 직렬화 상황이나, 리플렉션 공격에도 안전하다.<br>\n단, 만들려는 싱글턴이 Enum이외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다.<br>\n(열거 타입이 다른 인터페이스를 구현하도록 하는 건 가능.)</p>\n<h1>싱글턴 객체의 직렬화</h1>\n<p>싱글턴 클래스를 직렬화 하기 위해서는 Serializable을 구현한다고 선언하는 것 만으로는 부족하다.<br>\n모든 인스턴스 필드에 transient 예약어를 붙여 직렬화를 막은 다음 readResolve 메서드를 제공해야 한다.<br>\n이렇게 하지 않으면 역직렬화 시점에 새로운 인스턴스가 생성 된다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Elvis <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//역직렬화가 되어 새로운 인스턴스가 생성되더라도, </span></span><br><span class=\"line\">  <span class=\"comment\">//클래스간 공유 변수인 static 변수를 이용하면 싱글턴을 보장 할 수 있다.</span></span><br><span class=\"line\">  <span class=\"comment\">// 새로운 인스턴스는 GC에 의해 UnReachable 형태로 판별되어 제거된다.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라</li>\n</ul>\n"},{"title":"Item 31. 한정적 와일드 카드(Bounded Wildcard Type)를 사용해 API 유연성을 높여라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item31","typora-copy-images-to":"effective-java-item31","date":"2019-01-26T12:16:50.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\nGeneric에서 매개변수화 타입(Parameterize Type - List<String>)는 불공변이다.\n\n> 공변 vs 불공변\nJava에서 배열은 공변(variant), Generic은 불공변(invariant)이라 한다.  \n배열의 경우 Object[]과 String[] 간에는 부모-자식 클래스 관계가 성립한다. 이를 공변이라한다.  \n하지만 Generic에서는 List<Object>와 List<String>은 부모-자식 관계가 성립하지 않는다 이를 불공변이라한다.\n\n즉, List<String>은 String타입의 문자열만 넣을 수 있지만, List<Object>는 문자열이건, 숫자건 다 넣을 수 있으므로, 부모클래스에서 가능한 일은 자식클래스에서도 가능해야 한다는 **리스코프 치환원칙**에 위배된다.\n\n하지만 때로는 불공변 방식보다 유연한 무언가가 필요하다.\n\n# 생산자(producer) 와일드카드 적용\n```java\nStack<Number> numberStack = new Stack<>();\nIterator<Integer> integers = List.of(1,2,3,4,5);\nnumberStack.pushAll(integers);\n```\nInteger는 Number의 하위타입이기 때문에 잘 동작할 것 같지만, 실제로는 컴파일 시에 오류가 발생한다.\n\nParameterize Type이 불공변이기 때문에 Iterator<Number>와 Iterator<Integer>는 부모-자식 관계가 아니다.  \n그렇기 때문에 addAll 메서드의 파라미터로 사용할 수 없는 것이다.\n\n이런 경우 생산자(producer) 파라미터에 와일드카드 타입을 적용하여 유연하게 만들 수 있다.\n\n```java\npublic void pushAll(Iterator<? extends E> iterator) {\n  for (E e : iterator) {\n    push(e);\n  }\n}\n```\n생산자(producer) 파라미터란, 파라미터로 제공되어 메서드 내에서 사용 될 객체를 공급해 주는 파라미터이다. \n\n`<? extends E>` 형태로 사용하는 경우 E 타입의 하위타입만 파라미터로 올 수 있게 제약을 거는 것이다.  \n`모든 타입은 자기 자신의 하위타입이다!` 라는 규칙이 있으므로 자기 자신에 대한 타입도 들어올 수 있다.\n\n\n\n# 소비자(consumer) 와일드카드 적용\n\n```java\npublic void popAll(Collection<E> dst) {\n  while(!isEmpty()) {\n    dst.add(pop());\n  }\n}\n```\n```java\nStack<Number> numberStack = new Stack<>();\nCollection<Object> objects = List.of(1, \"String\");\nnumberStack.popAll(objects);\n```\n컴파일 하게되면 Collection<Object>는 Collection<Number>의 하위타입이 아니다라는 오류가 나온다.  \n이를 해결하기 위해서는 super를 이용해 와일드카드를 작성해야 한다.\n\n```java\npublic void popAll(Collection<? super E> dst) {\n  while(!isEmpty()) {\n    dst.add(pop());\n  }\n}\n```\n소비자(consumer) 파라미터란, 메서드에 제공되어 메서드 내에서 제공되는 객체를 자기 자신이 사용하는 파라미터를 의미한다.\n\n# PECS(Producer-Extends, Consumer-Super)\n다음 공식을 외워 어떤 와일드 카드 타입을 쓸지 기억하자\n* 생산자(producer) - Generic 클래스 내에 타입 파라미터를 이용해 객체를 제공하는 것 \n  * <? extends E>를 사용하여 유연성을 높일 수 있다.\n* 소비자(consumer) - Generic 클래스 내의 자원을 사용하는 객체를 파라미터로 전달하는 것 \n  * <? super E>를 사용하여 유연성을 높일 수 있다.\n  * Comparable, Comparator는 소비자로 사용된다.\n\n\n```java\nSet<Integer> integers = Set.of(1,2,3);\nSet<Double> doubles = Set.of(1.0, 2.0, 3.0);\nSet<Number> numbers = union(integers, doubles);\n```\n```java\npublic static <E> Set<E> union(Set<E> s1, Set<E> s2) {\n  Set<E> set = new HashSet<>();\n  set.addAll(integers);\n  set.addAll(doubles);\n  return set;\n}\n```\n위와 같이 메서드가 만들어지면 타입이 맞지 않는다고 컴파일 오류가 나게 된다.  \nSet<E>은 불공변이기 때문에 Set<Integer>와 Set<Double>은 Set<Number>의 하위타입이 아니기 떄문이다.\n\n```java\npublic static <E> Set<E> union(Set<? extends E> s1, Set<? extends E> s2) {\n  Set<E> set = new HashSet<>();\n  set.addAll(integers);\n  set.addAll(doubles);\n  return set;\n}\n```\n위와 같이 변경하면 컴파일 오류도 해결되고 잘 실행 된다.\n이렇게 공통 API를 작성할 때는 와일드 카드를 적절하게 쓰도록 하자.  \n클래스 사용자가 와일드카드 타입을 신경써야 한다면, 그 API에 문제가 있을 가능성이 크다.\n\n## Java7에서는...\n```java\nSet<Number> numbers = Union.<Number>union(integers, doubles);\n```\n위와 같은 형태로 명시적으로 타입인수를 사용해야 한다.  \n타입추론능력이 부족하기 때문이다.\n\n# 심화 - Comparable\n```java\npublic static <E extends Comparable<E>> E max(List<E> list)\n```\n와일드카드를 통해 좀 더 다듬은 모습이다.  \n**주의: Comparable을 구현한 클래스만 파라미터로 올 수 있다**\n```java\n public static <E extends Comparable<? super E>> E ma(List<? extends E> list) {\n            list.sort(Comparator.reverseOrder());\n            return list.get(0);\n        }\n```\n* 일반적으로는 Comparable<E>보단 Comparable<? super E>를 사용하는게 낫다. (대부분 소비자로 사용)\n\n# 심화2 - 와일드카드를 적절히 사용하라\n```java\npublic static <E> void swap(List<E> list, int i, int j);\npublic static void swap(List<?> list, int i, int j);\n```\n리스트 내의 특정 인자들의 위치를 뒤바꿔주는 메서드이다.  \n어느 메서드가 더 좋을까?\n\n기본적으로는 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하는 것이 좋다.\n\n```java\npublic static void swap(List<?> list, int i, int j) {\n  list.set(i, list.set(j, list.get(i)));\n}\n```\n위의 코드는 list.get하는 부분에서 컴파일 오류가 난다.\n비한정적 와일드카드를 사용하고 있기 때문에 list.set을 하는 경우에는 null밖에 넣을 수가 없다.  \n이런 경우 도우미 메서드를 따로 이용한다.\n```java\npublic static <E> void swapHelper(List<E> list, int i, int j) {\n  list.set(i, list.set(j, list.get(i)));\n}\n```\n이 경우에는 List<E>의 리턴타입이 항상 E인 것을 알기 때문에  \n런타임 시, 타입안정성을 보장 할 수 있고 set하는 경우에도 E 타입을 set할 것을 알기 때문에 컴파일 오류 없이 작동 한다.\n\n# 정리\n조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다.  \n그러나 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해야 한다.  \nPECS 공식을 기억하여 생산자에는 extends, 소비자에는 super를 사용하자.\n\n# 참고\n* Effective Java 3rd Edition - Item 31. 한정적 와일드 카드(bounded wildcard type)를 사용해 API 유연성을 높여라","source":"_posts/effective-java-item31.md","raw":"---\ntitle: Item 31. 한정적 와일드 카드(bounded wildcard type)를 사용해 API 유연성을 높여라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item31\ntypora-copy-images-to: effective-java-item31\ndate: 2019-01-26 21:16:50\nsubtitle:\nheader-img:\n---\n\n# 서론\nGeneric에서 매개변수화 타입(Parameterize Type - List<String>)는 불공변이다.\n\n> 공변 vs 불공변\nJava에서 배열은 공변(variant), Generic은 불공변(invariant)이라 한다.  \n배열의 경우 Object[]과 String[] 간에는 부모-자식 클래스 관계가 성립한다. 이를 공변이라한다.  \n하지만 Generic에서는 List<Object>와 List<String>은 부모-자식 관계가 성립하지 않는다 이를 불공변이라한다.\n\n즉, List<String>은 String타입의 문자열만 넣을 수 있지만, List<Object>는 문자열이건, 숫자건 다 넣을 수 있으므로, 부모클래스에서 가능한 일은 자식클래스에서도 가능해야 한다는 **리스코프 치환원칙**에 위배된다.\n\n하지만 때로는 불공변 방식보다 유연한 무언가가 필요하다.\n\n# 생산자(producer) 와일드카드 적용\n```java\nStack<Number> numberStack = new Stack<>();\nIterator<Integer> integers = List.of(1,2,3,4,5);\nnumberStack.pushAll(integers);\n```\nInteger는 Number의 하위타입이기 때문에 잘 동작할 것 같지만, 실제로는 컴파일 시에 오류가 발생한다.\n\nParameterize Type이 불공변이기 때문에 Iterator<Number>와 Iterator<Integer>는 부모-자식 관계가 아니다.  \n그렇기 때문에 addAll 메서드의 파라미터로 사용할 수 없는 것이다.\n\n이런 경우 생산자(producer) 파라미터에 와일드카드 타입을 적용하여 유연하게 만들 수 있다.\n\n```java\npublic void pushAll(Iterator<? extends E> iterator) {\n  for (E e : iterator) {\n    push(e);\n  }\n}\n```\n생산자(producer) 파라미터란, 파라미터로 제공되어 메서드 내에서 사용 될 객체를 공급해 주는 파라미터이다. \n\n`<? extends E>` 형태로 사용하는 경우 E 타입의 하위타입만 파라미터로 올 수 있게 제약을 거는 것이다.  \n`모든 타입은 자기 자신의 하위타입이다!` 라는 규칙이 있으므로 자기 자신에 대한 타입도 들어올 수 있다.\n\n\n\n# 소비자(consumer) 와일드카드 적용\n\n```java\npublic void popAll(Collection<E> dst) {\n  while(!isEmpty()) {\n    dst.add(pop());\n  }\n}\n```\n```java\nStack<Number> numberStack = new Stack<>();\nCollection<Object> objects = List.of(1, \"String\");\nnumberStack.popAll(objects);\n```\n컴파일 하게되면 Collection<Object>는 Collection<Number>의 하위타입이 아니다라는 오류가 나온다.  \n이를 해결하기 위해서는 super를 이용해 와일드카드를 작성해야 한다.\n\n```java\npublic void popAll(Collection<? super E> dst) {\n  while(!isEmpty()) {\n    dst.add(pop());\n  }\n}\n```\n소비자(consumer) 파라미터란, 메서드에 제공되어 메서드 내에서 제공되는 객체를 자기 자신이 사용하는 파라미터를 의미한다.\n\n# PECS(Producer-Extends, Consumer-Super)\n다음 공식을 외워 어떤 와일드 카드 타입을 쓸지 기억하자\n* 생산자(producer) - Generic 클래스 내에 타입 파라미터를 이용해 객체를 제공하는 것 \n  * <? extends E>를 사용하여 유연성을 높일 수 있다.\n* 소비자(consumer) - Generic 클래스 내의 자원을 사용하는 객체를 파라미터로 전달하는 것 \n  * <? super E>를 사용하여 유연성을 높일 수 있다.\n  * Comparable, Comparator는 소비자로 사용된다.\n\n\n```java\nSet<Integer> integers = Set.of(1,2,3);\nSet<Double> doubles = Set.of(1.0, 2.0, 3.0);\nSet<Number> numbers = union(integers, doubles);\n```\n```java\npublic static <E> Set<E> union(Set<E> s1, Set<E> s2) {\n  Set<E> set = new HashSet<>();\n  set.addAll(integers);\n  set.addAll(doubles);\n  return set;\n}\n```\n위와 같이 메서드가 만들어지면 타입이 맞지 않는다고 컴파일 오류가 나게 된다.  \nSet<E>은 불공변이기 때문에 Set<Integer>와 Set<Double>은 Set<Number>의 하위타입이 아니기 떄문이다.\n\n```java\npublic static <E> Set<E> union(Set<? extends E> s1, Set<? extends E> s2) {\n  Set<E> set = new HashSet<>();\n  set.addAll(integers);\n  set.addAll(doubles);\n  return set;\n}\n```\n위와 같이 변경하면 컴파일 오류도 해결되고 잘 실행 된다.\n이렇게 공통 API를 작성할 때는 와일드 카드를 적절하게 쓰도록 하자.  \n클래스 사용자가 와일드카드 타입을 신경써야 한다면, 그 API에 문제가 있을 가능성이 크다.\n\n## Java7에서는...\n```java\nSet<Number> numbers = Union.<Number>union(integers, doubles);\n```\n위와 같은 형태로 명시적으로 타입인수를 사용해야 한다.  \n타입추론능력이 부족하기 때문이다.\n\n# 심화 - Comparable\n```java\npublic static <E extends Comparable<E>> E max(List<E> list)\n```\n와일드카드를 통해 좀 더 다듬은 모습이다.  \n**주의: Comparable을 구현한 클래스만 파라미터로 올 수 있다**\n```java\n public static <E extends Comparable<? super E>> E ma(List<? extends E> list) {\n            list.sort(Comparator.reverseOrder());\n            return list.get(0);\n        }\n```\n* 일반적으로는 Comparable<E>보단 Comparable<? super E>를 사용하는게 낫다. (대부분 소비자로 사용)\n\n# 심화2 - 와일드카드를 적절히 사용하라\n```java\npublic static <E> void swap(List<E> list, int i, int j);\npublic static void swap(List<?> list, int i, int j);\n```\n리스트 내의 특정 인자들의 위치를 뒤바꿔주는 메서드이다.  \n어느 메서드가 더 좋을까?\n\n기본적으로는 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하는 것이 좋다.\n\n```java\npublic static void swap(List<?> list, int i, int j) {\n  list.set(i, list.set(j, list.get(i)));\n}\n```\n위의 코드는 list.get하는 부분에서 컴파일 오류가 난다.\n비한정적 와일드카드를 사용하고 있기 때문에 list.set을 하는 경우에는 null밖에 넣을 수가 없다.  \n이런 경우 도우미 메서드를 따로 이용한다.\n```java\npublic static <E> void swapHelper(List<E> list, int i, int j) {\n  list.set(i, list.set(j, list.get(i)));\n}\n```\n이 경우에는 List<E>의 리턴타입이 항상 E인 것을 알기 때문에  \n런타임 시, 타입안정성을 보장 할 수 있고 set하는 경우에도 E 타입을 set할 것을 알기 때문에 컴파일 오류 없이 작동 한다.\n\n# 정리\n조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다.  \n그러나 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해야 한다.  \nPECS 공식을 기억하여 생산자에는 extends, 소비자에는 super를 사용하자.\n\n# 참고\n* Effective Java 3rd Edition - Item 31. 한정적 와일드 카드(bounded wildcard type)를 사용해 API 유연성을 높여라","slug":"effective-java-item31","published":1,"updated":"2019-01-28T12:46:13.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2s70011cr1tzv7yhwr7","content":"<h1 id=\"서론\">서론</h1>\n<p>Generic에서 매개변수화 타입(Parameterize Type - List&lt;String&gt;)는 불공변이다.</p>\n<blockquote>\n<p>공변 vs 불공변\nJava에서 배열은 공변(variant), Generic은 불공변(invariant)이라 한다.<br>\n배열의 경우 Object[]과 String[] 간에는 부모-자식 클래스 관계가 성립한다. 이를 공변이라한다.<br>\n하지만 Generic에서는 List&lt;Object&gt;와 List&lt;String&gt;은 부모-자식 관계가 성립하지 않는다 이를 불공변이라한다.</p>\n</blockquote>\n<p>즉, List&lt;String&gt;은 String타입의 문자열만 넣을 수 있지만, List&lt;Object&gt;는 문자열이건, 숫자건 다 넣을 수 있으므로, 부모클래스에서 가능한 일은 자식클래스에서도 가능해야 한다는 <strong>리스코프 치환원칙</strong>에 위배된다.</p>\n<p>하지만 때로는 불공변 방식보다 유연한 무언가가 필요하다.</p>\n<h1 id=\"생산자producer-와일드카드-적용\">생산자(producer) 와일드카드 적용</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack&lt;Number&gt; numberStack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">Iterator&lt;Integer&gt; integers = List.of(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">numberStack.pushAll(integers);</span><br></pre></td></tr></table></figure></p>\n<p>Integer는 Number의 하위타입이기 때문에 잘 동작할 것 같지만, 실제로는 컴파일 시에 오류가 발생한다.</p>\n<p>Parameterize Type이 불공변이기 때문에 Iterator&lt;Number&gt;와 Iterator&lt;Integer&gt;는 부모-자식 관계가 아니다.<br>\n그렇기 때문에 addAll 메서드의 파라미터로 사용할 수 없는 것이다.</p>\n<p>이런 경우 생산자(producer) 파라미터에 와일드카드 타입을 적용하여 유연하게 만들 수 있다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pushAll</span><span class=\"params\">(Iterator&lt;? extends E&gt; iterator)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (E e : iterator) &#123;</span><br><span class=\"line\">    push(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>생산자(producer) 파라미터란, 파라미터로 제공되어 메서드 내에서 사용 될 객체를 공급해 주는 파라미터이다.</p>\n<p><code>&lt;? extends E&gt;</code> 형태로 사용하는 경우 E 타입의 하위타입만 파라미터로 올 수 있게 제약을 거는 것이다.<br>\n<code>모든 타입은 자기 자신의 하위타입이다!</code> 라는 규칙이 있으므로 자기 자신에 대한 타입도 들어올 수 있다.</p>\n<h1 id=\"소비자consumer-와일드카드-적용\">소비자(consumer) 와일드카드 적용</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">popAll</span><span class=\"params\">(Collection&lt;E&gt; dst)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!isEmpty()) &#123;</span><br><span class=\"line\">    dst.add(pop());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack&lt;Number&gt; numberStack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">Collection&lt;Object&gt; objects = List.of(<span class=\"number\">1</span>, <span class=\"string\">\"String\"</span>);</span><br><span class=\"line\">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure></p>\n<p>컴파일 하게되면 Collection&lt;Object&gt;는 Collection&lt;Number&gt;의 하위타입이 아니다라는 오류가 나온다.<br>\n이를 해결하기 위해서는 super를 이용해 와일드카드를 작성해야 한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">popAll</span><span class=\"params\">(Collection&lt;? <span class=\"keyword\">super</span> E&gt; dst)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!isEmpty()) &#123;</span><br><span class=\"line\">    dst.add(pop());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>소비자(consumer) 파라미터란, 메서드에 제공되어 메서드 내에서 제공되는 객체를 자기 자신이 사용하는 파라미터를 의미한다.</p>\n<h1 id=\"pecsproducer-extends-consumer-super\">PECS(Producer-Extends, Consumer-Super)</h1>\n<p>다음 공식을 외워 어떤 와일드 카드 타입을 쓸지 기억하자</p>\n<ul>\n<li>생산자(producer) - Generic 클래스 내에 타입 파라미터를 이용해 객체를 제공하는 것\n<ul>\n<li>&lt;? extends E&gt;를 사용하여 유연성을 높일 수 있다.</li>\n</ul>\n</li>\n<li>소비자(consumer) - Generic 클래스 내의 자원을 사용하는 객체를 파라미터로 전달하는 것\n<ul>\n<li>&lt;? super E&gt;를 사용하여 유연성을 높일 수 있다.</li>\n<li>Comparable, Comparator는 소비자로 사용된다.</li>\n</ul>\n</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Integer&gt; integers = Set.of(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">Set&lt;Double&gt; doubles = Set.of(<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>);</span><br><span class=\"line\">Set&lt;Number&gt; numbers = union(integers, doubles);</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;E&gt; <span class=\"function\">Set&lt;E&gt; <span class=\"title\">union</span><span class=\"params\">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</span><br><span class=\"line\">  Set&lt;E&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">  set.addAll(integers);</span><br><span class=\"line\">  set.addAll(doubles);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> set;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위와 같이 메서드가 만들어지면 타입이 맞지 않는다고 컴파일 오류가 나게 된다.<br>\nSet&lt;E&gt;은 불공변이기 때문에 Set&lt;Integer&gt;와 Set&lt;Double&gt;은 Set&lt;Number&gt;의 하위타입이 아니기 떄문이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;E&gt; <span class=\"function\">Set&lt;E&gt; <span class=\"title\">union</span><span class=\"params\">(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2)</span> </span>&#123;</span><br><span class=\"line\">  Set&lt;E&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">  set.addAll(integers);</span><br><span class=\"line\">  set.addAll(doubles);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> set;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위와 같이 변경하면 컴파일 오류도 해결되고 잘 실행 된다.\n이렇게 공통 API를 작성할 때는 와일드 카드를 적절하게 쓰도록 하자.<br>\n클래스 사용자가 와일드카드 타입을 신경써야 한다면, 그 API에 문제가 있을 가능성이 크다.</p>\n<h2 id=\"java7에서는\">Java7에서는...</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);</span><br></pre></td></tr></table></figure></p>\n<p>위와 같은 형태로 명시적으로 타입인수를 사용해야 한다.<br>\n타입추론능력이 부족하기 때문이다.</p>\n<h1 id=\"심화-comparable\">심화 - Comparable</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class=\"function\">E <span class=\"title\">max</span><span class=\"params\">(List&lt;E&gt; list)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>와일드카드를 통해 좀 더 다듬은 모습이다.<br>\n<strong>주의: Comparable을 구현한 클래스만 파라미터로 올 수 있다</strong>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;E extends Comparable&lt;? <span class=\"keyword\">super</span> E&gt;&gt; <span class=\"function\">E <span class=\"title\">ma</span><span class=\"params\">(List&lt;? extends E&gt; list)</span> </span>&#123;</span><br><span class=\"line\">           list.sort(Comparator.reverseOrder());</span><br><span class=\"line\">           <span class=\"keyword\">return</span> list.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>일반적으로는 Comparable&lt;E&gt;보단 Comparable&lt;? super E&gt;를 사용하는게 낫다. (대부분 소비자로 사용)</li>\n</ul>\n<h1 id=\"심화2-와일드카드를-적절히-사용하라\">심화2 - 와일드카드를 적절히 사용하라</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;E&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(List&lt;E&gt; list, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(List&lt;?&gt; list, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>리스트 내의 특정 인자들의 위치를 뒤바꿔주는 메서드이다.<br>\n어느 메서드가 더 좋을까?</p>\n<p>기본적으로는 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하는 것이 좋다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(List&lt;?&gt; list, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">  list.set(i, list.set(j, list.get(i)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 코드는 list.get하는 부분에서 컴파일 오류가 난다.\n비한정적 와일드카드를 사용하고 있기 때문에 list.set을 하는 경우에는 null밖에 넣을 수가 없다.<br>\n이런 경우 도우미 메서드를 따로 이용한다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;E&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swapHelper</span><span class=\"params\">(List&lt;E&gt; list, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">  list.set(i, list.set(j, list.get(i)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이 경우에는 List&lt;E&gt;의 리턴타입이 항상 E인 것을 알기 때문에<br>\n런타임 시, 타입안정성을 보장 할 수 있고 set하는 경우에도 E 타입을 set할 것을 알기 때문에 컴파일 오류 없이 작동 한다.</p>\n<h1 id=\"정리\">정리</h1>\n<p>조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다.<br>\n그러나 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해야 한다.<br>\nPECS 공식을 기억하여 생산자에는 extends, 소비자에는 super를 사용하자.</p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 31. 한정적 와일드 카드(bounded wildcard type)를 사용해 API 유연성을 높여라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>Generic에서 매개변수화 타입(Parameterize Type - List&lt;String&gt;)는 불공변이다.</p>\n<blockquote>\n<p>공변 vs 불공변\nJava에서 배열은 공변(variant), Generic은 불공변(invariant)이라 한다.<br>\n배열의 경우 Object[]과 String[] 간에는 부모-자식 클래스 관계가 성립한다. 이를 공변이라한다.<br>\n하지만 Generic에서는 List&lt;Object&gt;와 List&lt;String&gt;은 부모-자식 관계가 성립하지 않는다 이를 불공변이라한다.</p>\n</blockquote>\n<p>즉, List&lt;String&gt;은 String타입의 문자열만 넣을 수 있지만, List&lt;Object&gt;는 문자열이건, 숫자건 다 넣을 수 있으므로, 부모클래스에서 가능한 일은 자식클래스에서도 가능해야 한다는 <strong>리스코프 치환원칙</strong>에 위배된다.</p>\n<p>하지만 때로는 불공변 방식보다 유연한 무언가가 필요하다.</p>\n<h1>생산자(producer) 와일드카드 적용</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack&lt;Number&gt; numberStack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">Iterator&lt;Integer&gt; integers = List.of(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">numberStack.pushAll(integers);</span><br></pre></td></tr></table></figure></p>\n<p>Integer는 Number의 하위타입이기 때문에 잘 동작할 것 같지만, 실제로는 컴파일 시에 오류가 발생한다.</p>\n<p>Parameterize Type이 불공변이기 때문에 Iterator&lt;Number&gt;와 Iterator&lt;Integer&gt;는 부모-자식 관계가 아니다.<br>\n그렇기 때문에 addAll 메서드의 파라미터로 사용할 수 없는 것이다.</p>\n<p>이런 경우 생산자(producer) 파라미터에 와일드카드 타입을 적용하여 유연하게 만들 수 있다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pushAll</span><span class=\"params\">(Iterator&lt;? extends E&gt; iterator)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (E e : iterator) &#123;</span><br><span class=\"line\">    push(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>생산자(producer) 파라미터란, 파라미터로 제공되어 메서드 내에서 사용 될 객체를 공급해 주는 파라미터이다.</p>\n<p><code>&lt;? extends E&gt;</code> 형태로 사용하는 경우 E 타입의 하위타입만 파라미터로 올 수 있게 제약을 거는 것이다.<br>\n<code>모든 타입은 자기 자신의 하위타입이다!</code> 라는 규칙이 있으므로 자기 자신에 대한 타입도 들어올 수 있다.</p>\n<h1>소비자(consumer) 와일드카드 적용</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">popAll</span><span class=\"params\">(Collection&lt;E&gt; dst)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!isEmpty()) &#123;</span><br><span class=\"line\">    dst.add(pop());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack&lt;Number&gt; numberStack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">Collection&lt;Object&gt; objects = List.of(<span class=\"number\">1</span>, <span class=\"string\">\"String\"</span>);</span><br><span class=\"line\">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure></p>\n<p>컴파일 하게되면 Collection&lt;Object&gt;는 Collection&lt;Number&gt;의 하위타입이 아니다라는 오류가 나온다.<br>\n이를 해결하기 위해서는 super를 이용해 와일드카드를 작성해야 한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">popAll</span><span class=\"params\">(Collection&lt;? <span class=\"keyword\">super</span> E&gt; dst)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!isEmpty()) &#123;</span><br><span class=\"line\">    dst.add(pop());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>소비자(consumer) 파라미터란, 메서드에 제공되어 메서드 내에서 제공되는 객체를 자기 자신이 사용하는 파라미터를 의미한다.</p>\n<h1>PECS(Producer-Extends, Consumer-Super)</h1>\n<p>다음 공식을 외워 어떤 와일드 카드 타입을 쓸지 기억하자</p>\n<ul>\n<li>생산자(producer) - Generic 클래스 내에 타입 파라미터를 이용해 객체를 제공하는 것\n<ul>\n<li>&lt;? extends E&gt;를 사용하여 유연성을 높일 수 있다.</li>\n</ul>\n</li>\n<li>소비자(consumer) - Generic 클래스 내의 자원을 사용하는 객체를 파라미터로 전달하는 것\n<ul>\n<li>&lt;? super E&gt;를 사용하여 유연성을 높일 수 있다.</li>\n<li>Comparable, Comparator는 소비자로 사용된다.</li>\n</ul>\n</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Integer&gt; integers = Set.of(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">Set&lt;Double&gt; doubles = Set.of(<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>);</span><br><span class=\"line\">Set&lt;Number&gt; numbers = union(integers, doubles);</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;E&gt; <span class=\"function\">Set&lt;E&gt; <span class=\"title\">union</span><span class=\"params\">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</span><br><span class=\"line\">  Set&lt;E&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">  set.addAll(integers);</span><br><span class=\"line\">  set.addAll(doubles);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> set;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위와 같이 메서드가 만들어지면 타입이 맞지 않는다고 컴파일 오류가 나게 된다.<br>\nSet&lt;E&gt;은 불공변이기 때문에 Set&lt;Integer&gt;와 Set&lt;Double&gt;은 Set&lt;Number&gt;의 하위타입이 아니기 떄문이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;E&gt; <span class=\"function\">Set&lt;E&gt; <span class=\"title\">union</span><span class=\"params\">(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2)</span> </span>&#123;</span><br><span class=\"line\">  Set&lt;E&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">  set.addAll(integers);</span><br><span class=\"line\">  set.addAll(doubles);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> set;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위와 같이 변경하면 컴파일 오류도 해결되고 잘 실행 된다.\n이렇게 공통 API를 작성할 때는 와일드 카드를 적절하게 쓰도록 하자.<br>\n클래스 사용자가 와일드카드 타입을 신경써야 한다면, 그 API에 문제가 있을 가능성이 크다.</p>\n<h2>Java7에서는...</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);</span><br></pre></td></tr></table></figure></p>\n<p>위와 같은 형태로 명시적으로 타입인수를 사용해야 한다.<br>\n타입추론능력이 부족하기 때문이다.</p>\n<h1>심화 - Comparable</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class=\"function\">E <span class=\"title\">max</span><span class=\"params\">(List&lt;E&gt; list)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>와일드카드를 통해 좀 더 다듬은 모습이다.<br>\n<strong>주의: Comparable을 구현한 클래스만 파라미터로 올 수 있다</strong>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;E extends Comparable&lt;? <span class=\"keyword\">super</span> E&gt;&gt; <span class=\"function\">E <span class=\"title\">ma</span><span class=\"params\">(List&lt;? extends E&gt; list)</span> </span>&#123;</span><br><span class=\"line\">           list.sort(Comparator.reverseOrder());</span><br><span class=\"line\">           <span class=\"keyword\">return</span> list.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>일반적으로는 Comparable&lt;E&gt;보단 Comparable&lt;? super E&gt;를 사용하는게 낫다. (대부분 소비자로 사용)</li>\n</ul>\n<h1>심화2 - 와일드카드를 적절히 사용하라</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;E&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(List&lt;E&gt; list, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(List&lt;?&gt; list, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>리스트 내의 특정 인자들의 위치를 뒤바꿔주는 메서드이다.<br>\n어느 메서드가 더 좋을까?</p>\n<p>기본적으로는 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하는 것이 좋다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(List&lt;?&gt; list, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">  list.set(i, list.set(j, list.get(i)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 코드는 list.get하는 부분에서 컴파일 오류가 난다.\n비한정적 와일드카드를 사용하고 있기 때문에 list.set을 하는 경우에는 null밖에 넣을 수가 없다.<br>\n이런 경우 도우미 메서드를 따로 이용한다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;E&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swapHelper</span><span class=\"params\">(List&lt;E&gt; list, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">  list.set(i, list.set(j, list.get(i)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이 경우에는 List&lt;E&gt;의 리턴타입이 항상 E인 것을 알기 때문에<br>\n런타임 시, 타입안정성을 보장 할 수 있고 set하는 경우에도 E 타입을 set할 것을 알기 때문에 컴파일 오류 없이 작동 한다.</p>\n<h1>정리</h1>\n<p>조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다.<br>\n그러나 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해야 한다.<br>\nPECS 공식을 기억하여 생산자에는 extends, 소비자에는 super를 사용하자.</p>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 31. 한정적 와일드 카드(bounded wildcard type)를 사용해 API 유연성을 높여라</li>\n</ul>\n"},{"title":"Item 4. 인스턴스화를 막으려거든 Private 생성자를 사용하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item4","typora-copy-images-to":"effective-java-item4","date":"2019-01-07T11:44:23.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\n단순히 static 메서드와 static 필드만을 담은 클래스를 만들고 싶을 때가 있다.  \n보통 Utils 클래스를 정의할 떄 이런식으로 많이 사용하는데, 이러한 클래스는 인스턴스를 만들어서 사용하고자 만든 목적이 아니기 때문에 인스턴스화를 막아야 한다.  \n생성자를 하나도 명시 하지 않으면 Java에서는 매개변수가 없는 default 생성자를 만들어 준다. \n\n# 추상 클래스로 만들면?\n추상 클래스로 만드는 것으로는 인스턴스 화를 막을 수 없다.  \n단순히 상속을 통해 인스턴스를 만들 수 있기 때문이다. 오히려 abstract 클래스는 하위클래스를 만들어서 사용하라는 뉘앙스가 더 강하다.\n\n# private 생성자를 만들자\nprivate 생성자를 만드는 것 만으로도 인스턴스화를 막을 수 있다.\n외부에서 new 키워드를 통해 인스턴스를 만들 수 없기 때문이다.\n\n이중 보안을 하자면.. \n```java\nprivate Utils() {\n  throw new AssertionError();\n}\n```\n이런 식으로 Error를 발생 시켜주자.\n\n평소 코딩할 때는 Lombok을 이용해서 깔끔하게 등록해 주는 것도 방법이다.\n\n```java\n@NoArgsConstructor(access = AccessLevel.PRIVATE)\nclass Utils() {\n}\n```\n\n# 참고\n* Effective Java 3rd Edition - Item 4. 인스턴스화를 막으려거든 private 생성자를 사용하라\n\n","source":"_posts/effective-java-item4.md","raw":"---\ntitle: Item 4. 인스턴스화를 막으려거든 private 생성자를 사용하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item4\ntypora-copy-images-to: effective-java-item4\ndate: 2019-01-07 20:44:23\nsubtitle:\nheader-img:\n---\n\n# 서론\n단순히 static 메서드와 static 필드만을 담은 클래스를 만들고 싶을 때가 있다.  \n보통 Utils 클래스를 정의할 떄 이런식으로 많이 사용하는데, 이러한 클래스는 인스턴스를 만들어서 사용하고자 만든 목적이 아니기 때문에 인스턴스화를 막아야 한다.  \n생성자를 하나도 명시 하지 않으면 Java에서는 매개변수가 없는 default 생성자를 만들어 준다. \n\n# 추상 클래스로 만들면?\n추상 클래스로 만드는 것으로는 인스턴스 화를 막을 수 없다.  \n단순히 상속을 통해 인스턴스를 만들 수 있기 때문이다. 오히려 abstract 클래스는 하위클래스를 만들어서 사용하라는 뉘앙스가 더 강하다.\n\n# private 생성자를 만들자\nprivate 생성자를 만드는 것 만으로도 인스턴스화를 막을 수 있다.\n외부에서 new 키워드를 통해 인스턴스를 만들 수 없기 때문이다.\n\n이중 보안을 하자면.. \n```java\nprivate Utils() {\n  throw new AssertionError();\n}\n```\n이런 식으로 Error를 발생 시켜주자.\n\n평소 코딩할 때는 Lombok을 이용해서 깔끔하게 등록해 주는 것도 방법이다.\n\n```java\n@NoArgsConstructor(access = AccessLevel.PRIVATE)\nclass Utils() {\n}\n```\n\n# 참고\n* Effective Java 3rd Edition - Item 4. 인스턴스화를 막으려거든 private 생성자를 사용하라\n\n","slug":"effective-java-item4","published":1,"updated":"2019-01-07T13:32:09.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2s90014cr1th8j8cbb9","content":"<h1 id=\"서론\">서론</h1>\n<p>단순히 static 메서드와 static 필드만을 담은 클래스를 만들고 싶을 때가 있다.<br>\n보통 Utils 클래스를 정의할 떄 이런식으로 많이 사용하는데, 이러한 클래스는 인스턴스를 만들어서 사용하고자 만든 목적이 아니기 때문에 인스턴스화를 막아야 한다.<br>\n생성자를 하나도 명시 하지 않으면 Java에서는 매개변수가 없는 default 생성자를 만들어 준다.</p>\n<h1 id=\"추상-클래스로-만들면\">추상 클래스로 만들면?</h1>\n<p>추상 클래스로 만드는 것으로는 인스턴스 화를 막을 수 없다.<br>\n단순히 상속을 통해 인스턴스를 만들 수 있기 때문이다. 오히려 abstract 클래스는 하위클래스를 만들어서 사용하라는 뉘앙스가 더 강하다.</p>\n<h1 id=\"private-생성자를-만들자\">private 생성자를 만들자</h1>\n<p>private 생성자를 만드는 것 만으로도 인스턴스화를 막을 수 있다.\n외부에서 new 키워드를 통해 인스턴스를 만들 수 없기 때문이다.</p>\n<p>이중 보안을 하자면..\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Utils</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이런 식으로 Error를 발생 시켜주자.</p>\n<p>평소 코딩할 때는 Lombok을 이용해서 깔끔하게 등록해 주는 것도 방법이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Utils</span>() </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 4. 인스턴스화를 막으려거든 private 생성자를 사용하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>단순히 static 메서드와 static 필드만을 담은 클래스를 만들고 싶을 때가 있다.<br>\n보통 Utils 클래스를 정의할 떄 이런식으로 많이 사용하는데, 이러한 클래스는 인스턴스를 만들어서 사용하고자 만든 목적이 아니기 때문에 인스턴스화를 막아야 한다.<br>\n생성자를 하나도 명시 하지 않으면 Java에서는 매개변수가 없는 default 생성자를 만들어 준다.</p>\n<h1>추상 클래스로 만들면?</h1>\n<p>추상 클래스로 만드는 것으로는 인스턴스 화를 막을 수 없다.<br>\n단순히 상속을 통해 인스턴스를 만들 수 있기 때문이다. 오히려 abstract 클래스는 하위클래스를 만들어서 사용하라는 뉘앙스가 더 강하다.</p>\n<h1>private 생성자를 만들자</h1>\n<p>private 생성자를 만드는 것 만으로도 인스턴스화를 막을 수 있다.\n외부에서 new 키워드를 통해 인스턴스를 만들 수 없기 때문이다.</p>\n<p>이중 보안을 하자면..\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Utils</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이런 식으로 Error를 발생 시켜주자.</p>\n<p>평소 코딩할 때는 Lombok을 이용해서 깔끔하게 등록해 주는 것도 방법이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Utils</span>() </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 4. 인스턴스화를 막으려거든 private 생성자를 사용하라</li>\n</ul>\n"},{"title":"Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item32","typora-copy-images-to":"effective-java-item32","date":"2019-01-28T10:27:16.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\n가변인수(varargs) 메서드와 제네릭은 Java 5버전에 함께 추가되었다.  \n서로 잘 어우러지리라 생각하겠지만, 그렇지 않다. 가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는데, 구현방식에 헛점이 있다.  \n가변인수 메서드를 호출하면, 가변인수를 담기 위한 배열이 자동으로 하나 만들어진다.  \n그 결과 varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생한다.\n\n실제화 불가 타입은 런타임에는 컴파일타임보다 타입관련 정보를 적게 담고 있다`(소거)`\n\n# 제네릭과 varargs를 혼용하면 타입 안정성이 깨진다.\n매개변수화 타입(Parameterize Type (예 List<String>))의 변수가 타입이 다른 객체를 참조하면 **힙 오염**이 발생한다.\n\n```java\nstatic void dangerous(List<String>... stringLists) {\n  List<Integer> intList = List.of(42);\n  //varargs는 내부적으로 배열이고\n  //배열은 공변이기 때문에 List<String>타입은 Object의 하위클래스로 인식되어\n  //Object[]에 참조 될 수 있다.\n  Object[] objects = stringLists;\n  Object[0] = intList; //힙 오염 발생\n  String s = stringLists[0].get(0); // ClassCastException\n}\n```\n위의 코드를 한줄한줄 분석해보자\n1. List<String> varargs형태의 파라미터를 받는 메서드이다.\n2. List<Integer> 제네릭타입 객체를 생성하여 42라는 값을 추가하였다.\n3. varargs는 내부적으로 배열이고, 배열은 공변이기 때문에 List<String>[] -> Object[]에 참조될 수 있다.\n4. Object[0] = intList 초기화  \n(내부적으로는 List<String> 타입이지만, 런타임에는 제네릭 타입이 소거되므로 같은 List로만 인식되어 할당이 가능하다. **힙 오염 발생**)\n5. stringList[0]을 하면 List가 나오고 List의 0번째 인덱스 위치의 객체를 호출해 눈에 보이지 않는 String으로 형변환한다.  \n-> 여기서 ClassCastException이 발생 \n\n이처럼 타입안정성이 깨지기 때문에 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다.  \n(실제로 실무에서는 저런 경우는 거의 없다. 웬만하면 varargs 형태로 받아와서 그대로 사용하기 때문)\n\n# @SafeVarargs\n자바 7 전에는 제네릭 가변인수 메서드의 작성자가 호출자 쪽에서 발생하는 경고에 대해서 해줄 수 있는 일이 없었다.  \n사용자는 이 경고를 그냥 무시하거나, 사용하는 메서드에서 @SupprssWarning(\"unchecked\") annotation을 달아 경고를 숨겨야 했다.  \n자바 7부터 @SafeVarargs annotation이 추가되어 제네릭 가변인수 메서드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있게 되었다.\n\n단, @SafeVarargs annotation은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치이므로  \n반드시 메서드가 타입 안전한 경우에만 이 annotation을 붙이는 것이 좋다.\n\n## 어떤게 타입 안전할까?\n* 가변인수 메서드를 호출하면 varargs 매개변수를 담는 제네릭 배열이 만들어 진다.  \n* 메서드 내에서 이 배열에 아무것도 저장하지 않고, 배열의 참조가 밖으로 노출되지 않는다면 타입 안전하다.\n* 순수하게 메서드의 생산자 역할만 충실히 하면 메서드는 안전하다.\n\n## 자신의 제네릭 매개변수 배열의 참조를 노출하는 것은 위험하다.\n```java\nstatic <T> T[] toArray(T... args) {\n  return args;\n}\n```\n```java\nstatic <T> T[] pickTwo(T a, T b, T c) {\n  switch(ThreadLocalRandom.current().nextInt(3)) {\n    case 0: return toArray(a, b);\n    case 1: return toArray(b, c);\n    case 2: return toArray(c, a);\n  }\n  throw new AssertiionError();\n}\n```\n```java\npublic static void main(String[] args) {\n  String[] attributes = pickTwo(\"좋은\", \"빠른\", \"저렴한\");\n}\n```\n아무 문제가 없는 메서드이니 별다른 문제없이 컴파일 된다.  \n하지만 실행하면 ClassCastException을 던진다.  \n어디서 발생하는 에러일까?\n\n정답은 바로 String[] attributes = pickTwo(); 메서드에서 보이지 않는 형변환 시 발생한다.\n\n실제로는 아래와 같다.\n```java\nString[] attributes = (String[]) pickTwo(\"좋은\", \"빠른\", \"저렴한\");\n```\nObject[]는 String[]의 `하위타입`이 아니므로 형변환할 수 없다. (다운캐스팅 불가)  \n이 예시는 **제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다.** 를 다시금 알려주는 예제이다.\n\n단 예외가 두 가지 있다.\n* @SafeVarargs로 선언된 타입 안전성이 보장된 또 다른 varargs 메서드에 넘기는 것은 안전하다.\n* 배열 내용의 일부 함수를 호출만 하는 (varargs를 받지않는) 일반 메서드에 넘기는 것도 안전하다.\n\n# 제네릭 varargs 매개변수를 안전하게 사용하는 메서드\n```java\n@SafeVarargs\nstatic <T> List<T> flatten(List<? extends T>... lists) {\n  List<T> result = new ArrayList<>();\n  for(List<? extends T> list : lists) {\n    result.addAll(list);\n  }\n  return result;\n}\n```\n\n위의 메서드는 안전하다.  \nvarargs 배열을 직접 노출 시키지 않고, T타입의 제네릭 타입을 사용하였기 때문에 ClassCastException 또한 발생할 일이 없다.  \n안전한 varargs 메서드에는 @SafeVarargs annotation을 달아서 컴파일러 경고를 없애는 것이 좋다.\n\n# 제네릭 varargs 매개변수를 List로 대체하라\n```java\nstatic <T> List<T> flatten(List<List<? extends T>> lists) {\n  List<T> result = new ArrayList<>();\n  for (List<? extends T> list : lists) {\n    result.addAll(list);\n  }\n  return result;\n}\n```\n이 방식의 장점은 이 메서드의 타입 안전성을 검증할 수 있다는 점이다.  \n@SafeVarargs를 달지 않아도 되며 실수로 안전하다고 판단할 걱정도 없다.  \n단점은 클라이언트 코드가 살짝 지저분해지고, 속도가 약간 느려질 수 있다는 점이다.\n\n\n# 정리\n* varargs 매개변수는 단순히 파라미터를 받아와 메서드의 생산자(T 타입의 객체를 제공하는 용도)로만 사용하자\n* varargs는 read-only라고 생각하고, 아무런 데이터를 저장하지 말자\n* varargs 배열을 외부에 리턴하거나 노출하지 말자.  \n웬만하면 다시 컬렉션(List)에 담아 리턴하는 안전한 방식을 취하자\n\n\n# 참고\n* Effective Java 3rd Edition - Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라","source":"_posts/effective-java-item32.md","raw":"---\ntitle: Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item32\ntypora-copy-images-to: effective-java-item32\ndate: 2019-01-28 19:27:16\nsubtitle:\nheader-img:\n---\n\n# 서론\n가변인수(varargs) 메서드와 제네릭은 Java 5버전에 함께 추가되었다.  \n서로 잘 어우러지리라 생각하겠지만, 그렇지 않다. 가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는데, 구현방식에 헛점이 있다.  \n가변인수 메서드를 호출하면, 가변인수를 담기 위한 배열이 자동으로 하나 만들어진다.  \n그 결과 varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생한다.\n\n실제화 불가 타입은 런타임에는 컴파일타임보다 타입관련 정보를 적게 담고 있다`(소거)`\n\n# 제네릭과 varargs를 혼용하면 타입 안정성이 깨진다.\n매개변수화 타입(Parameterize Type (예 List<String>))의 변수가 타입이 다른 객체를 참조하면 **힙 오염**이 발생한다.\n\n```java\nstatic void dangerous(List<String>... stringLists) {\n  List<Integer> intList = List.of(42);\n  //varargs는 내부적으로 배열이고\n  //배열은 공변이기 때문에 List<String>타입은 Object의 하위클래스로 인식되어\n  //Object[]에 참조 될 수 있다.\n  Object[] objects = stringLists;\n  Object[0] = intList; //힙 오염 발생\n  String s = stringLists[0].get(0); // ClassCastException\n}\n```\n위의 코드를 한줄한줄 분석해보자\n1. List<String> varargs형태의 파라미터를 받는 메서드이다.\n2. List<Integer> 제네릭타입 객체를 생성하여 42라는 값을 추가하였다.\n3. varargs는 내부적으로 배열이고, 배열은 공변이기 때문에 List<String>[] -> Object[]에 참조될 수 있다.\n4. Object[0] = intList 초기화  \n(내부적으로는 List<String> 타입이지만, 런타임에는 제네릭 타입이 소거되므로 같은 List로만 인식되어 할당이 가능하다. **힙 오염 발생**)\n5. stringList[0]을 하면 List가 나오고 List의 0번째 인덱스 위치의 객체를 호출해 눈에 보이지 않는 String으로 형변환한다.  \n-> 여기서 ClassCastException이 발생 \n\n이처럼 타입안정성이 깨지기 때문에 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다.  \n(실제로 실무에서는 저런 경우는 거의 없다. 웬만하면 varargs 형태로 받아와서 그대로 사용하기 때문)\n\n# @SafeVarargs\n자바 7 전에는 제네릭 가변인수 메서드의 작성자가 호출자 쪽에서 발생하는 경고에 대해서 해줄 수 있는 일이 없었다.  \n사용자는 이 경고를 그냥 무시하거나, 사용하는 메서드에서 @SupprssWarning(\"unchecked\") annotation을 달아 경고를 숨겨야 했다.  \n자바 7부터 @SafeVarargs annotation이 추가되어 제네릭 가변인수 메서드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있게 되었다.\n\n단, @SafeVarargs annotation은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치이므로  \n반드시 메서드가 타입 안전한 경우에만 이 annotation을 붙이는 것이 좋다.\n\n## 어떤게 타입 안전할까?\n* 가변인수 메서드를 호출하면 varargs 매개변수를 담는 제네릭 배열이 만들어 진다.  \n* 메서드 내에서 이 배열에 아무것도 저장하지 않고, 배열의 참조가 밖으로 노출되지 않는다면 타입 안전하다.\n* 순수하게 메서드의 생산자 역할만 충실히 하면 메서드는 안전하다.\n\n## 자신의 제네릭 매개변수 배열의 참조를 노출하는 것은 위험하다.\n```java\nstatic <T> T[] toArray(T... args) {\n  return args;\n}\n```\n```java\nstatic <T> T[] pickTwo(T a, T b, T c) {\n  switch(ThreadLocalRandom.current().nextInt(3)) {\n    case 0: return toArray(a, b);\n    case 1: return toArray(b, c);\n    case 2: return toArray(c, a);\n  }\n  throw new AssertiionError();\n}\n```\n```java\npublic static void main(String[] args) {\n  String[] attributes = pickTwo(\"좋은\", \"빠른\", \"저렴한\");\n}\n```\n아무 문제가 없는 메서드이니 별다른 문제없이 컴파일 된다.  \n하지만 실행하면 ClassCastException을 던진다.  \n어디서 발생하는 에러일까?\n\n정답은 바로 String[] attributes = pickTwo(); 메서드에서 보이지 않는 형변환 시 발생한다.\n\n실제로는 아래와 같다.\n```java\nString[] attributes = (String[]) pickTwo(\"좋은\", \"빠른\", \"저렴한\");\n```\nObject[]는 String[]의 `하위타입`이 아니므로 형변환할 수 없다. (다운캐스팅 불가)  \n이 예시는 **제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다.** 를 다시금 알려주는 예제이다.\n\n단 예외가 두 가지 있다.\n* @SafeVarargs로 선언된 타입 안전성이 보장된 또 다른 varargs 메서드에 넘기는 것은 안전하다.\n* 배열 내용의 일부 함수를 호출만 하는 (varargs를 받지않는) 일반 메서드에 넘기는 것도 안전하다.\n\n# 제네릭 varargs 매개변수를 안전하게 사용하는 메서드\n```java\n@SafeVarargs\nstatic <T> List<T> flatten(List<? extends T>... lists) {\n  List<T> result = new ArrayList<>();\n  for(List<? extends T> list : lists) {\n    result.addAll(list);\n  }\n  return result;\n}\n```\n\n위의 메서드는 안전하다.  \nvarargs 배열을 직접 노출 시키지 않고, T타입의 제네릭 타입을 사용하였기 때문에 ClassCastException 또한 발생할 일이 없다.  \n안전한 varargs 메서드에는 @SafeVarargs annotation을 달아서 컴파일러 경고를 없애는 것이 좋다.\n\n# 제네릭 varargs 매개변수를 List로 대체하라\n```java\nstatic <T> List<T> flatten(List<List<? extends T>> lists) {\n  List<T> result = new ArrayList<>();\n  for (List<? extends T> list : lists) {\n    result.addAll(list);\n  }\n  return result;\n}\n```\n이 방식의 장점은 이 메서드의 타입 안전성을 검증할 수 있다는 점이다.  \n@SafeVarargs를 달지 않아도 되며 실수로 안전하다고 판단할 걱정도 없다.  \n단점은 클라이언트 코드가 살짝 지저분해지고, 속도가 약간 느려질 수 있다는 점이다.\n\n\n# 정리\n* varargs 매개변수는 단순히 파라미터를 받아와 메서드의 생산자(T 타입의 객체를 제공하는 용도)로만 사용하자\n* varargs는 read-only라고 생각하고, 아무런 데이터를 저장하지 말자\n* varargs 배열을 외부에 리턴하거나 노출하지 말자.  \n웬만하면 다시 컬렉션(List)에 담아 리턴하는 안전한 방식을 취하자\n\n\n# 참고\n* Effective Java 3rd Edition - Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라","slug":"effective-java-item32","published":1,"updated":"2019-01-29T10:59:40.321Z","_id":"cjrgbv2sa0016cr1t8edk0gqf","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"서론\">서론</h1>\n<p>가변인수(varargs) 메서드와 제네릭은 Java 5버전에 함께 추가되었다.<br>\n서로 잘 어우러지리라 생각하겠지만, 그렇지 않다. 가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는데, 구현방식에 헛점이 있다.<br>\n가변인수 메서드를 호출하면, 가변인수를 담기 위한 배열이 자동으로 하나 만들어진다.<br>\n그 결과 varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생한다.</p>\n<p>실제화 불가 타입은 런타임에는 컴파일타임보다 타입관련 정보를 적게 담고 있다<code>(소거)</code></p>\n<h1 id=\"제네릭과-varargs를-혼용하면-타입-안정성이-깨진다\">제네릭과 varargs를 혼용하면 타입 안정성이 깨진다.</h1>\n<p>매개변수화 타입(Parameterize Type (예 List&lt;String&gt;))의 변수가 타입이 다른 객체를 참조하면 <strong>힙 오염</strong>이 발생한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dangerous</span><span class=\"params\">(List&lt;String&gt;... stringLists)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;Integer&gt; intList = List.of(<span class=\"number\">42</span>);</span><br><span class=\"line\">  <span class=\"comment\">//varargs는 내부적으로 배열이고</span></span><br><span class=\"line\">  <span class=\"comment\">//배열은 공변이기 때문에 List&lt;String&gt;타입은 Object의 하위클래스로 인식되어</span></span><br><span class=\"line\">  <span class=\"comment\">//Object[]에 참조 될 수 있다.</span></span><br><span class=\"line\">  Object[] objects = stringLists;</span><br><span class=\"line\">  Object[<span class=\"number\">0</span>] = intList; <span class=\"comment\">//힙 오염 발생</span></span><br><span class=\"line\">  String s = stringLists[<span class=\"number\">0</span>].get(<span class=\"number\">0</span>); <span class=\"comment\">// ClassCastException</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 코드를 한줄한줄 분석해보자</p>\n<ol>\n<li>List&lt;String&gt; varargs형태의 파라미터를 받는 메서드이다.</li>\n<li>List&lt;Integer&gt; 제네릭타입 객체를 생성하여 42라는 값을 추가하였다.</li>\n<li>varargs는 내부적으로 배열이고, 배열은 공변이기 때문에 List&lt;String&gt;[] -&gt; Object[]에 참조될 수 있다.</li>\n<li>Object[0] = intList 초기화<br>\n(내부적으로는 List&lt;String&gt; 타입이지만, 런타임에는 제네릭 타입이 소거되므로 같은 List로만 인식되어 할당이 가능하다. <strong>힙 오염 발생</strong>)</li>\n<li>stringList[0]을 하면 List가 나오고 List의 0번째 인덱스 위치의 객체를 호출해 눈에 보이지 않는 String으로 형변환한다.<br>\n-&gt; 여기서 ClassCastException이 발생</li>\n</ol>\n<p>이처럼 타입안정성이 깨지기 때문에 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다.<br>\n(실제로 실무에서는 저런 경우는 거의 없다. 웬만하면 varargs 형태로 받아와서 그대로 사용하기 때문)</p>\n<h1 id=\"safevarargs\">@SafeVarargs</h1>\n<p>자바 7 전에는 제네릭 가변인수 메서드의 작성자가 호출자 쪽에서 발생하는 경고에 대해서 해줄 수 있는 일이 없었다.<br>\n사용자는 이 경고를 그냥 무시하거나, 사용하는 메서드에서 @SupprssWarning(&quot;unchecked&quot;) annotation을 달아 경고를 숨겨야 했다.<br>\n자바 7부터 @SafeVarargs annotation이 추가되어 제네릭 가변인수 메서드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있게 되었다.</p>\n<p>단, @SafeVarargs annotation은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치이므로<br>\n반드시 메서드가 타입 안전한 경우에만 이 annotation을 붙이는 것이 좋다.</p>\n<h2 id=\"어떤게-타입-안전할까\">어떤게 타입 안전할까?</h2>\n<ul>\n<li>가변인수 메서드를 호출하면 varargs 매개변수를 담는 제네릭 배열이 만들어 진다.</li>\n<li>메서드 내에서 이 배열에 아무것도 저장하지 않고, 배열의 참조가 밖으로 노출되지 않는다면 타입 안전하다.</li>\n<li>순수하게 메서드의 생산자 역할만 충실히 하면 메서드는 안전하다.</li>\n</ul>\n<h2 id=\"자신의-제네릭-매개변수-배열의-참조를-노출하는-것은-위험하다\">자신의 제네릭 매개변수 배열의 참조를 노출하는 것은 위험하다.</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;T&gt; T[] toArray(T... args) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> args;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;T&gt; T[] pickTwo(T a, T b, T c) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(ThreadLocalRandom.current().nextInt(<span class=\"number\">3</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> toArray(a, b);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> toArray(b, c);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> toArray(c, a);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertiionError();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  String[] attributes = pickTwo(<span class=\"string\">\"좋은\"</span>, <span class=\"string\">\"빠른\"</span>, <span class=\"string\">\"저렴한\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>아무 문제가 없는 메서드이니 별다른 문제없이 컴파일 된다.<br>\n하지만 실행하면 ClassCastException을 던진다.<br>\n어디서 발생하는 에러일까?</p>\n<p>정답은 바로 String[] attributes = pickTwo(); 메서드에서 보이지 않는 형변환 시 발생한다.</p>\n<p>실제로는 아래와 같다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] attributes = (String[]) pickTwo(<span class=\"string\">\"좋은\"</span>, <span class=\"string\">\"빠른\"</span>, <span class=\"string\">\"저렴한\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>Object[]는 String[]의 <code>하위타입</code>이 아니므로 형변환할 수 없다. (다운캐스팅 불가)<br>\n이 예시는 <strong>제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다.</strong> 를 다시금 알려주는 예제이다.</p>\n<p>단 예외가 두 가지 있다.</p>\n<ul>\n<li>@SafeVarargs로 선언된 타입 안전성이 보장된 또 다른 varargs 메서드에 넘기는 것은 안전하다.</li>\n<li>배열 내용의 일부 함수를 호출만 하는 (varargs를 받지않는) 일반 메서드에 넘기는 것도 안전하다.</li>\n</ul>\n<h1 id=\"제네릭-varargs-매개변수를-안전하게-사용하는-메서드\">제네릭 varargs 매개변수를 안전하게 사용하는 메서드</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SafeVarargs</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">flatten</span><span class=\"params\">(List&lt;? extends T&gt;... lists)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;T&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(List&lt;? extends T&gt; list : lists) &#123;</span><br><span class=\"line\">    result.addAll(list);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 메서드는 안전하다.<br>\nvarargs 배열을 직접 노출 시키지 않고, T타입의 제네릭 타입을 사용하였기 때문에 ClassCastException 또한 발생할 일이 없다.<br>\n안전한 varargs 메서드에는 @SafeVarargs annotation을 달아서 컴파일러 경고를 없애는 것이 좋다.</p>\n<h1 id=\"제네릭-varargs-매개변수를-list로-대체하라\">제네릭 varargs 매개변수를 List로 대체하라</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">flatten</span><span class=\"params\">(List&lt;List&lt;? extends T&gt;&gt; lists)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;T&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (List&lt;? extends T&gt; list : lists) &#123;</span><br><span class=\"line\">    result.addAll(list);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이 방식의 장점은 이 메서드의 타입 안전성을 검증할 수 있다는 점이다.<br>\n@SafeVarargs를 달지 않아도 되며 실수로 안전하다고 판단할 걱정도 없다.<br>\n단점은 클라이언트 코드가 살짝 지저분해지고, 속도가 약간 느려질 수 있다는 점이다.</p>\n<h1 id=\"정리\">정리</h1>\n<ul>\n<li>varargs 매개변수는 단순히 파라미터를 받아와 메서드의 생산자(T 타입의 객체를 제공하는 용도)로만 사용하자</li>\n<li>varargs는 read-only라고 생각하고, 아무런 데이터를 저장하지 말자</li>\n<li>varargs 배열을 외부에 리턴하거나 노출하지 말자.<br>\n웬만하면 다시 컬렉션(List)에 담아 리턴하는 안전한 방식을 취하자</li>\n</ul>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"category_generator":{"per_page":10},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>가변인수(varargs) 메서드와 제네릭은 Java 5버전에 함께 추가되었다.<br>\n서로 잘 어우러지리라 생각하겠지만, 그렇지 않다. 가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는데, 구현방식에 헛점이 있다.<br>\n가변인수 메서드를 호출하면, 가변인수를 담기 위한 배열이 자동으로 하나 만들어진다.<br>\n그 결과 varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생한다.</p>\n<p>실제화 불가 타입은 런타임에는 컴파일타임보다 타입관련 정보를 적게 담고 있다<code>(소거)</code></p>\n<h1>제네릭과 varargs를 혼용하면 타입 안정성이 깨진다.</h1>\n<p>매개변수화 타입(Parameterize Type (예 List&lt;String&gt;))의 변수가 타입이 다른 객체를 참조하면 <strong>힙 오염</strong>이 발생한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dangerous</span><span class=\"params\">(List&lt;String&gt;... stringLists)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;Integer&gt; intList = List.of(<span class=\"number\">42</span>);</span><br><span class=\"line\">  <span class=\"comment\">//varargs는 내부적으로 배열이고</span></span><br><span class=\"line\">  <span class=\"comment\">//배열은 공변이기 때문에 List&lt;String&gt;타입은 Object의 하위클래스로 인식되어</span></span><br><span class=\"line\">  <span class=\"comment\">//Object[]에 참조 될 수 있다.</span></span><br><span class=\"line\">  Object[] objects = stringLists;</span><br><span class=\"line\">  Object[<span class=\"number\">0</span>] = intList; <span class=\"comment\">//힙 오염 발생</span></span><br><span class=\"line\">  String s = stringLists[<span class=\"number\">0</span>].get(<span class=\"number\">0</span>); <span class=\"comment\">// ClassCastException</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 코드를 한줄한줄 분석해보자</p>\n<ol>\n<li>List&lt;String&gt; varargs형태의 파라미터를 받는 메서드이다.</li>\n<li>List&lt;Integer&gt; 제네릭타입 객체를 생성하여 42라는 값을 추가하였다.</li>\n<li>varargs는 내부적으로 배열이고, 배열은 공변이기 때문에 List&lt;String&gt;[] -&gt; Object[]에 참조될 수 있다.</li>\n<li>Object[0] = intList 초기화<br>\n(내부적으로는 List&lt;String&gt; 타입이지만, 런타임에는 제네릭 타입이 소거되므로 같은 List로만 인식되어 할당이 가능하다. <strong>힙 오염 발생</strong>)</li>\n<li>stringList[0]을 하면 List가 나오고 List의 0번째 인덱스 위치의 객체를 호출해 눈에 보이지 않는 String으로 형변환한다.<br>\n-&gt; 여기서 ClassCastException이 발생</li>\n</ol>\n<p>이처럼 타입안정성이 깨지기 때문에 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다.<br>\n(실제로 실무에서는 저런 경우는 거의 없다. 웬만하면 varargs 형태로 받아와서 그대로 사용하기 때문)</p>\n<h1>@SafeVarargs</h1>\n<p>자바 7 전에는 제네릭 가변인수 메서드의 작성자가 호출자 쪽에서 발생하는 경고에 대해서 해줄 수 있는 일이 없었다.<br>\n사용자는 이 경고를 그냥 무시하거나, 사용하는 메서드에서 @SupprssWarning(&quot;unchecked&quot;) annotation을 달아 경고를 숨겨야 했다.<br>\n자바 7부터 @SafeVarargs annotation이 추가되어 제네릭 가변인수 메서드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있게 되었다.</p>\n<p>단, @SafeVarargs annotation은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치이므로<br>\n반드시 메서드가 타입 안전한 경우에만 이 annotation을 붙이는 것이 좋다.</p>\n<h2>어떤게 타입 안전할까?</h2>\n<ul>\n<li>가변인수 메서드를 호출하면 varargs 매개변수를 담는 제네릭 배열이 만들어 진다.</li>\n<li>메서드 내에서 이 배열에 아무것도 저장하지 않고, 배열의 참조가 밖으로 노출되지 않는다면 타입 안전하다.</li>\n<li>순수하게 메서드의 생산자 역할만 충실히 하면 메서드는 안전하다.</li>\n</ul>\n<h2>자신의 제네릭 매개변수 배열의 참조를 노출하는 것은 위험하다.</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;T&gt; T[] toArray(T... args) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> args;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;T&gt; T[] pickTwo(T a, T b, T c) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(ThreadLocalRandom.current().nextInt(<span class=\"number\">3</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> toArray(a, b);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> toArray(b, c);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> toArray(c, a);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertiionError();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  String[] attributes = pickTwo(<span class=\"string\">\"좋은\"</span>, <span class=\"string\">\"빠른\"</span>, <span class=\"string\">\"저렴한\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>아무 문제가 없는 메서드이니 별다른 문제없이 컴파일 된다.<br>\n하지만 실행하면 ClassCastException을 던진다.<br>\n어디서 발생하는 에러일까?</p>\n<p>정답은 바로 String[] attributes = pickTwo(); 메서드에서 보이지 않는 형변환 시 발생한다.</p>\n<p>실제로는 아래와 같다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] attributes = (String[]) pickTwo(<span class=\"string\">\"좋은\"</span>, <span class=\"string\">\"빠른\"</span>, <span class=\"string\">\"저렴한\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>Object[]는 String[]의 <code>하위타입</code>이 아니므로 형변환할 수 없다. (다운캐스팅 불가)<br>\n이 예시는 <strong>제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다.</strong> 를 다시금 알려주는 예제이다.</p>\n<p>단 예외가 두 가지 있다.</p>\n<ul>\n<li>@SafeVarargs로 선언된 타입 안전성이 보장된 또 다른 varargs 메서드에 넘기는 것은 안전하다.</li>\n<li>배열 내용의 일부 함수를 호출만 하는 (varargs를 받지않는) 일반 메서드에 넘기는 것도 안전하다.</li>\n</ul>\n<h1>제네릭 varargs 매개변수를 안전하게 사용하는 메서드</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SafeVarargs</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">flatten</span><span class=\"params\">(List&lt;? extends T&gt;... lists)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;T&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(List&lt;? extends T&gt; list : lists) &#123;</span><br><span class=\"line\">    result.addAll(list);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 메서드는 안전하다.<br>\nvarargs 배열을 직접 노출 시키지 않고, T타입의 제네릭 타입을 사용하였기 때문에 ClassCastException 또한 발생할 일이 없다.<br>\n안전한 varargs 메서드에는 @SafeVarargs annotation을 달아서 컴파일러 경고를 없애는 것이 좋다.</p>\n<h1>제네릭 varargs 매개변수를 List로 대체하라</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">flatten</span><span class=\"params\">(List&lt;List&lt;? extends T&gt;&gt; lists)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;T&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (List&lt;? extends T&gt; list : lists) &#123;</span><br><span class=\"line\">    result.addAll(list);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이 방식의 장점은 이 메서드의 타입 안전성을 검증할 수 있다는 점이다.<br>\n@SafeVarargs를 달지 않아도 되며 실수로 안전하다고 판단할 걱정도 없다.<br>\n단점은 클라이언트 코드가 살짝 지저분해지고, 속도가 약간 느려질 수 있다는 점이다.</p>\n<h1>정리</h1>\n<ul>\n<li>varargs 매개변수는 단순히 파라미터를 받아와 메서드의 생산자(T 타입의 객체를 제공하는 용도)로만 사용하자</li>\n<li>varargs는 read-only라고 생각하고, 아무런 데이터를 저장하지 말자</li>\n<li>varargs 배열을 외부에 리턴하거나 노출하지 말자.<br>\n웬만하면 다시 컬렉션(List)에 담아 리턴하는 안전한 방식을 취하자</li>\n</ul>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라</li>\n</ul>\n"},{"title":"Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item5","typora-copy-images-to":"effective-java-item5","date":"2019-01-07T12:03:48.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\n사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 방식이나, 싱글턴 방식이 적합하지 않다.  \n자원에 따라 동작이 달라진다면, 자원의 수만큼 인스턴스를 만들어 동작하게 하는 것이 좋다.  \n이를 `의존 객체 주입`이라고 하는데 Spring과 같은 프레임워크에서 DI의 개념으로 많이 쓰이고 있다.\n\n의존 객체 주입은 생성자, 정적팩터리, 빌더 혹은 Setter를 이용해서 자원을 넘겨 줄 수 있다.\n\n# 팩터리 메서드 패턴 사용하여 자원 넘겨주기\n자바8에서는 Supplier<T> 인터페이스가 팩터리를 표현한 완벽한 예다.  \nSupplier<T>를 입력으로 받는 메서드는 일반적으로 한정적 와일드 카드 타입을 사용해 팩터리의 타입 매개변수를 제한한다.\n\n아래의 예제처럼 사용한다.\n타일들을 이용해 모자이크를 만드는 예제이다.\n```java\nMosaic create(Supplier<? extends Tile> tileFactory){}\n```\n\n# 요약\n* 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸 클래스는 사용하지 말자!\n* 필요한 자원 또는 팩터리를 생성자나 빌더를 통해 의존 객체를 주입하도록 하자\n* 의존 객체 주입은 유연성, 재사용성, 테스트 용이성을 높여 줄 것이다.\n\n# 참고\n* Effective Java 3rd Edition - Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라\n","source":"_posts/effective-java-item5.md","raw":"---\ntitle: Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item5\ntypora-copy-images-to: effective-java-item5\ndate: 2019-01-07 21:03:48\nsubtitle:\nheader-img:\n---\n\n# 서론\n사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 방식이나, 싱글턴 방식이 적합하지 않다.  \n자원에 따라 동작이 달라진다면, 자원의 수만큼 인스턴스를 만들어 동작하게 하는 것이 좋다.  \n이를 `의존 객체 주입`이라고 하는데 Spring과 같은 프레임워크에서 DI의 개념으로 많이 쓰이고 있다.\n\n의존 객체 주입은 생성자, 정적팩터리, 빌더 혹은 Setter를 이용해서 자원을 넘겨 줄 수 있다.\n\n# 팩터리 메서드 패턴 사용하여 자원 넘겨주기\n자바8에서는 Supplier<T> 인터페이스가 팩터리를 표현한 완벽한 예다.  \nSupplier<T>를 입력으로 받는 메서드는 일반적으로 한정적 와일드 카드 타입을 사용해 팩터리의 타입 매개변수를 제한한다.\n\n아래의 예제처럼 사용한다.\n타일들을 이용해 모자이크를 만드는 예제이다.\n```java\nMosaic create(Supplier<? extends Tile> tileFactory){}\n```\n\n# 요약\n* 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸 클래스는 사용하지 말자!\n* 필요한 자원 또는 팩터리를 생성자나 빌더를 통해 의존 객체를 주입하도록 하자\n* 의존 객체 주입은 유연성, 재사용성, 테스트 용이성을 높여 줄 것이다.\n\n# 참고\n* Effective Java 3rd Edition - Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라\n","slug":"effective-java-item5","published":1,"updated":"2019-01-07T13:32:09.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2sb0019cr1tct5czqms","content":"<h1 id=\"서론\">서론</h1>\n<p>사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 방식이나, 싱글턴 방식이 적합하지 않다.<br>\n자원에 따라 동작이 달라진다면, 자원의 수만큼 인스턴스를 만들어 동작하게 하는 것이 좋다.<br>\n이를 <code>의존 객체 주입</code>이라고 하는데 Spring과 같은 프레임워크에서 DI의 개념으로 많이 쓰이고 있다.</p>\n<p>의존 객체 주입은 생성자, 정적팩터리, 빌더 혹은 Setter를 이용해서 자원을 넘겨 줄 수 있다.</p>\n<h1 id=\"팩터리-메서드-패턴-사용하여-자원-넘겨주기\">팩터리 메서드 패턴 사용하여 자원 넘겨주기</h1>\n<p>자바8에서는 Supplier&lt;T&gt; 인터페이스가 팩터리를 표현한 완벽한 예다.<br>\nSupplier&lt;T&gt;를 입력으로 받는 메서드는 일반적으로 한정적 와일드 카드 타입을 사용해 팩터리의 타입 매개변수를 제한한다.</p>\n<p>아래의 예제처럼 사용한다.\n타일들을 이용해 모자이크를 만드는 예제이다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Mosaic <span class=\"title\">create</span><span class=\"params\">(Supplier&lt;? extends Tile&gt; tileFactory)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"요약\">요약</h1>\n<ul>\n<li>클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸 클래스는 사용하지 말자!</li>\n<li>필요한 자원 또는 팩터리를 생성자나 빌더를 통해 의존 객체를 주입하도록 하자</li>\n<li>의존 객체 주입은 유연성, 재사용성, 테스트 용이성을 높여 줄 것이다.</li>\n</ul>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 방식이나, 싱글턴 방식이 적합하지 않다.<br>\n자원에 따라 동작이 달라진다면, 자원의 수만큼 인스턴스를 만들어 동작하게 하는 것이 좋다.<br>\n이를 <code>의존 객체 주입</code>이라고 하는데 Spring과 같은 프레임워크에서 DI의 개념으로 많이 쓰이고 있다.</p>\n<p>의존 객체 주입은 생성자, 정적팩터리, 빌더 혹은 Setter를 이용해서 자원을 넘겨 줄 수 있다.</p>\n<h1>팩터리 메서드 패턴 사용하여 자원 넘겨주기</h1>\n<p>자바8에서는 Supplier&lt;T&gt; 인터페이스가 팩터리를 표현한 완벽한 예다.<br>\nSupplier&lt;T&gt;를 입력으로 받는 메서드는 일반적으로 한정적 와일드 카드 타입을 사용해 팩터리의 타입 매개변수를 제한한다.</p>\n<p>아래의 예제처럼 사용한다.\n타일들을 이용해 모자이크를 만드는 예제이다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Mosaic <span class=\"title\">create</span><span class=\"params\">(Supplier&lt;? extends Tile&gt; tileFactory)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>요약</h1>\n<ul>\n<li>클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸 클래스는 사용하지 말자!</li>\n<li>필요한 자원 또는 팩터리를 생성자나 빌더를 통해 의존 객체를 주입하도록 하자</li>\n<li>의존 객체 주입은 유연성, 재사용성, 테스트 용이성을 높여 줄 것이다.</li>\n</ul>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</li>\n</ul>\n"},{"title":"Item 6. 불필요한 객체 생성을 피하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item6","typora-copy-images-to":"effective-java-item6","date":"2019-01-07T12:33:11.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\n똑같은 기능의 객체를 매번 생성하기 보다는 객체 하나는 재사용하는 편이 나을 때가 많다. (아니 거의 무조건 재사용 할 수 있으면 하는 게 좋다.)  \n재사용은 빠르고 세련되며, 특히 불변 객체는 언제든지 안전하게 재사용 할 수 있다.\n\n# 아주 안 좋은 객체 생성의 예\n```java\nString s = new String(\"Hello\");\n```\n이러한 코드는 매번 새로운 String 객체를 생성하게 된다.\n\n# String Constant pool\n위의 코드를 조금 더 보완하면 아래 코드 처럼 사용할 수 있다.\n```java\nString s = \"Hello\";\n```\nJava JVM에는 String Constant pool 이라는 것이 있다.  \n(Java 7 버전을 기점으로 Perm영역 -> Heap 영역으로 변경되었다.)  \n위 처럼 쓰는 방식을 String 리터럴 방식이라 한다.  \n\nString 리터럴을 사용할 경우 기본적으로 String 내장 메서드인 intern()이라는 메서드를 호출하게 된다. \n```java\nString a = \"Hello\"; // 1\nString b = \"Hello\"; // 2\n```\n1. 최초로 Hello라는 String 리터럴을 사용하였기 때문에 intern() 메서드가 호출된다.  \n--> String Constant pool에서 해당 문자열을 검색하였지만 존재 하지 않기 때문에 String Constant pool에 넣고 새로운 주소값을 반환한다.\n\n2. 두번째로 Hello라는 String 리터럴을 사용하였기 때문에 마찬가지로 intern() 메서드가 호출된다.  \n--> String Constant pool에서 해당 문자열을 검색하니 기존에 등록된 주소 값이 반환된다.\n\n실질적으로 a와 b는 같은 주소값을 가지게 된다.\n\n그렇기 때문에 \n```java\nSystem.out.println(a == b);      //true\nSystem.out.println(a.equals(b)); //true\n```\n\n위의 코드를 실행해 보면 객체의 동등성 비교와 동일성 비교에서 모두 true가 나온다.\n* 동등성(equality) : 두 객체의 내용이 같은지 비교\n* 동일성(identity) : 두 객체가 같은 객체인지 hashcode를 비교\n\n그렇기 때문에 String을 사용할 경우에는 new를 이용한 객체 생성 방식보다 String 리터럴을 사용하는 방식이 더 좋다. (같은 객체를 재사용 하기 때문)\n> 그렇다고 실제 코드에서 String 리터럴을 사용했다고 `==` 을 이용한 동일성 비교는 하지말자.  \n상당히 위험한 코드이고, 다른 결과를 초래 할 가능성이 매우 높다.\n\n# Boolean의 예시\nBoolean의 경우 new Boolean(true)보다 Boolean.valueOf를 사용하는 것이 더 좋다.\n\nBoolean 클래스를 보면..\n```java\npublic final class Boolean implements java.io.Serializable,\n                                      Comparable<Boolean>\n{\n    /**\n     * The {@code Boolean} object corresponding to the primitive\n     * value {@code true}.\n     */\n    public static final Boolean TRUE = new Boolean(true);\n\n    /**\n     * The {@code Boolean} object corresponding to the primitive\n     * value {@code false}.\n     */\n    public static final Boolean FALSE = new Boolean(false);\n\n    /**\n     * The value of the Boolean.\n     *\n     * @serial\n     */\n    private final boolean value;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    private static final long serialVersionUID = -3665804199014368530L;\n\n    @Deprecated(since=\"9\")\n    public Boolean(boolean value) {\n        this.value = value;\n    }\n\n    @Deprecated(since=\"9\")\n    public Boolean(String s) {\n        this(parseBoolean(s));\n    }\n\n    public static boolean parseBoolean(String s) {\n        return \"true\".equalsIgnoreCase(s);\n    }\n\n    @HotSpotIntrinsicCandidate\n    public boolean booleanValue() {\n        return value;\n    }\n\n    @HotSpotIntrinsicCandidate\n    public static Boolean valueOf(boolean b) {\n        return (b ? TRUE : FALSE);\n    }\n}\n```\n\nnew Boolean의 경우 그때그때 새로운 객체를 생성하게 된다.  \n(로컬 컴퓨터에는 OpenJDK 11이 설치되어있는데 Java 9 버전 부터 Boolean 생성자는 Deprecated 처리 되었다.)\n\n하지만, Boolean.valueOf 라는 정적 메서드는 TRUE, FLASE라는 정적 필드에 이미 생성한 인스턴스를 사용하고 있기 때문에  \n객체를 추가적으로 생성하지 않아 성능상 이점이 있기 때문이다.\n\n# Auto Boxing을 주의하라!\n오토박싱은 Java 5 부터 나온 기능이다.  \nprimitive 타입과 Class 타입을 자동으로 변환해 주는 기능이다.  \n이 기능에 대해 간과하게 되면 쓸 데 없는 객체를 많이 만들어 낼 수 있다.  \n\n책에 소개 된 예제를 잠깐 돌아보면..\n```java\nprivate static long sum() {\n  Long sum = 0L;\n  for (long i = 0; i <= Integer.MAX_VALUE; i++) {\n    sum += i; //i에 대해 Auto Boxing이 일어나고 있다.\n  }\n  return sum;\n}\n```\ni가 더해질 때 마다 AutoBoxing이 발생하게 된다.  \nsum 변수를 쓸데 없이 long으로 선언해서 Long객체가 2^32개 만큼 쓸데 없이 생성 되었다. (책에는 231개라고 나와있는데 오타일 거라 생각한다.)   \nsum을 long으로만 바꿔줘도 불필요한 객체가 생성되는 일은 없을 것이며, 성능도 더 빨라지게 된다. (책에서는 6.3초 -> 0.59초로 성능 향상을 보았다고 한다.)\n\n\n# 나만의 객체 Pool을 만들지 말자\n객체를 생성하는 비용이 많이 드는 객체라면 미리 pool을 생성하여 사용하면 좋다.  \nJDBC에서 사용하는 Connection pool은 생성비용이 높기 때문에 재사용성을 높이기 위해 pool을 사용하는 것이 좋다.  \n하지만 일반적으로 개인이 만든 pool은 코드를 헷갈리게 하고 성능을 떨어뜨린다.  \n(요즘 GC는 최적화가 잘되서, pool을 만드는 것보다 그냥 객체를 생성하는게 더 빠르다고 한다.)\n\n\n# 예외는 있다.\n방어적 복사본을 만들어야 하는 경우가 있다.  \n불변 객체를 유지하기 위해 객체를 수정할 때 마다 새로운 객체를 만들어서 데이터를 수정하는 방식인데, 얼핏 보면 쓸 떼 없는 객체를 생성하는 것 처럼 보인다.  \n하지만 객체를 좀 더 만드는 피해보다, 객체가 재사용 되면서 불변성이 깨져 버그가 발생하는 피해가 더 크다는 사실을 명심해야 한다.\n\n# 참고\n* Effective Java 3rd Edition - Item 6. 불필요한 객체 생성을 피하라\n","source":"_posts/effective-java-item6.md","raw":"---\ntitle: Item 6. 불필요한 객체 생성을 피하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item6\ntypora-copy-images-to: effective-java-item6\ndate: 2019-01-07 21:33:11\nsubtitle:\nheader-img:\n---\n\n# 서론\n똑같은 기능의 객체를 매번 생성하기 보다는 객체 하나는 재사용하는 편이 나을 때가 많다. (아니 거의 무조건 재사용 할 수 있으면 하는 게 좋다.)  \n재사용은 빠르고 세련되며, 특히 불변 객체는 언제든지 안전하게 재사용 할 수 있다.\n\n# 아주 안 좋은 객체 생성의 예\n```java\nString s = new String(\"Hello\");\n```\n이러한 코드는 매번 새로운 String 객체를 생성하게 된다.\n\n# String Constant pool\n위의 코드를 조금 더 보완하면 아래 코드 처럼 사용할 수 있다.\n```java\nString s = \"Hello\";\n```\nJava JVM에는 String Constant pool 이라는 것이 있다.  \n(Java 7 버전을 기점으로 Perm영역 -> Heap 영역으로 변경되었다.)  \n위 처럼 쓰는 방식을 String 리터럴 방식이라 한다.  \n\nString 리터럴을 사용할 경우 기본적으로 String 내장 메서드인 intern()이라는 메서드를 호출하게 된다. \n```java\nString a = \"Hello\"; // 1\nString b = \"Hello\"; // 2\n```\n1. 최초로 Hello라는 String 리터럴을 사용하였기 때문에 intern() 메서드가 호출된다.  \n--> String Constant pool에서 해당 문자열을 검색하였지만 존재 하지 않기 때문에 String Constant pool에 넣고 새로운 주소값을 반환한다.\n\n2. 두번째로 Hello라는 String 리터럴을 사용하였기 때문에 마찬가지로 intern() 메서드가 호출된다.  \n--> String Constant pool에서 해당 문자열을 검색하니 기존에 등록된 주소 값이 반환된다.\n\n실질적으로 a와 b는 같은 주소값을 가지게 된다.\n\n그렇기 때문에 \n```java\nSystem.out.println(a == b);      //true\nSystem.out.println(a.equals(b)); //true\n```\n\n위의 코드를 실행해 보면 객체의 동등성 비교와 동일성 비교에서 모두 true가 나온다.\n* 동등성(equality) : 두 객체의 내용이 같은지 비교\n* 동일성(identity) : 두 객체가 같은 객체인지 hashcode를 비교\n\n그렇기 때문에 String을 사용할 경우에는 new를 이용한 객체 생성 방식보다 String 리터럴을 사용하는 방식이 더 좋다. (같은 객체를 재사용 하기 때문)\n> 그렇다고 실제 코드에서 String 리터럴을 사용했다고 `==` 을 이용한 동일성 비교는 하지말자.  \n상당히 위험한 코드이고, 다른 결과를 초래 할 가능성이 매우 높다.\n\n# Boolean의 예시\nBoolean의 경우 new Boolean(true)보다 Boolean.valueOf를 사용하는 것이 더 좋다.\n\nBoolean 클래스를 보면..\n```java\npublic final class Boolean implements java.io.Serializable,\n                                      Comparable<Boolean>\n{\n    /**\n     * The {@code Boolean} object corresponding to the primitive\n     * value {@code true}.\n     */\n    public static final Boolean TRUE = new Boolean(true);\n\n    /**\n     * The {@code Boolean} object corresponding to the primitive\n     * value {@code false}.\n     */\n    public static final Boolean FALSE = new Boolean(false);\n\n    /**\n     * The value of the Boolean.\n     *\n     * @serial\n     */\n    private final boolean value;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    private static final long serialVersionUID = -3665804199014368530L;\n\n    @Deprecated(since=\"9\")\n    public Boolean(boolean value) {\n        this.value = value;\n    }\n\n    @Deprecated(since=\"9\")\n    public Boolean(String s) {\n        this(parseBoolean(s));\n    }\n\n    public static boolean parseBoolean(String s) {\n        return \"true\".equalsIgnoreCase(s);\n    }\n\n    @HotSpotIntrinsicCandidate\n    public boolean booleanValue() {\n        return value;\n    }\n\n    @HotSpotIntrinsicCandidate\n    public static Boolean valueOf(boolean b) {\n        return (b ? TRUE : FALSE);\n    }\n}\n```\n\nnew Boolean의 경우 그때그때 새로운 객체를 생성하게 된다.  \n(로컬 컴퓨터에는 OpenJDK 11이 설치되어있는데 Java 9 버전 부터 Boolean 생성자는 Deprecated 처리 되었다.)\n\n하지만, Boolean.valueOf 라는 정적 메서드는 TRUE, FLASE라는 정적 필드에 이미 생성한 인스턴스를 사용하고 있기 때문에  \n객체를 추가적으로 생성하지 않아 성능상 이점이 있기 때문이다.\n\n# Auto Boxing을 주의하라!\n오토박싱은 Java 5 부터 나온 기능이다.  \nprimitive 타입과 Class 타입을 자동으로 변환해 주는 기능이다.  \n이 기능에 대해 간과하게 되면 쓸 데 없는 객체를 많이 만들어 낼 수 있다.  \n\n책에 소개 된 예제를 잠깐 돌아보면..\n```java\nprivate static long sum() {\n  Long sum = 0L;\n  for (long i = 0; i <= Integer.MAX_VALUE; i++) {\n    sum += i; //i에 대해 Auto Boxing이 일어나고 있다.\n  }\n  return sum;\n}\n```\ni가 더해질 때 마다 AutoBoxing이 발생하게 된다.  \nsum 변수를 쓸데 없이 long으로 선언해서 Long객체가 2^32개 만큼 쓸데 없이 생성 되었다. (책에는 231개라고 나와있는데 오타일 거라 생각한다.)   \nsum을 long으로만 바꿔줘도 불필요한 객체가 생성되는 일은 없을 것이며, 성능도 더 빨라지게 된다. (책에서는 6.3초 -> 0.59초로 성능 향상을 보았다고 한다.)\n\n\n# 나만의 객체 Pool을 만들지 말자\n객체를 생성하는 비용이 많이 드는 객체라면 미리 pool을 생성하여 사용하면 좋다.  \nJDBC에서 사용하는 Connection pool은 생성비용이 높기 때문에 재사용성을 높이기 위해 pool을 사용하는 것이 좋다.  \n하지만 일반적으로 개인이 만든 pool은 코드를 헷갈리게 하고 성능을 떨어뜨린다.  \n(요즘 GC는 최적화가 잘되서, pool을 만드는 것보다 그냥 객체를 생성하는게 더 빠르다고 한다.)\n\n\n# 예외는 있다.\n방어적 복사본을 만들어야 하는 경우가 있다.  \n불변 객체를 유지하기 위해 객체를 수정할 때 마다 새로운 객체를 만들어서 데이터를 수정하는 방식인데, 얼핏 보면 쓸 떼 없는 객체를 생성하는 것 처럼 보인다.  \n하지만 객체를 좀 더 만드는 피해보다, 객체가 재사용 되면서 불변성이 깨져 버그가 발생하는 피해가 더 크다는 사실을 명심해야 한다.\n\n# 참고\n* Effective Java 3rd Edition - Item 6. 불필요한 객체 생성을 피하라\n","slug":"effective-java-item6","published":1,"updated":"2019-01-07T13:32:09.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2sb001bcr1ttzhpjnn3","content":"<h1 id=\"서론\">서론</h1>\n<p>똑같은 기능의 객체를 매번 생성하기 보다는 객체 하나는 재사용하는 편이 나을 때가 많다. (아니 거의 무조건 재사용 할 수 있으면 하는 게 좋다.)<br>\n재사용은 빠르고 세련되며, 특히 불변 객체는 언제든지 안전하게 재사용 할 수 있다.</p>\n<h1 id=\"아주-안-좋은-객체-생성의-예\">아주 안 좋은 객체 생성의 예</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>이러한 코드는 매번 새로운 String 객체를 생성하게 된다.</p>\n<h1 id=\"string-constant-pool\">String Constant pool</h1>\n<p>위의 코드를 조금 더 보완하면 아래 코드 처럼 사용할 수 있다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">\"Hello\"</span>;</span><br></pre></td></tr></table></figure></p>\n<p>Java JVM에는 String Constant pool 이라는 것이 있다.<br>\n(Java 7 버전을 기점으로 Perm영역 -&gt; Heap 영역으로 변경되었다.)<br>\n위 처럼 쓰는 방식을 String 리터럴 방식이라 한다.</p>\n<p>String 리터럴을 사용할 경우 기본적으로 String 내장 메서드인 intern()이라는 메서드를 호출하게 된다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = <span class=\"string\">\"Hello\"</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\">String b = <span class=\"string\">\"Hello\"</span>; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>\n<p>최초로 Hello라는 String 리터럴을 사용하였기 때문에 intern() 메서드가 호출된다.<br>\n--&gt; String Constant pool에서 해당 문자열을 검색하였지만 존재 하지 않기 때문에 String Constant pool에 넣고 새로운 주소값을 반환한다.</p>\n</li>\n<li>\n<p>두번째로 Hello라는 String 리터럴을 사용하였기 때문에 마찬가지로 intern() 메서드가 호출된다.<br>\n--&gt; String Constant pool에서 해당 문자열을 검색하니 기존에 등록된 주소 값이 반환된다.</p>\n</li>\n</ol>\n<p>실질적으로 a와 b는 같은 주소값을 가지게 된다.</p>\n<p>그렇기 때문에\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(a == b);      <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(a.equals(b)); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>위의 코드를 실행해 보면 객체의 동등성 비교와 동일성 비교에서 모두 true가 나온다.</p>\n<ul>\n<li>동등성(equality) : 두 객체의 내용이 같은지 비교</li>\n<li>동일성(identity) : 두 객체가 같은 객체인지 hashcode를 비교</li>\n</ul>\n<p>그렇기 때문에 String을 사용할 경우에는 new를 이용한 객체 생성 방식보다 String 리터럴을 사용하는 방식이 더 좋다. (같은 객체를 재사용 하기 때문)</p>\n<blockquote>\n<p>그렇다고 실제 코드에서 String 리터럴을 사용했다고 <code>==</code> 을 이용한 동일성 비교는 하지말자.<br>\n상당히 위험한 코드이고, 다른 결과를 초래 할 가능성이 매우 높다.</p>\n</blockquote>\n<h1 id=\"boolean의-예시\">Boolean의 예시</h1>\n<p>Boolean의 경우 new Boolean(true)보다 Boolean.valueOf를 사용하는 것이 더 좋다.</p>\n<p>Boolean 클래스를 보면..\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Boolean</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>,</span></span><br><span class=\"line\"><span class=\"class\">                                      <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Boolean</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The &#123;<span class=\"doctag\">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class=\"line\"><span class=\"comment\">     * value &#123;<span class=\"doctag\">@code</span> true&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Boolean TRUE = <span class=\"keyword\">new</span> Boolean(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The &#123;<span class=\"doctag\">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class=\"line\"><span class=\"comment\">     * value &#123;<span class=\"doctag\">@code</span> false&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Boolean FALSE = <span class=\"keyword\">new</span> Boolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The value of the Boolean.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3665804199014368530L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Deprecated</span>(since=<span class=\"string\">\"9\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Boolean</span><span class=\"params\">(<span class=\"keyword\">boolean</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Deprecated</span>(since=<span class=\"string\">\"9\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Boolean</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(parseBoolean(s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parseBoolean</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"true\"</span>.equalsIgnoreCase(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@HotSpotIntrinsicCandidate</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">booleanValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@HotSpotIntrinsicCandidate</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Boolean <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (b ? TRUE : FALSE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>new Boolean의 경우 그때그때 새로운 객체를 생성하게 된다.<br>\n(로컬 컴퓨터에는 OpenJDK 11이 설치되어있는데 Java 9 버전 부터 Boolean 생성자는 Deprecated 처리 되었다.)</p>\n<p>하지만, Boolean.valueOf 라는 정적 메서드는 TRUE, FLASE라는 정적 필드에 이미 생성한 인스턴스를 사용하고 있기 때문에<br>\n객체를 추가적으로 생성하지 않아 성능상 이점이 있기 때문이다.</p>\n<h1 id=\"auto-boxing을-주의하라\">Auto Boxing을 주의하라!</h1>\n<p>오토박싱은 Java 5 부터 나온 기능이다.<br>\nprimitive 타입과 Class 타입을 자동으로 변환해 주는 기능이다.<br>\n이 기능에 대해 간과하게 되면 쓸 데 없는 객체를 많이 만들어 낼 수 있다.</p>\n<p>책에 소개 된 예제를 잠깐 돌아보면..\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">sum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Long sum = <span class=\"number\">0L</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> i = <span class=\"number\">0</span>; i &lt;= Integer.MAX_VALUE; i++) &#123;</span><br><span class=\"line\">    sum += i; <span class=\"comment\">//i에 대해 Auto Boxing이 일어나고 있다.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>i가 더해질 때 마다 AutoBoxing이 발생하게 된다.<br>\nsum 변수를 쓸데 없이 long으로 선언해서 Long객체가 2^32개 만큼 쓸데 없이 생성 되었다. (책에는 231개라고 나와있는데 오타일 거라 생각한다.)<br>\nsum을 long으로만 바꿔줘도 불필요한 객체가 생성되는 일은 없을 것이며, 성능도 더 빨라지게 된다. (책에서는 6.3초 -&gt; 0.59초로 성능 향상을 보았다고 한다.)</p>\n<h1 id=\"나만의-객체-pool을-만들지-말자\">나만의 객체 Pool을 만들지 말자</h1>\n<p>객체를 생성하는 비용이 많이 드는 객체라면 미리 pool을 생성하여 사용하면 좋다.<br>\nJDBC에서 사용하는 Connection pool은 생성비용이 높기 때문에 재사용성을 높이기 위해 pool을 사용하는 것이 좋다.<br>\n하지만 일반적으로 개인이 만든 pool은 코드를 헷갈리게 하고 성능을 떨어뜨린다.<br>\n(요즘 GC는 최적화가 잘되서, pool을 만드는 것보다 그냥 객체를 생성하는게 더 빠르다고 한다.)</p>\n<h1 id=\"예외는-있다\">예외는 있다.</h1>\n<p>방어적 복사본을 만들어야 하는 경우가 있다.<br>\n불변 객체를 유지하기 위해 객체를 수정할 때 마다 새로운 객체를 만들어서 데이터를 수정하는 방식인데, 얼핏 보면 쓸 떼 없는 객체를 생성하는 것 처럼 보인다.<br>\n하지만 객체를 좀 더 만드는 피해보다, 객체가 재사용 되면서 불변성이 깨져 버그가 발생하는 피해가 더 크다는 사실을 명심해야 한다.</p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 6. 불필요한 객체 생성을 피하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>똑같은 기능의 객체를 매번 생성하기 보다는 객체 하나는 재사용하는 편이 나을 때가 많다. (아니 거의 무조건 재사용 할 수 있으면 하는 게 좋다.)<br>\n재사용은 빠르고 세련되며, 특히 불변 객체는 언제든지 안전하게 재사용 할 수 있다.</p>\n<h1>아주 안 좋은 객체 생성의 예</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>이러한 코드는 매번 새로운 String 객체를 생성하게 된다.</p>\n<h1>String Constant pool</h1>\n<p>위의 코드를 조금 더 보완하면 아래 코드 처럼 사용할 수 있다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">\"Hello\"</span>;</span><br></pre></td></tr></table></figure></p>\n<p>Java JVM에는 String Constant pool 이라는 것이 있다.<br>\n(Java 7 버전을 기점으로 Perm영역 -&gt; Heap 영역으로 변경되었다.)<br>\n위 처럼 쓰는 방식을 String 리터럴 방식이라 한다.</p>\n<p>String 리터럴을 사용할 경우 기본적으로 String 내장 메서드인 intern()이라는 메서드를 호출하게 된다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = <span class=\"string\">\"Hello\"</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\">String b = <span class=\"string\">\"Hello\"</span>; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>\n<p>최초로 Hello라는 String 리터럴을 사용하였기 때문에 intern() 메서드가 호출된다.<br>\n--&gt; String Constant pool에서 해당 문자열을 검색하였지만 존재 하지 않기 때문에 String Constant pool에 넣고 새로운 주소값을 반환한다.</p>\n</li>\n<li>\n<p>두번째로 Hello라는 String 리터럴을 사용하였기 때문에 마찬가지로 intern() 메서드가 호출된다.<br>\n--&gt; String Constant pool에서 해당 문자열을 검색하니 기존에 등록된 주소 값이 반환된다.</p>\n</li>\n</ol>\n<p>실질적으로 a와 b는 같은 주소값을 가지게 된다.</p>\n<p>그렇기 때문에\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(a == b);      <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(a.equals(b)); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>위의 코드를 실행해 보면 객체의 동등성 비교와 동일성 비교에서 모두 true가 나온다.</p>\n<ul>\n<li>동등성(equality) : 두 객체의 내용이 같은지 비교</li>\n<li>동일성(identity) : 두 객체가 같은 객체인지 hashcode를 비교</li>\n</ul>\n<p>그렇기 때문에 String을 사용할 경우에는 new를 이용한 객체 생성 방식보다 String 리터럴을 사용하는 방식이 더 좋다. (같은 객체를 재사용 하기 때문)</p>\n<blockquote>\n<p>그렇다고 실제 코드에서 String 리터럴을 사용했다고 <code>==</code> 을 이용한 동일성 비교는 하지말자.<br>\n상당히 위험한 코드이고, 다른 결과를 초래 할 가능성이 매우 높다.</p>\n</blockquote>\n<h1>Boolean의 예시</h1>\n<p>Boolean의 경우 new Boolean(true)보다 Boolean.valueOf를 사용하는 것이 더 좋다.</p>\n<p>Boolean 클래스를 보면..\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Boolean</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>,</span></span><br><span class=\"line\"><span class=\"class\">                                      <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Boolean</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The &#123;<span class=\"doctag\">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class=\"line\"><span class=\"comment\">     * value &#123;<span class=\"doctag\">@code</span> true&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Boolean TRUE = <span class=\"keyword\">new</span> Boolean(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The &#123;<span class=\"doctag\">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class=\"line\"><span class=\"comment\">     * value &#123;<span class=\"doctag\">@code</span> false&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Boolean FALSE = <span class=\"keyword\">new</span> Boolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The value of the Boolean.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3665804199014368530L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Deprecated</span>(since=<span class=\"string\">\"9\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Boolean</span><span class=\"params\">(<span class=\"keyword\">boolean</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Deprecated</span>(since=<span class=\"string\">\"9\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Boolean</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(parseBoolean(s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parseBoolean</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"true\"</span>.equalsIgnoreCase(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@HotSpotIntrinsicCandidate</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">booleanValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@HotSpotIntrinsicCandidate</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Boolean <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (b ? TRUE : FALSE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>new Boolean의 경우 그때그때 새로운 객체를 생성하게 된다.<br>\n(로컬 컴퓨터에는 OpenJDK 11이 설치되어있는데 Java 9 버전 부터 Boolean 생성자는 Deprecated 처리 되었다.)</p>\n<p>하지만, Boolean.valueOf 라는 정적 메서드는 TRUE, FLASE라는 정적 필드에 이미 생성한 인스턴스를 사용하고 있기 때문에<br>\n객체를 추가적으로 생성하지 않아 성능상 이점이 있기 때문이다.</p>\n<h1>Auto Boxing을 주의하라!</h1>\n<p>오토박싱은 Java 5 부터 나온 기능이다.<br>\nprimitive 타입과 Class 타입을 자동으로 변환해 주는 기능이다.<br>\n이 기능에 대해 간과하게 되면 쓸 데 없는 객체를 많이 만들어 낼 수 있다.</p>\n<p>책에 소개 된 예제를 잠깐 돌아보면..\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">sum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Long sum = <span class=\"number\">0L</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> i = <span class=\"number\">0</span>; i &lt;= Integer.MAX_VALUE; i++) &#123;</span><br><span class=\"line\">    sum += i; <span class=\"comment\">//i에 대해 Auto Boxing이 일어나고 있다.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>i가 더해질 때 마다 AutoBoxing이 발생하게 된다.<br>\nsum 변수를 쓸데 없이 long으로 선언해서 Long객체가 2^32개 만큼 쓸데 없이 생성 되었다. (책에는 231개라고 나와있는데 오타일 거라 생각한다.)<br>\nsum을 long으로만 바꿔줘도 불필요한 객체가 생성되는 일은 없을 것이며, 성능도 더 빨라지게 된다. (책에서는 6.3초 -&gt; 0.59초로 성능 향상을 보았다고 한다.)</p>\n<h1>나만의 객체 Pool을 만들지 말자</h1>\n<p>객체를 생성하는 비용이 많이 드는 객체라면 미리 pool을 생성하여 사용하면 좋다.<br>\nJDBC에서 사용하는 Connection pool은 생성비용이 높기 때문에 재사용성을 높이기 위해 pool을 사용하는 것이 좋다.<br>\n하지만 일반적으로 개인이 만든 pool은 코드를 헷갈리게 하고 성능을 떨어뜨린다.<br>\n(요즘 GC는 최적화가 잘되서, pool을 만드는 것보다 그냥 객체를 생성하는게 더 빠르다고 한다.)</p>\n<h1>예외는 있다.</h1>\n<p>방어적 복사본을 만들어야 하는 경우가 있다.<br>\n불변 객체를 유지하기 위해 객체를 수정할 때 마다 새로운 객체를 만들어서 데이터를 수정하는 방식인데, 얼핏 보면 쓸 떼 없는 객체를 생성하는 것 처럼 보인다.<br>\n하지만 객체를 좀 더 만드는 피해보다, 객체가 재사용 되면서 불변성이 깨져 버그가 발생하는 피해가 더 크다는 사실을 명심해야 한다.</p>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 6. 불필요한 객체 생성을 피하라</li>\n</ul>\n"},{"title":"Item 7. 다 쓴 객체는 참조를 해제하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item7","typora-copy-images-to":"effective-java-item7","date":"2019-01-07T13:21:26.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\nJava의 장점 중 하나는 가비지 컬렉션을 지원하는 언어라는 점이다.  \nC, C++ 처럼 개발자가 메모리를 직접 할당하고 해제하는 방식이 아니기 때문에 Java에서는 메모리 관리가 굉장히 편하다는 장점이 있다.\n\n하지만 `아예 신경을 안써도 되는 것은 아니다.`  \n가비지 컬렉션을 통해 소멸 대상이 되는 객체가 되기 위해서는 어떠한 reference 변수에서 가르키지 않아야 한다.  \n다 쓴 객체에 대한 참조를 해제하지 않으면 가비지 컬렉션의 대상이 되지 않아 계속 메모리가 할당 되는 **메모리 누수** 현상이 발생 된다.\n\n가비지 컬렉션을 지원하는 언어에서는 메모리 누수를 찾기가 까다롭다  \n객체 참조(reference)를 하나 살려두면, 가비지 컬렉터는 그 객체 뿐만 아니라 그 객체 내에서 참조하고 있는 객체까지 회수 할 수 없다.\n\n이로 인해 잠재적으로 성능에 악영향을 줄 수 있다.\n\n# 가비지 컬렉션의 소멸 대상이 되기 위해서는...\n## 직접 할당 해제\n* 이 방법은 굉장히 단순하다.  \n말 그대로 객체 참조 변수를 null로 초기화 한다.  \n그렇게 되면 실제 heap 메모리에 존재하는 객체는 어떠한 참조(reference)도 가지지 않기 때문에\n  `가비지 컬렉션의 소멸 대상`이 된다.\n* 하지만 바람직한 방법은 아니다. 반드시 필요한 경우에만 사용 할 수 있도록 하는 것이 좋다.  \n(소스코드가 드러워짐 -_-)\n* 클래스 내에서 메모리를 관리 하는 객체(Stack 같은...)라면 이 방법을 통해 다 쓴 객체는 할당을 해제 하는 것이 옳다.\n\n## Scope를 통한 자동 할당 해제\n* 보통은 변수 선언`(대게 지역변수)`과 동시에 초기화를 사용한다.  \n그 변수에 대한 scope가 종료되는 순간 reference가 해제되어 가비지 컬렉션의 대상이 된다.\n* try~catch와 같은 구문에서는 catch 구문에서 try내에서 사용하는 변수를 참조하지 못하므로\n  try~catch 변수 초기화를 하기 어렵다.  \n  그렇게 때문에 finally 구문에서 변수에 대한 참조를 해제한다.\n\n# 메모리 누수를 일으키는 주범\n* 첫번째는 위에서 설명한 class내에서 instance에 대한 참조(reference)를 관리하는 객체이다.\n* 두번째는 Map과 같은 캐시\n* 세번째는 리스너(Listener) 혹은 콜백(Callback)\n\n\nMap과 같은 캐시에 객체참조를 넣어두고 사용이 끝났는데도 초기화를 안시켜주는 경우 메모리 누수가 발생한다.  \n엔트리가 살아있는 동안만 캐시를 사용하려면 `WeakHashMap`을 사용하자.  \nWeakHashMap을 이해하려면 Java의 Reference를 좀 알아야 한다.\n\n## Java Reference \nJava에는 4가지의 Reference가 있다.\n* Strong Reference\n  * 우리가 흔히 사용하는 reference\n  * String str = new String(\"abc\"); 와 같은 형태\n  * Strong Reference는 GC의 대상이 되지 않는다. \n  * Strong Reference관계의 객체가 GC가 되기 위해선 null로 초기화해  \n  객체에 대한 Reachability상태를 UnReachable 상태로 만들어 줘야 한다.\n\n* Soft Reference\n  * 객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference만 있는 상태\n  * SoftReference<Class> ref = new SoftReference<>(new String(\"abc\"));와 같은 형태로 사용\n  * Soft Reference는 대게 GC대상이 아니다가 `out of memory에러`가 나기 직전까지 가면  \n  Soft Reference 관계에 있는 객체들은 GC대상이 된다.\n\n* Weak Reference\n  * 객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference가 없고 Weak Reference만 있는 상태\n  * WeakReference<Class> ref = new WeakReference<Class>(new String(\"abc\")); 와 같은 형태로 사용\n  * WeakReference는 GC가 발생 할 때마다 대상이 된다.\n\n* Phantomly Reference\n  * 객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference와 Weak Referencerk 모두가 해당되지 않는 객체\n  * finalize 되었지만 메모리가 아직 회수 되지 않은 객체\n  * 아직 잘 이해가... 안됨\n\n## WeakHashMap \nWeak Reference를 이용한 HashMap  \n아래의 예제코드를 보자\n```java\npublic class ClassWeakHashMap {\n    public static class Referred {\n        protected void finalize() {\n            System.out.println(\"Good bye cruel world\");\n        }\n    }\n\n    /**\n    * GC를 발생 시켜 메모리를 회수하는 코드\n    * System.gc()가 잘 동작할지는 모르겠다.\n    */\n    public static void collect() throws InterruptedException {\n        System.out.println(\"Suggesting collection\");\n        System.gc();\n        System.out.println(\"Sleeping\");\n        Thread.sleep(5000);\n    }\n\n    public static void main(String args[]) throws InterruptedException {\n        System.out.println(\"Creating weak references\");\n\n        // This is now a weak reference. \n        // The object will be collected only if no strong references. \n        Referred strong = new Referred(); //Strong Reference로 하나 추가\n\n        //Weak Reference를 이용한 WeakHashMap에 엔트리를 추가하여\n        //Weak Reference 추가\n        Map<Referred, String> metadata = new WeakHashMap<Referred, String>();\n        metadata.put(strong, \"WeakHashMap's make my world go around\");\n\n        // Attempt to claim a suggested reference. \n        ClassWeakHashMap.collect();\n        //여기서는 gc가 발생해도 GC대상이 아니게 된다.\n        //strong이라는 변수를 통해 Strong Reference를 가지므로 GC 대상이 아니다.\n        System.out.println(\"Still has metadata entry? \" + (metadata.size() == 1));\n        System.out.println(\"Removing reference\");\n\n        // The object may be collected. \n        //Strong Reference를 끊었다.\n        strong = null;\n\n        //여기서는 Weak Reference만 남아 있기 때문에 GC대상이 된다.\n        ClassWeakHashMap.collect();\n        System.out.println(\"Still has metadata entry? \" + (metadata.size() == 1));\n        System.out.println(\"Done\");\n    }\n}\n```\n\nWeak Reference를 가지고 있으면 GC가 발생되기 전까지 객체에 접근이 가능하기 때문에 메모리 누수의 입장으로 볼 때 유리한 것 같다.  \n한번 캐싱하고 사용하고 버리는 대상에 좋은 방법이다.\n\n하지만 static한 Map을 사용하는 경우에는 비추이다.  \n언제 GC가 일어날지 모를 뿐더러.. 갑자기 데이터가 사라져 자칫 하면 장애가 발생 할 수 있으니,\n특별한 경우에만 WeakHashMap을 사용해야 한다.\n\n## 리스너 혹은 콜백\n리스너와 콜백은 root set에 대한 직접 참조가 아닌 객체에서 참조를 가지고 있다.  \n그렇기 때문에 리스너와 콜백을 사용하는 객체가 unreachable 상태가 되지 않는 이상 메모리에서 GC대상이 되지 않는다.  \n이 경우 weak reference를 이용하면 리스너와 콜백을 사용하고, GC 작동 시에 메모리 해제를 시킬 수 있어, 메모리 누수에 도움이 된다.\n\n\n\n# 추가적으로..\n메모리 누수는 겉으로 잘 드러나지 않아 수년 간 잠복하는 사례가 있다고 한다.  \n이런 누수는 철저한 코드리뷰나 힙 프로파일링 도구를 통해 디버깅을 동원해야 발견할 수 있으므로,  \n평소에 코드를 작성할 때 메모리 누수에 대한 부분을 신경을 써주는 것이 중요하다.\n\n# 참고\n* Effective Java 3rd Edition - Item 7. 다 쓴 객체는 참조를 해제하라\n* https://d2.naver.com/helloworld/329631\n* https://tourspace.tistory.com/42","source":"_posts/effective-java-item7.md","raw":"---\ntitle: Item 7. 다 쓴 객체는 참조를 해제하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item7\ntypora-copy-images-to: effective-java-item7\ndate: 2019-01-07 22:21:26\nsubtitle:\nheader-img:\n---\n\n# 서론\nJava의 장점 중 하나는 가비지 컬렉션을 지원하는 언어라는 점이다.  \nC, C++ 처럼 개발자가 메모리를 직접 할당하고 해제하는 방식이 아니기 때문에 Java에서는 메모리 관리가 굉장히 편하다는 장점이 있다.\n\n하지만 `아예 신경을 안써도 되는 것은 아니다.`  \n가비지 컬렉션을 통해 소멸 대상이 되는 객체가 되기 위해서는 어떠한 reference 변수에서 가르키지 않아야 한다.  \n다 쓴 객체에 대한 참조를 해제하지 않으면 가비지 컬렉션의 대상이 되지 않아 계속 메모리가 할당 되는 **메모리 누수** 현상이 발생 된다.\n\n가비지 컬렉션을 지원하는 언어에서는 메모리 누수를 찾기가 까다롭다  \n객체 참조(reference)를 하나 살려두면, 가비지 컬렉터는 그 객체 뿐만 아니라 그 객체 내에서 참조하고 있는 객체까지 회수 할 수 없다.\n\n이로 인해 잠재적으로 성능에 악영향을 줄 수 있다.\n\n# 가비지 컬렉션의 소멸 대상이 되기 위해서는...\n## 직접 할당 해제\n* 이 방법은 굉장히 단순하다.  \n말 그대로 객체 참조 변수를 null로 초기화 한다.  \n그렇게 되면 실제 heap 메모리에 존재하는 객체는 어떠한 참조(reference)도 가지지 않기 때문에\n  `가비지 컬렉션의 소멸 대상`이 된다.\n* 하지만 바람직한 방법은 아니다. 반드시 필요한 경우에만 사용 할 수 있도록 하는 것이 좋다.  \n(소스코드가 드러워짐 -_-)\n* 클래스 내에서 메모리를 관리 하는 객체(Stack 같은...)라면 이 방법을 통해 다 쓴 객체는 할당을 해제 하는 것이 옳다.\n\n## Scope를 통한 자동 할당 해제\n* 보통은 변수 선언`(대게 지역변수)`과 동시에 초기화를 사용한다.  \n그 변수에 대한 scope가 종료되는 순간 reference가 해제되어 가비지 컬렉션의 대상이 된다.\n* try~catch와 같은 구문에서는 catch 구문에서 try내에서 사용하는 변수를 참조하지 못하므로\n  try~catch 변수 초기화를 하기 어렵다.  \n  그렇게 때문에 finally 구문에서 변수에 대한 참조를 해제한다.\n\n# 메모리 누수를 일으키는 주범\n* 첫번째는 위에서 설명한 class내에서 instance에 대한 참조(reference)를 관리하는 객체이다.\n* 두번째는 Map과 같은 캐시\n* 세번째는 리스너(Listener) 혹은 콜백(Callback)\n\n\nMap과 같은 캐시에 객체참조를 넣어두고 사용이 끝났는데도 초기화를 안시켜주는 경우 메모리 누수가 발생한다.  \n엔트리가 살아있는 동안만 캐시를 사용하려면 `WeakHashMap`을 사용하자.  \nWeakHashMap을 이해하려면 Java의 Reference를 좀 알아야 한다.\n\n## Java Reference \nJava에는 4가지의 Reference가 있다.\n* Strong Reference\n  * 우리가 흔히 사용하는 reference\n  * String str = new String(\"abc\"); 와 같은 형태\n  * Strong Reference는 GC의 대상이 되지 않는다. \n  * Strong Reference관계의 객체가 GC가 되기 위해선 null로 초기화해  \n  객체에 대한 Reachability상태를 UnReachable 상태로 만들어 줘야 한다.\n\n* Soft Reference\n  * 객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference만 있는 상태\n  * SoftReference<Class> ref = new SoftReference<>(new String(\"abc\"));와 같은 형태로 사용\n  * Soft Reference는 대게 GC대상이 아니다가 `out of memory에러`가 나기 직전까지 가면  \n  Soft Reference 관계에 있는 객체들은 GC대상이 된다.\n\n* Weak Reference\n  * 객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference가 없고 Weak Reference만 있는 상태\n  * WeakReference<Class> ref = new WeakReference<Class>(new String(\"abc\")); 와 같은 형태로 사용\n  * WeakReference는 GC가 발생 할 때마다 대상이 된다.\n\n* Phantomly Reference\n  * 객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference와 Weak Referencerk 모두가 해당되지 않는 객체\n  * finalize 되었지만 메모리가 아직 회수 되지 않은 객체\n  * 아직 잘 이해가... 안됨\n\n## WeakHashMap \nWeak Reference를 이용한 HashMap  \n아래의 예제코드를 보자\n```java\npublic class ClassWeakHashMap {\n    public static class Referred {\n        protected void finalize() {\n            System.out.println(\"Good bye cruel world\");\n        }\n    }\n\n    /**\n    * GC를 발생 시켜 메모리를 회수하는 코드\n    * System.gc()가 잘 동작할지는 모르겠다.\n    */\n    public static void collect() throws InterruptedException {\n        System.out.println(\"Suggesting collection\");\n        System.gc();\n        System.out.println(\"Sleeping\");\n        Thread.sleep(5000);\n    }\n\n    public static void main(String args[]) throws InterruptedException {\n        System.out.println(\"Creating weak references\");\n\n        // This is now a weak reference. \n        // The object will be collected only if no strong references. \n        Referred strong = new Referred(); //Strong Reference로 하나 추가\n\n        //Weak Reference를 이용한 WeakHashMap에 엔트리를 추가하여\n        //Weak Reference 추가\n        Map<Referred, String> metadata = new WeakHashMap<Referred, String>();\n        metadata.put(strong, \"WeakHashMap's make my world go around\");\n\n        // Attempt to claim a suggested reference. \n        ClassWeakHashMap.collect();\n        //여기서는 gc가 발생해도 GC대상이 아니게 된다.\n        //strong이라는 변수를 통해 Strong Reference를 가지므로 GC 대상이 아니다.\n        System.out.println(\"Still has metadata entry? \" + (metadata.size() == 1));\n        System.out.println(\"Removing reference\");\n\n        // The object may be collected. \n        //Strong Reference를 끊었다.\n        strong = null;\n\n        //여기서는 Weak Reference만 남아 있기 때문에 GC대상이 된다.\n        ClassWeakHashMap.collect();\n        System.out.println(\"Still has metadata entry? \" + (metadata.size() == 1));\n        System.out.println(\"Done\");\n    }\n}\n```\n\nWeak Reference를 가지고 있으면 GC가 발생되기 전까지 객체에 접근이 가능하기 때문에 메모리 누수의 입장으로 볼 때 유리한 것 같다.  \n한번 캐싱하고 사용하고 버리는 대상에 좋은 방법이다.\n\n하지만 static한 Map을 사용하는 경우에는 비추이다.  \n언제 GC가 일어날지 모를 뿐더러.. 갑자기 데이터가 사라져 자칫 하면 장애가 발생 할 수 있으니,\n특별한 경우에만 WeakHashMap을 사용해야 한다.\n\n## 리스너 혹은 콜백\n리스너와 콜백은 root set에 대한 직접 참조가 아닌 객체에서 참조를 가지고 있다.  \n그렇기 때문에 리스너와 콜백을 사용하는 객체가 unreachable 상태가 되지 않는 이상 메모리에서 GC대상이 되지 않는다.  \n이 경우 weak reference를 이용하면 리스너와 콜백을 사용하고, GC 작동 시에 메모리 해제를 시킬 수 있어, 메모리 누수에 도움이 된다.\n\n\n\n# 추가적으로..\n메모리 누수는 겉으로 잘 드러나지 않아 수년 간 잠복하는 사례가 있다고 한다.  \n이런 누수는 철저한 코드리뷰나 힙 프로파일링 도구를 통해 디버깅을 동원해야 발견할 수 있으므로,  \n평소에 코드를 작성할 때 메모리 누수에 대한 부분을 신경을 써주는 것이 중요하다.\n\n# 참고\n* Effective Java 3rd Edition - Item 7. 다 쓴 객체는 참조를 해제하라\n* https://d2.naver.com/helloworld/329631\n* https://tourspace.tistory.com/42","slug":"effective-java-item7","published":1,"updated":"2019-01-07T13:32:09.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2sc001ecr1tns80s03f","content":"<h1 id=\"서론\">서론</h1>\n<p>Java의 장점 중 하나는 가비지 컬렉션을 지원하는 언어라는 점이다.<br>\nC, C++ 처럼 개발자가 메모리를 직접 할당하고 해제하는 방식이 아니기 때문에 Java에서는 메모리 관리가 굉장히 편하다는 장점이 있다.</p>\n<p>하지만 <code>아예 신경을 안써도 되는 것은 아니다.</code><br>\n가비지 컬렉션을 통해 소멸 대상이 되는 객체가 되기 위해서는 어떠한 reference 변수에서 가르키지 않아야 한다.<br>\n다 쓴 객체에 대한 참조를 해제하지 않으면 가비지 컬렉션의 대상이 되지 않아 계속 메모리가 할당 되는 <strong>메모리 누수</strong> 현상이 발생 된다.</p>\n<p>가비지 컬렉션을 지원하는 언어에서는 메모리 누수를 찾기가 까다롭다<br>\n객체 참조(reference)를 하나 살려두면, 가비지 컬렉터는 그 객체 뿐만 아니라 그 객체 내에서 참조하고 있는 객체까지 회수 할 수 없다.</p>\n<p>이로 인해 잠재적으로 성능에 악영향을 줄 수 있다.</p>\n<h1 id=\"가비지-컬렉션의-소멸-대상이-되기-위해서는\">가비지 컬렉션의 소멸 대상이 되기 위해서는...</h1>\n<h2 id=\"직접-할당-해제\">직접 할당 해제</h2>\n<ul>\n<li>이 방법은 굉장히 단순하다.<br>\n말 그대로 객체 참조 변수를 null로 초기화 한다.<br>\n그렇게 되면 실제 heap 메모리에 존재하는 객체는 어떠한 참조(reference)도 가지지 않기 때문에\n<code>가비지 컬렉션의 소멸 대상</code>이 된다.</li>\n<li>하지만 바람직한 방법은 아니다. 반드시 필요한 경우에만 사용 할 수 있도록 하는 것이 좋다.<br>\n(소스코드가 드러워짐 -_-)</li>\n<li>클래스 내에서 메모리를 관리 하는 객체(Stack 같은...)라면 이 방법을 통해 다 쓴 객체는 할당을 해제 하는 것이 옳다.</li>\n</ul>\n<h2 id=\"scope를-통한-자동-할당-해제\">Scope를 통한 자동 할당 해제</h2>\n<ul>\n<li>보통은 변수 선언<code>(대게 지역변수)</code>과 동시에 초기화를 사용한다.<br>\n그 변수에 대한 scope가 종료되는 순간 reference가 해제되어 가비지 컬렉션의 대상이 된다.</li>\n<li>try~catch와 같은 구문에서는 catch 구문에서 try내에서 사용하는 변수를 참조하지 못하므로\ntry~catch 변수 초기화를 하기 어렵다.<br>\n그렇게 때문에 finally 구문에서 변수에 대한 참조를 해제한다.</li>\n</ul>\n<h1 id=\"메모리-누수를-일으키는-주범\">메모리 누수를 일으키는 주범</h1>\n<ul>\n<li>첫번째는 위에서 설명한 class내에서 instance에 대한 참조(reference)를 관리하는 객체이다.</li>\n<li>두번째는 Map과 같은 캐시</li>\n<li>세번째는 리스너(Listener) 혹은 콜백(Callback)</li>\n</ul>\n<p>Map과 같은 캐시에 객체참조를 넣어두고 사용이 끝났는데도 초기화를 안시켜주는 경우 메모리 누수가 발생한다.<br>\n엔트리가 살아있는 동안만 캐시를 사용하려면 <code>WeakHashMap</code>을 사용하자.<br>\nWeakHashMap을 이해하려면 Java의 Reference를 좀 알아야 한다.</p>\n<h2 id=\"java-reference\">Java Reference</h2>\n<p>Java에는 4가지의 Reference가 있다.</p>\n<ul>\n<li>\n<p>Strong Reference</p>\n<ul>\n<li>우리가 흔히 사용하는 reference</li>\n<li>String str = new String(&quot;abc&quot;); 와 같은 형태</li>\n<li>Strong Reference는 GC의 대상이 되지 않는다.</li>\n<li>Strong Reference관계의 객체가 GC가 되기 위해선 null로 초기화해<br>\n객체에 대한 Reachability상태를 UnReachable 상태로 만들어 줘야 한다.</li>\n</ul>\n</li>\n<li>\n<p>Soft Reference</p>\n<ul>\n<li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference만 있는 상태</li>\n<li>SoftReference&lt;Class&gt; ref = new SoftReference&lt;&gt;(new String(&quot;abc&quot;));와 같은 형태로 사용</li>\n<li>Soft Reference는 대게 GC대상이 아니다가 <code>out of memory에러</code>가 나기 직전까지 가면<br>\nSoft Reference 관계에 있는 객체들은 GC대상이 된다.</li>\n</ul>\n</li>\n<li>\n<p>Weak Reference</p>\n<ul>\n<li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference가 없고 Weak Reference만 있는 상태</li>\n<li>WeakReference&lt;Class&gt; ref = new WeakReference&lt;Class&gt;(new String(&quot;abc&quot;)); 와 같은 형태로 사용</li>\n<li>WeakReference는 GC가 발생 할 때마다 대상이 된다.</li>\n</ul>\n</li>\n<li>\n<p>Phantomly Reference</p>\n<ul>\n<li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference와 Weak Referencerk 모두가 해당되지 않는 객체</li>\n<li>finalize 되었지만 메모리가 아직 회수 되지 않은 객체</li>\n<li>아직 잘 이해가... 안됨</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"weakhashmap\">WeakHashMap</h2>\n<p>Weak Reference를 이용한 HashMap<br>\n아래의 예제코드를 보자\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassWeakHashMap</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Referred</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Good bye cruel world\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * GC를 발생 시켜 메모리를 회수하는 코드</span></span><br><span class=\"line\"><span class=\"comment\">    * System.gc()가 잘 동작할지는 모르겠다.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">collect</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Suggesting collection\"</span>);</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Sleeping\"</span>);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Creating weak references\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This is now a weak reference. </span></span><br><span class=\"line\">        <span class=\"comment\">// The object will be collected only if no strong references. </span></span><br><span class=\"line\">        Referred strong = <span class=\"keyword\">new</span> Referred(); <span class=\"comment\">//Strong Reference로 하나 추가</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Weak Reference를 이용한 WeakHashMap에 엔트리를 추가하여</span></span><br><span class=\"line\">        <span class=\"comment\">//Weak Reference 추가</span></span><br><span class=\"line\">        Map&lt;Referred, String&gt; metadata = <span class=\"keyword\">new</span> WeakHashMap&lt;Referred, String&gt;();</span><br><span class=\"line\">        metadata.put(strong, <span class=\"string\">\"WeakHashMap's make my world go around\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Attempt to claim a suggested reference. </span></span><br><span class=\"line\">        ClassWeakHashMap.collect();</span><br><span class=\"line\">        <span class=\"comment\">//여기서는 gc가 발생해도 GC대상이 아니게 된다.</span></span><br><span class=\"line\">        <span class=\"comment\">//strong이라는 변수를 통해 Strong Reference를 가지므로 GC 대상이 아니다.</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Still has metadata entry? \"</span> + (metadata.size() == <span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Removing reference\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// The object may be collected. </span></span><br><span class=\"line\">        <span class=\"comment\">//Strong Reference를 끊었다.</span></span><br><span class=\"line\">        strong = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//여기서는 Weak Reference만 남아 있기 때문에 GC대상이 된다.</span></span><br><span class=\"line\">        ClassWeakHashMap.collect();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Still has metadata entry? \"</span> + (metadata.size() == <span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Done\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Weak Reference를 가지고 있으면 GC가 발생되기 전까지 객체에 접근이 가능하기 때문에 메모리 누수의 입장으로 볼 때 유리한 것 같다.<br>\n한번 캐싱하고 사용하고 버리는 대상에 좋은 방법이다.</p>\n<p>하지만 static한 Map을 사용하는 경우에는 비추이다.<br>\n언제 GC가 일어날지 모를 뿐더러.. 갑자기 데이터가 사라져 자칫 하면 장애가 발생 할 수 있으니,\n특별한 경우에만 WeakHashMap을 사용해야 한다.</p>\n<h2 id=\"리스너-혹은-콜백\">리스너 혹은 콜백</h2>\n<p>리스너와 콜백은 root set에 대한 직접 참조가 아닌 객체에서 참조를 가지고 있다.<br>\n그렇기 때문에 리스너와 콜백을 사용하는 객체가 unreachable 상태가 되지 않는 이상 메모리에서 GC대상이 되지 않는다.<br>\n이 경우 weak reference를 이용하면 리스너와 콜백을 사용하고, GC 작동 시에 메모리 해제를 시킬 수 있어, 메모리 누수에 도움이 된다.</p>\n<h1 id=\"추가적으로\">추가적으로..</h1>\n<p>메모리 누수는 겉으로 잘 드러나지 않아 수년 간 잠복하는 사례가 있다고 한다.<br>\n이런 누수는 철저한 코드리뷰나 힙 프로파일링 도구를 통해 디버깅을 동원해야 발견할 수 있으므로,<br>\n평소에 코드를 작성할 때 메모리 누수에 대한 부분을 신경을 써주는 것이 중요하다.</p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 7. 다 쓴 객체는 참조를 해제하라</li>\n<li>https://d2.naver.com/helloworld/329631</li>\n<li>https://tourspace.tistory.com/42</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>Java의 장점 중 하나는 가비지 컬렉션을 지원하는 언어라는 점이다.<br>\nC, C++ 처럼 개발자가 메모리를 직접 할당하고 해제하는 방식이 아니기 때문에 Java에서는 메모리 관리가 굉장히 편하다는 장점이 있다.</p>\n<p>하지만 <code>아예 신경을 안써도 되는 것은 아니다.</code><br>\n가비지 컬렉션을 통해 소멸 대상이 되는 객체가 되기 위해서는 어떠한 reference 변수에서 가르키지 않아야 한다.<br>\n다 쓴 객체에 대한 참조를 해제하지 않으면 가비지 컬렉션의 대상이 되지 않아 계속 메모리가 할당 되는 <strong>메모리 누수</strong> 현상이 발생 된다.</p>\n<p>가비지 컬렉션을 지원하는 언어에서는 메모리 누수를 찾기가 까다롭다<br>\n객체 참조(reference)를 하나 살려두면, 가비지 컬렉터는 그 객체 뿐만 아니라 그 객체 내에서 참조하고 있는 객체까지 회수 할 수 없다.</p>\n<p>이로 인해 잠재적으로 성능에 악영향을 줄 수 있다.</p>\n<h1>가비지 컬렉션의 소멸 대상이 되기 위해서는...</h1>\n<h2>직접 할당 해제</h2>\n<ul>\n<li>이 방법은 굉장히 단순하다.<br>\n말 그대로 객체 참조 변수를 null로 초기화 한다.<br>\n그렇게 되면 실제 heap 메모리에 존재하는 객체는 어떠한 참조(reference)도 가지지 않기 때문에\n<code>가비지 컬렉션의 소멸 대상</code>이 된다.</li>\n<li>하지만 바람직한 방법은 아니다. 반드시 필요한 경우에만 사용 할 수 있도록 하는 것이 좋다.<br>\n(소스코드가 드러워짐 -_-)</li>\n<li>클래스 내에서 메모리를 관리 하는 객체(Stack 같은...)라면 이 방법을 통해 다 쓴 객체는 할당을 해제 하는 것이 옳다.</li>\n</ul>\n<h2>Scope를 통한 자동 할당 해제</h2>\n<ul>\n<li>보통은 변수 선언<code>(대게 지역변수)</code>과 동시에 초기화를 사용한다.<br>\n그 변수에 대한 scope가 종료되는 순간 reference가 해제되어 가비지 컬렉션의 대상이 된다.</li>\n<li>try~catch와 같은 구문에서는 catch 구문에서 try내에서 사용하는 변수를 참조하지 못하므로\ntry~catch 변수 초기화를 하기 어렵다.<br>\n그렇게 때문에 finally 구문에서 변수에 대한 참조를 해제한다.</li>\n</ul>\n<h1>메모리 누수를 일으키는 주범</h1>\n<ul>\n<li>첫번째는 위에서 설명한 class내에서 instance에 대한 참조(reference)를 관리하는 객체이다.</li>\n<li>두번째는 Map과 같은 캐시</li>\n<li>세번째는 리스너(Listener) 혹은 콜백(Callback)</li>\n</ul>\n<p>Map과 같은 캐시에 객체참조를 넣어두고 사용이 끝났는데도 초기화를 안시켜주는 경우 메모리 누수가 발생한다.<br>\n엔트리가 살아있는 동안만 캐시를 사용하려면 <code>WeakHashMap</code>을 사용하자.<br>\nWeakHashMap을 이해하려면 Java의 Reference를 좀 알아야 한다.</p>\n<h2>Java Reference</h2>\n<p>Java에는 4가지의 Reference가 있다.</p>\n<ul>\n<li>\n<p>Strong Reference</p>\n<ul>\n<li>우리가 흔히 사용하는 reference</li>\n<li>String str = new String(&quot;abc&quot;); 와 같은 형태</li>\n<li>Strong Reference는 GC의 대상이 되지 않는다.</li>\n<li>Strong Reference관계의 객체가 GC가 되기 위해선 null로 초기화해<br>\n객체에 대한 Reachability상태를 UnReachable 상태로 만들어 줘야 한다.</li>\n</ul>\n</li>\n<li>\n<p>Soft Reference</p>\n<ul>\n<li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference만 있는 상태</li>\n<li>SoftReference&lt;Class&gt; ref = new SoftReference&lt;&gt;(new String(&quot;abc&quot;));와 같은 형태로 사용</li>\n<li>Soft Reference는 대게 GC대상이 아니다가 <code>out of memory에러</code>가 나기 직전까지 가면<br>\nSoft Reference 관계에 있는 객체들은 GC대상이 된다.</li>\n</ul>\n</li>\n<li>\n<p>Weak Reference</p>\n<ul>\n<li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference가 없고 Weak Reference만 있는 상태</li>\n<li>WeakReference&lt;Class&gt; ref = new WeakReference&lt;Class&gt;(new String(&quot;abc&quot;)); 와 같은 형태로 사용</li>\n<li>WeakReference는 GC가 발생 할 때마다 대상이 된다.</li>\n</ul>\n</li>\n<li>\n<p>Phantomly Reference</p>\n<ul>\n<li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference와 Weak Referencerk 모두가 해당되지 않는 객체</li>\n<li>finalize 되었지만 메모리가 아직 회수 되지 않은 객체</li>\n<li>아직 잘 이해가... 안됨</li>\n</ul>\n</li>\n</ul>\n<h2>WeakHashMap</h2>\n<p>Weak Reference를 이용한 HashMap<br>\n아래의 예제코드를 보자\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassWeakHashMap</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Referred</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Good bye cruel world\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * GC를 발생 시켜 메모리를 회수하는 코드</span></span><br><span class=\"line\"><span class=\"comment\">    * System.gc()가 잘 동작할지는 모르겠다.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">collect</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Suggesting collection\"</span>);</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Sleeping\"</span>);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Creating weak references\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This is now a weak reference. </span></span><br><span class=\"line\">        <span class=\"comment\">// The object will be collected only if no strong references. </span></span><br><span class=\"line\">        Referred strong = <span class=\"keyword\">new</span> Referred(); <span class=\"comment\">//Strong Reference로 하나 추가</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Weak Reference를 이용한 WeakHashMap에 엔트리를 추가하여</span></span><br><span class=\"line\">        <span class=\"comment\">//Weak Reference 추가</span></span><br><span class=\"line\">        Map&lt;Referred, String&gt; metadata = <span class=\"keyword\">new</span> WeakHashMap&lt;Referred, String&gt;();</span><br><span class=\"line\">        metadata.put(strong, <span class=\"string\">\"WeakHashMap's make my world go around\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Attempt to claim a suggested reference. </span></span><br><span class=\"line\">        ClassWeakHashMap.collect();</span><br><span class=\"line\">        <span class=\"comment\">//여기서는 gc가 발생해도 GC대상이 아니게 된다.</span></span><br><span class=\"line\">        <span class=\"comment\">//strong이라는 변수를 통해 Strong Reference를 가지므로 GC 대상이 아니다.</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Still has metadata entry? \"</span> + (metadata.size() == <span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Removing reference\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// The object may be collected. </span></span><br><span class=\"line\">        <span class=\"comment\">//Strong Reference를 끊었다.</span></span><br><span class=\"line\">        strong = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//여기서는 Weak Reference만 남아 있기 때문에 GC대상이 된다.</span></span><br><span class=\"line\">        ClassWeakHashMap.collect();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Still has metadata entry? \"</span> + (metadata.size() == <span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Done\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Weak Reference를 가지고 있으면 GC가 발생되기 전까지 객체에 접근이 가능하기 때문에 메모리 누수의 입장으로 볼 때 유리한 것 같다.<br>\n한번 캐싱하고 사용하고 버리는 대상에 좋은 방법이다.</p>\n<p>하지만 static한 Map을 사용하는 경우에는 비추이다.<br>\n언제 GC가 일어날지 모를 뿐더러.. 갑자기 데이터가 사라져 자칫 하면 장애가 발생 할 수 있으니,\n특별한 경우에만 WeakHashMap을 사용해야 한다.</p>\n<h2>리스너 혹은 콜백</h2>\n<p>리스너와 콜백은 root set에 대한 직접 참조가 아닌 객체에서 참조를 가지고 있다.<br>\n그렇기 때문에 리스너와 콜백을 사용하는 객체가 unreachable 상태가 되지 않는 이상 메모리에서 GC대상이 되지 않는다.<br>\n이 경우 weak reference를 이용하면 리스너와 콜백을 사용하고, GC 작동 시에 메모리 해제를 시킬 수 있어, 메모리 누수에 도움이 된다.</p>\n<h1>추가적으로..</h1>\n<p>메모리 누수는 겉으로 잘 드러나지 않아 수년 간 잠복하는 사례가 있다고 한다.<br>\n이런 누수는 철저한 코드리뷰나 힙 프로파일링 도구를 통해 디버깅을 동원해야 발견할 수 있으므로,<br>\n평소에 코드를 작성할 때 메모리 누수에 대한 부분을 신경을 써주는 것이 중요하다.</p>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 7. 다 쓴 객체는 참조를 해제하라</li>\n<li>https://d2.naver.com/helloworld/329631</li>\n<li>https://tourspace.tistory.com/42</li>\n</ul>\n"},{"title":"Item 8. Finalizer와 Cleaner 사용은 피하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item8","typora-copy-images-to":"effective-java-item8","date":"2019-01-07T15:32:01.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\nJava\u001e에서는 2가지의 객체 소멸자를 제공한다.\n* finalzier\n* cleaner\n\n이 2가지 객체 소멸자는 JVM내의 GC가 작동할 때 실행되는 구문이다.  \n기본적으로 이 2가지 구문은 **사용하지 말아야 한다.**  \n현재 Java 9 버전 부터는 Object 클래스에 대한 finalizer를 `Deprecated` 처리하였다.  \n아래에 사용하지 말아햐 하는 이유를 하나씩 보도록 하겠다.\n\n# finalizer와 cleaner를 사용하지 말아야 하는 이유\n## 실행을 보장할 수 없다.\nfinalizer에 특정 로직을 삽입하는 경우 실행을 보장 할 수 없다.  \n기본적으로 GC가 발생할 때 실행되는 로직이지만, Java Application이 죽는다던지의 이유로 finalizer 실행이 되지 않을 수 있다.   \n그렇기 때문에 제 때 실행되어야 하거나, 뭔가 상태를 수정하는 행위를 절대적으로 하면은 안된다.\n\n## 느리다.\nEffective Java 책의 예제에서는 AutoCloseable과 finalizer의 성능비교를 한 문단이 있다.  \nAutocloseable을 사용한 GC 수행시간은 12ns였지만, finalizer를 사용한 GC 수행 시간은 550ns가 걸렸다고 한다.  \nfinalizer가 가비지 컬렉터의 효율을 떨어뜨리기 때문이다.\n\n## 시스템 전체 장애를 유발 할 수 있다.\nJava API 문서 상에서는 GC가 UnReachable 상태의 객체를 가비지 컬렉션 할 때 finalizer가 호출된다고 명시하고 있다.  \n하지만 finalizer가 실행되는 시점은 GC 발생 시 즉각적으로 이루어지는게 아니다.  \nfinalizer queue에 삽입되어 순차적으로 finalizer를 실행하게 된다.  \n그렇기 때문에 finalizer메소드 실행이 느린 경우 객체 소멸이 느려지므로  `Out of Memory`와 같은 오류를 발생 시킬 가능성이 높아지게 된다.\n\n## finalizer 공격에 취약하다.\n위에 적은 것 처럼 finalizer 메소드 실행시간이 오래 걸리게 만들면 시스템에 심각한 장애를 유발할 수 있다.  \nfinalizer 메서드를 override해서 악의적으로 느리게 할 수 있기 떄문에 finalizer를 사용해야 하는 경우라면  \n메소드에 `final` 키워드를 붙여서 상속하지 못하도록 해야한다.\n\n# 그럼 finalizer나 cleaner는 어디서 쓰나?\n* 개발자가 객체의 close를 호출하지 않는 경우 -> 자원 해제를 안하느니 느리더라도 하는게 낫다.  \n(이 경우는 동의 못하겠다. 개발자가 close를 시켜야 한다.)\n* native peer와 연결된 객체\n  * native peer는 자바 객체가 아니기 떄문에 가비지 컬렉터의 관리 대상이 아니다.  \n  그렇기 때문에 native peer가 회수 될때 finalizer 메서드를 실행해 자원을 해제 할 수 있다.\n\n# finalizer 기능이 필요한 경우에는 어떻게?\nAutocloseable Interface를 사용하여 close를 호출시키도록 하자.  \n다음장의 try-catch-resource 구문에서 설명하도록 하겠다.\n\n# 참고\n* Effective Java 3rd Edition - Item 8. finalizer와 cleaner 사용은 피하라\n* [finalize 메소드의 오버라이딩을 자제해야 하는 이유.](http://www.yunsobi.com/blog/entry/finalize-%EB%A9%94%EC%86%8C%EB%93%9C%EC%9D%98-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EC%9D%84-%EC%9E%90%EC%A0%9C%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)","source":"_posts/effective-java-item8.md","raw":"---\ntitle: Item 8. finalizer와 cleaner 사용은 피하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item8\ntypora-copy-images-to: effective-java-item8\ndate: 2019-01-08 00:32:01\nsubtitle:\nheader-img:\n---\n\n# 서론\nJava\u001e에서는 2가지의 객체 소멸자를 제공한다.\n* finalzier\n* cleaner\n\n이 2가지 객체 소멸자는 JVM내의 GC가 작동할 때 실행되는 구문이다.  \n기본적으로 이 2가지 구문은 **사용하지 말아야 한다.**  \n현재 Java 9 버전 부터는 Object 클래스에 대한 finalizer를 `Deprecated` 처리하였다.  \n아래에 사용하지 말아햐 하는 이유를 하나씩 보도록 하겠다.\n\n# finalizer와 cleaner를 사용하지 말아야 하는 이유\n## 실행을 보장할 수 없다.\nfinalizer에 특정 로직을 삽입하는 경우 실행을 보장 할 수 없다.  \n기본적으로 GC가 발생할 때 실행되는 로직이지만, Java Application이 죽는다던지의 이유로 finalizer 실행이 되지 않을 수 있다.   \n그렇기 때문에 제 때 실행되어야 하거나, 뭔가 상태를 수정하는 행위를 절대적으로 하면은 안된다.\n\n## 느리다.\nEffective Java 책의 예제에서는 AutoCloseable과 finalizer의 성능비교를 한 문단이 있다.  \nAutocloseable을 사용한 GC 수행시간은 12ns였지만, finalizer를 사용한 GC 수행 시간은 550ns가 걸렸다고 한다.  \nfinalizer가 가비지 컬렉터의 효율을 떨어뜨리기 때문이다.\n\n## 시스템 전체 장애를 유발 할 수 있다.\nJava API 문서 상에서는 GC가 UnReachable 상태의 객체를 가비지 컬렉션 할 때 finalizer가 호출된다고 명시하고 있다.  \n하지만 finalizer가 실행되는 시점은 GC 발생 시 즉각적으로 이루어지는게 아니다.  \nfinalizer queue에 삽입되어 순차적으로 finalizer를 실행하게 된다.  \n그렇기 때문에 finalizer메소드 실행이 느린 경우 객체 소멸이 느려지므로  `Out of Memory`와 같은 오류를 발생 시킬 가능성이 높아지게 된다.\n\n## finalizer 공격에 취약하다.\n위에 적은 것 처럼 finalizer 메소드 실행시간이 오래 걸리게 만들면 시스템에 심각한 장애를 유발할 수 있다.  \nfinalizer 메서드를 override해서 악의적으로 느리게 할 수 있기 떄문에 finalizer를 사용해야 하는 경우라면  \n메소드에 `final` 키워드를 붙여서 상속하지 못하도록 해야한다.\n\n# 그럼 finalizer나 cleaner는 어디서 쓰나?\n* 개발자가 객체의 close를 호출하지 않는 경우 -> 자원 해제를 안하느니 느리더라도 하는게 낫다.  \n(이 경우는 동의 못하겠다. 개발자가 close를 시켜야 한다.)\n* native peer와 연결된 객체\n  * native peer는 자바 객체가 아니기 떄문에 가비지 컬렉터의 관리 대상이 아니다.  \n  그렇기 때문에 native peer가 회수 될때 finalizer 메서드를 실행해 자원을 해제 할 수 있다.\n\n# finalizer 기능이 필요한 경우에는 어떻게?\nAutocloseable Interface를 사용하여 close를 호출시키도록 하자.  \n다음장의 try-catch-resource 구문에서 설명하도록 하겠다.\n\n# 참고\n* Effective Java 3rd Edition - Item 8. finalizer와 cleaner 사용은 피하라\n* [finalize 메소드의 오버라이딩을 자제해야 하는 이유.](http://www.yunsobi.com/blog/entry/finalize-%EB%A9%94%EC%86%8C%EB%93%9C%EC%9D%98-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EC%9D%84-%EC%9E%90%EC%A0%9C%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)","slug":"effective-java-item8","published":1,"updated":"2019-01-07T13:32:09.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2sd001gcr1tt05lcc1r","content":"<h1 id=\"서론\">서론</h1>\n<p>Java\u001e에서는 2가지의 객체 소멸자를 제공한다.</p>\n<ul>\n<li>finalzier</li>\n<li>cleaner</li>\n</ul>\n<p>이 2가지 객체 소멸자는 JVM내의 GC가 작동할 때 실행되는 구문이다.<br>\n기본적으로 이 2가지 구문은 <strong>사용하지 말아야 한다.</strong><br>\n현재 Java 9 버전 부터는 Object 클래스에 대한 finalizer를 <code>Deprecated</code> 처리하였다.<br>\n아래에 사용하지 말아햐 하는 이유를 하나씩 보도록 하겠다.</p>\n<h1 id=\"finalizer와-cleaner를-사용하지-말아야-하는-이유\">finalizer와 cleaner를 사용하지 말아야 하는 이유</h1>\n<h2 id=\"실행을-보장할-수-없다\">실행을 보장할 수 없다.</h2>\n<p>finalizer에 특정 로직을 삽입하는 경우 실행을 보장 할 수 없다.<br>\n기본적으로 GC가 발생할 때 실행되는 로직이지만, Java Application이 죽는다던지의 이유로 finalizer 실행이 되지 않을 수 있다.<br>\n그렇기 때문에 제 때 실행되어야 하거나, 뭔가 상태를 수정하는 행위를 절대적으로 하면은 안된다.</p>\n<h2 id=\"느리다\">느리다.</h2>\n<p>Effective Java 책의 예제에서는 AutoCloseable과 finalizer의 성능비교를 한 문단이 있다.<br>\nAutocloseable을 사용한 GC 수행시간은 12ns였지만, finalizer를 사용한 GC 수행 시간은 550ns가 걸렸다고 한다.<br>\nfinalizer가 가비지 컬렉터의 효율을 떨어뜨리기 때문이다.</p>\n<h2 id=\"시스템-전체-장애를-유발-할-수-있다\">시스템 전체 장애를 유발 할 수 있다.</h2>\n<p>Java API 문서 상에서는 GC가 UnReachable 상태의 객체를 가비지 컬렉션 할 때 finalizer가 호출된다고 명시하고 있다.<br>\n하지만 finalizer가 실행되는 시점은 GC 발생 시 즉각적으로 이루어지는게 아니다.<br>\nfinalizer queue에 삽입되어 순차적으로 finalizer를 실행하게 된다.<br>\n그렇기 때문에 finalizer메소드 실행이 느린 경우 객체 소멸이 느려지므로  <code>Out of Memory</code>와 같은 오류를 발생 시킬 가능성이 높아지게 된다.</p>\n<h2 id=\"finalizer-공격에-취약하다\">finalizer 공격에 취약하다.</h2>\n<p>위에 적은 것 처럼 finalizer 메소드 실행시간이 오래 걸리게 만들면 시스템에 심각한 장애를 유발할 수 있다.<br>\nfinalizer 메서드를 override해서 악의적으로 느리게 할 수 있기 떄문에 finalizer를 사용해야 하는 경우라면<br>\n메소드에 <code>final</code> 키워드를 붙여서 상속하지 못하도록 해야한다.</p>\n<h1 id=\"그럼-finalizer나-cleaner는-어디서-쓰나\">그럼 finalizer나 cleaner는 어디서 쓰나?</h1>\n<ul>\n<li>개발자가 객체의 close를 호출하지 않는 경우 -&gt; 자원 해제를 안하느니 느리더라도 하는게 낫다.<br>\n(이 경우는 동의 못하겠다. 개발자가 close를 시켜야 한다.)</li>\n<li>native peer와 연결된 객체\n<ul>\n<li>native peer는 자바 객체가 아니기 떄문에 가비지 컬렉터의 관리 대상이 아니다.<br>\n그렇기 때문에 native peer가 회수 될때 finalizer 메서드를 실행해 자원을 해제 할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"finalizer-기능이-필요한-경우에는-어떻게\">finalizer 기능이 필요한 경우에는 어떻게?</h1>\n<p>Autocloseable Interface를 사용하여 close를 호출시키도록 하자.<br>\n다음장의 try-catch-resource 구문에서 설명하도록 하겠다.</p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 8. finalizer와 cleaner 사용은 피하라</li>\n<li><a href=\"http://www.yunsobi.com/blog/entry/finalize-%EB%A9%94%EC%86%8C%EB%93%9C%EC%9D%98-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EC%9D%84-%EC%9E%90%EC%A0%9C%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" target=\"_blank\" rel=\"noopener\">finalize 메소드의 오버라이딩을 자제해야 하는 이유.</a></li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>Java\u001e에서는 2가지의 객체 소멸자를 제공한다.</p>\n<ul>\n<li>finalzier</li>\n<li>cleaner</li>\n</ul>\n<p>이 2가지 객체 소멸자는 JVM내의 GC가 작동할 때 실행되는 구문이다.<br>\n기본적으로 이 2가지 구문은 <strong>사용하지 말아야 한다.</strong><br>\n현재 Java 9 버전 부터는 Object 클래스에 대한 finalizer를 <code>Deprecated</code> 처리하였다.<br>\n아래에 사용하지 말아햐 하는 이유를 하나씩 보도록 하겠다.</p>\n<h1>finalizer와 cleaner를 사용하지 말아야 하는 이유</h1>\n<h2>실행을 보장할 수 없다.</h2>\n<p>finalizer에 특정 로직을 삽입하는 경우 실행을 보장 할 수 없다.<br>\n기본적으로 GC가 발생할 때 실행되는 로직이지만, Java Application이 죽는다던지의 이유로 finalizer 실행이 되지 않을 수 있다.<br>\n그렇기 때문에 제 때 실행되어야 하거나, 뭔가 상태를 수정하는 행위를 절대적으로 하면은 안된다.</p>\n<h2>느리다.</h2>\n<p>Effective Java 책의 예제에서는 AutoCloseable과 finalizer의 성능비교를 한 문단이 있다.<br>\nAutocloseable을 사용한 GC 수행시간은 12ns였지만, finalizer를 사용한 GC 수행 시간은 550ns가 걸렸다고 한다.<br>\nfinalizer가 가비지 컬렉터의 효율을 떨어뜨리기 때문이다.</p>\n<h2>시스템 전체 장애를 유발 할 수 있다.</h2>\n<p>Java API 문서 상에서는 GC가 UnReachable 상태의 객체를 가비지 컬렉션 할 때 finalizer가 호출된다고 명시하고 있다.<br>\n하지만 finalizer가 실행되는 시점은 GC 발생 시 즉각적으로 이루어지는게 아니다.<br>\nfinalizer queue에 삽입되어 순차적으로 finalizer를 실행하게 된다.<br>\n그렇기 때문에 finalizer메소드 실행이 느린 경우 객체 소멸이 느려지므로  <code>Out of Memory</code>와 같은 오류를 발생 시킬 가능성이 높아지게 된다.</p>\n<h2>finalizer 공격에 취약하다.</h2>\n<p>위에 적은 것 처럼 finalizer 메소드 실행시간이 오래 걸리게 만들면 시스템에 심각한 장애를 유발할 수 있다.<br>\nfinalizer 메서드를 override해서 악의적으로 느리게 할 수 있기 떄문에 finalizer를 사용해야 하는 경우라면<br>\n메소드에 <code>final</code> 키워드를 붙여서 상속하지 못하도록 해야한다.</p>\n<h1>그럼 finalizer나 cleaner는 어디서 쓰나?</h1>\n<ul>\n<li>개발자가 객체의 close를 호출하지 않는 경우 -&gt; 자원 해제를 안하느니 느리더라도 하는게 낫다.<br>\n(이 경우는 동의 못하겠다. 개발자가 close를 시켜야 한다.)</li>\n<li>native peer와 연결된 객체\n<ul>\n<li>native peer는 자바 객체가 아니기 떄문에 가비지 컬렉터의 관리 대상이 아니다.<br>\n그렇기 때문에 native peer가 회수 될때 finalizer 메서드를 실행해 자원을 해제 할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h1>finalizer 기능이 필요한 경우에는 어떻게?</h1>\n<p>Autocloseable Interface를 사용하여 close를 호출시키도록 하자.<br>\n다음장의 try-catch-resource 구문에서 설명하도록 하겠다.</p>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 8. finalizer와 cleaner 사용은 피하라</li>\n<li><a href=\"http://www.yunsobi.com/blog/entry/finalize-%EB%A9%94%EC%86%8C%EB%93%9C%EC%9D%98-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EC%9D%84-%EC%9E%90%EC%A0%9C%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" target=\"_blank\" rel=\"noopener\">finalize 메소드의 오버라이딩을 자제해야 하는 이유.</a></li>\n</ul>\n"},{"title":"Item 9. Try-Finally 보다는 Try-With-Resources를 사용하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item9","typora-copy-images-to":"effective-java-item9","date":"2019-01-08T07:30:31.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\nJava 라이브러리 중에는 close메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, Connection등이 있다.  \n자원 닫기는 클라이언트가 놓치기 쉽기 때문에 예측할 수 없는 성능 문제로 이어지기도 한다.  \n\n나의 경우에도 신입 때 JDBC로 개발을 해야 했던 적이 있었는데,  \nDB의 max-connection이 10이어서 11번째 호출 시 부터는 JDBCException이 발생하는 오류를 겪은 적이 있다.  \n알고 보니 하나의 메서드에서 Connection 객체에 대한 참조를 해제 하지 않아 계속 Connection을 물고 있는 상황이었다.  \nSpring을 사용하면서는 Mybatis나 JPA같은 프레임웍 내에서 자원에 대한 관리를 해주기 때문에 이런 일을 만날 일은 없게 되었다.\n\n하지만 예전처럼 JDBC를 사용하거나, IO관련 작업을 할 때는 반드시 close를 통해 자원에 대한 해제가 필요하다.  \n이전에는 finallizer를 통해 했다고는 아는데 이전 장에서 봤듯이 안 쓰는것이 좋다.  \n그리고 try-catch-finally 구문을 통해 Exception이 발생하더라도, finally 절에서 close를 호출 하도록 했는데, 코드가 복잡해 지고, finally 절 내에서 Exception이 발생하는 경우도 있기 때문에 이를 방지하기 위해 더 더러운 코드를 생산하는 일이 적지 않았다.\n\n옛날에 자주 사용해 본 아주아주 슬픈 코드이다.\n```java\npublic class JDBCExam {\n  Connection connection;\n  Statement statement;\n  ResultSet resultSet;\n\n  String driverName = \"oracle.jdbc.driver.OracleDriver\";\n  String url = \"oracle:thin:localhost:1521:ORCL\";\n  String user = \"scott\";\n  String password = \"tiger\";\n\n  public JDBCExam() {\n      try {\n          Class.forName(driverName);\n          connection = DriverManager.getConnection(url, user, password);\n      } catch (ClassNotFoundException e) {\n          System.out.println(\"[로드 오류]\\n\" + e.getStackTrace());\n      } catch (SQLException e) {\n          System.out.println(\"[연결 오류]\\n\" + e.getStackTrace());\n      } finally {\n          try {\n              if (connection != null) {\n                  connection.close();\n              }\n              if (statement != null) {\n                  statement.close();\n              }\n              if (resultSet != null) {\n                  resultSet.close();\n              }\n          } catch (SQLException e) {\n              System.out.println(\"[닫기 오류]\\n\" + e.getStackTrace());\n          }\n      }\n  }\n}\n```\n\n# AutoCloseable\nJDK 1.7 부터 try-with-resources 구문이 추가 되었고, `AutoCloseable` 인터페이스가 추가되었다. 이 인터페이스가 나오고 부터 Java의 close를 지원하는 클래스에서 AutoCloseable을 구현하도록 변경되었다.\n\n# try-with-resources\ntry 절에 AutoCloseable을 구현한 클래스에 대한 인스턴스를 선언하게 되면 try절이 종료되는 시점에 AutoCloseable 인터페이스의 close() 메서드를 자동으로 호출 한다. 그렇기 때문에 이전처럼 finally 구문에서 별도로 자원에 대한 해제를 하지 않아도 된다.\n\n위의 예시코드를 try-with-resources 구문으로 바꿔보았다.  \n위의 코드보다는 한층 깔끔해 짐을 볼 수 있다.\n```java\npublic class JDBCExam {\n\n    String driverName = \"oracle.jdbc.driver.OracleDriver\";\n    String url = \"oracle:thin:localhost:1521:ORCL\";\n    String user = \"scott\";\n    String password = \"tiger\";\n\n    public JDBCExam() {\n        try (Connection connection = DriverManager.getConnection(url, user, password);\n             Statement statement = connection.prepareStatement(\"select * from member\");\n             ResultSet resultSet = statement.getResultSet();\n             ){\n            Class.forName(driverName);\n            String name = resultSet.getString(1);\n            System.out.println(\"회원명 : \" + name);\n            \n        } catch (ClassNotFoundException e) {\n            System.out.println(\"[로드 오류]\\n\" + e.getStackTrace());\n        } catch (SQLException e) {\n            System.out.println(\"[연결 오류]\\n\" + e.getStackTrace());\n        } \n    }\n}\n```\n\n# 참고\n* Effective Java 3rd Edition - Item 9. try-finally 보다는 try-with-resources를 사용하라","source":"_posts/effective-java-item9.md","raw":"---\ntitle: Item 9. try-finally 보다는 try-with-resources를 사용하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item9\ntypora-copy-images-to: effective-java-item9\ndate: 2019-01-08 16:30:31\nsubtitle:\nheader-img:\n---\n\n# 서론\nJava 라이브러리 중에는 close메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, Connection등이 있다.  \n자원 닫기는 클라이언트가 놓치기 쉽기 때문에 예측할 수 없는 성능 문제로 이어지기도 한다.  \n\n나의 경우에도 신입 때 JDBC로 개발을 해야 했던 적이 있었는데,  \nDB의 max-connection이 10이어서 11번째 호출 시 부터는 JDBCException이 발생하는 오류를 겪은 적이 있다.  \n알고 보니 하나의 메서드에서 Connection 객체에 대한 참조를 해제 하지 않아 계속 Connection을 물고 있는 상황이었다.  \nSpring을 사용하면서는 Mybatis나 JPA같은 프레임웍 내에서 자원에 대한 관리를 해주기 때문에 이런 일을 만날 일은 없게 되었다.\n\n하지만 예전처럼 JDBC를 사용하거나, IO관련 작업을 할 때는 반드시 close를 통해 자원에 대한 해제가 필요하다.  \n이전에는 finallizer를 통해 했다고는 아는데 이전 장에서 봤듯이 안 쓰는것이 좋다.  \n그리고 try-catch-finally 구문을 통해 Exception이 발생하더라도, finally 절에서 close를 호출 하도록 했는데, 코드가 복잡해 지고, finally 절 내에서 Exception이 발생하는 경우도 있기 때문에 이를 방지하기 위해 더 더러운 코드를 생산하는 일이 적지 않았다.\n\n옛날에 자주 사용해 본 아주아주 슬픈 코드이다.\n```java\npublic class JDBCExam {\n  Connection connection;\n  Statement statement;\n  ResultSet resultSet;\n\n  String driverName = \"oracle.jdbc.driver.OracleDriver\";\n  String url = \"oracle:thin:localhost:1521:ORCL\";\n  String user = \"scott\";\n  String password = \"tiger\";\n\n  public JDBCExam() {\n      try {\n          Class.forName(driverName);\n          connection = DriverManager.getConnection(url, user, password);\n      } catch (ClassNotFoundException e) {\n          System.out.println(\"[로드 오류]\\n\" + e.getStackTrace());\n      } catch (SQLException e) {\n          System.out.println(\"[연결 오류]\\n\" + e.getStackTrace());\n      } finally {\n          try {\n              if (connection != null) {\n                  connection.close();\n              }\n              if (statement != null) {\n                  statement.close();\n              }\n              if (resultSet != null) {\n                  resultSet.close();\n              }\n          } catch (SQLException e) {\n              System.out.println(\"[닫기 오류]\\n\" + e.getStackTrace());\n          }\n      }\n  }\n}\n```\n\n# AutoCloseable\nJDK 1.7 부터 try-with-resources 구문이 추가 되었고, `AutoCloseable` 인터페이스가 추가되었다. 이 인터페이스가 나오고 부터 Java의 close를 지원하는 클래스에서 AutoCloseable을 구현하도록 변경되었다.\n\n# try-with-resources\ntry 절에 AutoCloseable을 구현한 클래스에 대한 인스턴스를 선언하게 되면 try절이 종료되는 시점에 AutoCloseable 인터페이스의 close() 메서드를 자동으로 호출 한다. 그렇기 때문에 이전처럼 finally 구문에서 별도로 자원에 대한 해제를 하지 않아도 된다.\n\n위의 예시코드를 try-with-resources 구문으로 바꿔보았다.  \n위의 코드보다는 한층 깔끔해 짐을 볼 수 있다.\n```java\npublic class JDBCExam {\n\n    String driverName = \"oracle.jdbc.driver.OracleDriver\";\n    String url = \"oracle:thin:localhost:1521:ORCL\";\n    String user = \"scott\";\n    String password = \"tiger\";\n\n    public JDBCExam() {\n        try (Connection connection = DriverManager.getConnection(url, user, password);\n             Statement statement = connection.prepareStatement(\"select * from member\");\n             ResultSet resultSet = statement.getResultSet();\n             ){\n            Class.forName(driverName);\n            String name = resultSet.getString(1);\n            System.out.println(\"회원명 : \" + name);\n            \n        } catch (ClassNotFoundException e) {\n            System.out.println(\"[로드 오류]\\n\" + e.getStackTrace());\n        } catch (SQLException e) {\n            System.out.println(\"[연결 오류]\\n\" + e.getStackTrace());\n        } \n    }\n}\n```\n\n# 참고\n* Effective Java 3rd Edition - Item 9. try-finally 보다는 try-with-resources를 사용하라","slug":"effective-java-item9","published":1,"updated":"2019-01-07T13:32:09.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2se001icr1tldcu6bst","content":"<h1 id=\"서론\">서론</h1>\n<p>Java 라이브러리 중에는 close메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, Connection등이 있다.<br>\n자원 닫기는 클라이언트가 놓치기 쉽기 때문에 예측할 수 없는 성능 문제로 이어지기도 한다.</p>\n<p>나의 경우에도 신입 때 JDBC로 개발을 해야 했던 적이 있었는데,<br>\nDB의 max-connection이 10이어서 11번째 호출 시 부터는 JDBCException이 발생하는 오류를 겪은 적이 있다.<br>\n알고 보니 하나의 메서드에서 Connection 객체에 대한 참조를 해제 하지 않아 계속 Connection을 물고 있는 상황이었다.<br>\nSpring을 사용하면서는 Mybatis나 JPA같은 프레임웍 내에서 자원에 대한 관리를 해주기 때문에 이런 일을 만날 일은 없게 되었다.</p>\n<p>하지만 예전처럼 JDBC를 사용하거나, IO관련 작업을 할 때는 반드시 close를 통해 자원에 대한 해제가 필요하다.<br>\n이전에는 finallizer를 통해 했다고는 아는데 이전 장에서 봤듯이 안 쓰는것이 좋다.<br>\n그리고 try-catch-finally 구문을 통해 Exception이 발생하더라도, finally 절에서 close를 호출 하도록 했는데, 코드가 복잡해 지고, finally 절 내에서 Exception이 발생하는 경우도 있기 때문에 이를 방지하기 위해 더 더러운 코드를 생산하는 일이 적지 않았다.</p>\n<p>옛날에 자주 사용해 본 아주아주 슬픈 코드이다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JDBCExam</span> </span>&#123;</span><br><span class=\"line\">  Connection connection;</span><br><span class=\"line\">  Statement statement;</span><br><span class=\"line\">  ResultSet resultSet;</span><br><span class=\"line\"></span><br><span class=\"line\">  String driverName = <span class=\"string\">\"oracle.jdbc.driver.OracleDriver\"</span>;</span><br><span class=\"line\">  String url = <span class=\"string\">\"oracle:thin:localhost:1521:ORCL\"</span>;</span><br><span class=\"line\">  String user = <span class=\"string\">\"scott\"</span>;</span><br><span class=\"line\">  String password = <span class=\"string\">\"tiger\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JDBCExam</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Class.forName(driverName);</span><br><span class=\"line\">          connection = DriverManager.getConnection(url, user, password);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"[로드 오류]\\n\"</span> + e.getStackTrace());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"[연결 오류]\\n\"</span> + e.getStackTrace());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  connection.close();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (statement != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  statement.close();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (resultSet != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  resultSet.close();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">              System.out.println(<span class=\"string\">\"[닫기 오류]\\n\"</span> + e.getStackTrace());</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"autocloseable\">AutoCloseable</h1>\n<p>JDK 1.7 부터 try-with-resources 구문이 추가 되었고, <code>AutoCloseable</code> 인터페이스가 추가되었다. 이 인터페이스가 나오고 부터 Java의 close를 지원하는 클래스에서 AutoCloseable을 구현하도록 변경되었다.</p>\n<h1 id=\"try-with-resources\">try-with-resources</h1>\n<p>try 절에 AutoCloseable을 구현한 클래스에 대한 인스턴스를 선언하게 되면 try절이 종료되는 시점에 AutoCloseable 인터페이스의 close() 메서드를 자동으로 호출 한다. 그렇기 때문에 이전처럼 finally 구문에서 별도로 자원에 대한 해제를 하지 않아도 된다.</p>\n<p>위의 예시코드를 try-with-resources 구문으로 바꿔보았다.<br>\n위의 코드보다는 한층 깔끔해 짐을 볼 수 있다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JDBCExam</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String driverName = <span class=\"string\">\"oracle.jdbc.driver.OracleDriver\"</span>;</span><br><span class=\"line\">    String url = <span class=\"string\">\"oracle:thin:localhost:1521:ORCL\"</span>;</span><br><span class=\"line\">    String user = <span class=\"string\">\"scott\"</span>;</span><br><span class=\"line\">    String password = <span class=\"string\">\"tiger\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JDBCExam</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class=\"line\">             Statement statement = connection.prepareStatement(<span class=\"string\">\"select * from member\"</span>);</span><br><span class=\"line\">             ResultSet resultSet = statement.getResultSet();</span><br><span class=\"line\">             )&#123;</span><br><span class=\"line\">            Class.forName(driverName);</span><br><span class=\"line\">            String name = resultSet.getString(<span class=\"number\">1</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"회원명 : \"</span> + name);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"[로드 오류]\\n\"</span> + e.getStackTrace());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"[연결 오류]\\n\"</span> + e.getStackTrace());</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 9. try-finally 보다는 try-with-resources를 사용하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>Java 라이브러리 중에는 close메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, Connection등이 있다.<br>\n자원 닫기는 클라이언트가 놓치기 쉽기 때문에 예측할 수 없는 성능 문제로 이어지기도 한다.</p>\n<p>나의 경우에도 신입 때 JDBC로 개발을 해야 했던 적이 있었는데,<br>\nDB의 max-connection이 10이어서 11번째 호출 시 부터는 JDBCException이 발생하는 오류를 겪은 적이 있다.<br>\n알고 보니 하나의 메서드에서 Connection 객체에 대한 참조를 해제 하지 않아 계속 Connection을 물고 있는 상황이었다.<br>\nSpring을 사용하면서는 Mybatis나 JPA같은 프레임웍 내에서 자원에 대한 관리를 해주기 때문에 이런 일을 만날 일은 없게 되었다.</p>\n<p>하지만 예전처럼 JDBC를 사용하거나, IO관련 작업을 할 때는 반드시 close를 통해 자원에 대한 해제가 필요하다.<br>\n이전에는 finallizer를 통해 했다고는 아는데 이전 장에서 봤듯이 안 쓰는것이 좋다.<br>\n그리고 try-catch-finally 구문을 통해 Exception이 발생하더라도, finally 절에서 close를 호출 하도록 했는데, 코드가 복잡해 지고, finally 절 내에서 Exception이 발생하는 경우도 있기 때문에 이를 방지하기 위해 더 더러운 코드를 생산하는 일이 적지 않았다.</p>\n<p>옛날에 자주 사용해 본 아주아주 슬픈 코드이다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JDBCExam</span> </span>&#123;</span><br><span class=\"line\">  Connection connection;</span><br><span class=\"line\">  Statement statement;</span><br><span class=\"line\">  ResultSet resultSet;</span><br><span class=\"line\"></span><br><span class=\"line\">  String driverName = <span class=\"string\">\"oracle.jdbc.driver.OracleDriver\"</span>;</span><br><span class=\"line\">  String url = <span class=\"string\">\"oracle:thin:localhost:1521:ORCL\"</span>;</span><br><span class=\"line\">  String user = <span class=\"string\">\"scott\"</span>;</span><br><span class=\"line\">  String password = <span class=\"string\">\"tiger\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JDBCExam</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Class.forName(driverName);</span><br><span class=\"line\">          connection = DriverManager.getConnection(url, user, password);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"[로드 오류]\\n\"</span> + e.getStackTrace());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"[연결 오류]\\n\"</span> + e.getStackTrace());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  connection.close();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (statement != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  statement.close();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (resultSet != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  resultSet.close();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">              System.out.println(<span class=\"string\">\"[닫기 오류]\\n\"</span> + e.getStackTrace());</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>AutoCloseable</h1>\n<p>JDK 1.7 부터 try-with-resources 구문이 추가 되었고, <code>AutoCloseable</code> 인터페이스가 추가되었다. 이 인터페이스가 나오고 부터 Java의 close를 지원하는 클래스에서 AutoCloseable을 구현하도록 변경되었다.</p>\n<h1>try-with-resources</h1>\n<p>try 절에 AutoCloseable을 구현한 클래스에 대한 인스턴스를 선언하게 되면 try절이 종료되는 시점에 AutoCloseable 인터페이스의 close() 메서드를 자동으로 호출 한다. 그렇기 때문에 이전처럼 finally 구문에서 별도로 자원에 대한 해제를 하지 않아도 된다.</p>\n<p>위의 예시코드를 try-with-resources 구문으로 바꿔보았다.<br>\n위의 코드보다는 한층 깔끔해 짐을 볼 수 있다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JDBCExam</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String driverName = <span class=\"string\">\"oracle.jdbc.driver.OracleDriver\"</span>;</span><br><span class=\"line\">    String url = <span class=\"string\">\"oracle:thin:localhost:1521:ORCL\"</span>;</span><br><span class=\"line\">    String user = <span class=\"string\">\"scott\"</span>;</span><br><span class=\"line\">    String password = <span class=\"string\">\"tiger\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JDBCExam</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class=\"line\">             Statement statement = connection.prepareStatement(<span class=\"string\">\"select * from member\"</span>);</span><br><span class=\"line\">             ResultSet resultSet = statement.getResultSet();</span><br><span class=\"line\">             )&#123;</span><br><span class=\"line\">            Class.forName(driverName);</span><br><span class=\"line\">            String name = resultSet.getString(<span class=\"number\">1</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"회원명 : \"</span> + name);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"[로드 오류]\\n\"</span> + e.getStackTrace());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"[연결 오류]\\n\"</span> + e.getStackTrace());</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 9. try-finally 보다는 try-with-resources를 사용하라</li>\n</ul>\n"},{"title":"Shallow Copy와 Deep Copy","catalog":true,"Categories":["Java"],"typora-root-url":"java-object-copy","typora-copy-images-to":"java-object-copy","date":"2019-01-13T09:59:09.000Z","subtitle":null,"header-img":null,"_content":"\n# 객체의 복사(Copy)\n객체 지향 프로그래밍에서 객체를 복사하는 방법은 크게 두가지로 나뉜다.  \n얇은 복사(Shallow Copy)와 깊은 복사(Deep Copy)가 있다.  \n두가지 개념 모두 원본 객체를 바탕으로 새로운 객체를 만들어 낸다는 점에서는 같지만 미묘한 차이가 있다.\n\n설명을 진행하기 전에 아래와 같은 Interface를 구현한 객체에 대해 copy가 진행된다고 가정하겠다.\n```java\npublic interface Copyable<T> {\n   T shallowCopy(T t);\n   T deepCopy(T t);\n}\n```\n\n\n\n![clone](./clone.jpg)\n\n\n\n# Shallow Copy\n\nShallow copy란 원본 객체를 바탕으로 새로운 객체를 생성한 뒤, 내부 필드의 참조에 대해서는 원본 객체와 같은 필드의 참조를 바라보는 형태이다.\n\n```java\n@NoArgsConstructor\n@AllArgsConstructor\n@Getter\npublic class Menu implements Copyable<Menu> {\n\n  private String name;\n  private int price;\n  private Recipe recipe;\n\n  @Override\n  public Menu shallowCopy(Menu menu) {\n    Menu copyMenu = new Menu(menu.getName(), menu.getPrice(), menu.getRecipe());\n    return copyMenu;\n  }\n}\n```\n불변 객체에 대해서는 같은 객체를 공유한다는 점에서 메모리에 대한 비용을 아낄 수 있다는 장점이 있고, deep copy보다는 빠르다.\n\n하지만, 가변 객체에 대해서는 원본 객체의 Recipe 객체가 변경되는 경우 의도치 않게 복사한 Recipe도 변경되는 경우가 발생한다.  \n이런 경우에는 Deep Copy를 통해 완전히 분리를 시켜줘야 한다.\n\n\n# Deep Copy\nDeep Copy 원본 객체의 타입을 바탕으로 새로운 객체를 생성한 뒤, 내부 필드가 참조하는 객체에 대해서도 새로운 객체를 만들어 주는 방식이다.\n\n```java\n@NoArgsConstructor\n@AllArgsConstructor\n@Getter\n@Setter\npublic class Menu implements Copyable<Menu> {\n\n  private String name;\n  private int price;\n  private Recipe recipe;\n\n  @Override\n  public Menu deepCopy(Menu menu) {\n    Menu copyMenu = new Menu();\n    copyMenu.setName(new String(menu.getName));\n    copyMenu.setPrice(menu.getPrice());\n    copyMenu.setRecipe(Recipe.deepCopy(menu.getRecipe));\n    return copyMenu;\n  }\n}\n```\n\n위와 같이 필드에 대해 원본객체와 같은 reference를 사용하는 것이 아닌 필드의 reference에 대해서도 새로운 객체를 생성하여 복사하는 방식이다.  \n\n이런 경우 가변객체에 대한 변경에는 안전하다는 장점이 있다.  \n서로 다른 객체를 다루기 떄문에 안전하다.  \n\n하지만 객체 생성 비용이 shallow copy보다 비싸고 상대적으로 느리며, \ncopy하는 객체 수가 많을 수록 메모리를 많이 점유하게 된다는 단점이 있다.\n\n\n","source":"_posts/java-object-copy.md","raw":"---\ntitle: Shallow Copy와 Deep Copy\ncatalog: true\nCategories:\n  - Java\ntags:\n  - Java\n  - Effective-Java\ntypora-root-url: java-object-copy\ntypora-copy-images-to: java-object-copy\ndate: 2019-01-13 18:59:09\nsubtitle:\nheader-img:\n---\n\n# 객체의 복사(Copy)\n객체 지향 프로그래밍에서 객체를 복사하는 방법은 크게 두가지로 나뉜다.  \n얇은 복사(Shallow Copy)와 깊은 복사(Deep Copy)가 있다.  \n두가지 개념 모두 원본 객체를 바탕으로 새로운 객체를 만들어 낸다는 점에서는 같지만 미묘한 차이가 있다.\n\n설명을 진행하기 전에 아래와 같은 Interface를 구현한 객체에 대해 copy가 진행된다고 가정하겠다.\n```java\npublic interface Copyable<T> {\n   T shallowCopy(T t);\n   T deepCopy(T t);\n}\n```\n\n\n\n![clone](./clone.jpg)\n\n\n\n# Shallow Copy\n\nShallow copy란 원본 객체를 바탕으로 새로운 객체를 생성한 뒤, 내부 필드의 참조에 대해서는 원본 객체와 같은 필드의 참조를 바라보는 형태이다.\n\n```java\n@NoArgsConstructor\n@AllArgsConstructor\n@Getter\npublic class Menu implements Copyable<Menu> {\n\n  private String name;\n  private int price;\n  private Recipe recipe;\n\n  @Override\n  public Menu shallowCopy(Menu menu) {\n    Menu copyMenu = new Menu(menu.getName(), menu.getPrice(), menu.getRecipe());\n    return copyMenu;\n  }\n}\n```\n불변 객체에 대해서는 같은 객체를 공유한다는 점에서 메모리에 대한 비용을 아낄 수 있다는 장점이 있고, deep copy보다는 빠르다.\n\n하지만, 가변 객체에 대해서는 원본 객체의 Recipe 객체가 변경되는 경우 의도치 않게 복사한 Recipe도 변경되는 경우가 발생한다.  \n이런 경우에는 Deep Copy를 통해 완전히 분리를 시켜줘야 한다.\n\n\n# Deep Copy\nDeep Copy 원본 객체의 타입을 바탕으로 새로운 객체를 생성한 뒤, 내부 필드가 참조하는 객체에 대해서도 새로운 객체를 만들어 주는 방식이다.\n\n```java\n@NoArgsConstructor\n@AllArgsConstructor\n@Getter\n@Setter\npublic class Menu implements Copyable<Menu> {\n\n  private String name;\n  private int price;\n  private Recipe recipe;\n\n  @Override\n  public Menu deepCopy(Menu menu) {\n    Menu copyMenu = new Menu();\n    copyMenu.setName(new String(menu.getName));\n    copyMenu.setPrice(menu.getPrice());\n    copyMenu.setRecipe(Recipe.deepCopy(menu.getRecipe));\n    return copyMenu;\n  }\n}\n```\n\n위와 같이 필드에 대해 원본객체와 같은 reference를 사용하는 것이 아닌 필드의 reference에 대해서도 새로운 객체를 생성하여 복사하는 방식이다.  \n\n이런 경우 가변객체에 대한 변경에는 안전하다는 장점이 있다.  \n서로 다른 객체를 다루기 떄문에 안전하다.  \n\n하지만 객체 생성 비용이 shallow copy보다 비싸고 상대적으로 느리며, \ncopy하는 객체 수가 많을 수록 메모리를 많이 점유하게 된다는 단점이 있다.\n\n\n","slug":"java-object-copy","published":1,"updated":"2019-01-13T11:38:31.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv2sf001kcr1this05zxz","content":"<h1 id=\"객체의-복사copy\">객체의 복사(Copy)</h1>\n<p>객체 지향 프로그래밍에서 객체를 복사하는 방법은 크게 두가지로 나뉜다.<br>\n얇은 복사(Shallow Copy)와 깊은 복사(Deep Copy)가 있다.<br>\n두가지 개념 모두 원본 객체를 바탕으로 새로운 객체를 만들어 낸다는 점에서는 같지만 미묘한 차이가 있다.</p>\n<p>설명을 진행하기 전에 아래와 같은 Interface를 구현한 객체에 대해 copy가 진행된다고 가정하겠다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Copyable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">   <span class=\"function\">T <span class=\"title\">shallowCopy</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">   <span class=\"function\">T <span class=\"title\">deepCopy</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./clone.jpg\" alt=\"clone\"></p>\n<h1 id=\"shallow-copy\">Shallow Copy</h1>\n<p>Shallow copy란 원본 객체를 바탕으로 새로운 객체를 생성한 뒤, 내부 필드의 참조에 대해서는 원본 객체와 같은 필드의 참조를 바라보는 형태이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Menu</span> <span class=\"keyword\">implements</span> <span class=\"title\">Copyable</span>&lt;<span class=\"title\">Menu</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> price;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Recipe recipe;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Menu <span class=\"title\">shallowCopy</span><span class=\"params\">(Menu menu)</span> </span>&#123;</span><br><span class=\"line\">    Menu copyMenu = <span class=\"keyword\">new</span> Menu(menu.getName(), menu.getPrice(), menu.getRecipe());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copyMenu;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>불변 객체에 대해서는 같은 객체를 공유한다는 점에서 메모리에 대한 비용을 아낄 수 있다는 장점이 있고, deep copy보다는 빠르다.</p>\n<p>하지만, 가변 객체에 대해서는 원본 객체의 Recipe 객체가 변경되는 경우 의도치 않게 복사한 Recipe도 변경되는 경우가 발생한다.<br>\n이런 경우에는 Deep Copy를 통해 완전히 분리를 시켜줘야 한다.</p>\n<h1 id=\"deep-copy\">Deep Copy</h1>\n<p>Deep Copy 원본 객체의 타입을 바탕으로 새로운 객체를 생성한 뒤, 내부 필드가 참조하는 객체에 대해서도 새로운 객체를 만들어 주는 방식이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Menu</span> <span class=\"keyword\">implements</span> <span class=\"title\">Copyable</span>&lt;<span class=\"title\">Menu</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> price;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Recipe recipe;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Menu <span class=\"title\">deepCopy</span><span class=\"params\">(Menu menu)</span> </span>&#123;</span><br><span class=\"line\">    Menu copyMenu = <span class=\"keyword\">new</span> Menu();</span><br><span class=\"line\">    copyMenu.setName(<span class=\"keyword\">new</span> String(menu.getName));</span><br><span class=\"line\">    copyMenu.setPrice(menu.getPrice());</span><br><span class=\"line\">    copyMenu.setRecipe(Recipe.deepCopy(menu.getRecipe));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copyMenu;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위와 같이 필드에 대해 원본객체와 같은 reference를 사용하는 것이 아닌 필드의 reference에 대해서도 새로운 객체를 생성하여 복사하는 방식이다.</p>\n<p>이런 경우 가변객체에 대한 변경에는 안전하다는 장점이 있다.<br>\n서로 다른 객체를 다루기 떄문에 안전하다.</p>\n<p>하지만 객체 생성 비용이 shallow copy보다 비싸고 상대적으로 느리며,\ncopy하는 객체 수가 많을 수록 메모리를 많이 점유하게 된다는 단점이 있다.</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>객체의 복사(Copy)</h1>\n<p>객체 지향 프로그래밍에서 객체를 복사하는 방법은 크게 두가지로 나뉜다.<br>\n얇은 복사(Shallow Copy)와 깊은 복사(Deep Copy)가 있다.<br>\n두가지 개념 모두 원본 객체를 바탕으로 새로운 객체를 만들어 낸다는 점에서는 같지만 미묘한 차이가 있다.</p>\n<p>설명을 진행하기 전에 아래와 같은 Interface를 구현한 객체에 대해 copy가 진행된다고 가정하겠다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Copyable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">   <span class=\"function\">T <span class=\"title\">shallowCopy</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">   <span class=\"function\">T <span class=\"title\">deepCopy</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./clone.jpg\" alt=\"clone\"></p>\n<h1>Shallow Copy</h1>\n<p>Shallow copy란 원본 객체를 바탕으로 새로운 객체를 생성한 뒤, 내부 필드의 참조에 대해서는 원본 객체와 같은 필드의 참조를 바라보는 형태이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Menu</span> <span class=\"keyword\">implements</span> <span class=\"title\">Copyable</span>&lt;<span class=\"title\">Menu</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> price;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Recipe recipe;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Menu <span class=\"title\">shallowCopy</span><span class=\"params\">(Menu menu)</span> </span>&#123;</span><br><span class=\"line\">    Menu copyMenu = <span class=\"keyword\">new</span> Menu(menu.getName(), menu.getPrice(), menu.getRecipe());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copyMenu;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>불변 객체에 대해서는 같은 객체를 공유한다는 점에서 메모리에 대한 비용을 아낄 수 있다는 장점이 있고, deep copy보다는 빠르다.</p>\n<p>하지만, 가변 객체에 대해서는 원본 객체의 Recipe 객체가 변경되는 경우 의도치 않게 복사한 Recipe도 변경되는 경우가 발생한다.<br>\n이런 경우에는 Deep Copy를 통해 완전히 분리를 시켜줘야 한다.</p>\n<h1>Deep Copy</h1>\n<p>Deep Copy 원본 객체의 타입을 바탕으로 새로운 객체를 생성한 뒤, 내부 필드가 참조하는 객체에 대해서도 새로운 객체를 만들어 주는 방식이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Menu</span> <span class=\"keyword\">implements</span> <span class=\"title\">Copyable</span>&lt;<span class=\"title\">Menu</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> price;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Recipe recipe;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Menu <span class=\"title\">deepCopy</span><span class=\"params\">(Menu menu)</span> </span>&#123;</span><br><span class=\"line\">    Menu copyMenu = <span class=\"keyword\">new</span> Menu();</span><br><span class=\"line\">    copyMenu.setName(<span class=\"keyword\">new</span> String(menu.getName));</span><br><span class=\"line\">    copyMenu.setPrice(menu.getPrice());</span><br><span class=\"line\">    copyMenu.setRecipe(Recipe.deepCopy(menu.getRecipe));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copyMenu;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위와 같이 필드에 대해 원본객체와 같은 reference를 사용하는 것이 아닌 필드의 reference에 대해서도 새로운 객체를 생성하여 복사하는 방식이다.</p>\n<p>이런 경우 가변객체에 대한 변경에는 안전하다는 장점이 있다.<br>\n서로 다른 객체를 다루기 떄문에 안전하다.</p>\n<p>하지만 객체 생성 비용이 shallow copy보다 비싸고 상대적으로 느리며,\ncopy하는 객체 수가 많을 수록 메모리를 많이 점유하게 된다는 단점이 있다.</p>\n"},{"layout":"post","title":"Spring AOP (3)","subtitle":"3. Spring AOP","date":"2018-07-21T03:52:33.000Z","background":"/img/posts/06.jpg","_content":"\n앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.\n\n이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.\n\n\n\n# Spring AOP\n\nAOP란 `횡단 관심사 (Cross Cutting Concern)` 을 한데 모아 로직을 설계한다음\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다. \n\n이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.\n\n\n\n# Proxy란?\n\n![Proxy구성도](https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336)\n\n\n\n> Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.\n>\n> 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.\n>\n> 토비의 스프링 vol.1 (p. 430)\n\n\n\n토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다. \n\nSpring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.\n\n\n\n> OCP (Open-Close Principal : 개방 폐쇄의 원칙)\n>\n> **개방-폐쇄 원칙**(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.  \n\n실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.\n\n\n\n# Proxy vs Proxy Pattern\n\n일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.\n비슷한 개념이지만, 내용이 조금 다르다.\n\n일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.\n\nProxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.\n\n\n\n# JDK Dynamic Proxy\n\n![JDK Dynamic Proxy](https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif)\n\n\n\nJDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다. \n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다. \n\n내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.\n\n~~~java\npublic class ExamDynamicHandler implements InvocationHandler {\n    private ExamInterface target; // 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용\n     \n    public ExamDynamicHandler(ExamInterface target) {\n        this.target = target;\n    }\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args)\n            throws Throwable {\n        // TODO Auto-generated method stub\n        // 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용\n        String ret = (String)method.invoke(target, args); //타입 Safe하지 않는 단점이 있다.\n        return ret.toUpperCase(); //메소드 기능에 대한 확장\n    }\n}\n~~~\n\n\n\n# CGLIB Proxy\n\nCGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다. \n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.\n\n하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다. \n\nCGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.\n\n![CGLIB Proxy](http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png)\n\n\n\n* CGLIB Proxy 설정법\n\n* ~~~yaml\n  spring.aop.proxy-target-class=false\n  ~~~\n\n  ~~~xml\n  <aop:config proxy-target-class=\"true\">\n  </aop:config>\n  <aop:aspectj-autoproxy proxy-target-class=\"true\"/> <!-- AspectJ를 사용하는 경우 -->\n  ~~~\n\n  ~~~java\n  //AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다\n  @EnableAsync(proxyTargetClass = true)\n  @EnableCaching(proxyTargetClass = true) \n  ~~~\n\n\n\n# Spring Bean에 대한 Proxy는?\n\nSpring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데.. 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?\n\n![00.png](https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png)\n\n\n\nSpring에서는 `자동 프록시 생성기` 라는 것이 있다.\n\n빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  `DefaultAdvisorAutoProxyCreator` 라는 클래스를 사용한다. \n이 클래스는 어드바이저를 이용한 `자동 프록시 생성기` 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.\n\nDefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.\n\n1. 후처리기는 `빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해` 전달받은 빈이 프록시 적용 대상인지 확인한다.\n2. 프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 `프록시를 생성하고 어드바이저를 연결한다.`\n3. 프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.\n4. 컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.\n\n이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.\n\n \n\n# 요약..\n\n* Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.\n* Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n  * JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)\n  * CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)\n    따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)\n* Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.\n  (그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)\n\n\n\n# 참고\n\n토비의 스프링 vol.1\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttps://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99","source":"_posts/2018-07-21-spring-aop3.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (3)\"\nsubtitle: \"3. Spring AOP\"\ndate:   2018-07-21 12:52:33 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.\n\n이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.\n\n\n\n# Spring AOP\n\nAOP란 `횡단 관심사 (Cross Cutting Concern)` 을 한데 모아 로직을 설계한다음\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다. \n\n이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.\n\n\n\n# Proxy란?\n\n![Proxy구성도](https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336)\n\n\n\n> Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.\n>\n> 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.\n>\n> 토비의 스프링 vol.1 (p. 430)\n\n\n\n토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다. \n\nSpring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.\n\n\n\n> OCP (Open-Close Principal : 개방 폐쇄의 원칙)\n>\n> **개방-폐쇄 원칙**(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.  \n\n실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.\n\n\n\n# Proxy vs Proxy Pattern\n\n일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.\n비슷한 개념이지만, 내용이 조금 다르다.\n\n일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.\n\nProxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.\n\n\n\n# JDK Dynamic Proxy\n\n![JDK Dynamic Proxy](https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif)\n\n\n\nJDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다. \n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다. \n\n내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.\n\n~~~java\npublic class ExamDynamicHandler implements InvocationHandler {\n    private ExamInterface target; // 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용\n     \n    public ExamDynamicHandler(ExamInterface target) {\n        this.target = target;\n    }\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args)\n            throws Throwable {\n        // TODO Auto-generated method stub\n        // 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용\n        String ret = (String)method.invoke(target, args); //타입 Safe하지 않는 단점이 있다.\n        return ret.toUpperCase(); //메소드 기능에 대한 확장\n    }\n}\n~~~\n\n\n\n# CGLIB Proxy\n\nCGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다. \n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.\n\n하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다. \n\nCGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.\n\n![CGLIB Proxy](http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png)\n\n\n\n* CGLIB Proxy 설정법\n\n* ~~~yaml\n  spring.aop.proxy-target-class=false\n  ~~~\n\n  ~~~xml\n  <aop:config proxy-target-class=\"true\">\n  </aop:config>\n  <aop:aspectj-autoproxy proxy-target-class=\"true\"/> <!-- AspectJ를 사용하는 경우 -->\n  ~~~\n\n  ~~~java\n  //AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다\n  @EnableAsync(proxyTargetClass = true)\n  @EnableCaching(proxyTargetClass = true) \n  ~~~\n\n\n\n# Spring Bean에 대한 Proxy는?\n\nSpring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데.. 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?\n\n![00.png](https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png)\n\n\n\nSpring에서는 `자동 프록시 생성기` 라는 것이 있다.\n\n빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  `DefaultAdvisorAutoProxyCreator` 라는 클래스를 사용한다. \n이 클래스는 어드바이저를 이용한 `자동 프록시 생성기` 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.\n\nDefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.\n\n1. 후처리기는 `빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해` 전달받은 빈이 프록시 적용 대상인지 확인한다.\n2. 프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 `프록시를 생성하고 어드바이저를 연결한다.`\n3. 프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.\n4. 컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.\n\n이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.\n\n \n\n# 요약..\n\n* Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.\n* Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n  * JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)\n  * CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)\n    따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)\n* Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.\n  (그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)\n\n\n\n# 참고\n\n토비의 스프링 vol.1\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttps://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99","slug":"2018-07-21-spring-aop3","published":1,"updated":"2018-11-27T07:23:32.353Z","comments":1,"photos":[],"link":"","_id":"cjrgbv3ra002pcr1tbtpf7ypb","content":"<p>앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.</p>\n<p>이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.</p>\n<h1 id=\"spring-aop\">Spring AOP</h1>\n<p>AOP란 <code>횡단 관심사 (Cross Cutting Concern)</code> 을 한데 모아 로직을 설계한다음\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다.</p>\n<p>이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.</p>\n<h1 id=\"proxy란\">Proxy란?</h1>\n<p><img src=\"https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336\" alt=\"Proxy구성도\"></p>\n<blockquote>\n<p>Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.</p>\n<p>그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.</p>\n<p>토비의 스프링 vol.1 (p. 430)</p>\n</blockquote>\n<p>토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다.</p>\n<p>Spring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.</p>\n<blockquote>\n<p>OCP (Open-Close Principal : 개방 폐쇄의 원칙)</p>\n<p><strong>개방-폐쇄 원칙</strong>(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.</p>\n</blockquote>\n<p>실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.</p>\n<h1 id=\"proxy-vs-proxy-pattern\">Proxy vs Proxy Pattern</h1>\n<p>일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.\n비슷한 개념이지만, 내용이 조금 다르다.</p>\n<p>일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.</p>\n<p>Proxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.</p>\n<h1 id=\"jdk-dynamic-proxy\">JDK Dynamic Proxy</h1>\n<p><img src=\"https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif\" alt=\"JDK Dynamic Proxy\"></p>\n<p>JDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다.\n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다.</p>\n<p>내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExamDynamicHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExamInterface target; <span class=\"comment\">// 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExamDynamicHandler</span><span class=\"params\">(ExamInterface target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        <span class=\"comment\">// 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용</span></span><br><span class=\"line\">        String ret = (String)method.invoke(target, args); <span class=\"comment\">//타입 Safe하지 않는 단점이 있다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret.toUpperCase(); <span class=\"comment\">//메소드 기능에 대한 확장</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"cglib-proxy\">CGLIB Proxy</h1>\n<p>CGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다.\n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.</p>\n<p>하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다.</p>\n<p>CGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.</p>\n<p><img src=\"http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png\" alt=\"CGLIB Proxy\"></p>\n<ul>\n<li>\n<p>CGLIB Proxy 설정법</p>\n</li>\n<li>\n<p><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.aop.proxy-target-class=false</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>/&gt;</span> <span class=\"comment\">&lt;!-- AspectJ를 사용하는 경우 --&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAsync</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h1 id=\"spring-bean에-대한-proxy는\">Spring Bean에 대한 Proxy는?</h1>\n<p>Spring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데.. 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?</p>\n<p><img src=\"https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png\" alt=\"00.png\"></p>\n<p>Spring에서는 <code>자동 프록시 생성기</code> 라는 것이 있다.</p>\n<p>빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  <code>DefaultAdvisorAutoProxyCreator</code> 라는 클래스를 사용한다.\n이 클래스는 어드바이저를 이용한 <code>자동 프록시 생성기</code> 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.</p>\n<p>DefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.</p>\n<ol>\n<li>후처리기는 <code>빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해</code> 전달받은 빈이 프록시 적용 대상인지 확인한다.</li>\n<li>프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 <code>프록시를 생성하고 어드바이저를 연결한다.</code></li>\n<li>프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.</li>\n<li>컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.</li>\n</ol>\n<p>이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.</p>\n<h1 id=\"요약\">요약..</h1>\n<ul>\n<li>Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.</li>\n<li>Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n<ul>\n<li>JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)</li>\n<li>CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)\n따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)</li>\n</ul>\n</li>\n<li>Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.\n(그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)</li>\n</ul>\n<h1 id=\"참고\">참고</h1>\n<p>토비의 스프링 vol.1</p>\n<p>http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</p>\n<p>https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<p>앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.</p>\n<p>이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.</p>\n<h1>Spring AOP</h1>\n<p>AOP란 <code>횡단 관심사 (Cross Cutting Concern)</code> 을 한데 모아 로직을 설계한다음\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다.</p>\n<p>이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.</p>\n<h1>Proxy란?</h1>\n<p><img src=\"https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336\" alt=\"Proxy구성도\"></p>\n<blockquote>\n<p>Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.</p>\n<p>그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.</p>\n<p>토비의 스프링 vol.1 (p. 430)</p>\n</blockquote>\n<p>토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다.</p>\n<p>Spring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.</p>\n<blockquote>\n<p>OCP (Open-Close Principal : 개방 폐쇄의 원칙)</p>\n<p><strong>개방-폐쇄 원칙</strong>(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.</p>\n</blockquote>\n<p>실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.</p>\n<h1>Proxy vs Proxy Pattern</h1>\n<p>일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.\n비슷한 개념이지만, 내용이 조금 다르다.</p>\n<p>일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.</p>\n<p>Proxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.</p>\n<h1>JDK Dynamic Proxy</h1>\n<p><img src=\"https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif\" alt=\"JDK Dynamic Proxy\"></p>\n<p>JDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다.\n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다.</p>\n<p>내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExamDynamicHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExamInterface target; <span class=\"comment\">// 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExamDynamicHandler</span><span class=\"params\">(ExamInterface target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        <span class=\"comment\">// 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용</span></span><br><span class=\"line\">        String ret = (String)method.invoke(target, args); <span class=\"comment\">//타입 Safe하지 않는 단점이 있다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret.toUpperCase(); <span class=\"comment\">//메소드 기능에 대한 확장</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>CGLIB Proxy</h1>\n<p>CGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다.\n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.</p>\n<p>하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다.</p>\n<p>CGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.</p>\n<p><img src=\"http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png\" alt=\"CGLIB Proxy\"></p>\n<ul>\n<li>\n<p>CGLIB Proxy 설정법</p>\n</li>\n<li>\n<p><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.aop.proxy-target-class=false</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>/&gt;</span> <span class=\"comment\">&lt;!-- AspectJ를 사용하는 경우 --&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAsync</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h1>Spring Bean에 대한 Proxy는?</h1>\n<p>Spring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데.. 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?</p>\n<p><img src=\"https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png\" alt=\"00.png\"></p>\n<p>Spring에서는 <code>자동 프록시 생성기</code> 라는 것이 있다.</p>\n<p>빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  <code>DefaultAdvisorAutoProxyCreator</code> 라는 클래스를 사용한다.\n이 클래스는 어드바이저를 이용한 <code>자동 프록시 생성기</code> 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.</p>\n<p>DefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.</p>\n<ol>\n<li>후처리기는 <code>빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해</code> 전달받은 빈이 프록시 적용 대상인지 확인한다.</li>\n<li>프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 <code>프록시를 생성하고 어드바이저를 연결한다.</code></li>\n<li>프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.</li>\n<li>컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.</li>\n</ol>\n<p>이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.</p>\n<h1>요약..</h1>\n<ul>\n<li>Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.</li>\n<li>Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n<ul>\n<li>JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)</li>\n<li>CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)\n따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)</li>\n</ul>\n</li>\n<li>Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.\n(그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)</li>\n</ul>\n<h1>참고</h1>\n<p>토비의 스프링 vol.1</p>\n<p>http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</p>\n<p>https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99</p>\n"},{"layout":"post","title":"Spring AOP (4)","subtitle":"4. AspectJ","date":"2018-07-22T03:52:33.000Z","background":"/img/posts/06.jpg","_content":"\n# AspectJ란?\n\n> AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.\n\nAspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, `CTW, LTW`과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.\n\n\n\n> Aspect란?\n>\n> Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.\n> 그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.\n> 구조적으로 보자면 Aspect = PointCut + Advisor이다.\n\n \n\n# 위빙 Weaving\n\n위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.\n\n\n\n##런타임 시, 위빙 (RTW: Runtime Weaving)\n\nSpring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.\n\n![Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw)\n\n\n\n\n\n\n\n## 컴파일 시, 위빙 (CTW: Compile time Weaving)\n\nAspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)\n\n\n\n### CTW를 사용하기 위한 메이븐 설정\n\n**라이브러리 추가:** (pom.xml)\n\n```xml\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjrt</artifactId>\n    <version>1.8.6</version>\n    <scope>runtime</scope>\n</dependency>\n \n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjtools</artifactId>\n    <version>1.8.6</version>\n</dependency> \n```\n\n**플러그인 설정:** (pom.xml)\n\n```xml\n<plugin>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>aspectj-maven-plugin</artifactId>\n    <version>1.7</version>\n    <configuration>\n        <showWeaveInfo>true</showWeaveInfo>\n            <source>${aspectj-compiler.version}</source>\n            <target>${aspectj-compiler.version}</target>\n            <verbose>true</verbose>\n            <complianceLevel>${aspectj-compiler.version}</complianceLevel>\n            <outxml>true</outxml>\n    </configuration>\n    <executions>\n        <execution>\n            <goals>\n                <goal>compile</goal>\n                <goal>test-compile</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n*(\\*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)*\n\n위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용 \n\nAspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용\n\n\n\n## 클래스 로드 시, 위빙 (LTW: Load time Weaving)\n\n ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.\n\n그리고 설정이 가장 복잡하지 않은가 싶다..\n\n아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.\n\n~~~xml\n<context:load-time-weaver/> <!-- 스프링 설정 파일에 추가 servlet.xml -->\n~~~\n\n~~~java\n@EnableLoadTimeWeaving //Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.\n~~~\n\n~~~vm\n//IDE에서 개발 시, 해당 설정을 추가\n-javaagent:/fullpath/aspectjweaver-1.8.1.jar \n-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar \n~~~\n\n~~~\n//톰캣 시작 시, jvmargs 옵션에 추가\n-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar\n~~~\n\n\n\n# Annotations\n\n## JoinPoint 관련 Annotations\n\n공통적으로 pointcut에 대한 표현식을 인자로 받는다.\n\n* @Before\n  * 메소드 실행 이전 부분에 대한 Joinpoint 설정\n* @Around\n  * ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.\n  * 메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.\n* @After\n  * 메소드 실행 이후 부분의 대한 Joinpoint 설정\n* @AfterReturning\n  * 메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정\n* @AfterThrowable\n  * 메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정\n\n\n\n## Pointcut 관련 Annotation\n\n* @Pointcut\n  * Pointcut에 대한 표현식을 값으로 가짐\n  * @Pointcut이 적용된 메소드는 무조건 리턴타입이 void\n\n\n\n\n\n# Point Cut\n\n포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.\n\n![pointcut 개념](https://t1.daumcdn.net/cfile/tistory/223B623D548C415631)\n\n\n\n## 포인트 컷 표현식\n\nExpression을 이용한 pointcut 표현식\n\n![pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg)\n\n\n\n1. 접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)\n   * \\* 인 경우 모든 접근제어자에 대해 설정 가능\n   * 생략 시, \\* 과 같은 효과\n\n2. 리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)\n   * 필수 적으로 기재해야 한다.\n   * \\* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.\n3. Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)\n   * 단, 패키지 명도 기재해야 함 \n   * com.springframework.aop.. 처럼 ..으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리\n   * 필수 적으로 기재해야 한다.\n4. 메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * 모든 메소드에 적용 하려면 \\* 을 사용\n5. 파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * ,로 구분하여 순서대로 파라미터를 기재한다.\n   * 타입과 갯수에 상관없다면 .. 또는 \\* 를 기재한다.\n6. 예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)\n\n\n\n## 예시\n\n- **execution(int minus(int, int))**: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(int, int))**: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(..))**: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드\n\n- **execution(\\* *(..))**: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드\n\n- **execution(\\* *())**: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드\n\n- **execution(\\* springbook.aop.Target.*(..))**: springbook.aop.Target 클래스의 모든 메소드\n\n- **execution(\\* springbook.aop.*.*(..))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.\n\n- **execution(\\* springbook.aop..*.*(..))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함\n\n- **execution(\\* *..Target.*(..))**: 패키지에는 상관없이 Target 클래스의 모든 메소드\n\n- **execution(* *(..) throws Exception) **: Exception을 throw하는 모든 메소드\n\n- **within(com.springbook.aop.service.***) : service 패키지 내의 모든 Joinpoint\n\n- **within(com.springbook.aop.service..***) : service 패키지의 하위패키지 내의 모든 Joinpoint\n\n- **this(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint\n\n- **target(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint\n\n- **args(java.utils.List)** : 파라미터가 1개이고 List타입인 모든 Joinpoint\n\n- **@target(org.springframework.transaction.annotation.Transactional)** :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@within(org.springframework.transaction.annotation.Transactional)** : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@annotation(org.springframework.transaction.annotation.Transactional)** : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점\n\n* **@args(com.xyz.security.Classified)** : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점\n\n* **bean(UserRepository)** : “UserRepository” 빈\n\n* **!bean(UserRepository)** :  “UserRepository” 빈을 제외한 모든 빈\n\n* **bean(*)** : 모든 빈\n\n* **bean(user*)** : 이름이 'user'로 시작되는 모든 빈\n\n* **bean(*Repository)** : 이름이 “Repository”로 끝나는 모든 빈\n\n* **bean(user/*)** : 이름이 “user/“로 시작하는 모든 빈\n\n* **bean(*dataSource) || bean(*DataSource)** : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈\n\n \n\n# 예시코드\n\n## Aspect 파일 사용\n\n~~~java\npublic aspect TestAdvisor {\n    pointcut advicePoint() : execution(* com.example.advice..*(..));\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n    \n    //order는 어떻게 주는건지 모르겠다.\n}\n~~~\n\n\n\n## @Aspect 어노테이션 사용\n\n~~~java\n@Aspect\npublic class TestAdvisor {\n    \n    /**\n    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut\n    */\n    @Pointcut(\"execution(* com.example.advice..*(..))\")\n    public void pointcut(){\n        \n    }\n    \n    @order(2) //order가 높은 순으로 먼저 실행\n    @After(pointcut=\"pointcut()\")\n    public void afterAdvice(Joinpoint joinpoint) {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    @order(1)\n    @After(pointcut=\"pointcut()\")\n    public void showLog(Joinpoint joinpoint) {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n}\n~~~\n\n\n\n\n\n# 참고\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220564638014\n\nhttp://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\n\nhttps://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5","source":"_posts/2018-07-22-spring-aop4.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (4)\"\nsubtitle: \"4. AspectJ\"\ndate:   2018-07-22 12:52:33 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n# AspectJ란?\n\n> AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.\n\nAspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, `CTW, LTW`과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.\n\n\n\n> Aspect란?\n>\n> Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.\n> 그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.\n> 구조적으로 보자면 Aspect = PointCut + Advisor이다.\n\n \n\n# 위빙 Weaving\n\n위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.\n\n\n\n##런타임 시, 위빙 (RTW: Runtime Weaving)\n\nSpring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.\n\n![Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw)\n\n\n\n\n\n\n\n## 컴파일 시, 위빙 (CTW: Compile time Weaving)\n\nAspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)\n\n\n\n### CTW를 사용하기 위한 메이븐 설정\n\n**라이브러리 추가:** (pom.xml)\n\n```xml\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjrt</artifactId>\n    <version>1.8.6</version>\n    <scope>runtime</scope>\n</dependency>\n \n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjtools</artifactId>\n    <version>1.8.6</version>\n</dependency> \n```\n\n**플러그인 설정:** (pom.xml)\n\n```xml\n<plugin>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>aspectj-maven-plugin</artifactId>\n    <version>1.7</version>\n    <configuration>\n        <showWeaveInfo>true</showWeaveInfo>\n            <source>${aspectj-compiler.version}</source>\n            <target>${aspectj-compiler.version}</target>\n            <verbose>true</verbose>\n            <complianceLevel>${aspectj-compiler.version}</complianceLevel>\n            <outxml>true</outxml>\n    </configuration>\n    <executions>\n        <execution>\n            <goals>\n                <goal>compile</goal>\n                <goal>test-compile</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n*(\\*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)*\n\n위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용 \n\nAspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용\n\n\n\n## 클래스 로드 시, 위빙 (LTW: Load time Weaving)\n\n ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.\n\n그리고 설정이 가장 복잡하지 않은가 싶다..\n\n아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.\n\n~~~xml\n<context:load-time-weaver/> <!-- 스프링 설정 파일에 추가 servlet.xml -->\n~~~\n\n~~~java\n@EnableLoadTimeWeaving //Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.\n~~~\n\n~~~vm\n//IDE에서 개발 시, 해당 설정을 추가\n-javaagent:/fullpath/aspectjweaver-1.8.1.jar \n-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar \n~~~\n\n~~~\n//톰캣 시작 시, jvmargs 옵션에 추가\n-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar\n~~~\n\n\n\n# Annotations\n\n## JoinPoint 관련 Annotations\n\n공통적으로 pointcut에 대한 표현식을 인자로 받는다.\n\n* @Before\n  * 메소드 실행 이전 부분에 대한 Joinpoint 설정\n* @Around\n  * ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.\n  * 메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.\n* @After\n  * 메소드 실행 이후 부분의 대한 Joinpoint 설정\n* @AfterReturning\n  * 메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정\n* @AfterThrowable\n  * 메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정\n\n\n\n## Pointcut 관련 Annotation\n\n* @Pointcut\n  * Pointcut에 대한 표현식을 값으로 가짐\n  * @Pointcut이 적용된 메소드는 무조건 리턴타입이 void\n\n\n\n\n\n# Point Cut\n\n포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.\n\n![pointcut 개념](https://t1.daumcdn.net/cfile/tistory/223B623D548C415631)\n\n\n\n## 포인트 컷 표현식\n\nExpression을 이용한 pointcut 표현식\n\n![pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg)\n\n\n\n1. 접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)\n   * \\* 인 경우 모든 접근제어자에 대해 설정 가능\n   * 생략 시, \\* 과 같은 효과\n\n2. 리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)\n   * 필수 적으로 기재해야 한다.\n   * \\* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.\n3. Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)\n   * 단, 패키지 명도 기재해야 함 \n   * com.springframework.aop.. 처럼 ..으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리\n   * 필수 적으로 기재해야 한다.\n4. 메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * 모든 메소드에 적용 하려면 \\* 을 사용\n5. 파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * ,로 구분하여 순서대로 파라미터를 기재한다.\n   * 타입과 갯수에 상관없다면 .. 또는 \\* 를 기재한다.\n6. 예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)\n\n\n\n## 예시\n\n- **execution(int minus(int, int))**: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(int, int))**: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(..))**: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드\n\n- **execution(\\* *(..))**: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드\n\n- **execution(\\* *())**: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드\n\n- **execution(\\* springbook.aop.Target.*(..))**: springbook.aop.Target 클래스의 모든 메소드\n\n- **execution(\\* springbook.aop.*.*(..))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.\n\n- **execution(\\* springbook.aop..*.*(..))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함\n\n- **execution(\\* *..Target.*(..))**: 패키지에는 상관없이 Target 클래스의 모든 메소드\n\n- **execution(* *(..) throws Exception) **: Exception을 throw하는 모든 메소드\n\n- **within(com.springbook.aop.service.***) : service 패키지 내의 모든 Joinpoint\n\n- **within(com.springbook.aop.service..***) : service 패키지의 하위패키지 내의 모든 Joinpoint\n\n- **this(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint\n\n- **target(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint\n\n- **args(java.utils.List)** : 파라미터가 1개이고 List타입인 모든 Joinpoint\n\n- **@target(org.springframework.transaction.annotation.Transactional)** :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@within(org.springframework.transaction.annotation.Transactional)** : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@annotation(org.springframework.transaction.annotation.Transactional)** : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점\n\n* **@args(com.xyz.security.Classified)** : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점\n\n* **bean(UserRepository)** : “UserRepository” 빈\n\n* **!bean(UserRepository)** :  “UserRepository” 빈을 제외한 모든 빈\n\n* **bean(*)** : 모든 빈\n\n* **bean(user*)** : 이름이 'user'로 시작되는 모든 빈\n\n* **bean(*Repository)** : 이름이 “Repository”로 끝나는 모든 빈\n\n* **bean(user/*)** : 이름이 “user/“로 시작하는 모든 빈\n\n* **bean(*dataSource) || bean(*DataSource)** : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈\n\n \n\n# 예시코드\n\n## Aspect 파일 사용\n\n~~~java\npublic aspect TestAdvisor {\n    pointcut advicePoint() : execution(* com.example.advice..*(..));\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n    \n    //order는 어떻게 주는건지 모르겠다.\n}\n~~~\n\n\n\n## @Aspect 어노테이션 사용\n\n~~~java\n@Aspect\npublic class TestAdvisor {\n    \n    /**\n    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut\n    */\n    @Pointcut(\"execution(* com.example.advice..*(..))\")\n    public void pointcut(){\n        \n    }\n    \n    @order(2) //order가 높은 순으로 먼저 실행\n    @After(pointcut=\"pointcut()\")\n    public void afterAdvice(Joinpoint joinpoint) {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    @order(1)\n    @After(pointcut=\"pointcut()\")\n    public void showLog(Joinpoint joinpoint) {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n}\n~~~\n\n\n\n\n\n# 참고\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220564638014\n\nhttp://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\n\nhttps://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5","slug":"2018-07-22-spring-aop4","published":1,"updated":"2018-11-27T07:23:32.353Z","comments":1,"photos":[],"link":"","_id":"cjrgbv3rc002qcr1tnd4npbd4","content":"<h1 id=\"aspectj란\">AspectJ란?</h1>\n<blockquote>\n<p>AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.</p>\n</blockquote>\n<p>AspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, <code>CTW, LTW</code>과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.</p>\n<blockquote>\n<p>Aspect란?</p>\n<p>Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.\n그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.\n구조적으로 보자면 Aspect = PointCut + Advisor이다.</p>\n</blockquote>\n<h1 id=\"위빙-weaving\">위빙 Weaving</h1>\n<p>위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.</p>\n<p>##런타임 시, 위빙 (RTW: Runtime Weaving)</p>\n<p>Spring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.</p>\n<p><img src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw\" alt=\"Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<h2 id=\"컴파일-시-위빙-ctw-compile-time-weaving\">컴파일 시, 위빙 (CTW: Compile time Weaving)</h2>\n<p>AspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)</p>\n<h3 id=\"ctw를-사용하기-위한-메이븐-설정\">CTW를 사용하기 위한 메이븐 설정</h3>\n<p><strong>라이브러리 추가:</strong> (pom.xml)</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>플러그인 설정:</strong> (pom.xml)</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectj-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">showWeaveInfo</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">showWeaveInfo</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">verbose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">verbose</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">complianceLevel</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">complianceLevel</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outxml</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">outxml</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>test-compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><em>(*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)</em></p>\n<p>위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용</p>\n<p>AspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용</p>\n<h2 id=\"클래스-로드-시-위빙-ltw-load-time-weaving\">클래스 로드 시, 위빙 (LTW: Load time Weaving)</h2>\n<p>ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.</p>\n<p>그리고 설정이 가장 복잡하지 않은가 싶다..</p>\n<p>아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:load-time-weaver</span>/&gt;</span> <span class=\"comment\">&lt;!-- 스프링 설정 파일에 추가 servlet.xml --&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableLoadTimeWeaving</span> <span class=\"comment\">//Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//IDE에서 개발 시, 해당 설정을 추가</span><br><span class=\"line\">-javaagent:/fullpath/aspectjweaver-1.8.1.jar </span><br><span class=\"line\">-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//톰캣 시작 시, jvmargs 옵션에 추가</span><br><span class=\"line\">-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"annotations\">Annotations</h1>\n<h2 id=\"joinpoint-관련-annotations\">JoinPoint 관련 Annotations</h2>\n<p>공통적으로 pointcut에 대한 표현식을 인자로 받는다.</p>\n<ul>\n<li>@Before\n<ul>\n<li>메소드 실행 이전 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@Around\n<ul>\n<li>ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.</li>\n<li>메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.</li>\n</ul>\n</li>\n<li>@After\n<ul>\n<li>메소드 실행 이후 부분의 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterReturning\n<ul>\n<li>메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterThrowable\n<ul>\n<li>메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"pointcut-관련-annotation\">Pointcut 관련 Annotation</h2>\n<ul>\n<li>@Pointcut\n<ul>\n<li>Pointcut에 대한 표현식을 값으로 가짐</li>\n<li>@Pointcut이 적용된 메소드는 무조건 리턴타입이 void</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"point-cut\">Point Cut</h1>\n<p>포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/223B623D548C415631\" alt=\"pointcut 개념\"></p>\n<h2 id=\"포인트-컷-표현식\">포인트 컷 표현식</h2>\n<p>Expression을 이용한 pointcut 표현식</p>\n<p><img src=\"http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg\" alt=\"pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<ol>\n<li>\n<p>접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)</p>\n<ul>\n<li>* 인 경우 모든 접근제어자에 대해 설정 가능</li>\n<li>생략 시, * 과 같은 효과</li>\n</ul>\n</li>\n<li>\n<p>리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)</p>\n<ul>\n<li>단, 패키지 명도 기재해야 함</li>\n<li>com.springframework.aop.. 처럼 ..으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리</li>\n<li>필수 적으로 기재해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>모든 메소드에 적용 하려면 * 을 사용</li>\n</ul>\n</li>\n<li>\n<p>파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>,로 구분하여 순서대로 파라미터를 기재한다.</li>\n<li>타입과 갯수에 상관없다면 .. 또는 * 를 기재한다.</li>\n</ul>\n</li>\n<li>\n<p>예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)</p>\n</li>\n</ol>\n<h2 id=\"예시\">예시</h2>\n<ul>\n<li>\n<p><strong>execution(int minus(int, int))</strong>: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(int, int))</strong>: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(..))</strong>: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>(..))</em></em>: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>())</em></em>: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.Target.</em>(..))</em>*: springbook.aop.Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.</em>.</em>(..))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop..</em>.</em>(..))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함</p>\n</li>\n<li>\n<p><strong>execution(* <em>..Target.</em>(..))</strong>: 패키지에는 상관없이 Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(</em> *(..) throws Exception) **: Exception을 throw하는 모든 메소드</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service.</strong>*) : service 패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service..</strong>*) : service 패키지의 하위패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>this(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>target(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>args(java.utils.List)</strong> : 파라미터가 1개이고 List타입인 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>@target(org.springframework.transaction.annotation.Transactional)</strong> :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@within(org.springframework.transaction.annotation.Transactional)</strong> : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@annotation(org.springframework.transaction.annotation.Transactional)</strong> : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n</ul>\n<ul>\n<li>\n<p><strong>@args(com.xyz.security.Classified)</strong> : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>bean(UserRepository)</strong> : “UserRepository” 빈</p>\n</li>\n<li>\n<p><strong>!bean(UserRepository)</strong> :  “UserRepository” 빈을 제외한 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(</em>)</em>* : 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user</em>)</em>* : 이름이 'user'로 시작되는 모든 빈</p>\n</li>\n<li>\n<p>*<em>bean(<em>Repository)</em></em> : 이름이 “Repository”로 끝나는 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user/</em>)</em>* : 이름이 “user/“로 시작하는 모든 빈</p>\n</li>\n<li>\n<p>**bean(<em>dataSource) || bean(<em>DataSource)</em></em> : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈</p>\n</li>\n</ul>\n<h1 id=\"예시코드\">예시코드</h1>\n<h2 id=\"aspect-파일-사용\">Aspect 파일 사용</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> aspect TestAdvisor &#123;</span><br><span class=\"line\">    <span class=\"function\">pointcut <span class=\"title\">advicePoint</span><span class=\"params\">()</span> : <span class=\"title\">execution</span><span class=\"params\">(* com.example.advice..*(..)</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//order는 어떻게 주는건지 모르겠다.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"aspect-어노테이션-사용\">@Aspect 어노테이션 사용</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.example.advice..*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pointcut</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">2</span>) <span class=\"comment\">//order가 높은 순으로 먼저 실행</span></span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterAdvice</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showLog</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"참고\">참고</h1>\n<p>http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014</p>\n<p>http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9</p>\n<p>https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>AspectJ란?</h1>\n<blockquote>\n<p>AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.</p>\n</blockquote>\n<p>AspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, <code>CTW, LTW</code>과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.</p>\n<blockquote>\n<p>Aspect란?</p>\n<p>Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.\n그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.\n구조적으로 보자면 Aspect = PointCut + Advisor이다.</p>\n</blockquote>\n<h1>위빙 Weaving</h1>\n<p>위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.</p>\n<p>##런타임 시, 위빙 (RTW: Runtime Weaving)</p>\n<p>Spring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.</p>\n<p><img src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw\" alt=\"Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<h2>컴파일 시, 위빙 (CTW: Compile time Weaving)</h2>\n<p>AspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)</p>\n<h3>CTW를 사용하기 위한 메이븐 설정</h3>\n<p><strong>라이브러리 추가:</strong> (pom.xml)</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>플러그인 설정:</strong> (pom.xml)</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectj-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">showWeaveInfo</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">showWeaveInfo</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">verbose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">verbose</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">complianceLevel</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">complianceLevel</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outxml</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">outxml</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>test-compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><em>(*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)</em></p>\n<p>위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용</p>\n<p>AspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용</p>\n<h2>클래스 로드 시, 위빙 (LTW: Load time Weaving)</h2>\n<p>ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.</p>\n<p>그리고 설정이 가장 복잡하지 않은가 싶다..</p>\n<p>아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:load-time-weaver</span>/&gt;</span> <span class=\"comment\">&lt;!-- 스프링 설정 파일에 추가 servlet.xml --&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableLoadTimeWeaving</span> <span class=\"comment\">//Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//IDE에서 개발 시, 해당 설정을 추가</span><br><span class=\"line\">-javaagent:/fullpath/aspectjweaver-1.8.1.jar </span><br><span class=\"line\">-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//톰캣 시작 시, jvmargs 옵션에 추가</span><br><span class=\"line\">-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure></p>\n<h1>Annotations</h1>\n<h2>JoinPoint 관련 Annotations</h2>\n<p>공통적으로 pointcut에 대한 표현식을 인자로 받는다.</p>\n<ul>\n<li>@Before\n<ul>\n<li>메소드 실행 이전 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@Around\n<ul>\n<li>ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.</li>\n<li>메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.</li>\n</ul>\n</li>\n<li>@After\n<ul>\n<li>메소드 실행 이후 부분의 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterReturning\n<ul>\n<li>메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterThrowable\n<ul>\n<li>메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n</ul>\n<h2>Pointcut 관련 Annotation</h2>\n<ul>\n<li>@Pointcut\n<ul>\n<li>Pointcut에 대한 표현식을 값으로 가짐</li>\n<li>@Pointcut이 적용된 메소드는 무조건 리턴타입이 void</li>\n</ul>\n</li>\n</ul>\n<h1>Point Cut</h1>\n<p>포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/223B623D548C415631\" alt=\"pointcut 개념\"></p>\n<h2>포인트 컷 표현식</h2>\n<p>Expression을 이용한 pointcut 표현식</p>\n<p><img src=\"http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg\" alt=\"pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<ol>\n<li>\n<p>접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)</p>\n<ul>\n<li>* 인 경우 모든 접근제어자에 대해 설정 가능</li>\n<li>생략 시, * 과 같은 효과</li>\n</ul>\n</li>\n<li>\n<p>리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)</p>\n<ul>\n<li>단, 패키지 명도 기재해야 함</li>\n<li>com.springframework.aop.. 처럼 ..으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리</li>\n<li>필수 적으로 기재해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>모든 메소드에 적용 하려면 * 을 사용</li>\n</ul>\n</li>\n<li>\n<p>파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>,로 구분하여 순서대로 파라미터를 기재한다.</li>\n<li>타입과 갯수에 상관없다면 .. 또는 * 를 기재한다.</li>\n</ul>\n</li>\n<li>\n<p>예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)</p>\n</li>\n</ol>\n<h2>예시</h2>\n<ul>\n<li>\n<p><strong>execution(int minus(int, int))</strong>: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(int, int))</strong>: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(..))</strong>: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>(..))</em></em>: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>())</em></em>: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.Target.</em>(..))</em>*: springbook.aop.Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.</em>.</em>(..))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop..</em>.</em>(..))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함</p>\n</li>\n<li>\n<p><strong>execution(* <em>..Target.</em>(..))</strong>: 패키지에는 상관없이 Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(</em> *(..) throws Exception) **: Exception을 throw하는 모든 메소드</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service.</strong>*) : service 패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service..</strong>*) : service 패키지의 하위패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>this(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>target(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>args(java.utils.List)</strong> : 파라미터가 1개이고 List타입인 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>@target(org.springframework.transaction.annotation.Transactional)</strong> :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@within(org.springframework.transaction.annotation.Transactional)</strong> : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@annotation(org.springframework.transaction.annotation.Transactional)</strong> : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n</ul>\n<ul>\n<li>\n<p><strong>@args(com.xyz.security.Classified)</strong> : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>bean(UserRepository)</strong> : “UserRepository” 빈</p>\n</li>\n<li>\n<p><strong>!bean(UserRepository)</strong> :  “UserRepository” 빈을 제외한 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(</em>)</em>* : 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user</em>)</em>* : 이름이 'user'로 시작되는 모든 빈</p>\n</li>\n<li>\n<p>*<em>bean(<em>Repository)</em></em> : 이름이 “Repository”로 끝나는 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user/</em>)</em>* : 이름이 “user/“로 시작하는 모든 빈</p>\n</li>\n<li>\n<p>**bean(<em>dataSource) || bean(<em>DataSource)</em></em> : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈</p>\n</li>\n</ul>\n<h1>예시코드</h1>\n<h2>Aspect 파일 사용</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> aspect TestAdvisor &#123;</span><br><span class=\"line\">    <span class=\"function\">pointcut <span class=\"title\">advicePoint</span><span class=\"params\">()</span> : <span class=\"title\">execution</span><span class=\"params\">(* com.example.advice..*(..)</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//order는 어떻게 주는건지 모르겠다.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>@Aspect 어노테이션 사용</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.example.advice..*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pointcut</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">2</span>) <span class=\"comment\">//order가 높은 순으로 먼저 실행</span></span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterAdvice</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showLog</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>참고</h1>\n<p>http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014</p>\n<p>http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9</p>\n<p>https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5</p>\n"},{"title":"Spring Argument Resovler","catalog":true,"date":"2018-08-09T16:53:17.000Z","subtitle":"Controller를 깔끔하게 해주는 Argument Resolver","header-img":null,"typora-root-url":"./2018-08-10-spring-argument-resolver","typora-copy-images-to":"./2018-08-10-spring-argument-resolver","_content":"\n\n\n회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나.. 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.\n\n그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.\n\n하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다.. (Client IP를 구하는 코드가 한 10줄 정도는 된다.)\n\n그래서 중간에 Filter나 Interceptor로 해볼까..? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.\n\n\n\n# Spring Argument Resolver\n\nSpring Argument Resolver는 `Controller에 들어오는 파라미터를 가공` 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공/추가/수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.\nSpring에서는 `HandlerMethodArgumentResolver`라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.\n\n\n\n# Argument Resolver 동작 방식\n\n![Dispatch-Seq](./Dispatch-Seq.jpg)\n\n\n\n(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)\n\n1. Client Request 요청\n2. Dispatcher Servlet에서 해당 요청을 처리\n3. Client Request에 대한 Handler Mapping \n   1. RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)\n   2. Interceptor처리\n   3. `Argument Resolver 처리` <-- 바로 여기서 우리가 지정한 Argument Resolver 실행\n   4. Message Converter 처리\n4. Controller Method invoke\n\n\n\n![RequestMappingHandlerAdapter](./RequestMappingHandlerAdapter.png)\n\n\n\nRequestHandlerMappingAdapter.java > getDefaultArgumentResolvers\n\n위에서 지정 된 순서대로 Argument Resolver를 실행 한다.\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.\n\n\n\n# Custom Argument Resolver 만들기\n\n내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에..)\n\n기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.\nCustom Argument Resolver를 만들기 위해서는 `HandlerMethodArgumentResolver` 인터페이스를 구현하여 만든다.\n\n```java\npackage com.example.springstudy.resolver;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.support.WebDataBinderFactory;\nimport org.springframework.web.context.request.NativeWebRequest;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.method.support.ModelAndViewContainer;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class ClientIpArgumentResolver implements HandlerMethodArgumentResolver {\n\n    /**\n     * resolveArgument를 실행 할 수 있는 method인지 판별\n     * @param methodParameter\n     * @return\n     */\n    @Override\n    public boolean supportsParameter(MethodParameter methodParameter) {\n        //@ClientIP 어노테이션이 붙은 파라미터에 대해 적용\n        return methodParameter.hasParameterAnnotation(ClientIP.class);\n    }\n\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n}\n\n```\n\n\n\nHandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.\n\n- supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n  - 물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.\n- resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.\n\n\n\n# Custom Argument Resolver 등록하기\n\n개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.\n\n전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.\n\n\n\n1. ServletContext.xml 에 등록하는 방법\n\n```xml\n<mvc:annotation-driven>\n    <mvc:argument-resolvers>\n        <bean class=\"com.example.springstudy.resolver.ClientIpArgumentResolver\"></bean>      \n    </mvc:argument-resolvers>\n</mvc:annotation-driven>\n```\n\n\n\n1. Java Config를 이용하는 방법\n\n```java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\nimport java.util.List;\n\n//WebMvcConfigurationSupport를 상속 \n//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n    \n    //우리가 만든 ArgumentResolver를 추가한다.\n    @Override\n    protected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        super.addArgumentResolvers(argumentResolvers);\n        argumentResolvers.add(new ClientIpArgumentResolver());\n    }\n}\n```\n\n\n\n# Controller에 적용\n\n```java\npackage com.example.springstudy.controller;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class ClientController {\n\n    /**\n     * 요청을 보낸 Client Ip를 return\n     * @param clientIp\n     * @return\n     */\n    @GetMapping(\"/client\")\n    public String getClientIp(@ClientIP String clientIp) {\n\n        return String.format(\"Request Client Ip = %s\", clientIp);\n    }\n}\n```\n\n\n\nController 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.\n\n\n\n실행 결과\n\n![argument-resolver-result](./argument-resolver-result.png)\n\n\n\n\n\n# 참조\n\n토비의 스프링 vol.2\n\nhttp://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\n\nhttp://zgundam.tistory.com/38\n\nhttp://rstoyanchev.github.io/spring-mvc-31-update/#13","source":"_posts/2018-08-10-spring-argument-resolver.md","raw":"---\ntitle: Spring Argument Resovler\ncatalog: true\ndate: 2018-08-10 01:53:17\nsubtitle: Controller를 깔끔하게 해주는 Argument Resolver\nheader-img:\ntags: Spring\ntypora-root-url: ./2018-08-10-spring-argument-resolver\ntypora-copy-images-to: ./2018-08-10-spring-argument-resolver\n---\n\n\n\n회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나.. 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.\n\n그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.\n\n하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다.. (Client IP를 구하는 코드가 한 10줄 정도는 된다.)\n\n그래서 중간에 Filter나 Interceptor로 해볼까..? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.\n\n\n\n# Spring Argument Resolver\n\nSpring Argument Resolver는 `Controller에 들어오는 파라미터를 가공` 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공/추가/수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.\nSpring에서는 `HandlerMethodArgumentResolver`라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.\n\n\n\n# Argument Resolver 동작 방식\n\n![Dispatch-Seq](./Dispatch-Seq.jpg)\n\n\n\n(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)\n\n1. Client Request 요청\n2. Dispatcher Servlet에서 해당 요청을 처리\n3. Client Request에 대한 Handler Mapping \n   1. RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)\n   2. Interceptor처리\n   3. `Argument Resolver 처리` <-- 바로 여기서 우리가 지정한 Argument Resolver 실행\n   4. Message Converter 처리\n4. Controller Method invoke\n\n\n\n![RequestMappingHandlerAdapter](./RequestMappingHandlerAdapter.png)\n\n\n\nRequestHandlerMappingAdapter.java > getDefaultArgumentResolvers\n\n위에서 지정 된 순서대로 Argument Resolver를 실행 한다.\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.\n\n\n\n# Custom Argument Resolver 만들기\n\n내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에..)\n\n기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.\nCustom Argument Resolver를 만들기 위해서는 `HandlerMethodArgumentResolver` 인터페이스를 구현하여 만든다.\n\n```java\npackage com.example.springstudy.resolver;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.support.WebDataBinderFactory;\nimport org.springframework.web.context.request.NativeWebRequest;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.method.support.ModelAndViewContainer;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class ClientIpArgumentResolver implements HandlerMethodArgumentResolver {\n\n    /**\n     * resolveArgument를 실행 할 수 있는 method인지 판별\n     * @param methodParameter\n     * @return\n     */\n    @Override\n    public boolean supportsParameter(MethodParameter methodParameter) {\n        //@ClientIP 어노테이션이 붙은 파라미터에 대해 적용\n        return methodParameter.hasParameterAnnotation(ClientIP.class);\n    }\n\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n}\n\n```\n\n\n\nHandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.\n\n- supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n  - 물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.\n- resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.\n\n\n\n# Custom Argument Resolver 등록하기\n\n개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.\n\n전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.\n\n\n\n1. ServletContext.xml 에 등록하는 방법\n\n```xml\n<mvc:annotation-driven>\n    <mvc:argument-resolvers>\n        <bean class=\"com.example.springstudy.resolver.ClientIpArgumentResolver\"></bean>      \n    </mvc:argument-resolvers>\n</mvc:annotation-driven>\n```\n\n\n\n1. Java Config를 이용하는 방법\n\n```java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\nimport java.util.List;\n\n//WebMvcConfigurationSupport를 상속 \n//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n    \n    //우리가 만든 ArgumentResolver를 추가한다.\n    @Override\n    protected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        super.addArgumentResolvers(argumentResolvers);\n        argumentResolvers.add(new ClientIpArgumentResolver());\n    }\n}\n```\n\n\n\n# Controller에 적용\n\n```java\npackage com.example.springstudy.controller;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class ClientController {\n\n    /**\n     * 요청을 보낸 Client Ip를 return\n     * @param clientIp\n     * @return\n     */\n    @GetMapping(\"/client\")\n    public String getClientIp(@ClientIP String clientIp) {\n\n        return String.format(\"Request Client Ip = %s\", clientIp);\n    }\n}\n```\n\n\n\nController 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.\n\n\n\n실행 결과\n\n![argument-resolver-result](./argument-resolver-result.png)\n\n\n\n\n\n# 참조\n\n토비의 스프링 vol.2\n\nhttp://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\n\nhttp://zgundam.tistory.com/38\n\nhttp://rstoyanchev.github.io/spring-mvc-31-update/#13","slug":"2018-08-10-spring-argument-resolver","published":1,"updated":"2018-11-27T07:23:32.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv3rd002rcr1t9i13e9is","content":"<p>회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나.. 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.</p>\n<p>그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.</p>\n<p>하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다.. (Client IP를 구하는 코드가 한 10줄 정도는 된다.)</p>\n<p>그래서 중간에 Filter나 Interceptor로 해볼까..? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.</p>\n<h1 id=\"spring-argument-resolver\">Spring Argument Resolver</h1>\n<p>Spring Argument Resolver는 <code>Controller에 들어오는 파라미터를 가공</code> 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공/추가/수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.\nSpring에서는 <code>HandlerMethodArgumentResolver</code>라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.</p>\n<h1 id=\"argument-resolver-동작-방식\">Argument Resolver 동작 방식</h1>\n<p><img src=\"./Dispatch-Seq.jpg\" alt=\"Dispatch-Seq\"></p>\n<p>(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)</p>\n<ol>\n<li>Client Request 요청</li>\n<li>Dispatcher Servlet에서 해당 요청을 처리</li>\n<li>Client Request에 대한 Handler Mapping\n<ol>\n<li>RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)</li>\n<li>Interceptor처리</li>\n<li><code>Argument Resolver 처리</code> &lt;-- 바로 여기서 우리가 지정한 Argument Resolver 실행</li>\n<li>Message Converter 처리</li>\n</ol>\n</li>\n<li>Controller Method invoke</li>\n</ol>\n<p><img src=\"./RequestMappingHandlerAdapter.png\" alt=\"RequestMappingHandlerAdapter\"></p>\n<p>RequestHandlerMappingAdapter.java &gt; getDefaultArgumentResolvers</p>\n<p>위에서 지정 된 순서대로 Argument Resolver를 실행 한다.\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.</p>\n<h1 id=\"custom-argument-resolver-만들기\">Custom Argument Resolver 만들기</h1>\n<p>내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에..)</p>\n<p>기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.\nCustom Argument Resolver를 만들기 위해서는 <code>HandlerMethodArgumentResolver</code> 인터페이스를 구현하여 만든다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.resolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.MethodParameter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.util.StringUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientIpArgumentResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * resolveArgument를 실행 할 수 있는 method인지 판별</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supportsParameter</span><span class=\"params\">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//@ClientIP 어노테이션이 붙은 파라미터에 대해 적용</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> methodParameter.hasParameterAnnotation(ClientIP.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">        String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getRemoteAddr();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.</p>\n<ul>\n<li>supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n<ul>\n<li>물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.</li>\n</ul>\n</li>\n<li>resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.</li>\n</ul>\n<h1 id=\"custom-argument-resolver-등록하기\">Custom Argument Resolver 등록하기</h1>\n<p>개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.</p>\n<p>전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.</p>\n<ol>\n<li>ServletContext.xml 에 등록하는 방법</li>\n</ol>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.resolver.ClientIpArgumentResolver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span>      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>Java Config를 이용하는 방법</li>\n</ol>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//WebMvcConfigurationSupport를 상속 </span></span><br><span class=\"line\"><span class=\"comment\">//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//우리가 만든 ArgumentResolver를 추가한다.</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addArgumentResolvers</span><span class=\"params\">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addArgumentResolvers(argumentResolvers);</span><br><span class=\"line\">        argumentResolvers.add(<span class=\"keyword\">new</span> ClientIpArgumentResolver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"controller에-적용\">Controller에 적용</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 요청을 보낸 Client Ip를 return</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> clientIp</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/client\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getClientIp</span><span class=\"params\">(@ClientIP String clientIp)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.format(<span class=\"string\">\"Request Client Ip = %s\"</span>, clientIp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Controller 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.</p>\n<p>실행 결과</p>\n<p><img src=\"./argument-resolver-result.png\" alt=\"argument-resolver-result\"></p>\n<h1 id=\"참조\">참조</h1>\n<p>토비의 스프링 vol.2</p>\n<p>http://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0</p>\n<p>http://zgundam.tistory.com/38</p>\n<p>http://rstoyanchev.github.io/spring-mvc-31-update/#13</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<p>회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나.. 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.</p>\n<p>그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.</p>\n<p>하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다.. (Client IP를 구하는 코드가 한 10줄 정도는 된다.)</p>\n<p>그래서 중간에 Filter나 Interceptor로 해볼까..? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.</p>\n<h1>Spring Argument Resolver</h1>\n<p>Spring Argument Resolver는 <code>Controller에 들어오는 파라미터를 가공</code> 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공/추가/수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.\nSpring에서는 <code>HandlerMethodArgumentResolver</code>라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.</p>\n<h1>Argument Resolver 동작 방식</h1>\n<p><img src=\"./Dispatch-Seq.jpg\" alt=\"Dispatch-Seq\"></p>\n<p>(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)</p>\n<ol>\n<li>Client Request 요청</li>\n<li>Dispatcher Servlet에서 해당 요청을 처리</li>\n<li>Client Request에 대한 Handler Mapping\n<ol>\n<li>RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)</li>\n<li>Interceptor처리</li>\n<li><code>Argument Resolver 처리</code> &lt;-- 바로 여기서 우리가 지정한 Argument Resolver 실행</li>\n<li>Message Converter 처리</li>\n</ol>\n</li>\n<li>Controller Method invoke</li>\n</ol>\n<p><img src=\"./RequestMappingHandlerAdapter.png\" alt=\"RequestMappingHandlerAdapter\"></p>\n<p>RequestHandlerMappingAdapter.java &gt; getDefaultArgumentResolvers</p>\n<p>위에서 지정 된 순서대로 Argument Resolver를 실행 한다.\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.</p>\n<h1>Custom Argument Resolver 만들기</h1>\n<p>내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에..)</p>\n<p>기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.\nCustom Argument Resolver를 만들기 위해서는 <code>HandlerMethodArgumentResolver</code> 인터페이스를 구현하여 만든다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.resolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.MethodParameter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.util.StringUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientIpArgumentResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * resolveArgument를 실행 할 수 있는 method인지 판별</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supportsParameter</span><span class=\"params\">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//@ClientIP 어노테이션이 붙은 파라미터에 대해 적용</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> methodParameter.hasParameterAnnotation(ClientIP.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">        String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getRemoteAddr();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.</p>\n<ul>\n<li>supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n<ul>\n<li>물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.</li>\n</ul>\n</li>\n<li>resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.</li>\n</ul>\n<h1>Custom Argument Resolver 등록하기</h1>\n<p>개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.</p>\n<p>전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.</p>\n<ol>\n<li>ServletContext.xml 에 등록하는 방법</li>\n</ol>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.resolver.ClientIpArgumentResolver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span>      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>Java Config를 이용하는 방법</li>\n</ol>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//WebMvcConfigurationSupport를 상속 </span></span><br><span class=\"line\"><span class=\"comment\">//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//우리가 만든 ArgumentResolver를 추가한다.</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addArgumentResolvers</span><span class=\"params\">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addArgumentResolvers(argumentResolvers);</span><br><span class=\"line\">        argumentResolvers.add(<span class=\"keyword\">new</span> ClientIpArgumentResolver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>Controller에 적용</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 요청을 보낸 Client Ip를 return</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> clientIp</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/client\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getClientIp</span><span class=\"params\">(@ClientIP String clientIp)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.format(<span class=\"string\">\"Request Client Ip = %s\"</span>, clientIp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Controller 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.</p>\n<p>실행 결과</p>\n<p><img src=\"./argument-resolver-result.png\" alt=\"argument-resolver-result\"></p>\n<h1>참조</h1>\n<p>토비의 스프링 vol.2</p>\n<p>http://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0</p>\n<p>http://zgundam.tistory.com/38</p>\n<p>http://rstoyanchev.github.io/spring-mvc-31-update/#13</p>\n"},{"title":"Spring Dispatcher Servlet","catalog":true,"date":"2018-08-11T08:17:36.000Z","subtitle":null,"header-img":null,"Categories":["Spring"],"typora-root-url":"./2018-08-11-spring-dispatcher-servlet","typora-copy-images-to":"./2018-08-11-spring-dispatcher-servlet","_content":"\n# Spring Dispatcher Servlet\n\nSpring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다. \n\n\n\n# Front Controller Pattern\n\nDispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.\n\n\n\n![Front-controller-pattern](./Front-controller-pattern.png)\n\n\n\nSpring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.\n모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다. \n자세한 Cycle은 아래 그림과 같다.\n\n\n\n# Dispatcher Servlet Cycle\n\n![dispatcher-servlet-lifecycle](./dispatcher-servlet-lifecycle.jpg)\n\n\n\n1. doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 [doDispatch()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942) 메소드를 호출한다. \n2. 아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.\n3. [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017)  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.\n4. 요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.\n5. 실행될 interceptor들이 있다면 interceptor의 [preHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036) 메소드를 차례로 실행한다.\n6. Controller의 인스턴스는 HandlerExecutionChain의 [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017) 메소드를 이용해서 얻는다.\n7. HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, [getHandlerAdaptor()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024) 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.\n8. 선택된 HanlderAdaptor의 [handle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041) 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.\n9. 계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 [invoke()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894)한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)\n10. interceptor의 [postHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048) 메소드가 실행된다.\n11. [resolveViewName()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409) 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.\n12. Model 객체의 데이터를 보여주기 위해 해당 View 객체의 [render()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119) 메소드가 수행된다.\n\n\n\n# web.xml 설정하기\n\n### 기본 설정\n\n~~~xml\n<web-app> <!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--> \n    <servlet> \n        <servlet-name>appServlet</servlet-name> \n    \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    </servlet> \n\n    <servlet-mapping>\n        <servlet-name>appServlet</servlet-name>\n        <url-pattern>/</url-pattern> <!-- Default Servlet을 의미 --> \n    </servlet-mapping>\n</web-app>\n~~~\n\nappServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.\nDispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, `/` prefix로 들어오는 모든 요청을 처리한다.\n\nservlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 `/WEB-INF/appServlet-servlet.xml`을 찾게 된다. \n\n\n\n### contextConfigLocation을 이용한 설정\n\n빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다. \n\n```xml\n<servlet>\n    <servlet-name>appServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>\n        \t/WEB-INF/spring/appServlet/servlet-context.xml\n\t\t<!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --> \n        </param-value>\n    </init-param>\n</servlet>\n```\n\n\n\n### ContextLoaderListener를 이용한 설정\n\n일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.\n또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.\n이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.\n공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고, \nweb layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.\n\n~~~xml\n<!-- ApplicationContext 빈 설정 파일--> \n<context-param> \n    <param-name>contextConfigLocation</param-name> \n    <param-value> \n        <!--빈 설정 파일들간에 구분은 줄바꿈(\\n),컴마(,),세미콜론(;)등으로 한다.--> \n        /WEB-INF/config/myapp-service.xml,\n        /WEB-INF/config/myapp-dao.xml \t\t\n    </param-value> \n</context-param> \n\n<!-- \n웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, \n로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.\n--> \n<listener> \n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> </listener> \n\n<servlet> \n    <servlet-name>employee</servlet-name> \n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \t\t<init-param> \n    \t<param-name>contextConfigLocation</param-name> \t\n    \t<param-value> /WEB-INF/config/myapp-servlet.xml </param-value> \n    </init-param> \n</servlet> \n\n<servlet> \n    <servlet-name>webservice</servlet-name> \n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \t\t<init-param> \n    \t<param-name>contextConfigLocation</param-name> \n    \t<param-value> /WEB-INF/config/myapp-webservice.xml </param-value> \n    </init-param> \n</servlet>\n~~~\n\n맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.\n(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)\n\n따라서\nemployee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,\nwebServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.\n\n\n\n\n\n\n\n# 참고\n\nhttp://mangkyu.tistory.com/18\nhttp://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet\nhttp://hermeslog.tistory.com/156\nhttps://github.com/dongmyo/dispatcher2\nhttps://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/\nhttps://nesoy.github.io/articles/2017-02/Front-Controller\nhttp://wonwoo.ml/index.php/post/1590","source":"_posts/2018-08-11-spring-dispatcher-servlet.md","raw":"---\ntitle: Spring Dispatcher Servlet\ncatalog: true\ndate: 2018-08-11 17:17:36\nsubtitle:\nheader-img:\nCategories:\n - Spring\ntags: \n - Spring\n - core\ntypora-root-url: ./2018-08-11-spring-dispatcher-servlet\ntypora-copy-images-to: ./2018-08-11-spring-dispatcher-servlet\n---\n\n# Spring Dispatcher Servlet\n\nSpring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다. \n\n\n\n# Front Controller Pattern\n\nDispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.\n\n\n\n![Front-controller-pattern](./Front-controller-pattern.png)\n\n\n\nSpring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.\n모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다. \n자세한 Cycle은 아래 그림과 같다.\n\n\n\n# Dispatcher Servlet Cycle\n\n![dispatcher-servlet-lifecycle](./dispatcher-servlet-lifecycle.jpg)\n\n\n\n1. doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 [doDispatch()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942) 메소드를 호출한다. \n2. 아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.\n3. [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017)  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.\n4. 요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.\n5. 실행될 interceptor들이 있다면 interceptor의 [preHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036) 메소드를 차례로 실행한다.\n6. Controller의 인스턴스는 HandlerExecutionChain의 [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017) 메소드를 이용해서 얻는다.\n7. HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, [getHandlerAdaptor()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024) 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.\n8. 선택된 HanlderAdaptor의 [handle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041) 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.\n9. 계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 [invoke()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894)한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)\n10. interceptor의 [postHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048) 메소드가 실행된다.\n11. [resolveViewName()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409) 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.\n12. Model 객체의 데이터를 보여주기 위해 해당 View 객체의 [render()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119) 메소드가 수행된다.\n\n\n\n# web.xml 설정하기\n\n### 기본 설정\n\n~~~xml\n<web-app> <!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--> \n    <servlet> \n        <servlet-name>appServlet</servlet-name> \n    \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    </servlet> \n\n    <servlet-mapping>\n        <servlet-name>appServlet</servlet-name>\n        <url-pattern>/</url-pattern> <!-- Default Servlet을 의미 --> \n    </servlet-mapping>\n</web-app>\n~~~\n\nappServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.\nDispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, `/` prefix로 들어오는 모든 요청을 처리한다.\n\nservlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 `/WEB-INF/appServlet-servlet.xml`을 찾게 된다. \n\n\n\n### contextConfigLocation을 이용한 설정\n\n빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다. \n\n```xml\n<servlet>\n    <servlet-name>appServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>\n        \t/WEB-INF/spring/appServlet/servlet-context.xml\n\t\t<!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --> \n        </param-value>\n    </init-param>\n</servlet>\n```\n\n\n\n### ContextLoaderListener를 이용한 설정\n\n일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.\n또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.\n이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.\n공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고, \nweb layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.\n\n~~~xml\n<!-- ApplicationContext 빈 설정 파일--> \n<context-param> \n    <param-name>contextConfigLocation</param-name> \n    <param-value> \n        <!--빈 설정 파일들간에 구분은 줄바꿈(\\n),컴마(,),세미콜론(;)등으로 한다.--> \n        /WEB-INF/config/myapp-service.xml,\n        /WEB-INF/config/myapp-dao.xml \t\t\n    </param-value> \n</context-param> \n\n<!-- \n웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, \n로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.\n--> \n<listener> \n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> </listener> \n\n<servlet> \n    <servlet-name>employee</servlet-name> \n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \t\t<init-param> \n    \t<param-name>contextConfigLocation</param-name> \t\n    \t<param-value> /WEB-INF/config/myapp-servlet.xml </param-value> \n    </init-param> \n</servlet> \n\n<servlet> \n    <servlet-name>webservice</servlet-name> \n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \t\t<init-param> \n    \t<param-name>contextConfigLocation</param-name> \n    \t<param-value> /WEB-INF/config/myapp-webservice.xml </param-value> \n    </init-param> \n</servlet>\n~~~\n\n맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.\n(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)\n\n따라서\nemployee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,\nwebServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.\n\n\n\n\n\n\n\n# 참고\n\nhttp://mangkyu.tistory.com/18\nhttp://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet\nhttp://hermeslog.tistory.com/156\nhttps://github.com/dongmyo/dispatcher2\nhttps://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/\nhttps://nesoy.github.io/articles/2017-02/Front-Controller\nhttp://wonwoo.ml/index.php/post/1590","slug":"2018-08-11-spring-dispatcher-servlet","published":1,"updated":"2018-11-27T07:23:32.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv3re002scr1tkrpp7q2b","content":"<h1 id=\"spring-dispatcher-servlet\">Spring Dispatcher Servlet</h1>\n<p>Spring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다.</p>\n<h1 id=\"front-controller-pattern\">Front Controller Pattern</h1>\n<p>Dispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.</p>\n<p><img src=\"./Front-controller-pattern.png\" alt=\"Front-controller-pattern\"></p>\n<p>Spring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.\n모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다.\n자세한 Cycle은 아래 그림과 같다.</p>\n<h1 id=\"dispatcher-servlet-cycle\">Dispatcher Servlet Cycle</h1>\n<p><img src=\"./dispatcher-servlet-lifecycle.jpg\" alt=\"dispatcher-servlet-lifecycle\"></p>\n<ol>\n<li>doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942\" target=\"_blank\" rel=\"noopener\">doDispatch()</a> 메소드를 호출한다.</li>\n<li>아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017\" target=\"_blank\" rel=\"noopener\">getHandler()</a>  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.</li>\n<li>요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.</li>\n<li>실행될 interceptor들이 있다면 interceptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036\" target=\"_blank\" rel=\"noopener\">preHandle()</a> 메소드를 차례로 실행한다.</li>\n<li>Controller의 인스턴스는 HandlerExecutionChain의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드를 이용해서 얻는다.</li>\n<li>HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024\" target=\"_blank\" rel=\"noopener\">getHandlerAdaptor()</a> 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.</li>\n<li>선택된 HanlderAdaptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041\" target=\"_blank\" rel=\"noopener\">handle()</a> 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.</li>\n<li>계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894\" target=\"_blank\" rel=\"noopener\">invoke()</a>한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)</li>\n<li>interceptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048\" target=\"_blank\" rel=\"noopener\">postHandle()</a> 메소드가 실행된다.</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409\" target=\"_blank\" rel=\"noopener\">resolveViewName()</a> 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.</li>\n<li>Model 객체의 데이터를 보여주기 위해 해당 View 객체의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119\" target=\"_blank\" rel=\"noopener\">render()</a> 메소드가 수행된다.</li>\n</ol>\n<h1 id=\"webxml-설정하기\">web.xml 설정하기</h1>\n<h3 id=\"기본-설정\">기본 설정</h3>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span>&gt;</span> <span class=\"comment\">&lt;!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span> <span class=\"comment\">&lt;!-- Default Servlet을 의미 --&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>appServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.\nDispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, <code>/</code> prefix로 들어오는 모든 요청을 처리한다.</p>\n<p>servlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 <code>/WEB-INF/appServlet-servlet.xml</code>을 찾게 된다.</p>\n<h3 id=\"contextconfiglocation을-이용한-설정\">contextConfigLocation을 이용한 설정</h3>\n<p>빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다.</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        \t/WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"contextloaderlistener를-이용한-설정\">ContextLoaderListener를 이용한 설정</h3>\n<p>일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.\n또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.\n이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.\n공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고,\nweb layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- ApplicationContext 빈 설정 파일--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"comment\">&lt;!--빈 설정 파일들간에 구분은 줄바꿈(\\n),컴마(,),세미콜론(;)등으로 한다.--&gt;</span> </span><br><span class=\"line\">        /WEB-INF/config/myapp-service.xml,</span><br><span class=\"line\">        /WEB-INF/config/myapp-dao.xml \t\t</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, </span></span><br><span class=\"line\"><span class=\"comment\">로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>employee<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> \t\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> \t</span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> /WEB-INF/config/myapp-servlet.xml <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>webservice<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> \t\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> /WEB-INF/config/myapp-webservice.xml <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.\n(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)</p>\n<p>따라서\nemployee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,\nwebServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.</p>\n<h1 id=\"참고\">참고</h1>\n<p>http://mangkyu.tistory.com/18\nhttp://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet\nhttp://hermeslog.tistory.com/156\nhttps://github.com/dongmyo/dispatcher2\nhttps://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/\nhttps://nesoy.github.io/articles/2017-02/Front-Controller\nhttp://wonwoo.ml/index.php/post/1590</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>Spring Dispatcher Servlet</h1>\n<p>Spring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다.</p>\n<h1>Front Controller Pattern</h1>\n<p>Dispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.</p>\n<p><img src=\"./Front-controller-pattern.png\" alt=\"Front-controller-pattern\"></p>\n<p>Spring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.\n모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다.\n자세한 Cycle은 아래 그림과 같다.</p>\n<h1>Dispatcher Servlet Cycle</h1>\n<p><img src=\"./dispatcher-servlet-lifecycle.jpg\" alt=\"dispatcher-servlet-lifecycle\"></p>\n<ol>\n<li>doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942\" target=\"_blank\" rel=\"noopener\">doDispatch()</a> 메소드를 호출한다.</li>\n<li>아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017\" target=\"_blank\" rel=\"noopener\">getHandler()</a>  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.</li>\n<li>요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.</li>\n<li>실행될 interceptor들이 있다면 interceptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036\" target=\"_blank\" rel=\"noopener\">preHandle()</a> 메소드를 차례로 실행한다.</li>\n<li>Controller의 인스턴스는 HandlerExecutionChain의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드를 이용해서 얻는다.</li>\n<li>HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024\" target=\"_blank\" rel=\"noopener\">getHandlerAdaptor()</a> 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.</li>\n<li>선택된 HanlderAdaptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041\" target=\"_blank\" rel=\"noopener\">handle()</a> 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.</li>\n<li>계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894\" target=\"_blank\" rel=\"noopener\">invoke()</a>한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)</li>\n<li>interceptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048\" target=\"_blank\" rel=\"noopener\">postHandle()</a> 메소드가 실행된다.</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409\" target=\"_blank\" rel=\"noopener\">resolveViewName()</a> 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.</li>\n<li>Model 객체의 데이터를 보여주기 위해 해당 View 객체의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119\" target=\"_blank\" rel=\"noopener\">render()</a> 메소드가 수행된다.</li>\n</ol>\n<h1>web.xml 설정하기</h1>\n<h3>기본 설정</h3>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span>&gt;</span> <span class=\"comment\">&lt;!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span> <span class=\"comment\">&lt;!-- Default Servlet을 의미 --&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>appServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.\nDispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, <code>/</code> prefix로 들어오는 모든 요청을 처리한다.</p>\n<p>servlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 <code>/WEB-INF/appServlet-servlet.xml</code>을 찾게 된다.</p>\n<h3>contextConfigLocation을 이용한 설정</h3>\n<p>빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다.</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        \t/WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3>ContextLoaderListener를 이용한 설정</h3>\n<p>일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.\n또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.\n이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.\n공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고,\nweb layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- ApplicationContext 빈 설정 파일--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"comment\">&lt;!--빈 설정 파일들간에 구분은 줄바꿈(\\n),컴마(,),세미콜론(;)등으로 한다.--&gt;</span> </span><br><span class=\"line\">        /WEB-INF/config/myapp-service.xml,</span><br><span class=\"line\">        /WEB-INF/config/myapp-dao.xml \t\t</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, </span></span><br><span class=\"line\"><span class=\"comment\">로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>employee<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> \t\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> \t</span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> /WEB-INF/config/myapp-servlet.xml <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>webservice<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> \t\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> /WEB-INF/config/myapp-webservice.xml <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.\n(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)</p>\n<p>따라서\nemployee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,\nwebServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.</p>\n<h1>참고</h1>\n<p>http://mangkyu.tistory.com/18\nhttp://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet\nhttp://hermeslog.tistory.com/156\nhttps://github.com/dongmyo/dispatcher2\nhttps://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/\nhttps://nesoy.github.io/articles/2017-02/Front-Controller\nhttp://wonwoo.ml/index.php/post/1590</p>\n"},{"title":"Spring Filter와 Interceptor","catalog":true,"date":"2018-08-25T09:30:26.000Z","subtitle":null,"header-img":null,"Categories":["Spring"],"typora-root-url":"./2018-08-18-spring-filter-interceptor","typora-copy-images-to":"./2018-08-18-spring-filter-interceptor","_content":"\n# 들어가며..\n\n개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다. \n회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.\nFilter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.\n\n\n\n# Spring Request Flow\n\n![spring-request-lifecycle](./spring-request-lifecycle.jpg)\n\n\n\n이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.\n(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)\n\n\n\n그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.\nFilter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 `J2EE 표준스펙`이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다. \n\nInterceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.\n따라서 Interceptor는 `Spring Framework에서 제공하는 API`이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.\n\n\n\n# Filter\n\n위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.\n실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 `Spring Security, CORS Filter`등이 있다.\n\n\n\n## Filter Chain\n\n![filter-chain](./filter-chain.gif)\n\nFilter의 큰 특징으로는 Filter chain이라는 개념이 있다.\n실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 `Standard Context`에 `FilterMap`이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 `Filter chain`을 구성하게 되어 순차적으로 실행 되게 된다. \n\n* [Request에 대한 Filter Chain 생성](https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705)\n* [Request URL에 대한 FilterMap 생성](https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53)\n\n※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.\n\n\n\nFilter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.\n\n1. url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.\n2. servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.\n\n\n\n## Filter 생성\n\n~~~java\npackage com.example.springstudy.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\npublic class TestFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\t\t//filter 생성 시 처리\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        //다음 Filter 실행 전 처리 (preHandle)\n        \n        //다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)\n\t\tfilterChain.doFilter(servletRequest, servletResponse);\n        \n        //다음 Filter 실행 후 처리 (postHandle)\n    }\n\n    @Override\n    public void destroy() {\n\t\t//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)\n    }\n}\n\n~~~\n\n\n\n## 설정 방법\n\nFilter를 등록하는 방식을 크게 4가지 정도 있다.\n\n1. web.xml 등록 방식\n2. Java config 등록 방식 -> FilterRegistration Bean을 정의하여 추가할 Filter를 정의\n3. java config 등록 방식 -> AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가\n4. @WebFilter Annotation 등록 방식\n\n\n\n### 1. web.xml 등록 방식\n\n```xml\n<filter>\n    <filter-name>testFilter</filter-name>\n    <filter-class>com.example.springstudy.filter.TestFilter</filter-class>\n</filter>\n<filter>\n    <filter-name>testFilter2</filter-name>\n    <filter-class>com.example.springstudy.filter.TestFilter</filter-class>\n</filter>\n\n<filter-mapping>\n    <filter-name>testFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n    <!-- url-pattern 대신 Servlet을 지정할 수도 있다. -->\n    <servlet-name>testServlet</servlet-name> \n</filter-mapping>\n<filter-mapping>\n    <filter-name>testFilter2</filter-name>\n    <url-pattern>/*</url-pattern>\n    <!-- url-pattern 대신 Servlet을 지정할 수도 있다. -->\n    <servlet-name>testServlet</servlet-name> \n</filter-mapping>\n```\n\n\n\n### 2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의\n\n~~~java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class WebApplicationFilterConfig {\n\n    @Bean\n    public FilterRegistrationBean testFilterRegistration() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n        filterRegistrationBean.setFilter(new TestFilter());\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        filterRegistrationBean.setName(\"Test-Filter\");\n        filterRegistrationBean.setOrder(1);\n\n        return filterRegistrationBean;\n    }\n    \n    @Bean\n    public FilterRegistrationBean testFilter2Registration() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n        filterRegistrationBean.setFilter(new TestFilter2());\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        filterRegistrationBean.setName(\"Test-Filter2\");\n        filterRegistrationBean.setOrder(2);\n\n        return filterRegistrationBean;\n    }\n}\n~~~\n\n\n\nFilter chain의 실행 순서는 Filter1(Prehandle) -> Filter2(Prehandle) -> Filter2 (Posthandle) -> Filter1 (Posthandle) 순으로 실행 된다. \n\n\n\n### 3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가\n\n※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)\n\n~~~java\npackage com.example.springstudy.config;\n\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\nimport javax.servlet.Filter;\n\n@Configuration\npublic class WebInitializerConfig extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Filter[] getServletFilters() {\n        //추가할 필터 리스트를 추가한다.\n        return new Filter[]{new TestFilter(), new TestFilter2()};\n    }\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[0];\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class[0];\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[0];\n    }\n}\n\n~~~\n\n\n\n### 4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록\n\n~~~java\npackage com.example.springstudy.filter;\n\nimport org.springframework.core.annotation.Order;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n@Component\n@WebFilter(\n        description = \"1번째 필터\",\n        urlPatterns = \"/*\",\n        filterName = \"Test-Filter1\"\n)\n@Order(2)\npublic class TestFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"start testFilter1\");\n        filterChain.doFilter(servletRequest, servletResponse);\n        System.out.println(\"finish testFilter1\");\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n~~~\n\n다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.\n@Component -> Component-scan 시 Spring Bean으로 등록 된다.\n@WebFIlter -> Filter등록에 필요한 Interface를 제공한다.\n@Order -> @Component 어노테이션 사용 시 `Order Interface` 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다. \n개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.\n\n\n\n# Interceptor\n\n인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.\n\n인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 `preHandle(), postHandle()` 메소드가 구분 되어져 있어, 분기가 명확하다.\n또한 Filter와는 다르게 `handlerMethod`를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.\n\n\n\n## Interceptor 동작 방식\n\n1. 외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.\n2. DispatcherServlet의 doDispatch() 메소드에서 [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013) 메소드로 HandlerExecutionChain를 호출 한다.\n   (정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)\n3.  [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227) 메소드 내부에는 [getHandlerInternal()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401) 메소드로 handler를 가져오는 부분이 있다.\n   이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.\n4. 그 다음 [getHandlerExecutionChain()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480) 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.\n5. 추출 된 interceptor들에 대해 [preHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032) 메소드를 실행 시킨다.\n   (preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)\n6. 그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.\n7. 메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 [postHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044) 메소드를 실행 시킨다.\n\n\n\n## 설정 방법\n\n설정 방법은 크게 2가지로 이루어져 있다.\n\n1. servlet-context.xml에 등록\n\n2. Java-config 방식을 이용한 등록 -> WebMvcConfigurationSupport 이용하여 등록\n\n\n###  1. Servlet-context.xml에 등록\n\n~~~xml\n<mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/client\"/>\n            <mvc:mapping path=\"/client/test1\"/>\n            <bean id=\"testInterceptor\"\n                  class=\"com.example.springstudy.interceptor.TestInterceptor\"/>\n        </mvc:interceptor>\n</mvc:interceptors>\n~~~\n\n\n\n### 2. WebMvcConfigurationSupport 이용하여 등록\n\n~~~java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.interceptor.TestInterceptor;\nimport com.example.springstudy.interceptor.TestInterceptor2;\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n\nimport java.util.List;\n\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n\n    /**\n    * addInterceptors 메소드를 통해 Interceptor 등록\n    */\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) {\n        super.addInterceptors(registry);\n        //String... 타입으로 여러개 지정 가능\n        registry.addInterceptor(new TestInterceptor())\n                .addPathPatterns(\"/client/test1\", \"/client/help\");\n        //List 타입으로 여러개 지정 가능\n        registry.addInterceptor(new TestInterceptor2())\n                .addPathPatterns(Lists.newArrayList(\"/client\", \"/client/test1\"));\n    }\n}\n\n~~~\n\n\n\n# 참조\n\nhttp://javacan.tistory.com/entry/58\nhttp://www.leafcats.com/39\nhttps://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/","source":"_posts/2018-08-18-spring-filter-interceptor.md","raw":"---\ntitle: Spring Filter와 Interceptor\ncatalog: true\ndate: 2018-08-25 18:30:26\nsubtitle:\nheader-img:\nCategories:\n - Spring\ntags: \n - Spring\n - Spring Core\ntypora-root-url: ./2018-08-18-spring-filter-interceptor\ntypora-copy-images-to: ./2018-08-18-spring-filter-interceptor\n---\n\n# 들어가며..\n\n개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다. \n회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.\nFilter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.\n\n\n\n# Spring Request Flow\n\n![spring-request-lifecycle](./spring-request-lifecycle.jpg)\n\n\n\n이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.\n(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)\n\n\n\n그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.\nFilter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 `J2EE 표준스펙`이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다. \n\nInterceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.\n따라서 Interceptor는 `Spring Framework에서 제공하는 API`이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.\n\n\n\n# Filter\n\n위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.\n실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 `Spring Security, CORS Filter`등이 있다.\n\n\n\n## Filter Chain\n\n![filter-chain](./filter-chain.gif)\n\nFilter의 큰 특징으로는 Filter chain이라는 개념이 있다.\n실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 `Standard Context`에 `FilterMap`이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 `Filter chain`을 구성하게 되어 순차적으로 실행 되게 된다. \n\n* [Request에 대한 Filter Chain 생성](https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705)\n* [Request URL에 대한 FilterMap 생성](https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53)\n\n※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.\n\n\n\nFilter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.\n\n1. url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.\n2. servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.\n\n\n\n## Filter 생성\n\n~~~java\npackage com.example.springstudy.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\npublic class TestFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\t\t//filter 생성 시 처리\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        //다음 Filter 실행 전 처리 (preHandle)\n        \n        //다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)\n\t\tfilterChain.doFilter(servletRequest, servletResponse);\n        \n        //다음 Filter 실행 후 처리 (postHandle)\n    }\n\n    @Override\n    public void destroy() {\n\t\t//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)\n    }\n}\n\n~~~\n\n\n\n## 설정 방법\n\nFilter를 등록하는 방식을 크게 4가지 정도 있다.\n\n1. web.xml 등록 방식\n2. Java config 등록 방식 -> FilterRegistration Bean을 정의하여 추가할 Filter를 정의\n3. java config 등록 방식 -> AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가\n4. @WebFilter Annotation 등록 방식\n\n\n\n### 1. web.xml 등록 방식\n\n```xml\n<filter>\n    <filter-name>testFilter</filter-name>\n    <filter-class>com.example.springstudy.filter.TestFilter</filter-class>\n</filter>\n<filter>\n    <filter-name>testFilter2</filter-name>\n    <filter-class>com.example.springstudy.filter.TestFilter</filter-class>\n</filter>\n\n<filter-mapping>\n    <filter-name>testFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n    <!-- url-pattern 대신 Servlet을 지정할 수도 있다. -->\n    <servlet-name>testServlet</servlet-name> \n</filter-mapping>\n<filter-mapping>\n    <filter-name>testFilter2</filter-name>\n    <url-pattern>/*</url-pattern>\n    <!-- url-pattern 대신 Servlet을 지정할 수도 있다. -->\n    <servlet-name>testServlet</servlet-name> \n</filter-mapping>\n```\n\n\n\n### 2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의\n\n~~~java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class WebApplicationFilterConfig {\n\n    @Bean\n    public FilterRegistrationBean testFilterRegistration() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n        filterRegistrationBean.setFilter(new TestFilter());\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        filterRegistrationBean.setName(\"Test-Filter\");\n        filterRegistrationBean.setOrder(1);\n\n        return filterRegistrationBean;\n    }\n    \n    @Bean\n    public FilterRegistrationBean testFilter2Registration() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n        filterRegistrationBean.setFilter(new TestFilter2());\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        filterRegistrationBean.setName(\"Test-Filter2\");\n        filterRegistrationBean.setOrder(2);\n\n        return filterRegistrationBean;\n    }\n}\n~~~\n\n\n\nFilter chain의 실행 순서는 Filter1(Prehandle) -> Filter2(Prehandle) -> Filter2 (Posthandle) -> Filter1 (Posthandle) 순으로 실행 된다. \n\n\n\n### 3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가\n\n※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)\n\n~~~java\npackage com.example.springstudy.config;\n\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\nimport javax.servlet.Filter;\n\n@Configuration\npublic class WebInitializerConfig extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Filter[] getServletFilters() {\n        //추가할 필터 리스트를 추가한다.\n        return new Filter[]{new TestFilter(), new TestFilter2()};\n    }\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[0];\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class[0];\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[0];\n    }\n}\n\n~~~\n\n\n\n### 4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록\n\n~~~java\npackage com.example.springstudy.filter;\n\nimport org.springframework.core.annotation.Order;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n@Component\n@WebFilter(\n        description = \"1번째 필터\",\n        urlPatterns = \"/*\",\n        filterName = \"Test-Filter1\"\n)\n@Order(2)\npublic class TestFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"start testFilter1\");\n        filterChain.doFilter(servletRequest, servletResponse);\n        System.out.println(\"finish testFilter1\");\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n~~~\n\n다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.\n@Component -> Component-scan 시 Spring Bean으로 등록 된다.\n@WebFIlter -> Filter등록에 필요한 Interface를 제공한다.\n@Order -> @Component 어노테이션 사용 시 `Order Interface` 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다. \n개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.\n\n\n\n# Interceptor\n\n인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.\n\n인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 `preHandle(), postHandle()` 메소드가 구분 되어져 있어, 분기가 명확하다.\n또한 Filter와는 다르게 `handlerMethod`를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.\n\n\n\n## Interceptor 동작 방식\n\n1. 외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.\n2. DispatcherServlet의 doDispatch() 메소드에서 [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013) 메소드로 HandlerExecutionChain를 호출 한다.\n   (정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)\n3.  [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227) 메소드 내부에는 [getHandlerInternal()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401) 메소드로 handler를 가져오는 부분이 있다.\n   이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.\n4. 그 다음 [getHandlerExecutionChain()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480) 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.\n5. 추출 된 interceptor들에 대해 [preHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032) 메소드를 실행 시킨다.\n   (preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)\n6. 그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.\n7. 메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 [postHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044) 메소드를 실행 시킨다.\n\n\n\n## 설정 방법\n\n설정 방법은 크게 2가지로 이루어져 있다.\n\n1. servlet-context.xml에 등록\n\n2. Java-config 방식을 이용한 등록 -> WebMvcConfigurationSupport 이용하여 등록\n\n\n###  1. Servlet-context.xml에 등록\n\n~~~xml\n<mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/client\"/>\n            <mvc:mapping path=\"/client/test1\"/>\n            <bean id=\"testInterceptor\"\n                  class=\"com.example.springstudy.interceptor.TestInterceptor\"/>\n        </mvc:interceptor>\n</mvc:interceptors>\n~~~\n\n\n\n### 2. WebMvcConfigurationSupport 이용하여 등록\n\n~~~java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.interceptor.TestInterceptor;\nimport com.example.springstudy.interceptor.TestInterceptor2;\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n\nimport java.util.List;\n\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n\n    /**\n    * addInterceptors 메소드를 통해 Interceptor 등록\n    */\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) {\n        super.addInterceptors(registry);\n        //String... 타입으로 여러개 지정 가능\n        registry.addInterceptor(new TestInterceptor())\n                .addPathPatterns(\"/client/test1\", \"/client/help\");\n        //List 타입으로 여러개 지정 가능\n        registry.addInterceptor(new TestInterceptor2())\n                .addPathPatterns(Lists.newArrayList(\"/client\", \"/client/test1\"));\n    }\n}\n\n~~~\n\n\n\n# 참조\n\nhttp://javacan.tistory.com/entry/58\nhttp://www.leafcats.com/39\nhttps://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/","slug":"2018-08-18-spring-filter-interceptor","published":1,"updated":"2018-11-27T07:23:32.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv3rf002ucr1t5919901t","content":"<h1 id=\"들어가며\">들어가며..</h1>\n<p>개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다.\n회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.\nFilter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.</p>\n<h1 id=\"spring-request-flow\">Spring Request Flow</h1>\n<p><img src=\"./spring-request-lifecycle.jpg\" alt=\"spring-request-lifecycle\"></p>\n<p>이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.\n(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)</p>\n<p>그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.\nFilter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 <code>J2EE 표준스펙</code>이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다.</p>\n<p>Interceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.\n따라서 Interceptor는 <code>Spring Framework에서 제공하는 API</code>이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.</p>\n<h1 id=\"filter\">Filter</h1>\n<p>위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.\n실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 <code>Spring Security, CORS Filter</code>등이 있다.</p>\n<h2 id=\"filter-chain\">Filter Chain</h2>\n<p><img src=\"./filter-chain.gif\" alt=\"filter-chain\"></p>\n<p>Filter의 큰 특징으로는 Filter chain이라는 개념이 있다.\n실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 <code>Standard Context</code>에 <code>FilterMap</code>이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 <code>Filter chain</code>을 구성하게 되어 순차적으로 실행 되게 된다.</p>\n<ul>\n<li><a href=\"https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705\" target=\"_blank\" rel=\"noopener\">Request에 대한 Filter Chain 생성</a></li>\n<li><a href=\"https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53\" target=\"_blank\" rel=\"noopener\">Request URL에 대한 FilterMap 생성</a></li>\n</ul>\n<p>※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.</p>\n<p>Filter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.</p>\n<ol>\n<li>url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>\n<li>servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>\n</ol>\n<h2 id=\"filter-생성\">Filter 생성</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.annotation.WebFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//filter 생성 시 처리</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//다음 Filter 실행 전 처리 (preHandle)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)</span></span><br><span class=\"line\">\t\tfilterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//다음 Filter 실행 후 처리 (postHandle)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"설정-방법\">설정 방법</h2>\n<p>Filter를 등록하는 방식을 크게 4가지 정도 있다.</p>\n<ol>\n<li>web.xml 등록 방식</li>\n<li>Java config 등록 방식 -&gt; FilterRegistration Bean을 정의하여 추가할 Filter를 정의</li>\n<li>java config 등록 방식 -&gt; AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</li>\n<li>@WebFilter Annotation 등록 방식</li>\n</ol>\n<h3 id=\"1-webxml-등록-방식\">1. web.xml 등록 방식</h3>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-filterregistration-bean을-정의하여-추가할-filter를-정의\">2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.filter.TestFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebApplicationFilterConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">testFilterRegistration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean filterRegistrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        filterRegistrationBean.setFilter(<span class=\"keyword\">new</span> TestFilter());</span><br><span class=\"line\">        filterRegistrationBean.addUrlPatterns(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setName(<span class=\"string\">\"Test-Filter\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setOrder(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">testFilter2Registration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean filterRegistrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        filterRegistrationBean.setFilter(<span class=\"keyword\">new</span> TestFilter2());</span><br><span class=\"line\">        filterRegistrationBean.addUrlPatterns(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setName(<span class=\"string\">\"Test-Filter2\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setOrder(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Filter chain의 실행 순서는 Filter1(Prehandle) -&gt; Filter2(Prehandle) -&gt; Filter2 (Posthandle) -&gt; Filter1 (Posthandle) 순으로 실행 된다.</p>\n<h3 id=\"3-abstractannotationconfigdispatcherservletinitializer에서-getservletfilter에-추가\">3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</h3>\n<p>※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.Filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebInitializerConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Filter[] getServletFilters() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//추가할 필터 리스트를 추가한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Filter[]&#123;<span class=\"keyword\">new</span> TestFilter(), <span class=\"keyword\">new</span> TestFilter2()&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String[] getServletMappings() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-component-webfilter-order-어노테이션을-이용한-필터-등록\">4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.annotation.Order;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.annotation.WebFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@WebFilter</span>(</span><br><span class=\"line\">        description = <span class=\"string\">\"1번째 필터\"</span>,</span><br><span class=\"line\">        urlPatterns = <span class=\"string\">\"/*\"</span>,</span><br><span class=\"line\">        filterName = <span class=\"string\">\"Test-Filter1\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"meta\">@Order</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"start testFilter1\"</span>);</span><br><span class=\"line\">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"finish testFilter1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.\n@Component -&gt; Component-scan 시 Spring Bean으로 등록 된다.\n@WebFIlter -&gt; Filter등록에 필요한 Interface를 제공한다.\n@Order -&gt; @Component 어노테이션 사용 시 <code>Order Interface</code> 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다.\n개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.</p>\n<h1 id=\"interceptor\">Interceptor</h1>\n<p>인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.</p>\n<p>인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 <code>preHandle(), postHandle()</code> 메소드가 구분 되어져 있어, 분기가 명확하다.\n또한 Filter와는 다르게 <code>handlerMethod</code>를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.</p>\n<h2 id=\"interceptor-동작-방식\">Interceptor 동작 방식</h2>\n<ol>\n<li>외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.</li>\n<li>DispatcherServlet의 doDispatch() 메소드에서 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드로 HandlerExecutionChain를 호출 한다.\n(정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드 내부에는 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401\" target=\"_blank\" rel=\"noopener\">getHandlerInternal()</a> 메소드로 handler를 가져오는 부분이 있다.\n이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.</li>\n<li>그 다음 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480\" target=\"_blank\" rel=\"noopener\">getHandlerExecutionChain()</a> 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.</li>\n<li>추출 된 interceptor들에 대해 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032\" target=\"_blank\" rel=\"noopener\">preHandle()</a> 메소드를 실행 시킨다.\n(preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)</li>\n<li>그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.</li>\n<li>메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044\" target=\"_blank\" rel=\"noopener\">postHandle()</a> 메소드를 실행 시킨다.</li>\n</ol>\n<h2 id=\"설정-방법\">설정 방법</h2>\n<p>설정 방법은 크게 2가지로 이루어져 있다.</p>\n<ol>\n<li>\n<p>servlet-context.xml에 등록</p>\n</li>\n<li>\n<p>Java-config 방식을 이용한 등록 -&gt; WebMvcConfigurationSupport 이용하여 등록</p>\n</li>\n</ol>\n<h3 id=\"1-servlet-contextxml에-등록\">1. Servlet-context.xml에 등록</h3>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/client\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/client/test1\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testInterceptor\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                  <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.interceptor.TestInterceptor\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-webmvcconfigurationsupport-이용하여-등록\">2. WebMvcConfigurationSupport 이용하여 등록</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.interceptor.TestInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.interceptor.TestInterceptor2;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * addInterceptors 메소드를 통해 Interceptor 등록</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addInterceptors(registry);</span><br><span class=\"line\">        <span class=\"comment\">//String... 타입으로 여러개 지정 가능</span></span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> TestInterceptor())</span><br><span class=\"line\">                .addPathPatterns(<span class=\"string\">\"/client/test1\"</span>, <span class=\"string\">\"/client/help\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//List 타입으로 여러개 지정 가능</span></span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> TestInterceptor2())</span><br><span class=\"line\">                .addPathPatterns(Lists.newArrayList(<span class=\"string\">\"/client\"</span>, <span class=\"string\">\"/client/test1\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"참조\">참조</h1>\n<p>http://javacan.tistory.com/entry/58\nhttp://www.leafcats.com/39\nhttps://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>들어가며..</h1>\n<p>개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다.\n회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.\nFilter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.</p>\n<h1>Spring Request Flow</h1>\n<p><img src=\"./spring-request-lifecycle.jpg\" alt=\"spring-request-lifecycle\"></p>\n<p>이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.\n(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)</p>\n<p>그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.\nFilter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 <code>J2EE 표준스펙</code>이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다.</p>\n<p>Interceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.\n따라서 Interceptor는 <code>Spring Framework에서 제공하는 API</code>이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.</p>\n<h1>Filter</h1>\n<p>위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.\n실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 <code>Spring Security, CORS Filter</code>등이 있다.</p>\n<h2>Filter Chain</h2>\n<p><img src=\"./filter-chain.gif\" alt=\"filter-chain\"></p>\n<p>Filter의 큰 특징으로는 Filter chain이라는 개념이 있다.\n실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 <code>Standard Context</code>에 <code>FilterMap</code>이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 <code>Filter chain</code>을 구성하게 되어 순차적으로 실행 되게 된다.</p>\n<ul>\n<li><a href=\"https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705\" target=\"_blank\" rel=\"noopener\">Request에 대한 Filter Chain 생성</a></li>\n<li><a href=\"https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53\" target=\"_blank\" rel=\"noopener\">Request URL에 대한 FilterMap 생성</a></li>\n</ul>\n<p>※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.</p>\n<p>Filter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.</p>\n<ol>\n<li>url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>\n<li>servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>\n</ol>\n<h2>Filter 생성</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.annotation.WebFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//filter 생성 시 처리</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//다음 Filter 실행 전 처리 (preHandle)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)</span></span><br><span class=\"line\">\t\tfilterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//다음 Filter 실행 후 처리 (postHandle)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>설정 방법</h2>\n<p>Filter를 등록하는 방식을 크게 4가지 정도 있다.</p>\n<ol>\n<li>web.xml 등록 방식</li>\n<li>Java config 등록 방식 -&gt; FilterRegistration Bean을 정의하여 추가할 Filter를 정의</li>\n<li>java config 등록 방식 -&gt; AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</li>\n<li>@WebFilter Annotation 등록 방식</li>\n</ol>\n<h3>1. web.xml 등록 방식</h3>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3>2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.filter.TestFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebApplicationFilterConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">testFilterRegistration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean filterRegistrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        filterRegistrationBean.setFilter(<span class=\"keyword\">new</span> TestFilter());</span><br><span class=\"line\">        filterRegistrationBean.addUrlPatterns(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setName(<span class=\"string\">\"Test-Filter\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setOrder(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">testFilter2Registration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean filterRegistrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        filterRegistrationBean.setFilter(<span class=\"keyword\">new</span> TestFilter2());</span><br><span class=\"line\">        filterRegistrationBean.addUrlPatterns(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setName(<span class=\"string\">\"Test-Filter2\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setOrder(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Filter chain의 실행 순서는 Filter1(Prehandle) -&gt; Filter2(Prehandle) -&gt; Filter2 (Posthandle) -&gt; Filter1 (Posthandle) 순으로 실행 된다.</p>\n<h3>3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</h3>\n<p>※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.Filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebInitializerConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Filter[] getServletFilters() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//추가할 필터 리스트를 추가한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Filter[]&#123;<span class=\"keyword\">new</span> TestFilter(), <span class=\"keyword\">new</span> TestFilter2()&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String[] getServletMappings() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3>4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.annotation.Order;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.annotation.WebFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@WebFilter</span>(</span><br><span class=\"line\">        description = <span class=\"string\">\"1번째 필터\"</span>,</span><br><span class=\"line\">        urlPatterns = <span class=\"string\">\"/*\"</span>,</span><br><span class=\"line\">        filterName = <span class=\"string\">\"Test-Filter1\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"meta\">@Order</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"start testFilter1\"</span>);</span><br><span class=\"line\">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"finish testFilter1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.\n@Component -&gt; Component-scan 시 Spring Bean으로 등록 된다.\n@WebFIlter -&gt; Filter등록에 필요한 Interface를 제공한다.\n@Order -&gt; @Component 어노테이션 사용 시 <code>Order Interface</code> 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다.\n개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.</p>\n<h1>Interceptor</h1>\n<p>인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.</p>\n<p>인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 <code>preHandle(), postHandle()</code> 메소드가 구분 되어져 있어, 분기가 명확하다.\n또한 Filter와는 다르게 <code>handlerMethod</code>를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.</p>\n<h2>Interceptor 동작 방식</h2>\n<ol>\n<li>외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.</li>\n<li>DispatcherServlet의 doDispatch() 메소드에서 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드로 HandlerExecutionChain를 호출 한다.\n(정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드 내부에는 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401\" target=\"_blank\" rel=\"noopener\">getHandlerInternal()</a> 메소드로 handler를 가져오는 부분이 있다.\n이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.</li>\n<li>그 다음 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480\" target=\"_blank\" rel=\"noopener\">getHandlerExecutionChain()</a> 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.</li>\n<li>추출 된 interceptor들에 대해 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032\" target=\"_blank\" rel=\"noopener\">preHandle()</a> 메소드를 실행 시킨다.\n(preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)</li>\n<li>그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.</li>\n<li>메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044\" target=\"_blank\" rel=\"noopener\">postHandle()</a> 메소드를 실행 시킨다.</li>\n</ol>\n<h2>설정 방법</h2>\n<p>설정 방법은 크게 2가지로 이루어져 있다.</p>\n<ol>\n<li>\n<p>servlet-context.xml에 등록</p>\n</li>\n<li>\n<p>Java-config 방식을 이용한 등록 -&gt; WebMvcConfigurationSupport 이용하여 등록</p>\n</li>\n</ol>\n<h3>1. Servlet-context.xml에 등록</h3>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/client\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/client/test1\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testInterceptor\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                  <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.interceptor.TestInterceptor\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3>2. WebMvcConfigurationSupport 이용하여 등록</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.interceptor.TestInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.interceptor.TestInterceptor2;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * addInterceptors 메소드를 통해 Interceptor 등록</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addInterceptors(registry);</span><br><span class=\"line\">        <span class=\"comment\">//String... 타입으로 여러개 지정 가능</span></span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> TestInterceptor())</span><br><span class=\"line\">                .addPathPatterns(<span class=\"string\">\"/client/test1\"</span>, <span class=\"string\">\"/client/help\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//List 타입으로 여러개 지정 가능</span></span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> TestInterceptor2())</span><br><span class=\"line\">                .addPathPatterns(Lists.newArrayList(<span class=\"string\">\"/client\"</span>, <span class=\"string\">\"/client/test1\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>참조</h1>\n<p>http://javacan.tistory.com/entry/58\nhttp://www.leafcats.com/39\nhttps://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</p>\n"},{"title":"Spring Handle Exception","catalog":true,"date":"2018-08-30T14:30:26.000Z","subtitle":"Spring에서 지원하는 다양한 예외처리 방법","header-img":null,"Categories":["Spring"],"typora-root-url":"./2018-08-25-spring-mvc-handle-exception","typora-copy-images-to":"./2018-08-25-spring-mvc-handle-exception","_content":"\n# 들어가며\n\nSpring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.\nDispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.\nSpring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.\n\n\n\n# 예외(Exception) 처리는 어떻게?\n\nSpring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.\n\n1. Controller 레벨에서 처리\n2. Global 레벨에서 처리\n3. HandlerExceptionResolver를 이용한 처리\n\n\n\n# Controller 레벨에서의 처리\n\nSpring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.\n`@ExceptionHandler` 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.\n\n예제 코드\n\n~~~java\npackage com.example.springstudy.demo2.controller;\n\nimport com.example.springstudy.demo2.exception.DemoException;\nimport com.example.springstudy.demo2.exception.FilterException;\nimport com.example.springstudy.demo2.exception.InterceptorException;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@Slf4j\n@Controller\npublic class DemoController {\n\n    @GetMapping(path=\"/exception/demo\")\n    public String occurDemoException() {\n        //강제로 DemoException을 발생 시켜 보았다.\n        throw new DemoException(); //occur DemoException (RuntimeException)\n    }\n    \n    @GetMapping(path=\"/exception/demo2\")\n    public String occurDemoException2() {\n        //강제로 DemoException을 발생 시켜 보았다.\n        throw new DemoException(); //occur DemoException (RuntimeException)\n    }\n\n    @ExceptionHandler(value=DemoException.class)\n    public String handleDemoException(DemoException e) {\n        log.error(e.getMessage());\n        return \"/error/404\";\n    }\n}\n~~~\n\nDemoController내에서 발생한 DemoException에 대해서는 `handleDemoException` 메소드에서 모두 처리를 해준다.\n\n* Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면` @ExceptionHandler` 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.\n* Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.\n\nSpring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.\n\n\n\n# Global 레벨에서의 처리\n\n만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?\n위의 방식 처럼 Controller 별로 `@ExceptionHandler` 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.\nSpring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.\n\n* `@ControllerAdvice` - Exception 처리 후 Error Page등을 통해 처리가 가능하다.\n* `@RestControllerAdvice`\n  * REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)\n  * @RestControllerAdvice = @ControllerAdvice + @ResponseBody\n\n위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.\n\n**주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!**\n\n\n\n예제 코드\n\n~~~java\nimport com.example.springstudy.demo2.exception.DemoException;\nimport com.example.springstudy.demo2.exception.FilterException;\nimport com.example.springstudy.demo2.exception.InterceptorException;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\n\n@Slf4j\n@ControllerAdvice\npublic class DemoControllerAdvisor {\n\n    //모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리\n    @ExceptionHandler(value = DemoException.class)\n    public String handleDemoExceptionForGlobal(DemoException e) {\n        log.error(e.getMessage());\n        return \"/error/404\";\n    }\n}\n~~~\n\n\n\n## 여기서 궁금한 점...\n\nController 클래스 내에 `@ExceptionHandler`, `@ControllerAdvice` 클래스 내의 `@ExceptionHandler` 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?\n\n\n\n실험을 해보았다.\n준비물은 아래와 같다.\n\n1. DemoException을 throw하는 DemoController1, DemoController2\n2. DemoController1에서는 DemoException에 대해 `@ExceptionHandler`를 구현하였다.\n3. DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.\n4. 전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고\n   `@ExceptionHandler`를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.\n\n\n\n### Test-Case\n\n1. DemoController1 -> throw DemoException\n2. DemoController2 -> throw DemoException\n\n\n\n### 어떤 결과가 나왔을까?\n\n1. DemoController1 -> throw DemoException\n   * 예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.\n   * 예외처리가 끝난 후 404페이지가 리턴 되었다.\n   * `@ControllerAdvice내의 @ExceptionHandler`는 실행 되지 않았다.\n\n   **=> **@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.**\n        더 상위로 Exception을 throw하더라도 `@ControllerAdvice의 @ExceptionHandler`에서 예외처리를 하지 않는다.**\n\n\n\n2. DemoController2 -> throw DemoException\n\n   * 예상대로 DemoControllerAdvice 내의 `@ExceptionHandler` 메소드에서 예외처리가 되었다.\n   * DemoController2에는 `@ExceptionHandler`가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.\n\n\n\n# HandlerExceptionResolver를 이용한 처리\n\nHandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.\n`DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것`이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.\n(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)\n\nHandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.\n\n~~~java\npackage org.springframework.web.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.lang.Nullable;\n\npublic interface HandlerExceptionResolver {\n    @Nullable\n    ModelAndView resolveException(HttpServletRequest var1, HttpServletResponse var2, @Nullable Object var3, Exception var4);\n}\n~~~\n\nDispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.\n사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.\nSpring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.\n\n\n\nDispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.\n\n1. ExceptionHandlerExceptionResolver\n2. ResponseStatusExceptionResolver\n3. DefaultHandlerExceptionResolver\n\n순으로 Resolver가 실행된다.\n\n![image-20180831234615081](./image-20180831234615081.png)\n\n\n\n## ExceptionHandlerExceptionResolver\n\nSpring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.\n위에서 사용한 `@ExceptionHandler` 어노테이션에 대한 Resolver 클래스이다.\n\n\n\n## ResponseStatusExceptionResolver\n\nResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다. \n특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.\n\n사용 예제 (@ExceptionHandler와 함께 사용)\n\n~~~java\n//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.\n//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.\n@ResponseStatus(value = HttpStatus.FORBIDDEN, reason = \"Permission Denied\")\n@ExceptionHandler(value=DemoException.class)\npublic String handleDemoException(DemoException e) {\n    log.error(e.getMessage());\n    return \"/error/403\";\n}\n~~~\n\n![image-20180831235454808](./image-20180831235454808.png)\n\n위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.\n(403에 대한 페이지는 못만들었다 ^^;)\n\n\n\n## DefaultHandlerExceptionResolver\n\nDispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 `DefaultHandlerExceptionResolver`에서 예외처리를 해준다.\n\nDefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.\n각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다. \n\n* Request URL에 맞는 Controller를 못찾는 경우 ==> 404 Not Found\n* Controller 메소드 실행 중 예외가 발생하는 경우 ==> 500 Internal Server error\n* Controller의 파라미터 형식이 잘못된 경우 ==> 400 Bad Request\n\n\n\n## SimpleMappingExceptionResolver\n\nSimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.\nException별로 error-page를 매핑할 수 있는 기능을 제공한다.\n\n설정방법은 2가지로 설명하도록 하겠다.\n\n1. Java config 방식\n\n~~~java\n@Configuration\n@EnableWebMvc\npublic WebMvcConfig extends WebMvcConfigurerAdapter {\n    @Bean(name=“customMappingExceptionResolver”)\n    public SimpleMappingExceptionResolver customMappingExceptionResolver() {\n    \tSimpleMappingExceptionResolver r = new SimpleMappingExceptionResolver();\n\n        Properties mappings = new Properties();\n        mappings.setProperty(\"DatabaseException\", \"databaseError\");\n        mappings.setProperty(\"DemoException\", \"demoError\");\n\n        r.setExceptionMappings(mappings);  \n        r.setDefaultErrorView(\"default-error-page\");    \n        r.setExceptionAttribute(\"ex\");     \n        return r;\n    }\n}\n~~~\n\n2. xml 방식\n\n~~~xml\n<bean id=\"simpleMappingExceptionResolver\" class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\n    <property name=\"exceptionMappings\"> \n        <map> \n            <entry key=\"DatabaseException\" value=\"databaseError\"/> \n            <entry key=\"DemoException\" value=\"demoError\"/> \n        </map> \n    </property> \n    <property name=\"defaultErrorView\" value=\"error\"/> \n    <property name=\"exceptionAttribute\" value=\"ex\"/>\n</bean>\n~~~\n\n\n\n자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.\n근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?\n\n# 다시 한번 Spring MVC를 보자 (자꾸 보게되네?)\n\n![spring-mvc-request](./spring-mvc-request.jpg)\n\n\n\nSpring MVC의 대한 처리는 99프로가 `Dispatcher Servlet`에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.\n하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 `HandlerExceptionResolver`의 처리를 받을 수 없다. 이럴때는 어떡할건가?\n지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.\n\n\n\n# Filter에서 예외가 발생하면?\n\nfilter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.\n\nFilter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.\n\n* web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현\n* Filter 내부에서 try-catch 구문을 통해 예외 발생 시, `request.getRequestDispatcher(String)`를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.\n  (웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.\n   Interceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)\n\n\n\n# 참조\n\nhttps://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc\nhttps://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver\nhttp://www.nextree.co.kr/p3239/\nhttp://springsource.tistory.com/7\nhttp://stewie38.tistory.com/59\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/","source":"_posts/2018-08-25-spring-mvc-handle-exception.md","raw":"---\ntitle: Spring Handle Exception\ncatalog: true\ndate: 2018-08-30 23:30:26\nsubtitle: Spring에서 지원하는 다양한 예외처리 방법\nheader-img:\nCategories:\n - Spring\ntags: \n - Spring\n - Spring Core\ntypora-root-url: ./2018-08-25-spring-mvc-handle-exception\ntypora-copy-images-to: ./2018-08-25-spring-mvc-handle-exception\n---\n\n# 들어가며\n\nSpring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.\nDispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.\nSpring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.\n\n\n\n# 예외(Exception) 처리는 어떻게?\n\nSpring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.\n\n1. Controller 레벨에서 처리\n2. Global 레벨에서 처리\n3. HandlerExceptionResolver를 이용한 처리\n\n\n\n# Controller 레벨에서의 처리\n\nSpring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.\n`@ExceptionHandler` 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.\n\n예제 코드\n\n~~~java\npackage com.example.springstudy.demo2.controller;\n\nimport com.example.springstudy.demo2.exception.DemoException;\nimport com.example.springstudy.demo2.exception.FilterException;\nimport com.example.springstudy.demo2.exception.InterceptorException;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@Slf4j\n@Controller\npublic class DemoController {\n\n    @GetMapping(path=\"/exception/demo\")\n    public String occurDemoException() {\n        //강제로 DemoException을 발생 시켜 보았다.\n        throw new DemoException(); //occur DemoException (RuntimeException)\n    }\n    \n    @GetMapping(path=\"/exception/demo2\")\n    public String occurDemoException2() {\n        //강제로 DemoException을 발생 시켜 보았다.\n        throw new DemoException(); //occur DemoException (RuntimeException)\n    }\n\n    @ExceptionHandler(value=DemoException.class)\n    public String handleDemoException(DemoException e) {\n        log.error(e.getMessage());\n        return \"/error/404\";\n    }\n}\n~~~\n\nDemoController내에서 발생한 DemoException에 대해서는 `handleDemoException` 메소드에서 모두 처리를 해준다.\n\n* Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면` @ExceptionHandler` 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.\n* Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.\n\nSpring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.\n\n\n\n# Global 레벨에서의 처리\n\n만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?\n위의 방식 처럼 Controller 별로 `@ExceptionHandler` 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.\nSpring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.\n\n* `@ControllerAdvice` - Exception 처리 후 Error Page등을 통해 처리가 가능하다.\n* `@RestControllerAdvice`\n  * REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)\n  * @RestControllerAdvice = @ControllerAdvice + @ResponseBody\n\n위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.\n\n**주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!**\n\n\n\n예제 코드\n\n~~~java\nimport com.example.springstudy.demo2.exception.DemoException;\nimport com.example.springstudy.demo2.exception.FilterException;\nimport com.example.springstudy.demo2.exception.InterceptorException;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\n\n@Slf4j\n@ControllerAdvice\npublic class DemoControllerAdvisor {\n\n    //모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리\n    @ExceptionHandler(value = DemoException.class)\n    public String handleDemoExceptionForGlobal(DemoException e) {\n        log.error(e.getMessage());\n        return \"/error/404\";\n    }\n}\n~~~\n\n\n\n## 여기서 궁금한 점...\n\nController 클래스 내에 `@ExceptionHandler`, `@ControllerAdvice` 클래스 내의 `@ExceptionHandler` 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?\n\n\n\n실험을 해보았다.\n준비물은 아래와 같다.\n\n1. DemoException을 throw하는 DemoController1, DemoController2\n2. DemoController1에서는 DemoException에 대해 `@ExceptionHandler`를 구현하였다.\n3. DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.\n4. 전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고\n   `@ExceptionHandler`를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.\n\n\n\n### Test-Case\n\n1. DemoController1 -> throw DemoException\n2. DemoController2 -> throw DemoException\n\n\n\n### 어떤 결과가 나왔을까?\n\n1. DemoController1 -> throw DemoException\n   * 예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.\n   * 예외처리가 끝난 후 404페이지가 리턴 되었다.\n   * `@ControllerAdvice내의 @ExceptionHandler`는 실행 되지 않았다.\n\n   **=> **@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.**\n        더 상위로 Exception을 throw하더라도 `@ControllerAdvice의 @ExceptionHandler`에서 예외처리를 하지 않는다.**\n\n\n\n2. DemoController2 -> throw DemoException\n\n   * 예상대로 DemoControllerAdvice 내의 `@ExceptionHandler` 메소드에서 예외처리가 되었다.\n   * DemoController2에는 `@ExceptionHandler`가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.\n\n\n\n# HandlerExceptionResolver를 이용한 처리\n\nHandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.\n`DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것`이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.\n(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)\n\nHandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.\n\n~~~java\npackage org.springframework.web.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.lang.Nullable;\n\npublic interface HandlerExceptionResolver {\n    @Nullable\n    ModelAndView resolveException(HttpServletRequest var1, HttpServletResponse var2, @Nullable Object var3, Exception var4);\n}\n~~~\n\nDispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.\n사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.\nSpring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.\n\n\n\nDispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.\n\n1. ExceptionHandlerExceptionResolver\n2. ResponseStatusExceptionResolver\n3. DefaultHandlerExceptionResolver\n\n순으로 Resolver가 실행된다.\n\n![image-20180831234615081](./image-20180831234615081.png)\n\n\n\n## ExceptionHandlerExceptionResolver\n\nSpring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.\n위에서 사용한 `@ExceptionHandler` 어노테이션에 대한 Resolver 클래스이다.\n\n\n\n## ResponseStatusExceptionResolver\n\nResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다. \n특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.\n\n사용 예제 (@ExceptionHandler와 함께 사용)\n\n~~~java\n//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.\n//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.\n@ResponseStatus(value = HttpStatus.FORBIDDEN, reason = \"Permission Denied\")\n@ExceptionHandler(value=DemoException.class)\npublic String handleDemoException(DemoException e) {\n    log.error(e.getMessage());\n    return \"/error/403\";\n}\n~~~\n\n![image-20180831235454808](./image-20180831235454808.png)\n\n위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.\n(403에 대한 페이지는 못만들었다 ^^;)\n\n\n\n## DefaultHandlerExceptionResolver\n\nDispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 `DefaultHandlerExceptionResolver`에서 예외처리를 해준다.\n\nDefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.\n각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다. \n\n* Request URL에 맞는 Controller를 못찾는 경우 ==> 404 Not Found\n* Controller 메소드 실행 중 예외가 발생하는 경우 ==> 500 Internal Server error\n* Controller의 파라미터 형식이 잘못된 경우 ==> 400 Bad Request\n\n\n\n## SimpleMappingExceptionResolver\n\nSimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.\nException별로 error-page를 매핑할 수 있는 기능을 제공한다.\n\n설정방법은 2가지로 설명하도록 하겠다.\n\n1. Java config 방식\n\n~~~java\n@Configuration\n@EnableWebMvc\npublic WebMvcConfig extends WebMvcConfigurerAdapter {\n    @Bean(name=“customMappingExceptionResolver”)\n    public SimpleMappingExceptionResolver customMappingExceptionResolver() {\n    \tSimpleMappingExceptionResolver r = new SimpleMappingExceptionResolver();\n\n        Properties mappings = new Properties();\n        mappings.setProperty(\"DatabaseException\", \"databaseError\");\n        mappings.setProperty(\"DemoException\", \"demoError\");\n\n        r.setExceptionMappings(mappings);  \n        r.setDefaultErrorView(\"default-error-page\");    \n        r.setExceptionAttribute(\"ex\");     \n        return r;\n    }\n}\n~~~\n\n2. xml 방식\n\n~~~xml\n<bean id=\"simpleMappingExceptionResolver\" class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\n    <property name=\"exceptionMappings\"> \n        <map> \n            <entry key=\"DatabaseException\" value=\"databaseError\"/> \n            <entry key=\"DemoException\" value=\"demoError\"/> \n        </map> \n    </property> \n    <property name=\"defaultErrorView\" value=\"error\"/> \n    <property name=\"exceptionAttribute\" value=\"ex\"/>\n</bean>\n~~~\n\n\n\n자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.\n근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?\n\n# 다시 한번 Spring MVC를 보자 (자꾸 보게되네?)\n\n![spring-mvc-request](./spring-mvc-request.jpg)\n\n\n\nSpring MVC의 대한 처리는 99프로가 `Dispatcher Servlet`에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.\n하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 `HandlerExceptionResolver`의 처리를 받을 수 없다. 이럴때는 어떡할건가?\n지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.\n\n\n\n# Filter에서 예외가 발생하면?\n\nfilter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.\n\nFilter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.\n\n* web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현\n* Filter 내부에서 try-catch 구문을 통해 예외 발생 시, `request.getRequestDispatcher(String)`를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.\n  (웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.\n   Interceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)\n\n\n\n# 참조\n\nhttps://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc\nhttps://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver\nhttp://www.nextree.co.kr/p3239/\nhttp://springsource.tistory.com/7\nhttp://stewie38.tistory.com/59\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/","slug":"2018-08-25-spring-mvc-handle-exception","published":1,"updated":"2018-11-27T07:23:32.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv3rg002wcr1tg0nkpx9j","content":"<h1 id=\"들어가며\">들어가며</h1>\n<p>Spring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.\nDispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.\nSpring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.</p>\n<h1 id=\"예외exception-처리는-어떻게\">예외(Exception) 처리는 어떻게?</h1>\n<p>Spring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.</p>\n<ol>\n<li>Controller 레벨에서 처리</li>\n<li>Global 레벨에서 처리</li>\n<li>HandlerExceptionResolver를 이용한 처리</li>\n</ol>\n<h1 id=\"controller-레벨에서의-처리\">Controller 레벨에서의 처리</h1>\n<p>Spring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.\n<code>@ExceptionHandler</code> 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.</p>\n<p>예제 코드</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo2.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(path=<span class=\"string\">\"/exception/demo\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">occurDemoException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DemoException(); <span class=\"comment\">//occur DemoException (RuntimeException)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(path=<span class=\"string\">\"/exception/demo2\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">occurDemoException2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DemoException(); <span class=\"comment\">//occur DemoException (RuntimeException)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value=DemoException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoException</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">        log.error(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"/error/404\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>DemoController내에서 발생한 DemoException에 대해서는 <code>handleDemoException</code> 메소드에서 모두 처리를 해준다.</p>\n<ul>\n<li>Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면<code>@ExceptionHandler</code> 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.</li>\n<li>Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.</li>\n</ul>\n<p>Spring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.</p>\n<h1 id=\"global-레벨에서의-처리\">Global 레벨에서의 처리</h1>\n<p>만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?\n위의 방식 처럼 Controller 별로 <code>@ExceptionHandler</code> 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.\nSpring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.</p>\n<ul>\n<li><code>@ControllerAdvice</code> - Exception 처리 후 Error Page등을 통해 처리가 가능하다.</li>\n<li><code>@RestControllerAdvice</code>\n<ul>\n<li>REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)</li>\n<li>@RestControllerAdvice = @ControllerAdvice + @ResponseBody</li>\n</ul>\n</li>\n</ul>\n<p>위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.</p>\n<p><strong>주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!</strong></p>\n<p>예제 코드</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@ControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoControllerAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리</span></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value = DemoException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoExceptionForGlobal</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">        log.error(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"/error/404\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"여기서-궁금한-점\">여기서 궁금한 점...</h2>\n<p>Controller 클래스 내에 <code>@ExceptionHandler</code>, <code>@ControllerAdvice</code> 클래스 내의 <code>@ExceptionHandler</code> 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?</p>\n<p>실험을 해보았다.\n준비물은 아래와 같다.</p>\n<ol>\n<li>DemoException을 throw하는 DemoController1, DemoController2</li>\n<li>DemoController1에서는 DemoException에 대해 <code>@ExceptionHandler</code>를 구현하였다.</li>\n<li>DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.</li>\n<li>전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고\n<code>@ExceptionHandler</code>를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.</li>\n</ol>\n<h3 id=\"test-case\">Test-Case</h3>\n<ol>\n<li>DemoController1 -&gt; throw DemoException</li>\n<li>DemoController2 -&gt; throw DemoException</li>\n</ol>\n<h3 id=\"어떤-결과가-나왔을까\">어떤 결과가 나왔을까?</h3>\n<ol>\n<li>\n<p>DemoController1 -&gt; throw DemoException</p>\n<ul>\n<li>예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.</li>\n<li>예외처리가 끝난 후 404페이지가 리턴 되었다.</li>\n<li><code>@ControllerAdvice내의 @ExceptionHandler</code>는 실행 되지 않았다.</li>\n</ul>\n<p><strong>=&gt; <strong>@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.</strong>\n더 상위로 Exception을 throw하더라도 <code>@ControllerAdvice의 @ExceptionHandler</code>에서 예외처리를 하지 않는다.</strong></p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>DemoController2 -&gt; throw DemoException</p>\n<ul>\n<li>예상대로 DemoControllerAdvice 내의 <code>@ExceptionHandler</code> 메소드에서 예외처리가 되었다.</li>\n<li>DemoController2에는 <code>@ExceptionHandler</code>가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"handlerexceptionresolver를-이용한-처리\">HandlerExceptionResolver를 이용한 처리</h1>\n<p>HandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.\n<code>DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것</code>이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.\n(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)</p>\n<p>HandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.web.servlet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.lang.Nullable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandlerExceptionResolver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"function\">ModelAndView <span class=\"title\">resolveException</span><span class=\"params\">(HttpServletRequest var1, HttpServletResponse var2, @Nullable Object var3, Exception var4)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>DispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.\n사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.\nSpring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.</p>\n<p>Dispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.</p>\n<ol>\n<li>ExceptionHandlerExceptionResolver</li>\n<li>ResponseStatusExceptionResolver</li>\n<li>DefaultHandlerExceptionResolver</li>\n</ol>\n<p>순으로 Resolver가 실행된다.</p>\n<p><img src=\"./image-20180831234615081.png\" alt=\"image-20180831234615081\"></p>\n<h2 id=\"exceptionhandlerexceptionresolver\">ExceptionHandlerExceptionResolver</h2>\n<p>Spring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.\n위에서 사용한 <code>@ExceptionHandler</code> 어노테이션에 대한 Resolver 클래스이다.</p>\n<h2 id=\"responsestatusexceptionresolver\">ResponseStatusExceptionResolver</h2>\n<p>ResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다.\n특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.</p>\n<p>사용 예제 (@ExceptionHandler와 함께 사용)</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseStatus</span>(value = HttpStatus.FORBIDDEN, reason = <span class=\"string\">\"Permission Denied\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ExceptionHandler</span>(value=DemoException.class)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoException</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">    log.error(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"/error/403\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./image-20180831235454808.png\" alt=\"image-20180831235454808\"></p>\n<p>위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.\n(403에 대한 페이지는 못만들었다 ^^;)</p>\n<h2 id=\"defaulthandlerexceptionresolver\">DefaultHandlerExceptionResolver</h2>\n<p>DispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 <code>DefaultHandlerExceptionResolver</code>에서 예외처리를 해준다.</p>\n<p>DefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.\n각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다.</p>\n<ul>\n<li>Request URL에 맞는 Controller를 못찾는 경우 ==&gt; 404 Not Found</li>\n<li>Controller 메소드 실행 중 예외가 발생하는 경우 ==&gt; 500 Internal Server error</li>\n<li>Controller의 파라미터 형식이 잘못된 경우 ==&gt; 400 Bad Request</li>\n</ul>\n<h2 id=\"simplemappingexceptionresolver\">SimpleMappingExceptionResolver</h2>\n<p>SimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.\nException별로 error-page를 매핑할 수 있는 기능을 제공한다.</p>\n<p>설정방법은 2가지로 설명하도록 하겠다.</p>\n<ol>\n<li>Java config 방식</li>\n</ol>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> WebMvcConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=“customMappingExceptionResolver”)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SimpleMappingExceptionResolver <span class=\"title\">customMappingExceptionResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \tSimpleMappingExceptionResolver r = <span class=\"keyword\">new</span> SimpleMappingExceptionResolver();</span><br><span class=\"line\"></span><br><span class=\"line\">        Properties mappings = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        mappings.setProperty(<span class=\"string\">\"DatabaseException\"</span>, <span class=\"string\">\"databaseError\"</span>);</span><br><span class=\"line\">        mappings.setProperty(<span class=\"string\">\"DemoException\"</span>, <span class=\"string\">\"demoError\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        r.setExceptionMappings(mappings);  </span><br><span class=\"line\">        r.setDefaultErrorView(<span class=\"string\">\"default-error-page\"</span>);    </span><br><span class=\"line\">        r.setExceptionAttribute(<span class=\"string\">\"ex\"</span>);     </span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>xml 방식</li>\n</ol>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"simpleMappingExceptionResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionMappings\"</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span> </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"DatabaseException\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"databaseError\"</span>/&gt;</span> </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"DemoException\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"demoError\"</span>/&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"defaultErrorView\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"error\"</span>/&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionAttribute\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"ex\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.\n근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?</p>\n<h1 id=\"다시-한번-spring-mvc를-보자-자꾸-보게되네\">다시 한번 Spring MVC를 보자 (자꾸 보게되네?)</h1>\n<p><img src=\"./spring-mvc-request.jpg\" alt=\"spring-mvc-request\"></p>\n<p>Spring MVC의 대한 처리는 99프로가 <code>Dispatcher Servlet</code>에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.\n하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 <code>HandlerExceptionResolver</code>의 처리를 받을 수 없다. 이럴때는 어떡할건가?\n지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.</p>\n<h1 id=\"filter에서-예외가-발생하면\">Filter에서 예외가 발생하면?</h1>\n<p>filter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.</p>\n<p>Filter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.</p>\n<ul>\n<li>web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현</li>\n<li>Filter 내부에서 try-catch 구문을 통해 예외 발생 시, <code>request.getRequestDispatcher(String)</code>를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.\n(웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.\nInterceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)</li>\n</ul>\n<h1 id=\"참조\">참조</h1>\n<p>https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc\nhttps://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver\nhttp://www.nextree.co.kr/p3239/\nhttp://springsource.tistory.com/7\nhttp://stewie38.tistory.com/59\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>Spring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.\nDispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.\nSpring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.</p>\n<h1>예외(Exception) 처리는 어떻게?</h1>\n<p>Spring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.</p>\n<ol>\n<li>Controller 레벨에서 처리</li>\n<li>Global 레벨에서 처리</li>\n<li>HandlerExceptionResolver를 이용한 처리</li>\n</ol>\n<h1>Controller 레벨에서의 처리</h1>\n<p>Spring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.\n<code>@ExceptionHandler</code> 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.</p>\n<p>예제 코드</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo2.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(path=<span class=\"string\">\"/exception/demo\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">occurDemoException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DemoException(); <span class=\"comment\">//occur DemoException (RuntimeException)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(path=<span class=\"string\">\"/exception/demo2\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">occurDemoException2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DemoException(); <span class=\"comment\">//occur DemoException (RuntimeException)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value=DemoException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoException</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">        log.error(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"/error/404\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>DemoController내에서 발생한 DemoException에 대해서는 <code>handleDemoException</code> 메소드에서 모두 처리를 해준다.</p>\n<ul>\n<li>Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면<code>@ExceptionHandler</code> 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.</li>\n<li>Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.</li>\n</ul>\n<p>Spring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.</p>\n<h1>Global 레벨에서의 처리</h1>\n<p>만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?\n위의 방식 처럼 Controller 별로 <code>@ExceptionHandler</code> 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.\nSpring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.</p>\n<ul>\n<li><code>@ControllerAdvice</code> - Exception 처리 후 Error Page등을 통해 처리가 가능하다.</li>\n<li><code>@RestControllerAdvice</code>\n<ul>\n<li>REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)</li>\n<li>@RestControllerAdvice = @ControllerAdvice + @ResponseBody</li>\n</ul>\n</li>\n</ul>\n<p>위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.</p>\n<p><strong>주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!</strong></p>\n<p>예제 코드</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@ControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoControllerAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리</span></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value = DemoException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoExceptionForGlobal</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">        log.error(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"/error/404\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>여기서 궁금한 점...</h2>\n<p>Controller 클래스 내에 <code>@ExceptionHandler</code>, <code>@ControllerAdvice</code> 클래스 내의 <code>@ExceptionHandler</code> 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?</p>\n<p>실험을 해보았다.\n준비물은 아래와 같다.</p>\n<ol>\n<li>DemoException을 throw하는 DemoController1, DemoController2</li>\n<li>DemoController1에서는 DemoException에 대해 <code>@ExceptionHandler</code>를 구현하였다.</li>\n<li>DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.</li>\n<li>전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고\n<code>@ExceptionHandler</code>를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.</li>\n</ol>\n<h3>Test-Case</h3>\n<ol>\n<li>DemoController1 -&gt; throw DemoException</li>\n<li>DemoController2 -&gt; throw DemoException</li>\n</ol>\n<h3>어떤 결과가 나왔을까?</h3>\n<ol>\n<li>\n<p>DemoController1 -&gt; throw DemoException</p>\n<ul>\n<li>예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.</li>\n<li>예외처리가 끝난 후 404페이지가 리턴 되었다.</li>\n<li><code>@ControllerAdvice내의 @ExceptionHandler</code>는 실행 되지 않았다.</li>\n</ul>\n<p><strong>=&gt; <strong>@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.</strong>\n더 상위로 Exception을 throw하더라도 <code>@ControllerAdvice의 @ExceptionHandler</code>에서 예외처리를 하지 않는다.</strong></p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>DemoController2 -&gt; throw DemoException</p>\n<ul>\n<li>예상대로 DemoControllerAdvice 내의 <code>@ExceptionHandler</code> 메소드에서 예외처리가 되었다.</li>\n<li>DemoController2에는 <code>@ExceptionHandler</code>가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.</li>\n</ul>\n</li>\n</ol>\n<h1>HandlerExceptionResolver를 이용한 처리</h1>\n<p>HandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.\n<code>DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것</code>이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.\n(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)</p>\n<p>HandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.web.servlet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.lang.Nullable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandlerExceptionResolver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"function\">ModelAndView <span class=\"title\">resolveException</span><span class=\"params\">(HttpServletRequest var1, HttpServletResponse var2, @Nullable Object var3, Exception var4)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>DispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.\n사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.\nSpring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.</p>\n<p>Dispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.</p>\n<ol>\n<li>ExceptionHandlerExceptionResolver</li>\n<li>ResponseStatusExceptionResolver</li>\n<li>DefaultHandlerExceptionResolver</li>\n</ol>\n<p>순으로 Resolver가 실행된다.</p>\n<p><img src=\"./image-20180831234615081.png\" alt=\"image-20180831234615081\"></p>\n<h2>ExceptionHandlerExceptionResolver</h2>\n<p>Spring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.\n위에서 사용한 <code>@ExceptionHandler</code> 어노테이션에 대한 Resolver 클래스이다.</p>\n<h2>ResponseStatusExceptionResolver</h2>\n<p>ResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다.\n특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.</p>\n<p>사용 예제 (@ExceptionHandler와 함께 사용)</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseStatus</span>(value = HttpStatus.FORBIDDEN, reason = <span class=\"string\">\"Permission Denied\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ExceptionHandler</span>(value=DemoException.class)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoException</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">    log.error(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"/error/403\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./image-20180831235454808.png\" alt=\"image-20180831235454808\"></p>\n<p>위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.\n(403에 대한 페이지는 못만들었다 ^^;)</p>\n<h2>DefaultHandlerExceptionResolver</h2>\n<p>DispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 <code>DefaultHandlerExceptionResolver</code>에서 예외처리를 해준다.</p>\n<p>DefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.\n각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다.</p>\n<ul>\n<li>Request URL에 맞는 Controller를 못찾는 경우 ==&gt; 404 Not Found</li>\n<li>Controller 메소드 실행 중 예외가 발생하는 경우 ==&gt; 500 Internal Server error</li>\n<li>Controller의 파라미터 형식이 잘못된 경우 ==&gt; 400 Bad Request</li>\n</ul>\n<h2>SimpleMappingExceptionResolver</h2>\n<p>SimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.\nException별로 error-page를 매핑할 수 있는 기능을 제공한다.</p>\n<p>설정방법은 2가지로 설명하도록 하겠다.</p>\n<ol>\n<li>Java config 방식</li>\n</ol>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> WebMvcConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=“customMappingExceptionResolver”)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SimpleMappingExceptionResolver <span class=\"title\">customMappingExceptionResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \tSimpleMappingExceptionResolver r = <span class=\"keyword\">new</span> SimpleMappingExceptionResolver();</span><br><span class=\"line\"></span><br><span class=\"line\">        Properties mappings = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        mappings.setProperty(<span class=\"string\">\"DatabaseException\"</span>, <span class=\"string\">\"databaseError\"</span>);</span><br><span class=\"line\">        mappings.setProperty(<span class=\"string\">\"DemoException\"</span>, <span class=\"string\">\"demoError\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        r.setExceptionMappings(mappings);  </span><br><span class=\"line\">        r.setDefaultErrorView(<span class=\"string\">\"default-error-page\"</span>);    </span><br><span class=\"line\">        r.setExceptionAttribute(<span class=\"string\">\"ex\"</span>);     </span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>xml 방식</li>\n</ol>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"simpleMappingExceptionResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionMappings\"</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span> </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"DatabaseException\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"databaseError\"</span>/&gt;</span> </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"DemoException\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"demoError\"</span>/&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"defaultErrorView\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"error\"</span>/&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionAttribute\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"ex\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.\n근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?</p>\n<h1>다시 한번 Spring MVC를 보자 (자꾸 보게되네?)</h1>\n<p><img src=\"./spring-mvc-request.jpg\" alt=\"spring-mvc-request\"></p>\n<p>Spring MVC의 대한 처리는 99프로가 <code>Dispatcher Servlet</code>에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.\n하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 <code>HandlerExceptionResolver</code>의 처리를 받을 수 없다. 이럴때는 어떡할건가?\n지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.</p>\n<h1>Filter에서 예외가 발생하면?</h1>\n<p>filter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.</p>\n<p>Filter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.</p>\n<ul>\n<li>web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현</li>\n<li>Filter 내부에서 try-catch 구문을 통해 예외 발생 시, <code>request.getRequestDispatcher(String)</code>를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.\n(웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.\nInterceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)</li>\n</ul>\n<h1>참조</h1>\n<p>https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc\nhttps://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver\nhttp://www.nextree.co.kr/p3239/\nhttp://springsource.tistory.com/7\nhttp://stewie38.tistory.com/59\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</p>\n"},{"title":"Java Exception","catalog":true,"date":"2018-08-29T15:07:03.000Z","subtitle":"Java의 기본 예외처리","header-img":null,"Categories":["Java"],"typora-root-url":"./2018-08-29-java-exception","typora-copy-images-to":"./2018-08-29-java-exception","_content":"\n\n# 들어가며\n\nJava/Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.\n예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.\n이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.\n\n\n\n# 에러(Error)와 예외(Exception)\n\n![Exception-Class](./Exception-Class.png)\n\nJava에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.\nException은 또 2가지 종류로 구분 할 수 있다.\n\n* Error \n  * 주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.\n  * 주로 `복구 불가능한 상황`에 대해 사용한다.\n  * 주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.\n  * 관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.\n    (어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)\n* Checked Exception \n  * 점검지정 예외\n  * Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.\n  * 예외처리를 하지 않을 시, `컴파일 오류가 발생`\n  * 주로 `복구 가능한 상황`에 Checked Exception을 사용한다.\n  * Custom Checked Exception을 만들 경우 `Exception` 클래스를 상속하여 만든다.\n* Unchecked Exception\n  * 무점검 예외\n  * 프로그래밍 오류를 표현하는 경우 사용\n  * 개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.\n  * 주로 `복구 불가능한 상황`에 대해 사용한다.\n  * Custom Unchecked Exception을 만들 경우 `RuntimeException` 클래스를 상속하여 만든다\n\n\n\n## 추가적으로..\n\n개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.\n아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.\nChecked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.\n지원자가 했던 \"Checked Exception 절대 쓰지 말자!\" \"Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!\"라는 의견도 어느정도는 맞는 소리이다.\n새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의....로 간다고 하면 밑에서 부터 계속 throw..throw.. 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다. \n다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.\n\n\n\n# Java에서의 기본적인 예외처리\n\n## try-catch-finally\n\ntry-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.\n프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.\n\n~~~java\ntry {\n    //핵심 로직 수행\n} catch(Exception e) {\n    //예외 발생 시, 예외에 대한 처리\n} finally {\n   //try block, catch block 실행 후 반드시 실행하는 로직\n   //주로 자원에 대한 해제 로직이 추가된다. \n}\n~~~\n\n\n\n## try-catch-resources\n\nJava 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.\n\n~~~java\ntry (InputStream is = new FileInputStream(file)) { \n     //try block이 종료 되면 InputStream에 대한 close() 메소드를 실행\n     //핵심 로직 수행\n} catch (Exception e) {\n    //예외 발생 시, 예외에 대한 처리\n}\n~~~\n\n\n\n## Multi catch\n\nJava 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.\n\n~~~java\ntry (InputStream is = new FileInputStream(file)) { \n     //try block이 종료 되면 InputStream에 대한 close() 메소드를 실행\n     //핵심 로직 수행\n} catch (NullPointerException | ArrayIndexBoundException e) {\n    //예외 발생 시, 예외에 대한 처리\n}\n~~~\n\n\n\n# Exception Handling\n\nChecked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.\n\n* Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기\n* try-catch구문을 통한 예외처리를 하도록 유도\n\n보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.\n하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.\n\n\n\n# Anti Pattern\n\n1. Exception을 무시 하지 말 것\n2. exception.printStackTrace()는 쓰는게 아니다.\n3. 반복문 내에서는 Checked Exception에 대한 처리는 지양하자\n\n\n\n## Exception을 무시 하지 말 것 \n\n간혹 코드를 보다 보면..\n\n~~~java\ntry {\n    //열심히 작성\n    veryHardDo();\n} catch (Exception e) {\n    //아무것도 안해요~\n}\n~~~\n\n이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고.. 막상 catch구문에 작성할 코드는 없어보이고... 할 때 저런 코드들이 나오게 된다.\n이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고.. 왜 에러나는지 모르는 코드가 되어버린다. \n되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자.. (로그라도 남겨줘 ㅜㅜ)\n\n\n\n## exception.printStackTrace()는 쓰는게 아니다.\n\nexception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)\n하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.\n\n\n\n## 반복문 내에서는 Checked Exception에 대한 처리는 지양하자\n\n~~~java\nfor (String item : items) {\n    try {\n        insert(item);\n    }catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n~~~\n\n반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.\n이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.\n\n\n\n# 참조\n\nEffective Java 2nd Edition (Joshua Bloch)\n가장 빨리 만나는 자바8 (카이 호스트만)","source":"_posts/2018-08-29-java-exception.md","raw":"---\ntitle: Java Exception\ncatalog: true\ndate: 2018-08-30 00:07:03\nsubtitle: Java의 기본 예외처리\nheader-img:\nCategories:\n - Java\ntags: \n - Java\ntypora-root-url: ./2018-08-29-java-exception\ntypora-copy-images-to: ./2018-08-29-java-exception\n---\n\n\n# 들어가며\n\nJava/Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.\n예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.\n이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.\n\n\n\n# 에러(Error)와 예외(Exception)\n\n![Exception-Class](./Exception-Class.png)\n\nJava에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.\nException은 또 2가지 종류로 구분 할 수 있다.\n\n* Error \n  * 주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.\n  * 주로 `복구 불가능한 상황`에 대해 사용한다.\n  * 주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.\n  * 관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.\n    (어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)\n* Checked Exception \n  * 점검지정 예외\n  * Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.\n  * 예외처리를 하지 않을 시, `컴파일 오류가 발생`\n  * 주로 `복구 가능한 상황`에 Checked Exception을 사용한다.\n  * Custom Checked Exception을 만들 경우 `Exception` 클래스를 상속하여 만든다.\n* Unchecked Exception\n  * 무점검 예외\n  * 프로그래밍 오류를 표현하는 경우 사용\n  * 개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.\n  * 주로 `복구 불가능한 상황`에 대해 사용한다.\n  * Custom Unchecked Exception을 만들 경우 `RuntimeException` 클래스를 상속하여 만든다\n\n\n\n## 추가적으로..\n\n개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.\n아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.\nChecked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.\n지원자가 했던 \"Checked Exception 절대 쓰지 말자!\" \"Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!\"라는 의견도 어느정도는 맞는 소리이다.\n새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의....로 간다고 하면 밑에서 부터 계속 throw..throw.. 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다. \n다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.\n\n\n\n# Java에서의 기본적인 예외처리\n\n## try-catch-finally\n\ntry-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.\n프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.\n\n~~~java\ntry {\n    //핵심 로직 수행\n} catch(Exception e) {\n    //예외 발생 시, 예외에 대한 처리\n} finally {\n   //try block, catch block 실행 후 반드시 실행하는 로직\n   //주로 자원에 대한 해제 로직이 추가된다. \n}\n~~~\n\n\n\n## try-catch-resources\n\nJava 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.\n\n~~~java\ntry (InputStream is = new FileInputStream(file)) { \n     //try block이 종료 되면 InputStream에 대한 close() 메소드를 실행\n     //핵심 로직 수행\n} catch (Exception e) {\n    //예외 발생 시, 예외에 대한 처리\n}\n~~~\n\n\n\n## Multi catch\n\nJava 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.\n\n~~~java\ntry (InputStream is = new FileInputStream(file)) { \n     //try block이 종료 되면 InputStream에 대한 close() 메소드를 실행\n     //핵심 로직 수행\n} catch (NullPointerException | ArrayIndexBoundException e) {\n    //예외 발생 시, 예외에 대한 처리\n}\n~~~\n\n\n\n# Exception Handling\n\nChecked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.\n\n* Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기\n* try-catch구문을 통한 예외처리를 하도록 유도\n\n보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.\n하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.\n\n\n\n# Anti Pattern\n\n1. Exception을 무시 하지 말 것\n2. exception.printStackTrace()는 쓰는게 아니다.\n3. 반복문 내에서는 Checked Exception에 대한 처리는 지양하자\n\n\n\n## Exception을 무시 하지 말 것 \n\n간혹 코드를 보다 보면..\n\n~~~java\ntry {\n    //열심히 작성\n    veryHardDo();\n} catch (Exception e) {\n    //아무것도 안해요~\n}\n~~~\n\n이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고.. 막상 catch구문에 작성할 코드는 없어보이고... 할 때 저런 코드들이 나오게 된다.\n이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고.. 왜 에러나는지 모르는 코드가 되어버린다. \n되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자.. (로그라도 남겨줘 ㅜㅜ)\n\n\n\n## exception.printStackTrace()는 쓰는게 아니다.\n\nexception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)\n하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.\n\n\n\n## 반복문 내에서는 Checked Exception에 대한 처리는 지양하자\n\n~~~java\nfor (String item : items) {\n    try {\n        insert(item);\n    }catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n~~~\n\n반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.\n이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.\n\n\n\n# 참조\n\nEffective Java 2nd Edition (Joshua Bloch)\n가장 빨리 만나는 자바8 (카이 호스트만)","slug":"2018-08-29-java-exception","published":1,"updated":"2018-11-27T07:23:32.369Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv3rh002xcr1t3ic89qen","content":"<h1 id=\"들어가며\">들어가며</h1>\n<p>Java/Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.\n예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.\n이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.</p>\n<h1 id=\"에러error와-예외exception\">에러(Error)와 예외(Exception)</h1>\n<p><img src=\"./Exception-Class.png\" alt=\"Exception-Class\"></p>\n<p>Java에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.\nException은 또 2가지 종류로 구분 할 수 있다.</p>\n<ul>\n<li>Error\n<ul>\n<li>주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.</li>\n<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>\n<li>주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.</li>\n<li>관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.\n(어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)</li>\n</ul>\n</li>\n<li>Checked Exception\n<ul>\n<li>점검지정 예외</li>\n<li>Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.</li>\n<li>예외처리를 하지 않을 시, <code>컴파일 오류가 발생</code></li>\n<li>주로 <code>복구 가능한 상황</code>에 Checked Exception을 사용한다.</li>\n<li>Custom Checked Exception을 만들 경우 <code>Exception</code> 클래스를 상속하여 만든다.</li>\n</ul>\n</li>\n<li>Unchecked Exception\n<ul>\n<li>무점검 예외</li>\n<li>프로그래밍 오류를 표현하는 경우 사용</li>\n<li>개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.</li>\n<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>\n<li>Custom Unchecked Exception을 만들 경우 <code>RuntimeException</code> 클래스를 상속하여 만든다</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"추가적으로\">추가적으로..</h2>\n<p>개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.\n아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.\nChecked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.\n지원자가 했던 &quot;Checked Exception 절대 쓰지 말자!&quot; &quot;Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!&quot;라는 의견도 어느정도는 맞는 소리이다.\n새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의....로 간다고 하면 밑에서 부터 계속 throw..throw.. 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다.\n다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.</p>\n<h1 id=\"java에서의-기본적인-예외처리\">Java에서의 기본적인 예외처리</h1>\n<h2 id=\"try-catch-finally\">try-catch-finally</h2>\n<p>try-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.\n프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//try block, catch block 실행 후 반드시 실행하는 로직</span></span><br><span class=\"line\">   <span class=\"comment\">//주로 자원에 대한 해제 로직이 추가된다. </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"try-catch-resources\">try-catch-resources</h2>\n<p>Java 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream is = <span class=\"keyword\">new</span> FileInputStream(file)) &#123; </span><br><span class=\"line\">     <span class=\"comment\">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class=\"line\">     <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"multi-catch\">Multi catch</h2>\n<p>Java 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream is = <span class=\"keyword\">new</span> FileInputStream(file)) &#123; </span><br><span class=\"line\">     <span class=\"comment\">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class=\"line\">     <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (NullPointerException | ArrayIndexBoundException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"exception-handling\">Exception Handling</h1>\n<p>Checked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.</p>\n<ul>\n<li>Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기</li>\n<li>try-catch구문을 통한 예외처리를 하도록 유도</li>\n</ul>\n<p>보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.\n하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.</p>\n<h1 id=\"anti-pattern\">Anti Pattern</h1>\n<ol>\n<li>Exception을 무시 하지 말 것</li>\n<li>exception.printStackTrace()는 쓰는게 아니다.</li>\n<li>반복문 내에서는 Checked Exception에 대한 처리는 지양하자</li>\n</ol>\n<h2 id=\"exception을-무시-하지-말-것\">Exception을 무시 하지 말 것</h2>\n<p>간혹 코드를 보다 보면..</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//열심히 작성</span></span><br><span class=\"line\">    veryHardDo();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//아무것도 안해요~</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고.. 막상 catch구문에 작성할 코드는 없어보이고... 할 때 저런 코드들이 나오게 된다.\n이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고.. 왜 에러나는지 모르는 코드가 되어버린다.\n되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자.. (로그라도 남겨줘 ㅜㅜ)</p>\n<h2 id=\"exceptionprintstacktrace는-쓰는게-아니다\">exception.printStackTrace()는 쓰는게 아니다.</h2>\n<p>exception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)\n하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.</p>\n<h2 id=\"반복문-내에서는-checked-exception에-대한-처리는-지양하자\">반복문 내에서는 Checked Exception에 대한 처리는 지양하자</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (String item : items) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        insert(item);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.\n이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.</p>\n<h1 id=\"참조\">참조</h1>\n<p>Effective Java 2nd Edition (Joshua Bloch)\n가장 빨리 만나는 자바8 (카이 호스트만)</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>Java/Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.\n예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.\n이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.</p>\n<h1>에러(Error)와 예외(Exception)</h1>\n<p><img src=\"./Exception-Class.png\" alt=\"Exception-Class\"></p>\n<p>Java에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.\nException은 또 2가지 종류로 구분 할 수 있다.</p>\n<ul>\n<li>Error\n<ul>\n<li>주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.</li>\n<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>\n<li>주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.</li>\n<li>관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.\n(어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)</li>\n</ul>\n</li>\n<li>Checked Exception\n<ul>\n<li>점검지정 예외</li>\n<li>Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.</li>\n<li>예외처리를 하지 않을 시, <code>컴파일 오류가 발생</code></li>\n<li>주로 <code>복구 가능한 상황</code>에 Checked Exception을 사용한다.</li>\n<li>Custom Checked Exception을 만들 경우 <code>Exception</code> 클래스를 상속하여 만든다.</li>\n</ul>\n</li>\n<li>Unchecked Exception\n<ul>\n<li>무점검 예외</li>\n<li>프로그래밍 오류를 표현하는 경우 사용</li>\n<li>개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.</li>\n<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>\n<li>Custom Unchecked Exception을 만들 경우 <code>RuntimeException</code> 클래스를 상속하여 만든다</li>\n</ul>\n</li>\n</ul>\n<h2>추가적으로..</h2>\n<p>개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.\n아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.\nChecked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.\n지원자가 했던 &quot;Checked Exception 절대 쓰지 말자!&quot; &quot;Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!&quot;라는 의견도 어느정도는 맞는 소리이다.\n새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의....로 간다고 하면 밑에서 부터 계속 throw..throw.. 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다.\n다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.</p>\n<h1>Java에서의 기본적인 예외처리</h1>\n<h2>try-catch-finally</h2>\n<p>try-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.\n프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//try block, catch block 실행 후 반드시 실행하는 로직</span></span><br><span class=\"line\">   <span class=\"comment\">//주로 자원에 대한 해제 로직이 추가된다. </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>try-catch-resources</h2>\n<p>Java 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream is = <span class=\"keyword\">new</span> FileInputStream(file)) &#123; </span><br><span class=\"line\">     <span class=\"comment\">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class=\"line\">     <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>Multi catch</h2>\n<p>Java 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream is = <span class=\"keyword\">new</span> FileInputStream(file)) &#123; </span><br><span class=\"line\">     <span class=\"comment\">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class=\"line\">     <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (NullPointerException | ArrayIndexBoundException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>Exception Handling</h1>\n<p>Checked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.</p>\n<ul>\n<li>Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기</li>\n<li>try-catch구문을 통한 예외처리를 하도록 유도</li>\n</ul>\n<p>보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.\n하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.</p>\n<h1>Anti Pattern</h1>\n<ol>\n<li>Exception을 무시 하지 말 것</li>\n<li>exception.printStackTrace()는 쓰는게 아니다.</li>\n<li>반복문 내에서는 Checked Exception에 대한 처리는 지양하자</li>\n</ol>\n<h2>Exception을 무시 하지 말 것</h2>\n<p>간혹 코드를 보다 보면..</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//열심히 작성</span></span><br><span class=\"line\">    veryHardDo();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//아무것도 안해요~</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고.. 막상 catch구문에 작성할 코드는 없어보이고... 할 때 저런 코드들이 나오게 된다.\n이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고.. 왜 에러나는지 모르는 코드가 되어버린다.\n되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자.. (로그라도 남겨줘 ㅜㅜ)</p>\n<h2>exception.printStackTrace()는 쓰는게 아니다.</h2>\n<p>exception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)\n하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.</p>\n<h2>반복문 내에서는 Checked Exception에 대한 처리는 지양하자</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (String item : items) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        insert(item);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.\n이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.</p>\n<h1>참조</h1>\n<p>Effective Java 2nd Edition (Joshua Bloch)\n가장 빨리 만나는 자바8 (카이 호스트만)</p>\n"},{"title":"Servlet이란?","catalog":true,"date":"2018-09-01T04:50:06.000Z","subtitle":"Servlet.. 항상 이름만 들어본 그대여","header-img":null,"Categories":["Spring"],"typora-root-url":"./2018-09-01-servlet","typora-copy-images-to":"./2018-09-01-servlet","_content":"\n![servlet](./servlet.png)\n\n# 들어가며\n\n약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, \"이렇게 코딩하면 이렇게 동작하네~\" 라는 생각만 가지고 개발을 해왔었다. 근 1~2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 \"이게 이래서 이렇게 동작하는구나~\" 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.\n\n최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.\n\n\n# Servlet\n\nServlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데... 이제와서 알아보게 되었다.\n\nServlet의 정의에 대해 찾아보게 되었다. (출처 : [wikipedia](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF))\n\n>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 \"서블릿\"이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.\n\n결국은 `웹 서버에서 돌아가는 Java 코드`라는 뜻이다.\nJava 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.\n`HttpServlet` 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.\n\n\n\n## **Servlet의 특징**\n\n* Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술\n* 흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.\n* 클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.\n* Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.\n  (doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)\n* 클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다. \n  (WAS 내의 Thread pool의 Thread 객체를 이용한다.)\n* Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다\n  (내부적으로 Sington을 구현하고 있지는 않다고한다.)\n  여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.\n* 요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.\n  (오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)\n* MVC에서 컨트롤러로 이용됨..\n\n\n# Servlet Container\n\nServlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?\n당연히 있다. WAS라고 불리우는 프로그램이 있다.\nJava 진영에서 자주 사용하는 WAS는 단연 으뜸으로 `Apache Tomcat`이 있다. \n(다른거로는 `Jeus`나, `jBoss` 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)\n\nWAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.\n\n* Web Server (apache, nginx)와의 통신 지원\n  * 클라이언트 요청(Request)에 대한 Socket 통신 지원\n\n* Servlet Lifecycle 관리\n\n* Client 접근 URL에 대한 Servlet Mapping \n* 클라이언트 요청(Request)에 대한 멀티 스레드 관리\n* 선언적인 보안관리\n  * 보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.\n  * Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문\n  * DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.\n    대표적인 예로 Spring Security가 있다.\n\n\n\n\n# Servlet LifeCycle\n\n![Servlet-life-cycle](./Servlet-life-cycle.png)\n\nServlet의 LifeCycle은 3단계로 이루어 진다.\n\n* init() \n  *  WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.\n  * 주로 Servlet 객체에 대한 초기화 로직을 작성한다.\n  * 실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고\n    다시 서블릿 생성과 동시에 init()이 실행\n* service()\n  * Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.\n    (doGet(), doPost(), doPut(), doDel())\n* destroy()\n  * WAS shutdown 시 호출 된다.\n  * 주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다\n  * 자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.\n\n\n\n# Servlet 설정하기\n\n## Servlet class 생성하기\n\n~~~java\npackage com.example.springstudy.demo3.servlet;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@Slf4j\n@WebServlet(name=\"demoServlet\", url-pattern=\"/servlet/demo\")\npublic class DemoServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        log.info(\"doGet() 실행실행실행!!!\");\n        Thread thread = Thread.currentThread();\n        log.info(\"Thread ID : \" + thread.getId());\n        super.doGet(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n\n    @Override\n    public void destroy() {\n        log.info(\"Servlet destroy()\");\n        super.destroy();\n    }\n\n    @Override\n    public void init() throws ServletException {\n        log.info(\"Servlet init()\");\n        super.init();\n    }\n}\n\n~~~\n\n@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.\n(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)\n\n기본적으로 Servlet 클래스 생성은 `HttpServlet` 클래스를 상속 받아 생성한다.\nHttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.\n\n\n\n## web.xml 기반 설정\n\n~~~xml\n<servlet>\n     <servlet-name>demoServlet</servlet-name>\n     <servlet-class>com.example.springstudy.demo3.servlet.DemoServlet</servlet-class>\n</servlet>\n\n<servlet-mapping>\n    <servlet-name>demoServlet</servlet-name> \n    <url-pattern>/servlet/demo</url-pattern> \n</servlet-mapping>\n~~~\n\nweb.xml에 servlet 클래스를 선언하고 <servlet-mapping> 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.\n\n\n\n## Java Config 기반 설정\n\n~~~java\npackage com.example.springstudy.demo3.config;\n\nimport com.example.springstudy.demo3.servlet.DemoServlet;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class DemoServletConfig {\n\n    @Bean\n    public ServletRegistrationBean demoServletRegistrationBean() {\n        ServletRegistrationBean demoServletRegistrationBean = new ServletRegistrationBean();\n        demoServletRegistrationBean.setServlet(new DemoServlet());\n        demoServletRegistrationBean.addUrlMappings(\"/servlet/demo\");\n        return demoServletRegistrationBean;\n    }\n}\n\n~~~\n\n@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.\nServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.\n\n\n\n\n\n# JSP vs Servlet\n\n**JSP와 Servlet의 차이점**\n\n* JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태\n* Servlet은 html 태그가 out.println(\"<html>\") 형태로 들어간 형태\n\n\n\n## JSP -> Servlet 변환 과정\n\n![jspToServlet](./jspToServlet.jpeg)\n\n\n\nServlet의 최종 형태는 out.println(\"<html>\") 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.\n\n\n\n# 참조\n\nhttp://mangkyu.tistory.com/14\nhttp://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\nhttp://til0804.tistory.com/25","source":"_posts/2018-09-01-servlet.md","raw":"---\ntitle: Servlet이란?\ncatalog: true\ndate: 2018-09-01 13:50:06\nsubtitle: Servlet.. 항상 이름만 들어본 그대여\nheader-img:\nCategories:\n - Spring\ntags: \n - Spring\n - J2EE\ntypora-root-url: ./2018-09-01-servlet\ntypora-copy-images-to: ./2018-09-01-servlet\n---\n\n![servlet](./servlet.png)\n\n# 들어가며\n\n약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, \"이렇게 코딩하면 이렇게 동작하네~\" 라는 생각만 가지고 개발을 해왔었다. 근 1~2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 \"이게 이래서 이렇게 동작하는구나~\" 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.\n\n최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.\n\n\n# Servlet\n\nServlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데... 이제와서 알아보게 되었다.\n\nServlet의 정의에 대해 찾아보게 되었다. (출처 : [wikipedia](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF))\n\n>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 \"서블릿\"이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.\n\n결국은 `웹 서버에서 돌아가는 Java 코드`라는 뜻이다.\nJava 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.\n`HttpServlet` 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.\n\n\n\n## **Servlet의 특징**\n\n* Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술\n* 흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.\n* 클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.\n* Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.\n  (doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)\n* 클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다. \n  (WAS 내의 Thread pool의 Thread 객체를 이용한다.)\n* Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다\n  (내부적으로 Sington을 구현하고 있지는 않다고한다.)\n  여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.\n* 요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.\n  (오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)\n* MVC에서 컨트롤러로 이용됨..\n\n\n# Servlet Container\n\nServlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?\n당연히 있다. WAS라고 불리우는 프로그램이 있다.\nJava 진영에서 자주 사용하는 WAS는 단연 으뜸으로 `Apache Tomcat`이 있다. \n(다른거로는 `Jeus`나, `jBoss` 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)\n\nWAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.\n\n* Web Server (apache, nginx)와의 통신 지원\n  * 클라이언트 요청(Request)에 대한 Socket 통신 지원\n\n* Servlet Lifecycle 관리\n\n* Client 접근 URL에 대한 Servlet Mapping \n* 클라이언트 요청(Request)에 대한 멀티 스레드 관리\n* 선언적인 보안관리\n  * 보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.\n  * Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문\n  * DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.\n    대표적인 예로 Spring Security가 있다.\n\n\n\n\n# Servlet LifeCycle\n\n![Servlet-life-cycle](./Servlet-life-cycle.png)\n\nServlet의 LifeCycle은 3단계로 이루어 진다.\n\n* init() \n  *  WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.\n  * 주로 Servlet 객체에 대한 초기화 로직을 작성한다.\n  * 실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고\n    다시 서블릿 생성과 동시에 init()이 실행\n* service()\n  * Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.\n    (doGet(), doPost(), doPut(), doDel())\n* destroy()\n  * WAS shutdown 시 호출 된다.\n  * 주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다\n  * 자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.\n\n\n\n# Servlet 설정하기\n\n## Servlet class 생성하기\n\n~~~java\npackage com.example.springstudy.demo3.servlet;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@Slf4j\n@WebServlet(name=\"demoServlet\", url-pattern=\"/servlet/demo\")\npublic class DemoServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        log.info(\"doGet() 실행실행실행!!!\");\n        Thread thread = Thread.currentThread();\n        log.info(\"Thread ID : \" + thread.getId());\n        super.doGet(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n\n    @Override\n    public void destroy() {\n        log.info(\"Servlet destroy()\");\n        super.destroy();\n    }\n\n    @Override\n    public void init() throws ServletException {\n        log.info(\"Servlet init()\");\n        super.init();\n    }\n}\n\n~~~\n\n@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.\n(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)\n\n기본적으로 Servlet 클래스 생성은 `HttpServlet` 클래스를 상속 받아 생성한다.\nHttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.\n\n\n\n## web.xml 기반 설정\n\n~~~xml\n<servlet>\n     <servlet-name>demoServlet</servlet-name>\n     <servlet-class>com.example.springstudy.demo3.servlet.DemoServlet</servlet-class>\n</servlet>\n\n<servlet-mapping>\n    <servlet-name>demoServlet</servlet-name> \n    <url-pattern>/servlet/demo</url-pattern> \n</servlet-mapping>\n~~~\n\nweb.xml에 servlet 클래스를 선언하고 <servlet-mapping> 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.\n\n\n\n## Java Config 기반 설정\n\n~~~java\npackage com.example.springstudy.demo3.config;\n\nimport com.example.springstudy.demo3.servlet.DemoServlet;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class DemoServletConfig {\n\n    @Bean\n    public ServletRegistrationBean demoServletRegistrationBean() {\n        ServletRegistrationBean demoServletRegistrationBean = new ServletRegistrationBean();\n        demoServletRegistrationBean.setServlet(new DemoServlet());\n        demoServletRegistrationBean.addUrlMappings(\"/servlet/demo\");\n        return demoServletRegistrationBean;\n    }\n}\n\n~~~\n\n@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.\nServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.\n\n\n\n\n\n# JSP vs Servlet\n\n**JSP와 Servlet의 차이점**\n\n* JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태\n* Servlet은 html 태그가 out.println(\"<html>\") 형태로 들어간 형태\n\n\n\n## JSP -> Servlet 변환 과정\n\n![jspToServlet](./jspToServlet.jpeg)\n\n\n\nServlet의 최종 형태는 out.println(\"<html>\") 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.\n\n\n\n# 참조\n\nhttp://mangkyu.tistory.com/14\nhttp://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\nhttp://til0804.tistory.com/25","slug":"2018-09-01-servlet","published":1,"updated":"2018-12-22T10:58:30.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv3ri002ycr1tqey5uu4s","content":"<p><img src=\"./servlet.png\" alt=\"servlet\"></p>\n<h1 id=\"들어가며\">들어가며</h1>\n<p>약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, &quot;이렇게 코딩하면 이렇게 동작하네~&quot; 라는 생각만 가지고 개발을 해왔었다. 근 1~2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 &quot;이게 이래서 이렇게 동작하는구나~&quot; 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.</p>\n<p>최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.</p>\n<h1 id=\"servlet\">Servlet</h1>\n<p>Servlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데... 이제와서 알아보게 되었다.</p>\n<p>Servlet의 정의에 대해 찾아보게 되었다. (출처 : <a href=\"https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF\" target=\"_blank\" rel=\"noopener\">wikipedia</a>)</p>\n<blockquote>\n<p>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 &quot;서블릿&quot;이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.</p>\n</blockquote>\n<p>결국은 <code>웹 서버에서 돌아가는 Java 코드</code>라는 뜻이다.\nJava 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.\n<code>HttpServlet</code> 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.</p>\n<h2 id=\"servlet의-특징\"><strong>Servlet의 특징</strong></h2>\n<ul>\n<li>Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술</li>\n<li>흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.</li>\n<li>클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.</li>\n<li>Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.\n(doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)</li>\n<li>클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다.\n(WAS 내의 Thread pool의 Thread 객체를 이용한다.)</li>\n<li>Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다\n(내부적으로 Sington을 구현하고 있지는 않다고한다.)\n여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.</li>\n<li>요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.\n(오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)</li>\n<li>MVC에서 컨트롤러로 이용됨..</li>\n</ul>\n<h1 id=\"servlet-container\">Servlet Container</h1>\n<p>Servlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?\n당연히 있다. WAS라고 불리우는 프로그램이 있다.\nJava 진영에서 자주 사용하는 WAS는 단연 으뜸으로 <code>Apache Tomcat</code>이 있다.\n(다른거로는 <code>Jeus</code>나, <code>jBoss</code> 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)</p>\n<p>WAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.</p>\n<ul>\n<li>\n<p>Web Server (apache, nginx)와의 통신 지원</p>\n<ul>\n<li>클라이언트 요청(Request)에 대한 Socket 통신 지원</li>\n</ul>\n</li>\n<li>\n<p>Servlet Lifecycle 관리</p>\n</li>\n<li>\n<p>Client 접근 URL에 대한 Servlet Mapping</p>\n</li>\n<li>\n<p>클라이언트 요청(Request)에 대한 멀티 스레드 관리</p>\n</li>\n<li>\n<p>선언적인 보안관리</p>\n<ul>\n<li>보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.</li>\n<li>Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문</li>\n<li>DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.\n대표적인 예로 Spring Security가 있다.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"servlet-lifecycle\">Servlet LifeCycle</h1>\n<p><img src=\"./Servlet-life-cycle.png\" alt=\"Servlet-life-cycle\"></p>\n<p>Servlet의 LifeCycle은 3단계로 이루어 진다.</p>\n<ul>\n<li>init()\n<ul>\n<li>WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.</li>\n<li>주로 Servlet 객체에 대한 초기화 로직을 작성한다.</li>\n<li>실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고\n다시 서블릿 생성과 동시에 init()이 실행</li>\n</ul>\n</li>\n<li>service()\n<ul>\n<li>Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.\n(doGet(), doPost(), doPut(), doDel())</li>\n</ul>\n</li>\n<li>destroy()\n<ul>\n<li>WAS shutdown 시 호출 된다.</li>\n<li>주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다</li>\n<li>자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"servlet-설정하기\">Servlet 설정하기</h1>\n<h2 id=\"servlet-class-생성하기\">Servlet class 생성하기</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo3.servlet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@WebServlet</span>(name=<span class=\"string\">\"demoServlet\"</span>, url-pattern=<span class=\"string\">\"/servlet/demo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"doGet() 실행실행실행!!!\"</span>);</span><br><span class=\"line\">        Thread thread = Thread.currentThread();</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Thread ID : \"</span> + thread.getId());</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doGet(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doPost(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Servlet destroy()\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Servlet init()\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.\n(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)</p>\n<p>기본적으로 Servlet 클래스 생성은 <code>HttpServlet</code> 클래스를 상속 받아 생성한다.\nHttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.</p>\n<h2 id=\"webxml-기반-설정\">web.xml 기반 설정</h2>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.example.springstudy.demo3.servlet.DemoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/servlet/demo<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>web.xml에 servlet 클래스를 선언하고 &lt;servlet-mapping&gt; 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.</p>\n<h2 id=\"java-config-기반-설정\">Java Config 기반 설정</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo3.servlet.DemoServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServletConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServletRegistrationBean <span class=\"title\">demoServletRegistrationBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ServletRegistrationBean demoServletRegistrationBean = <span class=\"keyword\">new</span> ServletRegistrationBean();</span><br><span class=\"line\">        demoServletRegistrationBean.setServlet(<span class=\"keyword\">new</span> DemoServlet());</span><br><span class=\"line\">        demoServletRegistrationBean.addUrlMappings(<span class=\"string\">\"/servlet/demo\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> demoServletRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.\nServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.</p>\n<h1 id=\"jsp-vs-servlet\">JSP vs Servlet</h1>\n<p><strong>JSP와 Servlet의 차이점</strong></p>\n<ul>\n<li>JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태</li>\n<li>Servlet은 html 태그가 out.println(&quot;&lt;html&gt;&quot;) 형태로 들어간 형태</li>\n</ul>\n<h2 id=\"jsp-gt-servlet-변환-과정\">JSP -&gt; Servlet 변환 과정</h2>\n<p><img src=\"./jspToServlet.jpeg\" alt=\"jspToServlet\"></p>\n<p>Servlet의 최종 형태는 out.println(&quot;&lt;html&gt;&quot;) 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.</p>\n<h1 id=\"참조\">참조</h1>\n<p>http://mangkyu.tistory.com/14\nhttp://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\nhttp://til0804.tistory.com/25</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<p><img src=\"./servlet.png\" alt=\"servlet\"></p>\n<h1>들어가며</h1>\n<p>약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, &quot;이렇게 코딩하면 이렇게 동작하네~&quot; 라는 생각만 가지고 개발을 해왔었다. 근 1~2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 &quot;이게 이래서 이렇게 동작하는구나~&quot; 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.</p>\n<p>최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.</p>\n<h1>Servlet</h1>\n<p>Servlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데... 이제와서 알아보게 되었다.</p>\n<p>Servlet의 정의에 대해 찾아보게 되었다. (출처 : <a href=\"https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF\" target=\"_blank\" rel=\"noopener\">wikipedia</a>)</p>\n<blockquote>\n<p>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 &quot;서블릿&quot;이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.</p>\n</blockquote>\n<p>결국은 <code>웹 서버에서 돌아가는 Java 코드</code>라는 뜻이다.\nJava 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.\n<code>HttpServlet</code> 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.</p>\n<h2><strong>Servlet의 특징</strong></h2>\n<ul>\n<li>Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술</li>\n<li>흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.</li>\n<li>클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.</li>\n<li>Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.\n(doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)</li>\n<li>클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다.\n(WAS 내의 Thread pool의 Thread 객체를 이용한다.)</li>\n<li>Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다\n(내부적으로 Sington을 구현하고 있지는 않다고한다.)\n여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.</li>\n<li>요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.\n(오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)</li>\n<li>MVC에서 컨트롤러로 이용됨..</li>\n</ul>\n<h1>Servlet Container</h1>\n<p>Servlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?\n당연히 있다. WAS라고 불리우는 프로그램이 있다.\nJava 진영에서 자주 사용하는 WAS는 단연 으뜸으로 <code>Apache Tomcat</code>이 있다.\n(다른거로는 <code>Jeus</code>나, <code>jBoss</code> 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)</p>\n<p>WAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.</p>\n<ul>\n<li>\n<p>Web Server (apache, nginx)와의 통신 지원</p>\n<ul>\n<li>클라이언트 요청(Request)에 대한 Socket 통신 지원</li>\n</ul>\n</li>\n<li>\n<p>Servlet Lifecycle 관리</p>\n</li>\n<li>\n<p>Client 접근 URL에 대한 Servlet Mapping</p>\n</li>\n<li>\n<p>클라이언트 요청(Request)에 대한 멀티 스레드 관리</p>\n</li>\n<li>\n<p>선언적인 보안관리</p>\n<ul>\n<li>보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.</li>\n<li>Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문</li>\n<li>DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.\n대표적인 예로 Spring Security가 있다.</li>\n</ul>\n</li>\n</ul>\n<h1>Servlet LifeCycle</h1>\n<p><img src=\"./Servlet-life-cycle.png\" alt=\"Servlet-life-cycle\"></p>\n<p>Servlet의 LifeCycle은 3단계로 이루어 진다.</p>\n<ul>\n<li>init()\n<ul>\n<li>WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.</li>\n<li>주로 Servlet 객체에 대한 초기화 로직을 작성한다.</li>\n<li>실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고\n다시 서블릿 생성과 동시에 init()이 실행</li>\n</ul>\n</li>\n<li>service()\n<ul>\n<li>Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.\n(doGet(), doPost(), doPut(), doDel())</li>\n</ul>\n</li>\n<li>destroy()\n<ul>\n<li>WAS shutdown 시 호출 된다.</li>\n<li>주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다</li>\n<li>자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.</li>\n</ul>\n</li>\n</ul>\n<h1>Servlet 설정하기</h1>\n<h2>Servlet class 생성하기</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo3.servlet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@WebServlet</span>(name=<span class=\"string\">\"demoServlet\"</span>, url-pattern=<span class=\"string\">\"/servlet/demo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"doGet() 실행실행실행!!!\"</span>);</span><br><span class=\"line\">        Thread thread = Thread.currentThread();</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Thread ID : \"</span> + thread.getId());</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doGet(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doPost(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Servlet destroy()\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Servlet init()\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.\n(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)</p>\n<p>기본적으로 Servlet 클래스 생성은 <code>HttpServlet</code> 클래스를 상속 받아 생성한다.\nHttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.</p>\n<h2>web.xml 기반 설정</h2>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.example.springstudy.demo3.servlet.DemoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/servlet/demo<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>web.xml에 servlet 클래스를 선언하고 &lt;servlet-mapping&gt; 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.</p>\n<h2>Java Config 기반 설정</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo3.servlet.DemoServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServletConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServletRegistrationBean <span class=\"title\">demoServletRegistrationBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ServletRegistrationBean demoServletRegistrationBean = <span class=\"keyword\">new</span> ServletRegistrationBean();</span><br><span class=\"line\">        demoServletRegistrationBean.setServlet(<span class=\"keyword\">new</span> DemoServlet());</span><br><span class=\"line\">        demoServletRegistrationBean.addUrlMappings(<span class=\"string\">\"/servlet/demo\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> demoServletRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.\nServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.</p>\n<h1>JSP vs Servlet</h1>\n<p><strong>JSP와 Servlet의 차이점</strong></p>\n<ul>\n<li>JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태</li>\n<li>Servlet은 html 태그가 out.println(&quot;&lt;html&gt;&quot;) 형태로 들어간 형태</li>\n</ul>\n<h2>JSP -&gt; Servlet 변환 과정</h2>\n<p><img src=\"./jspToServlet.jpeg\" alt=\"jspToServlet\"></p>\n<p>Servlet의 최종 형태는 out.println(&quot;&lt;html&gt;&quot;) 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.</p>\n<h1>참조</h1>\n<p>http://mangkyu.tistory.com/14\nhttp://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\nhttp://til0804.tistory.com/25</p>\n"},{"title":"Spring IoC & DI(1) - IoC 등장배경(과정)","subtitle":"IoC/DI의 발전과정","header-img":null,"catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-09-12-spring-ioc","typora-copy-images-to":"./2018-09-12-spring-ioc","date":"2018-09-21T14:33:21.000Z","_content":"\n\n\n# IoC 등장배경\n\nIoC의 등장배경을 알기 위해서는 EJB나 Spring과 같은 프레임워크를 사용하기 이전 시대의 개발 방식에 대해 얘기를 해야한다.\n온고지신(?)이라 하였던가.. IoC를 이해하기 위해 옛날이야기를 해보도록 하겠다.\n\n태초에 Java로 만든 프로그램은 main()이라는 메소드에서 시작이 되었다.\nmain() 메소드 내에서 필요한 클래스를 개발자가 직접 코드내에서 생성하여 사용하였다. \n어떠한 프로그램을 만들던지 간에 프로그램에는 `모델(Model)`이라는 개념이 생겨나게 된다.\n이렇게 만들어진 클래스 간에서는 `관계(Relation)`과 `의존성(Dependency)`가 생기게 된다. \n\n`의존성이란?` A클래스에서 B클래스의 기능을 사용할 때 클래스A는 클래스B에 의존적이다 라고 하며\nA --> B 라고 표현한다 (UML에서는 클래스 간의 Dependency를 점선으로 표현한다.)\n즉, B클래스의 기능이 변하게 되면 A클래스에도 영향이 생긴다는 말로 직역할 수 있다.\n\n이해를 돕기위해 급식을 받는 학생에 대한 예제를 들어보겠다.\n(이 학교는 아침/점심/저녁을 다 주는 좋은 학교이다)\n\n\n\n## 클래스 -> 클래스 호출 관계\n\n![image-20180921143924788](./image-20180921143924788.png)\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eatBreakfast();\n        restaurant.eatLunch();\n        restaurant.eatDinner();\n\t}\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eatBreakfast() {\n        Breakfast breakfast = new Breakfast();\n        System.out.println(breakfast.getInfo() + \"을 먹었습니다.\");\n    }\n    \n    public void eatLunch() {\n        Lunch lunch = new Lunch();\n        System.out.println(lunch.getInfo() + \"을 먹었습니다.\");\n    }\n    \n    public void eatDinner() {\n        Dinner dinner = new Dinner();\n        System.out.println(dinner.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\nStudent 클래스는 밥을 먹기위해 Restaurant클래스를 new로 생성하였다.\nRestaurant클래스 내에서는 아침/점심/저녁을 먹을 수 있도록 각각 Breakfast, Lunch, Dinner클래스를 new로 생성하였다.\n위의 의존성에 대해 위 예제를 풀어보면 Student는 Restaurant에 대해 의존적이다. (Student ---> Restaurant)\nStudent클래스에서 Restaurant클래스를 생성하여 밥을 먹기 때문이다. 만약에 Restaurant 클래스에서 밥을 못먹게 하면\nStudent클래스는 정상적으로 밥을 먹는 기능을 수행할 수 없다.\nRestaurant클래스는 Breakfast/Lunch/Dinner에 대해 의존적이다.\n각각의 메소드에서 Breakfast/Lunch/Dinner클래스를 생성하여 밥을 먹는 행위를 하도록 하고있다.\n\n가만히 보게 되면 의존성에 대한 공통점을 발견할 수 있다.\n그것은 바로 `new`이다. `클래스 내에서의 new는 곧 의존성을 의미`하게 된다. new로 생성한 클래스가 문제가 생기면 사용을 하는 클래스의 기능에도 문제가 생기기 떄문이다.\n\n따라서 **프로그래밍의 의존성은 new이다** 로 간단하게 정의를 내릴 수 있겠다.\n\n\n\n## 클래스 -> 인터페이스(interface) -> 클래스 구조\n\n클래스 내에서 클래스를 생성하여 호출 하는 경우에는 변경에 많은 비용이 발생하게 된다.\n만약에 학교에서 야식까지 먹어가며 밤을 새는 경우에는 야식이라는 의존성을 또 추가하게 된다.\n뿐만 아니라 Breakfast/Lunch/Dinner 클래스에 변경이 생기는 경우에도 Restaurant 클래스는 영향을 받게 된다.\n\n이와 같은 문제를 쪼금 더 편하게 해결 할 수 있게 Java에서는 interface라는게 있다.\n(개인적으로 Service나 Repository 같은 클래스들을 생성 할 때 웬만하면 interface를 선언하는 편이다.)\n\n차후에 Mock객체 생성하기도 좋고, 요구사항이 변경 되었을 때 유연하게 대응 할 수 있어 개인적으로는 Interface를 자주 사용하는 편이다.\n\nBreakfast/Lunch/Dinner클래스를 자세히 보면… getInfo() 메소드가 공통적으로 쓰이고 있다.\n(getInfo메소드는 식단에 대한 정보이다.)\n따라서 하나의 interface로 Breakfast/Lunch/Dinner클래스를 추상화 할 수 있다.\n그렇게 되면 eat이라는 메소드 하나만으로도 아침~저녁을 먹을 수 있는 기능을 구현할 수 있다.\n위에서 말로 한 얘기를 코드로 풀어보면..\n\n![image-20180921145310488](./image-20180921145310488.png)\n\n\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eat(new Breakfast());\n        restaurant.eat(new Lunch());\n        restaurant.eat(new Dinner());\n\t}\n}\n~~~\n\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\n위의 클래스 -> 클래스 간의 Dependency 구조보다는 interface를 사용하므로써 많이 결합도가 완화된 모습이다.\n이전에는 Restaurant 클래스가 Break/Lunch/Dinner에 대해 모두 Dependency를 가지고 가는 구조여서 결합도가 강한 형태였는데, interface를 사용하여 결합도를 많이 약화 시켰다.\n\n자세히 보면 `Student클래스에서 Break/Lunch/Dinner를 생성하여 Restaurant에 주입`해 주었다.\n이러한 모습이 향후 DI의 개념과 비슷한 개념으로 발전하게 된다.\nRestaurant입장에서는 개발자가 생성한 객체가 아닌 `외부로 부터 주입받은 형태`로 Break/Lunch/Dinner에 대해 사용을 하기 때문이다.\n이 부분을 잘 이해하면 차후 IoC와 DI를 이해하는데 크게 도움이 된다.\n\n\n\n## 클래스 -> 팩토리(factory) 패턴\n\n디자인 패턴 중에는 팩토리(Factory) 패턴이라는 구현 방식이 있다.\n팩토리 패턴에 대해 간단하게 설명하자면, 객체의 상태(State) 또는 구분자(Type)을 통해 필요한 객체를 Return 해주는 패턴이다. 위에서 설명한 클래스 -> 인터페이스 방식을 차용하여 한 단계 더 Wrapping한 개념이라고 생각하면 편하다.\n팩토리 패턴을 이용하면 아예 `개발자에게 객체 생성에 대한 권한을 주지 않겠다! `를 구현 할 수 있게 된다.\n**개발자가 객체 생성을 직접 하지 않고도 시스템에 요청하여 원하는 객체를 얻어낼 수 있다.** <-- 이 내용은 DL(Dependency Lookup)과 비슷한 개념으로 통할 수 있을 것 같다.\n\n팩토리 패턴으로 만든 코드를 만들게 된다면, 아래와 같이 만들 수 있을 것이다.\n\n![image-20180921153027741](./image-20180921153027741.png)\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eat(EatFactory.get(Meal.BREAKFAST));\n        restaurant.eat(EatFactory.get(Meal.LUNCH));\n        restaurant.eat(EatFactory.get(Meal.DINNER));\n\t}\n}\n~~~\n~~~java\npublic enum Meal {\n   BREAKFAST, LUNCH, DINNER;\n}\n~~~\n~~~java\npublic class EatFactory() {\n    public static Eatable get(Meal meal) {\n        switch(meal) {\n            case BREAKFAST : return new Breakfast();\n            case LUNCH : return new Lunch();\n            case DINNER : return new Dinner();\n            default: throw new IllegalArgumentException(\"Not using Meal Type\");\n        }\n    }\n}\n~~~\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\n\n\n이제 개발자가 개발하는 코드에서 Breakfast/Lunch/Dinner에 대한 Dependency는 완전히 제거 되었다.\n야식이라는 식사 메뉴가 추가되어도 Meal enum에 야식 항목을 추가하고, EatFactory에 야식에 대한 case만 추가 해 주면 \nStudent 클래스는 유연하게 추가된 기능에 대해 대처가 가능하다.\n\n\n\n## IoC 패턴\n\nIoC패턴을 알기 전에 IoC에 대해 간단히 설명하자면.. \n기능을 담당하는 POJO class를 프로그램 시작 시, IoC 컨테이너에 Bean이라는 이름으로 객체를 생성해 둔다.\n이렇게 싱글톤으로 생성된 객체들을 필요한 시점에 IoC 컨테이너에서 의존성을 가지는 객체에 직접 주입을 해주는 패턴을 IoC패턴이라 한다.\n\n쉽게 말하면 객체의 멤버에 대한 상태가 없고(stateless) 기능의 역할을 담은 클래스들을 1개씩 IoC컨테이너라는 상자에 담아두고, 의존성 객체가 필요한 경우 IoC컨테이너에서 필요한 객체를 주입해준다. 라고 생각하면 편할 것 같다.\n객체에 대해 new 생성자를 통해 객체를 생성할 필요가 없으니, 메모리적인 낭비가 없다는 장점이 있을 뿐 더러 개발자에게 객체 관리에 대한 미시적인 역할을 맡기지 않아도 되는 장점이 있다. 자세한 내용은 다음 장에 기술하도록 하겠다.\n\n위의 내용을 Spring을 사용한 개발이라고 한다면... 아래와 같이 코드를 짤 수 있겠다.\n\n~~~java\n@SpringBootApplication(scanBasePackages = \"com.example.ioc\")\npublic class Student {\n    \n    @Autowired\n    private Restaurant restaurant;\n    @Autowired\n    private EatFactory eatFactory;\n    \n    public static void main(String[] args) {\n        \n\t\tSpringApplication.run(SpringStudyApplication.class, args);\n        //식사 시작\n        restaurant.eat(eatFactory.get(Meal.BREAKFAST));\n        restaurant.eat(eatFactory.get(Meal.LUNCH));\n        restaurant.eat(eatFactory.get(Meal.DINNER));\n\t}\n}\n~~~\n~~~java\npublic enum Meal {\n   BREAKFAST, LUNCH, DINNER;\n}\n~~~\n~~~java\n@Component\npublic class EatFactory() {\n\t\n    @Autowired @Qualifier(\"breakfast\")\n    private Eatable breakfast;\n    @Autowired @Qualifier(\"lunch\")\n    private Eatable lunch;\n    @Autowired @Qualifier(\"dinner\")\n    private Eatable dinner;\n    \n    public Eatable get(Meal meal) {\n        switch(meal) {\n            case BREAKFAST : breakfast;\n            case LUNCH : lunch;\n            case DINNER : dinner;\n            default: throw new IllegalArgumentException(\"Not using Meal Type\");\n        }\n    }\n}\n~~~\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\n@Service\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\nSpring에서는 component-scan이라는 기능을 통해 @Component 어노테이션이 붙은 클래스는 IoC 컨테이너에 Bean으로써 자동 등록 해준다. 이러한 Bean은 @Autowired / @Inject 와 같은 어노테이션을 통해 클래스에 주입을 해줄 수 있다.\n이렇게 되면 개발자가 new를 통해 의존성을 강제화 하지 않고 프레임워크가 이 역할을 대신 수행해 준다.\n\n개발자가 객체 생성과 의존성 주입에 대한 역할을 대신 해준다 \nInversion of Control (객체 관리과 의존성 관리를 시스템에서 해준다 : 제어의 역전) 이라고 불리게 되었다.\n\n\n\n# 참조\n\nhttp://www.javajigi.net/pages/viewpage.action?pageId=3664&focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\n토비의 스프링 VOL.2 Spring IoC","source":"_posts/2018-09-12-spring-ioc.md","raw":"---\ntitle: Spring IoC & DI(1) - IoC 등장배경(과정)\nsubtitle: IoC/DI의 발전과정\nheader-img:\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\ntypora-root-url: ./2018-09-12-spring-ioc\ntypora-copy-images-to: ./2018-09-12-spring-ioc\ndate: 2018-09-21 23:33:21\n---\n\n\n\n# IoC 등장배경\n\nIoC의 등장배경을 알기 위해서는 EJB나 Spring과 같은 프레임워크를 사용하기 이전 시대의 개발 방식에 대해 얘기를 해야한다.\n온고지신(?)이라 하였던가.. IoC를 이해하기 위해 옛날이야기를 해보도록 하겠다.\n\n태초에 Java로 만든 프로그램은 main()이라는 메소드에서 시작이 되었다.\nmain() 메소드 내에서 필요한 클래스를 개발자가 직접 코드내에서 생성하여 사용하였다. \n어떠한 프로그램을 만들던지 간에 프로그램에는 `모델(Model)`이라는 개념이 생겨나게 된다.\n이렇게 만들어진 클래스 간에서는 `관계(Relation)`과 `의존성(Dependency)`가 생기게 된다. \n\n`의존성이란?` A클래스에서 B클래스의 기능을 사용할 때 클래스A는 클래스B에 의존적이다 라고 하며\nA --> B 라고 표현한다 (UML에서는 클래스 간의 Dependency를 점선으로 표현한다.)\n즉, B클래스의 기능이 변하게 되면 A클래스에도 영향이 생긴다는 말로 직역할 수 있다.\n\n이해를 돕기위해 급식을 받는 학생에 대한 예제를 들어보겠다.\n(이 학교는 아침/점심/저녁을 다 주는 좋은 학교이다)\n\n\n\n## 클래스 -> 클래스 호출 관계\n\n![image-20180921143924788](./image-20180921143924788.png)\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eatBreakfast();\n        restaurant.eatLunch();\n        restaurant.eatDinner();\n\t}\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eatBreakfast() {\n        Breakfast breakfast = new Breakfast();\n        System.out.println(breakfast.getInfo() + \"을 먹었습니다.\");\n    }\n    \n    public void eatLunch() {\n        Lunch lunch = new Lunch();\n        System.out.println(lunch.getInfo() + \"을 먹었습니다.\");\n    }\n    \n    public void eatDinner() {\n        Dinner dinner = new Dinner();\n        System.out.println(dinner.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\nStudent 클래스는 밥을 먹기위해 Restaurant클래스를 new로 생성하였다.\nRestaurant클래스 내에서는 아침/점심/저녁을 먹을 수 있도록 각각 Breakfast, Lunch, Dinner클래스를 new로 생성하였다.\n위의 의존성에 대해 위 예제를 풀어보면 Student는 Restaurant에 대해 의존적이다. (Student ---> Restaurant)\nStudent클래스에서 Restaurant클래스를 생성하여 밥을 먹기 때문이다. 만약에 Restaurant 클래스에서 밥을 못먹게 하면\nStudent클래스는 정상적으로 밥을 먹는 기능을 수행할 수 없다.\nRestaurant클래스는 Breakfast/Lunch/Dinner에 대해 의존적이다.\n각각의 메소드에서 Breakfast/Lunch/Dinner클래스를 생성하여 밥을 먹는 행위를 하도록 하고있다.\n\n가만히 보게 되면 의존성에 대한 공통점을 발견할 수 있다.\n그것은 바로 `new`이다. `클래스 내에서의 new는 곧 의존성을 의미`하게 된다. new로 생성한 클래스가 문제가 생기면 사용을 하는 클래스의 기능에도 문제가 생기기 떄문이다.\n\n따라서 **프로그래밍의 의존성은 new이다** 로 간단하게 정의를 내릴 수 있겠다.\n\n\n\n## 클래스 -> 인터페이스(interface) -> 클래스 구조\n\n클래스 내에서 클래스를 생성하여 호출 하는 경우에는 변경에 많은 비용이 발생하게 된다.\n만약에 학교에서 야식까지 먹어가며 밤을 새는 경우에는 야식이라는 의존성을 또 추가하게 된다.\n뿐만 아니라 Breakfast/Lunch/Dinner 클래스에 변경이 생기는 경우에도 Restaurant 클래스는 영향을 받게 된다.\n\n이와 같은 문제를 쪼금 더 편하게 해결 할 수 있게 Java에서는 interface라는게 있다.\n(개인적으로 Service나 Repository 같은 클래스들을 생성 할 때 웬만하면 interface를 선언하는 편이다.)\n\n차후에 Mock객체 생성하기도 좋고, 요구사항이 변경 되었을 때 유연하게 대응 할 수 있어 개인적으로는 Interface를 자주 사용하는 편이다.\n\nBreakfast/Lunch/Dinner클래스를 자세히 보면… getInfo() 메소드가 공통적으로 쓰이고 있다.\n(getInfo메소드는 식단에 대한 정보이다.)\n따라서 하나의 interface로 Breakfast/Lunch/Dinner클래스를 추상화 할 수 있다.\n그렇게 되면 eat이라는 메소드 하나만으로도 아침~저녁을 먹을 수 있는 기능을 구현할 수 있다.\n위에서 말로 한 얘기를 코드로 풀어보면..\n\n![image-20180921145310488](./image-20180921145310488.png)\n\n\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eat(new Breakfast());\n        restaurant.eat(new Lunch());\n        restaurant.eat(new Dinner());\n\t}\n}\n~~~\n\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\n위의 클래스 -> 클래스 간의 Dependency 구조보다는 interface를 사용하므로써 많이 결합도가 완화된 모습이다.\n이전에는 Restaurant 클래스가 Break/Lunch/Dinner에 대해 모두 Dependency를 가지고 가는 구조여서 결합도가 강한 형태였는데, interface를 사용하여 결합도를 많이 약화 시켰다.\n\n자세히 보면 `Student클래스에서 Break/Lunch/Dinner를 생성하여 Restaurant에 주입`해 주었다.\n이러한 모습이 향후 DI의 개념과 비슷한 개념으로 발전하게 된다.\nRestaurant입장에서는 개발자가 생성한 객체가 아닌 `외부로 부터 주입받은 형태`로 Break/Lunch/Dinner에 대해 사용을 하기 때문이다.\n이 부분을 잘 이해하면 차후 IoC와 DI를 이해하는데 크게 도움이 된다.\n\n\n\n## 클래스 -> 팩토리(factory) 패턴\n\n디자인 패턴 중에는 팩토리(Factory) 패턴이라는 구현 방식이 있다.\n팩토리 패턴에 대해 간단하게 설명하자면, 객체의 상태(State) 또는 구분자(Type)을 통해 필요한 객체를 Return 해주는 패턴이다. 위에서 설명한 클래스 -> 인터페이스 방식을 차용하여 한 단계 더 Wrapping한 개념이라고 생각하면 편하다.\n팩토리 패턴을 이용하면 아예 `개발자에게 객체 생성에 대한 권한을 주지 않겠다! `를 구현 할 수 있게 된다.\n**개발자가 객체 생성을 직접 하지 않고도 시스템에 요청하여 원하는 객체를 얻어낼 수 있다.** <-- 이 내용은 DL(Dependency Lookup)과 비슷한 개념으로 통할 수 있을 것 같다.\n\n팩토리 패턴으로 만든 코드를 만들게 된다면, 아래와 같이 만들 수 있을 것이다.\n\n![image-20180921153027741](./image-20180921153027741.png)\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eat(EatFactory.get(Meal.BREAKFAST));\n        restaurant.eat(EatFactory.get(Meal.LUNCH));\n        restaurant.eat(EatFactory.get(Meal.DINNER));\n\t}\n}\n~~~\n~~~java\npublic enum Meal {\n   BREAKFAST, LUNCH, DINNER;\n}\n~~~\n~~~java\npublic class EatFactory() {\n    public static Eatable get(Meal meal) {\n        switch(meal) {\n            case BREAKFAST : return new Breakfast();\n            case LUNCH : return new Lunch();\n            case DINNER : return new Dinner();\n            default: throw new IllegalArgumentException(\"Not using Meal Type\");\n        }\n    }\n}\n~~~\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\n\n\n이제 개발자가 개발하는 코드에서 Breakfast/Lunch/Dinner에 대한 Dependency는 완전히 제거 되었다.\n야식이라는 식사 메뉴가 추가되어도 Meal enum에 야식 항목을 추가하고, EatFactory에 야식에 대한 case만 추가 해 주면 \nStudent 클래스는 유연하게 추가된 기능에 대해 대처가 가능하다.\n\n\n\n## IoC 패턴\n\nIoC패턴을 알기 전에 IoC에 대해 간단히 설명하자면.. \n기능을 담당하는 POJO class를 프로그램 시작 시, IoC 컨테이너에 Bean이라는 이름으로 객체를 생성해 둔다.\n이렇게 싱글톤으로 생성된 객체들을 필요한 시점에 IoC 컨테이너에서 의존성을 가지는 객체에 직접 주입을 해주는 패턴을 IoC패턴이라 한다.\n\n쉽게 말하면 객체의 멤버에 대한 상태가 없고(stateless) 기능의 역할을 담은 클래스들을 1개씩 IoC컨테이너라는 상자에 담아두고, 의존성 객체가 필요한 경우 IoC컨테이너에서 필요한 객체를 주입해준다. 라고 생각하면 편할 것 같다.\n객체에 대해 new 생성자를 통해 객체를 생성할 필요가 없으니, 메모리적인 낭비가 없다는 장점이 있을 뿐 더러 개발자에게 객체 관리에 대한 미시적인 역할을 맡기지 않아도 되는 장점이 있다. 자세한 내용은 다음 장에 기술하도록 하겠다.\n\n위의 내용을 Spring을 사용한 개발이라고 한다면... 아래와 같이 코드를 짤 수 있겠다.\n\n~~~java\n@SpringBootApplication(scanBasePackages = \"com.example.ioc\")\npublic class Student {\n    \n    @Autowired\n    private Restaurant restaurant;\n    @Autowired\n    private EatFactory eatFactory;\n    \n    public static void main(String[] args) {\n        \n\t\tSpringApplication.run(SpringStudyApplication.class, args);\n        //식사 시작\n        restaurant.eat(eatFactory.get(Meal.BREAKFAST));\n        restaurant.eat(eatFactory.get(Meal.LUNCH));\n        restaurant.eat(eatFactory.get(Meal.DINNER));\n\t}\n}\n~~~\n~~~java\npublic enum Meal {\n   BREAKFAST, LUNCH, DINNER;\n}\n~~~\n~~~java\n@Component\npublic class EatFactory() {\n\t\n    @Autowired @Qualifier(\"breakfast\")\n    private Eatable breakfast;\n    @Autowired @Qualifier(\"lunch\")\n    private Eatable lunch;\n    @Autowired @Qualifier(\"dinner\")\n    private Eatable dinner;\n    \n    public Eatable get(Meal meal) {\n        switch(meal) {\n            case BREAKFAST : breakfast;\n            case LUNCH : lunch;\n            case DINNER : dinner;\n            default: throw new IllegalArgumentException(\"Not using Meal Type\");\n        }\n    }\n}\n~~~\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\n@Service\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\nSpring에서는 component-scan이라는 기능을 통해 @Component 어노테이션이 붙은 클래스는 IoC 컨테이너에 Bean으로써 자동 등록 해준다. 이러한 Bean은 @Autowired / @Inject 와 같은 어노테이션을 통해 클래스에 주입을 해줄 수 있다.\n이렇게 되면 개발자가 new를 통해 의존성을 강제화 하지 않고 프레임워크가 이 역할을 대신 수행해 준다.\n\n개발자가 객체 생성과 의존성 주입에 대한 역할을 대신 해준다 \nInversion of Control (객체 관리과 의존성 관리를 시스템에서 해준다 : 제어의 역전) 이라고 불리게 되었다.\n\n\n\n# 참조\n\nhttp://www.javajigi.net/pages/viewpage.action?pageId=3664&focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\n토비의 스프링 VOL.2 Spring IoC","slug":"2018-09-12-spring-ioc","published":1,"updated":"2018-11-27T07:23:32.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv3rk0031cr1t2a69lf9m","content":"<h1 id=\"ioc-등장배경\">IoC 등장배경</h1>\n<p>IoC의 등장배경을 알기 위해서는 EJB나 Spring과 같은 프레임워크를 사용하기 이전 시대의 개발 방식에 대해 얘기를 해야한다.\n온고지신(?)이라 하였던가.. IoC를 이해하기 위해 옛날이야기를 해보도록 하겠다.</p>\n<p>태초에 Java로 만든 프로그램은 main()이라는 메소드에서 시작이 되었다.\nmain() 메소드 내에서 필요한 클래스를 개발자가 직접 코드내에서 생성하여 사용하였다.\n어떠한 프로그램을 만들던지 간에 프로그램에는 <code>모델(Model)</code>이라는 개념이 생겨나게 된다.\n이렇게 만들어진 클래스 간에서는 <code>관계(Relation)</code>과 <code>의존성(Dependency)</code>가 생기게 된다.</p>\n<p><code>의존성이란?</code> A클래스에서 B클래스의 기능을 사용할 때 클래스A는 클래스B에 의존적이다 라고 하며\nA --&gt; B 라고 표현한다 (UML에서는 클래스 간의 Dependency를 점선으로 표현한다.)\n즉, B클래스의 기능이 변하게 되면 A클래스에도 영향이 생긴다는 말로 직역할 수 있다.</p>\n<p>이해를 돕기위해 급식을 받는 학생에 대한 예제를 들어보겠다.\n(이 학교는 아침/점심/저녁을 다 주는 좋은 학교이다)</p>\n<h2 id=\"클래스-gt-클래스-호출-관계\">클래스 -&gt; 클래스 호출 관계</h2>\n<p><img src=\"./image-20180921143924788.png\" alt=\"image-20180921143924788\"></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eatBreakfast();</span><br><span class=\"line\">        restaurant.eatLunch();</span><br><span class=\"line\">        restaurant.eatDinner();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatBreakfast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Breakfast breakfast = <span class=\"keyword\">new</span> Breakfast();</span><br><span class=\"line\">        System.out.println(breakfast.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatLunch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Lunch lunch = <span class=\"keyword\">new</span> Lunch();</span><br><span class=\"line\">        System.out.println(lunch.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatDinner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Dinner dinner = <span class=\"keyword\">new</span> Dinner();</span><br><span class=\"line\">        System.out.println(dinner.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Student 클래스는 밥을 먹기위해 Restaurant클래스를 new로 생성하였다.\nRestaurant클래스 내에서는 아침/점심/저녁을 먹을 수 있도록 각각 Breakfast, Lunch, Dinner클래스를 new로 생성하였다.\n위의 의존성에 대해 위 예제를 풀어보면 Student는 Restaurant에 대해 의존적이다. (Student ---&gt; Restaurant)\nStudent클래스에서 Restaurant클래스를 생성하여 밥을 먹기 때문이다. 만약에 Restaurant 클래스에서 밥을 못먹게 하면\nStudent클래스는 정상적으로 밥을 먹는 기능을 수행할 수 없다.\nRestaurant클래스는 Breakfast/Lunch/Dinner에 대해 의존적이다.\n각각의 메소드에서 Breakfast/Lunch/Dinner클래스를 생성하여 밥을 먹는 행위를 하도록 하고있다.</p>\n<p>가만히 보게 되면 의존성에 대한 공통점을 발견할 수 있다.\n그것은 바로 <code>new</code>이다. <code>클래스 내에서의 new는 곧 의존성을 의미</code>하게 된다. new로 생성한 클래스가 문제가 생기면 사용을 하는 클래스의 기능에도 문제가 생기기 떄문이다.</p>\n<p>따라서 <strong>프로그래밍의 의존성은 new이다</strong> 로 간단하게 정의를 내릴 수 있겠다.</p>\n<h2 id=\"클래스-gt-인터페이스interface-gt-클래스-구조\">클래스 -&gt; 인터페이스(interface) -&gt; 클래스 구조</h2>\n<p>클래스 내에서 클래스를 생성하여 호출 하는 경우에는 변경에 많은 비용이 발생하게 된다.\n만약에 학교에서 야식까지 먹어가며 밤을 새는 경우에는 야식이라는 의존성을 또 추가하게 된다.\n뿐만 아니라 Breakfast/Lunch/Dinner 클래스에 변경이 생기는 경우에도 Restaurant 클래스는 영향을 받게 된다.</p>\n<p>이와 같은 문제를 쪼금 더 편하게 해결 할 수 있게 Java에서는 interface라는게 있다.\n(개인적으로 Service나 Repository 같은 클래스들을 생성 할 때 웬만하면 interface를 선언하는 편이다.)</p>\n<p>차후에 Mock객체 생성하기도 좋고, 요구사항이 변경 되었을 때 유연하게 대응 할 수 있어 개인적으로는 Interface를 자주 사용하는 편이다.</p>\n<p>Breakfast/Lunch/Dinner클래스를 자세히 보면… getInfo() 메소드가 공통적으로 쓰이고 있다.\n(getInfo메소드는 식단에 대한 정보이다.)\n따라서 하나의 interface로 Breakfast/Lunch/Dinner클래스를 추상화 할 수 있다.\n그렇게 되면 eat이라는 메소드 하나만으로도 아침~저녁을 먹을 수 있는 기능을 구현할 수 있다.\n위에서 말로 한 얘기를 코드로 풀어보면..</p>\n<p><img src=\"./image-20180921145310488.png\" alt=\"image-20180921145310488\"></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Breakfast());</span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Lunch());</span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Dinner());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 클래스 -&gt; 클래스 간의 Dependency 구조보다는 interface를 사용하므로써 많이 결합도가 완화된 모습이다.\n이전에는 Restaurant 클래스가 Break/Lunch/Dinner에 대해 모두 Dependency를 가지고 가는 구조여서 결합도가 강한 형태였는데, interface를 사용하여 결합도를 많이 약화 시켰다.</p>\n<p>자세히 보면 <code>Student클래스에서 Break/Lunch/Dinner를 생성하여 Restaurant에 주입</code>해 주었다.\n이러한 모습이 향후 DI의 개념과 비슷한 개념으로 발전하게 된다.\nRestaurant입장에서는 개발자가 생성한 객체가 아닌 <code>외부로 부터 주입받은 형태</code>로 Break/Lunch/Dinner에 대해 사용을 하기 때문이다.\n이 부분을 잘 이해하면 차후 IoC와 DI를 이해하는데 크게 도움이 된다.</p>\n<h2 id=\"클래스-gt-팩토리factory-패턴\">클래스 -&gt; 팩토리(factory) 패턴</h2>\n<p>디자인 패턴 중에는 팩토리(Factory) 패턴이라는 구현 방식이 있다.\n팩토리 패턴에 대해 간단하게 설명하자면, 객체의 상태(State) 또는 구분자(Type)을 통해 필요한 객체를 Return 해주는 패턴이다. 위에서 설명한 클래스 -&gt; 인터페이스 방식을 차용하여 한 단계 더 Wrapping한 개념이라고 생각하면 편하다.\n팩토리 패턴을 이용하면 아예 <code>개발자에게 객체 생성에 대한 권한을 주지 않겠다!</code>를 구현 할 수 있게 된다.\n<strong>개발자가 객체 생성을 직접 하지 않고도 시스템에 요청하여 원하는 객체를 얻어낼 수 있다.</strong> &lt;-- 이 내용은 DL(Dependency Lookup)과 비슷한 개념으로 통할 수 있을 것 같다.</p>\n<p>팩토리 패턴으로 만든 코드를 만들게 된다면, 아래와 같이 만들 수 있을 것이다.</p>\n<p><img src=\"./image-20180921153027741.png\" alt=\"image-20180921153027741\"></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.BREAKFAST));</span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.LUNCH));</span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.DINNER));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Meal &#123;</span><br><span class=\"line\">   BREAKFAST, LUNCH, DINNER;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">EatFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Eatable <span class=\"title\">get</span><span class=\"params\">(Meal meal)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(meal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BREAKFAST : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Breakfast();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LUNCH : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Lunch();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> DINNER : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Dinner();</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Not using Meal Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이제 개발자가 개발하는 코드에서 Breakfast/Lunch/Dinner에 대한 Dependency는 완전히 제거 되었다.\n야식이라는 식사 메뉴가 추가되어도 Meal enum에 야식 항목을 추가하고, EatFactory에 야식에 대한 case만 추가 해 주면\nStudent 클래스는 유연하게 추가된 기능에 대해 대처가 가능하다.</p>\n<h2 id=\"ioc-패턴\">IoC 패턴</h2>\n<p>IoC패턴을 알기 전에 IoC에 대해 간단히 설명하자면..\n기능을 담당하는 POJO class를 프로그램 시작 시, IoC 컨테이너에 Bean이라는 이름으로 객체를 생성해 둔다.\n이렇게 싱글톤으로 생성된 객체들을 필요한 시점에 IoC 컨테이너에서 의존성을 가지는 객체에 직접 주입을 해주는 패턴을 IoC패턴이라 한다.</p>\n<p>쉽게 말하면 객체의 멤버에 대한 상태가 없고(stateless) 기능의 역할을 담은 클래스들을 1개씩 IoC컨테이너라는 상자에 담아두고, 의존성 객체가 필요한 경우 IoC컨테이너에서 필요한 객체를 주입해준다. 라고 생각하면 편할 것 같다.\n객체에 대해 new 생성자를 통해 객체를 생성할 필요가 없으니, 메모리적인 낭비가 없다는 장점이 있을 뿐 더러 개발자에게 객체 관리에 대한 미시적인 역할을 맡기지 않아도 되는 장점이 있다. 자세한 내용은 다음 장에 기술하도록 하겠다.</p>\n<p>위의 내용을 Spring을 사용한 개발이라고 한다면... 아래와 같이 코드를 짤 수 있겠다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span>(scanBasePackages = <span class=\"string\">\"com.example.ioc\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Restaurant restaurant;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EatFactory eatFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\tSpringApplication.run(SpringStudyApplication.class, args);</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.BREAKFAST));</span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.LUNCH));</span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.DINNER));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Meal &#123;</span><br><span class=\"line\">   BREAKFAST, LUNCH, DINNER;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">EatFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"breakfast\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable breakfast;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"lunch\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable lunch;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"dinner\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable dinner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Eatable <span class=\"title\">get</span><span class=\"params\">(Meal meal)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(meal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BREAKFAST : breakfast;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LUNCH : lunch;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> DINNER : dinner;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Not using Meal Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Spring에서는 component-scan이라는 기능을 통해 @Component 어노테이션이 붙은 클래스는 IoC 컨테이너에 Bean으로써 자동 등록 해준다. 이러한 Bean은 @Autowired / @Inject 와 같은 어노테이션을 통해 클래스에 주입을 해줄 수 있다.\n이렇게 되면 개발자가 new를 통해 의존성을 강제화 하지 않고 프레임워크가 이 역할을 대신 수행해 준다.</p>\n<p>개발자가 객체 생성과 의존성 주입에 대한 역할을 대신 해준다\nInversion of Control (객체 관리과 의존성 관리를 시스템에서 해준다 : 제어의 역전) 이라고 불리게 되었다.</p>\n<h1 id=\"참조\">참조</h1>\n<p>http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\n토비의 스프링 VOL.2 Spring IoC</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>IoC 등장배경</h1>\n<p>IoC의 등장배경을 알기 위해서는 EJB나 Spring과 같은 프레임워크를 사용하기 이전 시대의 개발 방식에 대해 얘기를 해야한다.\n온고지신(?)이라 하였던가.. IoC를 이해하기 위해 옛날이야기를 해보도록 하겠다.</p>\n<p>태초에 Java로 만든 프로그램은 main()이라는 메소드에서 시작이 되었다.\nmain() 메소드 내에서 필요한 클래스를 개발자가 직접 코드내에서 생성하여 사용하였다.\n어떠한 프로그램을 만들던지 간에 프로그램에는 <code>모델(Model)</code>이라는 개념이 생겨나게 된다.\n이렇게 만들어진 클래스 간에서는 <code>관계(Relation)</code>과 <code>의존성(Dependency)</code>가 생기게 된다.</p>\n<p><code>의존성이란?</code> A클래스에서 B클래스의 기능을 사용할 때 클래스A는 클래스B에 의존적이다 라고 하며\nA --&gt; B 라고 표현한다 (UML에서는 클래스 간의 Dependency를 점선으로 표현한다.)\n즉, B클래스의 기능이 변하게 되면 A클래스에도 영향이 생긴다는 말로 직역할 수 있다.</p>\n<p>이해를 돕기위해 급식을 받는 학생에 대한 예제를 들어보겠다.\n(이 학교는 아침/점심/저녁을 다 주는 좋은 학교이다)</p>\n<h2>클래스 -&gt; 클래스 호출 관계</h2>\n<p><img src=\"./image-20180921143924788.png\" alt=\"image-20180921143924788\"></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eatBreakfast();</span><br><span class=\"line\">        restaurant.eatLunch();</span><br><span class=\"line\">        restaurant.eatDinner();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatBreakfast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Breakfast breakfast = <span class=\"keyword\">new</span> Breakfast();</span><br><span class=\"line\">        System.out.println(breakfast.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatLunch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Lunch lunch = <span class=\"keyword\">new</span> Lunch();</span><br><span class=\"line\">        System.out.println(lunch.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatDinner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Dinner dinner = <span class=\"keyword\">new</span> Dinner();</span><br><span class=\"line\">        System.out.println(dinner.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Student 클래스는 밥을 먹기위해 Restaurant클래스를 new로 생성하였다.\nRestaurant클래스 내에서는 아침/점심/저녁을 먹을 수 있도록 각각 Breakfast, Lunch, Dinner클래스를 new로 생성하였다.\n위의 의존성에 대해 위 예제를 풀어보면 Student는 Restaurant에 대해 의존적이다. (Student ---&gt; Restaurant)\nStudent클래스에서 Restaurant클래스를 생성하여 밥을 먹기 때문이다. 만약에 Restaurant 클래스에서 밥을 못먹게 하면\nStudent클래스는 정상적으로 밥을 먹는 기능을 수행할 수 없다.\nRestaurant클래스는 Breakfast/Lunch/Dinner에 대해 의존적이다.\n각각의 메소드에서 Breakfast/Lunch/Dinner클래스를 생성하여 밥을 먹는 행위를 하도록 하고있다.</p>\n<p>가만히 보게 되면 의존성에 대한 공통점을 발견할 수 있다.\n그것은 바로 <code>new</code>이다. <code>클래스 내에서의 new는 곧 의존성을 의미</code>하게 된다. new로 생성한 클래스가 문제가 생기면 사용을 하는 클래스의 기능에도 문제가 생기기 떄문이다.</p>\n<p>따라서 <strong>프로그래밍의 의존성은 new이다</strong> 로 간단하게 정의를 내릴 수 있겠다.</p>\n<h2>클래스 -&gt; 인터페이스(interface) -&gt; 클래스 구조</h2>\n<p>클래스 내에서 클래스를 생성하여 호출 하는 경우에는 변경에 많은 비용이 발생하게 된다.\n만약에 학교에서 야식까지 먹어가며 밤을 새는 경우에는 야식이라는 의존성을 또 추가하게 된다.\n뿐만 아니라 Breakfast/Lunch/Dinner 클래스에 변경이 생기는 경우에도 Restaurant 클래스는 영향을 받게 된다.</p>\n<p>이와 같은 문제를 쪼금 더 편하게 해결 할 수 있게 Java에서는 interface라는게 있다.\n(개인적으로 Service나 Repository 같은 클래스들을 생성 할 때 웬만하면 interface를 선언하는 편이다.)</p>\n<p>차후에 Mock객체 생성하기도 좋고, 요구사항이 변경 되었을 때 유연하게 대응 할 수 있어 개인적으로는 Interface를 자주 사용하는 편이다.</p>\n<p>Breakfast/Lunch/Dinner클래스를 자세히 보면… getInfo() 메소드가 공통적으로 쓰이고 있다.\n(getInfo메소드는 식단에 대한 정보이다.)\n따라서 하나의 interface로 Breakfast/Lunch/Dinner클래스를 추상화 할 수 있다.\n그렇게 되면 eat이라는 메소드 하나만으로도 아침~저녁을 먹을 수 있는 기능을 구현할 수 있다.\n위에서 말로 한 얘기를 코드로 풀어보면..</p>\n<p><img src=\"./image-20180921145310488.png\" alt=\"image-20180921145310488\"></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Breakfast());</span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Lunch());</span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Dinner());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 클래스 -&gt; 클래스 간의 Dependency 구조보다는 interface를 사용하므로써 많이 결합도가 완화된 모습이다.\n이전에는 Restaurant 클래스가 Break/Lunch/Dinner에 대해 모두 Dependency를 가지고 가는 구조여서 결합도가 강한 형태였는데, interface를 사용하여 결합도를 많이 약화 시켰다.</p>\n<p>자세히 보면 <code>Student클래스에서 Break/Lunch/Dinner를 생성하여 Restaurant에 주입</code>해 주었다.\n이러한 모습이 향후 DI의 개념과 비슷한 개념으로 발전하게 된다.\nRestaurant입장에서는 개발자가 생성한 객체가 아닌 <code>외부로 부터 주입받은 형태</code>로 Break/Lunch/Dinner에 대해 사용을 하기 때문이다.\n이 부분을 잘 이해하면 차후 IoC와 DI를 이해하는데 크게 도움이 된다.</p>\n<h2>클래스 -&gt; 팩토리(factory) 패턴</h2>\n<p>디자인 패턴 중에는 팩토리(Factory) 패턴이라는 구현 방식이 있다.\n팩토리 패턴에 대해 간단하게 설명하자면, 객체의 상태(State) 또는 구분자(Type)을 통해 필요한 객체를 Return 해주는 패턴이다. 위에서 설명한 클래스 -&gt; 인터페이스 방식을 차용하여 한 단계 더 Wrapping한 개념이라고 생각하면 편하다.\n팩토리 패턴을 이용하면 아예 <code>개발자에게 객체 생성에 대한 권한을 주지 않겠다!</code>를 구현 할 수 있게 된다.\n<strong>개발자가 객체 생성을 직접 하지 않고도 시스템에 요청하여 원하는 객체를 얻어낼 수 있다.</strong> &lt;-- 이 내용은 DL(Dependency Lookup)과 비슷한 개념으로 통할 수 있을 것 같다.</p>\n<p>팩토리 패턴으로 만든 코드를 만들게 된다면, 아래와 같이 만들 수 있을 것이다.</p>\n<p><img src=\"./image-20180921153027741.png\" alt=\"image-20180921153027741\"></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.BREAKFAST));</span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.LUNCH));</span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.DINNER));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Meal &#123;</span><br><span class=\"line\">   BREAKFAST, LUNCH, DINNER;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">EatFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Eatable <span class=\"title\">get</span><span class=\"params\">(Meal meal)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(meal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BREAKFAST : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Breakfast();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LUNCH : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Lunch();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> DINNER : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Dinner();</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Not using Meal Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이제 개발자가 개발하는 코드에서 Breakfast/Lunch/Dinner에 대한 Dependency는 완전히 제거 되었다.\n야식이라는 식사 메뉴가 추가되어도 Meal enum에 야식 항목을 추가하고, EatFactory에 야식에 대한 case만 추가 해 주면\nStudent 클래스는 유연하게 추가된 기능에 대해 대처가 가능하다.</p>\n<h2>IoC 패턴</h2>\n<p>IoC패턴을 알기 전에 IoC에 대해 간단히 설명하자면..\n기능을 담당하는 POJO class를 프로그램 시작 시, IoC 컨테이너에 Bean이라는 이름으로 객체를 생성해 둔다.\n이렇게 싱글톤으로 생성된 객체들을 필요한 시점에 IoC 컨테이너에서 의존성을 가지는 객체에 직접 주입을 해주는 패턴을 IoC패턴이라 한다.</p>\n<p>쉽게 말하면 객체의 멤버에 대한 상태가 없고(stateless) 기능의 역할을 담은 클래스들을 1개씩 IoC컨테이너라는 상자에 담아두고, 의존성 객체가 필요한 경우 IoC컨테이너에서 필요한 객체를 주입해준다. 라고 생각하면 편할 것 같다.\n객체에 대해 new 생성자를 통해 객체를 생성할 필요가 없으니, 메모리적인 낭비가 없다는 장점이 있을 뿐 더러 개발자에게 객체 관리에 대한 미시적인 역할을 맡기지 않아도 되는 장점이 있다. 자세한 내용은 다음 장에 기술하도록 하겠다.</p>\n<p>위의 내용을 Spring을 사용한 개발이라고 한다면... 아래와 같이 코드를 짤 수 있겠다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span>(scanBasePackages = <span class=\"string\">\"com.example.ioc\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Restaurant restaurant;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EatFactory eatFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\tSpringApplication.run(SpringStudyApplication.class, args);</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.BREAKFAST));</span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.LUNCH));</span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.DINNER));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Meal &#123;</span><br><span class=\"line\">   BREAKFAST, LUNCH, DINNER;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">EatFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"breakfast\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable breakfast;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"lunch\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable lunch;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"dinner\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable dinner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Eatable <span class=\"title\">get</span><span class=\"params\">(Meal meal)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(meal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BREAKFAST : breakfast;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LUNCH : lunch;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> DINNER : dinner;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Not using Meal Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Spring에서는 component-scan이라는 기능을 통해 @Component 어노테이션이 붙은 클래스는 IoC 컨테이너에 Bean으로써 자동 등록 해준다. 이러한 Bean은 @Autowired / @Inject 와 같은 어노테이션을 통해 클래스에 주입을 해줄 수 있다.\n이렇게 되면 개발자가 new를 통해 의존성을 강제화 하지 않고 프레임워크가 이 역할을 대신 수행해 준다.</p>\n<p>개발자가 객체 생성과 의존성 주입에 대한 역할을 대신 해준다\nInversion of Control (객체 관리과 의존성 관리를 시스템에서 해준다 : 제어의 역전) 이라고 불리게 되었다.</p>\n<h1>참조</h1>\n<p>http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\n토비의 스프링 VOL.2 Spring IoC</p>\n"},{"title":"Spring IoC & DI(2)","subtitle":"Spring IoC와 DI","catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-09-21-spring-ioc-2","typora-copy-images-to":"./2018-09-21-spring-ioc-2","date":"2018-09-22T08:00:54.000Z","header-img":null,"_content":"\n# IoC란?\n\nInversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.\n보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.\n하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며\n개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.\n\n따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여\n제어의 역전 (Inversion of Control)이라 불린다.\n\n\n\n# Container가 도데체 뭐람?\n\n![containers](./containers.jpg)\n\n\n\n개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다. \nSpring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등.. Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까? \n위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다. \n이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.\n컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는.. 컨테이너를 생각하는 것이 도움이 될 것 같다.\n실제 프레임워크에서의 컨테이너도 같은 역할을 한다. \n\n**이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체**라고 할 수 있다. \n\n위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면\n\n서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,\n외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.\n\nSpring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.\n\n\n\n# DI란?\n\nDI란 Dependency Injection의 의미로 IoC를 구현한 대표적인 예야\nPojo 객체내의 종속적인 객체를 IoC Container에서 직접 객체를 Injection해주는 걸 의미해\n스프링 개발에서는 99프로 DI방식을 통해 개발자가 직접 필요한 객체를 선언하지 않고 \nIoC Container에서 넣어줘서 사용해 —> 이거는 Bean 초기화시에 이루어져\nDL (Dependency Lookup) 이라는 기능도 있는데 이거는 거의 사용하지는 않아\n이 기능은 IoC Container에서 Bean의 메타정보를 이용해서 개발자가 Bean을 직접 찾는 행위야\n\nDI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.\nDI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.\n개념 자체는 `IoC의 형태 중 하나`라고 볼 수 있다.\n\nDI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.\n클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.\n\n\n\nSpring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며\n객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.\n\n1. Constructor Injection\n2. Dependency Constructor Injection\n3. Setter Injection\n4. Field Injection\n\n\n\n# 의존성 주입 Annotation\n\nSpring/Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.\n\n* @Autowired\n  * Spring에서 지원하는 Annotation\n  * `Type`에 맞춰서 주입이 된다.\n  * Interface에 상응하는 Bean이 2개 이상 인 경우에는 `@Qualifier(\"beanName\")을 혼용`하여 \n    필요한 Bean객체를 주입한다.\n* @Inject\n  * Java에서 지원하는 Annotation\n  * `Type`에 맞춰서 주입이 된다.\n* @Resource\n  * Java에서 지원하는 Annotation\n  * `이름`에 맞춰서 주입이 된다.\n\nSpring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject/@Resource를 사용하면 문제는 없을 것이나.. 대부분은 @Autowired를 사용한다.\n\n\n\n# DI 구현방식\n\n## Constructor Injection\n\n생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.\n이 방법은 xml 설정 시에 유용한 방법이다.\n객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    \n    @Autowired\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\n~~~xml\n<bean id=\"userRepository\" class=\"com.example.user.UserRepository\"></bean>\n<bean id=\"userService\", class=\"com.example.user.UserService\">\n\t<construct-args>\n        <ref bean=\"userRepository\"></ref>\n    </construct-args>\n</bean>\n~~~\n\n\n\n## Extension Constructor Injection\n\nSpring 4에 추가된 DI방법이다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\nUserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.\n어찌보면 당연한 내용 같은데...  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.\n\n\n\n~~~java\n@AllArgsConstructor\npublic Class UserService {\n    private UserRepository userRepository;\n}\n~~~\n\n\n\n## Setter Injection\n\nSetter를 통해 DI하는 방법이다.\n이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    \n    @Autowired\n    public setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\n\n\n## Field Injection\n\nSpring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.\n아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.\n\n~~~java\npublic Class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}\n~~~\n\n\n\n# 용어 설명\n\n* Bean\n  * Spring Container에 등록 되는 POJO객체 \n  * Spring Application의 Component들이 등록 된다.\n  * 기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.\n* Bean Factory\n  * Spring IoC를 담당하는 핵심 컨테이너\n  * Bean에 대한 등록/생성/조회/소멸을 관리한다.\n  * BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.\n  * 대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)\n* Application Context\n  * BeanFactory 인터페이스의 구현체 ()\n    * 정확히는 ListableBeanFactory\n    * Bean을 Listable하게 보관하는 인터페이스를 말한다.\n  * BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.\n    * ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.\n    * ApplicationEventPublisher - 이벤트 발생을 관장한다.\n    * MessageSource - properties파일을 통해 다국어 설정이 가능\n    * BeanLifecycle - Bean의 초기화, 소멸을 담당한다.\n* Configuration Meta Data \n  * Application Context에서 IoC 설정을 위해 사용되는 메타정보\n  * 컨테이너에 어떤 기능을 세팅할때 사용\n  * Bean 생성/구성할 경우에도 사용\n  * @Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능\n\n\n\n# Bean 등록 방법\n\n## Component-Scan\n\nSpring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.\nSpring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.\n분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에 \n불필요한 메모리 할당이 이루어질 수 있다.\n그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 `가장 많이 하는 설정`이 아닐까 싶다.\n\n* @Component 종류\n  * @Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)\n  * @Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)\n  * @Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)\n  * @Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)\n\n\n\n## Servlet-Context.xml\n\n기존 Bean 생성을 xml로 등록하는 방식이다.\n이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만...\n보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.\n위에서 언급한 `Component-scan`을 주로 사용하는 것이 좋다.\n\n~~~xml\n <bean name=\"beanNameViewResolver\" class=\"org.springframework.web.servlet.view.BeanNameViewResolver\">\n        <property name=\"order\" value=\"1\"/>\n    </bean>\n    <bean name=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/views/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n        <property name=\"order\" value=\"2\"/>\n    </bean>\n~~~\n\n\n\n## @Configuration\n\nxml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.\n뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.\nBean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 `@Bean` 어노테이션을 붙여주면 된다.\n\n~~~java\n@Configuration\npublic class UserConfig {\n    @Bean\n    public UserService userService() { //메소드 명이 기본적으로 Bean Name으로 추가된다.\n        return new UserService();\n    }\n}\n~~~\n\nJava Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우 \n아주 유용한 방법이라 할 수 있겠다.\n\n\n\n# Bean 생명주기\n\nSpring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.\nBean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.\n\nBean 생명주기 처리를 하는 방법은 3가지 방식이 있다.\n\n1. InitializingBean, DisposableBean 인터페이스 구현\n2. Bean정의 시 , 메소드 지정\n3. @PostConstruct, @PreDestroy Annotation 사용\n\n\n\n## InitializingBean, DisposableBean 인터페이스 구현\n\nInitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시 \n기능을 확장 할 수 있다.\n\nInitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에\nSpring에 종속적이게 된다.\n\n~~~java\npublic class TestBeanClass implements InitializingBean, DisposableBean{\n\t\n    private Connection conn;\n    \n    @Override\n    public void afterPropertiesSet() throws Exception {\n        //자원의 할당 처리\n        conn = DBConnectionCaller.getConnection();\n        System.out.println(\"bean 생성 및 초기화 : afterPropertiesSet() 호출됨\");\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        //주로 할당된 자원의 해제를 한다.\n        if(conn != null) conn.close();\n        System.out.println(\"bean 소멸 : destroy 호출됨\");\n    }\n}\n\n~~~\n\n\n\n## Bean정의 시 , 메소드 지정\n\n~~~xml\n<bean id=\"testBean\" class=\"com.example.TestBeanClass\"                      \n   init-method=\"init\" destroy-method=\"destroy\"/>\n~~~\n\n* xml설정 파일 <bean>에서 **init-method** 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출\n* xml설정 파일 <bean>에서 **destroy-method** 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출\n\n\n\n## @PostConstruct, @PreDestroy Annotation 사용\n\n~~~java\npublic class TestBeanClass {be\n\t\n    private Connection conn;\n    \n    @PostConstruct\n    public void init() {\n        //자원의 할당 처리\n        conn = DBConnectionCaller.getConnection();\n        System.out.println(\"bean 생성 및 초기화\");\n    }\n\n    @PreDestroy\n    public void destroy() {\n        //주로 할당된 자원의 해제를 한다.\n        if(conn != null) conn.close();\n        System.out.println(\"bean 소멸\");\n    }\n}\n~~~\n\n@PostConstuct, @PreDestroy 은 `JSR-250 Annotation` 기반이다 (한마디로 자바기반)\n따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.\n\n\n\n@PostConstuct, @PreDestroy 을 사용하기 위해서는\n`<annotation-config/> `설정이나, `@AnnotationDrivenConfig `어노테이션을 붙여줘야 한다.\n\n\n\n# Bean Scope\n\nhttps://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html 을 참고함\n\n* Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.\n* Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.\n* Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용\n* Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.\n  (이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)\n* Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다. \n\n\n\n# 참조\n\nhttp://www.javajigi.net/pages/viewpage.action?pageId=3664&focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\nhttps://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3\n토비의 스프링 VOL.2 Spring IoC","source":"_posts/2018-09-21-spring-ioc-2.md","raw":"---\ntitle: Spring IoC & DI(2)\nsubtitle: Spring IoC와 DI\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\ntypora-root-url: ./2018-09-21-spring-ioc-2\ntypora-copy-images-to: ./2018-09-21-spring-ioc-2\ndate: 2018-09-22 17:00:54\nheader-img:\n---\n\n# IoC란?\n\nInversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.\n보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.\n하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며\n개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.\n\n따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여\n제어의 역전 (Inversion of Control)이라 불린다.\n\n\n\n# Container가 도데체 뭐람?\n\n![containers](./containers.jpg)\n\n\n\n개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다. \nSpring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등.. Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까? \n위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다. \n이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.\n컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는.. 컨테이너를 생각하는 것이 도움이 될 것 같다.\n실제 프레임워크에서의 컨테이너도 같은 역할을 한다. \n\n**이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체**라고 할 수 있다. \n\n위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면\n\n서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,\n외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.\n\nSpring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.\n\n\n\n# DI란?\n\nDI란 Dependency Injection의 의미로 IoC를 구현한 대표적인 예야\nPojo 객체내의 종속적인 객체를 IoC Container에서 직접 객체를 Injection해주는 걸 의미해\n스프링 개발에서는 99프로 DI방식을 통해 개발자가 직접 필요한 객체를 선언하지 않고 \nIoC Container에서 넣어줘서 사용해 —> 이거는 Bean 초기화시에 이루어져\nDL (Dependency Lookup) 이라는 기능도 있는데 이거는 거의 사용하지는 않아\n이 기능은 IoC Container에서 Bean의 메타정보를 이용해서 개발자가 Bean을 직접 찾는 행위야\n\nDI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.\nDI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.\n개념 자체는 `IoC의 형태 중 하나`라고 볼 수 있다.\n\nDI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.\n클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.\n\n\n\nSpring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며\n객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.\n\n1. Constructor Injection\n2. Dependency Constructor Injection\n3. Setter Injection\n4. Field Injection\n\n\n\n# 의존성 주입 Annotation\n\nSpring/Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.\n\n* @Autowired\n  * Spring에서 지원하는 Annotation\n  * `Type`에 맞춰서 주입이 된다.\n  * Interface에 상응하는 Bean이 2개 이상 인 경우에는 `@Qualifier(\"beanName\")을 혼용`하여 \n    필요한 Bean객체를 주입한다.\n* @Inject\n  * Java에서 지원하는 Annotation\n  * `Type`에 맞춰서 주입이 된다.\n* @Resource\n  * Java에서 지원하는 Annotation\n  * `이름`에 맞춰서 주입이 된다.\n\nSpring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject/@Resource를 사용하면 문제는 없을 것이나.. 대부분은 @Autowired를 사용한다.\n\n\n\n# DI 구현방식\n\n## Constructor Injection\n\n생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.\n이 방법은 xml 설정 시에 유용한 방법이다.\n객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    \n    @Autowired\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\n~~~xml\n<bean id=\"userRepository\" class=\"com.example.user.UserRepository\"></bean>\n<bean id=\"userService\", class=\"com.example.user.UserService\">\n\t<construct-args>\n        <ref bean=\"userRepository\"></ref>\n    </construct-args>\n</bean>\n~~~\n\n\n\n## Extension Constructor Injection\n\nSpring 4에 추가된 DI방법이다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\nUserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.\n어찌보면 당연한 내용 같은데...  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.\n\n\n\n~~~java\n@AllArgsConstructor\npublic Class UserService {\n    private UserRepository userRepository;\n}\n~~~\n\n\n\n## Setter Injection\n\nSetter를 통해 DI하는 방법이다.\n이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    \n    @Autowired\n    public setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\n\n\n## Field Injection\n\nSpring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.\n아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.\n\n~~~java\npublic Class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}\n~~~\n\n\n\n# 용어 설명\n\n* Bean\n  * Spring Container에 등록 되는 POJO객체 \n  * Spring Application의 Component들이 등록 된다.\n  * 기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.\n* Bean Factory\n  * Spring IoC를 담당하는 핵심 컨테이너\n  * Bean에 대한 등록/생성/조회/소멸을 관리한다.\n  * BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.\n  * 대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)\n* Application Context\n  * BeanFactory 인터페이스의 구현체 ()\n    * 정확히는 ListableBeanFactory\n    * Bean을 Listable하게 보관하는 인터페이스를 말한다.\n  * BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.\n    * ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.\n    * ApplicationEventPublisher - 이벤트 발생을 관장한다.\n    * MessageSource - properties파일을 통해 다국어 설정이 가능\n    * BeanLifecycle - Bean의 초기화, 소멸을 담당한다.\n* Configuration Meta Data \n  * Application Context에서 IoC 설정을 위해 사용되는 메타정보\n  * 컨테이너에 어떤 기능을 세팅할때 사용\n  * Bean 생성/구성할 경우에도 사용\n  * @Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능\n\n\n\n# Bean 등록 방법\n\n## Component-Scan\n\nSpring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.\nSpring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.\n분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에 \n불필요한 메모리 할당이 이루어질 수 있다.\n그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 `가장 많이 하는 설정`이 아닐까 싶다.\n\n* @Component 종류\n  * @Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)\n  * @Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)\n  * @Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)\n  * @Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)\n\n\n\n## Servlet-Context.xml\n\n기존 Bean 생성을 xml로 등록하는 방식이다.\n이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만...\n보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.\n위에서 언급한 `Component-scan`을 주로 사용하는 것이 좋다.\n\n~~~xml\n <bean name=\"beanNameViewResolver\" class=\"org.springframework.web.servlet.view.BeanNameViewResolver\">\n        <property name=\"order\" value=\"1\"/>\n    </bean>\n    <bean name=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/views/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n        <property name=\"order\" value=\"2\"/>\n    </bean>\n~~~\n\n\n\n## @Configuration\n\nxml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.\n뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.\nBean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 `@Bean` 어노테이션을 붙여주면 된다.\n\n~~~java\n@Configuration\npublic class UserConfig {\n    @Bean\n    public UserService userService() { //메소드 명이 기본적으로 Bean Name으로 추가된다.\n        return new UserService();\n    }\n}\n~~~\n\nJava Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우 \n아주 유용한 방법이라 할 수 있겠다.\n\n\n\n# Bean 생명주기\n\nSpring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.\nBean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.\n\nBean 생명주기 처리를 하는 방법은 3가지 방식이 있다.\n\n1. InitializingBean, DisposableBean 인터페이스 구현\n2. Bean정의 시 , 메소드 지정\n3. @PostConstruct, @PreDestroy Annotation 사용\n\n\n\n## InitializingBean, DisposableBean 인터페이스 구현\n\nInitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시 \n기능을 확장 할 수 있다.\n\nInitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에\nSpring에 종속적이게 된다.\n\n~~~java\npublic class TestBeanClass implements InitializingBean, DisposableBean{\n\t\n    private Connection conn;\n    \n    @Override\n    public void afterPropertiesSet() throws Exception {\n        //자원의 할당 처리\n        conn = DBConnectionCaller.getConnection();\n        System.out.println(\"bean 생성 및 초기화 : afterPropertiesSet() 호출됨\");\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        //주로 할당된 자원의 해제를 한다.\n        if(conn != null) conn.close();\n        System.out.println(\"bean 소멸 : destroy 호출됨\");\n    }\n}\n\n~~~\n\n\n\n## Bean정의 시 , 메소드 지정\n\n~~~xml\n<bean id=\"testBean\" class=\"com.example.TestBeanClass\"                      \n   init-method=\"init\" destroy-method=\"destroy\"/>\n~~~\n\n* xml설정 파일 <bean>에서 **init-method** 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출\n* xml설정 파일 <bean>에서 **destroy-method** 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출\n\n\n\n## @PostConstruct, @PreDestroy Annotation 사용\n\n~~~java\npublic class TestBeanClass {be\n\t\n    private Connection conn;\n    \n    @PostConstruct\n    public void init() {\n        //자원의 할당 처리\n        conn = DBConnectionCaller.getConnection();\n        System.out.println(\"bean 생성 및 초기화\");\n    }\n\n    @PreDestroy\n    public void destroy() {\n        //주로 할당된 자원의 해제를 한다.\n        if(conn != null) conn.close();\n        System.out.println(\"bean 소멸\");\n    }\n}\n~~~\n\n@PostConstuct, @PreDestroy 은 `JSR-250 Annotation` 기반이다 (한마디로 자바기반)\n따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.\n\n\n\n@PostConstuct, @PreDestroy 을 사용하기 위해서는\n`<annotation-config/> `설정이나, `@AnnotationDrivenConfig `어노테이션을 붙여줘야 한다.\n\n\n\n# Bean Scope\n\nhttps://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html 을 참고함\n\n* Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.\n* Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.\n* Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용\n* Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.\n  (이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)\n* Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다. \n\n\n\n# 참조\n\nhttp://www.javajigi.net/pages/viewpage.action?pageId=3664&focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\nhttps://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3\n토비의 스프링 VOL.2 Spring IoC","slug":"2018-09-21-spring-ioc-2","published":1,"updated":"2018-11-27T07:23:32.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv3rl0033cr1tvdiw7k6a","content":"<h1 id=\"ioc란\">IoC란?</h1>\n<p>Inversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.\n보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.\n하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며\n개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.</p>\n<p>따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여\n제어의 역전 (Inversion of Control)이라 불린다.</p>\n<h1 id=\"container가-도데체-뭐람\">Container가 도데체 뭐람?</h1>\n<p><img src=\"./containers.jpg\" alt=\"containers\"></p>\n<p>개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다.\nSpring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등.. Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까?\n위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다.\n이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.\n컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는.. 컨테이너를 생각하는 것이 도움이 될 것 같다.\n실제 프레임워크에서의 컨테이너도 같은 역할을 한다.</p>\n<p><strong>이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체</strong>라고 할 수 있다.</p>\n<p>위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면</p>\n<p>서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,\n외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.</p>\n<p>Spring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.</p>\n<h1 id=\"di란\">DI란?</h1>\n<p>DI란 Dependency Injection의 의미로 IoC를 구현한 대표적인 예야\nPojo 객체내의 종속적인 객체를 IoC Container에서 직접 객체를 Injection해주는 걸 의미해\n스프링 개발에서는 99프로 DI방식을 통해 개발자가 직접 필요한 객체를 선언하지 않고\nIoC Container에서 넣어줘서 사용해 —&gt; 이거는 Bean 초기화시에 이루어져\nDL (Dependency Lookup) 이라는 기능도 있는데 이거는 거의 사용하지는 않아\n이 기능은 IoC Container에서 Bean의 메타정보를 이용해서 개발자가 Bean을 직접 찾는 행위야</p>\n<p>DI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.\nDI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.\n개념 자체는 <code>IoC의 형태 중 하나</code>라고 볼 수 있다.</p>\n<p>DI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.\n클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.</p>\n<p>Spring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며\n객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.</p>\n<ol>\n<li>Constructor Injection</li>\n<li>Dependency Constructor Injection</li>\n<li>Setter Injection</li>\n<li>Field Injection</li>\n</ol>\n<h1 id=\"의존성-주입-annotation\">의존성 주입 Annotation</h1>\n<p>Spring/Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.</p>\n<ul>\n<li>@Autowired\n<ul>\n<li>Spring에서 지원하는 Annotation</li>\n<li><code>Type</code>에 맞춰서 주입이 된다.</li>\n<li>Interface에 상응하는 Bean이 2개 이상 인 경우에는 <code>@Qualifier(&quot;beanName&quot;)을 혼용</code>하여\n필요한 Bean객체를 주입한다.</li>\n</ul>\n</li>\n<li>@Inject\n<ul>\n<li>Java에서 지원하는 Annotation</li>\n<li><code>Type</code>에 맞춰서 주입이 된다.</li>\n</ul>\n</li>\n<li>@Resource\n<ul>\n<li>Java에서 지원하는 Annotation</li>\n<li><code>이름</code>에 맞춰서 주입이 된다.</li>\n</ul>\n</li>\n</ul>\n<p>Spring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject/@Resource를 사용하면 문제는 없을 것이나.. 대부분은 @Autowired를 사용한다.</p>\n<h1 id=\"di-구현방식\">DI 구현방식</h1>\n<h2 id=\"constructor-injection\">Constructor Injection</h2>\n<p>생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.\n이 방법은 xml 설정 시에 유용한 방법이다.\n객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userRepository\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.user.UserRepository\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span>, <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.user.UserService\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">construct-args</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userRepository\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ref</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">construct-args</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"extension-constructor-injection\">Extension Constructor Injection</h2>\n<p>Spring 4에 추가된 DI방법이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>UserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.\n어찌보면 당연한 내용 같은데...  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"setter-injection\">Setter Injection</h2>\n<p>Setter를 통해 DI하는 방법이다.\n이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">setUserRepository</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"field-injection\">Field Injection</h2>\n<p>Spring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.\n아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"용어-설명\">용어 설명</h1>\n<ul>\n<li>Bean\n<ul>\n<li>Spring Container에 등록 되는 POJO객체</li>\n<li>Spring Application의 Component들이 등록 된다.</li>\n<li>기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.</li>\n</ul>\n</li>\n<li>Bean Factory\n<ul>\n<li>Spring IoC를 담당하는 핵심 컨테이너</li>\n<li>Bean에 대한 등록/생성/조회/소멸을 관리한다.</li>\n<li>BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.</li>\n<li>대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)</li>\n</ul>\n</li>\n<li>Application Context\n<ul>\n<li>BeanFactory 인터페이스의 구현체 ()\n<ul>\n<li>정확히는 ListableBeanFactory</li>\n<li>Bean을 Listable하게 보관하는 인터페이스를 말한다.</li>\n</ul>\n</li>\n<li>BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.\n<ul>\n<li>ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.</li>\n<li>ApplicationEventPublisher - 이벤트 발생을 관장한다.</li>\n<li>MessageSource - properties파일을 통해 다국어 설정이 가능</li>\n<li>BeanLifecycle - Bean의 초기화, 소멸을 담당한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Configuration Meta Data\n<ul>\n<li>Application Context에서 IoC 설정을 위해 사용되는 메타정보</li>\n<li>컨테이너에 어떤 기능을 세팅할때 사용</li>\n<li>Bean 생성/구성할 경우에도 사용</li>\n<li>@Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"bean-등록-방법\">Bean 등록 방법</h1>\n<h2 id=\"component-scan\">Component-Scan</h2>\n<p>Spring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.\nSpring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.\n분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에\n불필요한 메모리 할당이 이루어질 수 있다.\n그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 <code>가장 많이 하는 설정</code>이 아닐까 싶다.</p>\n<ul>\n<li>@Component 종류\n<ul>\n<li>@Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)</li>\n<li>@Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)</li>\n<li>@Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)</li>\n<li>@Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"servlet-contextxml\">Servlet-Context.xml</h2>\n<p>기존 Bean 생성을 xml로 등록하는 방식이다.\n이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만...\n보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.\n위에서 언급한 <code>Component-scan</code>을 주로 사용하는 것이 좋다.</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"beanNameViewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.BeanNameViewResolver\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"order\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"internalResourceViewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/WEB-INF/views/\"</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"order\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"2\"</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"configuration\">@Configuration</h2>\n<p>xml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.\n뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.\nBean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 <code>@Bean</code> 어노테이션을 붙여주면 된다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserService <span class=\"title\">userService</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//메소드 명이 기본적으로 Bean Name으로 추가된다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserService();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Java Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우\n아주 유용한 방법이라 할 수 있겠다.</p>\n<h1 id=\"bean-생명주기\">Bean 생명주기</h1>\n<p>Spring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.\nBean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.</p>\n<p>Bean 생명주기 처리를 하는 방법은 3가지 방식이 있다.</p>\n<ol>\n<li>InitializingBean, DisposableBean 인터페이스 구현</li>\n<li>Bean정의 시 , 메소드 지정</li>\n<li>@PostConstruct, @PreDestroy Annotation 사용</li>\n</ol>\n<h2 id=\"initializingbean-disposablebean-인터페이스-구현\">InitializingBean, DisposableBean 인터페이스 구현</h2>\n<p>InitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시\n기능을 확장 할 수 있다.</p>\n<p>InitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에\nSpring에 종속적이게 된다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBeanClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span>, <span class=\"title\">DisposableBean</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection conn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//자원의 할당 처리</span></span><br><span class=\"line\">        conn = DBConnectionCaller.getConnection();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 생성 및 초기화 : afterPropertiesSet() 호출됨\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//주로 할당된 자원의 해제를 한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) conn.close();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 소멸 : destroy 호출됨\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"bean정의-시-메소드-지정\">Bean정의 시 , 메소드 지정</h2>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.TestBeanClass\"</span>                      </span></span><br><span class=\"line\"><span class=\"tag\">   <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"destroy\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>xml설정 파일 &lt;bean&gt;에서 <strong>init-method</strong> 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출</li>\n<li>xml설정 파일 &lt;bean&gt;에서 <strong>destroy-method</strong> 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출</li>\n</ul>\n<h2 id=\"postconstruct-predestroy-annotation-사용\">@PostConstruct, @PreDestroy Annotation 사용</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBeanClass</span> </span>&#123;be</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection conn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//자원의 할당 처리</span></span><br><span class=\"line\">        conn = DBConnectionCaller.getConnection();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 생성 및 초기화\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//주로 할당된 자원의 해제를 한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) conn.close();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 소멸\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>@PostConstuct, @PreDestroy 은 <code>JSR-250 Annotation</code> 기반이다 (한마디로 자바기반)\n따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.</p>\n<p>@PostConstuct, @PreDestroy 을 사용하기 위해서는\n<code>&lt;annotation-config/&gt;</code>설정이나, <code>@AnnotationDrivenConfig</code>어노테이션을 붙여줘야 한다.</p>\n<h1 id=\"bean-scope\">Bean Scope</h1>\n<p>https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html 을 참고함</p>\n<ul>\n<li>Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.</li>\n<li>Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.</li>\n<li>Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용</li>\n<li>Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.\n(이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)</li>\n<li>Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다.</li>\n</ul>\n<h1 id=\"참조\">참조</h1>\n<p>http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\nhttps://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3\n토비의 스프링 VOL.2 Spring IoC</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>IoC란?</h1>\n<p>Inversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.\n보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.\n하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며\n개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.</p>\n<p>따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여\n제어의 역전 (Inversion of Control)이라 불린다.</p>\n<h1>Container가 도데체 뭐람?</h1>\n<p><img src=\"./containers.jpg\" alt=\"containers\"></p>\n<p>개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다.\nSpring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등.. Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까?\n위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다.\n이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.\n컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는.. 컨테이너를 생각하는 것이 도움이 될 것 같다.\n실제 프레임워크에서의 컨테이너도 같은 역할을 한다.</p>\n<p><strong>이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체</strong>라고 할 수 있다.</p>\n<p>위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면</p>\n<p>서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,\n외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.</p>\n<p>Spring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.</p>\n<h1>DI란?</h1>\n<p>DI란 Dependency Injection의 의미로 IoC를 구현한 대표적인 예야\nPojo 객체내의 종속적인 객체를 IoC Container에서 직접 객체를 Injection해주는 걸 의미해\n스프링 개발에서는 99프로 DI방식을 통해 개발자가 직접 필요한 객체를 선언하지 않고\nIoC Container에서 넣어줘서 사용해 —&gt; 이거는 Bean 초기화시에 이루어져\nDL (Dependency Lookup) 이라는 기능도 있는데 이거는 거의 사용하지는 않아\n이 기능은 IoC Container에서 Bean의 메타정보를 이용해서 개발자가 Bean을 직접 찾는 행위야</p>\n<p>DI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.\nDI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.\n개념 자체는 <code>IoC의 형태 중 하나</code>라고 볼 수 있다.</p>\n<p>DI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.\n클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.</p>\n<p>Spring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며\n객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.</p>\n<ol>\n<li>Constructor Injection</li>\n<li>Dependency Constructor Injection</li>\n<li>Setter Injection</li>\n<li>Field Injection</li>\n</ol>\n<h1>의존성 주입 Annotation</h1>\n<p>Spring/Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.</p>\n<ul>\n<li>@Autowired\n<ul>\n<li>Spring에서 지원하는 Annotation</li>\n<li><code>Type</code>에 맞춰서 주입이 된다.</li>\n<li>Interface에 상응하는 Bean이 2개 이상 인 경우에는 <code>@Qualifier(&quot;beanName&quot;)을 혼용</code>하여\n필요한 Bean객체를 주입한다.</li>\n</ul>\n</li>\n<li>@Inject\n<ul>\n<li>Java에서 지원하는 Annotation</li>\n<li><code>Type</code>에 맞춰서 주입이 된다.</li>\n</ul>\n</li>\n<li>@Resource\n<ul>\n<li>Java에서 지원하는 Annotation</li>\n<li><code>이름</code>에 맞춰서 주입이 된다.</li>\n</ul>\n</li>\n</ul>\n<p>Spring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject/@Resource를 사용하면 문제는 없을 것이나.. 대부분은 @Autowired를 사용한다.</p>\n<h1>DI 구현방식</h1>\n<h2>Constructor Injection</h2>\n<p>생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.\n이 방법은 xml 설정 시에 유용한 방법이다.\n객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userRepository\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.user.UserRepository\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span>, <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.user.UserService\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">construct-args</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userRepository\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ref</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">construct-args</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2>Extension Constructor Injection</h2>\n<p>Spring 4에 추가된 DI방법이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>UserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.\n어찌보면 당연한 내용 같은데...  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>Setter Injection</h2>\n<p>Setter를 통해 DI하는 방법이다.\n이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">setUserRepository</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>Field Injection</h2>\n<p>Spring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.\n아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>용어 설명</h1>\n<ul>\n<li>Bean\n<ul>\n<li>Spring Container에 등록 되는 POJO객체</li>\n<li>Spring Application의 Component들이 등록 된다.</li>\n<li>기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.</li>\n</ul>\n</li>\n<li>Bean Factory\n<ul>\n<li>Spring IoC를 담당하는 핵심 컨테이너</li>\n<li>Bean에 대한 등록/생성/조회/소멸을 관리한다.</li>\n<li>BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.</li>\n<li>대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)</li>\n</ul>\n</li>\n<li>Application Context\n<ul>\n<li>BeanFactory 인터페이스의 구현체 ()\n<ul>\n<li>정확히는 ListableBeanFactory</li>\n<li>Bean을 Listable하게 보관하는 인터페이스를 말한다.</li>\n</ul>\n</li>\n<li>BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.\n<ul>\n<li>ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.</li>\n<li>ApplicationEventPublisher - 이벤트 발생을 관장한다.</li>\n<li>MessageSource - properties파일을 통해 다국어 설정이 가능</li>\n<li>BeanLifecycle - Bean의 초기화, 소멸을 담당한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Configuration Meta Data\n<ul>\n<li>Application Context에서 IoC 설정을 위해 사용되는 메타정보</li>\n<li>컨테이너에 어떤 기능을 세팅할때 사용</li>\n<li>Bean 생성/구성할 경우에도 사용</li>\n<li>@Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능</li>\n</ul>\n</li>\n</ul>\n<h1>Bean 등록 방법</h1>\n<h2>Component-Scan</h2>\n<p>Spring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.\nSpring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.\n분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에\n불필요한 메모리 할당이 이루어질 수 있다.\n그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 <code>가장 많이 하는 설정</code>이 아닐까 싶다.</p>\n<ul>\n<li>@Component 종류\n<ul>\n<li>@Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)</li>\n<li>@Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)</li>\n<li>@Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)</li>\n<li>@Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)</li>\n</ul>\n</li>\n</ul>\n<h2>Servlet-Context.xml</h2>\n<p>기존 Bean 생성을 xml로 등록하는 방식이다.\n이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만...\n보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.\n위에서 언급한 <code>Component-scan</code>을 주로 사용하는 것이 좋다.</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"beanNameViewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.BeanNameViewResolver\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"order\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"internalResourceViewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/WEB-INF/views/\"</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"order\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"2\"</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2>@Configuration</h2>\n<p>xml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.\n뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.\nBean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 <code>@Bean</code> 어노테이션을 붙여주면 된다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserService <span class=\"title\">userService</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//메소드 명이 기본적으로 Bean Name으로 추가된다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserService();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Java Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우\n아주 유용한 방법이라 할 수 있겠다.</p>\n<h1>Bean 생명주기</h1>\n<p>Spring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.\nBean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.</p>\n<p>Bean 생명주기 처리를 하는 방법은 3가지 방식이 있다.</p>\n<ol>\n<li>InitializingBean, DisposableBean 인터페이스 구현</li>\n<li>Bean정의 시 , 메소드 지정</li>\n<li>@PostConstruct, @PreDestroy Annotation 사용</li>\n</ol>\n<h2>InitializingBean, DisposableBean 인터페이스 구현</h2>\n<p>InitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시\n기능을 확장 할 수 있다.</p>\n<p>InitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에\nSpring에 종속적이게 된다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBeanClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span>, <span class=\"title\">DisposableBean</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection conn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//자원의 할당 처리</span></span><br><span class=\"line\">        conn = DBConnectionCaller.getConnection();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 생성 및 초기화 : afterPropertiesSet() 호출됨\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//주로 할당된 자원의 해제를 한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) conn.close();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 소멸 : destroy 호출됨\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>Bean정의 시 , 메소드 지정</h2>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.TestBeanClass\"</span>                      </span></span><br><span class=\"line\"><span class=\"tag\">   <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"destroy\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>xml설정 파일 &lt;bean&gt;에서 <strong>init-method</strong> 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출</li>\n<li>xml설정 파일 &lt;bean&gt;에서 <strong>destroy-method</strong> 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출</li>\n</ul>\n<h2>@PostConstruct, @PreDestroy Annotation 사용</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBeanClass</span> </span>&#123;be</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection conn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//자원의 할당 처리</span></span><br><span class=\"line\">        conn = DBConnectionCaller.getConnection();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 생성 및 초기화\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//주로 할당된 자원의 해제를 한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) conn.close();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 소멸\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>@PostConstuct, @PreDestroy 은 <code>JSR-250 Annotation</code> 기반이다 (한마디로 자바기반)\n따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.</p>\n<p>@PostConstuct, @PreDestroy 을 사용하기 위해서는\n<code>&lt;annotation-config/&gt;</code>설정이나, <code>@AnnotationDrivenConfig</code>어노테이션을 붙여줘야 한다.</p>\n<h1>Bean Scope</h1>\n<p>https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html 을 참고함</p>\n<ul>\n<li>Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.</li>\n<li>Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.</li>\n<li>Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용</li>\n<li>Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.\n(이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)</li>\n<li>Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다.</li>\n</ul>\n<h1>참조</h1>\n<p>http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\nhttps://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3\n토비의 스프링 VOL.2 Spring IoC</p>\n"},{"layout":"posts","title":"SpEL Expression(1)","catalog":true,"Categories":["Spring"],"date":"2018-11-21T05:11:42.000Z","typora-root-url":"2018-11-21-spel-expression","typora-copy-images-to":"2018-11-21-spel-expression","_content":"\n# 들어가며\n\nSpring Cache Abstraction 기능을 사용하게 되면서, key modeling 시, 필요한 SpEL에 대해 알아보게 되었다.\n기본적인 설명과 예제는 Spring Docs를 기반으로 번역\n\n# SpEL (<u>Sp</u>ring <u>E</u>xpression <u>L</u>anguage)이란?\n\nSpring Expression Language (줄여서 SpEL)은 런타임에 쿼리를 지원하고 객체를 조작할 수 있는 강력한 표현식 언어이다. 언어 구문은 Unified EL과 유사하지만, 여러가지 추가 기능을 제공한다.\n\n다른 Java에서 사용가능한 표현식 언어가 있지만, SpEL은 Spring 커뮤니티에 표현식 언어를 제공하기 위해 만들어졌다.\nSpring 포트폴리오 내에서 표현식 평가 (Expression evaluation)의 기반으로 SpEL을 제공하지만, SpEL은 Spring과 직접 연계되지 않고 독립적으로 사용 할 수 있다.\n독립적으로 사용하기 위해서는 Parser 같은 Bootstraping 기반 클래스에 대한 설정을 몇가지 할 필요가 있다.\n하지만 웬만한 개발자들은 이런 기반 클래스에 대한 설정 없이 SpEL 표현식만 잘 작성하면 된다.\n\n# SpEL에서 지원하는 기능\n\n* 리터럴 표현식 (Literal Expression)\n* Boolean과 관계형 Operator (Boolean and Relational Operator)\n* 정규 표현식 (Regular Expression)\n* 클래스 표현식 (Class Expression)\n* 프로퍼티, 배열, 리스트, 맵에 대한 접근 지원 (Accessing properties, arrays, lists, maps)\n* 메서드 호출 (Method Invocation)\n* 관계형 Operator (Relational Operator)\n* 할당 (Assignment)\n* 생성자 호출 (Calling Constructors)\n* Bean 참조 (Bean References)\n* 배열 생성 (Array Contruction)\n* 인라인 리스트/맵 (Inline List/Map)\n* 삼항 연산자 (Ternary Operator)\n* 변수 (Variables)\n* 사용자 정의 함수 (User defined functions)\n* 컬렉션 투영 (Collections Projection)\n* 컬렉션 선택 (Collections Selection)\n* Template 표현식 (Templated expression)\n\n# Expression 인터페이스를 이용한 표현식 파싱\n\n``` java\npublic class ExpressionTest {\n\n    public static void main(String[] args) {\n\n        String message = parseExpression(\"\\\"Hello World\\\"\", String.class);\n        System.out.println(message); //\"Hello World\"\n\n        String message2 = parseExpression(\"\\\"Hello World\\\".concat('!')\", String.class);\n        System.out.println(message2); //\"Hello World!\"\n    }\n\n    public static <T> T parseExpression(String expression, Class<T> clazz) {\n        ExpressionParser parser = new SpelExpressionParser();\n        Expression exp = parser.parseExpression(expression);\n        return exp.getValue(clazz);\n    }\n}\n```\n\n* 위의 코드는 SpEL표현식 문자열에 대한 파싱(Parsing) 하는 프로그램의 예제 코드이다.\n* ExpressionParser Interface를 구현하는 SpelExpressionParser로 SpEL 표현식의 내용을 파싱(Parsing) 할 수 있다.\n* exp.getValue() 메서드를 이용해 파싱된 결과값을 Object 타입으로 얻거나, Class정보를 파라미터로 추가해 자동으로 타입 캐스팅이 가능하다.\n\n# EvaluationContext 인터페이스를 이용한 표현식 파싱\n\n* Property, Method, Field에 대한 파싱을 처리\n* 타입변환을 수행하는 표현식을 평가 할 때 EvaluationContext 인터페이스를 사용\n* EvaluationContext의 구현체인 StandardEvaluationContext는 객체를 조작하기 위해 java reflection의 기능을 사용\n* 성능을 향상 시키기 위해 java.lang.reflect의 Method, Field, Constructor를 캐싱한다.\n\nSpEL의 더 일반적인 사용법은 특정 객체 인스턴스(root객체)에 대해 평가되는 표현식 문자열을 제공하는 것이다.\nroot객체를 제공하는 방식은 2가지 방식이 있다.\n\n## root 객체를 똑같이 제공하는 경우\n\n``` java\n// Create and set a calendar\nGregorianCalendar c = new GregorianCalendar();\nc.set(1856, 7, 9);\n\n// name, birthday, nationality를 파라미터로 갖는 생성자이다.\nInventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");\n\nExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"name\"); //tesla객체의 name 프로퍼티가 파싱\n\n//Context에 tesla객체를 넣어준다.\nEvaluationContext context = new StandardEvaluationContext(tesla);\nString name = (String) exp.getValue(context); //name = \"Nikola Tesla\"\n```\n\n* StandardEvaluationContext는 `name` 프로퍼티가 평가 될 객체를 지정하는 클래스이다.\n  (위의 예제는 root객체, 즉 tesla 객체를 고정하여 사용하는 예제)\n* 위의 SpelExpressionParser가 표현식을 평가 할 때, 표현식의 대한 기준을 Tesla 객체로 지정하는 부분이다.\n* `parser.parseExpression(\"name\");` 가 실행되면, tesla 객체의 name 프로퍼티가 파싱된다.\n* name변수에는 `Nikola Tesla` 문자열이 리턴된다.\n* 타입 캐스팅 실패 시에는, `EvaluationException`이 throw된다.\n\n## root 객체가 계속 변경되는 경우\n\n``` java\n// Create and set a calendar\nGregorianCalendar c = new GregorianCalendar();\nc.set(1856, 7, 9);\n\n// name, birthday, nationality를 파라미터로 갖는 생성자이다.\nInventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");\n\nExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"name\"); //tesla객체의 name 프로퍼티가 파싱\n\nString name = (String) exp.getValue(tesla);\n```\n\ngetValue 메서드 호출 시에, StandardEvaluationContext를 사용하지 않고 root 객체를 직접 지정해 준다.\n\n## 두 가지 방식의 차이\n\n* StandardEvaluationContext를 사용하는 경우 생성 비용이 상대적으로 많이 든다.\n* 반복적으로 사용하는 동안 `Field에 대해 캐싱되고 있기 때문에 표현식 파싱이 더 빠르다`는 장점이 있다.\n* 설정 파일에서 SpEL을 사용하는 경우에는, root 객체를 고정하고 SpEL 표현식만 개발자에게 설정 하도록 하는 것이 좋다.\n\n\n# Bean을 정의하는 표현식\n* BeanDefinition을 정의하는 XML이나, Annotation 기반의 설정에는 MetaData와 SpEL표현식을 같이 사용할 수 있다.\n* `#{<expression>}` 문법으로 사용한다.\n\n\n## XML Based\n* 프로퍼티나 생성자 Argument 값을 표현식으로 나타낼 수 있다.\n```xml\n<bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\">\n  <property name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/>\n</bean>\n```\n\nsystemProperties bean을 미리 지정하여 사용할 수 있다. (bean을 사용하였지만 `@` 문자를 안붙인 것을 주의)\n```xml\n<bean id=\"taxCalculator\" class=\"org.spring.samples.TaxCalculator\">\n  <property name=\"defaultLocale\" value=\"#{ systemProperties['user.region'] }\"/>\n</bean>\n```\n\n아래 예제 처럼 다른 bean의 Properties를 사용할 수 있다.\n```xml\n<bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\">\n  <property name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/>\n</bean>\n\n<bean id=\"shapeGuess\" class=\"org.spring.samples.ShapeGuess\">\n  <property name=\"initialShapeSeed\" value=\"#{ numberGuess.randomNumber }\"/>\n</bean>\n```\n\n## Annotation Based\n* 기본값을 지정하기 위해 @Value Annotation을 이용해 Field, Method, Method-Parameter에 붙일 수 있다.\n\n```java\npublic static class FieldValueTestBean\n\n  @Value(\"#{ systemProperties['user.region'] }\")\n  private String defaultLocale;\n\n  public void setDefaultLocale(String defaultLocale)\n  {\n    this.defaultLocale = defaultLocale;\n  }\n\n  public String getDefaultLocale() \n  {\n    return this.defaultLocale;\n  }\n}\n```\n\n```java\npublic static class PropertyValueTestBean\n\n  private String defaultLocale;\n\n  @Value(\"#{ systemProperties['user.region'] }\")\n  public void setDefaultLocale(String defaultLocale)\n  {\n    this.defaultLocale = defaultLocale;\n  }\n}\n```\n\n```java\n  private MovieFinder movieFinder;\n  private String defaultLocale;\n\n  @Autowired\n  public void configure(MovieFinder movieFinder, \n                   @Value(\"#{ systemProperties['user.region'] }\"} String defaultLocale) {\n    this.movieFinder = movieFinder;\n    this.defaultLocale = defaultLocale;\n  }\n```\n\n\n\n\n# 참고\n\n* https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html\n* https://blog.outsider.ne.kr/835\n* https://blog.outsider.ne.kr/837","source":"_posts/2018-11-21-spel-expression.md","raw":"---\nlayout: posts\ntitle: SpEL Expression(1)\ncatalog: true\nCategories:\n- Spring\ntags:\n- Spring\n- SpEL\ndate: 2018-11-21 14:11:42\ntypora-root-url: 2018-11-21-spel-expression\ntypora-copy-images-to: 2018-11-21-spel-expression\n---\n\n# 들어가며\n\nSpring Cache Abstraction 기능을 사용하게 되면서, key modeling 시, 필요한 SpEL에 대해 알아보게 되었다.\n기본적인 설명과 예제는 Spring Docs를 기반으로 번역\n\n# SpEL (<u>Sp</u>ring <u>E</u>xpression <u>L</u>anguage)이란?\n\nSpring Expression Language (줄여서 SpEL)은 런타임에 쿼리를 지원하고 객체를 조작할 수 있는 강력한 표현식 언어이다. 언어 구문은 Unified EL과 유사하지만, 여러가지 추가 기능을 제공한다.\n\n다른 Java에서 사용가능한 표현식 언어가 있지만, SpEL은 Spring 커뮤니티에 표현식 언어를 제공하기 위해 만들어졌다.\nSpring 포트폴리오 내에서 표현식 평가 (Expression evaluation)의 기반으로 SpEL을 제공하지만, SpEL은 Spring과 직접 연계되지 않고 독립적으로 사용 할 수 있다.\n독립적으로 사용하기 위해서는 Parser 같은 Bootstraping 기반 클래스에 대한 설정을 몇가지 할 필요가 있다.\n하지만 웬만한 개발자들은 이런 기반 클래스에 대한 설정 없이 SpEL 표현식만 잘 작성하면 된다.\n\n# SpEL에서 지원하는 기능\n\n* 리터럴 표현식 (Literal Expression)\n* Boolean과 관계형 Operator (Boolean and Relational Operator)\n* 정규 표현식 (Regular Expression)\n* 클래스 표현식 (Class Expression)\n* 프로퍼티, 배열, 리스트, 맵에 대한 접근 지원 (Accessing properties, arrays, lists, maps)\n* 메서드 호출 (Method Invocation)\n* 관계형 Operator (Relational Operator)\n* 할당 (Assignment)\n* 생성자 호출 (Calling Constructors)\n* Bean 참조 (Bean References)\n* 배열 생성 (Array Contruction)\n* 인라인 리스트/맵 (Inline List/Map)\n* 삼항 연산자 (Ternary Operator)\n* 변수 (Variables)\n* 사용자 정의 함수 (User defined functions)\n* 컬렉션 투영 (Collections Projection)\n* 컬렉션 선택 (Collections Selection)\n* Template 표현식 (Templated expression)\n\n# Expression 인터페이스를 이용한 표현식 파싱\n\n``` java\npublic class ExpressionTest {\n\n    public static void main(String[] args) {\n\n        String message = parseExpression(\"\\\"Hello World\\\"\", String.class);\n        System.out.println(message); //\"Hello World\"\n\n        String message2 = parseExpression(\"\\\"Hello World\\\".concat('!')\", String.class);\n        System.out.println(message2); //\"Hello World!\"\n    }\n\n    public static <T> T parseExpression(String expression, Class<T> clazz) {\n        ExpressionParser parser = new SpelExpressionParser();\n        Expression exp = parser.parseExpression(expression);\n        return exp.getValue(clazz);\n    }\n}\n```\n\n* 위의 코드는 SpEL표현식 문자열에 대한 파싱(Parsing) 하는 프로그램의 예제 코드이다.\n* ExpressionParser Interface를 구현하는 SpelExpressionParser로 SpEL 표현식의 내용을 파싱(Parsing) 할 수 있다.\n* exp.getValue() 메서드를 이용해 파싱된 결과값을 Object 타입으로 얻거나, Class정보를 파라미터로 추가해 자동으로 타입 캐스팅이 가능하다.\n\n# EvaluationContext 인터페이스를 이용한 표현식 파싱\n\n* Property, Method, Field에 대한 파싱을 처리\n* 타입변환을 수행하는 표현식을 평가 할 때 EvaluationContext 인터페이스를 사용\n* EvaluationContext의 구현체인 StandardEvaluationContext는 객체를 조작하기 위해 java reflection의 기능을 사용\n* 성능을 향상 시키기 위해 java.lang.reflect의 Method, Field, Constructor를 캐싱한다.\n\nSpEL의 더 일반적인 사용법은 특정 객체 인스턴스(root객체)에 대해 평가되는 표현식 문자열을 제공하는 것이다.\nroot객체를 제공하는 방식은 2가지 방식이 있다.\n\n## root 객체를 똑같이 제공하는 경우\n\n``` java\n// Create and set a calendar\nGregorianCalendar c = new GregorianCalendar();\nc.set(1856, 7, 9);\n\n// name, birthday, nationality를 파라미터로 갖는 생성자이다.\nInventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");\n\nExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"name\"); //tesla객체의 name 프로퍼티가 파싱\n\n//Context에 tesla객체를 넣어준다.\nEvaluationContext context = new StandardEvaluationContext(tesla);\nString name = (String) exp.getValue(context); //name = \"Nikola Tesla\"\n```\n\n* StandardEvaluationContext는 `name` 프로퍼티가 평가 될 객체를 지정하는 클래스이다.\n  (위의 예제는 root객체, 즉 tesla 객체를 고정하여 사용하는 예제)\n* 위의 SpelExpressionParser가 표현식을 평가 할 때, 표현식의 대한 기준을 Tesla 객체로 지정하는 부분이다.\n* `parser.parseExpression(\"name\");` 가 실행되면, tesla 객체의 name 프로퍼티가 파싱된다.\n* name변수에는 `Nikola Tesla` 문자열이 리턴된다.\n* 타입 캐스팅 실패 시에는, `EvaluationException`이 throw된다.\n\n## root 객체가 계속 변경되는 경우\n\n``` java\n// Create and set a calendar\nGregorianCalendar c = new GregorianCalendar();\nc.set(1856, 7, 9);\n\n// name, birthday, nationality를 파라미터로 갖는 생성자이다.\nInventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");\n\nExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"name\"); //tesla객체의 name 프로퍼티가 파싱\n\nString name = (String) exp.getValue(tesla);\n```\n\ngetValue 메서드 호출 시에, StandardEvaluationContext를 사용하지 않고 root 객체를 직접 지정해 준다.\n\n## 두 가지 방식의 차이\n\n* StandardEvaluationContext를 사용하는 경우 생성 비용이 상대적으로 많이 든다.\n* 반복적으로 사용하는 동안 `Field에 대해 캐싱되고 있기 때문에 표현식 파싱이 더 빠르다`는 장점이 있다.\n* 설정 파일에서 SpEL을 사용하는 경우에는, root 객체를 고정하고 SpEL 표현식만 개발자에게 설정 하도록 하는 것이 좋다.\n\n\n# Bean을 정의하는 표현식\n* BeanDefinition을 정의하는 XML이나, Annotation 기반의 설정에는 MetaData와 SpEL표현식을 같이 사용할 수 있다.\n* `#{<expression>}` 문법으로 사용한다.\n\n\n## XML Based\n* 프로퍼티나 생성자 Argument 값을 표현식으로 나타낼 수 있다.\n```xml\n<bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\">\n  <property name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/>\n</bean>\n```\n\nsystemProperties bean을 미리 지정하여 사용할 수 있다. (bean을 사용하였지만 `@` 문자를 안붙인 것을 주의)\n```xml\n<bean id=\"taxCalculator\" class=\"org.spring.samples.TaxCalculator\">\n  <property name=\"defaultLocale\" value=\"#{ systemProperties['user.region'] }\"/>\n</bean>\n```\n\n아래 예제 처럼 다른 bean의 Properties를 사용할 수 있다.\n```xml\n<bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\">\n  <property name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/>\n</bean>\n\n<bean id=\"shapeGuess\" class=\"org.spring.samples.ShapeGuess\">\n  <property name=\"initialShapeSeed\" value=\"#{ numberGuess.randomNumber }\"/>\n</bean>\n```\n\n## Annotation Based\n* 기본값을 지정하기 위해 @Value Annotation을 이용해 Field, Method, Method-Parameter에 붙일 수 있다.\n\n```java\npublic static class FieldValueTestBean\n\n  @Value(\"#{ systemProperties['user.region'] }\")\n  private String defaultLocale;\n\n  public void setDefaultLocale(String defaultLocale)\n  {\n    this.defaultLocale = defaultLocale;\n  }\n\n  public String getDefaultLocale() \n  {\n    return this.defaultLocale;\n  }\n}\n```\n\n```java\npublic static class PropertyValueTestBean\n\n  private String defaultLocale;\n\n  @Value(\"#{ systemProperties['user.region'] }\")\n  public void setDefaultLocale(String defaultLocale)\n  {\n    this.defaultLocale = defaultLocale;\n  }\n}\n```\n\n```java\n  private MovieFinder movieFinder;\n  private String defaultLocale;\n\n  @Autowired\n  public void configure(MovieFinder movieFinder, \n                   @Value(\"#{ systemProperties['user.region'] }\"} String defaultLocale) {\n    this.movieFinder = movieFinder;\n    this.defaultLocale = defaultLocale;\n  }\n```\n\n\n\n\n# 참고\n\n* https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html\n* https://blog.outsider.ne.kr/835\n* https://blog.outsider.ne.kr/837","slug":"2018-11-21-spel-expression","published":1,"updated":"2018-11-27T07:23:32.382Z","comments":1,"photos":[],"link":"","_id":"cjrgbv3rm0036cr1tfzkgl2dn","content":"<h1 id=\"들어가며\">들어가며</h1>\n<p>Spring Cache Abstraction 기능을 사용하게 되면서, key modeling 시, 필요한 SpEL에 대해 알아보게 되었다.\n기본적인 설명과 예제는 Spring Docs를 기반으로 번역</p>\n<h1 id=\"spel-ltugtspltugtring-ltugteltugtxpression-ltugtlltugtanguage이란\">SpEL (&lt;u&gt;Sp&lt;/u&gt;ring &lt;u&gt;E&lt;/u&gt;xpression &lt;u&gt;L&lt;/u&gt;anguage)이란?</h1>\n<p>Spring Expression Language (줄여서 SpEL)은 런타임에 쿼리를 지원하고 객체를 조작할 수 있는 강력한 표현식 언어이다. 언어 구문은 Unified EL과 유사하지만, 여러가지 추가 기능을 제공한다.</p>\n<p>다른 Java에서 사용가능한 표현식 언어가 있지만, SpEL은 Spring 커뮤니티에 표현식 언어를 제공하기 위해 만들어졌다.\nSpring 포트폴리오 내에서 표현식 평가 (Expression evaluation)의 기반으로 SpEL을 제공하지만, SpEL은 Spring과 직접 연계되지 않고 독립적으로 사용 할 수 있다.\n독립적으로 사용하기 위해서는 Parser 같은 Bootstraping 기반 클래스에 대한 설정을 몇가지 할 필요가 있다.\n하지만 웬만한 개발자들은 이런 기반 클래스에 대한 설정 없이 SpEL 표현식만 잘 작성하면 된다.</p>\n<h1 id=\"spel에서-지원하는-기능\">SpEL에서 지원하는 기능</h1>\n<ul>\n<li>리터럴 표현식 (Literal Expression)</li>\n<li>Boolean과 관계형 Operator (Boolean and Relational Operator)</li>\n<li>정규 표현식 (Regular Expression)</li>\n<li>클래스 표현식 (Class Expression)</li>\n<li>프로퍼티, 배열, 리스트, 맵에 대한 접근 지원 (Accessing properties, arrays, lists, maps)</li>\n<li>메서드 호출 (Method Invocation)</li>\n<li>관계형 Operator (Relational Operator)</li>\n<li>할당 (Assignment)</li>\n<li>생성자 호출 (Calling Constructors)</li>\n<li>Bean 참조 (Bean References)</li>\n<li>배열 생성 (Array Contruction)</li>\n<li>인라인 리스트/맵 (Inline List/Map)</li>\n<li>삼항 연산자 (Ternary Operator)</li>\n<li>변수 (Variables)</li>\n<li>사용자 정의 함수 (User defined functions)</li>\n<li>컬렉션 투영 (Collections Projection)</li>\n<li>컬렉션 선택 (Collections Selection)</li>\n<li>Template 표현식 (Templated expression)</li>\n</ul>\n<h1 id=\"expression-인터페이스를-이용한-표현식-파싱\">Expression 인터페이스를 이용한 표현식 파싱</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressionTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String message = parseExpression(<span class=\"string\">\"\\\"Hello World\\\"\"</span>, String.class);</span><br><span class=\"line\">        System.out.println(message); <span class=\"comment\">//\"Hello World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String message2 = parseExpression(<span class=\"string\">\"\\\"Hello World\\\".concat('!')\"</span>, String.class);</span><br><span class=\"line\">        System.out.println(message2); <span class=\"comment\">//\"Hello World!\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">parseExpression</span><span class=\"params\">(String expression, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">        ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">        Expression exp = parser.parseExpression(expression);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> exp.getValue(clazz);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>위의 코드는 SpEL표현식 문자열에 대한 파싱(Parsing) 하는 프로그램의 예제 코드이다.</li>\n<li>ExpressionParser Interface를 구현하는 SpelExpressionParser로 SpEL 표현식의 내용을 파싱(Parsing) 할 수 있다.</li>\n<li>exp.getValue() 메서드를 이용해 파싱된 결과값을 Object 타입으로 얻거나, Class정보를 파라미터로 추가해 자동으로 타입 캐스팅이 가능하다.</li>\n</ul>\n<h1 id=\"evaluationcontext-인터페이스를-이용한-표현식-파싱\">EvaluationContext 인터페이스를 이용한 표현식 파싱</h1>\n<ul>\n<li>Property, Method, Field에 대한 파싱을 처리</li>\n<li>타입변환을 수행하는 표현식을 평가 할 때 EvaluationContext 인터페이스를 사용</li>\n<li>EvaluationContext의 구현체인 StandardEvaluationContext는 객체를 조작하기 위해 java reflection의 기능을 사용</li>\n<li>성능을 향상 시키기 위해 java.lang.reflect의 Method, Field, Constructor를 캐싱한다.</li>\n</ul>\n<p>SpEL의 더 일반적인 사용법은 특정 객체 인스턴스(root객체)에 대해 평가되는 표현식 문자열을 제공하는 것이다.\nroot객체를 제공하는 방식은 2가지 방식이 있다.</p>\n<h2 id=\"root-객체를-똑같이-제공하는-경우\">root 객체를 똑같이 제공하는 경우</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create and set a calendar</span></span><br><span class=\"line\">GregorianCalendar c = <span class=\"keyword\">new</span> GregorianCalendar();</span><br><span class=\"line\">c.set(<span class=\"number\">1856</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// name, birthday, nationality를 파라미터로 갖는 생성자이다.</span></span><br><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, c.getTime(), <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">Expression exp = parser.parseExpression(<span class=\"string\">\"name\"</span>); <span class=\"comment\">//tesla객체의 name 프로퍼티가 파싱</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Context에 tesla객체를 넣어준다.</span></span><br><span class=\"line\">EvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\">String name = (String) exp.getValue(context); <span class=\"comment\">//name = \"Nikola Tesla\"</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>StandardEvaluationContext는 <code>name</code> 프로퍼티가 평가 될 객체를 지정하는 클래스이다.\n(위의 예제는 root객체, 즉 tesla 객체를 고정하여 사용하는 예제)</li>\n<li>위의 SpelExpressionParser가 표현식을 평가 할 때, 표현식의 대한 기준을 Tesla 객체로 지정하는 부분이다.</li>\n<li><code>parser.parseExpression(&quot;name&quot;);</code> 가 실행되면, tesla 객체의 name 프로퍼티가 파싱된다.</li>\n<li>name변수에는 <code>Nikola Tesla</code> 문자열이 리턴된다.</li>\n<li>타입 캐스팅 실패 시에는, <code>EvaluationException</code>이 throw된다.</li>\n</ul>\n<h2 id=\"root-객체가-계속-변경되는-경우\">root 객체가 계속 변경되는 경우</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create and set a calendar</span></span><br><span class=\"line\">GregorianCalendar c = <span class=\"keyword\">new</span> GregorianCalendar();</span><br><span class=\"line\">c.set(<span class=\"number\">1856</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// name, birthday, nationality를 파라미터로 갖는 생성자이다.</span></span><br><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, c.getTime(), <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">Expression exp = parser.parseExpression(<span class=\"string\">\"name\"</span>); <span class=\"comment\">//tesla객체의 name 프로퍼티가 파싱</span></span><br><span class=\"line\"></span><br><span class=\"line\">String name = (String) exp.getValue(tesla);</span><br></pre></td></tr></table></figure></p>\n<p>getValue 메서드 호출 시에, StandardEvaluationContext를 사용하지 않고 root 객체를 직접 지정해 준다.</p>\n<h2 id=\"두-가지-방식의-차이\">두 가지 방식의 차이</h2>\n<ul>\n<li>StandardEvaluationContext를 사용하는 경우 생성 비용이 상대적으로 많이 든다.</li>\n<li>반복적으로 사용하는 동안 <code>Field에 대해 캐싱되고 있기 때문에 표현식 파싱이 더 빠르다</code>는 장점이 있다.</li>\n<li>설정 파일에서 SpEL을 사용하는 경우에는, root 객체를 고정하고 SpEL 표현식만 개발자에게 설정 하도록 하는 것이 좋다.</li>\n</ul>\n<h1 id=\"bean을-정의하는-표현식\">Bean을 정의하는 표현식</h1>\n<ul>\n<li>BeanDefinition을 정의하는 XML이나, Annotation 기반의 설정에는 MetaData와 SpEL표현식을 같이 사용할 수 있다.</li>\n<li><code>#{&lt;expression&gt;}</code> 문법으로 사용한다.</li>\n</ul>\n<h2 id=\"xml-based\">XML Based</h2>\n<ul>\n<li>프로퍼티나 생성자 Argument 값을 표현식으로 나타낼 수 있다.\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"numberGuess\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.NumberGuess\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"randomNumber\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>systemProperties bean을 미리 지정하여 사용할 수 있다. (bean을 사용하였지만 <code>@</code> 문자를 안붙인 것을 주의)\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"taxCalculator\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.TaxCalculator\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"defaultLocale\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; systemProperties['user.region'] &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>아래 예제 처럼 다른 bean의 Properties를 사용할 수 있다.\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"numberGuess\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.NumberGuess\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"randomNumber\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"shapeGuess\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.ShapeGuess\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"initialShapeSeed\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; numberGuess.randomNumber &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"annotation-based\">Annotation Based</h2>\n<ul>\n<li>기본값을 지정하기 위해 @Value Annotation을 이용해 Field, Method, Method-Parameter에 붙일 수 있다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FieldValueTestBean</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\">  @Value(\"#&#123; systemProperties['user.region'] &#125;\")</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String defaultLocale;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDefaultLocale</span><span class=\"params\">(String defaultLocale)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.defaultLocale = defaultLocale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDefaultLocale</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.defaultLocale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PropertyValueTestBean</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">private</span> <span class=\"title\">String</span> <span class=\"title\">defaultLocale</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Value</span>(<span class=\"string\">\"#&#123; systemProperties['user.region'] &#125;\"</span>)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDefaultLocale</span><span class=\"params\">(String defaultLocale)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.defaultLocale = defaultLocale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> MovieFinder movieFinder;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String defaultLocale;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(MovieFinder movieFinder, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 @Value(<span class=\"string\">\"#&#123; systemProperties['user.region'] &#125;\"</span>&#125; String defaultLocale)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.movieFinder = movieFinder;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.defaultLocale = defaultLocale;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html</li>\n<li>https://blog.outsider.ne.kr/835</li>\n<li>https://blog.outsider.ne.kr/837</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>Spring Cache Abstraction 기능을 사용하게 되면서, key modeling 시, 필요한 SpEL에 대해 알아보게 되었다.\n기본적인 설명과 예제는 Spring Docs를 기반으로 번역</p>\n<h1>SpEL (&lt;u&gt;Sp&lt;/u&gt;ring &lt;u&gt;E&lt;/u&gt;xpression &lt;u&gt;L&lt;/u&gt;anguage)이란?</h1>\n<p>Spring Expression Language (줄여서 SpEL)은 런타임에 쿼리를 지원하고 객체를 조작할 수 있는 강력한 표현식 언어이다. 언어 구문은 Unified EL과 유사하지만, 여러가지 추가 기능을 제공한다.</p>\n<p>다른 Java에서 사용가능한 표현식 언어가 있지만, SpEL은 Spring 커뮤니티에 표현식 언어를 제공하기 위해 만들어졌다.\nSpring 포트폴리오 내에서 표현식 평가 (Expression evaluation)의 기반으로 SpEL을 제공하지만, SpEL은 Spring과 직접 연계되지 않고 독립적으로 사용 할 수 있다.\n독립적으로 사용하기 위해서는 Parser 같은 Bootstraping 기반 클래스에 대한 설정을 몇가지 할 필요가 있다.\n하지만 웬만한 개발자들은 이런 기반 클래스에 대한 설정 없이 SpEL 표현식만 잘 작성하면 된다.</p>\n<h1>SpEL에서 지원하는 기능</h1>\n<ul>\n<li>리터럴 표현식 (Literal Expression)</li>\n<li>Boolean과 관계형 Operator (Boolean and Relational Operator)</li>\n<li>정규 표현식 (Regular Expression)</li>\n<li>클래스 표현식 (Class Expression)</li>\n<li>프로퍼티, 배열, 리스트, 맵에 대한 접근 지원 (Accessing properties, arrays, lists, maps)</li>\n<li>메서드 호출 (Method Invocation)</li>\n<li>관계형 Operator (Relational Operator)</li>\n<li>할당 (Assignment)</li>\n<li>생성자 호출 (Calling Constructors)</li>\n<li>Bean 참조 (Bean References)</li>\n<li>배열 생성 (Array Contruction)</li>\n<li>인라인 리스트/맵 (Inline List/Map)</li>\n<li>삼항 연산자 (Ternary Operator)</li>\n<li>변수 (Variables)</li>\n<li>사용자 정의 함수 (User defined functions)</li>\n<li>컬렉션 투영 (Collections Projection)</li>\n<li>컬렉션 선택 (Collections Selection)</li>\n<li>Template 표현식 (Templated expression)</li>\n</ul>\n<h1>Expression 인터페이스를 이용한 표현식 파싱</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressionTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String message = parseExpression(<span class=\"string\">\"\\\"Hello World\\\"\"</span>, String.class);</span><br><span class=\"line\">        System.out.println(message); <span class=\"comment\">//\"Hello World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String message2 = parseExpression(<span class=\"string\">\"\\\"Hello World\\\".concat('!')\"</span>, String.class);</span><br><span class=\"line\">        System.out.println(message2); <span class=\"comment\">//\"Hello World!\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">parseExpression</span><span class=\"params\">(String expression, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">        ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">        Expression exp = parser.parseExpression(expression);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> exp.getValue(clazz);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>위의 코드는 SpEL표현식 문자열에 대한 파싱(Parsing) 하는 프로그램의 예제 코드이다.</li>\n<li>ExpressionParser Interface를 구현하는 SpelExpressionParser로 SpEL 표현식의 내용을 파싱(Parsing) 할 수 있다.</li>\n<li>exp.getValue() 메서드를 이용해 파싱된 결과값을 Object 타입으로 얻거나, Class정보를 파라미터로 추가해 자동으로 타입 캐스팅이 가능하다.</li>\n</ul>\n<h1>EvaluationContext 인터페이스를 이용한 표현식 파싱</h1>\n<ul>\n<li>Property, Method, Field에 대한 파싱을 처리</li>\n<li>타입변환을 수행하는 표현식을 평가 할 때 EvaluationContext 인터페이스를 사용</li>\n<li>EvaluationContext의 구현체인 StandardEvaluationContext는 객체를 조작하기 위해 java reflection의 기능을 사용</li>\n<li>성능을 향상 시키기 위해 java.lang.reflect의 Method, Field, Constructor를 캐싱한다.</li>\n</ul>\n<p>SpEL의 더 일반적인 사용법은 특정 객체 인스턴스(root객체)에 대해 평가되는 표현식 문자열을 제공하는 것이다.\nroot객체를 제공하는 방식은 2가지 방식이 있다.</p>\n<h2>root 객체를 똑같이 제공하는 경우</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create and set a calendar</span></span><br><span class=\"line\">GregorianCalendar c = <span class=\"keyword\">new</span> GregorianCalendar();</span><br><span class=\"line\">c.set(<span class=\"number\">1856</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// name, birthday, nationality를 파라미터로 갖는 생성자이다.</span></span><br><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, c.getTime(), <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">Expression exp = parser.parseExpression(<span class=\"string\">\"name\"</span>); <span class=\"comment\">//tesla객체의 name 프로퍼티가 파싱</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Context에 tesla객체를 넣어준다.</span></span><br><span class=\"line\">EvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\">String name = (String) exp.getValue(context); <span class=\"comment\">//name = \"Nikola Tesla\"</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>StandardEvaluationContext는 <code>name</code> 프로퍼티가 평가 될 객체를 지정하는 클래스이다.\n(위의 예제는 root객체, 즉 tesla 객체를 고정하여 사용하는 예제)</li>\n<li>위의 SpelExpressionParser가 표현식을 평가 할 때, 표현식의 대한 기준을 Tesla 객체로 지정하는 부분이다.</li>\n<li><code>parser.parseExpression(&quot;name&quot;);</code> 가 실행되면, tesla 객체의 name 프로퍼티가 파싱된다.</li>\n<li>name변수에는 <code>Nikola Tesla</code> 문자열이 리턴된다.</li>\n<li>타입 캐스팅 실패 시에는, <code>EvaluationException</code>이 throw된다.</li>\n</ul>\n<h2>root 객체가 계속 변경되는 경우</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create and set a calendar</span></span><br><span class=\"line\">GregorianCalendar c = <span class=\"keyword\">new</span> GregorianCalendar();</span><br><span class=\"line\">c.set(<span class=\"number\">1856</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// name, birthday, nationality를 파라미터로 갖는 생성자이다.</span></span><br><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, c.getTime(), <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">Expression exp = parser.parseExpression(<span class=\"string\">\"name\"</span>); <span class=\"comment\">//tesla객체의 name 프로퍼티가 파싱</span></span><br><span class=\"line\"></span><br><span class=\"line\">String name = (String) exp.getValue(tesla);</span><br></pre></td></tr></table></figure></p>\n<p>getValue 메서드 호출 시에, StandardEvaluationContext를 사용하지 않고 root 객체를 직접 지정해 준다.</p>\n<h2>두 가지 방식의 차이</h2>\n<ul>\n<li>StandardEvaluationContext를 사용하는 경우 생성 비용이 상대적으로 많이 든다.</li>\n<li>반복적으로 사용하는 동안 <code>Field에 대해 캐싱되고 있기 때문에 표현식 파싱이 더 빠르다</code>는 장점이 있다.</li>\n<li>설정 파일에서 SpEL을 사용하는 경우에는, root 객체를 고정하고 SpEL 표현식만 개발자에게 설정 하도록 하는 것이 좋다.</li>\n</ul>\n<h1>Bean을 정의하는 표현식</h1>\n<ul>\n<li>BeanDefinition을 정의하는 XML이나, Annotation 기반의 설정에는 MetaData와 SpEL표현식을 같이 사용할 수 있다.</li>\n<li><code>#{&lt;expression&gt;}</code> 문법으로 사용한다.</li>\n</ul>\n<h2>XML Based</h2>\n<ul>\n<li>프로퍼티나 생성자 Argument 값을 표현식으로 나타낼 수 있다.\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"numberGuess\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.NumberGuess\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"randomNumber\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>systemProperties bean을 미리 지정하여 사용할 수 있다. (bean을 사용하였지만 <code>@</code> 문자를 안붙인 것을 주의)\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"taxCalculator\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.TaxCalculator\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"defaultLocale\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; systemProperties['user.region'] &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>아래 예제 처럼 다른 bean의 Properties를 사용할 수 있다.\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"numberGuess\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.NumberGuess\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"randomNumber\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"shapeGuess\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.ShapeGuess\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"initialShapeSeed\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; numberGuess.randomNumber &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2>Annotation Based</h2>\n<ul>\n<li>기본값을 지정하기 위해 @Value Annotation을 이용해 Field, Method, Method-Parameter에 붙일 수 있다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FieldValueTestBean</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\">  @Value(\"#&#123; systemProperties['user.region'] &#125;\")</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String defaultLocale;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDefaultLocale</span><span class=\"params\">(String defaultLocale)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.defaultLocale = defaultLocale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDefaultLocale</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.defaultLocale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PropertyValueTestBean</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">private</span> <span class=\"title\">String</span> <span class=\"title\">defaultLocale</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Value</span>(<span class=\"string\">\"#&#123; systemProperties['user.region'] &#125;\"</span>)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDefaultLocale</span><span class=\"params\">(String defaultLocale)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.defaultLocale = defaultLocale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> MovieFinder movieFinder;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String defaultLocale;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(MovieFinder movieFinder, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 @Value(<span class=\"string\">\"#&#123; systemProperties['user.region'] &#125;\"</span>&#125; String defaultLocale)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.movieFinder = movieFinder;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.defaultLocale = defaultLocale;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>참고</h1>\n<ul>\n<li>https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html</li>\n<li>https://blog.outsider.ne.kr/835</li>\n<li>https://blog.outsider.ne.kr/837</li>\n</ul>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (2) Docker 설치 및 사용방법","date":"2018-11-28T14:50:01.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-11-28-docker-2","typora-copy-images-to":"2018-11-28-docker-2","_content":"\n# 들어가며\n\n지난 장에서는 Docker에 대한 개념, Image와 컨테이너, VM과의 차이점등을 그림으로 설명하였습니다.\n이번 장부터는 Docker를 linux서버에 설치하는 과정을 설명하고자 합니다.\n(Linux서버 설치는 hyper-v를 이용하여 vm으로 설치 하였습니다. <차후에 hyper-v 설정기를 올릴 예정입니다.>)\nWindows, Mac에도 설치 할 수 있지만, Linux에 설치하는게 거의 표준이다 싶히 사용되고 있으며, Windows, Mac에 설치를 하더라도 어차피 가상화 환경에서 Docker가 설치 되기 때문에... linux를 설치하여 Docker를 설치하였습니다.\n(지울 때 편하게 지우고 싶어서 그런건 안비밀)\n\n\n\n# CentOS 7 환경에서 Docker 설치하기\n\nDocker를 설치하는 방법은 다양한 방법이 있겠지만.. 가장 간단한 방법으로 설치해 보도록 하겠습니다.\n\n설치 환경은 아래와 같습니다.\n\n* OS: CentOS 7 (VM 환경(Hyper-v)에서 테스트)\n* user: docker-user (일부러 root가 아닌 사용자를 생성하였습니다... 이유는 아래에)\n* SW: Redis 5\n\n>Docker 다운로드 yum을 이용해서 Docker를 받는 방법도 있지만, `최신버전이 아닙니다. `\n>차후 Docker-compose를 사용하기 위해서는 Docker버전이 1.13 이상이 되야 합니다. \n>따라서 한번에 패키지로 설치해 주는 url로 설치하도록 합니다. \n\n```sh\nsudo curl -fsSL https://get.docker.com/ | sudo sh\nsudo sh sudo service docker start #Docker Daemon Start\n```\n\n\n\n# Docker의 Permission\n\nDocker를 설치하고 확인하기 위해 Docker 명령을 입력하였습니다.\n\n```sh\ndocker version\n```\n\n![docker permission](./docker-permission.png)\n\ndocker명령을 입력했을 시, permission denied 에러가 발생한 것을 볼 수 있습니다.\ndocker는 명령을 실행 할 때 기본적으로 root계정을 필요로 합니다. (docker의 특성상 시스템의 내부적인 부분에 접근하는 게 많다보니... 그렇다고 합니다.)\n그렇기 때문에 sudo명령을 사용하여 docker 명령을 실행 할 수 있습니다.\n\n`하지만 sudo가 너무 귀찮다! 하시는 분들은...` 아래 명령을 실행하여 계정을 `docker 그룹`에 포함 시켜주시면 됩니다.\n\n```sh\nsudo usermod -aG docker $USER\nsudo service docker restart\n \nexit #로그아웃\ndocker-user <password> #다시 로그인\n```\n\n```sh\ndocker version\n```\n![sudo docker](./sudo-docker.png)\n\n이제 sudo 명령 없이도 docker 명령어 실행이 잘 됩니다!\n\n\n\n# 간단한 Docker Container(깡통)를 만들어 봅시다!\n\nDocker Hub([https://hub.docker.com](https://hub.docker.com/)) 사이트에 들어가면 우리가 필요로하는 많은 프로그램들이 이미지로 올라가 있습니다.\n이번 예제에서는 Redis를 가지고 Docker Container를 만들어보도록 하겠습니다.\n\n![docker-hub](./docker-hub.png)\n\ndocker hub 사이트에서 redis를 검색해 보았습니다.\n여러가지 redis 이미지가 보이는데 official이라고 되어있는 것이 공식이미지 입니다.\nbitnami/redis라고 되어있는 것은 docker hub의 사용자들이 올린 이미지입니다.\n\n\n\n![redis-versions](./redis-versions.png)\n\nofficial 이미지의 상세 버전을 보니 4.x~5.0.1까지 있습니다.\n이번 예제에서는 그나마 stable한 버전인 인 5.0-alpine 버전을 사용해 보도록 하겠습니다.\n\n\n\n# Docker 이미지 다운로드 (Docker hub -> Docker Client)\n\npull 명령을 통해 docker hub에 있는 이미지를 다운로드 합니다.\n\n```sh\ndocker pull redis:<tag> # ex) redis:5.0-alpine, redis:4-alpine, redis:latest(가장 마지막 배포 버전입니다.)\ndocker pull redis #tag version을 적지 않은 경우 자동으로 lastest 버전을 다운로드 합니다.\n```\n\n\n\n# Docker 이미지 확인 / 삭제\n\n## Docker 이미지 확인\n\nimages 명령을 이용하여 docker image리스트를 확인합니다.\n\n```sh\ndocker images\n```\n\n* 자주 사용하는 options\n  * -a --all : 숨겨진 임시 이미지를 보여줍니다.\n  * -f --filter : filter를 이용하여 이미지 조회 조건을 변경하여 조회 할 수 있습니다.\n  * -q --quite : image의 image ID만 출력합니다.\n\n\n>docker의 이미지는 1개의 파일이 아닌, 여러 이미지의 레이어(Layer)로 구성되어 있습니다.\n따라서 Redis이미지를 다운받더라고 Redis 이미지 하나가 아닌 여러 이미지의 레이어로 구성되어 있습니다.\n![image layer](./image-layer.png)\n따라서 하나의 이미지라도 여러 이미지가 투영되어 보이는 결과물이라 볼 수 있습니다.\n\n\n\n## Docker 이미지 삭제\n\nrmi 명령을 이용하여 docker의 image를 삭제 할 수 있습니다.\n\n```sh\n# ex) docker rmi redis:5.0-alpine, docker rmi <imageID>\ndocker rmi {이미지명/이미지ID} \n```\n\n* 자주 사용하는 Options\n  - -f --force : 이미지를 강제로 삭제합니다. (해당 이미지로 만들어진 Docker Container가 존재하는 경우 이미지를 삭제 할 수 없는데, 그 때 강제로 삭제 하기위해 사용)\n\n\n\n# Docker Container 생성 / 삭제\n\n## Docker Container 생성\n\nrun 명령으로 Container를 생성합니다.\n\n```sh\n# ex) docker run -it -d redis:5.0-alpine,\n#     docker run -it -d 4760dc956b2d\ndocker run {options} <image명/image ID> \n```\n\n- 자주 사용하는 Options\n\n  - -d --detach : Container 생성 후 Background로 실행 (이 옵션 없을 시, Redis 같은 경우에는 Console에 Redis log가 지속적으로 표시됩니다.)\n  - -h --hostname : Container 명 지정\n  - -i --interactive : 소통형 모드로 실행 (주로 ubuntu와 같은 Container 실행 시 사용)\n  - -p --publish : 해당 Container의 외부 Port 지정 (10000:6379) (외부:내부) 형식으로 지정\n  - -P --publish-all : 여러개의 Port 노출 (1000-1100)\n  - --rm : Container 종료 시, Container 삭제 `(자주 사용되는 옵션입니다)`\n  - -v --volume : 외부 볼륨 연동 /home/user/data:/data (외부 OS 디렉토리:컨테이너 내부 디렉토리) - 상호 데이터가 공유됨\n\n\n\n## Docker Container 목록 조회\n\nps 명령으로 Container 목록을 조회합니다.\n\n```sh\ndocker ps {options}\n```\n*  자주 사용하는 Options\n  * -a : 비활성 상태의 Container까지 조회\n  * -q : Container ID만 조회\n  * -f --filter : Container 조회 시, Filter를 이용하여 조회\n\n\n\n## Docker Container 내부 접속\n\nattach 명령을 이용하여 접속\n```sh\ndocker attach [container명/container ID]\n```\n>attach 명령은 /bin/bash로 실행 되기 때문에, Container에 /bin/bash가 없는 경우에는 접속이 불가능 합니다. \n\n\n\nexec 명령을 이용하여 Container 내부 명령 수행\n```sh\n# ex) docker exec -it redis:5.0-alpine /bin/sh\n# Redis의 경우 Container에 bin/bash가 없어 bin/sh로 실행하면 내부접속이 가능합니다\ndocker exec {options} [container명/container ID] [명령어]  \n```\n\n* 자주 사용하는 options\n  * -d --detach : 명령수행을 Background 모드로 수행\n  * -e --env : 환경변수 (Environment) 설정\n  * -i --interaction : 대화형 모드로 설정\n\n\n\n# Docker Container 삭제\n\nrm 명령으로 Container를 삭제 합니다.\n\n```sh\n# ex) docker rm -f redis:5.0-alpine\ndocker rm {options} [container명/container ID] \n```\n\n- 자주 사용하는 options\n  - -f --force : 활성(active) 상태의 Container 강제삭제\n  - -l --link : Container간 link가 관계인 Container 삭제\n  - -v --volumes : Container 관련 볼륨(외부 디렉토리) 삭제\n\n\n\n# 자주 사용한 명령어 모음\n\n```sh\n#Container 전체 삭제 (-a -q 옵션으로 전체 Container의 ID만 뽑아온다.)\ndocker rm -f $(docker ps -a -q)\n\n#Image 전체 삭제 (-q 옵션으로 images에 대한 Image ID만 뽑아온다.)\ndocker rmi $(docker images -q)\n\n#특정 Container 삭제 (grep 명령으로 Container ID만 뽑아온다.)\ndocker rm -f $(docker ps -a | grep \"redis:5.0-alpine\"| awk '{print $1}')\n\n#특정 이미지 삭제 (grep + awk 명령어로 image ID만 뽑아온다.)\ndocker rmi $(docker images | grep \"^redis\"| awk '{print $3}')  \n\n#Docker 삭제\ncd ~\nyum remove -y docker*\n```\n\n\n\n# 참고\n\n* http://www.sauru.so/blog/docker-installation-and-test-drive/\n* https://hub.docker.com/_/redis/\n* http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03\n* https://docs.docker.com/engine/reference/run/","source":"_posts/2018-11-28-docker-2.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (2) Docker 설치 및 사용방법\ndate: 2018-11-28 23:50:01\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-11-28-docker-2\ntypora-copy-images-to: 2018-11-28-docker-2\n---\n\n# 들어가며\n\n지난 장에서는 Docker에 대한 개념, Image와 컨테이너, VM과의 차이점등을 그림으로 설명하였습니다.\n이번 장부터는 Docker를 linux서버에 설치하는 과정을 설명하고자 합니다.\n(Linux서버 설치는 hyper-v를 이용하여 vm으로 설치 하였습니다. <차후에 hyper-v 설정기를 올릴 예정입니다.>)\nWindows, Mac에도 설치 할 수 있지만, Linux에 설치하는게 거의 표준이다 싶히 사용되고 있으며, Windows, Mac에 설치를 하더라도 어차피 가상화 환경에서 Docker가 설치 되기 때문에... linux를 설치하여 Docker를 설치하였습니다.\n(지울 때 편하게 지우고 싶어서 그런건 안비밀)\n\n\n\n# CentOS 7 환경에서 Docker 설치하기\n\nDocker를 설치하는 방법은 다양한 방법이 있겠지만.. 가장 간단한 방법으로 설치해 보도록 하겠습니다.\n\n설치 환경은 아래와 같습니다.\n\n* OS: CentOS 7 (VM 환경(Hyper-v)에서 테스트)\n* user: docker-user (일부러 root가 아닌 사용자를 생성하였습니다... 이유는 아래에)\n* SW: Redis 5\n\n>Docker 다운로드 yum을 이용해서 Docker를 받는 방법도 있지만, `최신버전이 아닙니다. `\n>차후 Docker-compose를 사용하기 위해서는 Docker버전이 1.13 이상이 되야 합니다. \n>따라서 한번에 패키지로 설치해 주는 url로 설치하도록 합니다. \n\n```sh\nsudo curl -fsSL https://get.docker.com/ | sudo sh\nsudo sh sudo service docker start #Docker Daemon Start\n```\n\n\n\n# Docker의 Permission\n\nDocker를 설치하고 확인하기 위해 Docker 명령을 입력하였습니다.\n\n```sh\ndocker version\n```\n\n![docker permission](./docker-permission.png)\n\ndocker명령을 입력했을 시, permission denied 에러가 발생한 것을 볼 수 있습니다.\ndocker는 명령을 실행 할 때 기본적으로 root계정을 필요로 합니다. (docker의 특성상 시스템의 내부적인 부분에 접근하는 게 많다보니... 그렇다고 합니다.)\n그렇기 때문에 sudo명령을 사용하여 docker 명령을 실행 할 수 있습니다.\n\n`하지만 sudo가 너무 귀찮다! 하시는 분들은...` 아래 명령을 실행하여 계정을 `docker 그룹`에 포함 시켜주시면 됩니다.\n\n```sh\nsudo usermod -aG docker $USER\nsudo service docker restart\n \nexit #로그아웃\ndocker-user <password> #다시 로그인\n```\n\n```sh\ndocker version\n```\n![sudo docker](./sudo-docker.png)\n\n이제 sudo 명령 없이도 docker 명령어 실행이 잘 됩니다!\n\n\n\n# 간단한 Docker Container(깡통)를 만들어 봅시다!\n\nDocker Hub([https://hub.docker.com](https://hub.docker.com/)) 사이트에 들어가면 우리가 필요로하는 많은 프로그램들이 이미지로 올라가 있습니다.\n이번 예제에서는 Redis를 가지고 Docker Container를 만들어보도록 하겠습니다.\n\n![docker-hub](./docker-hub.png)\n\ndocker hub 사이트에서 redis를 검색해 보았습니다.\n여러가지 redis 이미지가 보이는데 official이라고 되어있는 것이 공식이미지 입니다.\nbitnami/redis라고 되어있는 것은 docker hub의 사용자들이 올린 이미지입니다.\n\n\n\n![redis-versions](./redis-versions.png)\n\nofficial 이미지의 상세 버전을 보니 4.x~5.0.1까지 있습니다.\n이번 예제에서는 그나마 stable한 버전인 인 5.0-alpine 버전을 사용해 보도록 하겠습니다.\n\n\n\n# Docker 이미지 다운로드 (Docker hub -> Docker Client)\n\npull 명령을 통해 docker hub에 있는 이미지를 다운로드 합니다.\n\n```sh\ndocker pull redis:<tag> # ex) redis:5.0-alpine, redis:4-alpine, redis:latest(가장 마지막 배포 버전입니다.)\ndocker pull redis #tag version을 적지 않은 경우 자동으로 lastest 버전을 다운로드 합니다.\n```\n\n\n\n# Docker 이미지 확인 / 삭제\n\n## Docker 이미지 확인\n\nimages 명령을 이용하여 docker image리스트를 확인합니다.\n\n```sh\ndocker images\n```\n\n* 자주 사용하는 options\n  * -a --all : 숨겨진 임시 이미지를 보여줍니다.\n  * -f --filter : filter를 이용하여 이미지 조회 조건을 변경하여 조회 할 수 있습니다.\n  * -q --quite : image의 image ID만 출력합니다.\n\n\n>docker의 이미지는 1개의 파일이 아닌, 여러 이미지의 레이어(Layer)로 구성되어 있습니다.\n따라서 Redis이미지를 다운받더라고 Redis 이미지 하나가 아닌 여러 이미지의 레이어로 구성되어 있습니다.\n![image layer](./image-layer.png)\n따라서 하나의 이미지라도 여러 이미지가 투영되어 보이는 결과물이라 볼 수 있습니다.\n\n\n\n## Docker 이미지 삭제\n\nrmi 명령을 이용하여 docker의 image를 삭제 할 수 있습니다.\n\n```sh\n# ex) docker rmi redis:5.0-alpine, docker rmi <imageID>\ndocker rmi {이미지명/이미지ID} \n```\n\n* 자주 사용하는 Options\n  - -f --force : 이미지를 강제로 삭제합니다. (해당 이미지로 만들어진 Docker Container가 존재하는 경우 이미지를 삭제 할 수 없는데, 그 때 강제로 삭제 하기위해 사용)\n\n\n\n# Docker Container 생성 / 삭제\n\n## Docker Container 생성\n\nrun 명령으로 Container를 생성합니다.\n\n```sh\n# ex) docker run -it -d redis:5.0-alpine,\n#     docker run -it -d 4760dc956b2d\ndocker run {options} <image명/image ID> \n```\n\n- 자주 사용하는 Options\n\n  - -d --detach : Container 생성 후 Background로 실행 (이 옵션 없을 시, Redis 같은 경우에는 Console에 Redis log가 지속적으로 표시됩니다.)\n  - -h --hostname : Container 명 지정\n  - -i --interactive : 소통형 모드로 실행 (주로 ubuntu와 같은 Container 실행 시 사용)\n  - -p --publish : 해당 Container의 외부 Port 지정 (10000:6379) (외부:내부) 형식으로 지정\n  - -P --publish-all : 여러개의 Port 노출 (1000-1100)\n  - --rm : Container 종료 시, Container 삭제 `(자주 사용되는 옵션입니다)`\n  - -v --volume : 외부 볼륨 연동 /home/user/data:/data (외부 OS 디렉토리:컨테이너 내부 디렉토리) - 상호 데이터가 공유됨\n\n\n\n## Docker Container 목록 조회\n\nps 명령으로 Container 목록을 조회합니다.\n\n```sh\ndocker ps {options}\n```\n*  자주 사용하는 Options\n  * -a : 비활성 상태의 Container까지 조회\n  * -q : Container ID만 조회\n  * -f --filter : Container 조회 시, Filter를 이용하여 조회\n\n\n\n## Docker Container 내부 접속\n\nattach 명령을 이용하여 접속\n```sh\ndocker attach [container명/container ID]\n```\n>attach 명령은 /bin/bash로 실행 되기 때문에, Container에 /bin/bash가 없는 경우에는 접속이 불가능 합니다. \n\n\n\nexec 명령을 이용하여 Container 내부 명령 수행\n```sh\n# ex) docker exec -it redis:5.0-alpine /bin/sh\n# Redis의 경우 Container에 bin/bash가 없어 bin/sh로 실행하면 내부접속이 가능합니다\ndocker exec {options} [container명/container ID] [명령어]  \n```\n\n* 자주 사용하는 options\n  * -d --detach : 명령수행을 Background 모드로 수행\n  * -e --env : 환경변수 (Environment) 설정\n  * -i --interaction : 대화형 모드로 설정\n\n\n\n# Docker Container 삭제\n\nrm 명령으로 Container를 삭제 합니다.\n\n```sh\n# ex) docker rm -f redis:5.0-alpine\ndocker rm {options} [container명/container ID] \n```\n\n- 자주 사용하는 options\n  - -f --force : 활성(active) 상태의 Container 강제삭제\n  - -l --link : Container간 link가 관계인 Container 삭제\n  - -v --volumes : Container 관련 볼륨(외부 디렉토리) 삭제\n\n\n\n# 자주 사용한 명령어 모음\n\n```sh\n#Container 전체 삭제 (-a -q 옵션으로 전체 Container의 ID만 뽑아온다.)\ndocker rm -f $(docker ps -a -q)\n\n#Image 전체 삭제 (-q 옵션으로 images에 대한 Image ID만 뽑아온다.)\ndocker rmi $(docker images -q)\n\n#특정 Container 삭제 (grep 명령으로 Container ID만 뽑아온다.)\ndocker rm -f $(docker ps -a | grep \"redis:5.0-alpine\"| awk '{print $1}')\n\n#특정 이미지 삭제 (grep + awk 명령어로 image ID만 뽑아온다.)\ndocker rmi $(docker images | grep \"^redis\"| awk '{print $3}')  \n\n#Docker 삭제\ncd ~\nyum remove -y docker*\n```\n\n\n\n# 참고\n\n* http://www.sauru.so/blog/docker-installation-and-test-drive/\n* https://hub.docker.com/_/redis/\n* http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03\n* https://docs.docker.com/engine/reference/run/","slug":"2018-11-28-docker-2","published":1,"updated":"2018-12-08T08:36:29.329Z","comments":1,"photos":[],"link":"","_id":"cjrgbv3ro0038cr1t1on8m91w","content":"<h1 id=\"들어가며\">들어가며</h1>\n<p>지난 장에서는 Docker에 대한 개념, Image와 컨테이너, VM과의 차이점등을 그림으로 설명하였습니다.\n이번 장부터는 Docker를 linux서버에 설치하는 과정을 설명하고자 합니다.\n(Linux서버 설치는 hyper-v를 이용하여 vm으로 설치 하였습니다. &lt;차후에 hyper-v 설정기를 올릴 예정입니다.&gt;)\nWindows, Mac에도 설치 할 수 있지만, Linux에 설치하는게 거의 표준이다 싶히 사용되고 있으며, Windows, Mac에 설치를 하더라도 어차피 가상화 환경에서 Docker가 설치 되기 때문에... linux를 설치하여 Docker를 설치하였습니다.\n(지울 때 편하게 지우고 싶어서 그런건 안비밀)</p>\n<h1 id=\"centos-7-환경에서-docker-설치하기\">CentOS 7 환경에서 Docker 설치하기</h1>\n<p>Docker를 설치하는 방법은 다양한 방법이 있겠지만.. 가장 간단한 방법으로 설치해 보도록 하겠습니다.</p>\n<p>설치 환경은 아래와 같습니다.</p>\n<ul>\n<li>OS: CentOS 7 (VM 환경(Hyper-v)에서 테스트)</li>\n<li>user: docker-user (일부러 root가 아닌 사용자를 생성하였습니다... 이유는 아래에)</li>\n<li>SW: Redis 5</li>\n</ul>\n<blockquote>\n<p>Docker 다운로드 yum을 이용해서 Docker를 받는 방법도 있지만, <code>최신버전이 아닙니다.</code>\n차후 Docker-compose를 사용하기 위해서는 Docker버전이 1.13 이상이 되야 합니다.\n따라서 한번에 패키지로 설치해 주는 url로 설치하도록 합니다.</p>\n</blockquote>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo curl -fsSL https://get.docker.com/ | sudo sh</span><br><span class=\"line\">sudo sh sudo service docker start <span class=\"comment\">#Docker Daemon Start</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"docker의-permission\">Docker의 Permission</h1>\n<p>Docker를 설치하고 확인하기 위해 Docker 명령을 입력하였습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./docker-permission.png\" alt=\"docker permission\"></p>\n<p>docker명령을 입력했을 시, permission denied 에러가 발생한 것을 볼 수 있습니다.\ndocker는 명령을 실행 할 때 기본적으로 root계정을 필요로 합니다. (docker의 특성상 시스템의 내부적인 부분에 접근하는 게 많다보니... 그렇다고 합니다.)\n그렇기 때문에 sudo명령을 사용하여 docker 명령을 실행 할 수 있습니다.</p>\n<p><code>하지만 sudo가 너무 귀찮다! 하시는 분들은...</code> 아래 명령을 실행하여 계정을 <code>docker 그룹</code>에 포함 시켜주시면 됩니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG docker <span class=\"variable\">$USER</span></span><br><span class=\"line\">sudo service docker restart</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">exit</span> <span class=\"comment\">#로그아웃</span></span><br><span class=\"line\">docker-user &lt;password&gt; <span class=\"comment\">#다시 로그인</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./sudo-docker.png\" alt=\"sudo docker\"></p>\n<p>이제 sudo 명령 없이도 docker 명령어 실행이 잘 됩니다!</p>\n<h1 id=\"간단한-docker-container깡통를-만들어-봅시다\">간단한 Docker Container(깡통)를 만들어 봅시다!</h1>\n<p>Docker Hub(<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com</a>) 사이트에 들어가면 우리가 필요로하는 많은 프로그램들이 이미지로 올라가 있습니다.\n이번 예제에서는 Redis를 가지고 Docker Container를 만들어보도록 하겠습니다.</p>\n<p><img src=\"./docker-hub.png\" alt=\"docker-hub\"></p>\n<p>docker hub 사이트에서 redis를 검색해 보았습니다.\n여러가지 redis 이미지가 보이는데 official이라고 되어있는 것이 공식이미지 입니다.\nbitnami/redis라고 되어있는 것은 docker hub의 사용자들이 올린 이미지입니다.</p>\n<p><img src=\"./redis-versions.png\" alt=\"redis-versions\"></p>\n<p>official 이미지의 상세 버전을 보니 4.x~5.0.1까지 있습니다.\n이번 예제에서는 그나마 stable한 버전인 인 5.0-alpine 버전을 사용해 보도록 하겠습니다.</p>\n<h1 id=\"docker-이미지-다운로드-docker-hub-gt-docker-client\">Docker 이미지 다운로드 (Docker hub -&gt; Docker Client)</h1>\n<p>pull 명령을 통해 docker hub에 있는 이미지를 다운로드 합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull redis:&lt;tag&gt; <span class=\"comment\"># ex) redis:5.0-alpine, redis:4-alpine, redis:latest(가장 마지막 배포 버전입니다.)</span></span><br><span class=\"line\">docker pull redis <span class=\"comment\">#tag version을 적지 않은 경우 자동으로 lastest 버전을 다운로드 합니다.</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"docker-이미지-확인-삭제\">Docker 이미지 확인 / 삭제</h1>\n<h2 id=\"docker-이미지-확인\">Docker 이미지 확인</h2>\n<p>images 명령을 이용하여 docker image리스트를 확인합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>자주 사용하는 options\n<ul>\n<li>-a --all : 숨겨진 임시 이미지를 보여줍니다.</li>\n<li>-f --filter : filter를 이용하여 이미지 조회 조건을 변경하여 조회 할 수 있습니다.</li>\n<li>-q --quite : image의 image ID만 출력합니다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>docker의 이미지는 1개의 파일이 아닌, 여러 이미지의 레이어(Layer)로 구성되어 있습니다.\n따라서 Redis이미지를 다운받더라고 Redis 이미지 하나가 아닌 여러 이미지의 레이어로 구성되어 있습니다.\n<img src=\"./image-layer.png\" alt=\"image layer\">\n따라서 하나의 이미지라도 여러 이미지가 투영되어 보이는 결과물이라 볼 수 있습니다.</p>\n</blockquote>\n<h2 id=\"docker-이미지-삭제\">Docker 이미지 삭제</h2>\n<p>rmi 명령을 이용하여 docker의 image를 삭제 할 수 있습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker rmi redis:5.0-alpine, docker rmi &lt;imageID&gt;</span></span><br><span class=\"line\">docker rmi &#123;이미지명/이미지ID&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>자주 사용하는 Options\n<ul>\n<li>-f --force : 이미지를 강제로 삭제합니다. (해당 이미지로 만들어진 Docker Container가 존재하는 경우 이미지를 삭제 할 수 없는데, 그 때 강제로 삭제 하기위해 사용)</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"docker-container-생성-삭제\">Docker Container 생성 / 삭제</h1>\n<h2 id=\"docker-container-생성\">Docker Container 생성</h2>\n<p>run 명령으로 Container를 생성합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker run -it -d redis:5.0-alpine,</span></span><br><span class=\"line\"><span class=\"comment\">#     docker run -it -d 4760dc956b2d</span></span><br><span class=\"line\">docker run &#123;options&#125; &lt;image명/image ID&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>\n<p>자주 사용하는 Options</p>\n<ul>\n<li>-d --detach : Container 생성 후 Background로 실행 (이 옵션 없을 시, Redis 같은 경우에는 Console에 Redis log가 지속적으로 표시됩니다.)</li>\n<li>-h --hostname : Container 명 지정</li>\n<li>-i --interactive : 소통형 모드로 실행 (주로 ubuntu와 같은 Container 실행 시 사용)</li>\n<li>-p --publish : 해당 Container의 외부 Port 지정 (10000:6379) (외부:내부) 형식으로 지정</li>\n<li>-P --publish-all : 여러개의 Port 노출 (1000-1100)</li>\n<li>--rm : Container 종료 시, Container 삭제 <code>(자주 사용되는 옵션입니다)</code></li>\n<li>-v --volume : 외부 볼륨 연동 /home/user/data:/data (외부 OS 디렉토리:컨테이너 내부 디렉토리) - 상호 데이터가 공유됨</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"docker-container-목록-조회\">Docker Container 목록 조회</h2>\n<p>ps 명령으로 Container 목록을 조회합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps &#123;options&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>자주 사용하는 Options</li>\n<li>-a : 비활성 상태의 Container까지 조회</li>\n<li>-q : Container ID만 조회</li>\n<li>-f --filter : Container 조회 시, Filter를 이용하여 조회</li>\n</ul>\n<h2 id=\"docker-container-내부-접속\">Docker Container 내부 접속</h2>\n<p>attach 명령을 이용하여 접속\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker attach [container명/container ID]</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>attach 명령은 /bin/bash로 실행 되기 때문에, Container에 /bin/bash가 없는 경우에는 접속이 불가능 합니다.</p>\n</blockquote>\n<p>exec 명령을 이용하여 Container 내부 명령 수행\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker exec -it redis:5.0-alpine /bin/sh</span></span><br><span class=\"line\"><span class=\"comment\"># Redis의 경우 Container에 bin/bash가 없어 bin/sh로 실행하면 내부접속이 가능합니다</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> &#123;options&#125; [container명/container ID] [명령어]</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>자주 사용하는 options\n<ul>\n<li>-d --detach : 명령수행을 Background 모드로 수행</li>\n<li>-e --env : 환경변수 (Environment) 설정</li>\n<li>-i --interaction : 대화형 모드로 설정</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"docker-container-삭제\">Docker Container 삭제</h1>\n<p>rm 명령으로 Container를 삭제 합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker rm -f redis:5.0-alpine</span></span><br><span class=\"line\">docker rm &#123;options&#125; [container명/container ID]</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>자주 사용하는 options\n<ul>\n<li>-f --force : 활성(active) 상태의 Container 강제삭제</li>\n<li>-l --link : Container간 link가 관계인 Container 삭제</li>\n<li>-v --volumes : Container 관련 볼륨(외부 디렉토리) 삭제</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"자주-사용한-명령어-모음\">자주 사용한 명령어 모음</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Container 전체 삭제 (-a -q 옵션으로 전체 Container의 ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rm -f $(docker ps -a -q)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Image 전체 삭제 (-q 옵션으로 images에 대한 Image ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rmi $(docker images -q)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#특정 Container 삭제 (grep 명령으로 Container ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rm -f $(docker ps -a | grep <span class=\"string\">\"redis:5.0-alpine\"</span>| awk <span class=\"string\">'&#123;print $1&#125;'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#특정 이미지 삭제 (grep + awk 명령어로 image ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rmi $(docker images | grep <span class=\"string\">\"^redis\"</span>| awk <span class=\"string\">'&#123;print $3&#125;'</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Docker 삭제</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">yum remove -y docker*</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>http://www.sauru.so/blog/docker-installation-and-test-drive/</li>\n<li>https://hub.docker.com/_/redis/</li>\n<li>http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03</li>\n<li>https://docs.docker.com/engine/reference/run/</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>지난 장에서는 Docker에 대한 개념, Image와 컨테이너, VM과의 차이점등을 그림으로 설명하였습니다.\n이번 장부터는 Docker를 linux서버에 설치하는 과정을 설명하고자 합니다.\n(Linux서버 설치는 hyper-v를 이용하여 vm으로 설치 하였습니다. &lt;차후에 hyper-v 설정기를 올릴 예정입니다.&gt;)\nWindows, Mac에도 설치 할 수 있지만, Linux에 설치하는게 거의 표준이다 싶히 사용되고 있으며, Windows, Mac에 설치를 하더라도 어차피 가상화 환경에서 Docker가 설치 되기 때문에... linux를 설치하여 Docker를 설치하였습니다.\n(지울 때 편하게 지우고 싶어서 그런건 안비밀)</p>\n<h1>CentOS 7 환경에서 Docker 설치하기</h1>\n<p>Docker를 설치하는 방법은 다양한 방법이 있겠지만.. 가장 간단한 방법으로 설치해 보도록 하겠습니다.</p>\n<p>설치 환경은 아래와 같습니다.</p>\n<ul>\n<li>OS: CentOS 7 (VM 환경(Hyper-v)에서 테스트)</li>\n<li>user: docker-user (일부러 root가 아닌 사용자를 생성하였습니다... 이유는 아래에)</li>\n<li>SW: Redis 5</li>\n</ul>\n<blockquote>\n<p>Docker 다운로드 yum을 이용해서 Docker를 받는 방법도 있지만, <code>최신버전이 아닙니다.</code>\n차후 Docker-compose를 사용하기 위해서는 Docker버전이 1.13 이상이 되야 합니다.\n따라서 한번에 패키지로 설치해 주는 url로 설치하도록 합니다.</p>\n</blockquote>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo curl -fsSL https://get.docker.com/ | sudo sh</span><br><span class=\"line\">sudo sh sudo service docker start <span class=\"comment\">#Docker Daemon Start</span></span><br></pre></td></tr></table></figure></p>\n<h1>Docker의 Permission</h1>\n<p>Docker를 설치하고 확인하기 위해 Docker 명령을 입력하였습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./docker-permission.png\" alt=\"docker permission\"></p>\n<p>docker명령을 입력했을 시, permission denied 에러가 발생한 것을 볼 수 있습니다.\ndocker는 명령을 실행 할 때 기본적으로 root계정을 필요로 합니다. (docker의 특성상 시스템의 내부적인 부분에 접근하는 게 많다보니... 그렇다고 합니다.)\n그렇기 때문에 sudo명령을 사용하여 docker 명령을 실행 할 수 있습니다.</p>\n<p><code>하지만 sudo가 너무 귀찮다! 하시는 분들은...</code> 아래 명령을 실행하여 계정을 <code>docker 그룹</code>에 포함 시켜주시면 됩니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG docker <span class=\"variable\">$USER</span></span><br><span class=\"line\">sudo service docker restart</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">exit</span> <span class=\"comment\">#로그아웃</span></span><br><span class=\"line\">docker-user &lt;password&gt; <span class=\"comment\">#다시 로그인</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./sudo-docker.png\" alt=\"sudo docker\"></p>\n<p>이제 sudo 명령 없이도 docker 명령어 실행이 잘 됩니다!</p>\n<h1>간단한 Docker Container(깡통)를 만들어 봅시다!</h1>\n<p>Docker Hub(<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com</a>) 사이트에 들어가면 우리가 필요로하는 많은 프로그램들이 이미지로 올라가 있습니다.\n이번 예제에서는 Redis를 가지고 Docker Container를 만들어보도록 하겠습니다.</p>\n<p><img src=\"./docker-hub.png\" alt=\"docker-hub\"></p>\n<p>docker hub 사이트에서 redis를 검색해 보았습니다.\n여러가지 redis 이미지가 보이는데 official이라고 되어있는 것이 공식이미지 입니다.\nbitnami/redis라고 되어있는 것은 docker hub의 사용자들이 올린 이미지입니다.</p>\n<p><img src=\"./redis-versions.png\" alt=\"redis-versions\"></p>\n<p>official 이미지의 상세 버전을 보니 4.x~5.0.1까지 있습니다.\n이번 예제에서는 그나마 stable한 버전인 인 5.0-alpine 버전을 사용해 보도록 하겠습니다.</p>\n<h1>Docker 이미지 다운로드 (Docker hub -&gt; Docker Client)</h1>\n<p>pull 명령을 통해 docker hub에 있는 이미지를 다운로드 합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull redis:&lt;tag&gt; <span class=\"comment\"># ex) redis:5.0-alpine, redis:4-alpine, redis:latest(가장 마지막 배포 버전입니다.)</span></span><br><span class=\"line\">docker pull redis <span class=\"comment\">#tag version을 적지 않은 경우 자동으로 lastest 버전을 다운로드 합니다.</span></span><br></pre></td></tr></table></figure></p>\n<h1>Docker 이미지 확인 / 삭제</h1>\n<h2>Docker 이미지 확인</h2>\n<p>images 명령을 이용하여 docker image리스트를 확인합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>자주 사용하는 options\n<ul>\n<li>-a --all : 숨겨진 임시 이미지를 보여줍니다.</li>\n<li>-f --filter : filter를 이용하여 이미지 조회 조건을 변경하여 조회 할 수 있습니다.</li>\n<li>-q --quite : image의 image ID만 출력합니다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>docker의 이미지는 1개의 파일이 아닌, 여러 이미지의 레이어(Layer)로 구성되어 있습니다.\n따라서 Redis이미지를 다운받더라고 Redis 이미지 하나가 아닌 여러 이미지의 레이어로 구성되어 있습니다.\n<img src=\"./image-layer.png\" alt=\"image layer\">\n따라서 하나의 이미지라도 여러 이미지가 투영되어 보이는 결과물이라 볼 수 있습니다.</p>\n</blockquote>\n<h2>Docker 이미지 삭제</h2>\n<p>rmi 명령을 이용하여 docker의 image를 삭제 할 수 있습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker rmi redis:5.0-alpine, docker rmi &lt;imageID&gt;</span></span><br><span class=\"line\">docker rmi &#123;이미지명/이미지ID&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>자주 사용하는 Options\n<ul>\n<li>-f --force : 이미지를 강제로 삭제합니다. (해당 이미지로 만들어진 Docker Container가 존재하는 경우 이미지를 삭제 할 수 없는데, 그 때 강제로 삭제 하기위해 사용)</li>\n</ul>\n</li>\n</ul>\n<h1>Docker Container 생성 / 삭제</h1>\n<h2>Docker Container 생성</h2>\n<p>run 명령으로 Container를 생성합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker run -it -d redis:5.0-alpine,</span></span><br><span class=\"line\"><span class=\"comment\">#     docker run -it -d 4760dc956b2d</span></span><br><span class=\"line\">docker run &#123;options&#125; &lt;image명/image ID&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>\n<p>자주 사용하는 Options</p>\n<ul>\n<li>-d --detach : Container 생성 후 Background로 실행 (이 옵션 없을 시, Redis 같은 경우에는 Console에 Redis log가 지속적으로 표시됩니다.)</li>\n<li>-h --hostname : Container 명 지정</li>\n<li>-i --interactive : 소통형 모드로 실행 (주로 ubuntu와 같은 Container 실행 시 사용)</li>\n<li>-p --publish : 해당 Container의 외부 Port 지정 (10000:6379) (외부:내부) 형식으로 지정</li>\n<li>-P --publish-all : 여러개의 Port 노출 (1000-1100)</li>\n<li>--rm : Container 종료 시, Container 삭제 <code>(자주 사용되는 옵션입니다)</code></li>\n<li>-v --volume : 외부 볼륨 연동 /home/user/data:/data (외부 OS 디렉토리:컨테이너 내부 디렉토리) - 상호 데이터가 공유됨</li>\n</ul>\n</li>\n</ul>\n<h2>Docker Container 목록 조회</h2>\n<p>ps 명령으로 Container 목록을 조회합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps &#123;options&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>자주 사용하는 Options</li>\n<li>-a : 비활성 상태의 Container까지 조회</li>\n<li>-q : Container ID만 조회</li>\n<li>-f --filter : Container 조회 시, Filter를 이용하여 조회</li>\n</ul>\n<h2>Docker Container 내부 접속</h2>\n<p>attach 명령을 이용하여 접속\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker attach [container명/container ID]</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>attach 명령은 /bin/bash로 실행 되기 때문에, Container에 /bin/bash가 없는 경우에는 접속이 불가능 합니다.</p>\n</blockquote>\n<p>exec 명령을 이용하여 Container 내부 명령 수행\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker exec -it redis:5.0-alpine /bin/sh</span></span><br><span class=\"line\"><span class=\"comment\"># Redis의 경우 Container에 bin/bash가 없어 bin/sh로 실행하면 내부접속이 가능합니다</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> &#123;options&#125; [container명/container ID] [명령어]</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>자주 사용하는 options\n<ul>\n<li>-d --detach : 명령수행을 Background 모드로 수행</li>\n<li>-e --env : 환경변수 (Environment) 설정</li>\n<li>-i --interaction : 대화형 모드로 설정</li>\n</ul>\n</li>\n</ul>\n<h1>Docker Container 삭제</h1>\n<p>rm 명령으로 Container를 삭제 합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker rm -f redis:5.0-alpine</span></span><br><span class=\"line\">docker rm &#123;options&#125; [container명/container ID]</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>자주 사용하는 options\n<ul>\n<li>-f --force : 활성(active) 상태의 Container 강제삭제</li>\n<li>-l --link : Container간 link가 관계인 Container 삭제</li>\n<li>-v --volumes : Container 관련 볼륨(외부 디렉토리) 삭제</li>\n</ul>\n</li>\n</ul>\n<h1>자주 사용한 명령어 모음</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Container 전체 삭제 (-a -q 옵션으로 전체 Container의 ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rm -f $(docker ps -a -q)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Image 전체 삭제 (-q 옵션으로 images에 대한 Image ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rmi $(docker images -q)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#특정 Container 삭제 (grep 명령으로 Container ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rm -f $(docker ps -a | grep <span class=\"string\">\"redis:5.0-alpine\"</span>| awk <span class=\"string\">'&#123;print $1&#125;'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#특정 이미지 삭제 (grep + awk 명령어로 image ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rmi $(docker images | grep <span class=\"string\">\"^redis\"</span>| awk <span class=\"string\">'&#123;print $3&#125;'</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Docker 삭제</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">yum remove -y docker*</span><br></pre></td></tr></table></figure></p>\n<h1>참고</h1>\n<ul>\n<li>http://www.sauru.so/blog/docker-installation-and-test-drive/</li>\n<li>https://hub.docker.com/_/redis/</li>\n<li>http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03</li>\n<li>https://docs.docker.com/engine/reference/run/</li>\n</ul>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (3) Dockerfile","date":"2018-12-01T06:44:03.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-12-01-docker-3","typora-copy-images-to":"2018-12-01-docker-3","_content":"\n# Dockerfile 이란?\n\n이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소프트웨어에 대한 공식이미지도 있지만, Docker Hub 사용자들이 공식이미지를 바탕으로 커스터마이징하여 배포한 이미지도 등록되어 있습니다.\n\n어떻게 이미지를 빌드하고 배포 할 수 있었을까요? **Dockerfile을 이용한 이미지 빌드를 이용하면 가능합니다.**\n\nDockerfile은 이미지를 바탕으로 몇가지 명령을 실행 할 수 있는 로직을 담은 파일입니다.\nDockerfile을 통해 더 유연하게 이미지에 대한 설정을 변경할 수 있고, 그 설정을 이미지에 담아 배포 할 수 있습니다.\n\n물론 Docker run 구문에서 options을 사용하여 같은 기능을 하도록 구현 할 수 있지만, Dockerfile로 작성하게 되면 향후 유지보수가 쉬워지고 run 구문에 대한 options을 전부 기억하지 않아도 되는 장점이 있습니다.\n\n이번 장에서는 Dockerfile을 작성하는 명령어를 위주로 알아보겠으며, 간단한 예제 Dockerfile을 보도록 하겠습니다.\n\n\n\n# Dockerfile 사용방법\n\nDockerfile을 이용한 docker build\n\n```sh\n#dockerfile이 위치한 directory의 dockerfile을 가지고 build합니다.\ndocker build -f /path/to/dockerfile \n```\n\n\n\n# Dockerfile을 구성하는 핵심 명령어\n\n## From - Dockerfile의 시작\n\nFrom 명령어는 어떤 이미지를 바탕으로 container를 빌드 할 것인지 명시합니다.\n\n```sh\n# redis:5.0-alpine 이미지를 바탕으로 빌드\nFrom redis:5.0-alpine\n```\n\n\n\n## CMD - Dockerfile의 끝\n\n\n* CMD명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.\n* 보통은 해당 프로그램을 실행시키는 명령을 사용합니다. ( ex> startup.sh)\n* CMD 명령은 Dockerfile에서 `단 한번만 사용`할 수 있습니다.\n\n\n\n명령어 예제\n\n```sh\n# 일반적인 실행 방법\nCMD [\"execute.sh\", \"param1\", \"param2\"] \n\n# Entrypoint 실행을 위한 Default Parameter - Entrypoint를 위한 파라미터를 제공\nCMD [\"param1\", \"param2\"] \n\n# shell form\nCMD execute.sh param1 param2\n```\n\n\n\n> CMD 구문 사용 시, 주의사항!\n>\n> ```sh\n> docker build -f ./dockerfile test\n> # Container 생성 시, docker run [이미지] [실행파일 또는 명령] 입니다.\n> docker run test echo \"test!\" \n> ```\n>\n> 위 예시 처럼 run 명령 시, 이미지 명 뒤에 `실행파일이나 명령어`가 오게되면 CMD에 설정된 명령은 `무시`되고 docker run 구문에서 사용된 명령이 **CMD 대신 실행**됩니다.\n\n\n\n## ENTRYPOINT\n\n* ENTRYPOINT명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.\n* 보통 스크립트를 실행하거나, 실행명령을 수행하게 됩니다.\n* ENTRYPOINT명령은 Dockerfile에서 `단 한번만 사용가능` 합니다.\n* 기본적으로 FROM에서 설정한 이미지의 /bin/sh 파일을 기반으로 실행되며, 이미지에 /bin/sh 파일이 없는 경우 실행이 불가능 합니다.\n\nENTRYPOINT 사용 예시\n```sh\nENTRYPOINT [\"docker-entrypoint.sh\"]\nENTRYPOINT [\"docker-entrypoint.sh\", \"--param1=true\", \"--param2=1\"]\n```\n\n```sh\n#run 명령의 options으로 구현한 방식\n#이러한 방식으로도 사용할 수 있지만, 추천하지 않는 안티패턴입니다.\ndocker run --entrypoint=\"docker-entrypoint.sh\" test\n```\n\n\n\n# Dockerfile에서 자주 사용하는 명령어\n\n## ADD - 파일을 Container에 추가\n\n* Container 내부에 Host OS의 파일을 추가하려고 할 때 사용합니다.\n* ADD <Host OS의 파일 경로> <Container의 파일 경로> 로 작성합니다.\n* <Container의 파일경로>란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.\n* <Host OS의 파일경로>는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가\n* <Container의 파일경로>는 `반드시 절대경로`로 사용합니다.\n* 와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.\n* Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀어서 Container에 추가됩니다.\n  (Container에 압축 해제 된 파일들이 추가됨)\n* 인터넷에 있는 파일 URL은 압축만 해제된 뒤, tar파일만 추가됩니다.\n* Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.\n* ADD로 추가되는 파일은 root root 기존 권한을 따릅니다 (단, URL로 추가된 파일의 경우 600)\n\n```sh\nADD ../file.sh /home/file.sh (x) #상위 디렉터리 사용x\nADD /home/user/file.sh /home/file.sh(x) #절대경로 사용x\nADD file.sh ../../file.sh (x) #<Container 파일경로>는 상대경로 사용x\n \nADD file.sh /home/file.sh (O) #가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.\nADD *.sh /home (O) # 와일드카드를 이용하여 복사 가능\nADD compress.tar.gz / # Container / 경로에 compress.tar파일의 풀어진 형태로 파일 추가\nADD http://file.co.kr/file/1234.tar.gz / # Container 내부의 / 경로에 1234.tar.gz 파일 추가\n```\n\n\n\n## COPY - 파일을 Container로 복사\n\n* ADD의 기능과 거의 유사합니다.\n* COPY <Host OS의 파일 경로> <Container의 파일 경로> 로 작성합니다.\n* <Container의 파일경로>란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.\n* <Host OS의 파일경로>는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가\n* <Container의 파일경로>는 `반드시 절대경로`로 사용합니다.\n* 와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.\n* Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀지않고 그대로 복사됩니다. **(ADD와 차이점)**\n* 인터넷에 있는 파일 URL은 사용 불가. **(ADD와 차이점)**\n* Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.\n* COPY로 추가되는 파일은 root root 기존 권한을 따릅니다\n\n```sh\nCOPY ../file.sh /home/file.sh (x) #상위 디렉터리 사용x\nCOPY /home/user/file.sh /home/file.sh(x) #절대경로 사용x\nCOPY file.sh ../../file.sh (x) #<Container 파일경로>는 상대경로 사용x\n \nCOPY file.sh /home/file.sh (O) #가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.\nCOPY *.sh /home (O) # 와일드카드를 이용하여 복사 가능\nCOPY compress.tar.gz / (O)# Container / 경로에 compress.tar파일이 복사\nCOPY http://file.co.kr/file/1234.tar.gz / (X) # COPY는 인터넷 파일URL 사용 불가\n```\n\n\n\n## RUN - Container 내부에서 명령 실행\n\n* 기본적으로 /bin/sh 파일로 실행됩니다.\n* Window의 경우 cmd 기반 명령을 수행합니다.\n\nDockerfile 내 RUN 명령어 사용법\n```sh\n# software 설치 명령 실행 (예시의 경우 yum이 Container내부에 설치되어야 합니다.)\nRUN yum -y install software  \n# /usr/local/redis directory 생성\nRUN mkdir -p /usr/local/redis \n# execute.sh 파일 실행 \nRUN [\"execute.sh\", \"param1\", \"param2\"] \n```\n\n\n\n명령어의 길이가 긴 경우 \\ 문자를 사용하여 append 가능합니다\n\n```sh\nRUN yum -y install software \\\n         echo \"install software\" \\\n         mkdir -p /usr/local/redis\n```\n\n\n\n## ENV - Container 내부에서 사용할 환경 변수 추가\n\nContainer는 Host OS와 독립된 공간이기 때문에 Container 내부에서 사용 할 환경변수를 추가할 수 있습니다.\n\n```sh\nENV LOCAL_PORT 80\nENV REDIS_HOME /usr/local/bin/redis\n```\n\n\n\n## EXPOSE - Container의 Port 설정\n\n* Host OS - Container와 통신할 포트를 설정\n* EXPOSE는 Host OS와 연결만 할 뿐 외부에 노출 되지는 않습니다.\n* 포트를 노출 하기 위해서는 docker run -p 또는 -P 옵션 사용해야 합니다.\n\n```sh\nEXPOSE 80   #Container 내의 Web Server Port 노출\nEXPOSE 6379 #Container 내의 Redis Server Port 노출\n \nEXPOSE 80 6379 #포트 여러개 노출\n```\n\n\n\n## VOLUME - 외부 볼륨 설정\n\n* Container 내부의 Directory와 Host OS의 Directory를 동기화 시키는 설정\n* log파일이나 설정파일은 보통 Container 내부에만 있는데 이를 Host OS에 동기화 하여 파일에 대한 접근이 가능하게 한다.\n\n```sh\n# Dockerfile volume 설정\nVOLUME [\"/data\", \"/var/log\"]\n\n# docker run 사용 시, volumn 설정\n# -v 옵션을 사용하여 설정 -v <host 디렉터리>:<컨테이너 디렉터리>\ndocker run -v /host/os/data:/container/data app \n```\n\n\n\n## WORKDIR - Container의 Work Directory 설정\n\n* RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉터리\n* 중간에 Directory가 변경되는 경우 바꿀수 있다.\n* 리눅스의 cd 명령어와 비슷하다.\n\n```sh\nWORKDIR /usr/local/bin\nADD redis.conf /usr/local/bin/redis.conf\n \nWORKDIR /usr/local\nADD redis.log /usr/local/redis.log\n\nWORKDIR var\nWORKDIR lib\nRUN touch file.sh # /var/lib/file.sh 생성\n```\n\n# 참고\n* http://pyrasis.com/book/DockerForTheReallyImpatient\n* https://docs.docker.com/engine/reference/builder\n","source":"_posts/2018-12-01-docker-3.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (3) Dockerfile\ndate: 2018-12-01 15:44:03\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-12-01-docker-3\ntypora-copy-images-to: 2018-12-01-docker-3\n---\n\n# Dockerfile 이란?\n\n이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소프트웨어에 대한 공식이미지도 있지만, Docker Hub 사용자들이 공식이미지를 바탕으로 커스터마이징하여 배포한 이미지도 등록되어 있습니다.\n\n어떻게 이미지를 빌드하고 배포 할 수 있었을까요? **Dockerfile을 이용한 이미지 빌드를 이용하면 가능합니다.**\n\nDockerfile은 이미지를 바탕으로 몇가지 명령을 실행 할 수 있는 로직을 담은 파일입니다.\nDockerfile을 통해 더 유연하게 이미지에 대한 설정을 변경할 수 있고, 그 설정을 이미지에 담아 배포 할 수 있습니다.\n\n물론 Docker run 구문에서 options을 사용하여 같은 기능을 하도록 구현 할 수 있지만, Dockerfile로 작성하게 되면 향후 유지보수가 쉬워지고 run 구문에 대한 options을 전부 기억하지 않아도 되는 장점이 있습니다.\n\n이번 장에서는 Dockerfile을 작성하는 명령어를 위주로 알아보겠으며, 간단한 예제 Dockerfile을 보도록 하겠습니다.\n\n\n\n# Dockerfile 사용방법\n\nDockerfile을 이용한 docker build\n\n```sh\n#dockerfile이 위치한 directory의 dockerfile을 가지고 build합니다.\ndocker build -f /path/to/dockerfile \n```\n\n\n\n# Dockerfile을 구성하는 핵심 명령어\n\n## From - Dockerfile의 시작\n\nFrom 명령어는 어떤 이미지를 바탕으로 container를 빌드 할 것인지 명시합니다.\n\n```sh\n# redis:5.0-alpine 이미지를 바탕으로 빌드\nFrom redis:5.0-alpine\n```\n\n\n\n## CMD - Dockerfile의 끝\n\n\n* CMD명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.\n* 보통은 해당 프로그램을 실행시키는 명령을 사용합니다. ( ex> startup.sh)\n* CMD 명령은 Dockerfile에서 `단 한번만 사용`할 수 있습니다.\n\n\n\n명령어 예제\n\n```sh\n# 일반적인 실행 방법\nCMD [\"execute.sh\", \"param1\", \"param2\"] \n\n# Entrypoint 실행을 위한 Default Parameter - Entrypoint를 위한 파라미터를 제공\nCMD [\"param1\", \"param2\"] \n\n# shell form\nCMD execute.sh param1 param2\n```\n\n\n\n> CMD 구문 사용 시, 주의사항!\n>\n> ```sh\n> docker build -f ./dockerfile test\n> # Container 생성 시, docker run [이미지] [실행파일 또는 명령] 입니다.\n> docker run test echo \"test!\" \n> ```\n>\n> 위 예시 처럼 run 명령 시, 이미지 명 뒤에 `실행파일이나 명령어`가 오게되면 CMD에 설정된 명령은 `무시`되고 docker run 구문에서 사용된 명령이 **CMD 대신 실행**됩니다.\n\n\n\n## ENTRYPOINT\n\n* ENTRYPOINT명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.\n* 보통 스크립트를 실행하거나, 실행명령을 수행하게 됩니다.\n* ENTRYPOINT명령은 Dockerfile에서 `단 한번만 사용가능` 합니다.\n* 기본적으로 FROM에서 설정한 이미지의 /bin/sh 파일을 기반으로 실행되며, 이미지에 /bin/sh 파일이 없는 경우 실행이 불가능 합니다.\n\nENTRYPOINT 사용 예시\n```sh\nENTRYPOINT [\"docker-entrypoint.sh\"]\nENTRYPOINT [\"docker-entrypoint.sh\", \"--param1=true\", \"--param2=1\"]\n```\n\n```sh\n#run 명령의 options으로 구현한 방식\n#이러한 방식으로도 사용할 수 있지만, 추천하지 않는 안티패턴입니다.\ndocker run --entrypoint=\"docker-entrypoint.sh\" test\n```\n\n\n\n# Dockerfile에서 자주 사용하는 명령어\n\n## ADD - 파일을 Container에 추가\n\n* Container 내부에 Host OS의 파일을 추가하려고 할 때 사용합니다.\n* ADD <Host OS의 파일 경로> <Container의 파일 경로> 로 작성합니다.\n* <Container의 파일경로>란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.\n* <Host OS의 파일경로>는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가\n* <Container의 파일경로>는 `반드시 절대경로`로 사용합니다.\n* 와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.\n* Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀어서 Container에 추가됩니다.\n  (Container에 압축 해제 된 파일들이 추가됨)\n* 인터넷에 있는 파일 URL은 압축만 해제된 뒤, tar파일만 추가됩니다.\n* Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.\n* ADD로 추가되는 파일은 root root 기존 권한을 따릅니다 (단, URL로 추가된 파일의 경우 600)\n\n```sh\nADD ../file.sh /home/file.sh (x) #상위 디렉터리 사용x\nADD /home/user/file.sh /home/file.sh(x) #절대경로 사용x\nADD file.sh ../../file.sh (x) #<Container 파일경로>는 상대경로 사용x\n \nADD file.sh /home/file.sh (O) #가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.\nADD *.sh /home (O) # 와일드카드를 이용하여 복사 가능\nADD compress.tar.gz / # Container / 경로에 compress.tar파일의 풀어진 형태로 파일 추가\nADD http://file.co.kr/file/1234.tar.gz / # Container 내부의 / 경로에 1234.tar.gz 파일 추가\n```\n\n\n\n## COPY - 파일을 Container로 복사\n\n* ADD의 기능과 거의 유사합니다.\n* COPY <Host OS의 파일 경로> <Container의 파일 경로> 로 작성합니다.\n* <Container의 파일경로>란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.\n* <Host OS의 파일경로>는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가\n* <Container의 파일경로>는 `반드시 절대경로`로 사용합니다.\n* 와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.\n* Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀지않고 그대로 복사됩니다. **(ADD와 차이점)**\n* 인터넷에 있는 파일 URL은 사용 불가. **(ADD와 차이점)**\n* Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.\n* COPY로 추가되는 파일은 root root 기존 권한을 따릅니다\n\n```sh\nCOPY ../file.sh /home/file.sh (x) #상위 디렉터리 사용x\nCOPY /home/user/file.sh /home/file.sh(x) #절대경로 사용x\nCOPY file.sh ../../file.sh (x) #<Container 파일경로>는 상대경로 사용x\n \nCOPY file.sh /home/file.sh (O) #가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.\nCOPY *.sh /home (O) # 와일드카드를 이용하여 복사 가능\nCOPY compress.tar.gz / (O)# Container / 경로에 compress.tar파일이 복사\nCOPY http://file.co.kr/file/1234.tar.gz / (X) # COPY는 인터넷 파일URL 사용 불가\n```\n\n\n\n## RUN - Container 내부에서 명령 실행\n\n* 기본적으로 /bin/sh 파일로 실행됩니다.\n* Window의 경우 cmd 기반 명령을 수행합니다.\n\nDockerfile 내 RUN 명령어 사용법\n```sh\n# software 설치 명령 실행 (예시의 경우 yum이 Container내부에 설치되어야 합니다.)\nRUN yum -y install software  \n# /usr/local/redis directory 생성\nRUN mkdir -p /usr/local/redis \n# execute.sh 파일 실행 \nRUN [\"execute.sh\", \"param1\", \"param2\"] \n```\n\n\n\n명령어의 길이가 긴 경우 \\ 문자를 사용하여 append 가능합니다\n\n```sh\nRUN yum -y install software \\\n         echo \"install software\" \\\n         mkdir -p /usr/local/redis\n```\n\n\n\n## ENV - Container 내부에서 사용할 환경 변수 추가\n\nContainer는 Host OS와 독립된 공간이기 때문에 Container 내부에서 사용 할 환경변수를 추가할 수 있습니다.\n\n```sh\nENV LOCAL_PORT 80\nENV REDIS_HOME /usr/local/bin/redis\n```\n\n\n\n## EXPOSE - Container의 Port 설정\n\n* Host OS - Container와 통신할 포트를 설정\n* EXPOSE는 Host OS와 연결만 할 뿐 외부에 노출 되지는 않습니다.\n* 포트를 노출 하기 위해서는 docker run -p 또는 -P 옵션 사용해야 합니다.\n\n```sh\nEXPOSE 80   #Container 내의 Web Server Port 노출\nEXPOSE 6379 #Container 내의 Redis Server Port 노출\n \nEXPOSE 80 6379 #포트 여러개 노출\n```\n\n\n\n## VOLUME - 외부 볼륨 설정\n\n* Container 내부의 Directory와 Host OS의 Directory를 동기화 시키는 설정\n* log파일이나 설정파일은 보통 Container 내부에만 있는데 이를 Host OS에 동기화 하여 파일에 대한 접근이 가능하게 한다.\n\n```sh\n# Dockerfile volume 설정\nVOLUME [\"/data\", \"/var/log\"]\n\n# docker run 사용 시, volumn 설정\n# -v 옵션을 사용하여 설정 -v <host 디렉터리>:<컨테이너 디렉터리>\ndocker run -v /host/os/data:/container/data app \n```\n\n\n\n## WORKDIR - Container의 Work Directory 설정\n\n* RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉터리\n* 중간에 Directory가 변경되는 경우 바꿀수 있다.\n* 리눅스의 cd 명령어와 비슷하다.\n\n```sh\nWORKDIR /usr/local/bin\nADD redis.conf /usr/local/bin/redis.conf\n \nWORKDIR /usr/local\nADD redis.log /usr/local/redis.log\n\nWORKDIR var\nWORKDIR lib\nRUN touch file.sh # /var/lib/file.sh 생성\n```\n\n# 참고\n* http://pyrasis.com/book/DockerForTheReallyImpatient\n* https://docs.docker.com/engine/reference/builder\n","slug":"2018-12-01-docker-3","published":1,"updated":"2018-12-08T08:36:25.490Z","comments":1,"photos":[],"link":"","_id":"cjrgbv3rq003bcr1tsx820cbd","content":"<h1 id=\"dockerfile-이란\">Dockerfile 이란?</h1>\n<p>이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소프트웨어에 대한 공식이미지도 있지만, Docker Hub 사용자들이 공식이미지를 바탕으로 커스터마이징하여 배포한 이미지도 등록되어 있습니다.</p>\n<p>어떻게 이미지를 빌드하고 배포 할 수 있었을까요? <strong>Dockerfile을 이용한 이미지 빌드를 이용하면 가능합니다.</strong></p>\n<p>Dockerfile은 이미지를 바탕으로 몇가지 명령을 실행 할 수 있는 로직을 담은 파일입니다.\nDockerfile을 통해 더 유연하게 이미지에 대한 설정을 변경할 수 있고, 그 설정을 이미지에 담아 배포 할 수 있습니다.</p>\n<p>물론 Docker run 구문에서 options을 사용하여 같은 기능을 하도록 구현 할 수 있지만, Dockerfile로 작성하게 되면 향후 유지보수가 쉬워지고 run 구문에 대한 options을 전부 기억하지 않아도 되는 장점이 있습니다.</p>\n<p>이번 장에서는 Dockerfile을 작성하는 명령어를 위주로 알아보겠으며, 간단한 예제 Dockerfile을 보도록 하겠습니다.</p>\n<h1 id=\"dockerfile-사용방법\">Dockerfile 사용방법</h1>\n<p>Dockerfile을 이용한 docker build</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dockerfile이 위치한 directory의 dockerfile을 가지고 build합니다.</span></span><br><span class=\"line\">docker build -f /path/to/dockerfile</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"dockerfile을-구성하는-핵심-명령어\">Dockerfile을 구성하는 핵심 명령어</h1>\n<h2 id=\"from-dockerfile의-시작\">From - Dockerfile의 시작</h2>\n<p>From 명령어는 어떤 이미지를 바탕으로 container를 빌드 할 것인지 명시합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis:5.0-alpine 이미지를 바탕으로 빌드</span></span><br><span class=\"line\">From redis:5.0-alpine</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"cmd-dockerfile의-끝\">CMD - Dockerfile의 끝</h2>\n<ul>\n<li>CMD명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li>\n<li>보통은 해당 프로그램을 실행시키는 명령을 사용합니다. ( ex&gt; startup.sh)</li>\n<li>CMD 명령은 Dockerfile에서 <code>단 한번만 사용</code>할 수 있습니다.</li>\n</ul>\n<p>명령어 예제</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 일반적인 실행 방법</span></span><br><span class=\"line\">CMD [<span class=\"string\">\"execute.sh\"</span>, <span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Entrypoint 실행을 위한 Default Parameter - Entrypoint를 위한 파라미터를 제공</span></span><br><span class=\"line\">CMD [<span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># shell form</span></span><br><span class=\"line\">CMD execute.sh param1 param2</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>CMD 구문 사용 시, 주의사항!</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; docker build -f ./dockerfile <span class=\"built_in\">test</span></span><br><span class=\"line\">&gt; <span class=\"comment\"># Container 생성 시, docker run [이미지] [실행파일 또는 명령] 입니다.</span></span><br><span class=\"line\">&gt; docker run <span class=\"built_in\">test</span> <span class=\"built_in\">echo</span> <span class=\"string\">\"test!\"</span> </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>위 예시 처럼 run 명령 시, 이미지 명 뒤에 <code>실행파일이나 명령어</code>가 오게되면 CMD에 설정된 명령은 <code>무시</code>되고 docker run 구문에서 사용된 명령이 <strong>CMD 대신 실행</strong>됩니다.</p>\n</blockquote>\n<h2 id=\"entrypoint\">ENTRYPOINT</h2>\n<ul>\n<li>ENTRYPOINT명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li>\n<li>보통 스크립트를 실행하거나, 실행명령을 수행하게 됩니다.</li>\n<li>ENTRYPOINT명령은 Dockerfile에서 <code>단 한번만 사용가능</code> 합니다.</li>\n<li>기본적으로 FROM에서 설정한 이미지의 /bin/sh 파일을 기반으로 실행되며, 이미지에 /bin/sh 파일이 없는 경우 실행이 불가능 합니다.</li>\n</ul>\n<p>ENTRYPOINT 사용 예시\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"docker-entrypoint.sh\"</span>]</span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"docker-entrypoint.sh\"</span>, <span class=\"string\">\"--param1=true\"</span>, <span class=\"string\">\"--param2=1\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#run 명령의 options으로 구현한 방식</span></span><br><span class=\"line\"><span class=\"comment\">#이러한 방식으로도 사용할 수 있지만, 추천하지 않는 안티패턴입니다.</span></span><br><span class=\"line\">docker run --entrypoint=<span class=\"string\">\"docker-entrypoint.sh\"</span> <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"dockerfile에서-자주-사용하는-명령어\">Dockerfile에서 자주 사용하는 명령어</h1>\n<h2 id=\"add-파일을-container에-추가\">ADD - 파일을 Container에 추가</h2>\n<ul>\n<li>Container 내부에 Host OS의 파일을 추가하려고 할 때 사용합니다.</li>\n<li>ADD &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li>\n<li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li>\n<li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li>\n<li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li>\n<li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li>\n<li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀어서 Container에 추가됩니다.\n(Container에 압축 해제 된 파일들이 추가됨)</li>\n<li>인터넷에 있는 파일 URL은 압축만 해제된 뒤, tar파일만 추가됩니다.</li>\n<li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li>\n<li>ADD로 추가되는 파일은 root root 기존 권한을 따릅니다 (단, URL로 추가된 파일의 경우 600)</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADD ../file.sh /home/file.sh (x) <span class=\"comment\">#상위 디렉터리 사용x</span></span><br><span class=\"line\">ADD /home/user/file.sh /home/file.sh(x) <span class=\"comment\">#절대경로 사용x</span></span><br><span class=\"line\">ADD file.sh ../../file.sh (x) <span class=\"comment\">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class=\"line\"> </span><br><span class=\"line\">ADD file.sh /home/file.sh (O) <span class=\"comment\">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class=\"line\">ADD *.sh /home (O) <span class=\"comment\"># 와일드카드를 이용하여 복사 가능</span></span><br><span class=\"line\">ADD compress.tar.gz / <span class=\"comment\"># Container / 경로에 compress.tar파일의 풀어진 형태로 파일 추가</span></span><br><span class=\"line\">ADD http://file.co.kr/file/1234.tar.gz / <span class=\"comment\"># Container 내부의 / 경로에 1234.tar.gz 파일 추가</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"copy-파일을-container로-복사\">COPY - 파일을 Container로 복사</h2>\n<ul>\n<li>ADD의 기능과 거의 유사합니다.</li>\n<li>COPY &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li>\n<li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li>\n<li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li>\n<li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li>\n<li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li>\n<li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀지않고 그대로 복사됩니다. <strong>(ADD와 차이점)</strong></li>\n<li>인터넷에 있는 파일 URL은 사용 불가. <strong>(ADD와 차이점)</strong></li>\n<li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li>\n<li>COPY로 추가되는 파일은 root root 기존 권한을 따릅니다</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY ../file.sh /home/file.sh (x) <span class=\"comment\">#상위 디렉터리 사용x</span></span><br><span class=\"line\">COPY /home/user/file.sh /home/file.sh(x) <span class=\"comment\">#절대경로 사용x</span></span><br><span class=\"line\">COPY file.sh ../../file.sh (x) <span class=\"comment\">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class=\"line\"> </span><br><span class=\"line\">COPY file.sh /home/file.sh (O) <span class=\"comment\">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class=\"line\">COPY *.sh /home (O) <span class=\"comment\"># 와일드카드를 이용하여 복사 가능</span></span><br><span class=\"line\">COPY compress.tar.gz / (O)<span class=\"comment\"># Container / 경로에 compress.tar파일이 복사</span></span><br><span class=\"line\">COPY http://file.co.kr/file/1234.tar.gz / (X) <span class=\"comment\"># COPY는 인터넷 파일URL 사용 불가</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"run-container-내부에서-명령-실행\">RUN - Container 내부에서 명령 실행</h2>\n<ul>\n<li>기본적으로 /bin/sh 파일로 실행됩니다.</li>\n<li>Window의 경우 cmd 기반 명령을 수행합니다.</li>\n</ul>\n<p>Dockerfile 내 RUN 명령어 사용법\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># software 설치 명령 실행 (예시의 경우 yum이 Container내부에 설치되어야 합니다.)</span></span><br><span class=\"line\">RUN yum -y install software  </span><br><span class=\"line\"><span class=\"comment\"># /usr/local/redis directory 생성</span></span><br><span class=\"line\">RUN mkdir -p /usr/<span class=\"built_in\">local</span>/redis </span><br><span class=\"line\"><span class=\"comment\"># execute.sh 파일 실행 </span></span><br><span class=\"line\">RUN [<span class=\"string\">\"execute.sh\"</span>, <span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p>명령어의 길이가 긴 경우 \\ 문자를 사용하여 append 가능합니다</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN yum -y install software \\</span><br><span class=\"line\">         <span class=\"built_in\">echo</span> <span class=\"string\">\"install software\"</span> \\</span><br><span class=\"line\">         mkdir -p /usr/<span class=\"built_in\">local</span>/redis</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"env-container-내부에서-사용할-환경-변수-추가\">ENV - Container 내부에서 사용할 환경 변수 추가</h2>\n<p>Container는 Host OS와 독립된 공간이기 때문에 Container 내부에서 사용 할 환경변수를 추가할 수 있습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV LOCAL_PORT 80</span><br><span class=\"line\">ENV REDIS_HOME /usr/<span class=\"built_in\">local</span>/bin/redis</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"expose-container의-port-설정\">EXPOSE - Container의 Port 설정</h2>\n<ul>\n<li>Host OS - Container와 통신할 포트를 설정</li>\n<li>EXPOSE는 Host OS와 연결만 할 뿐 외부에 노출 되지는 않습니다.</li>\n<li>포트를 노출 하기 위해서는 docker run -p 또는 -P 옵션 사용해야 합니다.</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPOSE 80   <span class=\"comment\">#Container 내의 Web Server Port 노출</span></span><br><span class=\"line\">EXPOSE 6379 <span class=\"comment\">#Container 내의 Redis Server Port 노출</span></span><br><span class=\"line\"> </span><br><span class=\"line\">EXPOSE 80 6379 <span class=\"comment\">#포트 여러개 노출</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"volume-외부-볼륨-설정\">VOLUME - 외부 볼륨 설정</h2>\n<ul>\n<li>Container 내부의 Directory와 Host OS의 Directory를 동기화 시키는 설정</li>\n<li>log파일이나 설정파일은 보통 Container 내부에만 있는데 이를 Host OS에 동기화 하여 파일에 대한 접근이 가능하게 한다.</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Dockerfile volume 설정</span></span><br><span class=\"line\">VOLUME [<span class=\"string\">\"/data\"</span>, <span class=\"string\">\"/var/log\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># docker run 사용 시, volumn 설정</span></span><br><span class=\"line\"><span class=\"comment\"># -v 옵션을 사용하여 설정 -v &lt;host 디렉터리&gt;:&lt;컨테이너 디렉터리&gt;</span></span><br><span class=\"line\">docker run -v /host/os/data:/container/data app</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"workdir-container의-work-directory-설정\">WORKDIR - Container의 Work Directory 설정</h2>\n<ul>\n<li>RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉터리</li>\n<li>중간에 Directory가 변경되는 경우 바꿀수 있다.</li>\n<li>리눅스의 cd 명령어와 비슷하다.</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR /usr/<span class=\"built_in\">local</span>/bin</span><br><span class=\"line\">ADD redis.conf /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\"> </span><br><span class=\"line\">WORKDIR /usr/<span class=\"built_in\">local</span></span><br><span class=\"line\">ADD redis.log /usr/<span class=\"built_in\">local</span>/redis.log</span><br><span class=\"line\"></span><br><span class=\"line\">WORKDIR var</span><br><span class=\"line\">WORKDIR lib</span><br><span class=\"line\">RUN touch file.sh <span class=\"comment\"># /var/lib/file.sh 생성</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>http://pyrasis.com/book/DockerForTheReallyImpatient</li>\n<li>https://docs.docker.com/engine/reference/builder</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>Dockerfile 이란?</h1>\n<p>이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소프트웨어에 대한 공식이미지도 있지만, Docker Hub 사용자들이 공식이미지를 바탕으로 커스터마이징하여 배포한 이미지도 등록되어 있습니다.</p>\n<p>어떻게 이미지를 빌드하고 배포 할 수 있었을까요? <strong>Dockerfile을 이용한 이미지 빌드를 이용하면 가능합니다.</strong></p>\n<p>Dockerfile은 이미지를 바탕으로 몇가지 명령을 실행 할 수 있는 로직을 담은 파일입니다.\nDockerfile을 통해 더 유연하게 이미지에 대한 설정을 변경할 수 있고, 그 설정을 이미지에 담아 배포 할 수 있습니다.</p>\n<p>물론 Docker run 구문에서 options을 사용하여 같은 기능을 하도록 구현 할 수 있지만, Dockerfile로 작성하게 되면 향후 유지보수가 쉬워지고 run 구문에 대한 options을 전부 기억하지 않아도 되는 장점이 있습니다.</p>\n<p>이번 장에서는 Dockerfile을 작성하는 명령어를 위주로 알아보겠으며, 간단한 예제 Dockerfile을 보도록 하겠습니다.</p>\n<h1>Dockerfile 사용방법</h1>\n<p>Dockerfile을 이용한 docker build</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dockerfile이 위치한 directory의 dockerfile을 가지고 build합니다.</span></span><br><span class=\"line\">docker build -f /path/to/dockerfile</span><br></pre></td></tr></table></figure></p>\n<h1>Dockerfile을 구성하는 핵심 명령어</h1>\n<h2>From - Dockerfile의 시작</h2>\n<p>From 명령어는 어떤 이미지를 바탕으로 container를 빌드 할 것인지 명시합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis:5.0-alpine 이미지를 바탕으로 빌드</span></span><br><span class=\"line\">From redis:5.0-alpine</span><br></pre></td></tr></table></figure></p>\n<h2>CMD - Dockerfile의 끝</h2>\n<ul>\n<li>CMD명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li>\n<li>보통은 해당 프로그램을 실행시키는 명령을 사용합니다. ( ex&gt; startup.sh)</li>\n<li>CMD 명령은 Dockerfile에서 <code>단 한번만 사용</code>할 수 있습니다.</li>\n</ul>\n<p>명령어 예제</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 일반적인 실행 방법</span></span><br><span class=\"line\">CMD [<span class=\"string\">\"execute.sh\"</span>, <span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Entrypoint 실행을 위한 Default Parameter - Entrypoint를 위한 파라미터를 제공</span></span><br><span class=\"line\">CMD [<span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># shell form</span></span><br><span class=\"line\">CMD execute.sh param1 param2</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>CMD 구문 사용 시, 주의사항!</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; docker build -f ./dockerfile <span class=\"built_in\">test</span></span><br><span class=\"line\">&gt; <span class=\"comment\"># Container 생성 시, docker run [이미지] [실행파일 또는 명령] 입니다.</span></span><br><span class=\"line\">&gt; docker run <span class=\"built_in\">test</span> <span class=\"built_in\">echo</span> <span class=\"string\">\"test!\"</span> </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>위 예시 처럼 run 명령 시, 이미지 명 뒤에 <code>실행파일이나 명령어</code>가 오게되면 CMD에 설정된 명령은 <code>무시</code>되고 docker run 구문에서 사용된 명령이 <strong>CMD 대신 실행</strong>됩니다.</p>\n</blockquote>\n<h2>ENTRYPOINT</h2>\n<ul>\n<li>ENTRYPOINT명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li>\n<li>보통 스크립트를 실행하거나, 실행명령을 수행하게 됩니다.</li>\n<li>ENTRYPOINT명령은 Dockerfile에서 <code>단 한번만 사용가능</code> 합니다.</li>\n<li>기본적으로 FROM에서 설정한 이미지의 /bin/sh 파일을 기반으로 실행되며, 이미지에 /bin/sh 파일이 없는 경우 실행이 불가능 합니다.</li>\n</ul>\n<p>ENTRYPOINT 사용 예시\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"docker-entrypoint.sh\"</span>]</span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"docker-entrypoint.sh\"</span>, <span class=\"string\">\"--param1=true\"</span>, <span class=\"string\">\"--param2=1\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#run 명령의 options으로 구현한 방식</span></span><br><span class=\"line\"><span class=\"comment\">#이러한 방식으로도 사용할 수 있지만, 추천하지 않는 안티패턴입니다.</span></span><br><span class=\"line\">docker run --entrypoint=<span class=\"string\">\"docker-entrypoint.sh\"</span> <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure></p>\n<h1>Dockerfile에서 자주 사용하는 명령어</h1>\n<h2>ADD - 파일을 Container에 추가</h2>\n<ul>\n<li>Container 내부에 Host OS의 파일을 추가하려고 할 때 사용합니다.</li>\n<li>ADD &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li>\n<li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li>\n<li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li>\n<li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li>\n<li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li>\n<li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀어서 Container에 추가됩니다.\n(Container에 압축 해제 된 파일들이 추가됨)</li>\n<li>인터넷에 있는 파일 URL은 압축만 해제된 뒤, tar파일만 추가됩니다.</li>\n<li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li>\n<li>ADD로 추가되는 파일은 root root 기존 권한을 따릅니다 (단, URL로 추가된 파일의 경우 600)</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADD ../file.sh /home/file.sh (x) <span class=\"comment\">#상위 디렉터리 사용x</span></span><br><span class=\"line\">ADD /home/user/file.sh /home/file.sh(x) <span class=\"comment\">#절대경로 사용x</span></span><br><span class=\"line\">ADD file.sh ../../file.sh (x) <span class=\"comment\">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class=\"line\"> </span><br><span class=\"line\">ADD file.sh /home/file.sh (O) <span class=\"comment\">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class=\"line\">ADD *.sh /home (O) <span class=\"comment\"># 와일드카드를 이용하여 복사 가능</span></span><br><span class=\"line\">ADD compress.tar.gz / <span class=\"comment\"># Container / 경로에 compress.tar파일의 풀어진 형태로 파일 추가</span></span><br><span class=\"line\">ADD http://file.co.kr/file/1234.tar.gz / <span class=\"comment\"># Container 내부의 / 경로에 1234.tar.gz 파일 추가</span></span><br></pre></td></tr></table></figure></p>\n<h2>COPY - 파일을 Container로 복사</h2>\n<ul>\n<li>ADD의 기능과 거의 유사합니다.</li>\n<li>COPY &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li>\n<li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li>\n<li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li>\n<li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li>\n<li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li>\n<li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀지않고 그대로 복사됩니다. <strong>(ADD와 차이점)</strong></li>\n<li>인터넷에 있는 파일 URL은 사용 불가. <strong>(ADD와 차이점)</strong></li>\n<li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li>\n<li>COPY로 추가되는 파일은 root root 기존 권한을 따릅니다</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY ../file.sh /home/file.sh (x) <span class=\"comment\">#상위 디렉터리 사용x</span></span><br><span class=\"line\">COPY /home/user/file.sh /home/file.sh(x) <span class=\"comment\">#절대경로 사용x</span></span><br><span class=\"line\">COPY file.sh ../../file.sh (x) <span class=\"comment\">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class=\"line\"> </span><br><span class=\"line\">COPY file.sh /home/file.sh (O) <span class=\"comment\">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class=\"line\">COPY *.sh /home (O) <span class=\"comment\"># 와일드카드를 이용하여 복사 가능</span></span><br><span class=\"line\">COPY compress.tar.gz / (O)<span class=\"comment\"># Container / 경로에 compress.tar파일이 복사</span></span><br><span class=\"line\">COPY http://file.co.kr/file/1234.tar.gz / (X) <span class=\"comment\"># COPY는 인터넷 파일URL 사용 불가</span></span><br></pre></td></tr></table></figure></p>\n<h2>RUN - Container 내부에서 명령 실행</h2>\n<ul>\n<li>기본적으로 /bin/sh 파일로 실행됩니다.</li>\n<li>Window의 경우 cmd 기반 명령을 수행합니다.</li>\n</ul>\n<p>Dockerfile 내 RUN 명령어 사용법\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># software 설치 명령 실행 (예시의 경우 yum이 Container내부에 설치되어야 합니다.)</span></span><br><span class=\"line\">RUN yum -y install software  </span><br><span class=\"line\"><span class=\"comment\"># /usr/local/redis directory 생성</span></span><br><span class=\"line\">RUN mkdir -p /usr/<span class=\"built_in\">local</span>/redis </span><br><span class=\"line\"><span class=\"comment\"># execute.sh 파일 실행 </span></span><br><span class=\"line\">RUN [<span class=\"string\">\"execute.sh\"</span>, <span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p>명령어의 길이가 긴 경우 \\ 문자를 사용하여 append 가능합니다</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN yum -y install software \\</span><br><span class=\"line\">         <span class=\"built_in\">echo</span> <span class=\"string\">\"install software\"</span> \\</span><br><span class=\"line\">         mkdir -p /usr/<span class=\"built_in\">local</span>/redis</span><br></pre></td></tr></table></figure></p>\n<h2>ENV - Container 내부에서 사용할 환경 변수 추가</h2>\n<p>Container는 Host OS와 독립된 공간이기 때문에 Container 내부에서 사용 할 환경변수를 추가할 수 있습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV LOCAL_PORT 80</span><br><span class=\"line\">ENV REDIS_HOME /usr/<span class=\"built_in\">local</span>/bin/redis</span><br></pre></td></tr></table></figure></p>\n<h2>EXPOSE - Container의 Port 설정</h2>\n<ul>\n<li>Host OS - Container와 통신할 포트를 설정</li>\n<li>EXPOSE는 Host OS와 연결만 할 뿐 외부에 노출 되지는 않습니다.</li>\n<li>포트를 노출 하기 위해서는 docker run -p 또는 -P 옵션 사용해야 합니다.</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPOSE 80   <span class=\"comment\">#Container 내의 Web Server Port 노출</span></span><br><span class=\"line\">EXPOSE 6379 <span class=\"comment\">#Container 내의 Redis Server Port 노출</span></span><br><span class=\"line\"> </span><br><span class=\"line\">EXPOSE 80 6379 <span class=\"comment\">#포트 여러개 노출</span></span><br></pre></td></tr></table></figure></p>\n<h2>VOLUME - 외부 볼륨 설정</h2>\n<ul>\n<li>Container 내부의 Directory와 Host OS의 Directory를 동기화 시키는 설정</li>\n<li>log파일이나 설정파일은 보통 Container 내부에만 있는데 이를 Host OS에 동기화 하여 파일에 대한 접근이 가능하게 한다.</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Dockerfile volume 설정</span></span><br><span class=\"line\">VOLUME [<span class=\"string\">\"/data\"</span>, <span class=\"string\">\"/var/log\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># docker run 사용 시, volumn 설정</span></span><br><span class=\"line\"><span class=\"comment\"># -v 옵션을 사용하여 설정 -v &lt;host 디렉터리&gt;:&lt;컨테이너 디렉터리&gt;</span></span><br><span class=\"line\">docker run -v /host/os/data:/container/data app</span><br></pre></td></tr></table></figure></p>\n<h2>WORKDIR - Container의 Work Directory 설정</h2>\n<ul>\n<li>RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉터리</li>\n<li>중간에 Directory가 변경되는 경우 바꿀수 있다.</li>\n<li>리눅스의 cd 명령어와 비슷하다.</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR /usr/<span class=\"built_in\">local</span>/bin</span><br><span class=\"line\">ADD redis.conf /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\"> </span><br><span class=\"line\">WORKDIR /usr/<span class=\"built_in\">local</span></span><br><span class=\"line\">ADD redis.log /usr/<span class=\"built_in\">local</span>/redis.log</span><br><span class=\"line\"></span><br><span class=\"line\">WORKDIR var</span><br><span class=\"line\">WORKDIR lib</span><br><span class=\"line\">RUN touch file.sh <span class=\"comment\"># /var/lib/file.sh 생성</span></span><br></pre></td></tr></table></figure></p>\n<h1>참고</h1>\n<ul>\n<li>http://pyrasis.com/book/DockerForTheReallyImpatient</li>\n<li>https://docs.docker.com/engine/reference/builder</li>\n</ul>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (4) Docker-Compose 설치 및 사용방법","date":"2018-12-01T07:44:03.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-12-01-docker-4","typora-copy-images-to":"2018-12-01-docker-4","_content":"\n# Docker-Compose 이란?\n\n기존에는 Docker를 이용해서 1개의 이미지를 바탕으로 하나의 소프트웨어에 대한 컨테이너를 만들 수 있었습니다.\n하지만 목표는 Web Server도 설치하고, DB도 설치하고, IDE도 설치해서 한 세트로 배포를 해주고 싶은데... 지금까지 배운 방법으로는 Docker image를 내가 필요한 것만큼 다운받아서 Container를 생성해야 합니다.\n\n이때 필요한 개념이 Docker-Compose입니다.\nDocker-Compose는 사용자에게 한번에 여러가지 소프트웨어에 대한 이미지 정보를 담아 빌드 할 수 있습니다.\n사용자는 Docker-Compose로 만든 파일을 다운받아 이미지 내에 포함된 소프트웨어에 대한 Container를 한번에 만들 수 있습니다.\n\n\n\n# Docker-Compose 설치\n\n```sh\n#docker 공식 github에서 다운로드\nsudo curl -L \"https://github.com/docker/compose/releases/download/1.23.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n```\n\n다운로드 받은 docker-compose 파일을 실행 가능한 파일로 만듭니다.\n(보통의 리눅스 실행파일 path는 `/usr/local/bin`입니다. **OS별로 다를 수 있습니다.**)\n\n```sh\nchmod +x /usr/local/bin/docker-compose\n```\n\n\n\n# Docker-compose.yml\n\nDocker-compose.yml 파일은 생성하고자 하는 Container들의 image 정보들을 담고 있는 설정 파일입니다.\n여기에 설치하고자 하는 소프트웨어들의 빌드정보를 지정 할 수 있습니다.\n또한 Docker에서 사용한 설정정보를 기술 할 수 있어 사용자는 파일을 받아 별도의 옵션 없이 Container만 생성하면 됩니다.\n\n\n\n# Docker-Compose.yml에서 자주 사용하는 options\n\n## build\n\nbuild는 해당 이미지가 빌드 될 때 사용 할 Dockerfile을 지정할 수 있는 options입니다.\n\n```yml\nredis1:\n     image: redis:5.0-alpine\n     build:\n       context: ..\n       dockerfile: Dockerfile\n       args:\n         - buildno : 1\n         - username : carrey\n```\n\n- context : dockerfile의 위치를 지정합니다. Default는 현재위치 (./) 입니다.\n- dockerfile : dockerfile명을 지정합니다 Default는 Dockerfile 입니다.\n\n- args : Dockerfile내에서 사용할 Arguments를 설정합니다.\n\n\n\n## command\n\ncommand는 Dockerfile에서 CMD역할을 했던 명령을 `Override`합니다.\n(Dockerfile과 같이 사용하는 경우 Dockerfile의 CMD명령이 아닌 `Docker-compose의 command명령이 실행`)\n\n```yml\nredis1:\n  command : startup.sh -p 3000\n```\n\n\n\n## depends_on\n\nDocker-compose 내의 이미지가 2개 이상인 경우 실행 의존성을 줄 수 있습니다.\n예를들어 DB가 먼저 실행된 다음에 WAS가 실행되어야 하는 경우 Docker-Compose에서는 depend_on 설정에 따라 다른 이미지를 먼저 빌드 합니다.\n\n```yml\nservices:\n  web:\n    build: .\n    depends_on: //web 이미지에 대한 Container는 redis와 db가 생성되고 시작되기 전에는 빌드되지 않습니다.\n      - db       \n      - redis\n  redis:\n    image: redis\n  db:\n    image: postgres\n```\n\n\n\n## entrypoint\n\nContainer가 run 또는 start 시, entrypoint 로직을 실행 합니다.\nentrypoint와 Dockerfile이 함께 사용되는 경우, `Dockerfile의 ENTRYPOINT설정은 무시됩니다.`\n\n```yml\nredis1 : \n\timage: redis:5.0-alpine\n\tentrypoint: /code/entrypoint.sh\n```\n\n\n\n## env_file\n\nEnv 파일을 Container 내부에 import 하는 경우에 사용합니다.\n\n```yml\nubuntu:\n\timage: ubuntu\n    env_file : ../env/environments.env\n```\n\n\n\n## environment\n\nContainer 내부에서 사용할 환경 변수를 등록합니다.\n\n```yml\nredis1:\n    environment:\n      - REQUIREPASS=1234\n      - CLIENTHOST=192.168.130.93\n      - CLIENTPORT=6380\n      - MASTERHOST=192.168.130.93\n      - MASTERPORT=6379\n```\n\n\n\n## expose\n\nContainer내의 내부 포트만 설정 (외부 노출은되지 않습니다.) \nlink된 Container끼리는 expose에 설정된 포트로 통신이 가능\n\n```yml\nweb:\n\texpose:\n\t  - \"3000\"\n\t  - \"8000\"\n```\n\n\n\n## ports\n\nHost OS 포트와 Container 내부포트 매핑 (포트포워딩)\nHost OS 포트를 사용할 수 있으므로 외부접속이 가능\n\n```yml\ntomcat:\n      ports:\n       - \"80:8080\"  # <Host OS포트> : <컨테이너 내부포트>\n     \n#Short Syntax --> 권장하는 방식\nubuntu:\n      ports:\n       - \"3000\"        #이 구문은 \"3000:3000\" 과 동일\n       - \"3000-3005\"   #이 구문은 \"3000-3005:3000-3005\"와 동일\n       - \"8000:8000\"\n       - \"9090-9091:8080-8081\"\n       - \"49100:22\"\n       - \"127.0.0.1:8001:8001\"\n       - \"127.0.0.1:5000-5010:5000-5010\"\n       - \"6060:6060/udp\"\n \n#Long Syntax --> 권장하지 않는 방식\ntomcat2:\n      ports:\n       - target : 8080 #Container 내부포트\n       - published : 80 # 외부 OS 포트\n       - protocol : tcp # tcp 또는 udp\n       - mode : host #host: 각각의 Container 노드와 1:1로 매핑 \n```\n\n>포트 매핑 시 주의 할 점\n>Host : Container 형식으로 포트를 매핑하면 YAML이 xx:yy 형식은 구문 분석시에 default를 60으로 주기 때문에 60번 이하 포트에 대해서 잘못된 결과가 초래될 수 있음. \n>(8000 : 22 와 같이 숫자만 적는 경우 문제가 발생)\n>따라서, `포트 매핑은 항상 문자열로 적어야 합니다.`\n>( \"8000 : 22\"와 같이 문자열로 선언해야 안전합니다. ) ==> 60번 이하 포트를 쓰지말라는 소리가 아님.\n\n\n\n## image\n\n어떤 image를 바탕으로 생성할 것인지 지정합니다.\n\n```yml\nredis: \n      image: redis\nubuntu: \n      image: ubuntu:14.04\n```\n\n\n\n##  link\n\n* 다른 Container와 연결하기 위해 설정합니다.\n* 외부 Port노출이 안되어도 Expose명령으로 노출된 Port로 연결\n* network_mode가 `host인 경우 사용할 수 없습니다.` (host인 경우 Host OS의 port를 직접 사용하기 때문)\n* 서비스 이름:Alias 형태로 선언하거나 서비스 이름만 지정합니다.\n\n```yml\nweb:\n  link:\n    - db:mycontainerdb-alias\n    - redis\ndb: \n  image: mysql\nredis: \n  image: redis\n```\n\n\n\n## network_mode\n\nDocker network policy 설정 (다음 장에 상세 설명하겠습니다.)\n\n```yml\nnetwork_mode: \"bridge\"\nnetwork_mode: \"host\"\nnetwork_mode: \"none\"\nnetwork_mode: \"service:[service name]\"\nnetwork_mode: \"container:[container name/id]\"\n```\n\n> Docker Swarm을 사용하는 경우 network_mode 옵션은 무시됩니다.\n\n\n\n## volumes\n\n* Host OS의 디렉터리 경로를 Container 내부의 디렉터리에 Mount 합니다. (쉽게 말해서 디렉토리가 연동됩니다.)\n* docker run -v 또는 --volume과 같습니다.\n* Dockerfile의 VOLUME[] 과 같습니다.\n* docker-compose.yml의 volumes에는 상대경로를 지정할 수 있습니다.\n* 호스트:컨테이너:권한 순으로 작성하여 읽기/쓰기 권한 설정을 할 수 있습니다. (Default는 rw)\n  * ro : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수만 있음. Container에서 파일에 대한 수정이 불가능합니다.\n  * rw : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수 있고, Container에서 파일 수정이 가능하고, Host OS 디렉토리에 반영이 됩니다.\n\n```yml\nredis: \n    volumes:\n     - /usr/local/redis/data:/data # <Host OS 디렉터리 경로> : <Container 내부 data 경로>\n \n    volumes:\n     - /usr/local/redis/data:/data:ro #ReadOnly \n     - /usr/local/redis/data:/data:rw #ReadWrite\n```\n\n\n\n## restart\n\nContainer 재 시작에 대한 policy를 설정합니다.\n\n* no : 문제가 발생하여 Container가 중지된 경우 재시작 하지 않음 (default)\n* always : 어떠한 문제로 Container가 중지되는 경우 무조건 재시작 \n* on-failure : Container의 exit code 0 이 아닌 경우 재시작\n* unless-stopped : 명시적으로 중지되거나, Docker 자체가 중지되는 경우 재시작\n\n```yml\nrestart: no            \nrestart: always          \nrestart: on-failure      \nrestart: unless-stopped  \n```\n\n\n\n# 참고\n\n* https://docs.docker.com/compose/compose-file/\n* http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/\n* https://www.joinc.co.kr/w/man/12/docker/Guide/DataWithContainer","source":"_posts/2018-12-01-docker-4.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (4) Docker-Compose 설치 및 사용방법\ndate: 2018-12-01 16:44:03\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-12-01-docker-4\ntypora-copy-images-to: 2018-12-01-docker-4\n---\n\n# Docker-Compose 이란?\n\n기존에는 Docker를 이용해서 1개의 이미지를 바탕으로 하나의 소프트웨어에 대한 컨테이너를 만들 수 있었습니다.\n하지만 목표는 Web Server도 설치하고, DB도 설치하고, IDE도 설치해서 한 세트로 배포를 해주고 싶은데... 지금까지 배운 방법으로는 Docker image를 내가 필요한 것만큼 다운받아서 Container를 생성해야 합니다.\n\n이때 필요한 개념이 Docker-Compose입니다.\nDocker-Compose는 사용자에게 한번에 여러가지 소프트웨어에 대한 이미지 정보를 담아 빌드 할 수 있습니다.\n사용자는 Docker-Compose로 만든 파일을 다운받아 이미지 내에 포함된 소프트웨어에 대한 Container를 한번에 만들 수 있습니다.\n\n\n\n# Docker-Compose 설치\n\n```sh\n#docker 공식 github에서 다운로드\nsudo curl -L \"https://github.com/docker/compose/releases/download/1.23.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n```\n\n다운로드 받은 docker-compose 파일을 실행 가능한 파일로 만듭니다.\n(보통의 리눅스 실행파일 path는 `/usr/local/bin`입니다. **OS별로 다를 수 있습니다.**)\n\n```sh\nchmod +x /usr/local/bin/docker-compose\n```\n\n\n\n# Docker-compose.yml\n\nDocker-compose.yml 파일은 생성하고자 하는 Container들의 image 정보들을 담고 있는 설정 파일입니다.\n여기에 설치하고자 하는 소프트웨어들의 빌드정보를 지정 할 수 있습니다.\n또한 Docker에서 사용한 설정정보를 기술 할 수 있어 사용자는 파일을 받아 별도의 옵션 없이 Container만 생성하면 됩니다.\n\n\n\n# Docker-Compose.yml에서 자주 사용하는 options\n\n## build\n\nbuild는 해당 이미지가 빌드 될 때 사용 할 Dockerfile을 지정할 수 있는 options입니다.\n\n```yml\nredis1:\n     image: redis:5.0-alpine\n     build:\n       context: ..\n       dockerfile: Dockerfile\n       args:\n         - buildno : 1\n         - username : carrey\n```\n\n- context : dockerfile의 위치를 지정합니다. Default는 현재위치 (./) 입니다.\n- dockerfile : dockerfile명을 지정합니다 Default는 Dockerfile 입니다.\n\n- args : Dockerfile내에서 사용할 Arguments를 설정합니다.\n\n\n\n## command\n\ncommand는 Dockerfile에서 CMD역할을 했던 명령을 `Override`합니다.\n(Dockerfile과 같이 사용하는 경우 Dockerfile의 CMD명령이 아닌 `Docker-compose의 command명령이 실행`)\n\n```yml\nredis1:\n  command : startup.sh -p 3000\n```\n\n\n\n## depends_on\n\nDocker-compose 내의 이미지가 2개 이상인 경우 실행 의존성을 줄 수 있습니다.\n예를들어 DB가 먼저 실행된 다음에 WAS가 실행되어야 하는 경우 Docker-Compose에서는 depend_on 설정에 따라 다른 이미지를 먼저 빌드 합니다.\n\n```yml\nservices:\n  web:\n    build: .\n    depends_on: //web 이미지에 대한 Container는 redis와 db가 생성되고 시작되기 전에는 빌드되지 않습니다.\n      - db       \n      - redis\n  redis:\n    image: redis\n  db:\n    image: postgres\n```\n\n\n\n## entrypoint\n\nContainer가 run 또는 start 시, entrypoint 로직을 실행 합니다.\nentrypoint와 Dockerfile이 함께 사용되는 경우, `Dockerfile의 ENTRYPOINT설정은 무시됩니다.`\n\n```yml\nredis1 : \n\timage: redis:5.0-alpine\n\tentrypoint: /code/entrypoint.sh\n```\n\n\n\n## env_file\n\nEnv 파일을 Container 내부에 import 하는 경우에 사용합니다.\n\n```yml\nubuntu:\n\timage: ubuntu\n    env_file : ../env/environments.env\n```\n\n\n\n## environment\n\nContainer 내부에서 사용할 환경 변수를 등록합니다.\n\n```yml\nredis1:\n    environment:\n      - REQUIREPASS=1234\n      - CLIENTHOST=192.168.130.93\n      - CLIENTPORT=6380\n      - MASTERHOST=192.168.130.93\n      - MASTERPORT=6379\n```\n\n\n\n## expose\n\nContainer내의 내부 포트만 설정 (외부 노출은되지 않습니다.) \nlink된 Container끼리는 expose에 설정된 포트로 통신이 가능\n\n```yml\nweb:\n\texpose:\n\t  - \"3000\"\n\t  - \"8000\"\n```\n\n\n\n## ports\n\nHost OS 포트와 Container 내부포트 매핑 (포트포워딩)\nHost OS 포트를 사용할 수 있으므로 외부접속이 가능\n\n```yml\ntomcat:\n      ports:\n       - \"80:8080\"  # <Host OS포트> : <컨테이너 내부포트>\n     \n#Short Syntax --> 권장하는 방식\nubuntu:\n      ports:\n       - \"3000\"        #이 구문은 \"3000:3000\" 과 동일\n       - \"3000-3005\"   #이 구문은 \"3000-3005:3000-3005\"와 동일\n       - \"8000:8000\"\n       - \"9090-9091:8080-8081\"\n       - \"49100:22\"\n       - \"127.0.0.1:8001:8001\"\n       - \"127.0.0.1:5000-5010:5000-5010\"\n       - \"6060:6060/udp\"\n \n#Long Syntax --> 권장하지 않는 방식\ntomcat2:\n      ports:\n       - target : 8080 #Container 내부포트\n       - published : 80 # 외부 OS 포트\n       - protocol : tcp # tcp 또는 udp\n       - mode : host #host: 각각의 Container 노드와 1:1로 매핑 \n```\n\n>포트 매핑 시 주의 할 점\n>Host : Container 형식으로 포트를 매핑하면 YAML이 xx:yy 형식은 구문 분석시에 default를 60으로 주기 때문에 60번 이하 포트에 대해서 잘못된 결과가 초래될 수 있음. \n>(8000 : 22 와 같이 숫자만 적는 경우 문제가 발생)\n>따라서, `포트 매핑은 항상 문자열로 적어야 합니다.`\n>( \"8000 : 22\"와 같이 문자열로 선언해야 안전합니다. ) ==> 60번 이하 포트를 쓰지말라는 소리가 아님.\n\n\n\n## image\n\n어떤 image를 바탕으로 생성할 것인지 지정합니다.\n\n```yml\nredis: \n      image: redis\nubuntu: \n      image: ubuntu:14.04\n```\n\n\n\n##  link\n\n* 다른 Container와 연결하기 위해 설정합니다.\n* 외부 Port노출이 안되어도 Expose명령으로 노출된 Port로 연결\n* network_mode가 `host인 경우 사용할 수 없습니다.` (host인 경우 Host OS의 port를 직접 사용하기 때문)\n* 서비스 이름:Alias 형태로 선언하거나 서비스 이름만 지정합니다.\n\n```yml\nweb:\n  link:\n    - db:mycontainerdb-alias\n    - redis\ndb: \n  image: mysql\nredis: \n  image: redis\n```\n\n\n\n## network_mode\n\nDocker network policy 설정 (다음 장에 상세 설명하겠습니다.)\n\n```yml\nnetwork_mode: \"bridge\"\nnetwork_mode: \"host\"\nnetwork_mode: \"none\"\nnetwork_mode: \"service:[service name]\"\nnetwork_mode: \"container:[container name/id]\"\n```\n\n> Docker Swarm을 사용하는 경우 network_mode 옵션은 무시됩니다.\n\n\n\n## volumes\n\n* Host OS의 디렉터리 경로를 Container 내부의 디렉터리에 Mount 합니다. (쉽게 말해서 디렉토리가 연동됩니다.)\n* docker run -v 또는 --volume과 같습니다.\n* Dockerfile의 VOLUME[] 과 같습니다.\n* docker-compose.yml의 volumes에는 상대경로를 지정할 수 있습니다.\n* 호스트:컨테이너:권한 순으로 작성하여 읽기/쓰기 권한 설정을 할 수 있습니다. (Default는 rw)\n  * ro : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수만 있음. Container에서 파일에 대한 수정이 불가능합니다.\n  * rw : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수 있고, Container에서 파일 수정이 가능하고, Host OS 디렉토리에 반영이 됩니다.\n\n```yml\nredis: \n    volumes:\n     - /usr/local/redis/data:/data # <Host OS 디렉터리 경로> : <Container 내부 data 경로>\n \n    volumes:\n     - /usr/local/redis/data:/data:ro #ReadOnly \n     - /usr/local/redis/data:/data:rw #ReadWrite\n```\n\n\n\n## restart\n\nContainer 재 시작에 대한 policy를 설정합니다.\n\n* no : 문제가 발생하여 Container가 중지된 경우 재시작 하지 않음 (default)\n* always : 어떠한 문제로 Container가 중지되는 경우 무조건 재시작 \n* on-failure : Container의 exit code 0 이 아닌 경우 재시작\n* unless-stopped : 명시적으로 중지되거나, Docker 자체가 중지되는 경우 재시작\n\n```yml\nrestart: no            \nrestart: always          \nrestart: on-failure      \nrestart: unless-stopped  \n```\n\n\n\n# 참고\n\n* https://docs.docker.com/compose/compose-file/\n* http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/\n* https://www.joinc.co.kr/w/man/12/docker/Guide/DataWithContainer","slug":"2018-12-01-docker-4","published":1,"updated":"2018-12-08T08:32:55.264Z","comments":1,"photos":[],"link":"","_id":"cjrgbv3rt003dcr1td0wqolx5","content":"<h1 id=\"docker-compose-이란\">Docker-Compose 이란?</h1>\n<p>기존에는 Docker를 이용해서 1개의 이미지를 바탕으로 하나의 소프트웨어에 대한 컨테이너를 만들 수 있었습니다.\n하지만 목표는 Web Server도 설치하고, DB도 설치하고, IDE도 설치해서 한 세트로 배포를 해주고 싶은데... 지금까지 배운 방법으로는 Docker image를 내가 필요한 것만큼 다운받아서 Container를 생성해야 합니다.</p>\n<p>이때 필요한 개념이 Docker-Compose입니다.\nDocker-Compose는 사용자에게 한번에 여러가지 소프트웨어에 대한 이미지 정보를 담아 빌드 할 수 있습니다.\n사용자는 Docker-Compose로 만든 파일을 다운받아 이미지 내에 포함된 소프트웨어에 대한 Container를 한번에 만들 수 있습니다.</p>\n<h1 id=\"docker-compose-설치\">Docker-Compose 설치</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#docker 공식 github에서 다운로드</span></span><br><span class=\"line\">sudo curl -L <span class=\"string\">\"https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class=\"variable\">$(uname -s)</span>-<span class=\"variable\">$(uname -m)</span>\"</span> -o /usr/<span class=\"built_in\">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></p>\n<p>다운로드 받은 docker-compose 파일을 실행 가능한 파일로 만듭니다.\n(보통의 리눅스 실행파일 path는 <code>/usr/local/bin</code>입니다. <strong>OS별로 다를 수 있습니다.</strong>)</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x /usr/<span class=\"built_in\">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"docker-composeyml\">Docker-compose.yml</h1>\n<p>Docker-compose.yml 파일은 생성하고자 하는 Container들의 image 정보들을 담고 있는 설정 파일입니다.\n여기에 설치하고자 하는 소프트웨어들의 빌드정보를 지정 할 수 있습니다.\n또한 Docker에서 사용한 설정정보를 기술 할 수 있어 사용자는 파일을 받아 별도의 옵션 없이 Container만 생성하면 됩니다.</p>\n<h1 id=\"docker-composeyml에서-자주-사용하는-options\">Docker-Compose.yml에서 자주 사용하는 options</h1>\n<h2 id=\"build\">build</h2>\n<p>build는 해당 이미지가 빌드 될 때 사용 할 Dockerfile을 지정할 수 있는 options입니다.</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">redis1:</span></span><br><span class=\"line\"><span class=\"attr\">     image:</span> <span class=\"attr\">redis:5.0-alpine</span></span><br><span class=\"line\"><span class=\"attr\">     build:</span></span><br><span class=\"line\"><span class=\"attr\">       context:</span> <span class=\"string\">..</span></span><br><span class=\"line\"><span class=\"attr\">       dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\"><span class=\"attr\">       args:</span></span><br><span class=\"line\"><span class=\"bullet\">         -</span> <span class=\"string\">buildno</span> <span class=\"string\">:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"bullet\">         -</span> <span class=\"string\">username</span> <span class=\"string\">:</span> <span class=\"string\">carrey</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>\n<p>context : dockerfile의 위치를 지정합니다. Default는 현재위치 (./) 입니다.</p>\n</li>\n<li>\n<p>dockerfile : dockerfile명을 지정합니다 Default는 Dockerfile 입니다.</p>\n</li>\n<li>\n<p>args : Dockerfile내에서 사용할 Arguments를 설정합니다.</p>\n</li>\n</ul>\n<h2 id=\"command\">command</h2>\n<p>command는 Dockerfile에서 CMD역할을 했던 명령을 <code>Override</code>합니다.\n(Dockerfile과 같이 사용하는 경우 Dockerfile의 CMD명령이 아닌 <code>Docker-compose의 command명령이 실행</code>)</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">redis1:</span></span><br><span class=\"line\">  <span class=\"string\">command</span> <span class=\"string\">:</span> <span class=\"string\">startup.sh</span> <span class=\"bullet\">-p</span> <span class=\"number\">3000</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"depends_on\">depends_on</h2>\n<p>Docker-compose 내의 이미지가 2개 이상인 경우 실행 의존성을 줄 수 있습니다.\n예를들어 DB가 먼저 실행된 다음에 WAS가 실행되어야 하는 경우 Docker-Compose에서는 depend_on 설정에 따라 다른 이미지를 먼저 빌드 합니다.</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"><span class=\"attr\">  web:</span></span><br><span class=\"line\"><span class=\"attr\">    build:</span> <span class=\"string\">.</span></span><br><span class=\"line\"><span class=\"attr\">    depends_on:</span> <span class=\"string\">//web</span> <span class=\"string\">이미지에</span> <span class=\"string\">대한</span> <span class=\"string\">Container는</span> <span class=\"string\">redis와</span> <span class=\"string\">db가</span> <span class=\"string\">생성되고</span> <span class=\"string\">시작되기</span> <span class=\"string\">전에는</span> <span class=\"string\">빌드되지</span> <span class=\"string\">않습니다.</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">db</span>       </span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">redis</span></span><br><span class=\"line\"><span class=\"attr\">  redis:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">redis</span></span><br><span class=\"line\"><span class=\"attr\">  db:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">postgres</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"entrypoint\">entrypoint</h2>\n<p>Container가 run 또는 start 시, entrypoint 로직을 실행 합니다.\nentrypoint와 Dockerfile이 함께 사용되는 경우, <code>Dockerfile의 ENTRYPOINT설정은 무시됩니다.</code></p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">redis1</span> <span class=\"string\">:</span> </span><br><span class=\"line\">\t<span class=\"attr\">image:</span> <span class=\"attr\">redis:5.0-alpine</span></span><br><span class=\"line\">\t<span class=\"attr\">entrypoint:</span> <span class=\"string\">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"env_file\">env_file</h2>\n<p>Env 파일을 Container 내부에 import 하는 경우에 사용합니다.</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">ubuntu:</span></span><br><span class=\"line\">\t<span class=\"attr\">image:</span> <span class=\"string\">ubuntu</span></span><br><span class=\"line\">    <span class=\"string\">env_file</span> <span class=\"string\">:</span> <span class=\"string\">../env/environments.env</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"environment\">environment</h2>\n<p>Container 내부에서 사용할 환경 변수를 등록합니다.</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">redis1:</span></span><br><span class=\"line\"><span class=\"attr\">    environment:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">REQUIREPASS=1234</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTHOST=192.168.130.93</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTPORT=6380</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERHOST=192.168.130.93</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERPORT=6379</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"expose\">expose</h2>\n<p>Container내의 내부 포트만 설정 (외부 노출은되지 않습니다.)\nlink된 Container끼리는 expose에 설정된 포트로 통신이 가능</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">web:</span></span><br><span class=\"line\">\t<span class=\"attr\">expose:</span></span><br><span class=\"line\">\t  <span class=\"bullet\">-</span> <span class=\"string\">\"3000\"</span></span><br><span class=\"line\">\t  <span class=\"bullet\">-</span> <span class=\"string\">\"8000\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ports\">ports</h2>\n<p>Host OS 포트와 Container 내부포트 매핑 (포트포워딩)\nHost OS 포트를 사용할 수 있으므로 외부접속이 가능</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">tomcat:</span></span><br><span class=\"line\"><span class=\"attr\">      ports:</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"80:8080\"</span>  <span class=\"comment\"># &lt;Host OS포트&gt; : &lt;컨테이너 내부포트&gt;</span></span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">#Short Syntax --&gt; 권장하는 방식</span></span><br><span class=\"line\"><span class=\"attr\">ubuntu:</span></span><br><span class=\"line\"><span class=\"attr\">      ports:</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"3000\"</span>        <span class=\"comment\">#이 구문은 \"3000:3000\" 과 동일</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"3000-3005\"</span>   <span class=\"comment\">#이 구문은 \"3000-3005:3000-3005\"와 동일</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"8000:8000\"</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"9090-9091:8080-8081\"</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"49100:22\"</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"127.0.0.1:8001:8001\"</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"127.0.0.1:5000-5010:5000-5010\"</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"6060:6060/udp\"</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#Long Syntax --&gt; 권장하지 않는 방식</span></span><br><span class=\"line\"><span class=\"attr\">tomcat2:</span></span><br><span class=\"line\"><span class=\"attr\">      ports:</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">target</span> <span class=\"string\">:</span> <span class=\"number\">8080</span> <span class=\"comment\">#Container 내부포트</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">published</span> <span class=\"string\">:</span> <span class=\"number\">80</span> <span class=\"comment\"># 외부 OS 포트</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">protocol</span> <span class=\"string\">:</span> <span class=\"string\">tcp</span> <span class=\"comment\"># tcp 또는 udp</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">mode</span> <span class=\"string\">:</span> <span class=\"string\">host</span> <span class=\"comment\">#host: 각각의 Container 노드와 1:1로 매핑</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>포트 매핑 시 주의 할 점\nHost : Container 형식으로 포트를 매핑하면 YAML이 xx:yy 형식은 구문 분석시에 default를 60으로 주기 때문에 60번 이하 포트에 대해서 잘못된 결과가 초래될 수 있음.\n(8000 : 22 와 같이 숫자만 적는 경우 문제가 발생)\n따라서, <code>포트 매핑은 항상 문자열로 적어야 합니다.</code>\n( &quot;8000 : 22&quot;와 같이 문자열로 선언해야 안전합니다. ) ==&gt; 60번 이하 포트를 쓰지말라는 소리가 아님.</p>\n</blockquote>\n<h2 id=\"image\">image</h2>\n<p>어떤 image를 바탕으로 생성할 것인지 지정합니다.</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">redis:</span> </span><br><span class=\"line\"><span class=\"attr\">      image:</span> <span class=\"string\">redis</span></span><br><span class=\"line\"><span class=\"attr\">ubuntu:</span> </span><br><span class=\"line\"><span class=\"attr\">      image:</span> <span class=\"attr\">ubuntu:14.04</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"link\">link</h2>\n<ul>\n<li>다른 Container와 연결하기 위해 설정합니다.</li>\n<li>외부 Port노출이 안되어도 Expose명령으로 노출된 Port로 연결</li>\n<li>network_mode가 <code>host인 경우 사용할 수 없습니다.</code> (host인 경우 Host OS의 port를 직접 사용하기 때문)</li>\n<li>서비스 이름:Alias 형태로 선언하거나 서비스 이름만 지정합니다.</li>\n</ul>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">web:</span></span><br><span class=\"line\"><span class=\"attr\">  link:</span></span><br><span class=\"line\"><span class=\"attr\">    - db:</span><span class=\"string\">mycontainerdb-alias</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">redis</span></span><br><span class=\"line\"><span class=\"attr\">db:</span> </span><br><span class=\"line\"><span class=\"attr\">  image:</span> <span class=\"string\">mysql</span></span><br><span class=\"line\"><span class=\"attr\">redis:</span> </span><br><span class=\"line\"><span class=\"attr\">  image:</span> <span class=\"string\">redis</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"network_mode\">network_mode</h2>\n<p>Docker network policy 설정 (다음 장에 상세 설명하겠습니다.)</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">network_mode:</span> <span class=\"string\">\"bridge\"</span></span><br><span class=\"line\"><span class=\"attr\">network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\"><span class=\"attr\">network_mode:</span> <span class=\"string\">\"none\"</span></span><br><span class=\"line\"><span class=\"attr\">network_mode:</span> <span class=\"string\">\"service:[service name]\"</span></span><br><span class=\"line\"><span class=\"attr\">network_mode:</span> <span class=\"string\">\"container:[container name/id]\"</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Docker Swarm을 사용하는 경우 network_mode 옵션은 무시됩니다.</p>\n</blockquote>\n<h2 id=\"volumes\">volumes</h2>\n<ul>\n<li>Host OS의 디렉터리 경로를 Container 내부의 디렉터리에 Mount 합니다. (쉽게 말해서 디렉토리가 연동됩니다.)</li>\n<li>docker run -v 또는 --volume과 같습니다.</li>\n<li>Dockerfile의 VOLUME[] 과 같습니다.</li>\n<li>docker-compose.yml의 volumes에는 상대경로를 지정할 수 있습니다.</li>\n<li>호스트:컨테이너:권한 순으로 작성하여 읽기/쓰기 권한 설정을 할 수 있습니다. (Default는 rw)\n<ul>\n<li>ro : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수만 있음. Container에서 파일에 대한 수정이 불가능합니다.</li>\n<li>rw : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수 있고, Container에서 파일 수정이 가능하고, Host OS 디렉토리에 반영이 됩니다.</li>\n</ul>\n</li>\n</ul>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">redis:</span> </span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">     -</span> <span class=\"string\">/usr/local/redis/data:/data</span> <span class=\"comment\"># &lt;Host OS 디렉터리 경로&gt; : &lt;Container 내부 data 경로&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">     -</span> <span class=\"string\">/usr/local/redis/data:/data:ro</span> <span class=\"comment\">#ReadOnly </span></span><br><span class=\"line\"><span class=\"bullet\">     -</span> <span class=\"string\">/usr/local/redis/data:/data:rw</span> <span class=\"comment\">#ReadWrite</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"restart\">restart</h2>\n<p>Container 재 시작에 대한 policy를 설정합니다.</p>\n<ul>\n<li>no : 문제가 발생하여 Container가 중지된 경우 재시작 하지 않음 (default)</li>\n<li>always : 어떠한 문제로 Container가 중지되는 경우 무조건 재시작</li>\n<li>on-failure : Container의 exit code 0 이 아닌 경우 재시작</li>\n<li>unless-stopped : 명시적으로 중지되거나, Docker 자체가 중지되는 경우 재시작</li>\n</ul>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">restart:</span> <span class=\"literal\">no</span>            </span><br><span class=\"line\"><span class=\"attr\">restart:</span> <span class=\"string\">always</span>          </span><br><span class=\"line\"><span class=\"attr\">restart:</span> <span class=\"string\">on-failure</span>      </span><br><span class=\"line\"><span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>https://docs.docker.com/compose/compose-file/</li>\n<li>http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/</li>\n<li>https://www.joinc.co.kr/w/man/12/docker/Guide/DataWithContainer</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>Docker-Compose 이란?</h1>\n<p>기존에는 Docker를 이용해서 1개의 이미지를 바탕으로 하나의 소프트웨어에 대한 컨테이너를 만들 수 있었습니다.\n하지만 목표는 Web Server도 설치하고, DB도 설치하고, IDE도 설치해서 한 세트로 배포를 해주고 싶은데... 지금까지 배운 방법으로는 Docker image를 내가 필요한 것만큼 다운받아서 Container를 생성해야 합니다.</p>\n<p>이때 필요한 개념이 Docker-Compose입니다.\nDocker-Compose는 사용자에게 한번에 여러가지 소프트웨어에 대한 이미지 정보를 담아 빌드 할 수 있습니다.\n사용자는 Docker-Compose로 만든 파일을 다운받아 이미지 내에 포함된 소프트웨어에 대한 Container를 한번에 만들 수 있습니다.</p>\n<h1>Docker-Compose 설치</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#docker 공식 github에서 다운로드</span></span><br><span class=\"line\">sudo curl -L <span class=\"string\">\"https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class=\"variable\">$(uname -s)</span>-<span class=\"variable\">$(uname -m)</span>\"</span> -o /usr/<span class=\"built_in\">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></p>\n<p>다운로드 받은 docker-compose 파일을 실행 가능한 파일로 만듭니다.\n(보통의 리눅스 실행파일 path는 <code>/usr/local/bin</code>입니다. <strong>OS별로 다를 수 있습니다.</strong>)</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x /usr/<span class=\"built_in\">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></p>\n<h1>Docker-compose.yml</h1>\n<p>Docker-compose.yml 파일은 생성하고자 하는 Container들의 image 정보들을 담고 있는 설정 파일입니다.\n여기에 설치하고자 하는 소프트웨어들의 빌드정보를 지정 할 수 있습니다.\n또한 Docker에서 사용한 설정정보를 기술 할 수 있어 사용자는 파일을 받아 별도의 옵션 없이 Container만 생성하면 됩니다.</p>\n<h1>Docker-Compose.yml에서 자주 사용하는 options</h1>\n<h2>build</h2>\n<p>build는 해당 이미지가 빌드 될 때 사용 할 Dockerfile을 지정할 수 있는 options입니다.</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">redis1:</span></span><br><span class=\"line\"><span class=\"attr\">     image:</span> <span class=\"attr\">redis:5.0-alpine</span></span><br><span class=\"line\"><span class=\"attr\">     build:</span></span><br><span class=\"line\"><span class=\"attr\">       context:</span> <span class=\"string\">..</span></span><br><span class=\"line\"><span class=\"attr\">       dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\"><span class=\"attr\">       args:</span></span><br><span class=\"line\"><span class=\"bullet\">         -</span> <span class=\"string\">buildno</span> <span class=\"string\">:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"bullet\">         -</span> <span class=\"string\">username</span> <span class=\"string\">:</span> <span class=\"string\">carrey</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>\n<p>context : dockerfile의 위치를 지정합니다. Default는 현재위치 (./) 입니다.</p>\n</li>\n<li>\n<p>dockerfile : dockerfile명을 지정합니다 Default는 Dockerfile 입니다.</p>\n</li>\n<li>\n<p>args : Dockerfile내에서 사용할 Arguments를 설정합니다.</p>\n</li>\n</ul>\n<h2>command</h2>\n<p>command는 Dockerfile에서 CMD역할을 했던 명령을 <code>Override</code>합니다.\n(Dockerfile과 같이 사용하는 경우 Dockerfile의 CMD명령이 아닌 <code>Docker-compose의 command명령이 실행</code>)</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">redis1:</span></span><br><span class=\"line\">  <span class=\"string\">command</span> <span class=\"string\">:</span> <span class=\"string\">startup.sh</span> <span class=\"bullet\">-p</span> <span class=\"number\">3000</span></span><br></pre></td></tr></table></figure></p>\n<h2>depends_on</h2>\n<p>Docker-compose 내의 이미지가 2개 이상인 경우 실행 의존성을 줄 수 있습니다.\n예를들어 DB가 먼저 실행된 다음에 WAS가 실행되어야 하는 경우 Docker-Compose에서는 depend_on 설정에 따라 다른 이미지를 먼저 빌드 합니다.</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"><span class=\"attr\">  web:</span></span><br><span class=\"line\"><span class=\"attr\">    build:</span> <span class=\"string\">.</span></span><br><span class=\"line\"><span class=\"attr\">    depends_on:</span> <span class=\"string\">//web</span> <span class=\"string\">이미지에</span> <span class=\"string\">대한</span> <span class=\"string\">Container는</span> <span class=\"string\">redis와</span> <span class=\"string\">db가</span> <span class=\"string\">생성되고</span> <span class=\"string\">시작되기</span> <span class=\"string\">전에는</span> <span class=\"string\">빌드되지</span> <span class=\"string\">않습니다.</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">db</span>       </span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">redis</span></span><br><span class=\"line\"><span class=\"attr\">  redis:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">redis</span></span><br><span class=\"line\"><span class=\"attr\">  db:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">postgres</span></span><br></pre></td></tr></table></figure></p>\n<h2>entrypoint</h2>\n<p>Container가 run 또는 start 시, entrypoint 로직을 실행 합니다.\nentrypoint와 Dockerfile이 함께 사용되는 경우, <code>Dockerfile의 ENTRYPOINT설정은 무시됩니다.</code></p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">redis1</span> <span class=\"string\">:</span> </span><br><span class=\"line\">\t<span class=\"attr\">image:</span> <span class=\"attr\">redis:5.0-alpine</span></span><br><span class=\"line\">\t<span class=\"attr\">entrypoint:</span> <span class=\"string\">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure></p>\n<h2>env_file</h2>\n<p>Env 파일을 Container 내부에 import 하는 경우에 사용합니다.</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">ubuntu:</span></span><br><span class=\"line\">\t<span class=\"attr\">image:</span> <span class=\"string\">ubuntu</span></span><br><span class=\"line\">    <span class=\"string\">env_file</span> <span class=\"string\">:</span> <span class=\"string\">../env/environments.env</span></span><br></pre></td></tr></table></figure></p>\n<h2>environment</h2>\n<p>Container 내부에서 사용할 환경 변수를 등록합니다.</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">redis1:</span></span><br><span class=\"line\"><span class=\"attr\">    environment:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">REQUIREPASS=1234</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTHOST=192.168.130.93</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTPORT=6380</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERHOST=192.168.130.93</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERPORT=6379</span></span><br></pre></td></tr></table></figure></p>\n<h2>expose</h2>\n<p>Container내의 내부 포트만 설정 (외부 노출은되지 않습니다.)\nlink된 Container끼리는 expose에 설정된 포트로 통신이 가능</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">web:</span></span><br><span class=\"line\">\t<span class=\"attr\">expose:</span></span><br><span class=\"line\">\t  <span class=\"bullet\">-</span> <span class=\"string\">\"3000\"</span></span><br><span class=\"line\">\t  <span class=\"bullet\">-</span> <span class=\"string\">\"8000\"</span></span><br></pre></td></tr></table></figure></p>\n<h2>ports</h2>\n<p>Host OS 포트와 Container 내부포트 매핑 (포트포워딩)\nHost OS 포트를 사용할 수 있으므로 외부접속이 가능</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">tomcat:</span></span><br><span class=\"line\"><span class=\"attr\">      ports:</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"80:8080\"</span>  <span class=\"comment\"># &lt;Host OS포트&gt; : &lt;컨테이너 내부포트&gt;</span></span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">#Short Syntax --&gt; 권장하는 방식</span></span><br><span class=\"line\"><span class=\"attr\">ubuntu:</span></span><br><span class=\"line\"><span class=\"attr\">      ports:</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"3000\"</span>        <span class=\"comment\">#이 구문은 \"3000:3000\" 과 동일</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"3000-3005\"</span>   <span class=\"comment\">#이 구문은 \"3000-3005:3000-3005\"와 동일</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"8000:8000\"</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"9090-9091:8080-8081\"</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"49100:22\"</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"127.0.0.1:8001:8001\"</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"127.0.0.1:5000-5010:5000-5010\"</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">\"6060:6060/udp\"</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#Long Syntax --&gt; 권장하지 않는 방식</span></span><br><span class=\"line\"><span class=\"attr\">tomcat2:</span></span><br><span class=\"line\"><span class=\"attr\">      ports:</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">target</span> <span class=\"string\">:</span> <span class=\"number\">8080</span> <span class=\"comment\">#Container 내부포트</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">published</span> <span class=\"string\">:</span> <span class=\"number\">80</span> <span class=\"comment\"># 외부 OS 포트</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">protocol</span> <span class=\"string\">:</span> <span class=\"string\">tcp</span> <span class=\"comment\"># tcp 또는 udp</span></span><br><span class=\"line\"><span class=\"bullet\">       -</span> <span class=\"string\">mode</span> <span class=\"string\">:</span> <span class=\"string\">host</span> <span class=\"comment\">#host: 각각의 Container 노드와 1:1로 매핑</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>포트 매핑 시 주의 할 점\nHost : Container 형식으로 포트를 매핑하면 YAML이 xx:yy 형식은 구문 분석시에 default를 60으로 주기 때문에 60번 이하 포트에 대해서 잘못된 결과가 초래될 수 있음.\n(8000 : 22 와 같이 숫자만 적는 경우 문제가 발생)\n따라서, <code>포트 매핑은 항상 문자열로 적어야 합니다.</code>\n( &quot;8000 : 22&quot;와 같이 문자열로 선언해야 안전합니다. ) ==&gt; 60번 이하 포트를 쓰지말라는 소리가 아님.</p>\n</blockquote>\n<h2>image</h2>\n<p>어떤 image를 바탕으로 생성할 것인지 지정합니다.</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">redis:</span> </span><br><span class=\"line\"><span class=\"attr\">      image:</span> <span class=\"string\">redis</span></span><br><span class=\"line\"><span class=\"attr\">ubuntu:</span> </span><br><span class=\"line\"><span class=\"attr\">      image:</span> <span class=\"attr\">ubuntu:14.04</span></span><br></pre></td></tr></table></figure></p>\n<h2>link</h2>\n<ul>\n<li>다른 Container와 연결하기 위해 설정합니다.</li>\n<li>외부 Port노출이 안되어도 Expose명령으로 노출된 Port로 연결</li>\n<li>network_mode가 <code>host인 경우 사용할 수 없습니다.</code> (host인 경우 Host OS의 port를 직접 사용하기 때문)</li>\n<li>서비스 이름:Alias 형태로 선언하거나 서비스 이름만 지정합니다.</li>\n</ul>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">web:</span></span><br><span class=\"line\"><span class=\"attr\">  link:</span></span><br><span class=\"line\"><span class=\"attr\">    - db:</span><span class=\"string\">mycontainerdb-alias</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">redis</span></span><br><span class=\"line\"><span class=\"attr\">db:</span> </span><br><span class=\"line\"><span class=\"attr\">  image:</span> <span class=\"string\">mysql</span></span><br><span class=\"line\"><span class=\"attr\">redis:</span> </span><br><span class=\"line\"><span class=\"attr\">  image:</span> <span class=\"string\">redis</span></span><br></pre></td></tr></table></figure></p>\n<h2>network_mode</h2>\n<p>Docker network policy 설정 (다음 장에 상세 설명하겠습니다.)</p>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">network_mode:</span> <span class=\"string\">\"bridge\"</span></span><br><span class=\"line\"><span class=\"attr\">network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\"><span class=\"attr\">network_mode:</span> <span class=\"string\">\"none\"</span></span><br><span class=\"line\"><span class=\"attr\">network_mode:</span> <span class=\"string\">\"service:[service name]\"</span></span><br><span class=\"line\"><span class=\"attr\">network_mode:</span> <span class=\"string\">\"container:[container name/id]\"</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Docker Swarm을 사용하는 경우 network_mode 옵션은 무시됩니다.</p>\n</blockquote>\n<h2>volumes</h2>\n<ul>\n<li>Host OS의 디렉터리 경로를 Container 내부의 디렉터리에 Mount 합니다. (쉽게 말해서 디렉토리가 연동됩니다.)</li>\n<li>docker run -v 또는 --volume과 같습니다.</li>\n<li>Dockerfile의 VOLUME[] 과 같습니다.</li>\n<li>docker-compose.yml의 volumes에는 상대경로를 지정할 수 있습니다.</li>\n<li>호스트:컨테이너:권한 순으로 작성하여 읽기/쓰기 권한 설정을 할 수 있습니다. (Default는 rw)\n<ul>\n<li>ro : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수만 있음. Container에서 파일에 대한 수정이 불가능합니다.</li>\n<li>rw : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수 있고, Container에서 파일 수정이 가능하고, Host OS 디렉토리에 반영이 됩니다.</li>\n</ul>\n</li>\n</ul>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">redis:</span> </span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">     -</span> <span class=\"string\">/usr/local/redis/data:/data</span> <span class=\"comment\"># &lt;Host OS 디렉터리 경로&gt; : &lt;Container 내부 data 경로&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">     -</span> <span class=\"string\">/usr/local/redis/data:/data:ro</span> <span class=\"comment\">#ReadOnly </span></span><br><span class=\"line\"><span class=\"bullet\">     -</span> <span class=\"string\">/usr/local/redis/data:/data:rw</span> <span class=\"comment\">#ReadWrite</span></span><br></pre></td></tr></table></figure></p>\n<h2>restart</h2>\n<p>Container 재 시작에 대한 policy를 설정합니다.</p>\n<ul>\n<li>no : 문제가 발생하여 Container가 중지된 경우 재시작 하지 않음 (default)</li>\n<li>always : 어떠한 문제로 Container가 중지되는 경우 무조건 재시작</li>\n<li>on-failure : Container의 exit code 0 이 아닌 경우 재시작</li>\n<li>unless-stopped : 명시적으로 중지되거나, Docker 자체가 중지되는 경우 재시작</li>\n</ul>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">restart:</span> <span class=\"literal\">no</span>            </span><br><span class=\"line\"><span class=\"attr\">restart:</span> <span class=\"string\">always</span>          </span><br><span class=\"line\"><span class=\"attr\">restart:</span> <span class=\"string\">on-failure</span>      </span><br><span class=\"line\"><span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span></span><br></pre></td></tr></table></figure></p>\n<h1>참고</h1>\n<ul>\n<li>https://docs.docker.com/compose/compose-file/</li>\n<li>http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/</li>\n<li>https://www.joinc.co.kr/w/man/12/docker/Guide/DataWithContainer</li>\n</ul>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (6) Docker를 이용한 Redis Cluster 설치하기","date":"2018-12-01T08:53:04.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-12-01-docker-6","typora-copy-images-to":"2018-12-01-docker-6","_content":"\n# Redis Cluster 구성도\n\n![Redis-Cluster-archi](./Redis-Cluster-archi.PNG)\n\n\n\n간단하게 정리하면.\n\n* 각 서버 별로 Redis 3대를 설치. Master 1개, Slave 2개로 구성하여 Replication을 지원할 수 있도록 Cluster를 구성하였습니다.\n* 각 서버 별로 Sentinel 3대를 설치. 양대비 원리에 맞추어 홀수개로 설정 하였습니다.\n* 각각의 서버의 Sentinel 3대가 서버의 Master Redis를 감시합니다. (Failover 대기)\n* Redis Cluster를 서버 3대에 설치. Data Sharding을 하기 위해 저장소를 3개로 분리하였습니다.\n* HAProxy로 분산 처리 구축. 5000, 5002, 5004번 포트는 각 서버의 Master Redis를 바라봅니다.\n* 5001, 5003, 5005번 포트는 각 서버의 Slave Redis 2대씩 바라봅니다.\n\n지금부터 Redis Cluster를 어떻게 설치 하였는지 설치 과정에 대해 알아보도록 하겠습니다.\n\n\n\n# Docker를 이용한 Redis Cluster 설치\n\nRedis-Cluster를 설치하는 순서는 아래와 같습니다. (CentOS 7기준으로 설치 하였습니다.)\n* Git 설치 (미리 올려둔 Docker file들을 다운받기 위함)\n* Docker 설치\n* Docker-Compose 설치\n* Docker Build\n\n\n\n## Git 설치 + Docker file 다운로드\n\n```sh\n# git설치\nyum -y install git\ngit --version # git 버전 확인\n \n#Redis-Cluster 디렉터리 생성\nmkdir -p /home/redis/redis-cluster\n \n#Redis-Cluster-Home 이동\ncd /home/redis/redis-cluster\n \n#아래 디렉터리들은 각 Redis Container의 외부볼륨으로 설정하기 위해 생성하였습니다.\n#==> Container 외부 볼륨을 설정해야 Redis Container가 삭제되더라도 Data가 보존됩니다.\n#===> dump.rdb 파일이 생성되는 장소\nmkdir -p ./redis-data/redis1\nmkdir -p ./redis-data/redis2\nmkdir -p ./redis-data/redis3\n \n#Docker file Download\n#설치파일을 다운받습니다.\ngit init\ngit remote add origin \"https://github.com/jaehun2841/redis-cluster-on-docker.git\"\ngit pull origin master\n```\n\n\n\n## Docker 설치\n\n```sh\n#docker 설치\ncurl -fsSL https://get.docker.com/ | sh\n \n#docker 설치 후 docker 시작\nservice docker start\n```\n\nDocker를 yum으로도 설치가 가능하지만 버전이 낮아 Docker-compose를 설치 할 수 없습니다.\n차후에 update까지 필요하니 위 url에서 제공하는 shell script를 실행하여 설치하도록 합니다.\n**※ 위 Script는 sudo 명령 또는 root 권한을 필요로 합니다.**\n\nDocker 설치 내용은 2장에서 기술한 내용을 참고하시길 바랍니다.\n\n\n\n## Docker-Compose 설치\n\n```sh\n#docker 공식 github에서 다운로드\nsudo curl -L \"https://github.com/docker/compose/releases/download/1.23.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n\nchmod +x /usr/local/bin/docker-compose\n```\n\nDocker-Compose 설치 내용은 4장에서 기술한 내용을 참고하시길 바랍니다.\n\n\n\n## Docker build\n\n```sh\n# redis-cluster home 이동\ncd /home/redis/redis-cluster\n \n#docker build\ndocker-compose -f conf/docker-compose.yml up --build -d\n```\n\n* -f 옵션으로 docker-compose.yml 파일을 설정합니다. \n  (docker-compose.yml 파일은 github redis-cluster 설치파일을 받을때 다운 받았습니다. )\n* up 명령으로 docker container를 실행합니다.\n* --build 옵션으로 build후 container를 실행합니다.\n* -d 옵션으로 background로 실행되도록 합니다. \n  (-d 옵션을 빼면 redis의 로그가....나오며 exit하는 순간 container가 stop됩니다.)\n\n\n\n# Redis Cluster를 빌드하기 위한 docker-compose.yml 파일\n\n```yml\nversion: '3'\nservices:\n \n  redis-master:\n     image: redis:5.0-alpine   # image 옵션으로 redis공식이미지를 기반으로 생성합니다.\n     build:\n       context: ..             # build file에 대한 context를 지정\n       dockerfile: Dockerfile  #dockerfile명을 지정합니다. (Default는 \"Dockerfile\" 파일명을 가진 파일을 실행합니다.)\n     network_mode: \"host\"      # Image가 Container가 되었을때 network모드를 host모드로 설정합니다 (docker0 인터페이스를 사용하지 않고 Host OS의 eth0 인터페이스 사용)\n     environment:              # Container 내부에서 사용 할 환경변수를 설정합니다.\n      - REQUIREPASS=password1234\n      - CLIENTPORT=6379\n      - CLIENTHOST=192.168.137.101\n      - MASTERHOST=\n      - MASTERPORT=\n     volumes:  # Host OS의 디렉터리와 Container내의 디렉터리와 연동합니다.\n      - \"../redis-data/redis1:/data\"\n     restart: always\n \n  redis-slave1:\n     image: redis:5.0-alpine\n     build:\n       context: ..\n       dockerfile: Dockerfile\n     network_mode: \"host\"\n     environment:\n      - REQUIREPASS=password1234\n      - CLIENTPORT=6380\n      - MASTERPORT=6379\n      - CLIENTHOST=192.168.137.101\n      - MASTERHOST=192.168.137.101\n     volumes:\n      - \"../redis-data/redis2:/data\"\n     restart: always\n \n  redis-slave2:\n     image: redis:5.0-alpine\n     build:\n       context: ..\n       dockerfile: Dockerfile\n     network_mode: \"host\"\n     environment:\n      - REQUIREPASS=password1234\n      - CLIENTPORT=6381\n      - MASTERPORT=6379\n      - CLIENTHOST=192.168.137.101\n      - MASTERHOST=192.168.137.101 \n     volumes:\n      - \"../redis-data/redis3:/data\"\n     restart: always\n```\n\n>**Redis Container의 Network모드가 Host인 이유**\n>Redis 공식 홈페이지의 cluster-tutorial에서 발췌한 내용입니다.\n>\n>>Redis Cluster and Docker\n>>\n>>Currently Redis Cluster does not support NATted environments and in general environments where IP addresses or TCP ports are remapped.\n>>Docker uses a technique called port mapping: programs running inside Docker containers may be exposed with a different port compared to the one the program believes to be using.\n>>This is useful in order to run multiple containers using the same ports, at the same time, in the same server.\n>>`In order to make Docker compatible with Redis Cluster you need to use the host networking mode of Docker.` Please check the --net=host option in the Docker documentation for more information.\n>\n>Redis Cluster에서는 NAT환경과 IP주소 또는 TCP포트가 재 매핑되는 환경을 지원하지 않는다고 합니다.\n>따라서 Docker에서 Redis Cluster를 호환되게 하기 위해서는 Host 모드로 사용할 것을 권고하고 있습니다.\n\n\n\n# Redis Container 생성을 위한 Dockerfile 작성\n\nDocker-Compose build를 사용하면서 Dockerfile에는 Redis Container를 구성하는 공통적인 로직을 담았습니다.\n주로 내부에서 file을 생성하거나 Host OS의 파일을 Container가 생성하는 시점에 복사하기 위한 로직이 주로 들어있습니다.\n그리고 접근권한이 막혀 파일이 실행되지 않는 문제를 해결하기 위해 접근권한을 변경하였습니다.\n\n```sh\nFROM redis:5.0-alpine //redis 이미지를 기반으로 빌드됨을 의미합니다.\n \nMAINTAINER Carrey (jaehun2841@gmail.com)\n \n# Copy Redis File\n# 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 합니다.\n# 기존의 docker-entryporint.sh 파일을 삭제합니다.\nRUN rm -rf /usr/local/bin/docker-entrypoint.sh  \n# 공통적으로 적용할 redis.conf 파일을 복사합니다.\nADD redis.conf /usr/local/bin/redis.conf    \n# Container가 생성, 시작하는 시점에 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.\nADD docker-entrypoint.sh /usr/local/bin        \n \n## change access authority\nRUN chmod 755 /usr/local/bin/redis.conf\nRUN chmod 755 /usr/local/bin/docker-entrypoint.sh\n \nRUN chown redis:redis /usr/local/bin/redis.conf\nRUN chown redis:redis /usr/local/bin/docker-entrypoint.sh\n\n#Redis Container에 대한 Port를 지정합니다. (내부포트이며 외부노출은 안됨)\nEXPOSE $CLIENTPORT #CLIENTPORT에 대한 값은 docker-compose.yml에 정의되어 있습니다.          \n# Container가 생성, 시작하는 시점에 실행됩니다.\nENTRYPOINT [\"/usr/local/bin/docker-entrypoint.sh\"] \n# Container 빌드가 완료되고 Redis Server를 실행시킵니다.\nCMD [ \"redis-server\",\"/usr/local/bin/redis.conf\" ] \n```\n\n\n\n# Redis Cluster 설정\n\nRedis Cluster에 대한 Replication 설정에 대해 알아보겠습니다.\n\n설정 방법은 redis.conf 파일을 각 Container로 복사하여 공통적인 설정을 하였습니다.\n각 redis.conf 파일에 대한 변경사항은 `docker-entrypoint.sh` 파일을 통해 redis.conf 파일 정보를 replace하였습니다.\n\n```sh\n#!/bin/sh\nset -e\n \n## from redis-5.0\n# Redis서버에 접근가능한 Host를 설정합니다.\nsed -i \"s/bind 127.0.0.1/bind $CLIENTHOST 127.0.0.1/g\" /usr/local/bin/redis.conf\n\n### redis port inside redis.conf\n#redis.conf 파일의 port 6379 문자열을 port $CLINETPORT로 변경합니다. \n#($CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.)\nsed -i \"s/port 6379/port $CLIENTPORT/g\" /usr/local/bin/redis.conf \n\n# requirepass foobared 문자열을 requirepass $REQUIREPASS로 변경하였습니다. \n#(Redis 접속 시 비밀번호를 설정하였습니다.)\nsed -i \"s/# requirepass foobared/requirepass $REQUIREPASS/g\" /usr/local/bin/redis.conf          \nsed -i \"s/# masterauth <master-password>/masterauth $REQUIREPASS/g\" /usr/local/bin/redis.conf   \n\n### slaveof <masterip> <masterport> => slaveof $MASTERHOST $MASTERPORT\n# $MASTERPORT가 공백이 아닌 Container에 대해 slaveof 설정을 통해 Master-Slave 설정을 합니다.\nif [ \"$MASTERPORT\" != \"\" ];then\n    sed -i \"s/# slaveof <masterip> <masterport>/slaveof $MASTERHOST $MASTERPORT/g\" /usr/local/bin/redis.conf  \nfi\n \n# first arg is `-f` or `--some-option`\n# or first arg is `something.conf`\nif [ \"${1#-}\" != \"$1\" ] || [ \"${1%.conf}\" != \"$1\" ]; then\n    set -- redis-server \"$@\"\nfi\n \n# allow the container to be started with `--user`\nif [ \"$1\" = 'redis-server' -a \"$(id -u)\" = '0' ]; then\n    chown -R redis .\n    exec su-exec redis \"$@\"\nfi\n \nexec \"$@\"\n```\n\n\n\n# Redis Cluster 실행 결과\nRedis.log\n![redis-replication](./redis-replication-3746317.PNG)\n\n로그에서 0 clients connected (2 slaves) 라는 로그가 보입니다.\nRedis에 접속한 클라이언트 수는 0 client이며\n2개의 slave redis와 연결하고 있습니다.\n\n중간부분 로그에서 로그를 보면 slave로 설정한 Redis와 연동이 되는 것을 확인 할 수 있습니다.\n\n\n\nredis-cli > info replication\n![redis-replication2](./redis-replication2-3746337.PNG)\n\nredis-cli에서 info replication 명령을 실행하였을 때, 조회되는 내용입니다.\nslave0, slave1에 대한 참조를 가지고 있는 것을 확인 할 수 있습니다.\n\n\n\n# 참고\n\n* https://redis.io/topics/cluster-tutorial","source":"_posts/2018-12-01-docker-6.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (6) Docker를 이용한 Redis Cluster 설치하기\ndate: 2018-12-01 17:53:04\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-12-01-docker-6\ntypora-copy-images-to: 2018-12-01-docker-6\n---\n\n# Redis Cluster 구성도\n\n![Redis-Cluster-archi](./Redis-Cluster-archi.PNG)\n\n\n\n간단하게 정리하면.\n\n* 각 서버 별로 Redis 3대를 설치. Master 1개, Slave 2개로 구성하여 Replication을 지원할 수 있도록 Cluster를 구성하였습니다.\n* 각 서버 별로 Sentinel 3대를 설치. 양대비 원리에 맞추어 홀수개로 설정 하였습니다.\n* 각각의 서버의 Sentinel 3대가 서버의 Master Redis를 감시합니다. (Failover 대기)\n* Redis Cluster를 서버 3대에 설치. Data Sharding을 하기 위해 저장소를 3개로 분리하였습니다.\n* HAProxy로 분산 처리 구축. 5000, 5002, 5004번 포트는 각 서버의 Master Redis를 바라봅니다.\n* 5001, 5003, 5005번 포트는 각 서버의 Slave Redis 2대씩 바라봅니다.\n\n지금부터 Redis Cluster를 어떻게 설치 하였는지 설치 과정에 대해 알아보도록 하겠습니다.\n\n\n\n# Docker를 이용한 Redis Cluster 설치\n\nRedis-Cluster를 설치하는 순서는 아래와 같습니다. (CentOS 7기준으로 설치 하였습니다.)\n* Git 설치 (미리 올려둔 Docker file들을 다운받기 위함)\n* Docker 설치\n* Docker-Compose 설치\n* Docker Build\n\n\n\n## Git 설치 + Docker file 다운로드\n\n```sh\n# git설치\nyum -y install git\ngit --version # git 버전 확인\n \n#Redis-Cluster 디렉터리 생성\nmkdir -p /home/redis/redis-cluster\n \n#Redis-Cluster-Home 이동\ncd /home/redis/redis-cluster\n \n#아래 디렉터리들은 각 Redis Container의 외부볼륨으로 설정하기 위해 생성하였습니다.\n#==> Container 외부 볼륨을 설정해야 Redis Container가 삭제되더라도 Data가 보존됩니다.\n#===> dump.rdb 파일이 생성되는 장소\nmkdir -p ./redis-data/redis1\nmkdir -p ./redis-data/redis2\nmkdir -p ./redis-data/redis3\n \n#Docker file Download\n#설치파일을 다운받습니다.\ngit init\ngit remote add origin \"https://github.com/jaehun2841/redis-cluster-on-docker.git\"\ngit pull origin master\n```\n\n\n\n## Docker 설치\n\n```sh\n#docker 설치\ncurl -fsSL https://get.docker.com/ | sh\n \n#docker 설치 후 docker 시작\nservice docker start\n```\n\nDocker를 yum으로도 설치가 가능하지만 버전이 낮아 Docker-compose를 설치 할 수 없습니다.\n차후에 update까지 필요하니 위 url에서 제공하는 shell script를 실행하여 설치하도록 합니다.\n**※ 위 Script는 sudo 명령 또는 root 권한을 필요로 합니다.**\n\nDocker 설치 내용은 2장에서 기술한 내용을 참고하시길 바랍니다.\n\n\n\n## Docker-Compose 설치\n\n```sh\n#docker 공식 github에서 다운로드\nsudo curl -L \"https://github.com/docker/compose/releases/download/1.23.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n\nchmod +x /usr/local/bin/docker-compose\n```\n\nDocker-Compose 설치 내용은 4장에서 기술한 내용을 참고하시길 바랍니다.\n\n\n\n## Docker build\n\n```sh\n# redis-cluster home 이동\ncd /home/redis/redis-cluster\n \n#docker build\ndocker-compose -f conf/docker-compose.yml up --build -d\n```\n\n* -f 옵션으로 docker-compose.yml 파일을 설정합니다. \n  (docker-compose.yml 파일은 github redis-cluster 설치파일을 받을때 다운 받았습니다. )\n* up 명령으로 docker container를 실행합니다.\n* --build 옵션으로 build후 container를 실행합니다.\n* -d 옵션으로 background로 실행되도록 합니다. \n  (-d 옵션을 빼면 redis의 로그가....나오며 exit하는 순간 container가 stop됩니다.)\n\n\n\n# Redis Cluster를 빌드하기 위한 docker-compose.yml 파일\n\n```yml\nversion: '3'\nservices:\n \n  redis-master:\n     image: redis:5.0-alpine   # image 옵션으로 redis공식이미지를 기반으로 생성합니다.\n     build:\n       context: ..             # build file에 대한 context를 지정\n       dockerfile: Dockerfile  #dockerfile명을 지정합니다. (Default는 \"Dockerfile\" 파일명을 가진 파일을 실행합니다.)\n     network_mode: \"host\"      # Image가 Container가 되었을때 network모드를 host모드로 설정합니다 (docker0 인터페이스를 사용하지 않고 Host OS의 eth0 인터페이스 사용)\n     environment:              # Container 내부에서 사용 할 환경변수를 설정합니다.\n      - REQUIREPASS=password1234\n      - CLIENTPORT=6379\n      - CLIENTHOST=192.168.137.101\n      - MASTERHOST=\n      - MASTERPORT=\n     volumes:  # Host OS의 디렉터리와 Container내의 디렉터리와 연동합니다.\n      - \"../redis-data/redis1:/data\"\n     restart: always\n \n  redis-slave1:\n     image: redis:5.0-alpine\n     build:\n       context: ..\n       dockerfile: Dockerfile\n     network_mode: \"host\"\n     environment:\n      - REQUIREPASS=password1234\n      - CLIENTPORT=6380\n      - MASTERPORT=6379\n      - CLIENTHOST=192.168.137.101\n      - MASTERHOST=192.168.137.101\n     volumes:\n      - \"../redis-data/redis2:/data\"\n     restart: always\n \n  redis-slave2:\n     image: redis:5.0-alpine\n     build:\n       context: ..\n       dockerfile: Dockerfile\n     network_mode: \"host\"\n     environment:\n      - REQUIREPASS=password1234\n      - CLIENTPORT=6381\n      - MASTERPORT=6379\n      - CLIENTHOST=192.168.137.101\n      - MASTERHOST=192.168.137.101 \n     volumes:\n      - \"../redis-data/redis3:/data\"\n     restart: always\n```\n\n>**Redis Container의 Network모드가 Host인 이유**\n>Redis 공식 홈페이지의 cluster-tutorial에서 발췌한 내용입니다.\n>\n>>Redis Cluster and Docker\n>>\n>>Currently Redis Cluster does not support NATted environments and in general environments where IP addresses or TCP ports are remapped.\n>>Docker uses a technique called port mapping: programs running inside Docker containers may be exposed with a different port compared to the one the program believes to be using.\n>>This is useful in order to run multiple containers using the same ports, at the same time, in the same server.\n>>`In order to make Docker compatible with Redis Cluster you need to use the host networking mode of Docker.` Please check the --net=host option in the Docker documentation for more information.\n>\n>Redis Cluster에서는 NAT환경과 IP주소 또는 TCP포트가 재 매핑되는 환경을 지원하지 않는다고 합니다.\n>따라서 Docker에서 Redis Cluster를 호환되게 하기 위해서는 Host 모드로 사용할 것을 권고하고 있습니다.\n\n\n\n# Redis Container 생성을 위한 Dockerfile 작성\n\nDocker-Compose build를 사용하면서 Dockerfile에는 Redis Container를 구성하는 공통적인 로직을 담았습니다.\n주로 내부에서 file을 생성하거나 Host OS의 파일을 Container가 생성하는 시점에 복사하기 위한 로직이 주로 들어있습니다.\n그리고 접근권한이 막혀 파일이 실행되지 않는 문제를 해결하기 위해 접근권한을 변경하였습니다.\n\n```sh\nFROM redis:5.0-alpine //redis 이미지를 기반으로 빌드됨을 의미합니다.\n \nMAINTAINER Carrey (jaehun2841@gmail.com)\n \n# Copy Redis File\n# 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 합니다.\n# 기존의 docker-entryporint.sh 파일을 삭제합니다.\nRUN rm -rf /usr/local/bin/docker-entrypoint.sh  \n# 공통적으로 적용할 redis.conf 파일을 복사합니다.\nADD redis.conf /usr/local/bin/redis.conf    \n# Container가 생성, 시작하는 시점에 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.\nADD docker-entrypoint.sh /usr/local/bin        \n \n## change access authority\nRUN chmod 755 /usr/local/bin/redis.conf\nRUN chmod 755 /usr/local/bin/docker-entrypoint.sh\n \nRUN chown redis:redis /usr/local/bin/redis.conf\nRUN chown redis:redis /usr/local/bin/docker-entrypoint.sh\n\n#Redis Container에 대한 Port를 지정합니다. (내부포트이며 외부노출은 안됨)\nEXPOSE $CLIENTPORT #CLIENTPORT에 대한 값은 docker-compose.yml에 정의되어 있습니다.          \n# Container가 생성, 시작하는 시점에 실행됩니다.\nENTRYPOINT [\"/usr/local/bin/docker-entrypoint.sh\"] \n# Container 빌드가 완료되고 Redis Server를 실행시킵니다.\nCMD [ \"redis-server\",\"/usr/local/bin/redis.conf\" ] \n```\n\n\n\n# Redis Cluster 설정\n\nRedis Cluster에 대한 Replication 설정에 대해 알아보겠습니다.\n\n설정 방법은 redis.conf 파일을 각 Container로 복사하여 공통적인 설정을 하였습니다.\n각 redis.conf 파일에 대한 변경사항은 `docker-entrypoint.sh` 파일을 통해 redis.conf 파일 정보를 replace하였습니다.\n\n```sh\n#!/bin/sh\nset -e\n \n## from redis-5.0\n# Redis서버에 접근가능한 Host를 설정합니다.\nsed -i \"s/bind 127.0.0.1/bind $CLIENTHOST 127.0.0.1/g\" /usr/local/bin/redis.conf\n\n### redis port inside redis.conf\n#redis.conf 파일의 port 6379 문자열을 port $CLINETPORT로 변경합니다. \n#($CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.)\nsed -i \"s/port 6379/port $CLIENTPORT/g\" /usr/local/bin/redis.conf \n\n# requirepass foobared 문자열을 requirepass $REQUIREPASS로 변경하였습니다. \n#(Redis 접속 시 비밀번호를 설정하였습니다.)\nsed -i \"s/# requirepass foobared/requirepass $REQUIREPASS/g\" /usr/local/bin/redis.conf          \nsed -i \"s/# masterauth <master-password>/masterauth $REQUIREPASS/g\" /usr/local/bin/redis.conf   \n\n### slaveof <masterip> <masterport> => slaveof $MASTERHOST $MASTERPORT\n# $MASTERPORT가 공백이 아닌 Container에 대해 slaveof 설정을 통해 Master-Slave 설정을 합니다.\nif [ \"$MASTERPORT\" != \"\" ];then\n    sed -i \"s/# slaveof <masterip> <masterport>/slaveof $MASTERHOST $MASTERPORT/g\" /usr/local/bin/redis.conf  \nfi\n \n# first arg is `-f` or `--some-option`\n# or first arg is `something.conf`\nif [ \"${1#-}\" != \"$1\" ] || [ \"${1%.conf}\" != \"$1\" ]; then\n    set -- redis-server \"$@\"\nfi\n \n# allow the container to be started with `--user`\nif [ \"$1\" = 'redis-server' -a \"$(id -u)\" = '0' ]; then\n    chown -R redis .\n    exec su-exec redis \"$@\"\nfi\n \nexec \"$@\"\n```\n\n\n\n# Redis Cluster 실행 결과\nRedis.log\n![redis-replication](./redis-replication-3746317.PNG)\n\n로그에서 0 clients connected (2 slaves) 라는 로그가 보입니다.\nRedis에 접속한 클라이언트 수는 0 client이며\n2개의 slave redis와 연결하고 있습니다.\n\n중간부분 로그에서 로그를 보면 slave로 설정한 Redis와 연동이 되는 것을 확인 할 수 있습니다.\n\n\n\nredis-cli > info replication\n![redis-replication2](./redis-replication2-3746337.PNG)\n\nredis-cli에서 info replication 명령을 실행하였을 때, 조회되는 내용입니다.\nslave0, slave1에 대한 참조를 가지고 있는 것을 확인 할 수 있습니다.\n\n\n\n# 참고\n\n* https://redis.io/topics/cluster-tutorial","slug":"2018-12-01-docker-6","published":1,"updated":"2018-12-08T08:32:55.273Z","comments":1,"photos":[],"link":"","_id":"cjrgbv3ru003gcr1tlpo0g916","content":"<h1 id=\"redis-cluster-구성도\">Redis Cluster 구성도</h1>\n<p><img src=\"./Redis-Cluster-archi.PNG\" alt=\"Redis-Cluster-archi\"></p>\n<p>간단하게 정리하면.</p>\n<ul>\n<li>각 서버 별로 Redis 3대를 설치. Master 1개, Slave 2개로 구성하여 Replication을 지원할 수 있도록 Cluster를 구성하였습니다.</li>\n<li>각 서버 별로 Sentinel 3대를 설치. 양대비 원리에 맞추어 홀수개로 설정 하였습니다.</li>\n<li>각각의 서버의 Sentinel 3대가 서버의 Master Redis를 감시합니다. (Failover 대기)</li>\n<li>Redis Cluster를 서버 3대에 설치. Data Sharding을 하기 위해 저장소를 3개로 분리하였습니다.</li>\n<li>HAProxy로 분산 처리 구축. 5000, 5002, 5004번 포트는 각 서버의 Master Redis를 바라봅니다.</li>\n<li>5001, 5003, 5005번 포트는 각 서버의 Slave Redis 2대씩 바라봅니다.</li>\n</ul>\n<p>지금부터 Redis Cluster를 어떻게 설치 하였는지 설치 과정에 대해 알아보도록 하겠습니다.</p>\n<h1 id=\"docker를-이용한-redis-cluster-설치\">Docker를 이용한 Redis Cluster 설치</h1>\n<p>Redis-Cluster를 설치하는 순서는 아래와 같습니다. (CentOS 7기준으로 설치 하였습니다.)</p>\n<ul>\n<li>Git 설치 (미리 올려둔 Docker file들을 다운받기 위함)</li>\n<li>Docker 설치</li>\n<li>Docker-Compose 설치</li>\n<li>Docker Build</li>\n</ul>\n<h2 id=\"git-설치-docker-file-다운로드\">Git 설치 + Docker file 다운로드</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># git설치</span></span><br><span class=\"line\">yum -y install git</span><br><span class=\"line\">git --version <span class=\"comment\"># git 버전 확인</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#Redis-Cluster 디렉터리 생성</span></span><br><span class=\"line\">mkdir -p /home/redis/redis-cluster</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#Redis-Cluster-Home 이동</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/redis/redis-cluster</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#아래 디렉터리들은 각 Redis Container의 외부볼륨으로 설정하기 위해 생성하였습니다.</span></span><br><span class=\"line\"><span class=\"comment\">#==&gt; Container 외부 볼륨을 설정해야 Redis Container가 삭제되더라도 Data가 보존됩니다.</span></span><br><span class=\"line\"><span class=\"comment\">#===&gt; dump.rdb 파일이 생성되는 장소</span></span><br><span class=\"line\">mkdir -p ./redis-data/redis1</span><br><span class=\"line\">mkdir -p ./redis-data/redis2</span><br><span class=\"line\">mkdir -p ./redis-data/redis3</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#Docker file Download</span></span><br><span class=\"line\"><span class=\"comment\">#설치파일을 다운받습니다.</span></span><br><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin <span class=\"string\">\"https://github.com/jaehun2841/redis-cluster-on-docker.git\"</span></span><br><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"docker-설치\">Docker 설치</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#docker 설치</span></span><br><span class=\"line\">curl -fsSL https://get.docker.com/ | sh</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#docker 설치 후 docker 시작</span></span><br><span class=\"line\">service docker start</span><br></pre></td></tr></table></figure></p>\n<p>Docker를 yum으로도 설치가 가능하지만 버전이 낮아 Docker-compose를 설치 할 수 없습니다.\n차후에 update까지 필요하니 위 url에서 제공하는 shell script를 실행하여 설치하도록 합니다.\n<strong>※ 위 Script는 sudo 명령 또는 root 권한을 필요로 합니다.</strong></p>\n<p>Docker 설치 내용은 2장에서 기술한 내용을 참고하시길 바랍니다.</p>\n<h2 id=\"docker-compose-설치\">Docker-Compose 설치</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#docker 공식 github에서 다운로드</span></span><br><span class=\"line\">sudo curl -L <span class=\"string\">\"https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class=\"variable\">$(uname -s)</span>-<span class=\"variable\">$(uname -m)</span>\"</span> -o /usr/<span class=\"built_in\">local</span>/bin/docker-compose</span><br><span class=\"line\"></span><br><span class=\"line\">chmod +x /usr/<span class=\"built_in\">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></p>\n<p>Docker-Compose 설치 내용은 4장에서 기술한 내용을 참고하시길 바랍니다.</p>\n<h2 id=\"docker-build\">Docker build</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis-cluster home 이동</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/redis/redis-cluster</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#docker build</span></span><br><span class=\"line\">docker-compose -f conf/docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>-f 옵션으로 docker-compose.yml 파일을 설정합니다.\n(docker-compose.yml 파일은 github redis-cluster 설치파일을 받을때 다운 받았습니다. )</li>\n<li>up 명령으로 docker container를 실행합니다.</li>\n<li>--build 옵션으로 build후 container를 실행합니다.</li>\n<li>-d 옵션으로 background로 실행되도록 합니다.\n(-d 옵션을 빼면 redis의 로그가....나오며 exit하는 순간 container가 stop됩니다.)</li>\n</ul>\n<h1 id=\"redis-cluster를-빌드하기-위한-docker-composeyml-파일\">Redis Cluster를 빌드하기 위한 docker-compose.yml 파일</h1>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'3'</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"attr\">redis-master:</span></span><br><span class=\"line\">     <span class=\"attr\">image:</span> <span class=\"attr\">redis:5.0-alpine</span>   <span class=\"comment\"># image 옵션으로 redis공식이미지를 기반으로 생성합니다.</span></span><br><span class=\"line\">     <span class=\"attr\">build:</span></span><br><span class=\"line\">       <span class=\"attr\">context:</span> <span class=\"string\">..</span>             <span class=\"comment\"># build file에 대한 context를 지정</span></span><br><span class=\"line\">       <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span>  <span class=\"comment\">#dockerfile명을 지정합니다. (Default는 \"Dockerfile\" 파일명을 가진 파일을 실행합니다.)</span></span><br><span class=\"line\">     <span class=\"attr\">network_mode:</span> <span class=\"string\">\"host\"</span>      <span class=\"comment\"># Image가 Container가 되었을때 network모드를 host모드로 설정합니다 (docker0 인터페이스를 사용하지 않고 Host OS의 eth0 인터페이스 사용)</span></span><br><span class=\"line\">     <span class=\"attr\">environment:</span>              <span class=\"comment\"># Container 내부에서 사용 할 환경변수를 설정합니다.</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">REQUIREPASS=password1234</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">CLIENTPORT=6379</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MASTERHOST=</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MASTERPORT=</span></span><br><span class=\"line\">     <span class=\"attr\">volumes:</span>  <span class=\"comment\"># Host OS의 디렉터리와 Container내의 디렉터리와 연동합니다.</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"../redis-data/redis1:/data\"</span></span><br><span class=\"line\">     <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"attr\">redis-slave1:</span></span><br><span class=\"line\">     <span class=\"attr\">image:</span> <span class=\"attr\">redis:5.0-alpine</span></span><br><span class=\"line\">     <span class=\"attr\">build:</span></span><br><span class=\"line\">       <span class=\"attr\">context:</span> <span class=\"string\">..</span></span><br><span class=\"line\">       <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\">     <span class=\"attr\">network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\">     <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">REQUIREPASS=password1234</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">CLIENTPORT=6380</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MASTERPORT=6379</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MASTERHOST=192.168.137.101</span></span><br><span class=\"line\">     <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"../redis-data/redis2:/data\"</span></span><br><span class=\"line\">     <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"attr\">redis-slave2:</span></span><br><span class=\"line\">     <span class=\"attr\">image:</span> <span class=\"attr\">redis:5.0-alpine</span></span><br><span class=\"line\">     <span class=\"attr\">build:</span></span><br><span class=\"line\">       <span class=\"attr\">context:</span> <span class=\"string\">..</span></span><br><span class=\"line\">       <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\">     <span class=\"attr\">network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\">     <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">REQUIREPASS=password1234</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">CLIENTPORT=6381</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MASTERPORT=6379</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MASTERHOST=192.168.137.101</span> </span><br><span class=\"line\">     <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"../redis-data/redis3:/data\"</span></span><br><span class=\"line\">     <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><strong>Redis Container의 Network모드가 Host인 이유</strong>\nRedis 공식 홈페이지의 cluster-tutorial에서 발췌한 내용입니다.</p>\n<blockquote>\n<p>Redis Cluster and Docker</p>\n<p>Currently Redis Cluster does not support NATted environments and in general environments where IP addresses or TCP ports are remapped.\nDocker uses a technique called port mapping: programs running inside Docker containers may be exposed with a different port compared to the one the program believes to be using.\nThis is useful in order to run multiple containers using the same ports, at the same time, in the same server.\n<code>In order to make Docker compatible with Redis Cluster you need to use the host networking mode of Docker.</code> Please check the --net=host option in the Docker documentation for more information.</p>\n</blockquote>\n<p>Redis Cluster에서는 NAT환경과 IP주소 또는 TCP포트가 재 매핑되는 환경을 지원하지 않는다고 합니다.\n따라서 Docker에서 Redis Cluster를 호환되게 하기 위해서는 Host 모드로 사용할 것을 권고하고 있습니다.</p>\n</blockquote>\n<h1 id=\"redis-container-생성을-위한-dockerfile-작성\">Redis Container 생성을 위한 Dockerfile 작성</h1>\n<p>Docker-Compose build를 사용하면서 Dockerfile에는 Redis Container를 구성하는 공통적인 로직을 담았습니다.\n주로 내부에서 file을 생성하거나 Host OS의 파일을 Container가 생성하는 시점에 복사하기 위한 로직이 주로 들어있습니다.\n그리고 접근권한이 막혀 파일이 실행되지 않는 문제를 해결하기 위해 접근권한을 변경하였습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM redis:5.0-alpine //redis 이미지를 기반으로 빌드됨을 의미합니다.</span><br><span class=\"line\"> </span><br><span class=\"line\">MAINTAINER Carrey (jaehun2841@gmail.com)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Copy Redis File</span></span><br><span class=\"line\"><span class=\"comment\"># 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 합니다.</span></span><br><span class=\"line\"><span class=\"comment\"># 기존의 docker-entryporint.sh 파일을 삭제합니다.</span></span><br><span class=\"line\">RUN rm -rf /usr/<span class=\"built_in\">local</span>/bin/docker-entrypoint.sh  </span><br><span class=\"line\"><span class=\"comment\"># 공통적으로 적용할 redis.conf 파일을 복사합니다.</span></span><br><span class=\"line\">ADD redis.conf /usr/<span class=\"built_in\">local</span>/bin/redis.conf    </span><br><span class=\"line\"><span class=\"comment\"># Container가 생성, 시작하는 시점에 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.</span></span><br><span class=\"line\">ADD docker-entrypoint.sh /usr/<span class=\"built_in\">local</span>/bin        </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">## change access authority</span></span><br><span class=\"line\">RUN chmod 755 /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">RUN chmod 755 /usr/<span class=\"built_in\">local</span>/bin/docker-entrypoint.sh</span><br><span class=\"line\"> </span><br><span class=\"line\">RUN chown redis:redis /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">RUN chown redis:redis /usr/<span class=\"built_in\">local</span>/bin/docker-entrypoint.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Redis Container에 대한 Port를 지정합니다. (내부포트이며 외부노출은 안됨)</span></span><br><span class=\"line\">EXPOSE <span class=\"variable\">$CLIENTPORT</span> <span class=\"comment\">#CLIENTPORT에 대한 값은 docker-compose.yml에 정의되어 있습니다.          </span></span><br><span class=\"line\"><span class=\"comment\"># Container가 생성, 시작하는 시점에 실행됩니다.</span></span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"/usr/local/bin/docker-entrypoint.sh\"</span>] </span><br><span class=\"line\"><span class=\"comment\"># Container 빌드가 완료되고 Redis Server를 실행시킵니다.</span></span><br><span class=\"line\">CMD [ <span class=\"string\">\"redis-server\"</span>,<span class=\"string\">\"/usr/local/bin/redis.conf\"</span> ]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"redis-cluster-설정\">Redis Cluster 설정</h1>\n<p>Redis Cluster에 대한 Replication 설정에 대해 알아보겠습니다.</p>\n<p>설정 방법은 redis.conf 파일을 각 Container로 복사하여 공통적인 설정을 하였습니다.\n각 redis.conf 파일에 대한 변경사항은 <code>docker-entrypoint.sh</code> 파일을 통해 redis.conf 파일 정보를 replace하였습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -e</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">## from redis-5.0</span></span><br><span class=\"line\"><span class=\"comment\"># Redis서버에 접근가능한 Host를 설정합니다.</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/bind 127.0.0.1/bind <span class=\"variable\">$CLIENTHOST</span> 127.0.0.1/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### redis port inside redis.conf</span></span><br><span class=\"line\"><span class=\"comment\">#redis.conf 파일의 port 6379 문자열을 port $CLINETPORT로 변경합니다. </span></span><br><span class=\"line\"><span class=\"comment\">#($CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.)</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/port 6379/port <span class=\"variable\">$CLIENTPORT</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># requirepass foobared 문자열을 requirepass $REQUIREPASS로 변경하였습니다. </span></span><br><span class=\"line\"><span class=\"comment\">#(Redis 접속 시 비밀번호를 설정하였습니다.)</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# requirepass foobared/requirepass <span class=\"variable\">$REQUIREPASS</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf          </span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# masterauth &lt;master-password&gt;/masterauth <span class=\"variable\">$REQUIREPASS</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### slaveof &lt;masterip&gt; &lt;masterport&gt; =&gt; slaveof $MASTERHOST $MASTERPORT</span></span><br><span class=\"line\"><span class=\"comment\"># $MASTERPORT가 공백이 아닌 Container에 대해 slaveof 설정을 통해 Master-Slave 설정을 합니다.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$MASTERPORT</span>\"</span> != <span class=\"string\">\"\"</span> ];<span class=\"keyword\">then</span></span><br><span class=\"line\">    sed -i <span class=\"string\">\"s/# slaveof &lt;masterip&gt; &lt;masterport&gt;/slaveof <span class=\"variable\">$MASTERHOST</span> <span class=\"variable\">$MASTERPORT</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf  </span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># first arg is `-f` or `--some-option`</span></span><br><span class=\"line\"><span class=\"comment\"># or first arg is `something.conf`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$&#123;1#-&#125;</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> ] || [ <span class=\"string\">\"<span class=\"variable\">$&#123;1%.conf&#125;</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">set</span> -- redis-server <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># allow the container to be started with `--user`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> = <span class=\"string\">'redis-server'</span> -a <span class=\"string\">\"<span class=\"variable\">$(id -u)</span>\"</span> = <span class=\"string\">'0'</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    chown -R redis .</span><br><span class=\"line\">    <span class=\"built_in\">exec</span> su-exec redis <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">exec</span> <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"redis-cluster-실행-결과\">Redis Cluster 실행 결과</h1>\n<p>Redis.log\n<img src=\"./redis-replication-3746317.PNG\" alt=\"redis-replication\"></p>\n<p>로그에서 0 clients connected (2 slaves) 라는 로그가 보입니다.\nRedis에 접속한 클라이언트 수는 0 client이며\n2개의 slave redis와 연결하고 있습니다.</p>\n<p>중간부분 로그에서 로그를 보면 slave로 설정한 Redis와 연동이 되는 것을 확인 할 수 있습니다.</p>\n<p>redis-cli &gt; info replication\n<img src=\"./redis-replication2-3746337.PNG\" alt=\"redis-replication2\"></p>\n<p>redis-cli에서 info replication 명령을 실행하였을 때, 조회되는 내용입니다.\nslave0, slave1에 대한 참조를 가지고 있는 것을 확인 할 수 있습니다.</p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>https://redis.io/topics/cluster-tutorial</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>Redis Cluster 구성도</h1>\n<p><img src=\"./Redis-Cluster-archi.PNG\" alt=\"Redis-Cluster-archi\"></p>\n<p>간단하게 정리하면.</p>\n<ul>\n<li>각 서버 별로 Redis 3대를 설치. Master 1개, Slave 2개로 구성하여 Replication을 지원할 수 있도록 Cluster를 구성하였습니다.</li>\n<li>각 서버 별로 Sentinel 3대를 설치. 양대비 원리에 맞추어 홀수개로 설정 하였습니다.</li>\n<li>각각의 서버의 Sentinel 3대가 서버의 Master Redis를 감시합니다. (Failover 대기)</li>\n<li>Redis Cluster를 서버 3대에 설치. Data Sharding을 하기 위해 저장소를 3개로 분리하였습니다.</li>\n<li>HAProxy로 분산 처리 구축. 5000, 5002, 5004번 포트는 각 서버의 Master Redis를 바라봅니다.</li>\n<li>5001, 5003, 5005번 포트는 각 서버의 Slave Redis 2대씩 바라봅니다.</li>\n</ul>\n<p>지금부터 Redis Cluster를 어떻게 설치 하였는지 설치 과정에 대해 알아보도록 하겠습니다.</p>\n<h1>Docker를 이용한 Redis Cluster 설치</h1>\n<p>Redis-Cluster를 설치하는 순서는 아래와 같습니다. (CentOS 7기준으로 설치 하였습니다.)</p>\n<ul>\n<li>Git 설치 (미리 올려둔 Docker file들을 다운받기 위함)</li>\n<li>Docker 설치</li>\n<li>Docker-Compose 설치</li>\n<li>Docker Build</li>\n</ul>\n<h2>Git 설치 + Docker file 다운로드</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># git설치</span></span><br><span class=\"line\">yum -y install git</span><br><span class=\"line\">git --version <span class=\"comment\"># git 버전 확인</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#Redis-Cluster 디렉터리 생성</span></span><br><span class=\"line\">mkdir -p /home/redis/redis-cluster</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#Redis-Cluster-Home 이동</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/redis/redis-cluster</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#아래 디렉터리들은 각 Redis Container의 외부볼륨으로 설정하기 위해 생성하였습니다.</span></span><br><span class=\"line\"><span class=\"comment\">#==&gt; Container 외부 볼륨을 설정해야 Redis Container가 삭제되더라도 Data가 보존됩니다.</span></span><br><span class=\"line\"><span class=\"comment\">#===&gt; dump.rdb 파일이 생성되는 장소</span></span><br><span class=\"line\">mkdir -p ./redis-data/redis1</span><br><span class=\"line\">mkdir -p ./redis-data/redis2</span><br><span class=\"line\">mkdir -p ./redis-data/redis3</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#Docker file Download</span></span><br><span class=\"line\"><span class=\"comment\">#설치파일을 다운받습니다.</span></span><br><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin <span class=\"string\">\"https://github.com/jaehun2841/redis-cluster-on-docker.git\"</span></span><br><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure></p>\n<h2>Docker 설치</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#docker 설치</span></span><br><span class=\"line\">curl -fsSL https://get.docker.com/ | sh</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#docker 설치 후 docker 시작</span></span><br><span class=\"line\">service docker start</span><br></pre></td></tr></table></figure></p>\n<p>Docker를 yum으로도 설치가 가능하지만 버전이 낮아 Docker-compose를 설치 할 수 없습니다.\n차후에 update까지 필요하니 위 url에서 제공하는 shell script를 실행하여 설치하도록 합니다.\n<strong>※ 위 Script는 sudo 명령 또는 root 권한을 필요로 합니다.</strong></p>\n<p>Docker 설치 내용은 2장에서 기술한 내용을 참고하시길 바랍니다.</p>\n<h2>Docker-Compose 설치</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#docker 공식 github에서 다운로드</span></span><br><span class=\"line\">sudo curl -L <span class=\"string\">\"https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class=\"variable\">$(uname -s)</span>-<span class=\"variable\">$(uname -m)</span>\"</span> -o /usr/<span class=\"built_in\">local</span>/bin/docker-compose</span><br><span class=\"line\"></span><br><span class=\"line\">chmod +x /usr/<span class=\"built_in\">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></p>\n<p>Docker-Compose 설치 내용은 4장에서 기술한 내용을 참고하시길 바랍니다.</p>\n<h2>Docker build</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis-cluster home 이동</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/redis/redis-cluster</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#docker build</span></span><br><span class=\"line\">docker-compose -f conf/docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>-f 옵션으로 docker-compose.yml 파일을 설정합니다.\n(docker-compose.yml 파일은 github redis-cluster 설치파일을 받을때 다운 받았습니다. )</li>\n<li>up 명령으로 docker container를 실행합니다.</li>\n<li>--build 옵션으로 build후 container를 실행합니다.</li>\n<li>-d 옵션으로 background로 실행되도록 합니다.\n(-d 옵션을 빼면 redis의 로그가....나오며 exit하는 순간 container가 stop됩니다.)</li>\n</ul>\n<h1>Redis Cluster를 빌드하기 위한 docker-compose.yml 파일</h1>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'3'</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"attr\">redis-master:</span></span><br><span class=\"line\">     <span class=\"attr\">image:</span> <span class=\"attr\">redis:5.0-alpine</span>   <span class=\"comment\"># image 옵션으로 redis공식이미지를 기반으로 생성합니다.</span></span><br><span class=\"line\">     <span class=\"attr\">build:</span></span><br><span class=\"line\">       <span class=\"attr\">context:</span> <span class=\"string\">..</span>             <span class=\"comment\"># build file에 대한 context를 지정</span></span><br><span class=\"line\">       <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span>  <span class=\"comment\">#dockerfile명을 지정합니다. (Default는 \"Dockerfile\" 파일명을 가진 파일을 실행합니다.)</span></span><br><span class=\"line\">     <span class=\"attr\">network_mode:</span> <span class=\"string\">\"host\"</span>      <span class=\"comment\"># Image가 Container가 되었을때 network모드를 host모드로 설정합니다 (docker0 인터페이스를 사용하지 않고 Host OS의 eth0 인터페이스 사용)</span></span><br><span class=\"line\">     <span class=\"attr\">environment:</span>              <span class=\"comment\"># Container 내부에서 사용 할 환경변수를 설정합니다.</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">REQUIREPASS=password1234</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">CLIENTPORT=6379</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MASTERHOST=</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MASTERPORT=</span></span><br><span class=\"line\">     <span class=\"attr\">volumes:</span>  <span class=\"comment\"># Host OS의 디렉터리와 Container내의 디렉터리와 연동합니다.</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"../redis-data/redis1:/data\"</span></span><br><span class=\"line\">     <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"attr\">redis-slave1:</span></span><br><span class=\"line\">     <span class=\"attr\">image:</span> <span class=\"attr\">redis:5.0-alpine</span></span><br><span class=\"line\">     <span class=\"attr\">build:</span></span><br><span class=\"line\">       <span class=\"attr\">context:</span> <span class=\"string\">..</span></span><br><span class=\"line\">       <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\">     <span class=\"attr\">network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\">     <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">REQUIREPASS=password1234</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">CLIENTPORT=6380</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MASTERPORT=6379</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MASTERHOST=192.168.137.101</span></span><br><span class=\"line\">     <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"../redis-data/redis2:/data\"</span></span><br><span class=\"line\">     <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"attr\">redis-slave2:</span></span><br><span class=\"line\">     <span class=\"attr\">image:</span> <span class=\"attr\">redis:5.0-alpine</span></span><br><span class=\"line\">     <span class=\"attr\">build:</span></span><br><span class=\"line\">       <span class=\"attr\">context:</span> <span class=\"string\">..</span></span><br><span class=\"line\">       <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\">     <span class=\"attr\">network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\">     <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">REQUIREPASS=password1234</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">CLIENTPORT=6381</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MASTERPORT=6379</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MASTERHOST=192.168.137.101</span> </span><br><span class=\"line\">     <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"../redis-data/redis3:/data\"</span></span><br><span class=\"line\">     <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><strong>Redis Container의 Network모드가 Host인 이유</strong>\nRedis 공식 홈페이지의 cluster-tutorial에서 발췌한 내용입니다.</p>\n<blockquote>\n<p>Redis Cluster and Docker</p>\n<p>Currently Redis Cluster does not support NATted environments and in general environments where IP addresses or TCP ports are remapped.\nDocker uses a technique called port mapping: programs running inside Docker containers may be exposed with a different port compared to the one the program believes to be using.\nThis is useful in order to run multiple containers using the same ports, at the same time, in the same server.\n<code>In order to make Docker compatible with Redis Cluster you need to use the host networking mode of Docker.</code> Please check the --net=host option in the Docker documentation for more information.</p>\n</blockquote>\n<p>Redis Cluster에서는 NAT환경과 IP주소 또는 TCP포트가 재 매핑되는 환경을 지원하지 않는다고 합니다.\n따라서 Docker에서 Redis Cluster를 호환되게 하기 위해서는 Host 모드로 사용할 것을 권고하고 있습니다.</p>\n</blockquote>\n<h1>Redis Container 생성을 위한 Dockerfile 작성</h1>\n<p>Docker-Compose build를 사용하면서 Dockerfile에는 Redis Container를 구성하는 공통적인 로직을 담았습니다.\n주로 내부에서 file을 생성하거나 Host OS의 파일을 Container가 생성하는 시점에 복사하기 위한 로직이 주로 들어있습니다.\n그리고 접근권한이 막혀 파일이 실행되지 않는 문제를 해결하기 위해 접근권한을 변경하였습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM redis:5.0-alpine //redis 이미지를 기반으로 빌드됨을 의미합니다.</span><br><span class=\"line\"> </span><br><span class=\"line\">MAINTAINER Carrey (jaehun2841@gmail.com)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Copy Redis File</span></span><br><span class=\"line\"><span class=\"comment\"># 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 합니다.</span></span><br><span class=\"line\"><span class=\"comment\"># 기존의 docker-entryporint.sh 파일을 삭제합니다.</span></span><br><span class=\"line\">RUN rm -rf /usr/<span class=\"built_in\">local</span>/bin/docker-entrypoint.sh  </span><br><span class=\"line\"><span class=\"comment\"># 공통적으로 적용할 redis.conf 파일을 복사합니다.</span></span><br><span class=\"line\">ADD redis.conf /usr/<span class=\"built_in\">local</span>/bin/redis.conf    </span><br><span class=\"line\"><span class=\"comment\"># Container가 생성, 시작하는 시점에 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.</span></span><br><span class=\"line\">ADD docker-entrypoint.sh /usr/<span class=\"built_in\">local</span>/bin        </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">## change access authority</span></span><br><span class=\"line\">RUN chmod 755 /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">RUN chmod 755 /usr/<span class=\"built_in\">local</span>/bin/docker-entrypoint.sh</span><br><span class=\"line\"> </span><br><span class=\"line\">RUN chown redis:redis /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">RUN chown redis:redis /usr/<span class=\"built_in\">local</span>/bin/docker-entrypoint.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Redis Container에 대한 Port를 지정합니다. (내부포트이며 외부노출은 안됨)</span></span><br><span class=\"line\">EXPOSE <span class=\"variable\">$CLIENTPORT</span> <span class=\"comment\">#CLIENTPORT에 대한 값은 docker-compose.yml에 정의되어 있습니다.          </span></span><br><span class=\"line\"><span class=\"comment\"># Container가 생성, 시작하는 시점에 실행됩니다.</span></span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"/usr/local/bin/docker-entrypoint.sh\"</span>] </span><br><span class=\"line\"><span class=\"comment\"># Container 빌드가 완료되고 Redis Server를 실행시킵니다.</span></span><br><span class=\"line\">CMD [ <span class=\"string\">\"redis-server\"</span>,<span class=\"string\">\"/usr/local/bin/redis.conf\"</span> ]</span><br></pre></td></tr></table></figure></p>\n<h1>Redis Cluster 설정</h1>\n<p>Redis Cluster에 대한 Replication 설정에 대해 알아보겠습니다.</p>\n<p>설정 방법은 redis.conf 파일을 각 Container로 복사하여 공통적인 설정을 하였습니다.\n각 redis.conf 파일에 대한 변경사항은 <code>docker-entrypoint.sh</code> 파일을 통해 redis.conf 파일 정보를 replace하였습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -e</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">## from redis-5.0</span></span><br><span class=\"line\"><span class=\"comment\"># Redis서버에 접근가능한 Host를 설정합니다.</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/bind 127.0.0.1/bind <span class=\"variable\">$CLIENTHOST</span> 127.0.0.1/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### redis port inside redis.conf</span></span><br><span class=\"line\"><span class=\"comment\">#redis.conf 파일의 port 6379 문자열을 port $CLINETPORT로 변경합니다. </span></span><br><span class=\"line\"><span class=\"comment\">#($CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.)</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/port 6379/port <span class=\"variable\">$CLIENTPORT</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># requirepass foobared 문자열을 requirepass $REQUIREPASS로 변경하였습니다. </span></span><br><span class=\"line\"><span class=\"comment\">#(Redis 접속 시 비밀번호를 설정하였습니다.)</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# requirepass foobared/requirepass <span class=\"variable\">$REQUIREPASS</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf          </span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# masterauth &lt;master-password&gt;/masterauth <span class=\"variable\">$REQUIREPASS</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### slaveof &lt;masterip&gt; &lt;masterport&gt; =&gt; slaveof $MASTERHOST $MASTERPORT</span></span><br><span class=\"line\"><span class=\"comment\"># $MASTERPORT가 공백이 아닌 Container에 대해 slaveof 설정을 통해 Master-Slave 설정을 합니다.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$MASTERPORT</span>\"</span> != <span class=\"string\">\"\"</span> ];<span class=\"keyword\">then</span></span><br><span class=\"line\">    sed -i <span class=\"string\">\"s/# slaveof &lt;masterip&gt; &lt;masterport&gt;/slaveof <span class=\"variable\">$MASTERHOST</span> <span class=\"variable\">$MASTERPORT</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf  </span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># first arg is `-f` or `--some-option`</span></span><br><span class=\"line\"><span class=\"comment\"># or first arg is `something.conf`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$&#123;1#-&#125;</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> ] || [ <span class=\"string\">\"<span class=\"variable\">$&#123;1%.conf&#125;</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">set</span> -- redis-server <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># allow the container to be started with `--user`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> = <span class=\"string\">'redis-server'</span> -a <span class=\"string\">\"<span class=\"variable\">$(id -u)</span>\"</span> = <span class=\"string\">'0'</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    chown -R redis .</span><br><span class=\"line\">    <span class=\"built_in\">exec</span> su-exec redis <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">exec</span> <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<h1>Redis Cluster 실행 결과</h1>\n<p>Redis.log\n<img src=\"./redis-replication-3746317.PNG\" alt=\"redis-replication\"></p>\n<p>로그에서 0 clients connected (2 slaves) 라는 로그가 보입니다.\nRedis에 접속한 클라이언트 수는 0 client이며\n2개의 slave redis와 연결하고 있습니다.</p>\n<p>중간부분 로그에서 로그를 보면 slave로 설정한 Redis와 연동이 되는 것을 확인 할 수 있습니다.</p>\n<p>redis-cli &gt; info replication\n<img src=\"./redis-replication2-3746337.PNG\" alt=\"redis-replication2\"></p>\n<p>redis-cli에서 info replication 명령을 실행하였을 때, 조회되는 내용입니다.\nslave0, slave1에 대한 참조를 가지고 있는 것을 확인 할 수 있습니다.</p>\n<h1>참고</h1>\n<ul>\n<li>https://redis.io/topics/cluster-tutorial</li>\n</ul>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (7) Docker를 이용한 Redis Sentinel 설치하기","date":"2018-12-02T06:46:07.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-12-02-docker-7","typora-copy-images-to":"2018-12-02-docker-7","_content":"\n\n\n# Redis Sentinel이란?\n\nRedis Cluster 운영환경에서 Master-Slave 관계를 가진 Redis가 있습니다.\n시스템 오류나 알수 없는 원인으로 인해 Master Redis가 down되어 연결이 중단 되면, 사용자나 Application에서는 Redis Master를 통해 데이터를 등록 할 수 없게 됩니다.\n이런 경우 Slave Redis를 Master Redis로 승격시켜 시스템이 정상적으로 운영 될 수 있도록 해야 합니다.\n\n이 때 사용하는 게 Redis Sentinel입니다.\nSentinel은 Master Redis의 상태를 감시합니다. 그러다가 Master Redis가 Down이 되어버리면, Sentinel들은 Slave Redis들 중에 어떤 Redis 서버를 Master로 승격시킬지 투표하게 됩니다.\nSlave Redis 중 Sentinel의 투표를 더 많이 받은 Redis Server가 Master Redis로 승격됩니다.\n이후 장애를 해결한 원래 Master Redis는 재시작 시, 현재 Master Redis의 Slave Redis로 시작되게 됩니다.\n\n이와같이, Redis Sentinel은 Redis Cluster 환경에서의 Failover를 자동으로 해주는 Redis의 한 Mode입니다.\n\n\n\n# Role Change 원리\n\n![Redis-failover-1](./Redis-failover-1.PNG)\n\n위의 상황은 6379 포트를 사용하는 Master Redis가 Down된 상황입니다.\nSentinel들은 일제히 Master Redis를 감시하다가 Down된 상황을 인지하고\n2번째 그림처럼 Slave Redis들 중 어떤 Redis 서버를 Master Redis로 승격할 지 투표로 정하게 됩니다.\n여기서 중요한 건 Redis Sentinel의 노드 갯수는 `항상 홀수로 설정`해야 합니다. (짝수 인 경우 1:1, 2:2 상황이 되어 어떤 Redis Server를 승격 시킬지 알 수 없기 때문입니다.)\n위의 예제에서는 15485 번 포트를 사용하는 Slave Redis가 2대1로 선택되었습니다.\nSentinel은 바로 redis.conf 파일을 조작하여 Slave Redis를 Master Redis로 변경합니다.\n그리고 자기 자신의 sentinel.conf 정보를 조작하여 감시하는 Redis 서버 정보를 update 합니다.\n이후 Down되었던 기존의 Master Redis의 장애가 처리되어 Restart되는 경우를 보도록 하겠습니다. \n\n\n\n![Redis-failover-2](./Redis-failover-2.PNG)\n\nSentinel은 Down되었던 Master 정보를 메모리에 저장하고 있습니다.\n이후 Down되었던 Master Redis가 장애를 처리하고 다시 시작 되는 경우, Master Redis의 redis.conf 파일을 조작하여 \n현재 Master Redis의 Slave로 설정합니다.\n\n>이 경우 Sentinel의 설정 값이 따라 다르지만,\n>일시적으로 Master Redis가 2대가 됩니다.\n>만약에 Down 되었다가 Restart된 Redis에 Data가 저장되는 경우, Slave Redis로 전환되면서 Master의 rdb파일을 바탕으로 Data를 Update하기 때문에 데이터가 사라지는 상황이 오게 됩니다.\n>따라서 Down 되었다가 살아나는 Redis에 접근 하지 못하도록 막아야 합니다. \n\n\n\n# Redis Sentinel 설치하기\n\nDocker, Docker-Compose, git은 Redis Cluster를 설치하며 설치 했다고 가정하겠습니다.\n\n\n\n## Redis Sentinel 파일 다운로드\n\n기존에 github에 올려둔 Sentienel 설정파일을 다운로드 합니다.\n\n```sh\n\nmkdir -p /home/redis/redis-sentinel #Redis-sentinel home 생성\ncd /home/redis\nmkdir -p ./sentinel-data/sentinel1   #외부 log파일 볼륨 설정\nmkdir -p ./sentinel-data/sentinel2\nmkdir -p ./sentinel-data/sentinel3\n \ngit init\ngit remote add origin \"https://github.com/jaehun2841/redis-sentinel-on-docker.git\"\ngit pull origin master #github에서 sentinel 설정 파일 다운로드\n```\n\n\n\n## Redis sentinel Build\n\n```sh\ncd /home/redis/redis-sentinel\ndocker-compose -f conf/sentinel-docker-compose.yml up --build -d \n```\n\n\n\n# Redis Sentinel 생성을 위한 docker-compose.yml파일 \n\n```yml\n\nversion: '3'\nservices:\n \n  redis-sentinel1:                        #Sentinel Container명\n     image: lgatica/redis-sentinel:4.0.2  #redis-sentinel 이미지를 바탕으로 빌드합니다.\n     build:\n       context: ..                        #Dockerfile context 설정\n       dockerfile: Dockerfile             #Dockerfile명 설정 (Default는 Dockerfile로 된 파일명을 찾습니다.)\n     network_mode: \"host\"\n     environment:                         #Container에서 사용할 환경 변수 설정\n      - CLIENTHOST=192.168.137.101\n      - CLIENTPORT=26379\n      - MASTERHOST=192.168.137.101\n      - MASTERPORT=6379                   #Sentinel의 mymaster port를 적어줍니다.\n      - QUORUM=2                          #QUORUM 값은 Sentinel들이 투표했을때 득표수가 2 이상인 Redis에 대해 Master로 승격할 수 있도록 하는 조건 값입니다.\n      - DOWN_AFTER_MILLISEC=3000          #Redis master node down 후 3초 이후 failover 시작\n      - FAILOVER_TIMEOUT=3000\n      - REQUIREPASS=password1234\n     volumes:\n      - \"../../sentinel-data/sentinel1:/redis\"  #Container 외부 볼륨 설정\n     restart: always                         #restart policy Container가 중지되거나 down되는 경우 무조건 다시 시작합니다.\n \n  redis-sentinel2:\n     image: lgatica/redis-sentinel:4.0.2\n     build:\n       context: ..\n       dockerfile: Dockerfile\n     network_mode: \"host\"\n     environment:\n      - CLIENTHOST=192.168.137.101\n      - CLIENTPORT=26380\n      - MASTERHOST=192.168.137.101\n      - MASTERPORT=6379\n      - QUORUM=2\n      - DOWN_AFTER_MILLISEC=3000\n      - FAILOVER_TIMEOUT=3000\n      - REQUIREPASS=password1234\n     volumes:\n      - \"../../sentinel-data/sentinel2:/redis\"\n     restart: always\n \n  redis-sentinel3:\n     image: lgatica/redis-sentinel:4.0.2\n     build:\n       context: ..\n       dockerfile: Dockerfile\n     network_mode: \"host\"\n     environment:\n      - CLIENTHOST=192.168.137.101\n      - CLIENTPORT=26381\n      - MASTERHOST=192.168.137.101\n      - MASTERPORT=6379\n      - QUORUM=2\n      - DOWN_AFTER_MILLISEC=3000\n      - FAILOVER_TIMEOUT=3000\n      - REQUIREPASS=password1234\n     volumes:\n      - \"../../sentinel-data/sentinel3:/redis\"\n     restart: always\n```\n\n\n\n# Redis Sentinel 이미지 생성을 위한 Dockerfile 작성\n\n```sh\n#redis-sentinel 이미지 기반으로 빌드합니다.\nFROM lgatica/redis-sentinel:4.0.2   \n \nMAINTAINER Carrey \n \n## Copy Redis File\n## 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 한다.\n# 기존 container의 sentinel-entrypoint.sh 삭제합니다.\nRUN rm -rf /usr/local/bin/sentinel-entrypoint.sh         \n\n# sentinel 설정이 담긴 sentinel.conf 파일 복사합니다.\nADD sentinel.conf /usr/local/bin/sentinel.conf                          \n\n# sentinel container 시작 시, 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.\nADD sentinel-entrypoint.sh /usr/local/bin/sentinel-entrypoint.sh         \n \n## change access authority\n# 복사한 파일에 대한 권한을 변경합니다. (Permission Denied 문제)\nRUN chmod 755 /usr/local/bin/sentinel.conf                               \nRUN chmod 755 /usr/local/bin/sentinel-entrypoint.sh\nRUN chown redis:redis /usr/local/bin/sentinel.conf\nRUN chown redis:redis /usr/local/bin/sentinel-entrypoint.sh\n \n# Redis Container에 대한 Port를 지정합니다. (host 모드이기 때문에 외부 노출)\nEXPOSE $CLIENTPORT                                    \n\n# Container가 생성, 시작하는 시점에 실행됩니다.\nENTRYPOINT [\"/usr/local/bin/sentinel-entrypoint.sh\"]        \n\n# Container 빌드가 완료되고 Sentinel Server를 실행시킵니다. \n# conf 파일 뿐만 아니라 --sentinel 옵션을 추가하여 Redis가 Sentinel 모드로 실행 되도록 합니다.\n# Sentinel 또한 Redis Server이지만, Sentinel 설정을 하여 실행 시키는 것 뿐입니다.\nCMD [ \"redis-server\",\"/usr/local/bin/sentinel.conf\", \"--sentinel\" ]                          \n```\n\n\n\n# Redis Sentinel 설정\n\n```sh\n\n#!/bin/sh\nset -e\n \n# bind 127.0.0.1 문자열을 각 이미지에서 설정한 $CLIENTHOST 값으로 변경합니다. \n# $CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.\nsed -i \"s/bind 127.0.0.1/bind $CLIENTHOST/g\" /usr/local/bin/sentinel.conf      \n         \n# port 6379 문자열을 각 이미지에서 설정한 $CLIENTPORT 값으로 변경합니다. \n# Sentinel 이미지 별로 port다르게 설정\nsed -i \"s/port 6379/port $CLIENTPORT/g\" /usr/local/bin/sentinel.conf  \n \n# sentinel에 대한 mymaster를 설정하는 부분입니다. \n# 실제 Master Redis의 ip와 port를 설정하고 QUORUM 값을 설정합니다.\n# QUORUM 값은 Slave->Master Role Change 시, slave redis가 받아야 하는 최소 투표 수 입니다.\nsed -i \"s/sentinel monitor mymaster 127.0.0.1 6379 2/sentinel monitor mymaster $MASTERHOST $MASTERPORT $QUORUM/g\" /usr/local/bin/sentinel.conf\n \n# Redis server가 다운되고 후처리 실행 시간 까지 걸리는 시간을 지정합니다. \n# ex)3000 -> 3000 밀리세컨드 -> 3초\nsed -i \"s/sentinel down-after-milliseconds mymaster 30000/sentinel down-after-milliseconds mymaster $DOWN_AFTER_MILLISEC/g\" /usr/local/bin/sentinel.conf\n \n# Redis failover timeout 시간을 설정 합니다.\nsed -i \"s/sentinel failover-timeout mymaster 180000/sentinel failover-timeout mymaster $FAILOVER_TIMEOUT/g\" /usr/local/bin/sentinel.conf\n \n# sentinel이 master redis에 접근할 때 인증하는 비밀번호를 설정합니다.\nsed -i \"s/# sentinel auth-pass mymaster MySUPER--secret-0123passw0rd/sentinel auth-pass mymaster $REQUIREPASS/g\" /usr/local/bin/sentinel.conf\n \n \n# first arg is `-f` or `--some-option`\n# or first arg is `something.conf`\nif [ \"${1#-}\" != \"$1\" ] || [ \"${1%.conf}\" != \"$1\" ]; then\n    set -- redis-server \"$@\"\nfi\n \n# allow the container to be started with `--user`\nif [ \"$1\" = 'redis-server' -a \"$(id -u)\" = '0' ]; then\n    chown -R redis .\n    exec su-exec redis \"$@\"\nfi\n \nexec \"$@\"\n```\n\n\n\n# Redis Sentinel 실행 결과\n\n```sh\ndocker-compose -f conf/sentinel-docker-compose.yml up --build -d \n```\n\n\n\n![redis-sentinel-log](./redis-sentinel-log.PNG)\n\nsentinel 1~3 까지의 로그를 모아보았습니다.\n테스트용 port인 (6379~6381) 에 대한 master/slave 정보를 가지고 있는것을 볼수 있습니다.\n\n로그처럼\n\n\n```log\nredis-sentinel2_1  | 1:X 02 Dec 10:06:24.082 # +monitor master mymaster 192.168.137.101 6379 quorum 2\n```\nsentinel이 자신의 마스터에 대한 정보를 가지고 모니터 하며 quorum 2를 가지고 있는 것을 볼 수 있습니다.\n\n\n\n# Failover Test\n\n자, Failover를 구성 했으니 실제로 Master를 한번 죽여보도록 해보겠습니다.\n\n```sh\ndocker stop <master_node_id> # Redis Master Container를 중지\n```\n\n![redis-failover-log](./redis-failover-log.PNG)\n\n맨 처음 로그를 살펴보면 각 sentinel 노드에서 sdown 시그널을 발생시키고 있습니다.\n\n중간정도 줄을 보면\n\n```sh\n+odown master mymaster 192.168.137.101 6379 #quorum 3/2\n```\n\n라는 로그가 나오게 되는데 3개의 sentinel에서 모두 sdown으로 인지하게 되는것입니다.\n3/2의 뜻은  2개 노드에서 sdown이 발생 했을 때, odown 판정을 내린다는 다수결 투표 숫자입니다.\n그런데 3개의 노드가 모두 투표를 하여 과반수 이상이 되었으므로 192.168.137.101 6379인 Redis 노드는 odown상태가 되었습니다.\n\n그 바로 다음 줄 부터 failover 작업이 시작됩니다.\n위의 예제에서는 6380 포트를 사용하는 redis노드가 새로운 마스터로 선출 되었습니다.\n따라서 6380 포트를 사용하는 redis노드는 master로 role-change가 되면서 master 노드로써 역할을 수행하게 됩니다.\n\n이렇게 Redis Sentinel을 이용하여 master node를 감시하며, 장애 상황에 대한 failover를 지원하고 있습니다.\n\n\n\n## sdown vs odown\n\nSentinel에서 down을 판단하는 방법은 `sdown`과 `odown`으로 이루어집니다.\nfailover 시 Master가 죽었다는 걸 판단하기 위해서는 `다수결의 원칙`이 적용됩니다. (그래서 Sentinel노드 갯수를 홀수로 설정하는 이유입니다.)\n\n먼저, Master가 죽게 되면 Sentinel은 자신이 감시하고 있는 Master가 죽었다고 sdown 시그널을 표현합니다 (`Subjective Down` 이라 합니다.)\nsdown은 단지 Master와 Sentinel 자기 자신이 연결이 되지 않음을 의미합니다.\n\n위에서 보듯이 Master가 죽었으니 다른 Sentinel들도 연결이 끊어졌다고 sdown 시그널을 보냅니다.\n그렇게 되면 다수결에 원칙에 따라 quorum값 만큼의 sdown이 발생하면 sentinel은 odown 시그널을 보냅니다. (`Objective Down`이라 합니다.)\n\nodown은 다수결에 의해서 명시적으로 Master가 Down되었다고 선포하는 것과 같습니다.\n그렇게 되면 Sentinel들은 다음 Master를 선출하기 위해 남아있는 Slave Redis들에게 투표를 하게 됩니다.\n다수결의 원칙으로 더 많은 투표수를 받은 Slave가 Master로 선출되게 됩니다.\n\n\n\n## 중단되었던 6379 포트를 사용하는 Redis 노드가 살아나면?\n\n아까 stop했던 container를 다시 살려보겠습니다.\n\n```sh\ndocker start <redis1_node_id>\n```\n\n![redis-failover-3](./redis-failover-3-3748019.PNG)\n\n3번째 줄부터 보시면, sentinel에서 `-sdown` 로그를 찍어주고 있습니다.\nsentinel에서 연결되지 않았던 6379번 노드에 대해 정상적으로 커넥션이 맺어지고 있기 때문입니다.\n중간 줄 부터 보게 되면다른 sentinel 노드에서도 `-sdown` 로그를 찍어주며 6379번 노드에 대한 부활을 알려주고 있습니다.\n\n그런 다음에 `+convert-to-slave` 로그를 보면, 기존의 6379번 노드는 원래 master role을 수행 하던 Redis 노드였습니다.\n하지만 현재 sentinel에 대한 mymaster는 6380번 노드이기 때문에 6379번 노드는 master role을 수행 할 수 없습니다.\n\n따라서  `+role-change` 명령을 통해  기존에 master role -> slave role로 변경되어야 합니다.\n그리고 현재 master role 권한이 있는 6380번 노드의 slave으로 편입되게 됩니다.\nredis-cli를 통해 6379번 노드에 접속하여 `info replication` 명령을 날려보았습니다.\n\n![redis-failover-4](./redis-failover-4.PNG)\n\n현재 role은 `slave` 이며, 6380번 노드를 master로 설정하고 있습니다.\n\n\n\n> **왜 기존의 master가 살아나면, slave로 전환하여 사용해야 할까?**\n>\n> 이유는 간단합니다. \n> Redis Master-Slave간 데이터 Replication을 이해 하면 쉽게 이해 할 수 있습니다\n> Redis의 데이터 Replication은 dump.rdb파일을 통해 이루어지는데, \n> master노드 만 dump.rdb파일에 데이터를 write 할 수 있습니다.\n> slave노드에서는 dump.rdb파일을 읽어서 데이터 replication을 하게 되는데,\n> 만약 기존의 master의 role이 유지된다면, dump.rdb파일을 조작하여 기존의 master가 다운된 시간 동안\n> 들어온 데이터가 삭제될 수 있습니다. \n> 그렇게 때문에 데이터 정합성을 위해 기존의 master는 slave로 role이 전환되어야 합니다.","source":"_posts/2018-12-02-docker-7.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (7) Docker를 이용한 Redis Sentinel 설치하기\ndate: 2018-12-02 15:46:07\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-12-02-docker-7\ntypora-copy-images-to: 2018-12-02-docker-7\n---\n\n\n\n# Redis Sentinel이란?\n\nRedis Cluster 운영환경에서 Master-Slave 관계를 가진 Redis가 있습니다.\n시스템 오류나 알수 없는 원인으로 인해 Master Redis가 down되어 연결이 중단 되면, 사용자나 Application에서는 Redis Master를 통해 데이터를 등록 할 수 없게 됩니다.\n이런 경우 Slave Redis를 Master Redis로 승격시켜 시스템이 정상적으로 운영 될 수 있도록 해야 합니다.\n\n이 때 사용하는 게 Redis Sentinel입니다.\nSentinel은 Master Redis의 상태를 감시합니다. 그러다가 Master Redis가 Down이 되어버리면, Sentinel들은 Slave Redis들 중에 어떤 Redis 서버를 Master로 승격시킬지 투표하게 됩니다.\nSlave Redis 중 Sentinel의 투표를 더 많이 받은 Redis Server가 Master Redis로 승격됩니다.\n이후 장애를 해결한 원래 Master Redis는 재시작 시, 현재 Master Redis의 Slave Redis로 시작되게 됩니다.\n\n이와같이, Redis Sentinel은 Redis Cluster 환경에서의 Failover를 자동으로 해주는 Redis의 한 Mode입니다.\n\n\n\n# Role Change 원리\n\n![Redis-failover-1](./Redis-failover-1.PNG)\n\n위의 상황은 6379 포트를 사용하는 Master Redis가 Down된 상황입니다.\nSentinel들은 일제히 Master Redis를 감시하다가 Down된 상황을 인지하고\n2번째 그림처럼 Slave Redis들 중 어떤 Redis 서버를 Master Redis로 승격할 지 투표로 정하게 됩니다.\n여기서 중요한 건 Redis Sentinel의 노드 갯수는 `항상 홀수로 설정`해야 합니다. (짝수 인 경우 1:1, 2:2 상황이 되어 어떤 Redis Server를 승격 시킬지 알 수 없기 때문입니다.)\n위의 예제에서는 15485 번 포트를 사용하는 Slave Redis가 2대1로 선택되었습니다.\nSentinel은 바로 redis.conf 파일을 조작하여 Slave Redis를 Master Redis로 변경합니다.\n그리고 자기 자신의 sentinel.conf 정보를 조작하여 감시하는 Redis 서버 정보를 update 합니다.\n이후 Down되었던 기존의 Master Redis의 장애가 처리되어 Restart되는 경우를 보도록 하겠습니다. \n\n\n\n![Redis-failover-2](./Redis-failover-2.PNG)\n\nSentinel은 Down되었던 Master 정보를 메모리에 저장하고 있습니다.\n이후 Down되었던 Master Redis가 장애를 처리하고 다시 시작 되는 경우, Master Redis의 redis.conf 파일을 조작하여 \n현재 Master Redis의 Slave로 설정합니다.\n\n>이 경우 Sentinel의 설정 값이 따라 다르지만,\n>일시적으로 Master Redis가 2대가 됩니다.\n>만약에 Down 되었다가 Restart된 Redis에 Data가 저장되는 경우, Slave Redis로 전환되면서 Master의 rdb파일을 바탕으로 Data를 Update하기 때문에 데이터가 사라지는 상황이 오게 됩니다.\n>따라서 Down 되었다가 살아나는 Redis에 접근 하지 못하도록 막아야 합니다. \n\n\n\n# Redis Sentinel 설치하기\n\nDocker, Docker-Compose, git은 Redis Cluster를 설치하며 설치 했다고 가정하겠습니다.\n\n\n\n## Redis Sentinel 파일 다운로드\n\n기존에 github에 올려둔 Sentienel 설정파일을 다운로드 합니다.\n\n```sh\n\nmkdir -p /home/redis/redis-sentinel #Redis-sentinel home 생성\ncd /home/redis\nmkdir -p ./sentinel-data/sentinel1   #외부 log파일 볼륨 설정\nmkdir -p ./sentinel-data/sentinel2\nmkdir -p ./sentinel-data/sentinel3\n \ngit init\ngit remote add origin \"https://github.com/jaehun2841/redis-sentinel-on-docker.git\"\ngit pull origin master #github에서 sentinel 설정 파일 다운로드\n```\n\n\n\n## Redis sentinel Build\n\n```sh\ncd /home/redis/redis-sentinel\ndocker-compose -f conf/sentinel-docker-compose.yml up --build -d \n```\n\n\n\n# Redis Sentinel 생성을 위한 docker-compose.yml파일 \n\n```yml\n\nversion: '3'\nservices:\n \n  redis-sentinel1:                        #Sentinel Container명\n     image: lgatica/redis-sentinel:4.0.2  #redis-sentinel 이미지를 바탕으로 빌드합니다.\n     build:\n       context: ..                        #Dockerfile context 설정\n       dockerfile: Dockerfile             #Dockerfile명 설정 (Default는 Dockerfile로 된 파일명을 찾습니다.)\n     network_mode: \"host\"\n     environment:                         #Container에서 사용할 환경 변수 설정\n      - CLIENTHOST=192.168.137.101\n      - CLIENTPORT=26379\n      - MASTERHOST=192.168.137.101\n      - MASTERPORT=6379                   #Sentinel의 mymaster port를 적어줍니다.\n      - QUORUM=2                          #QUORUM 값은 Sentinel들이 투표했을때 득표수가 2 이상인 Redis에 대해 Master로 승격할 수 있도록 하는 조건 값입니다.\n      - DOWN_AFTER_MILLISEC=3000          #Redis master node down 후 3초 이후 failover 시작\n      - FAILOVER_TIMEOUT=3000\n      - REQUIREPASS=password1234\n     volumes:\n      - \"../../sentinel-data/sentinel1:/redis\"  #Container 외부 볼륨 설정\n     restart: always                         #restart policy Container가 중지되거나 down되는 경우 무조건 다시 시작합니다.\n \n  redis-sentinel2:\n     image: lgatica/redis-sentinel:4.0.2\n     build:\n       context: ..\n       dockerfile: Dockerfile\n     network_mode: \"host\"\n     environment:\n      - CLIENTHOST=192.168.137.101\n      - CLIENTPORT=26380\n      - MASTERHOST=192.168.137.101\n      - MASTERPORT=6379\n      - QUORUM=2\n      - DOWN_AFTER_MILLISEC=3000\n      - FAILOVER_TIMEOUT=3000\n      - REQUIREPASS=password1234\n     volumes:\n      - \"../../sentinel-data/sentinel2:/redis\"\n     restart: always\n \n  redis-sentinel3:\n     image: lgatica/redis-sentinel:4.0.2\n     build:\n       context: ..\n       dockerfile: Dockerfile\n     network_mode: \"host\"\n     environment:\n      - CLIENTHOST=192.168.137.101\n      - CLIENTPORT=26381\n      - MASTERHOST=192.168.137.101\n      - MASTERPORT=6379\n      - QUORUM=2\n      - DOWN_AFTER_MILLISEC=3000\n      - FAILOVER_TIMEOUT=3000\n      - REQUIREPASS=password1234\n     volumes:\n      - \"../../sentinel-data/sentinel3:/redis\"\n     restart: always\n```\n\n\n\n# Redis Sentinel 이미지 생성을 위한 Dockerfile 작성\n\n```sh\n#redis-sentinel 이미지 기반으로 빌드합니다.\nFROM lgatica/redis-sentinel:4.0.2   \n \nMAINTAINER Carrey \n \n## Copy Redis File\n## 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 한다.\n# 기존 container의 sentinel-entrypoint.sh 삭제합니다.\nRUN rm -rf /usr/local/bin/sentinel-entrypoint.sh         \n\n# sentinel 설정이 담긴 sentinel.conf 파일 복사합니다.\nADD sentinel.conf /usr/local/bin/sentinel.conf                          \n\n# sentinel container 시작 시, 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.\nADD sentinel-entrypoint.sh /usr/local/bin/sentinel-entrypoint.sh         \n \n## change access authority\n# 복사한 파일에 대한 권한을 변경합니다. (Permission Denied 문제)\nRUN chmod 755 /usr/local/bin/sentinel.conf                               \nRUN chmod 755 /usr/local/bin/sentinel-entrypoint.sh\nRUN chown redis:redis /usr/local/bin/sentinel.conf\nRUN chown redis:redis /usr/local/bin/sentinel-entrypoint.sh\n \n# Redis Container에 대한 Port를 지정합니다. (host 모드이기 때문에 외부 노출)\nEXPOSE $CLIENTPORT                                    \n\n# Container가 생성, 시작하는 시점에 실행됩니다.\nENTRYPOINT [\"/usr/local/bin/sentinel-entrypoint.sh\"]        \n\n# Container 빌드가 완료되고 Sentinel Server를 실행시킵니다. \n# conf 파일 뿐만 아니라 --sentinel 옵션을 추가하여 Redis가 Sentinel 모드로 실행 되도록 합니다.\n# Sentinel 또한 Redis Server이지만, Sentinel 설정을 하여 실행 시키는 것 뿐입니다.\nCMD [ \"redis-server\",\"/usr/local/bin/sentinel.conf\", \"--sentinel\" ]                          \n```\n\n\n\n# Redis Sentinel 설정\n\n```sh\n\n#!/bin/sh\nset -e\n \n# bind 127.0.0.1 문자열을 각 이미지에서 설정한 $CLIENTHOST 값으로 변경합니다. \n# $CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.\nsed -i \"s/bind 127.0.0.1/bind $CLIENTHOST/g\" /usr/local/bin/sentinel.conf      \n         \n# port 6379 문자열을 각 이미지에서 설정한 $CLIENTPORT 값으로 변경합니다. \n# Sentinel 이미지 별로 port다르게 설정\nsed -i \"s/port 6379/port $CLIENTPORT/g\" /usr/local/bin/sentinel.conf  \n \n# sentinel에 대한 mymaster를 설정하는 부분입니다. \n# 실제 Master Redis의 ip와 port를 설정하고 QUORUM 값을 설정합니다.\n# QUORUM 값은 Slave->Master Role Change 시, slave redis가 받아야 하는 최소 투표 수 입니다.\nsed -i \"s/sentinel monitor mymaster 127.0.0.1 6379 2/sentinel monitor mymaster $MASTERHOST $MASTERPORT $QUORUM/g\" /usr/local/bin/sentinel.conf\n \n# Redis server가 다운되고 후처리 실행 시간 까지 걸리는 시간을 지정합니다. \n# ex)3000 -> 3000 밀리세컨드 -> 3초\nsed -i \"s/sentinel down-after-milliseconds mymaster 30000/sentinel down-after-milliseconds mymaster $DOWN_AFTER_MILLISEC/g\" /usr/local/bin/sentinel.conf\n \n# Redis failover timeout 시간을 설정 합니다.\nsed -i \"s/sentinel failover-timeout mymaster 180000/sentinel failover-timeout mymaster $FAILOVER_TIMEOUT/g\" /usr/local/bin/sentinel.conf\n \n# sentinel이 master redis에 접근할 때 인증하는 비밀번호를 설정합니다.\nsed -i \"s/# sentinel auth-pass mymaster MySUPER--secret-0123passw0rd/sentinel auth-pass mymaster $REQUIREPASS/g\" /usr/local/bin/sentinel.conf\n \n \n# first arg is `-f` or `--some-option`\n# or first arg is `something.conf`\nif [ \"${1#-}\" != \"$1\" ] || [ \"${1%.conf}\" != \"$1\" ]; then\n    set -- redis-server \"$@\"\nfi\n \n# allow the container to be started with `--user`\nif [ \"$1\" = 'redis-server' -a \"$(id -u)\" = '0' ]; then\n    chown -R redis .\n    exec su-exec redis \"$@\"\nfi\n \nexec \"$@\"\n```\n\n\n\n# Redis Sentinel 실행 결과\n\n```sh\ndocker-compose -f conf/sentinel-docker-compose.yml up --build -d \n```\n\n\n\n![redis-sentinel-log](./redis-sentinel-log.PNG)\n\nsentinel 1~3 까지의 로그를 모아보았습니다.\n테스트용 port인 (6379~6381) 에 대한 master/slave 정보를 가지고 있는것을 볼수 있습니다.\n\n로그처럼\n\n\n```log\nredis-sentinel2_1  | 1:X 02 Dec 10:06:24.082 # +monitor master mymaster 192.168.137.101 6379 quorum 2\n```\nsentinel이 자신의 마스터에 대한 정보를 가지고 모니터 하며 quorum 2를 가지고 있는 것을 볼 수 있습니다.\n\n\n\n# Failover Test\n\n자, Failover를 구성 했으니 실제로 Master를 한번 죽여보도록 해보겠습니다.\n\n```sh\ndocker stop <master_node_id> # Redis Master Container를 중지\n```\n\n![redis-failover-log](./redis-failover-log.PNG)\n\n맨 처음 로그를 살펴보면 각 sentinel 노드에서 sdown 시그널을 발생시키고 있습니다.\n\n중간정도 줄을 보면\n\n```sh\n+odown master mymaster 192.168.137.101 6379 #quorum 3/2\n```\n\n라는 로그가 나오게 되는데 3개의 sentinel에서 모두 sdown으로 인지하게 되는것입니다.\n3/2의 뜻은  2개 노드에서 sdown이 발생 했을 때, odown 판정을 내린다는 다수결 투표 숫자입니다.\n그런데 3개의 노드가 모두 투표를 하여 과반수 이상이 되었으므로 192.168.137.101 6379인 Redis 노드는 odown상태가 되었습니다.\n\n그 바로 다음 줄 부터 failover 작업이 시작됩니다.\n위의 예제에서는 6380 포트를 사용하는 redis노드가 새로운 마스터로 선출 되었습니다.\n따라서 6380 포트를 사용하는 redis노드는 master로 role-change가 되면서 master 노드로써 역할을 수행하게 됩니다.\n\n이렇게 Redis Sentinel을 이용하여 master node를 감시하며, 장애 상황에 대한 failover를 지원하고 있습니다.\n\n\n\n## sdown vs odown\n\nSentinel에서 down을 판단하는 방법은 `sdown`과 `odown`으로 이루어집니다.\nfailover 시 Master가 죽었다는 걸 판단하기 위해서는 `다수결의 원칙`이 적용됩니다. (그래서 Sentinel노드 갯수를 홀수로 설정하는 이유입니다.)\n\n먼저, Master가 죽게 되면 Sentinel은 자신이 감시하고 있는 Master가 죽었다고 sdown 시그널을 표현합니다 (`Subjective Down` 이라 합니다.)\nsdown은 단지 Master와 Sentinel 자기 자신이 연결이 되지 않음을 의미합니다.\n\n위에서 보듯이 Master가 죽었으니 다른 Sentinel들도 연결이 끊어졌다고 sdown 시그널을 보냅니다.\n그렇게 되면 다수결에 원칙에 따라 quorum값 만큼의 sdown이 발생하면 sentinel은 odown 시그널을 보냅니다. (`Objective Down`이라 합니다.)\n\nodown은 다수결에 의해서 명시적으로 Master가 Down되었다고 선포하는 것과 같습니다.\n그렇게 되면 Sentinel들은 다음 Master를 선출하기 위해 남아있는 Slave Redis들에게 투표를 하게 됩니다.\n다수결의 원칙으로 더 많은 투표수를 받은 Slave가 Master로 선출되게 됩니다.\n\n\n\n## 중단되었던 6379 포트를 사용하는 Redis 노드가 살아나면?\n\n아까 stop했던 container를 다시 살려보겠습니다.\n\n```sh\ndocker start <redis1_node_id>\n```\n\n![redis-failover-3](./redis-failover-3-3748019.PNG)\n\n3번째 줄부터 보시면, sentinel에서 `-sdown` 로그를 찍어주고 있습니다.\nsentinel에서 연결되지 않았던 6379번 노드에 대해 정상적으로 커넥션이 맺어지고 있기 때문입니다.\n중간 줄 부터 보게 되면다른 sentinel 노드에서도 `-sdown` 로그를 찍어주며 6379번 노드에 대한 부활을 알려주고 있습니다.\n\n그런 다음에 `+convert-to-slave` 로그를 보면, 기존의 6379번 노드는 원래 master role을 수행 하던 Redis 노드였습니다.\n하지만 현재 sentinel에 대한 mymaster는 6380번 노드이기 때문에 6379번 노드는 master role을 수행 할 수 없습니다.\n\n따라서  `+role-change` 명령을 통해  기존에 master role -> slave role로 변경되어야 합니다.\n그리고 현재 master role 권한이 있는 6380번 노드의 slave으로 편입되게 됩니다.\nredis-cli를 통해 6379번 노드에 접속하여 `info replication` 명령을 날려보았습니다.\n\n![redis-failover-4](./redis-failover-4.PNG)\n\n현재 role은 `slave` 이며, 6380번 노드를 master로 설정하고 있습니다.\n\n\n\n> **왜 기존의 master가 살아나면, slave로 전환하여 사용해야 할까?**\n>\n> 이유는 간단합니다. \n> Redis Master-Slave간 데이터 Replication을 이해 하면 쉽게 이해 할 수 있습니다\n> Redis의 데이터 Replication은 dump.rdb파일을 통해 이루어지는데, \n> master노드 만 dump.rdb파일에 데이터를 write 할 수 있습니다.\n> slave노드에서는 dump.rdb파일을 읽어서 데이터 replication을 하게 되는데,\n> 만약 기존의 master의 role이 유지된다면, dump.rdb파일을 조작하여 기존의 master가 다운된 시간 동안\n> 들어온 데이터가 삭제될 수 있습니다. \n> 그렇게 때문에 데이터 정합성을 위해 기존의 master는 slave로 role이 전환되어야 합니다.","slug":"2018-12-02-docker-7","published":1,"updated":"2018-12-08T08:32:55.280Z","comments":1,"photos":[],"link":"","_id":"cjrgbv3rw003icr1tgxkyz66z","content":"<h1 id=\"redis-sentinel이란\">Redis Sentinel이란?</h1>\n<p>Redis Cluster 운영환경에서 Master-Slave 관계를 가진 Redis가 있습니다.\n시스템 오류나 알수 없는 원인으로 인해 Master Redis가 down되어 연결이 중단 되면, 사용자나 Application에서는 Redis Master를 통해 데이터를 등록 할 수 없게 됩니다.\n이런 경우 Slave Redis를 Master Redis로 승격시켜 시스템이 정상적으로 운영 될 수 있도록 해야 합니다.</p>\n<p>이 때 사용하는 게 Redis Sentinel입니다.\nSentinel은 Master Redis의 상태를 감시합니다. 그러다가 Master Redis가 Down이 되어버리면, Sentinel들은 Slave Redis들 중에 어떤 Redis 서버를 Master로 승격시킬지 투표하게 됩니다.\nSlave Redis 중 Sentinel의 투표를 더 많이 받은 Redis Server가 Master Redis로 승격됩니다.\n이후 장애를 해결한 원래 Master Redis는 재시작 시, 현재 Master Redis의 Slave Redis로 시작되게 됩니다.</p>\n<p>이와같이, Redis Sentinel은 Redis Cluster 환경에서의 Failover를 자동으로 해주는 Redis의 한 Mode입니다.</p>\n<h1 id=\"role-change-원리\">Role Change 원리</h1>\n<p><img src=\"./Redis-failover-1.PNG\" alt=\"Redis-failover-1\"></p>\n<p>위의 상황은 6379 포트를 사용하는 Master Redis가 Down된 상황입니다.\nSentinel들은 일제히 Master Redis를 감시하다가 Down된 상황을 인지하고\n2번째 그림처럼 Slave Redis들 중 어떤 Redis 서버를 Master Redis로 승격할 지 투표로 정하게 됩니다.\n여기서 중요한 건 Redis Sentinel의 노드 갯수는 <code>항상 홀수로 설정</code>해야 합니다. (짝수 인 경우 1:1, 2:2 상황이 되어 어떤 Redis Server를 승격 시킬지 알 수 없기 때문입니다.)\n위의 예제에서는 15485 번 포트를 사용하는 Slave Redis가 2대1로 선택되었습니다.\nSentinel은 바로 redis.conf 파일을 조작하여 Slave Redis를 Master Redis로 변경합니다.\n그리고 자기 자신의 sentinel.conf 정보를 조작하여 감시하는 Redis 서버 정보를 update 합니다.\n이후 Down되었던 기존의 Master Redis의 장애가 처리되어 Restart되는 경우를 보도록 하겠습니다.</p>\n<p><img src=\"./Redis-failover-2.PNG\" alt=\"Redis-failover-2\"></p>\n<p>Sentinel은 Down되었던 Master 정보를 메모리에 저장하고 있습니다.\n이후 Down되었던 Master Redis가 장애를 처리하고 다시 시작 되는 경우, Master Redis의 redis.conf 파일을 조작하여\n현재 Master Redis의 Slave로 설정합니다.</p>\n<blockquote>\n<p>이 경우 Sentinel의 설정 값이 따라 다르지만,\n일시적으로 Master Redis가 2대가 됩니다.\n만약에 Down 되었다가 Restart된 Redis에 Data가 저장되는 경우, Slave Redis로 전환되면서 Master의 rdb파일을 바탕으로 Data를 Update하기 때문에 데이터가 사라지는 상황이 오게 됩니다.\n따라서 Down 되었다가 살아나는 Redis에 접근 하지 못하도록 막아야 합니다.</p>\n</blockquote>\n<h1 id=\"redis-sentinel-설치하기\">Redis Sentinel 설치하기</h1>\n<p>Docker, Docker-Compose, git은 Redis Cluster를 설치하며 설치 했다고 가정하겠습니다.</p>\n<h2 id=\"redis-sentinel-파일-다운로드\">Redis Sentinel 파일 다운로드</h2>\n<p>기존에 github에 올려둔 Sentienel 설정파일을 다운로드 합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mkdir -p /home/redis/redis-sentinel <span class=\"comment\">#Redis-sentinel home 생성</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/redis</span><br><span class=\"line\">mkdir -p ./sentinel-data/sentinel1   <span class=\"comment\">#외부 log파일 볼륨 설정</span></span><br><span class=\"line\">mkdir -p ./sentinel-data/sentinel2</span><br><span class=\"line\">mkdir -p ./sentinel-data/sentinel3</span><br><span class=\"line\"> </span><br><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin <span class=\"string\">\"https://github.com/jaehun2841/redis-sentinel-on-docker.git\"</span></span><br><span class=\"line\">git pull origin master <span class=\"comment\">#github에서 sentinel 설정 파일 다운로드</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"redis-sentinel-build\">Redis sentinel Build</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /home/redis/redis-sentinel</span><br><span class=\"line\">docker-compose -f conf/sentinel-docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"redis-sentinel-생성을-위한-docker-composeyml파일\">Redis Sentinel 생성을 위한 docker-compose.yml파일</h1>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'3'</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"attr\">  redis-sentinel1:</span>                        <span class=\"comment\">#Sentinel Container명</span></span><br><span class=\"line\"><span class=\"attr\">     image:</span> <span class=\"string\">lgatica/redis-sentinel:4.0.2</span>  <span class=\"comment\">#redis-sentinel 이미지를 바탕으로 빌드합니다.</span></span><br><span class=\"line\"><span class=\"attr\">     build:</span></span><br><span class=\"line\"><span class=\"attr\">       context:</span> <span class=\"string\">..</span>                        <span class=\"comment\">#Dockerfile context 설정</span></span><br><span class=\"line\"><span class=\"attr\">       dockerfile:</span> <span class=\"string\">Dockerfile</span>             <span class=\"comment\">#Dockerfile명 설정 (Default는 Dockerfile로 된 파일명을 찾습니다.)</span></span><br><span class=\"line\"><span class=\"attr\">     network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\"><span class=\"attr\">     environment:</span>                         <span class=\"comment\">#Container에서 사용할 환경 변수 설정</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTPORT=26379</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERPORT=6379</span>                   <span class=\"comment\">#Sentinel의 mymaster port를 적어줍니다.</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">QUORUM=2</span>                          <span class=\"comment\">#QUORUM 값은 Sentinel들이 투표했을때 득표수가 2 이상인 Redis에 대해 Master로 승격할 수 있도록 하는 조건 값입니다.</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">DOWN_AFTER_MILLISEC=3000</span>          <span class=\"comment\">#Redis master node down 후 3초 이후 failover 시작</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">FAILOVER_TIMEOUT=3000</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">REQUIREPASS=password1234</span></span><br><span class=\"line\"><span class=\"attr\">     volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"../../sentinel-data/sentinel1:/redis\"</span>  <span class=\"comment\">#Container 외부 볼륨 설정</span></span><br><span class=\"line\"><span class=\"attr\">     restart:</span> <span class=\"string\">always</span>                         <span class=\"comment\">#restart policy Container가 중지되거나 down되는 경우 무조건 다시 시작합니다.</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"attr\">  redis-sentinel2:</span></span><br><span class=\"line\"><span class=\"attr\">     image:</span> <span class=\"string\">lgatica/redis-sentinel:4.0.2</span></span><br><span class=\"line\"><span class=\"attr\">     build:</span></span><br><span class=\"line\"><span class=\"attr\">       context:</span> <span class=\"string\">..</span></span><br><span class=\"line\"><span class=\"attr\">       dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\"><span class=\"attr\">     network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\"><span class=\"attr\">     environment:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTPORT=26380</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERPORT=6379</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">QUORUM=2</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">DOWN_AFTER_MILLISEC=3000</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">FAILOVER_TIMEOUT=3000</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">REQUIREPASS=password1234</span></span><br><span class=\"line\"><span class=\"attr\">     volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"../../sentinel-data/sentinel2:/redis\"</span></span><br><span class=\"line\"><span class=\"attr\">     restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"attr\">  redis-sentinel3:</span></span><br><span class=\"line\"><span class=\"attr\">     image:</span> <span class=\"string\">lgatica/redis-sentinel:4.0.2</span></span><br><span class=\"line\"><span class=\"attr\">     build:</span></span><br><span class=\"line\"><span class=\"attr\">       context:</span> <span class=\"string\">..</span></span><br><span class=\"line\"><span class=\"attr\">       dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\"><span class=\"attr\">     network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\"><span class=\"attr\">     environment:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTPORT=26381</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERPORT=6379</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">QUORUM=2</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">DOWN_AFTER_MILLISEC=3000</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">FAILOVER_TIMEOUT=3000</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">REQUIREPASS=password1234</span></span><br><span class=\"line\"><span class=\"attr\">     volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"../../sentinel-data/sentinel3:/redis\"</span></span><br><span class=\"line\"><span class=\"attr\">     restart:</span> <span class=\"string\">always</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"redis-sentinel-이미지-생성을-위한-dockerfile-작성\">Redis Sentinel 이미지 생성을 위한 Dockerfile 작성</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#redis-sentinel 이미지 기반으로 빌드합니다.</span></span><br><span class=\"line\">FROM lgatica/redis-sentinel:4.0.2   </span><br><span class=\"line\"> </span><br><span class=\"line\">MAINTAINER Carrey </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">## Copy Redis File</span></span><br><span class=\"line\"><span class=\"comment\">## 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 한다.</span></span><br><span class=\"line\"><span class=\"comment\"># 기존 container의 sentinel-entrypoint.sh 삭제합니다.</span></span><br><span class=\"line\">RUN rm -rf /usr/<span class=\"built_in\">local</span>/bin/sentinel-entrypoint.sh         </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># sentinel 설정이 담긴 sentinel.conf 파일 복사합니다.</span></span><br><span class=\"line\">ADD sentinel.conf /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf                          </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># sentinel container 시작 시, 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.</span></span><br><span class=\"line\">ADD sentinel-entrypoint.sh /usr/<span class=\"built_in\">local</span>/bin/sentinel-entrypoint.sh         </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">## change access authority</span></span><br><span class=\"line\"><span class=\"comment\"># 복사한 파일에 대한 권한을 변경합니다. (Permission Denied 문제)</span></span><br><span class=\"line\">RUN chmod 755 /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf                               </span><br><span class=\"line\">RUN chmod 755 /usr/<span class=\"built_in\">local</span>/bin/sentinel-entrypoint.sh</span><br><span class=\"line\">RUN chown redis:redis /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf</span><br><span class=\"line\">RUN chown redis:redis /usr/<span class=\"built_in\">local</span>/bin/sentinel-entrypoint.sh</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Redis Container에 대한 Port를 지정합니다. (host 모드이기 때문에 외부 노출)</span></span><br><span class=\"line\">EXPOSE <span class=\"variable\">$CLIENTPORT</span>                                    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Container가 생성, 시작하는 시점에 실행됩니다.</span></span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"/usr/local/bin/sentinel-entrypoint.sh\"</span>]        </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Container 빌드가 완료되고 Sentinel Server를 실행시킵니다. </span></span><br><span class=\"line\"><span class=\"comment\"># conf 파일 뿐만 아니라 --sentinel 옵션을 추가하여 Redis가 Sentinel 모드로 실행 되도록 합니다.</span></span><br><span class=\"line\"><span class=\"comment\"># Sentinel 또한 Redis Server이지만, Sentinel 설정을 하여 실행 시키는 것 뿐입니다.</span></span><br><span class=\"line\">CMD [ <span class=\"string\">\"redis-server\"</span>,<span class=\"string\">\"/usr/local/bin/sentinel.conf\"</span>, <span class=\"string\">\"--sentinel\"</span> ]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"redis-sentinel-설정\">Redis Sentinel 설정</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -e</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># bind 127.0.0.1 문자열을 각 이미지에서 설정한 $CLIENTHOST 값으로 변경합니다. </span></span><br><span class=\"line\"><span class=\"comment\"># $CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/bind 127.0.0.1/bind <span class=\"variable\">$CLIENTHOST</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf      </span><br><span class=\"line\">         </span><br><span class=\"line\"><span class=\"comment\"># port 6379 문자열을 각 이미지에서 설정한 $CLIENTPORT 값으로 변경합니다. </span></span><br><span class=\"line\"><span class=\"comment\"># Sentinel 이미지 별로 port다르게 설정</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/port 6379/port <span class=\"variable\">$CLIENTPORT</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf  </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># sentinel에 대한 mymaster를 설정하는 부분입니다. </span></span><br><span class=\"line\"><span class=\"comment\"># 실제 Master Redis의 ip와 port를 설정하고 QUORUM 값을 설정합니다.</span></span><br><span class=\"line\"><span class=\"comment\"># QUORUM 값은 Slave-&gt;Master Role Change 시, slave redis가 받아야 하는 최소 투표 수 입니다.</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/sentinel monitor mymaster 127.0.0.1 6379 2/sentinel monitor mymaster <span class=\"variable\">$MASTERHOST</span> <span class=\"variable\">$MASTERPORT</span> <span class=\"variable\">$QUORUM</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Redis server가 다운되고 후처리 실행 시간 까지 걸리는 시간을 지정합니다. </span></span><br><span class=\"line\"><span class=\"comment\"># ex)3000 -&gt; 3000 밀리세컨드 -&gt; 3초</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/sentinel down-after-milliseconds mymaster 30000/sentinel down-after-milliseconds mymaster <span class=\"variable\">$DOWN_AFTER_MILLISEC</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Redis failover timeout 시간을 설정 합니다.</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/sentinel failover-timeout mymaster 180000/sentinel failover-timeout mymaster <span class=\"variable\">$FAILOVER_TIMEOUT</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># sentinel이 master redis에 접근할 때 인증하는 비밀번호를 설정합니다.</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# sentinel auth-pass mymaster MySUPER--secret-0123passw0rd/sentinel auth-pass mymaster <span class=\"variable\">$REQUIREPASS</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># first arg is `-f` or `--some-option`</span></span><br><span class=\"line\"><span class=\"comment\"># or first arg is `something.conf`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$&#123;1#-&#125;</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> ] || [ <span class=\"string\">\"<span class=\"variable\">$&#123;1%.conf&#125;</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">set</span> -- redis-server <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># allow the container to be started with `--user`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> = <span class=\"string\">'redis-server'</span> -a <span class=\"string\">\"<span class=\"variable\">$(id -u)</span>\"</span> = <span class=\"string\">'0'</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    chown -R redis .</span><br><span class=\"line\">    <span class=\"built_in\">exec</span> su-exec redis <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">exec</span> <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"redis-sentinel-실행-결과\">Redis Sentinel 실행 결과</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose -f conf/sentinel-docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./redis-sentinel-log.PNG\" alt=\"redis-sentinel-log\"></p>\n<p>sentinel 1~3 까지의 로그를 모아보았습니다.\n테스트용 port인 (6379~6381) 에 대한 master/slave 정보를 가지고 있는것을 볼수 있습니다.</p>\n<p>로그처럼</p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-sentinel2_1  | 1:X 02 Dec 10:06:24.082 # +monitor master mymaster 192.168.137.101 6379 quorum 2</span><br></pre></td></tr></table></figure></p>\n<p>sentinel이 자신의 마스터에 대한 정보를 가지고 모니터 하며 quorum 2를 가지고 있는 것을 볼 수 있습니다.</p>\n<h1 id=\"failover-test\">Failover Test</h1>\n<p>자, Failover를 구성 했으니 실제로 Master를 한번 죽여보도록 해보겠습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop &lt;master_node_id&gt; <span class=\"comment\"># Redis Master Container를 중지</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./redis-failover-log.PNG\" alt=\"redis-failover-log\"></p>\n<p>맨 처음 로그를 살펴보면 각 sentinel 노드에서 sdown 시그널을 발생시키고 있습니다.</p>\n<p>중간정도 줄을 보면</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+odown master mymaster 192.168.137.101 6379 <span class=\"comment\">#quorum 3/2</span></span><br></pre></td></tr></table></figure></p>\n<p>라는 로그가 나오게 되는데 3개의 sentinel에서 모두 sdown으로 인지하게 되는것입니다.\n3/2의 뜻은  2개 노드에서 sdown이 발생 했을 때, odown 판정을 내린다는 다수결 투표 숫자입니다.\n그런데 3개의 노드가 모두 투표를 하여 과반수 이상이 되었으므로 192.168.137.101 6379인 Redis 노드는 odown상태가 되었습니다.</p>\n<p>그 바로 다음 줄 부터 failover 작업이 시작됩니다.\n위의 예제에서는 6380 포트를 사용하는 redis노드가 새로운 마스터로 선출 되었습니다.\n따라서 6380 포트를 사용하는 redis노드는 master로 role-change가 되면서 master 노드로써 역할을 수행하게 됩니다.</p>\n<p>이렇게 Redis Sentinel을 이용하여 master node를 감시하며, 장애 상황에 대한 failover를 지원하고 있습니다.</p>\n<h2 id=\"sdown-vs-odown\">sdown vs odown</h2>\n<p>Sentinel에서 down을 판단하는 방법은 <code>sdown</code>과 <code>odown</code>으로 이루어집니다.\nfailover 시 Master가 죽었다는 걸 판단하기 위해서는 <code>다수결의 원칙</code>이 적용됩니다. (그래서 Sentinel노드 갯수를 홀수로 설정하는 이유입니다.)</p>\n<p>먼저, Master가 죽게 되면 Sentinel은 자신이 감시하고 있는 Master가 죽었다고 sdown 시그널을 표현합니다 (<code>Subjective Down</code> 이라 합니다.)\nsdown은 단지 Master와 Sentinel 자기 자신이 연결이 되지 않음을 의미합니다.</p>\n<p>위에서 보듯이 Master가 죽었으니 다른 Sentinel들도 연결이 끊어졌다고 sdown 시그널을 보냅니다.\n그렇게 되면 다수결에 원칙에 따라 quorum값 만큼의 sdown이 발생하면 sentinel은 odown 시그널을 보냅니다. (<code>Objective Down</code>이라 합니다.)</p>\n<p>odown은 다수결에 의해서 명시적으로 Master가 Down되었다고 선포하는 것과 같습니다.\n그렇게 되면 Sentinel들은 다음 Master를 선출하기 위해 남아있는 Slave Redis들에게 투표를 하게 됩니다.\n다수결의 원칙으로 더 많은 투표수를 받은 Slave가 Master로 선출되게 됩니다.</p>\n<h2 id=\"중단되었던-6379-포트를-사용하는-redis-노드가-살아나면\">중단되었던 6379 포트를 사용하는 Redis 노드가 살아나면?</h2>\n<p>아까 stop했던 container를 다시 살려보겠습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start &lt;redis1_node_id&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./redis-failover-3-3748019.PNG\" alt=\"redis-failover-3\"></p>\n<p>3번째 줄부터 보시면, sentinel에서 <code>-sdown</code> 로그를 찍어주고 있습니다.\nsentinel에서 연결되지 않았던 6379번 노드에 대해 정상적으로 커넥션이 맺어지고 있기 때문입니다.\n중간 줄 부터 보게 되면다른 sentinel 노드에서도 <code>-sdown</code> 로그를 찍어주며 6379번 노드에 대한 부활을 알려주고 있습니다.</p>\n<p>그런 다음에 <code>+convert-to-slave</code> 로그를 보면, 기존의 6379번 노드는 원래 master role을 수행 하던 Redis 노드였습니다.\n하지만 현재 sentinel에 대한 mymaster는 6380번 노드이기 때문에 6379번 노드는 master role을 수행 할 수 없습니다.</p>\n<p>따라서  <code>+role-change</code> 명령을 통해  기존에 master role -&gt; slave role로 변경되어야 합니다.\n그리고 현재 master role 권한이 있는 6380번 노드의 slave으로 편입되게 됩니다.\nredis-cli를 통해 6379번 노드에 접속하여 <code>info replication</code> 명령을 날려보았습니다.</p>\n<p><img src=\"./redis-failover-4.PNG\" alt=\"redis-failover-4\"></p>\n<p>현재 role은 <code>slave</code> 이며, 6380번 노드를 master로 설정하고 있습니다.</p>\n<blockquote>\n<p><strong>왜 기존의 master가 살아나면, slave로 전환하여 사용해야 할까?</strong></p>\n<p>이유는 간단합니다.\nRedis Master-Slave간 데이터 Replication을 이해 하면 쉽게 이해 할 수 있습니다\nRedis의 데이터 Replication은 dump.rdb파일을 통해 이루어지는데,\nmaster노드 만 dump.rdb파일에 데이터를 write 할 수 있습니다.\nslave노드에서는 dump.rdb파일을 읽어서 데이터 replication을 하게 되는데,\n만약 기존의 master의 role이 유지된다면, dump.rdb파일을 조작하여 기존의 master가 다운된 시간 동안\n들어온 데이터가 삭제될 수 있습니다.\n그렇게 때문에 데이터 정합성을 위해 기존의 master는 slave로 role이 전환되어야 합니다.</p>\n</blockquote>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>Redis Sentinel이란?</h1>\n<p>Redis Cluster 운영환경에서 Master-Slave 관계를 가진 Redis가 있습니다.\n시스템 오류나 알수 없는 원인으로 인해 Master Redis가 down되어 연결이 중단 되면, 사용자나 Application에서는 Redis Master를 통해 데이터를 등록 할 수 없게 됩니다.\n이런 경우 Slave Redis를 Master Redis로 승격시켜 시스템이 정상적으로 운영 될 수 있도록 해야 합니다.</p>\n<p>이 때 사용하는 게 Redis Sentinel입니다.\nSentinel은 Master Redis의 상태를 감시합니다. 그러다가 Master Redis가 Down이 되어버리면, Sentinel들은 Slave Redis들 중에 어떤 Redis 서버를 Master로 승격시킬지 투표하게 됩니다.\nSlave Redis 중 Sentinel의 투표를 더 많이 받은 Redis Server가 Master Redis로 승격됩니다.\n이후 장애를 해결한 원래 Master Redis는 재시작 시, 현재 Master Redis의 Slave Redis로 시작되게 됩니다.</p>\n<p>이와같이, Redis Sentinel은 Redis Cluster 환경에서의 Failover를 자동으로 해주는 Redis의 한 Mode입니다.</p>\n<h1>Role Change 원리</h1>\n<p><img src=\"./Redis-failover-1.PNG\" alt=\"Redis-failover-1\"></p>\n<p>위의 상황은 6379 포트를 사용하는 Master Redis가 Down된 상황입니다.\nSentinel들은 일제히 Master Redis를 감시하다가 Down된 상황을 인지하고\n2번째 그림처럼 Slave Redis들 중 어떤 Redis 서버를 Master Redis로 승격할 지 투표로 정하게 됩니다.\n여기서 중요한 건 Redis Sentinel의 노드 갯수는 <code>항상 홀수로 설정</code>해야 합니다. (짝수 인 경우 1:1, 2:2 상황이 되어 어떤 Redis Server를 승격 시킬지 알 수 없기 때문입니다.)\n위의 예제에서는 15485 번 포트를 사용하는 Slave Redis가 2대1로 선택되었습니다.\nSentinel은 바로 redis.conf 파일을 조작하여 Slave Redis를 Master Redis로 변경합니다.\n그리고 자기 자신의 sentinel.conf 정보를 조작하여 감시하는 Redis 서버 정보를 update 합니다.\n이후 Down되었던 기존의 Master Redis의 장애가 처리되어 Restart되는 경우를 보도록 하겠습니다.</p>\n<p><img src=\"./Redis-failover-2.PNG\" alt=\"Redis-failover-2\"></p>\n<p>Sentinel은 Down되었던 Master 정보를 메모리에 저장하고 있습니다.\n이후 Down되었던 Master Redis가 장애를 처리하고 다시 시작 되는 경우, Master Redis의 redis.conf 파일을 조작하여\n현재 Master Redis의 Slave로 설정합니다.</p>\n<blockquote>\n<p>이 경우 Sentinel의 설정 값이 따라 다르지만,\n일시적으로 Master Redis가 2대가 됩니다.\n만약에 Down 되었다가 Restart된 Redis에 Data가 저장되는 경우, Slave Redis로 전환되면서 Master의 rdb파일을 바탕으로 Data를 Update하기 때문에 데이터가 사라지는 상황이 오게 됩니다.\n따라서 Down 되었다가 살아나는 Redis에 접근 하지 못하도록 막아야 합니다.</p>\n</blockquote>\n<h1>Redis Sentinel 설치하기</h1>\n<p>Docker, Docker-Compose, git은 Redis Cluster를 설치하며 설치 했다고 가정하겠습니다.</p>\n<h2>Redis Sentinel 파일 다운로드</h2>\n<p>기존에 github에 올려둔 Sentienel 설정파일을 다운로드 합니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mkdir -p /home/redis/redis-sentinel <span class=\"comment\">#Redis-sentinel home 생성</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/redis</span><br><span class=\"line\">mkdir -p ./sentinel-data/sentinel1   <span class=\"comment\">#외부 log파일 볼륨 설정</span></span><br><span class=\"line\">mkdir -p ./sentinel-data/sentinel2</span><br><span class=\"line\">mkdir -p ./sentinel-data/sentinel3</span><br><span class=\"line\"> </span><br><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin <span class=\"string\">\"https://github.com/jaehun2841/redis-sentinel-on-docker.git\"</span></span><br><span class=\"line\">git pull origin master <span class=\"comment\">#github에서 sentinel 설정 파일 다운로드</span></span><br></pre></td></tr></table></figure></p>\n<h2>Redis sentinel Build</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /home/redis/redis-sentinel</span><br><span class=\"line\">docker-compose -f conf/sentinel-docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure></p>\n<h1>Redis Sentinel 생성을 위한 docker-compose.yml파일</h1>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'3'</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"attr\">  redis-sentinel1:</span>                        <span class=\"comment\">#Sentinel Container명</span></span><br><span class=\"line\"><span class=\"attr\">     image:</span> <span class=\"string\">lgatica/redis-sentinel:4.0.2</span>  <span class=\"comment\">#redis-sentinel 이미지를 바탕으로 빌드합니다.</span></span><br><span class=\"line\"><span class=\"attr\">     build:</span></span><br><span class=\"line\"><span class=\"attr\">       context:</span> <span class=\"string\">..</span>                        <span class=\"comment\">#Dockerfile context 설정</span></span><br><span class=\"line\"><span class=\"attr\">       dockerfile:</span> <span class=\"string\">Dockerfile</span>             <span class=\"comment\">#Dockerfile명 설정 (Default는 Dockerfile로 된 파일명을 찾습니다.)</span></span><br><span class=\"line\"><span class=\"attr\">     network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\"><span class=\"attr\">     environment:</span>                         <span class=\"comment\">#Container에서 사용할 환경 변수 설정</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTPORT=26379</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERPORT=6379</span>                   <span class=\"comment\">#Sentinel의 mymaster port를 적어줍니다.</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">QUORUM=2</span>                          <span class=\"comment\">#QUORUM 값은 Sentinel들이 투표했을때 득표수가 2 이상인 Redis에 대해 Master로 승격할 수 있도록 하는 조건 값입니다.</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">DOWN_AFTER_MILLISEC=3000</span>          <span class=\"comment\">#Redis master node down 후 3초 이후 failover 시작</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">FAILOVER_TIMEOUT=3000</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">REQUIREPASS=password1234</span></span><br><span class=\"line\"><span class=\"attr\">     volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"../../sentinel-data/sentinel1:/redis\"</span>  <span class=\"comment\">#Container 외부 볼륨 설정</span></span><br><span class=\"line\"><span class=\"attr\">     restart:</span> <span class=\"string\">always</span>                         <span class=\"comment\">#restart policy Container가 중지되거나 down되는 경우 무조건 다시 시작합니다.</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"attr\">  redis-sentinel2:</span></span><br><span class=\"line\"><span class=\"attr\">     image:</span> <span class=\"string\">lgatica/redis-sentinel:4.0.2</span></span><br><span class=\"line\"><span class=\"attr\">     build:</span></span><br><span class=\"line\"><span class=\"attr\">       context:</span> <span class=\"string\">..</span></span><br><span class=\"line\"><span class=\"attr\">       dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\"><span class=\"attr\">     network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\"><span class=\"attr\">     environment:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTPORT=26380</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERPORT=6379</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">QUORUM=2</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">DOWN_AFTER_MILLISEC=3000</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">FAILOVER_TIMEOUT=3000</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">REQUIREPASS=password1234</span></span><br><span class=\"line\"><span class=\"attr\">     volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"../../sentinel-data/sentinel2:/redis\"</span></span><br><span class=\"line\"><span class=\"attr\">     restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"attr\">  redis-sentinel3:</span></span><br><span class=\"line\"><span class=\"attr\">     image:</span> <span class=\"string\">lgatica/redis-sentinel:4.0.2</span></span><br><span class=\"line\"><span class=\"attr\">     build:</span></span><br><span class=\"line\"><span class=\"attr\">       context:</span> <span class=\"string\">..</span></span><br><span class=\"line\"><span class=\"attr\">       dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\"><span class=\"attr\">     network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\"><span class=\"attr\">     environment:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTPORT=26381</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">MASTERPORT=6379</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">QUORUM=2</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">DOWN_AFTER_MILLISEC=3000</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">FAILOVER_TIMEOUT=3000</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">REQUIREPASS=password1234</span></span><br><span class=\"line\"><span class=\"attr\">     volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"../../sentinel-data/sentinel3:/redis\"</span></span><br><span class=\"line\"><span class=\"attr\">     restart:</span> <span class=\"string\">always</span></span><br></pre></td></tr></table></figure></p>\n<h1>Redis Sentinel 이미지 생성을 위한 Dockerfile 작성</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#redis-sentinel 이미지 기반으로 빌드합니다.</span></span><br><span class=\"line\">FROM lgatica/redis-sentinel:4.0.2   </span><br><span class=\"line\"> </span><br><span class=\"line\">MAINTAINER Carrey </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">## Copy Redis File</span></span><br><span class=\"line\"><span class=\"comment\">## 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 한다.</span></span><br><span class=\"line\"><span class=\"comment\"># 기존 container의 sentinel-entrypoint.sh 삭제합니다.</span></span><br><span class=\"line\">RUN rm -rf /usr/<span class=\"built_in\">local</span>/bin/sentinel-entrypoint.sh         </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># sentinel 설정이 담긴 sentinel.conf 파일 복사합니다.</span></span><br><span class=\"line\">ADD sentinel.conf /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf                          </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># sentinel container 시작 시, 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.</span></span><br><span class=\"line\">ADD sentinel-entrypoint.sh /usr/<span class=\"built_in\">local</span>/bin/sentinel-entrypoint.sh         </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">## change access authority</span></span><br><span class=\"line\"><span class=\"comment\"># 복사한 파일에 대한 권한을 변경합니다. (Permission Denied 문제)</span></span><br><span class=\"line\">RUN chmod 755 /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf                               </span><br><span class=\"line\">RUN chmod 755 /usr/<span class=\"built_in\">local</span>/bin/sentinel-entrypoint.sh</span><br><span class=\"line\">RUN chown redis:redis /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf</span><br><span class=\"line\">RUN chown redis:redis /usr/<span class=\"built_in\">local</span>/bin/sentinel-entrypoint.sh</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Redis Container에 대한 Port를 지정합니다. (host 모드이기 때문에 외부 노출)</span></span><br><span class=\"line\">EXPOSE <span class=\"variable\">$CLIENTPORT</span>                                    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Container가 생성, 시작하는 시점에 실행됩니다.</span></span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"/usr/local/bin/sentinel-entrypoint.sh\"</span>]        </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Container 빌드가 완료되고 Sentinel Server를 실행시킵니다. </span></span><br><span class=\"line\"><span class=\"comment\"># conf 파일 뿐만 아니라 --sentinel 옵션을 추가하여 Redis가 Sentinel 모드로 실행 되도록 합니다.</span></span><br><span class=\"line\"><span class=\"comment\"># Sentinel 또한 Redis Server이지만, Sentinel 설정을 하여 실행 시키는 것 뿐입니다.</span></span><br><span class=\"line\">CMD [ <span class=\"string\">\"redis-server\"</span>,<span class=\"string\">\"/usr/local/bin/sentinel.conf\"</span>, <span class=\"string\">\"--sentinel\"</span> ]</span><br></pre></td></tr></table></figure></p>\n<h1>Redis Sentinel 설정</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -e</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># bind 127.0.0.1 문자열을 각 이미지에서 설정한 $CLIENTHOST 값으로 변경합니다. </span></span><br><span class=\"line\"><span class=\"comment\"># $CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/bind 127.0.0.1/bind <span class=\"variable\">$CLIENTHOST</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf      </span><br><span class=\"line\">         </span><br><span class=\"line\"><span class=\"comment\"># port 6379 문자열을 각 이미지에서 설정한 $CLIENTPORT 값으로 변경합니다. </span></span><br><span class=\"line\"><span class=\"comment\"># Sentinel 이미지 별로 port다르게 설정</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/port 6379/port <span class=\"variable\">$CLIENTPORT</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf  </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># sentinel에 대한 mymaster를 설정하는 부분입니다. </span></span><br><span class=\"line\"><span class=\"comment\"># 실제 Master Redis의 ip와 port를 설정하고 QUORUM 값을 설정합니다.</span></span><br><span class=\"line\"><span class=\"comment\"># QUORUM 값은 Slave-&gt;Master Role Change 시, slave redis가 받아야 하는 최소 투표 수 입니다.</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/sentinel monitor mymaster 127.0.0.1 6379 2/sentinel monitor mymaster <span class=\"variable\">$MASTERHOST</span> <span class=\"variable\">$MASTERPORT</span> <span class=\"variable\">$QUORUM</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Redis server가 다운되고 후처리 실행 시간 까지 걸리는 시간을 지정합니다. </span></span><br><span class=\"line\"><span class=\"comment\"># ex)3000 -&gt; 3000 밀리세컨드 -&gt; 3초</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/sentinel down-after-milliseconds mymaster 30000/sentinel down-after-milliseconds mymaster <span class=\"variable\">$DOWN_AFTER_MILLISEC</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Redis failover timeout 시간을 설정 합니다.</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/sentinel failover-timeout mymaster 180000/sentinel failover-timeout mymaster <span class=\"variable\">$FAILOVER_TIMEOUT</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># sentinel이 master redis에 접근할 때 인증하는 비밀번호를 설정합니다.</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# sentinel auth-pass mymaster MySUPER--secret-0123passw0rd/sentinel auth-pass mymaster <span class=\"variable\">$REQUIREPASS</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/sentinel.conf</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># first arg is `-f` or `--some-option`</span></span><br><span class=\"line\"><span class=\"comment\"># or first arg is `something.conf`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$&#123;1#-&#125;</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> ] || [ <span class=\"string\">\"<span class=\"variable\">$&#123;1%.conf&#125;</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">set</span> -- redis-server <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># allow the container to be started with `--user`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> = <span class=\"string\">'redis-server'</span> -a <span class=\"string\">\"<span class=\"variable\">$(id -u)</span>\"</span> = <span class=\"string\">'0'</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    chown -R redis .</span><br><span class=\"line\">    <span class=\"built_in\">exec</span> su-exec redis <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">exec</span> <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<h1>Redis Sentinel 실행 결과</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose -f conf/sentinel-docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./redis-sentinel-log.PNG\" alt=\"redis-sentinel-log\"></p>\n<p>sentinel 1~3 까지의 로그를 모아보았습니다.\n테스트용 port인 (6379~6381) 에 대한 master/slave 정보를 가지고 있는것을 볼수 있습니다.</p>\n<p>로그처럼</p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-sentinel2_1  | 1:X 02 Dec 10:06:24.082 # +monitor master mymaster 192.168.137.101 6379 quorum 2</span><br></pre></td></tr></table></figure></p>\n<p>sentinel이 자신의 마스터에 대한 정보를 가지고 모니터 하며 quorum 2를 가지고 있는 것을 볼 수 있습니다.</p>\n<h1>Failover Test</h1>\n<p>자, Failover를 구성 했으니 실제로 Master를 한번 죽여보도록 해보겠습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop &lt;master_node_id&gt; <span class=\"comment\"># Redis Master Container를 중지</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./redis-failover-log.PNG\" alt=\"redis-failover-log\"></p>\n<p>맨 처음 로그를 살펴보면 각 sentinel 노드에서 sdown 시그널을 발생시키고 있습니다.</p>\n<p>중간정도 줄을 보면</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+odown master mymaster 192.168.137.101 6379 <span class=\"comment\">#quorum 3/2</span></span><br></pre></td></tr></table></figure></p>\n<p>라는 로그가 나오게 되는데 3개의 sentinel에서 모두 sdown으로 인지하게 되는것입니다.\n3/2의 뜻은  2개 노드에서 sdown이 발생 했을 때, odown 판정을 내린다는 다수결 투표 숫자입니다.\n그런데 3개의 노드가 모두 투표를 하여 과반수 이상이 되었으므로 192.168.137.101 6379인 Redis 노드는 odown상태가 되었습니다.</p>\n<p>그 바로 다음 줄 부터 failover 작업이 시작됩니다.\n위의 예제에서는 6380 포트를 사용하는 redis노드가 새로운 마스터로 선출 되었습니다.\n따라서 6380 포트를 사용하는 redis노드는 master로 role-change가 되면서 master 노드로써 역할을 수행하게 됩니다.</p>\n<p>이렇게 Redis Sentinel을 이용하여 master node를 감시하며, 장애 상황에 대한 failover를 지원하고 있습니다.</p>\n<h2>sdown vs odown</h2>\n<p>Sentinel에서 down을 판단하는 방법은 <code>sdown</code>과 <code>odown</code>으로 이루어집니다.\nfailover 시 Master가 죽었다는 걸 판단하기 위해서는 <code>다수결의 원칙</code>이 적용됩니다. (그래서 Sentinel노드 갯수를 홀수로 설정하는 이유입니다.)</p>\n<p>먼저, Master가 죽게 되면 Sentinel은 자신이 감시하고 있는 Master가 죽었다고 sdown 시그널을 표현합니다 (<code>Subjective Down</code> 이라 합니다.)\nsdown은 단지 Master와 Sentinel 자기 자신이 연결이 되지 않음을 의미합니다.</p>\n<p>위에서 보듯이 Master가 죽었으니 다른 Sentinel들도 연결이 끊어졌다고 sdown 시그널을 보냅니다.\n그렇게 되면 다수결에 원칙에 따라 quorum값 만큼의 sdown이 발생하면 sentinel은 odown 시그널을 보냅니다. (<code>Objective Down</code>이라 합니다.)</p>\n<p>odown은 다수결에 의해서 명시적으로 Master가 Down되었다고 선포하는 것과 같습니다.\n그렇게 되면 Sentinel들은 다음 Master를 선출하기 위해 남아있는 Slave Redis들에게 투표를 하게 됩니다.\n다수결의 원칙으로 더 많은 투표수를 받은 Slave가 Master로 선출되게 됩니다.</p>\n<h2>중단되었던 6379 포트를 사용하는 Redis 노드가 살아나면?</h2>\n<p>아까 stop했던 container를 다시 살려보겠습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start &lt;redis1_node_id&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./redis-failover-3-3748019.PNG\" alt=\"redis-failover-3\"></p>\n<p>3번째 줄부터 보시면, sentinel에서 <code>-sdown</code> 로그를 찍어주고 있습니다.\nsentinel에서 연결되지 않았던 6379번 노드에 대해 정상적으로 커넥션이 맺어지고 있기 때문입니다.\n중간 줄 부터 보게 되면다른 sentinel 노드에서도 <code>-sdown</code> 로그를 찍어주며 6379번 노드에 대한 부활을 알려주고 있습니다.</p>\n<p>그런 다음에 <code>+convert-to-slave</code> 로그를 보면, 기존의 6379번 노드는 원래 master role을 수행 하던 Redis 노드였습니다.\n하지만 현재 sentinel에 대한 mymaster는 6380번 노드이기 때문에 6379번 노드는 master role을 수행 할 수 없습니다.</p>\n<p>따라서  <code>+role-change</code> 명령을 통해  기존에 master role -&gt; slave role로 변경되어야 합니다.\n그리고 현재 master role 권한이 있는 6380번 노드의 slave으로 편입되게 됩니다.\nredis-cli를 통해 6379번 노드에 접속하여 <code>info replication</code> 명령을 날려보았습니다.</p>\n<p><img src=\"./redis-failover-4.PNG\" alt=\"redis-failover-4\"></p>\n<p>현재 role은 <code>slave</code> 이며, 6380번 노드를 master로 설정하고 있습니다.</p>\n<blockquote>\n<p><strong>왜 기존의 master가 살아나면, slave로 전환하여 사용해야 할까?</strong></p>\n<p>이유는 간단합니다.\nRedis Master-Slave간 데이터 Replication을 이해 하면 쉽게 이해 할 수 있습니다\nRedis의 데이터 Replication은 dump.rdb파일을 통해 이루어지는데,\nmaster노드 만 dump.rdb파일에 데이터를 write 할 수 있습니다.\nslave노드에서는 dump.rdb파일을 읽어서 데이터 replication을 하게 되는데,\n만약 기존의 master의 role이 유지된다면, dump.rdb파일을 조작하여 기존의 master가 다운된 시간 동안\n들어온 데이터가 삭제될 수 있습니다.\n그렇게 때문에 데이터 정합성을 위해 기존의 master는 slave로 role이 전환되어야 합니다.</p>\n</blockquote>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (10) Redis Cluster Mode 설정하기","date":"2018-12-03T06:54:18.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-12-03-docker-10","typora-copy-images-to":"2018-12-03-docker-10","_content":"\n# 들어가며\n\n이전 장 까지 했던 Redis 구조는 `Redis Replication + Redis Sentinel`을 이용한 failover 기능을 구성하고 있었습니다. Spring Application에서 Jedis를 이용하여 Application sharding을 구성하여 사용을 하였습니다. 이렇게 Redis를 잘 사용하나 싶었지만, 최근 Spring Cache Abstraction에 대해 공부했었고, Redis Replication + Sharding + Failover를 사용하면서 **Spring-Data-Redis를 사용할 방법이 없을까?** 라는 생각을 하게 되었습니다.\n\n맨 처음에 회사에서 Spring + Redis연동을 할 때 당연히 Spring-Data-Redis를 염두하고 시작을 했었지만, 어느 블로그에서 **Spring-Data-Redis는 Sharding을 지원하지 않는다!** 라는 절망적인 얘기를 보고 여태까지 Docker를 이용해 설치한 방식에서 Jedis를 이용한 Sharding을 이용하고 있었습니다.\n\n그 이후, Redis 관련 문서를 쭉 보던 중.. Redis 공식 홈페이지에서 `Redis Cluster Mode`에 대한 내용을 보게 되었습니다.\n그 내용을 요약하자면\n\n* Redis3 버전 부터 Redis는 `Cluster Mode`를 지원한다.\n* Cluster Mode에서는 Redis Sentinel의 도움없이 `Cluster 자체적으로 Failover를 진행`한다.\n* Cluster Mode에서는 Master-Slave 노드 구조를 가질 수 있고, `노드 간 Replication을 지원`한다.\n* Cluster Mode에서는 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행\n  `Auto Sharding을 지원`한다 (이야!!!!!!!!!!!!)\n* Application Sharding이 필요없기 때문에, `Spring-Data-Redis 사용이 가능하다.`\n  (사실은 이 목적 때문에 Cluster Mode 설치를 해보게 되었습니다.)\n\n\n\n# 기존에 설치한 Redis 구조와 다른 점은?\n\n## 이전 장까지 설치 했던 Redis 구조\n![Redis-Cluster-archi](./Redis-Cluster-archi.PNG)\n\n* Master - Slave -Slave 구조\n* Redis Sentinel을 이용한 Master 감시 + Fail over 기능 지원\n* HAProxy를 이용한 Master / Slave 접근 Port 분리\n\n\n\n## 새롭게 구성한 Redis Cluster\n\n![new-redis-cluster](./new-redis-cluster.PNG)\n\n* HAProxy는 5000번 포트만 사용하도록 축소 5001~5005는 불필요하기 때문\n  * 앞으로는 무조건 Master에만 통신\n  * 어떤 Node와 통신하여 데이터를 set하거나 get 할 수 있음 (Cluster Mode 지원)\n  * 어떤 Node에 set하더라도 자동으로 Sharding\n\n* 감시자 역할의 Sentinel 제거 \n    * Cluster Mode에서는 Redis Node끼리 감시하며 Fail over가 가능합니다.\n* Slave 갯수도 한개로 축소\n\n\n\n# Cluster Mode에서 지원하는 기능\n\n## Fail Over\n![new-redis-cluster2](./new-redis-cluster2.PNG)\n* Redis Cluster Mode에서는 기존의 Sentinel을 별도로 설치하여 감시자 역할을 하는 것에서 벗어나 Cluster 자체적으로 Node들을 감시하고 Failover를 수행 할 수 있습니다.\n* Redis Cluster Mode를 사용하기 위해서는 각 Redis Node 별로 2개의 port가 열려 있어야 합니다.\n    * 6379, 6380 default - Redis 서버 접속 포트\n    * 16379, 16380 default  `(접속 포트 + 10000)` - Redis Cluster Bus \n* Cluster Bus를 이용해 Redis Cluster는 각 노드를 감시하고 서버 다운 시 또는 Connection 유실 시 Fail over를 수행합니다.\n* Cluster Bus는 노드 간 데이터 교환에 대해 다른 바이너리 프로토콜을 사용합니다.\n* 이 프로토콜은 대역폭과 처리 시간을 적게 사용하여 노드 간에 정보를 교환하는 데 더 적합합니다.\n\n\n\n## Auto Sharding \n\n* Redis Cluster Mode에서는 자동으로 Cluster Node에 대한 자동 샤딩을 제공합니다.\n* Redis Cluster에는 16384개의 slot이 있으며, slot에 대한 구간 별로 샤딩이 가능합니다.\n* slot을 계산하기 위해 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행합니다.\n    * [0-5500] 까지는 1번 Redis Node에 저장\n    * [5501-11000] 까지는 2번 Redis Node에 저장\n    * [11001-16384] 까지는 3번 Redis Node에 저장\n    * Redis Node가 scale out 되는 경우 Master Node 수를 나눈 만큼 대역이 할당\n\n\n\n## Redis-cli를 이용한 cluster 명령\n\nRedis 5버전에 포함된 redis-cli 버전 부터 cluster 옵션이 추가 되었습니다.\nRedis 4버전 이하에 대해서는 별도로 Ruby 기반의 프로그램을 설치해야 되서 번거로워서, Redis 5버전으로 설치를 해보았습니다. (성능도 더 좋을라나?ㅎ)\n\n\n\n### Redis Cluster 생성\n\n```\nredis-cli --cluster create 192.168.137.101:6379 192.168.137.102:6379 192.168.137.103:6379 \\\n192.168.137.102:6380 192.168.137.103:6380 192.168.137.101:6380 \\\n--cluster-replicas 1\n```\n* Redis Cluster를 생성하기 위해서는 Master Node가 최소 3개 이상 필요합니다.\n* 맨 처음 등록하는 3개의 노드가 Master Node\n* `--cluster-replicas 1` 의 의미는 각 Slave Node가 1개임을 의미합니다.\n* 6개의 노드가 등록 되었다면 처음 3개는 Master, 뒤의 3개는 Slave가 됩니다\n* Slave는 선언된 순서 대로 Master의 Slave로 등록 됩니다\n    * 192.168.137.101:6379 -> 192.168.137.102:6380\n    * 192.168.137.102:6379 -> 192.168.137.103:6380\n    * 192.168.137.103:6379 -> 192.168.137.101:6380\n\n![cluster-setting](./cluster-setting.PNG)\n\n![cluster-setting2](./cluster-setting2.PNG)\n\n\n\nredis-cli에 접속하여 cluster nodes 명령어로 cluster를 구성하는 nodes에 대한 정보를 조회해 보았습니다.\n\n![cluster-nodes](./cluster-nodes.png)\n\n\n\n\n\n### Redis Node ADD / REMOVE\n\n새로운 노드를 추가하는 과정은 기본적으로 2가지입니다.\n* 새로운 Master를 추가하는 경우\n* 새로운 Slave를 추가하는 경우\n\n\n\n### Master 추가\n\n```\nredis-cli --cluster add-node 192.168.137.104:6379 192.168.137.101:6379\n```\n* 위 명령은 cluster에 새로운 노드를 추가하는 명령어입니다.\n* 192.168.137.101:6379 구성 된 Cluster에 192.168.137.104:6379 추가한다는 명령어입니다.\n* cluster를 지정할 때는 master node를 아무거나 지정하면 됩니다. (192.168.137.101~103:6379)\n* 여기까지 했을 때는 Cluster에 일원이 되어 Cluster로 묶여는지나, `실제로 데이터는 저장 되지 않습니다.`\n* hash slot이 할당 되지 않았기 때문에 데이터는 저장되지 않습니다.\n* `re-sharding`을 통해 slot의 대역을 할당 받아야 합니다.\n\n\n\n### Slave 추가\n\n```sh\nredis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave\n```\n* 위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.\n* 이 경우에는 새롭게 추가된 노드를 `복제본의 수가 적은 마스터` 나 임의의 마스터에 대한 Slave로 추가됩니다.\n\n```sh\nredis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave\\\n--cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e1\n```\n* 위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.\n* 이 경우에는 master node를 지정하기 때문에 특정 master-id에 해당하는 master node의 slave로 추가됩니다.\n\n\n\n## Node 제거\n\n```sh\nredis-cli --cluster del-node 192.168.137.101:6379 `<node-id>`\nredis-cli --cluster del-node 192.168.137.101:6379\n3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e\n```\n\n* 위 명령은 Redis Cluster의 node를 제거하는 명령어입니다.\n* Redis Cluster에 포함된 아무 node를 적어준다 `192.168.137.101:6379 는 Redis Cluster 노드 중 하나`\n* node-id는 삭제하고자 하는 node의 id입니다.\n* node-id는 cluster nodes 명령어를 통해 검색하여 적어줍니다.\n* Slave는 막 지울 수 있습니다!\n* 하지만 **Master는 노드에 저장된 내용이 하나도 없어야 삭제가 가능합니다.**\n* 지울 수 있는 대안으로는 수동으로 failover를 하여 slave로 만든 다음에 삭제를 하는 방법이 있습니다.\n\n\n\n### Re-sharding\n\n```sh\nredis-cli --cluster reshard 192.168.137.101:6379\n```\n\n* 위 명령은 현재 cluster에 대한 reshard를 수행하는 명령어입니다.\n* cluster내의 master node 아무거나 써주면 자동으로 cluster node를 스캔하여 reshard를 수행합니다.\n* resharding 중에도 무중단으로 redis를 사용할 수 있습니다.\n* 하지만 resharding을 **수행하는 key에 대해서는 lock이 걸립니다.**\n* 만약 resharding 대상이 많은 경우에는 redis 서버가 중지되었다가 다시 시작 될 수 있습니다.\n\n\n\n# Redis 설치\n## Docker 설정하기\n### docker-compose.yml\n```yml\nversion: '3'\nservices:\n   redis-master:\n      image: redis:5.0-alpine\n      build:\n         context: ..\n         dockerfile: Dockerfile\n      network_mode: \"host\"\n      environment:\n      - REQUIREPASS=<password>\n      - CLIENTHOST=192.168.137.101\n      - CLIENTPORT=6379\n      volumes:\n      - \"../../new_redis-data/redis1:/data\"\n      restart: always\n\n   redis-slave:\n      image: redis:5.0-alpine\n      build:\n         context: ..\n         dockerfile: Dockerfile\n      network_mode: \"host\"\n      environment:\n      - REQUIREPASS=<password>\n      - CLIENTHOST=192.168.137.101\n      - CLIENTPORT=6380\n      volumes:\n      - \"../../new_redis-data/redis2:/data\"\n      restart: always\n```\n* redis-cli의 cluster option을 사용하기 위해 redis:5.0-alpine 버전을 사용하였습니다.\n* redis:5.0.0이 RELEASE 버전이지만, Dockerfile에서 sed 명령어 사용 시, `Permission denied`가 발생하는 버그가 있습니다.\n* network_mode 는 `host`로 설정. `Docker Redis는 NAT에 대한 지원을 하지 않습니다.`\n* 외부 볼륨 연동을 위해 ../../new_redis-data/master 폴더와 docker container 내의 /data 폴더를 연동하였습니다.\n* container down 시 항상 재시작 하도록 restart policy를 always로 설정 하였습니다.\n\n\n\n### docker-entrypoint.sh\n\n```sh\n#!/bin/sh\nset -e\n\n## from redis-5\nsed -i \"s/bind 127.0.0.1/bind $CLIENTHOST 127.0.0.1/g\" /usr/local/bin/redis.conf\nsed -i \"s/port 6379/port $CLIENTPORT/g\" /usr/local/bin/redis.conf\nsed -i \"s/# requirepass foobared/requirepass $REQUIREPASS/g\" /usr/local/bin/redis.conf\nsed -i \"s/# masterauth <master-password>/masterauth $REQUIREPASS/g\" /usr/local/bin/redis.conf\nsed -i \"s/# cluster-enabled yes/cluster-enabled yes/g\" /usr/local/bin/redis.conf\nsed -i \"s/# cluster-config-file nodes-6379.conf/cluster-config-file nodes.conf/g\" /usr/local/bin/redis.conf\nsed -i \"s/# cluster-node-timeout 15000/cluster-node-timeout 5000/g\" /usr/local/bin/redis.conf\n\n# first arg is `-f` or `--some-option`\n# or first arg is `something.conf`\nif [ \"${1#-}\" != \"$1\" ] || [ \"${1%.conf}\" != \"$1\" ]; then\n\tset -- redis-server \"$@\"\nfi\n\n# allow the container to be started with `--user`\nif [ \"$1\" = 'redis-server' -a \"$(id -u)\" = '0' ]; then\n\tchown -R redis .\n    exec su-exec redis \"$@\"\nfi\n\nexec \"$@\"\n```\n\n* sed명령어를 통해 container내의 redis.conf파일을 치환\n     `치환자에 대한 설정은 docker-compose.yml > environment에 등록`\n    * bind 옵션에 대해 CLINET IP를 설정\n    * port도 기본 6379 port에서 6379, 6380으로 치환하였습니다.\n    * requirepass도 설정\n    * masterauth도 requirepass와 동일하게 설정\n    * cluster-mode를 사용하기 위해 `cluster-enable yes`로 설정\n    * cluster에 대한 로그를 볼 수 있도록 `cluster-config-file nodes.conf` conf 파일 지정 (여기에 로그 생성)\n    * cluster failover를 위해 `cluster-node-timeout`을 5초로 지정\n\n\n\n# Failover Test\n\n테스트를 위해 192.168.137.101:6379 (master1)에 대한 docker container를 죽여보았습니다.\n\n```sh\ndocker stop 030bb02a246e\n```\n\n![master-down](./master-down.png)\n* docker ps -a 명령으로 볼 때 192.168.137.101:6379 (master1)에 대한 docker container가 다운!!\n\n![failover-1](./failover-1.png)\n\n* 5초 정도 지나니 무슨 로그가 올라왔습니다. epoch vote라는 로그를 보아하니 새로운 마스터를 선출하였습니다.\n\n* redis-cli를 통해 `cluster nodes`를 검색해 보니 `192.168.137.101:6379 (master1)`의 slave였던 `192.168.137.103:6380 (slave1)` 가 새로운 master로 promote 되었습니다.\n\n```sh\ndocker start 030bb02a246e\n```\n* docker start 명령으로 다시 container를 살려보았습니다.\n\n![failover2](./failover2.png)\n* 기존의 master는 slave로 편입되어 정상적인 cluster가 작동하고 있습니다.\n\n\n\n# Sharding Test\n\n![cluster-keys-command](./cluster-keys-command.PNG)\n\n* redis-cli를 통해 foo1~foo10까지 key를 만들어 set해 보았습니다.\n* set할때 마다 16384 modules 연산을 통해 slot별로 sharding이 되는 모습입니다.\n* 각 redis-cli에서 keys * 명령을 통해 조회 해보면 고르게 sharding이 되어있음을 확인 할 수 있습니다.\n\n\n\n# Node ADD/REMOVE\n\n![cluster-add](./cluster-add.PNG)\n* 신규 Master node (192.168.137.104:6379)를 새로이 추가해 보았습니다.\n\n![cluster-add-node-slave](./cluster-add-node-slave.PNG)\n![slave-add-result](./slave-add-result.png)\n\n* 신규 Slave node (192.168.137.104:6380)를 새로이 추가해 보았습니다.\n* 신규 Master node (192.168.137.104:6379)의 slave로 추가해보았다.\n* 정상적으로 모두 등록 되었다.\n\n![slave-del](./slave-del.png)\n* slave를 삭제해 보았습니다.\n\n![slave-del-result](./slave-del-result.png)\n\n* slave가 정상적으로 삭제 되었습니다.\n\n![master-del-fail](./master-del-fail.png)\n* master 삭제를 시도해 보았습니다.\n* slot이 비어있지 않아 삭제가 불가능 했습니다.\n* 이런 경우 reshard를 통해 slot을 비워준뒤에 삭제 해야합니다.\n\n![sub-reshard](./sub-reshard.PNG)\n\n* reshard 명령을 다시 실행 합니다.\n* `What is the receiving node ID?` 라는 질문에 192.168.137.101:6379 node-id를 지정합니다.\n* `Source node` 항목에는 우리가 삭제할 192.168.137.104:6379 node-id를 지정합니다.\n* `source node` 두번째 항목에는 done을 입력하여 Source node 항목을 모두 입력하였음을 선언해 줍니다.\n\n![master-del-success](./master-del-success.png)\n\n* 다시 master를 삭제하니 정상적으로 삭제가 됩니다.\n\n\n\n# Re-Sharding Test\n\n![reshard-test-1](./reshard-test-1-3831920.PNG)\n* 새롭게 추가한 노드에 reshard를 해보았습니다.\n* 4000개정도를 새로이 옮긴다고 조건을 주고 Resharding을 실행 해보았습니다.\n```\nDo you want to proceed with the proposed reshard plan (yes/no)? yes\n```\n\n![reshard-test-2](./reshard-test-2-3832564.PNG)\n\n![reshard-test-3](./reshard-test-3.PNG)\n\n* 정상적으로 resharding이 되어 데이터가 4개의 node에 고르게 분포 되었습니다.\n\n\n\n\n# 참고\n* https://redis.io/topics/cluster-tutorial","source":"_posts/2018-12-03-docker-10.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (10) Redis Cluster Mode 설정하기\ndate: 2018-12-03 15:54:18\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-12-03-docker-10\ntypora-copy-images-to: 2018-12-03-docker-10\n---\n\n# 들어가며\n\n이전 장 까지 했던 Redis 구조는 `Redis Replication + Redis Sentinel`을 이용한 failover 기능을 구성하고 있었습니다. Spring Application에서 Jedis를 이용하여 Application sharding을 구성하여 사용을 하였습니다. 이렇게 Redis를 잘 사용하나 싶었지만, 최근 Spring Cache Abstraction에 대해 공부했었고, Redis Replication + Sharding + Failover를 사용하면서 **Spring-Data-Redis를 사용할 방법이 없을까?** 라는 생각을 하게 되었습니다.\n\n맨 처음에 회사에서 Spring + Redis연동을 할 때 당연히 Spring-Data-Redis를 염두하고 시작을 했었지만, 어느 블로그에서 **Spring-Data-Redis는 Sharding을 지원하지 않는다!** 라는 절망적인 얘기를 보고 여태까지 Docker를 이용해 설치한 방식에서 Jedis를 이용한 Sharding을 이용하고 있었습니다.\n\n그 이후, Redis 관련 문서를 쭉 보던 중.. Redis 공식 홈페이지에서 `Redis Cluster Mode`에 대한 내용을 보게 되었습니다.\n그 내용을 요약하자면\n\n* Redis3 버전 부터 Redis는 `Cluster Mode`를 지원한다.\n* Cluster Mode에서는 Redis Sentinel의 도움없이 `Cluster 자체적으로 Failover를 진행`한다.\n* Cluster Mode에서는 Master-Slave 노드 구조를 가질 수 있고, `노드 간 Replication을 지원`한다.\n* Cluster Mode에서는 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행\n  `Auto Sharding을 지원`한다 (이야!!!!!!!!!!!!)\n* Application Sharding이 필요없기 때문에, `Spring-Data-Redis 사용이 가능하다.`\n  (사실은 이 목적 때문에 Cluster Mode 설치를 해보게 되었습니다.)\n\n\n\n# 기존에 설치한 Redis 구조와 다른 점은?\n\n## 이전 장까지 설치 했던 Redis 구조\n![Redis-Cluster-archi](./Redis-Cluster-archi.PNG)\n\n* Master - Slave -Slave 구조\n* Redis Sentinel을 이용한 Master 감시 + Fail over 기능 지원\n* HAProxy를 이용한 Master / Slave 접근 Port 분리\n\n\n\n## 새롭게 구성한 Redis Cluster\n\n![new-redis-cluster](./new-redis-cluster.PNG)\n\n* HAProxy는 5000번 포트만 사용하도록 축소 5001~5005는 불필요하기 때문\n  * 앞으로는 무조건 Master에만 통신\n  * 어떤 Node와 통신하여 데이터를 set하거나 get 할 수 있음 (Cluster Mode 지원)\n  * 어떤 Node에 set하더라도 자동으로 Sharding\n\n* 감시자 역할의 Sentinel 제거 \n    * Cluster Mode에서는 Redis Node끼리 감시하며 Fail over가 가능합니다.\n* Slave 갯수도 한개로 축소\n\n\n\n# Cluster Mode에서 지원하는 기능\n\n## Fail Over\n![new-redis-cluster2](./new-redis-cluster2.PNG)\n* Redis Cluster Mode에서는 기존의 Sentinel을 별도로 설치하여 감시자 역할을 하는 것에서 벗어나 Cluster 자체적으로 Node들을 감시하고 Failover를 수행 할 수 있습니다.\n* Redis Cluster Mode를 사용하기 위해서는 각 Redis Node 별로 2개의 port가 열려 있어야 합니다.\n    * 6379, 6380 default - Redis 서버 접속 포트\n    * 16379, 16380 default  `(접속 포트 + 10000)` - Redis Cluster Bus \n* Cluster Bus를 이용해 Redis Cluster는 각 노드를 감시하고 서버 다운 시 또는 Connection 유실 시 Fail over를 수행합니다.\n* Cluster Bus는 노드 간 데이터 교환에 대해 다른 바이너리 프로토콜을 사용합니다.\n* 이 프로토콜은 대역폭과 처리 시간을 적게 사용하여 노드 간에 정보를 교환하는 데 더 적합합니다.\n\n\n\n## Auto Sharding \n\n* Redis Cluster Mode에서는 자동으로 Cluster Node에 대한 자동 샤딩을 제공합니다.\n* Redis Cluster에는 16384개의 slot이 있으며, slot에 대한 구간 별로 샤딩이 가능합니다.\n* slot을 계산하기 위해 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행합니다.\n    * [0-5500] 까지는 1번 Redis Node에 저장\n    * [5501-11000] 까지는 2번 Redis Node에 저장\n    * [11001-16384] 까지는 3번 Redis Node에 저장\n    * Redis Node가 scale out 되는 경우 Master Node 수를 나눈 만큼 대역이 할당\n\n\n\n## Redis-cli를 이용한 cluster 명령\n\nRedis 5버전에 포함된 redis-cli 버전 부터 cluster 옵션이 추가 되었습니다.\nRedis 4버전 이하에 대해서는 별도로 Ruby 기반의 프로그램을 설치해야 되서 번거로워서, Redis 5버전으로 설치를 해보았습니다. (성능도 더 좋을라나?ㅎ)\n\n\n\n### Redis Cluster 생성\n\n```\nredis-cli --cluster create 192.168.137.101:6379 192.168.137.102:6379 192.168.137.103:6379 \\\n192.168.137.102:6380 192.168.137.103:6380 192.168.137.101:6380 \\\n--cluster-replicas 1\n```\n* Redis Cluster를 생성하기 위해서는 Master Node가 최소 3개 이상 필요합니다.\n* 맨 처음 등록하는 3개의 노드가 Master Node\n* `--cluster-replicas 1` 의 의미는 각 Slave Node가 1개임을 의미합니다.\n* 6개의 노드가 등록 되었다면 처음 3개는 Master, 뒤의 3개는 Slave가 됩니다\n* Slave는 선언된 순서 대로 Master의 Slave로 등록 됩니다\n    * 192.168.137.101:6379 -> 192.168.137.102:6380\n    * 192.168.137.102:6379 -> 192.168.137.103:6380\n    * 192.168.137.103:6379 -> 192.168.137.101:6380\n\n![cluster-setting](./cluster-setting.PNG)\n\n![cluster-setting2](./cluster-setting2.PNG)\n\n\n\nredis-cli에 접속하여 cluster nodes 명령어로 cluster를 구성하는 nodes에 대한 정보를 조회해 보았습니다.\n\n![cluster-nodes](./cluster-nodes.png)\n\n\n\n\n\n### Redis Node ADD / REMOVE\n\n새로운 노드를 추가하는 과정은 기본적으로 2가지입니다.\n* 새로운 Master를 추가하는 경우\n* 새로운 Slave를 추가하는 경우\n\n\n\n### Master 추가\n\n```\nredis-cli --cluster add-node 192.168.137.104:6379 192.168.137.101:6379\n```\n* 위 명령은 cluster에 새로운 노드를 추가하는 명령어입니다.\n* 192.168.137.101:6379 구성 된 Cluster에 192.168.137.104:6379 추가한다는 명령어입니다.\n* cluster를 지정할 때는 master node를 아무거나 지정하면 됩니다. (192.168.137.101~103:6379)\n* 여기까지 했을 때는 Cluster에 일원이 되어 Cluster로 묶여는지나, `실제로 데이터는 저장 되지 않습니다.`\n* hash slot이 할당 되지 않았기 때문에 데이터는 저장되지 않습니다.\n* `re-sharding`을 통해 slot의 대역을 할당 받아야 합니다.\n\n\n\n### Slave 추가\n\n```sh\nredis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave\n```\n* 위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.\n* 이 경우에는 새롭게 추가된 노드를 `복제본의 수가 적은 마스터` 나 임의의 마스터에 대한 Slave로 추가됩니다.\n\n```sh\nredis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave\\\n--cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e1\n```\n* 위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.\n* 이 경우에는 master node를 지정하기 때문에 특정 master-id에 해당하는 master node의 slave로 추가됩니다.\n\n\n\n## Node 제거\n\n```sh\nredis-cli --cluster del-node 192.168.137.101:6379 `<node-id>`\nredis-cli --cluster del-node 192.168.137.101:6379\n3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e\n```\n\n* 위 명령은 Redis Cluster의 node를 제거하는 명령어입니다.\n* Redis Cluster에 포함된 아무 node를 적어준다 `192.168.137.101:6379 는 Redis Cluster 노드 중 하나`\n* node-id는 삭제하고자 하는 node의 id입니다.\n* node-id는 cluster nodes 명령어를 통해 검색하여 적어줍니다.\n* Slave는 막 지울 수 있습니다!\n* 하지만 **Master는 노드에 저장된 내용이 하나도 없어야 삭제가 가능합니다.**\n* 지울 수 있는 대안으로는 수동으로 failover를 하여 slave로 만든 다음에 삭제를 하는 방법이 있습니다.\n\n\n\n### Re-sharding\n\n```sh\nredis-cli --cluster reshard 192.168.137.101:6379\n```\n\n* 위 명령은 현재 cluster에 대한 reshard를 수행하는 명령어입니다.\n* cluster내의 master node 아무거나 써주면 자동으로 cluster node를 스캔하여 reshard를 수행합니다.\n* resharding 중에도 무중단으로 redis를 사용할 수 있습니다.\n* 하지만 resharding을 **수행하는 key에 대해서는 lock이 걸립니다.**\n* 만약 resharding 대상이 많은 경우에는 redis 서버가 중지되었다가 다시 시작 될 수 있습니다.\n\n\n\n# Redis 설치\n## Docker 설정하기\n### docker-compose.yml\n```yml\nversion: '3'\nservices:\n   redis-master:\n      image: redis:5.0-alpine\n      build:\n         context: ..\n         dockerfile: Dockerfile\n      network_mode: \"host\"\n      environment:\n      - REQUIREPASS=<password>\n      - CLIENTHOST=192.168.137.101\n      - CLIENTPORT=6379\n      volumes:\n      - \"../../new_redis-data/redis1:/data\"\n      restart: always\n\n   redis-slave:\n      image: redis:5.0-alpine\n      build:\n         context: ..\n         dockerfile: Dockerfile\n      network_mode: \"host\"\n      environment:\n      - REQUIREPASS=<password>\n      - CLIENTHOST=192.168.137.101\n      - CLIENTPORT=6380\n      volumes:\n      - \"../../new_redis-data/redis2:/data\"\n      restart: always\n```\n* redis-cli의 cluster option을 사용하기 위해 redis:5.0-alpine 버전을 사용하였습니다.\n* redis:5.0.0이 RELEASE 버전이지만, Dockerfile에서 sed 명령어 사용 시, `Permission denied`가 발생하는 버그가 있습니다.\n* network_mode 는 `host`로 설정. `Docker Redis는 NAT에 대한 지원을 하지 않습니다.`\n* 외부 볼륨 연동을 위해 ../../new_redis-data/master 폴더와 docker container 내의 /data 폴더를 연동하였습니다.\n* container down 시 항상 재시작 하도록 restart policy를 always로 설정 하였습니다.\n\n\n\n### docker-entrypoint.sh\n\n```sh\n#!/bin/sh\nset -e\n\n## from redis-5\nsed -i \"s/bind 127.0.0.1/bind $CLIENTHOST 127.0.0.1/g\" /usr/local/bin/redis.conf\nsed -i \"s/port 6379/port $CLIENTPORT/g\" /usr/local/bin/redis.conf\nsed -i \"s/# requirepass foobared/requirepass $REQUIREPASS/g\" /usr/local/bin/redis.conf\nsed -i \"s/# masterauth <master-password>/masterauth $REQUIREPASS/g\" /usr/local/bin/redis.conf\nsed -i \"s/# cluster-enabled yes/cluster-enabled yes/g\" /usr/local/bin/redis.conf\nsed -i \"s/# cluster-config-file nodes-6379.conf/cluster-config-file nodes.conf/g\" /usr/local/bin/redis.conf\nsed -i \"s/# cluster-node-timeout 15000/cluster-node-timeout 5000/g\" /usr/local/bin/redis.conf\n\n# first arg is `-f` or `--some-option`\n# or first arg is `something.conf`\nif [ \"${1#-}\" != \"$1\" ] || [ \"${1%.conf}\" != \"$1\" ]; then\n\tset -- redis-server \"$@\"\nfi\n\n# allow the container to be started with `--user`\nif [ \"$1\" = 'redis-server' -a \"$(id -u)\" = '0' ]; then\n\tchown -R redis .\n    exec su-exec redis \"$@\"\nfi\n\nexec \"$@\"\n```\n\n* sed명령어를 통해 container내의 redis.conf파일을 치환\n     `치환자에 대한 설정은 docker-compose.yml > environment에 등록`\n    * bind 옵션에 대해 CLINET IP를 설정\n    * port도 기본 6379 port에서 6379, 6380으로 치환하였습니다.\n    * requirepass도 설정\n    * masterauth도 requirepass와 동일하게 설정\n    * cluster-mode를 사용하기 위해 `cluster-enable yes`로 설정\n    * cluster에 대한 로그를 볼 수 있도록 `cluster-config-file nodes.conf` conf 파일 지정 (여기에 로그 생성)\n    * cluster failover를 위해 `cluster-node-timeout`을 5초로 지정\n\n\n\n# Failover Test\n\n테스트를 위해 192.168.137.101:6379 (master1)에 대한 docker container를 죽여보았습니다.\n\n```sh\ndocker stop 030bb02a246e\n```\n\n![master-down](./master-down.png)\n* docker ps -a 명령으로 볼 때 192.168.137.101:6379 (master1)에 대한 docker container가 다운!!\n\n![failover-1](./failover-1.png)\n\n* 5초 정도 지나니 무슨 로그가 올라왔습니다. epoch vote라는 로그를 보아하니 새로운 마스터를 선출하였습니다.\n\n* redis-cli를 통해 `cluster nodes`를 검색해 보니 `192.168.137.101:6379 (master1)`의 slave였던 `192.168.137.103:6380 (slave1)` 가 새로운 master로 promote 되었습니다.\n\n```sh\ndocker start 030bb02a246e\n```\n* docker start 명령으로 다시 container를 살려보았습니다.\n\n![failover2](./failover2.png)\n* 기존의 master는 slave로 편입되어 정상적인 cluster가 작동하고 있습니다.\n\n\n\n# Sharding Test\n\n![cluster-keys-command](./cluster-keys-command.PNG)\n\n* redis-cli를 통해 foo1~foo10까지 key를 만들어 set해 보았습니다.\n* set할때 마다 16384 modules 연산을 통해 slot별로 sharding이 되는 모습입니다.\n* 각 redis-cli에서 keys * 명령을 통해 조회 해보면 고르게 sharding이 되어있음을 확인 할 수 있습니다.\n\n\n\n# Node ADD/REMOVE\n\n![cluster-add](./cluster-add.PNG)\n* 신규 Master node (192.168.137.104:6379)를 새로이 추가해 보았습니다.\n\n![cluster-add-node-slave](./cluster-add-node-slave.PNG)\n![slave-add-result](./slave-add-result.png)\n\n* 신규 Slave node (192.168.137.104:6380)를 새로이 추가해 보았습니다.\n* 신규 Master node (192.168.137.104:6379)의 slave로 추가해보았다.\n* 정상적으로 모두 등록 되었다.\n\n![slave-del](./slave-del.png)\n* slave를 삭제해 보았습니다.\n\n![slave-del-result](./slave-del-result.png)\n\n* slave가 정상적으로 삭제 되었습니다.\n\n![master-del-fail](./master-del-fail.png)\n* master 삭제를 시도해 보았습니다.\n* slot이 비어있지 않아 삭제가 불가능 했습니다.\n* 이런 경우 reshard를 통해 slot을 비워준뒤에 삭제 해야합니다.\n\n![sub-reshard](./sub-reshard.PNG)\n\n* reshard 명령을 다시 실행 합니다.\n* `What is the receiving node ID?` 라는 질문에 192.168.137.101:6379 node-id를 지정합니다.\n* `Source node` 항목에는 우리가 삭제할 192.168.137.104:6379 node-id를 지정합니다.\n* `source node` 두번째 항목에는 done을 입력하여 Source node 항목을 모두 입력하였음을 선언해 줍니다.\n\n![master-del-success](./master-del-success.png)\n\n* 다시 master를 삭제하니 정상적으로 삭제가 됩니다.\n\n\n\n# Re-Sharding Test\n\n![reshard-test-1](./reshard-test-1-3831920.PNG)\n* 새롭게 추가한 노드에 reshard를 해보았습니다.\n* 4000개정도를 새로이 옮긴다고 조건을 주고 Resharding을 실행 해보았습니다.\n```\nDo you want to proceed with the proposed reshard plan (yes/no)? yes\n```\n\n![reshard-test-2](./reshard-test-2-3832564.PNG)\n\n![reshard-test-3](./reshard-test-3.PNG)\n\n* 정상적으로 resharding이 되어 데이터가 4개의 node에 고르게 분포 되었습니다.\n\n\n\n\n# 참고\n* https://redis.io/topics/cluster-tutorial","slug":"2018-12-03-docker-10","published":1,"updated":"2018-12-08T08:32:55.298Z","comments":1,"photos":[],"link":"","_id":"cjrgbv3rx003kcr1t7r5dhxm1","content":"<h1 id=\"들어가며\">들어가며</h1>\n<p>이전 장 까지 했던 Redis 구조는 <code>Redis Replication + Redis Sentinel</code>을 이용한 failover 기능을 구성하고 있었습니다. Spring Application에서 Jedis를 이용하여 Application sharding을 구성하여 사용을 하였습니다. 이렇게 Redis를 잘 사용하나 싶었지만, 최근 Spring Cache Abstraction에 대해 공부했었고, Redis Replication + Sharding + Failover를 사용하면서 <strong>Spring-Data-Redis를 사용할 방법이 없을까?</strong> 라는 생각을 하게 되었습니다.</p>\n<p>맨 처음에 회사에서 Spring + Redis연동을 할 때 당연히 Spring-Data-Redis를 염두하고 시작을 했었지만, 어느 블로그에서 <strong>Spring-Data-Redis는 Sharding을 지원하지 않는다!</strong> 라는 절망적인 얘기를 보고 여태까지 Docker를 이용해 설치한 방식에서 Jedis를 이용한 Sharding을 이용하고 있었습니다.</p>\n<p>그 이후, Redis 관련 문서를 쭉 보던 중.. Redis 공식 홈페이지에서 <code>Redis Cluster Mode</code>에 대한 내용을 보게 되었습니다.\n그 내용을 요약하자면</p>\n<ul>\n<li>Redis3 버전 부터 Redis는 <code>Cluster Mode</code>를 지원한다.</li>\n<li>Cluster Mode에서는 Redis Sentinel의 도움없이 <code>Cluster 자체적으로 Failover를 진행</code>한다.</li>\n<li>Cluster Mode에서는 Master-Slave 노드 구조를 가질 수 있고, <code>노드 간 Replication을 지원</code>한다.</li>\n<li>Cluster Mode에서는 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행\n<code>Auto Sharding을 지원</code>한다 (이야!!!!!!!!!!!!)</li>\n<li>Application Sharding이 필요없기 때문에, <code>Spring-Data-Redis 사용이 가능하다.</code>\n(사실은 이 목적 때문에 Cluster Mode 설치를 해보게 되었습니다.)</li>\n</ul>\n<h1 id=\"기존에-설치한-redis-구조와-다른-점은\">기존에 설치한 Redis 구조와 다른 점은?</h1>\n<h2 id=\"이전-장까지-설치-했던-redis-구조\">이전 장까지 설치 했던 Redis 구조</h2>\n<p><img src=\"./Redis-Cluster-archi.PNG\" alt=\"Redis-Cluster-archi\"></p>\n<ul>\n<li>Master - Slave -Slave 구조</li>\n<li>Redis Sentinel을 이용한 Master 감시 + Fail over 기능 지원</li>\n<li>HAProxy를 이용한 Master / Slave 접근 Port 분리</li>\n</ul>\n<h2 id=\"새롭게-구성한-redis-cluster\">새롭게 구성한 Redis Cluster</h2>\n<p><img src=\"./new-redis-cluster.PNG\" alt=\"new-redis-cluster\"></p>\n<ul>\n<li>\n<p>HAProxy는 5000번 포트만 사용하도록 축소 5001~5005는 불필요하기 때문</p>\n<ul>\n<li>앞으로는 무조건 Master에만 통신</li>\n<li>어떤 Node와 통신하여 데이터를 set하거나 get 할 수 있음 (Cluster Mode 지원)</li>\n<li>어떤 Node에 set하더라도 자동으로 Sharding</li>\n</ul>\n</li>\n<li>\n<p>감시자 역할의 Sentinel 제거</p>\n<ul>\n<li>Cluster Mode에서는 Redis Node끼리 감시하며 Fail over가 가능합니다.</li>\n</ul>\n</li>\n<li>\n<p>Slave 갯수도 한개로 축소</p>\n</li>\n</ul>\n<h1 id=\"cluster-mode에서-지원하는-기능\">Cluster Mode에서 지원하는 기능</h1>\n<h2 id=\"fail-over\">Fail Over</h2>\n<p><img src=\"./new-redis-cluster2.PNG\" alt=\"new-redis-cluster2\"></p>\n<ul>\n<li>Redis Cluster Mode에서는 기존의 Sentinel을 별도로 설치하여 감시자 역할을 하는 것에서 벗어나 Cluster 자체적으로 Node들을 감시하고 Failover를 수행 할 수 있습니다.</li>\n<li>Redis Cluster Mode를 사용하기 위해서는 각 Redis Node 별로 2개의 port가 열려 있어야 합니다.\n<ul>\n<li>6379, 6380 default - Redis 서버 접속 포트</li>\n<li>16379, 16380 default  <code>(접속 포트 + 10000)</code> - Redis Cluster Bus</li>\n</ul>\n</li>\n<li>Cluster Bus를 이용해 Redis Cluster는 각 노드를 감시하고 서버 다운 시 또는 Connection 유실 시 Fail over를 수행합니다.</li>\n<li>Cluster Bus는 노드 간 데이터 교환에 대해 다른 바이너리 프로토콜을 사용합니다.</li>\n<li>이 프로토콜은 대역폭과 처리 시간을 적게 사용하여 노드 간에 정보를 교환하는 데 더 적합합니다.</li>\n</ul>\n<h2 id=\"auto-sharding\">Auto Sharding</h2>\n<ul>\n<li>Redis Cluster Mode에서는 자동으로 Cluster Node에 대한 자동 샤딩을 제공합니다.</li>\n<li>Redis Cluster에는 16384개의 slot이 있으며, slot에 대한 구간 별로 샤딩이 가능합니다.</li>\n<li>slot을 계산하기 위해 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행합니다.\n<ul>\n<li>[0-5500] 까지는 1번 Redis Node에 저장</li>\n<li>[5501-11000] 까지는 2번 Redis Node에 저장</li>\n<li>[11001-16384] 까지는 3번 Redis Node에 저장</li>\n<li>Redis Node가 scale out 되는 경우 Master Node 수를 나눈 만큼 대역이 할당</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"redis-cli를-이용한-cluster-명령\">Redis-cli를 이용한 cluster 명령</h2>\n<p>Redis 5버전에 포함된 redis-cli 버전 부터 cluster 옵션이 추가 되었습니다.\nRedis 4버전 이하에 대해서는 별도로 Ruby 기반의 프로그램을 설치해야 되서 번거로워서, Redis 5버전으로 설치를 해보았습니다. (성능도 더 좋을라나?ㅎ)</p>\n<h3 id=\"redis-cluster-생성\">Redis Cluster 생성</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster create 192.168.137.101:6379 192.168.137.102:6379 192.168.137.103:6379 \\</span><br><span class=\"line\">192.168.137.102:6380 192.168.137.103:6380 192.168.137.101:6380 \\</span><br><span class=\"line\">--cluster-replicas 1</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>Redis Cluster를 생성하기 위해서는 Master Node가 최소 3개 이상 필요합니다.</li>\n<li>맨 처음 등록하는 3개의 노드가 Master Node</li>\n<li><code>--cluster-replicas 1</code> 의 의미는 각 Slave Node가 1개임을 의미합니다.</li>\n<li>6개의 노드가 등록 되었다면 처음 3개는 Master, 뒤의 3개는 Slave가 됩니다</li>\n<li>Slave는 선언된 순서 대로 Master의 Slave로 등록 됩니다\n<ul>\n<li>192.168.137.101:6379 -&gt; 192.168.137.102:6380</li>\n<li>192.168.137.102:6379 -&gt; 192.168.137.103:6380</li>\n<li>192.168.137.103:6379 -&gt; 192.168.137.101:6380</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"./cluster-setting.PNG\" alt=\"cluster-setting\"></p>\n<p><img src=\"./cluster-setting2.PNG\" alt=\"cluster-setting2\"></p>\n<p>redis-cli에 접속하여 cluster nodes 명령어로 cluster를 구성하는 nodes에 대한 정보를 조회해 보았습니다.</p>\n<p><img src=\"./cluster-nodes.png\" alt=\"cluster-nodes\"></p>\n<h3 id=\"redis-node-add-remove\">Redis Node ADD / REMOVE</h3>\n<p>새로운 노드를 추가하는 과정은 기본적으로 2가지입니다.</p>\n<ul>\n<li>새로운 Master를 추가하는 경우</li>\n<li>새로운 Slave를 추가하는 경우</li>\n</ul>\n<h3 id=\"master-추가\">Master 추가</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster add-node 192.168.137.104:6379 192.168.137.101:6379</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>위 명령은 cluster에 새로운 노드를 추가하는 명령어입니다.</li>\n<li>192.168.137.101:6379 구성 된 Cluster에 192.168.137.104:6379 추가한다는 명령어입니다.</li>\n<li>cluster를 지정할 때는 master node를 아무거나 지정하면 됩니다. (192.168.137.101~103:6379)</li>\n<li>여기까지 했을 때는 Cluster에 일원이 되어 Cluster로 묶여는지나, <code>실제로 데이터는 저장 되지 않습니다.</code></li>\n<li>hash slot이 할당 되지 않았기 때문에 데이터는 저장되지 않습니다.</li>\n<li><code>re-sharding</code>을 통해 slot의 대역을 할당 받아야 합니다.</li>\n</ul>\n<h3 id=\"slave-추가\">Slave 추가</h3>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.</li>\n<li>이 경우에는 새롭게 추가된 노드를 <code>복제본의 수가 적은 마스터</code> 나 임의의 마스터에 대한 Slave로 추가됩니다.</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave\\</span><br><span class=\"line\">--cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e1</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.</li>\n<li>이 경우에는 master node를 지정하기 때문에 특정 master-id에 해당하는 master node의 slave로 추가됩니다.</li>\n</ul>\n<h2 id=\"node-제거\">Node 제거</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster del-node 192.168.137.101:6379 `&lt;node-id&gt;`</span><br><span class=\"line\">redis-cli --cluster del-node 192.168.137.101:6379</span><br><span class=\"line\">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>위 명령은 Redis Cluster의 node를 제거하는 명령어입니다.</li>\n<li>Redis Cluster에 포함된 아무 node를 적어준다 <code>192.168.137.101:6379 는 Redis Cluster 노드 중 하나</code></li>\n<li>node-id는 삭제하고자 하는 node의 id입니다.</li>\n<li>node-id는 cluster nodes 명령어를 통해 검색하여 적어줍니다.</li>\n<li>Slave는 막 지울 수 있습니다!</li>\n<li>하지만 <strong>Master는 노드에 저장된 내용이 하나도 없어야 삭제가 가능합니다.</strong></li>\n<li>지울 수 있는 대안으로는 수동으로 failover를 하여 slave로 만든 다음에 삭제를 하는 방법이 있습니다.</li>\n</ul>\n<h3 id=\"re-sharding\">Re-sharding</h3>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster reshard 192.168.137.101:6379</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>위 명령은 현재 cluster에 대한 reshard를 수행하는 명령어입니다.</li>\n<li>cluster내의 master node 아무거나 써주면 자동으로 cluster node를 스캔하여 reshard를 수행합니다.</li>\n<li>resharding 중에도 무중단으로 redis를 사용할 수 있습니다.</li>\n<li>하지만 resharding을 <strong>수행하는 key에 대해서는 lock이 걸립니다.</strong></li>\n<li>만약 resharding 대상이 많은 경우에는 redis 서버가 중지되었다가 다시 시작 될 수 있습니다.</li>\n</ul>\n<h1 id=\"redis-설치\">Redis 설치</h1>\n<h2 id=\"docker-설정하기\">Docker 설정하기</h2>\n<h3 id=\"docker-composeyml\">docker-compose.yml</h3>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'3'</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"><span class=\"attr\">   redis-master:</span></span><br><span class=\"line\"><span class=\"attr\">      image:</span> <span class=\"attr\">redis:5.0-alpine</span></span><br><span class=\"line\"><span class=\"attr\">      build:</span></span><br><span class=\"line\"><span class=\"attr\">         context:</span> <span class=\"string\">..</span></span><br><span class=\"line\"><span class=\"attr\">         dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\"><span class=\"attr\">      network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\"><span class=\"attr\">      environment:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">REQUIREPASS=&lt;password&gt;</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTPORT=6379</span></span><br><span class=\"line\"><span class=\"attr\">      volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"../../new_redis-data/redis1:/data\"</span></span><br><span class=\"line\"><span class=\"attr\">      restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">   redis-slave:</span></span><br><span class=\"line\"><span class=\"attr\">      image:</span> <span class=\"attr\">redis:5.0-alpine</span></span><br><span class=\"line\"><span class=\"attr\">      build:</span></span><br><span class=\"line\"><span class=\"attr\">         context:</span> <span class=\"string\">..</span></span><br><span class=\"line\"><span class=\"attr\">         dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\"><span class=\"attr\">      network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\"><span class=\"attr\">      environment:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">REQUIREPASS=&lt;password&gt;</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTPORT=6380</span></span><br><span class=\"line\"><span class=\"attr\">      volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"../../new_redis-data/redis2:/data\"</span></span><br><span class=\"line\"><span class=\"attr\">      restart:</span> <span class=\"string\">always</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>redis-cli의 cluster option을 사용하기 위해 redis:5.0-alpine 버전을 사용하였습니다.</li>\n<li>redis:5.0.0이 RELEASE 버전이지만, Dockerfile에서 sed 명령어 사용 시, <code>Permission denied</code>가 발생하는 버그가 있습니다.</li>\n<li>network_mode 는 <code>host</code>로 설정. <code>Docker Redis는 NAT에 대한 지원을 하지 않습니다.</code></li>\n<li>외부 볼륨 연동을 위해 ../../new_redis-data/master 폴더와 docker container 내의 /data 폴더를 연동하였습니다.</li>\n<li>container down 시 항상 재시작 하도록 restart policy를 always로 설정 하였습니다.</li>\n</ul>\n<h3 id=\"docker-entrypointsh\">docker-entrypoint.sh</h3>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -e</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## from redis-5</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/bind 127.0.0.1/bind <span class=\"variable\">$CLIENTHOST</span> 127.0.0.1/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">sed -i <span class=\"string\">\"s/port 6379/port <span class=\"variable\">$CLIENTPORT</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# requirepass foobared/requirepass <span class=\"variable\">$REQUIREPASS</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# masterauth &lt;master-password&gt;/masterauth <span class=\"variable\">$REQUIREPASS</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# cluster-enabled yes/cluster-enabled yes/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# cluster-config-file nodes-6379.conf/cluster-config-file nodes.conf/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# cluster-node-timeout 15000/cluster-node-timeout 5000/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># first arg is `-f` or `--some-option`</span></span><br><span class=\"line\"><span class=\"comment\"># or first arg is `something.conf`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$&#123;1#-&#125;</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> ] || [ <span class=\"string\">\"<span class=\"variable\">$&#123;1%.conf&#125;</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t<span class=\"built_in\">set</span> -- redis-server <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># allow the container to be started with `--user`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> = <span class=\"string\">'redis-server'</span> -a <span class=\"string\">\"<span class=\"variable\">$(id -u)</span>\"</span> = <span class=\"string\">'0'</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\tchown -R redis .</span><br><span class=\"line\">    <span class=\"built_in\">exec</span> su-exec redis <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exec</span> <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>sed명령어를 통해 container내의 redis.conf파일을 치환\n<code>치환자에 대한 설정은 docker-compose.yml &gt; environment에 등록</code>\n<ul>\n<li>bind 옵션에 대해 CLINET IP를 설정</li>\n<li>port도 기본 6379 port에서 6379, 6380으로 치환하였습니다.</li>\n<li>requirepass도 설정</li>\n<li>masterauth도 requirepass와 동일하게 설정</li>\n<li>cluster-mode를 사용하기 위해 <code>cluster-enable yes</code>로 설정</li>\n<li>cluster에 대한 로그를 볼 수 있도록 <code>cluster-config-file nodes.conf</code> conf 파일 지정 (여기에 로그 생성)</li>\n<li>cluster failover를 위해 <code>cluster-node-timeout</code>을 5초로 지정</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"failover-test\">Failover Test</h1>\n<p>테스트를 위해 192.168.137.101:6379 (master1)에 대한 docker container를 죽여보았습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop 030bb02a246e</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./master-down.png\" alt=\"master-down\"></p>\n<ul>\n<li>docker ps -a 명령으로 볼 때 192.168.137.101:6379 (master1)에 대한 docker container가 다운!!</li>\n</ul>\n<p><img src=\"./failover-1.png\" alt=\"failover-1\"></p>\n<ul>\n<li>\n<p>5초 정도 지나니 무슨 로그가 올라왔습니다. epoch vote라는 로그를 보아하니 새로운 마스터를 선출하였습니다.</p>\n</li>\n<li>\n<p>redis-cli를 통해 <code>cluster nodes</code>를 검색해 보니 <code>192.168.137.101:6379 (master1)</code>의 slave였던 <code>192.168.137.103:6380 (slave1)</code> 가 새로운 master로 promote 되었습니다.</p>\n</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start 030bb02a246e</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>docker start 명령으로 다시 container를 살려보았습니다.</li>\n</ul>\n<p><img src=\"./failover2.png\" alt=\"failover2\"></p>\n<ul>\n<li>기존의 master는 slave로 편입되어 정상적인 cluster가 작동하고 있습니다.</li>\n</ul>\n<h1 id=\"sharding-test\">Sharding Test</h1>\n<p><img src=\"./cluster-keys-command.PNG\" alt=\"cluster-keys-command\"></p>\n<ul>\n<li>redis-cli를 통해 foo1~foo10까지 key를 만들어 set해 보았습니다.</li>\n<li>set할때 마다 16384 modules 연산을 통해 slot별로 sharding이 되는 모습입니다.</li>\n<li>각 redis-cli에서 keys * 명령을 통해 조회 해보면 고르게 sharding이 되어있음을 확인 할 수 있습니다.</li>\n</ul>\n<h1 id=\"node-addremove\">Node ADD/REMOVE</h1>\n<p><img src=\"./cluster-add.PNG\" alt=\"cluster-add\"></p>\n<ul>\n<li>신규 Master node (192.168.137.104:6379)를 새로이 추가해 보았습니다.</li>\n</ul>\n<p><img src=\"./cluster-add-node-slave.PNG\" alt=\"cluster-add-node-slave\">\n<img src=\"./slave-add-result.png\" alt=\"slave-add-result\"></p>\n<ul>\n<li>신규 Slave node (192.168.137.104:6380)를 새로이 추가해 보았습니다.</li>\n<li>신규 Master node (192.168.137.104:6379)의 slave로 추가해보았다.</li>\n<li>정상적으로 모두 등록 되었다.</li>\n</ul>\n<p><img src=\"./slave-del.png\" alt=\"slave-del\"></p>\n<ul>\n<li>slave를 삭제해 보았습니다.</li>\n</ul>\n<p><img src=\"./slave-del-result.png\" alt=\"slave-del-result\"></p>\n<ul>\n<li>slave가 정상적으로 삭제 되었습니다.</li>\n</ul>\n<p><img src=\"./master-del-fail.png\" alt=\"master-del-fail\"></p>\n<ul>\n<li>master 삭제를 시도해 보았습니다.</li>\n<li>slot이 비어있지 않아 삭제가 불가능 했습니다.</li>\n<li>이런 경우 reshard를 통해 slot을 비워준뒤에 삭제 해야합니다.</li>\n</ul>\n<p><img src=\"./sub-reshard.PNG\" alt=\"sub-reshard\"></p>\n<ul>\n<li>reshard 명령을 다시 실행 합니다.</li>\n<li><code>What is the receiving node ID?</code> 라는 질문에 192.168.137.101:6379 node-id를 지정합니다.</li>\n<li><code>Source node</code> 항목에는 우리가 삭제할 192.168.137.104:6379 node-id를 지정합니다.</li>\n<li><code>source node</code> 두번째 항목에는 done을 입력하여 Source node 항목을 모두 입력하였음을 선언해 줍니다.</li>\n</ul>\n<p><img src=\"./master-del-success.png\" alt=\"master-del-success\"></p>\n<ul>\n<li>다시 master를 삭제하니 정상적으로 삭제가 됩니다.</li>\n</ul>\n<h1 id=\"re-sharding-test\">Re-Sharding Test</h1>\n<p><img src=\"./reshard-test-1-3831920.PNG\" alt=\"reshard-test-1\"></p>\n<ul>\n<li>새롭게 추가한 노드에 reshard를 해보았습니다.</li>\n<li>4000개정도를 새로이 옮긴다고 조건을 주고 Resharding을 실행 해보았습니다.\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"./reshard-test-2-3832564.PNG\" alt=\"reshard-test-2\"></p>\n<p><img src=\"./reshard-test-3.PNG\" alt=\"reshard-test-3\"></p>\n<ul>\n<li>정상적으로 resharding이 되어 데이터가 4개의 node에 고르게 분포 되었습니다.</li>\n</ul>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>https://redis.io/topics/cluster-tutorial</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>이전 장 까지 했던 Redis 구조는 <code>Redis Replication + Redis Sentinel</code>을 이용한 failover 기능을 구성하고 있었습니다. Spring Application에서 Jedis를 이용하여 Application sharding을 구성하여 사용을 하였습니다. 이렇게 Redis를 잘 사용하나 싶었지만, 최근 Spring Cache Abstraction에 대해 공부했었고, Redis Replication + Sharding + Failover를 사용하면서 <strong>Spring-Data-Redis를 사용할 방법이 없을까?</strong> 라는 생각을 하게 되었습니다.</p>\n<p>맨 처음에 회사에서 Spring + Redis연동을 할 때 당연히 Spring-Data-Redis를 염두하고 시작을 했었지만, 어느 블로그에서 <strong>Spring-Data-Redis는 Sharding을 지원하지 않는다!</strong> 라는 절망적인 얘기를 보고 여태까지 Docker를 이용해 설치한 방식에서 Jedis를 이용한 Sharding을 이용하고 있었습니다.</p>\n<p>그 이후, Redis 관련 문서를 쭉 보던 중.. Redis 공식 홈페이지에서 <code>Redis Cluster Mode</code>에 대한 내용을 보게 되었습니다.\n그 내용을 요약하자면</p>\n<ul>\n<li>Redis3 버전 부터 Redis는 <code>Cluster Mode</code>를 지원한다.</li>\n<li>Cluster Mode에서는 Redis Sentinel의 도움없이 <code>Cluster 자체적으로 Failover를 진행</code>한다.</li>\n<li>Cluster Mode에서는 Master-Slave 노드 구조를 가질 수 있고, <code>노드 간 Replication을 지원</code>한다.</li>\n<li>Cluster Mode에서는 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행\n<code>Auto Sharding을 지원</code>한다 (이야!!!!!!!!!!!!)</li>\n<li>Application Sharding이 필요없기 때문에, <code>Spring-Data-Redis 사용이 가능하다.</code>\n(사실은 이 목적 때문에 Cluster Mode 설치를 해보게 되었습니다.)</li>\n</ul>\n<h1>기존에 설치한 Redis 구조와 다른 점은?</h1>\n<h2>이전 장까지 설치 했던 Redis 구조</h2>\n<p><img src=\"./Redis-Cluster-archi.PNG\" alt=\"Redis-Cluster-archi\"></p>\n<ul>\n<li>Master - Slave -Slave 구조</li>\n<li>Redis Sentinel을 이용한 Master 감시 + Fail over 기능 지원</li>\n<li>HAProxy를 이용한 Master / Slave 접근 Port 분리</li>\n</ul>\n<h2>새롭게 구성한 Redis Cluster</h2>\n<p><img src=\"./new-redis-cluster.PNG\" alt=\"new-redis-cluster\"></p>\n<ul>\n<li>\n<p>HAProxy는 5000번 포트만 사용하도록 축소 5001~5005는 불필요하기 때문</p>\n<ul>\n<li>앞으로는 무조건 Master에만 통신</li>\n<li>어떤 Node와 통신하여 데이터를 set하거나 get 할 수 있음 (Cluster Mode 지원)</li>\n<li>어떤 Node에 set하더라도 자동으로 Sharding</li>\n</ul>\n</li>\n<li>\n<p>감시자 역할의 Sentinel 제거</p>\n<ul>\n<li>Cluster Mode에서는 Redis Node끼리 감시하며 Fail over가 가능합니다.</li>\n</ul>\n</li>\n<li>\n<p>Slave 갯수도 한개로 축소</p>\n</li>\n</ul>\n<h1>Cluster Mode에서 지원하는 기능</h1>\n<h2>Fail Over</h2>\n<p><img src=\"./new-redis-cluster2.PNG\" alt=\"new-redis-cluster2\"></p>\n<ul>\n<li>Redis Cluster Mode에서는 기존의 Sentinel을 별도로 설치하여 감시자 역할을 하는 것에서 벗어나 Cluster 자체적으로 Node들을 감시하고 Failover를 수행 할 수 있습니다.</li>\n<li>Redis Cluster Mode를 사용하기 위해서는 각 Redis Node 별로 2개의 port가 열려 있어야 합니다.\n<ul>\n<li>6379, 6380 default - Redis 서버 접속 포트</li>\n<li>16379, 16380 default  <code>(접속 포트 + 10000)</code> - Redis Cluster Bus</li>\n</ul>\n</li>\n<li>Cluster Bus를 이용해 Redis Cluster는 각 노드를 감시하고 서버 다운 시 또는 Connection 유실 시 Fail over를 수행합니다.</li>\n<li>Cluster Bus는 노드 간 데이터 교환에 대해 다른 바이너리 프로토콜을 사용합니다.</li>\n<li>이 프로토콜은 대역폭과 처리 시간을 적게 사용하여 노드 간에 정보를 교환하는 데 더 적합합니다.</li>\n</ul>\n<h2>Auto Sharding</h2>\n<ul>\n<li>Redis Cluster Mode에서는 자동으로 Cluster Node에 대한 자동 샤딩을 제공합니다.</li>\n<li>Redis Cluster에는 16384개의 slot이 있으며, slot에 대한 구간 별로 샤딩이 가능합니다.</li>\n<li>slot을 계산하기 위해 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행합니다.\n<ul>\n<li>[0-5500] 까지는 1번 Redis Node에 저장</li>\n<li>[5501-11000] 까지는 2번 Redis Node에 저장</li>\n<li>[11001-16384] 까지는 3번 Redis Node에 저장</li>\n<li>Redis Node가 scale out 되는 경우 Master Node 수를 나눈 만큼 대역이 할당</li>\n</ul>\n</li>\n</ul>\n<h2>Redis-cli를 이용한 cluster 명령</h2>\n<p>Redis 5버전에 포함된 redis-cli 버전 부터 cluster 옵션이 추가 되었습니다.\nRedis 4버전 이하에 대해서는 별도로 Ruby 기반의 프로그램을 설치해야 되서 번거로워서, Redis 5버전으로 설치를 해보았습니다. (성능도 더 좋을라나?ㅎ)</p>\n<h3>Redis Cluster 생성</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster create 192.168.137.101:6379 192.168.137.102:6379 192.168.137.103:6379 \\</span><br><span class=\"line\">192.168.137.102:6380 192.168.137.103:6380 192.168.137.101:6380 \\</span><br><span class=\"line\">--cluster-replicas 1</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>Redis Cluster를 생성하기 위해서는 Master Node가 최소 3개 이상 필요합니다.</li>\n<li>맨 처음 등록하는 3개의 노드가 Master Node</li>\n<li><code>--cluster-replicas 1</code> 의 의미는 각 Slave Node가 1개임을 의미합니다.</li>\n<li>6개의 노드가 등록 되었다면 처음 3개는 Master, 뒤의 3개는 Slave가 됩니다</li>\n<li>Slave는 선언된 순서 대로 Master의 Slave로 등록 됩니다\n<ul>\n<li>192.168.137.101:6379 -&gt; 192.168.137.102:6380</li>\n<li>192.168.137.102:6379 -&gt; 192.168.137.103:6380</li>\n<li>192.168.137.103:6379 -&gt; 192.168.137.101:6380</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"./cluster-setting.PNG\" alt=\"cluster-setting\"></p>\n<p><img src=\"./cluster-setting2.PNG\" alt=\"cluster-setting2\"></p>\n<p>redis-cli에 접속하여 cluster nodes 명령어로 cluster를 구성하는 nodes에 대한 정보를 조회해 보았습니다.</p>\n<p><img src=\"./cluster-nodes.png\" alt=\"cluster-nodes\"></p>\n<h3>Redis Node ADD / REMOVE</h3>\n<p>새로운 노드를 추가하는 과정은 기본적으로 2가지입니다.</p>\n<ul>\n<li>새로운 Master를 추가하는 경우</li>\n<li>새로운 Slave를 추가하는 경우</li>\n</ul>\n<h3>Master 추가</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster add-node 192.168.137.104:6379 192.168.137.101:6379</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>위 명령은 cluster에 새로운 노드를 추가하는 명령어입니다.</li>\n<li>192.168.137.101:6379 구성 된 Cluster에 192.168.137.104:6379 추가한다는 명령어입니다.</li>\n<li>cluster를 지정할 때는 master node를 아무거나 지정하면 됩니다. (192.168.137.101~103:6379)</li>\n<li>여기까지 했을 때는 Cluster에 일원이 되어 Cluster로 묶여는지나, <code>실제로 데이터는 저장 되지 않습니다.</code></li>\n<li>hash slot이 할당 되지 않았기 때문에 데이터는 저장되지 않습니다.</li>\n<li><code>re-sharding</code>을 통해 slot의 대역을 할당 받아야 합니다.</li>\n</ul>\n<h3>Slave 추가</h3>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.</li>\n<li>이 경우에는 새롭게 추가된 노드를 <code>복제본의 수가 적은 마스터</code> 나 임의의 마스터에 대한 Slave로 추가됩니다.</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave\\</span><br><span class=\"line\">--cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e1</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.</li>\n<li>이 경우에는 master node를 지정하기 때문에 특정 master-id에 해당하는 master node의 slave로 추가됩니다.</li>\n</ul>\n<h2>Node 제거</h2>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster del-node 192.168.137.101:6379 `&lt;node-id&gt;`</span><br><span class=\"line\">redis-cli --cluster del-node 192.168.137.101:6379</span><br><span class=\"line\">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>위 명령은 Redis Cluster의 node를 제거하는 명령어입니다.</li>\n<li>Redis Cluster에 포함된 아무 node를 적어준다 <code>192.168.137.101:6379 는 Redis Cluster 노드 중 하나</code></li>\n<li>node-id는 삭제하고자 하는 node의 id입니다.</li>\n<li>node-id는 cluster nodes 명령어를 통해 검색하여 적어줍니다.</li>\n<li>Slave는 막 지울 수 있습니다!</li>\n<li>하지만 <strong>Master는 노드에 저장된 내용이 하나도 없어야 삭제가 가능합니다.</strong></li>\n<li>지울 수 있는 대안으로는 수동으로 failover를 하여 slave로 만든 다음에 삭제를 하는 방법이 있습니다.</li>\n</ul>\n<h3>Re-sharding</h3>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster reshard 192.168.137.101:6379</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>위 명령은 현재 cluster에 대한 reshard를 수행하는 명령어입니다.</li>\n<li>cluster내의 master node 아무거나 써주면 자동으로 cluster node를 스캔하여 reshard를 수행합니다.</li>\n<li>resharding 중에도 무중단으로 redis를 사용할 수 있습니다.</li>\n<li>하지만 resharding을 <strong>수행하는 key에 대해서는 lock이 걸립니다.</strong></li>\n<li>만약 resharding 대상이 많은 경우에는 redis 서버가 중지되었다가 다시 시작 될 수 있습니다.</li>\n</ul>\n<h1>Redis 설치</h1>\n<h2>Docker 설정하기</h2>\n<h3>docker-compose.yml</h3>\n<p><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'3'</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"><span class=\"attr\">   redis-master:</span></span><br><span class=\"line\"><span class=\"attr\">      image:</span> <span class=\"attr\">redis:5.0-alpine</span></span><br><span class=\"line\"><span class=\"attr\">      build:</span></span><br><span class=\"line\"><span class=\"attr\">         context:</span> <span class=\"string\">..</span></span><br><span class=\"line\"><span class=\"attr\">         dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\"><span class=\"attr\">      network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\"><span class=\"attr\">      environment:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">REQUIREPASS=&lt;password&gt;</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTPORT=6379</span></span><br><span class=\"line\"><span class=\"attr\">      volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"../../new_redis-data/redis1:/data\"</span></span><br><span class=\"line\"><span class=\"attr\">      restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">   redis-slave:</span></span><br><span class=\"line\"><span class=\"attr\">      image:</span> <span class=\"attr\">redis:5.0-alpine</span></span><br><span class=\"line\"><span class=\"attr\">      build:</span></span><br><span class=\"line\"><span class=\"attr\">         context:</span> <span class=\"string\">..</span></span><br><span class=\"line\"><span class=\"attr\">         dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\"><span class=\"attr\">      network_mode:</span> <span class=\"string\">\"host\"</span></span><br><span class=\"line\"><span class=\"attr\">      environment:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">REQUIREPASS=&lt;password&gt;</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTHOST=192.168.137.101</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">CLIENTPORT=6380</span></span><br><span class=\"line\"><span class=\"attr\">      volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"../../new_redis-data/redis2:/data\"</span></span><br><span class=\"line\"><span class=\"attr\">      restart:</span> <span class=\"string\">always</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>redis-cli의 cluster option을 사용하기 위해 redis:5.0-alpine 버전을 사용하였습니다.</li>\n<li>redis:5.0.0이 RELEASE 버전이지만, Dockerfile에서 sed 명령어 사용 시, <code>Permission denied</code>가 발생하는 버그가 있습니다.</li>\n<li>network_mode 는 <code>host</code>로 설정. <code>Docker Redis는 NAT에 대한 지원을 하지 않습니다.</code></li>\n<li>외부 볼륨 연동을 위해 ../../new_redis-data/master 폴더와 docker container 내의 /data 폴더를 연동하였습니다.</li>\n<li>container down 시 항상 재시작 하도록 restart policy를 always로 설정 하였습니다.</li>\n</ul>\n<h3>docker-entrypoint.sh</h3>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -e</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## from redis-5</span></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/bind 127.0.0.1/bind <span class=\"variable\">$CLIENTHOST</span> 127.0.0.1/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">sed -i <span class=\"string\">\"s/port 6379/port <span class=\"variable\">$CLIENTPORT</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# requirepass foobared/requirepass <span class=\"variable\">$REQUIREPASS</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# masterauth &lt;master-password&gt;/masterauth <span class=\"variable\">$REQUIREPASS</span>/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# cluster-enabled yes/cluster-enabled yes/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# cluster-config-file nodes-6379.conf/cluster-config-file nodes.conf/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\">sed -i <span class=\"string\">\"s/# cluster-node-timeout 15000/cluster-node-timeout 5000/g\"</span> /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># first arg is `-f` or `--some-option`</span></span><br><span class=\"line\"><span class=\"comment\"># or first arg is `something.conf`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$&#123;1#-&#125;</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> ] || [ <span class=\"string\">\"<span class=\"variable\">$&#123;1%.conf&#125;</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t<span class=\"built_in\">set</span> -- redis-server <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># allow the container to be started with `--user`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> = <span class=\"string\">'redis-server'</span> -a <span class=\"string\">\"<span class=\"variable\">$(id -u)</span>\"</span> = <span class=\"string\">'0'</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\tchown -R redis .</span><br><span class=\"line\">    <span class=\"built_in\">exec</span> su-exec redis <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exec</span> <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>sed명령어를 통해 container내의 redis.conf파일을 치환\n<code>치환자에 대한 설정은 docker-compose.yml &gt; environment에 등록</code>\n<ul>\n<li>bind 옵션에 대해 CLINET IP를 설정</li>\n<li>port도 기본 6379 port에서 6379, 6380으로 치환하였습니다.</li>\n<li>requirepass도 설정</li>\n<li>masterauth도 requirepass와 동일하게 설정</li>\n<li>cluster-mode를 사용하기 위해 <code>cluster-enable yes</code>로 설정</li>\n<li>cluster에 대한 로그를 볼 수 있도록 <code>cluster-config-file nodes.conf</code> conf 파일 지정 (여기에 로그 생성)</li>\n<li>cluster failover를 위해 <code>cluster-node-timeout</code>을 5초로 지정</li>\n</ul>\n</li>\n</ul>\n<h1>Failover Test</h1>\n<p>테스트를 위해 192.168.137.101:6379 (master1)에 대한 docker container를 죽여보았습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop 030bb02a246e</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./master-down.png\" alt=\"master-down\"></p>\n<ul>\n<li>docker ps -a 명령으로 볼 때 192.168.137.101:6379 (master1)에 대한 docker container가 다운!!</li>\n</ul>\n<p><img src=\"./failover-1.png\" alt=\"failover-1\"></p>\n<ul>\n<li>\n<p>5초 정도 지나니 무슨 로그가 올라왔습니다. epoch vote라는 로그를 보아하니 새로운 마스터를 선출하였습니다.</p>\n</li>\n<li>\n<p>redis-cli를 통해 <code>cluster nodes</code>를 검색해 보니 <code>192.168.137.101:6379 (master1)</code>의 slave였던 <code>192.168.137.103:6380 (slave1)</code> 가 새로운 master로 promote 되었습니다.</p>\n</li>\n</ul>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start 030bb02a246e</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>docker start 명령으로 다시 container를 살려보았습니다.</li>\n</ul>\n<p><img src=\"./failover2.png\" alt=\"failover2\"></p>\n<ul>\n<li>기존의 master는 slave로 편입되어 정상적인 cluster가 작동하고 있습니다.</li>\n</ul>\n<h1>Sharding Test</h1>\n<p><img src=\"./cluster-keys-command.PNG\" alt=\"cluster-keys-command\"></p>\n<ul>\n<li>redis-cli를 통해 foo1~foo10까지 key를 만들어 set해 보았습니다.</li>\n<li>set할때 마다 16384 modules 연산을 통해 slot별로 sharding이 되는 모습입니다.</li>\n<li>각 redis-cli에서 keys * 명령을 통해 조회 해보면 고르게 sharding이 되어있음을 확인 할 수 있습니다.</li>\n</ul>\n<h1>Node ADD/REMOVE</h1>\n<p><img src=\"./cluster-add.PNG\" alt=\"cluster-add\"></p>\n<ul>\n<li>신규 Master node (192.168.137.104:6379)를 새로이 추가해 보았습니다.</li>\n</ul>\n<p><img src=\"./cluster-add-node-slave.PNG\" alt=\"cluster-add-node-slave\">\n<img src=\"./slave-add-result.png\" alt=\"slave-add-result\"></p>\n<ul>\n<li>신규 Slave node (192.168.137.104:6380)를 새로이 추가해 보았습니다.</li>\n<li>신규 Master node (192.168.137.104:6379)의 slave로 추가해보았다.</li>\n<li>정상적으로 모두 등록 되었다.</li>\n</ul>\n<p><img src=\"./slave-del.png\" alt=\"slave-del\"></p>\n<ul>\n<li>slave를 삭제해 보았습니다.</li>\n</ul>\n<p><img src=\"./slave-del-result.png\" alt=\"slave-del-result\"></p>\n<ul>\n<li>slave가 정상적으로 삭제 되었습니다.</li>\n</ul>\n<p><img src=\"./master-del-fail.png\" alt=\"master-del-fail\"></p>\n<ul>\n<li>master 삭제를 시도해 보았습니다.</li>\n<li>slot이 비어있지 않아 삭제가 불가능 했습니다.</li>\n<li>이런 경우 reshard를 통해 slot을 비워준뒤에 삭제 해야합니다.</li>\n</ul>\n<p><img src=\"./sub-reshard.PNG\" alt=\"sub-reshard\"></p>\n<ul>\n<li>reshard 명령을 다시 실행 합니다.</li>\n<li><code>What is the receiving node ID?</code> 라는 질문에 192.168.137.101:6379 node-id를 지정합니다.</li>\n<li><code>Source node</code> 항목에는 우리가 삭제할 192.168.137.104:6379 node-id를 지정합니다.</li>\n<li><code>source node</code> 두번째 항목에는 done을 입력하여 Source node 항목을 모두 입력하였음을 선언해 줍니다.</li>\n</ul>\n<p><img src=\"./master-del-success.png\" alt=\"master-del-success\"></p>\n<ul>\n<li>다시 master를 삭제하니 정상적으로 삭제가 됩니다.</li>\n</ul>\n<h1>Re-Sharding Test</h1>\n<p><img src=\"./reshard-test-1-3831920.PNG\" alt=\"reshard-test-1\"></p>\n<ul>\n<li>새롭게 추가한 노드에 reshard를 해보았습니다.</li>\n<li>4000개정도를 새로이 옮긴다고 조건을 주고 Resharding을 실행 해보았습니다.\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"./reshard-test-2-3832564.PNG\" alt=\"reshard-test-2\"></p>\n<p><img src=\"./reshard-test-3.PNG\" alt=\"reshard-test-3\"></p>\n<ul>\n<li>정상적으로 resharding이 되어 데이터가 4개의 node에 고르게 분포 되었습니다.</li>\n</ul>\n<h1>참고</h1>\n<ul>\n<li>https://redis.io/topics/cluster-tutorial</li>\n</ul>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (8) HAProxy를 이용한 분산처리 환경 구축하기","date":"2018-12-02T11:32:11.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-12-02-docker-8","typora-copy-images-to":"2018-12-02-docker-8","_content":"\n# HAProxy란?\n\nHAProxy는 기존의 하드웨어 스위치(L4/L7)을 대체하는 소프트웨어 로드밸런서입니다.\n로드 밸런싱이란 부하 분산을 위해서 가상IP를 통해 여러서버에 접속하도록 트래픽을 분배해 주는 기능을 의미합니다.\n\n\n\n# Redis-Cluster에 HAProxy가 필요한 이유\n\nRedis Cluster에서는 Failover가 일어날 수 있습니다.\n\n처음에 1번이 Master였다가, 2번이 Master가 되고, 3번이 Master가 될 수 있습니다.\n하지만 Redis Cluster를 사용하는 Application에서 항상 바뀌는 Master의 포트정보를 찾는것은 매우 비용을 낭비하는 행위라 볼 수 있습니다.\n\n따라서 HAProxy에서 Health check를 하면서 실시간으로 Master를 찾아 신호를 보내줄 수 있기 때문에 HAProxy를 Redis-Cluster에 접목하였습니다.\n\n\n\n# 다시 한번 보는 Redis Cluster 구성도\n\n![Redis-Cluster-archi](./Redis-Cluster-archi.PNG)\n\nHAProxy Port를 6개를 지정합니다. (각각 1개는 Master Port, Slave Port라고 가정하고 (1(master)+1(slave)) x 3 (서버대수))\n\n5000, 5002, 5004번 Port는 각 서버의 Master Redis를 체크합니다.\n따라서 5000, 5002, 5004으로 들어온 요청은 각각의 서버의 Master Redis에 전달 됩니다.\n\n다음으로 5001, 5003, 5005번 Port는 각 서버의 Slave Redis를 체크합니다.\n따라서 5001, 5003, 5005으로 들어온 요청은 각각의 서버의 Slave Redis들에게 전달됩니다. (HAProxy에는 여러 서버에 대한 분배방식을 설정 할 수 있는데 고루게 요청할 수 있도록 RoundRobin 방식으로 설정하였습니다)\n\n\n\n# HAProxy 설치방법\n\n```sh\n# 관련 모듈을 yum으로 설치한다.\nyum install gcc gcc-c++ pcre-devel openssl-devel\n\n# wget명령어도 haproxy 다운로드\nwget http://www.haproxy.org/download/1.8/src/haproxy-1.8.3.tar.gz\n\n# 압축을 풀어준다.\ntar zxvf haproxy-1.8.3.tar.gz\n\n# 디렉토리 이동\ncd haproxy-1.8.3\n\n# c파일을 컴파일 해준다. https 사용이 필요한 경우 USE_OPENSSL=1 설정 추가\nmake TARGET=linux2628 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 \n\n# /usr/local/haproxy 디렉토리에 설치\nmake PREFIX=/usr/local/haproxy DESTDIR= install\n```\n\n\n\n# haproxy.cfg 파일 작성\n\nhaproxy.cfg 파일을 작성 할 때는 크게 2가지 관점으로 작성합니다.\n\n* frontend : haproxy에서 사용할 포트 설정, 포트로 신호가 왔을 시 실행할 backend 연결\n* backend : frontend로 부터 온 신호를 바탕으로 연결가능한 서버에 트래픽을 분배\n\n```bash\n\nglobal\n  log 127.0.0.1 local0\n  log 127.0.0.1 local1 notice\n \ndefaults REDIS\nmode tcp\ntimeout connect 4s\ntimeout server 15s\ntimeout client 15s\n# timeout tunnel 365d\n \nfrontend front_redis_master1\n bind *:5000 name redis                 #5000번 포트에 대한 bind 정보입니다.\n default_backend back_redis_master1     #5000번 포트로 신호가 들어오면 backend를 실행\n \nbackend back_redis_master1\n option tcp-check                       #tcp-check를 통해 접근가능한 서버 필터링\n tcp-check send AUTH\\ password1234\\r\\n  #비밀번호 password1234를 입력하고 Redis 서버에 접속합니다.\n tcp-check expect string +OK            #OK가 왔는지?\n tcp-check send PING\\r\\n                #PING을 날려 신호를 점검합니다.\n tcp-check expect string +PONG          #PONG이라는 응답이 왔는지?\n tcp-check send info\\ replication\\r\\n   #info replication 명령을 날려 Redis에 대한 정보를 받아옵니다.\n tcp-check expect string role:master    #role이 master인지 확인 합니다.\n \n #repl_backlog_active의 값이 1인지 확인합니다 \n #이 조건을 추가한 이유는 Failover간 잠시의 시간동안 Master가 2대가 되는데 그것을 방지 하기 위함입니다.\n #(진짜 Master Redis에만 1, slave는 0)\n tcp-check expect string repl_backlog_active:1 \n tcp-check send QUIT\\r\\n                #QUIT 명령을 전송\n tcp-check expect string +OK\n server redis1 192.168.137.101:6379 check inter 1s  #1초 단위로 해당 ip의 port로 체크합니다.\n server redis2 192.168.137.101:6380 check inter 1s  #1초 단위로 해당 ip의 port로 체크합니다.\n server redis3 192.168.137.101:6381 check inter 1s  #1초 단위로 해당 ip의 port로 체크합니다.\n \nfrontend front_redis_slave1\nbind *:5001 name redis                #5001번 포트에 대한 bind 정보입니다.\ndefault_backend back_redis_slave1\n \nbackend back_redis_slave1\n balance roundrobin                   #라운드 로빈 방식으로 분배\n option tcp-check\n tcp-check send AUTH\\ password1234\\r\\n        \n tcp-check expect string +OK\n tcp-check send PING\\r\\n              \n tcp-check expect string +PONG\n tcp-check send info\\ replication\\r\\n \n tcp-check expect string role:slave   #role key가 slave인지 확인 합니다.\n tcp-check send QUIT\\r\\n\n tcp-check expect string +OK\n server redis1 192.168.137.101:6379 check inter 1s  #1초 단위로 해당 ip의 port로 체크합니다.\n server redis2 192.168.137.101:6380 check inter 1s  #1초 단위로 해당 ip의 port로 체크합니다.\n server redis3 192.168.137.101:6381 check inter 1s  #1초 단위로 해당 ip의 port로 체크합니다.\n \n#Listen on all IP's on port 9000 //9000 포트로 접근 시, Web Console에 진입할 수 있습니다. \nlisten stats\n   bind 0.0.0.0:9000 \n   mode http\n   balance\n   timeout client 5000\n   timeout connect 4000\n   timeout server 30000\n \n   #This is the virtual URL to access the stats page\n   stats uri /haproxy_stats //URL주소는 ip:9000/haproxy_stats입니다.\n   #Authentication realm. This can be set to anything. Escape space characters with a backslash.\n   stats realm HAProxy\\ Statistics\n \n   #The user/pass you want to use. Change this password!\n   stats auth admin:1234 #Web Console에 접근하는 계정/암호 설정\n \n   #This allows you to take down and bring up back end servers.\n   #This will produce an error on older versions of HAProxy.\n   stats admin if TRUE\n```\n\n위의 내용에서는 일단 하나의 Master-Slave에 대한 설정값만 있습니다.\n여태까지 설치 내용에서는 Master-Slave 구성이 3세트이기 때문에 실제 haproxy.cfg를 작성 할 경우에는 \n5002~5005번 포트를 사용하는 설정에 대해서도 추가해야 합니다.\n\n\n\n# HAProxy Web Console 확인하기\n\n![haproxy1](./haproxy1.PNG)\n\n**haproxy-server-ip:9000** 으로 접속하였습니다\n현재 192.168.137.101 서버에는 6379, 6380, 6381 포트를 사용하는 Redis 노드가 3개가 동작하고 있습니다.\n현재 master 역할을 수행하는 것은 6380 포트를 사용하는 redis2 노드입니다.\n따라서 **haproxy-server-ip:5000** 으로 접속하게 되면 redis2 노드에 신호가 분배되어 Redis master서버에 대한 명령을 실행 할 수 있습니다.\n\n\n\n현재 slave 역할을 수행하는 것은 6379, 6381포트를 사용하는 redis1, redis3노드 입니다.\n따라서 **haproxy-server-ip:5001**으로 접속하게 되면 RoundRobin 방식으로 redis1, redis3 노드에 신호가 분배되어 Redis slave 서버에 대한 명령을 실행 할 수 있습니다\n\n> **HAProxy를 구성한 이유**\n>\n> Application에서 Redis를 사용하면서, Master에만 데이터를 입력하고, Slave에서만 데이터를 조회하려는 행위를 많이 하게 됩니다. 아무래도 Redis서버에 대한 부하를 줄여주고자 이러한 행위를 하게 되는데, Haproxy를 설정 해 두면, Application Server에서 failover로 인해 변하는 master/slave 포트에 대한 걱정을 할 필요가 없습니다.\n> HAProxy에서 알아서 tcp-check를 통해 master/slave를 정해주기 때문입니다.\n\n\n\n# Failover Test\n\nSentinel 테스트와 동일하게 Master를 죽여보도록 하겠습니다.\n\n```sh\ndocker stop <master-node-id>\n```\n\n![haproxy2](./haproxy2.PNG)\n\nMaster node를 죽이니, 5000번 포트에서는 더이상 master로 갈 수 있는 서버가 없다고 나옵니다.\n(**이 때 순단을 최소화 하려면 failover 시간과, HAProxy tcp-check 시간을 최소로 줄여야 합니다.**)\n\n\n\n![haproxy3](./haproxy3.PNG)\n\n잠시 시간이 지나고 Redis Failover가 진행됩니다. 진행이 완료되면, HAProxy에서도 tcp-check가 이루어집니다.\n\n\n\n![haproxy4](./haproxy4.PNG)\n\ntcp-check가 끝나고 redis1 노드가 master로 선출되어, 5000번 포트로 접근 시, redis1 노드로 분산되게 됩니다.\n\n\n\n\n\n다시, 죽었던 redis2 노드를 살려보겠습니다.\n\n```sh\ndocker start <redis2_node_id>\n```\n\n\n\n![haproxy5](./haproxy5.PNG)\n\nredis2 노드가 다시 살아나고, sentinel에서도 role-change 작업이 이루어집니다.\n곧이어, HAProxy에서도 tcp-check를 통해 redis2노드가 slave가 되었음을 확인하고 5001 포트에서 분배가능한 서버로 분류됩니다.\n\n\n\n![haproxy6](./haproxy6.PNG)\n\n\n\n이와 같이 Application Server에서는 무조건 master port는 5000번, slave port는 5001번 이라고만 알고 있으면 Redis서버에서 failover가 진행되더라도, 설정을 바꿀 필요없이 사용이 가능합니다.\n\n\n\n\n\n# 참고\n\n* http://blog.whitelife.co.kr/321","source":"_posts/2018-12-02-docker-8.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (8) HAProxy를 이용한 분산처리 환경 구축하기\ndate: 2018-12-02 20:32:11\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-12-02-docker-8\ntypora-copy-images-to: 2018-12-02-docker-8\n---\n\n# HAProxy란?\n\nHAProxy는 기존의 하드웨어 스위치(L4/L7)을 대체하는 소프트웨어 로드밸런서입니다.\n로드 밸런싱이란 부하 분산을 위해서 가상IP를 통해 여러서버에 접속하도록 트래픽을 분배해 주는 기능을 의미합니다.\n\n\n\n# Redis-Cluster에 HAProxy가 필요한 이유\n\nRedis Cluster에서는 Failover가 일어날 수 있습니다.\n\n처음에 1번이 Master였다가, 2번이 Master가 되고, 3번이 Master가 될 수 있습니다.\n하지만 Redis Cluster를 사용하는 Application에서 항상 바뀌는 Master의 포트정보를 찾는것은 매우 비용을 낭비하는 행위라 볼 수 있습니다.\n\n따라서 HAProxy에서 Health check를 하면서 실시간으로 Master를 찾아 신호를 보내줄 수 있기 때문에 HAProxy를 Redis-Cluster에 접목하였습니다.\n\n\n\n# 다시 한번 보는 Redis Cluster 구성도\n\n![Redis-Cluster-archi](./Redis-Cluster-archi.PNG)\n\nHAProxy Port를 6개를 지정합니다. (각각 1개는 Master Port, Slave Port라고 가정하고 (1(master)+1(slave)) x 3 (서버대수))\n\n5000, 5002, 5004번 Port는 각 서버의 Master Redis를 체크합니다.\n따라서 5000, 5002, 5004으로 들어온 요청은 각각의 서버의 Master Redis에 전달 됩니다.\n\n다음으로 5001, 5003, 5005번 Port는 각 서버의 Slave Redis를 체크합니다.\n따라서 5001, 5003, 5005으로 들어온 요청은 각각의 서버의 Slave Redis들에게 전달됩니다. (HAProxy에는 여러 서버에 대한 분배방식을 설정 할 수 있는데 고루게 요청할 수 있도록 RoundRobin 방식으로 설정하였습니다)\n\n\n\n# HAProxy 설치방법\n\n```sh\n# 관련 모듈을 yum으로 설치한다.\nyum install gcc gcc-c++ pcre-devel openssl-devel\n\n# wget명령어도 haproxy 다운로드\nwget http://www.haproxy.org/download/1.8/src/haproxy-1.8.3.tar.gz\n\n# 압축을 풀어준다.\ntar zxvf haproxy-1.8.3.tar.gz\n\n# 디렉토리 이동\ncd haproxy-1.8.3\n\n# c파일을 컴파일 해준다. https 사용이 필요한 경우 USE_OPENSSL=1 설정 추가\nmake TARGET=linux2628 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 \n\n# /usr/local/haproxy 디렉토리에 설치\nmake PREFIX=/usr/local/haproxy DESTDIR= install\n```\n\n\n\n# haproxy.cfg 파일 작성\n\nhaproxy.cfg 파일을 작성 할 때는 크게 2가지 관점으로 작성합니다.\n\n* frontend : haproxy에서 사용할 포트 설정, 포트로 신호가 왔을 시 실행할 backend 연결\n* backend : frontend로 부터 온 신호를 바탕으로 연결가능한 서버에 트래픽을 분배\n\n```bash\n\nglobal\n  log 127.0.0.1 local0\n  log 127.0.0.1 local1 notice\n \ndefaults REDIS\nmode tcp\ntimeout connect 4s\ntimeout server 15s\ntimeout client 15s\n# timeout tunnel 365d\n \nfrontend front_redis_master1\n bind *:5000 name redis                 #5000번 포트에 대한 bind 정보입니다.\n default_backend back_redis_master1     #5000번 포트로 신호가 들어오면 backend를 실행\n \nbackend back_redis_master1\n option tcp-check                       #tcp-check를 통해 접근가능한 서버 필터링\n tcp-check send AUTH\\ password1234\\r\\n  #비밀번호 password1234를 입력하고 Redis 서버에 접속합니다.\n tcp-check expect string +OK            #OK가 왔는지?\n tcp-check send PING\\r\\n                #PING을 날려 신호를 점검합니다.\n tcp-check expect string +PONG          #PONG이라는 응답이 왔는지?\n tcp-check send info\\ replication\\r\\n   #info replication 명령을 날려 Redis에 대한 정보를 받아옵니다.\n tcp-check expect string role:master    #role이 master인지 확인 합니다.\n \n #repl_backlog_active의 값이 1인지 확인합니다 \n #이 조건을 추가한 이유는 Failover간 잠시의 시간동안 Master가 2대가 되는데 그것을 방지 하기 위함입니다.\n #(진짜 Master Redis에만 1, slave는 0)\n tcp-check expect string repl_backlog_active:1 \n tcp-check send QUIT\\r\\n                #QUIT 명령을 전송\n tcp-check expect string +OK\n server redis1 192.168.137.101:6379 check inter 1s  #1초 단위로 해당 ip의 port로 체크합니다.\n server redis2 192.168.137.101:6380 check inter 1s  #1초 단위로 해당 ip의 port로 체크합니다.\n server redis3 192.168.137.101:6381 check inter 1s  #1초 단위로 해당 ip의 port로 체크합니다.\n \nfrontend front_redis_slave1\nbind *:5001 name redis                #5001번 포트에 대한 bind 정보입니다.\ndefault_backend back_redis_slave1\n \nbackend back_redis_slave1\n balance roundrobin                   #라운드 로빈 방식으로 분배\n option tcp-check\n tcp-check send AUTH\\ password1234\\r\\n        \n tcp-check expect string +OK\n tcp-check send PING\\r\\n              \n tcp-check expect string +PONG\n tcp-check send info\\ replication\\r\\n \n tcp-check expect string role:slave   #role key가 slave인지 확인 합니다.\n tcp-check send QUIT\\r\\n\n tcp-check expect string +OK\n server redis1 192.168.137.101:6379 check inter 1s  #1초 단위로 해당 ip의 port로 체크합니다.\n server redis2 192.168.137.101:6380 check inter 1s  #1초 단위로 해당 ip의 port로 체크합니다.\n server redis3 192.168.137.101:6381 check inter 1s  #1초 단위로 해당 ip의 port로 체크합니다.\n \n#Listen on all IP's on port 9000 //9000 포트로 접근 시, Web Console에 진입할 수 있습니다. \nlisten stats\n   bind 0.0.0.0:9000 \n   mode http\n   balance\n   timeout client 5000\n   timeout connect 4000\n   timeout server 30000\n \n   #This is the virtual URL to access the stats page\n   stats uri /haproxy_stats //URL주소는 ip:9000/haproxy_stats입니다.\n   #Authentication realm. This can be set to anything. Escape space characters with a backslash.\n   stats realm HAProxy\\ Statistics\n \n   #The user/pass you want to use. Change this password!\n   stats auth admin:1234 #Web Console에 접근하는 계정/암호 설정\n \n   #This allows you to take down and bring up back end servers.\n   #This will produce an error on older versions of HAProxy.\n   stats admin if TRUE\n```\n\n위의 내용에서는 일단 하나의 Master-Slave에 대한 설정값만 있습니다.\n여태까지 설치 내용에서는 Master-Slave 구성이 3세트이기 때문에 실제 haproxy.cfg를 작성 할 경우에는 \n5002~5005번 포트를 사용하는 설정에 대해서도 추가해야 합니다.\n\n\n\n# HAProxy Web Console 확인하기\n\n![haproxy1](./haproxy1.PNG)\n\n**haproxy-server-ip:9000** 으로 접속하였습니다\n현재 192.168.137.101 서버에는 6379, 6380, 6381 포트를 사용하는 Redis 노드가 3개가 동작하고 있습니다.\n현재 master 역할을 수행하는 것은 6380 포트를 사용하는 redis2 노드입니다.\n따라서 **haproxy-server-ip:5000** 으로 접속하게 되면 redis2 노드에 신호가 분배되어 Redis master서버에 대한 명령을 실행 할 수 있습니다.\n\n\n\n현재 slave 역할을 수행하는 것은 6379, 6381포트를 사용하는 redis1, redis3노드 입니다.\n따라서 **haproxy-server-ip:5001**으로 접속하게 되면 RoundRobin 방식으로 redis1, redis3 노드에 신호가 분배되어 Redis slave 서버에 대한 명령을 실행 할 수 있습니다\n\n> **HAProxy를 구성한 이유**\n>\n> Application에서 Redis를 사용하면서, Master에만 데이터를 입력하고, Slave에서만 데이터를 조회하려는 행위를 많이 하게 됩니다. 아무래도 Redis서버에 대한 부하를 줄여주고자 이러한 행위를 하게 되는데, Haproxy를 설정 해 두면, Application Server에서 failover로 인해 변하는 master/slave 포트에 대한 걱정을 할 필요가 없습니다.\n> HAProxy에서 알아서 tcp-check를 통해 master/slave를 정해주기 때문입니다.\n\n\n\n# Failover Test\n\nSentinel 테스트와 동일하게 Master를 죽여보도록 하겠습니다.\n\n```sh\ndocker stop <master-node-id>\n```\n\n![haproxy2](./haproxy2.PNG)\n\nMaster node를 죽이니, 5000번 포트에서는 더이상 master로 갈 수 있는 서버가 없다고 나옵니다.\n(**이 때 순단을 최소화 하려면 failover 시간과, HAProxy tcp-check 시간을 최소로 줄여야 합니다.**)\n\n\n\n![haproxy3](./haproxy3.PNG)\n\n잠시 시간이 지나고 Redis Failover가 진행됩니다. 진행이 완료되면, HAProxy에서도 tcp-check가 이루어집니다.\n\n\n\n![haproxy4](./haproxy4.PNG)\n\ntcp-check가 끝나고 redis1 노드가 master로 선출되어, 5000번 포트로 접근 시, redis1 노드로 분산되게 됩니다.\n\n\n\n\n\n다시, 죽었던 redis2 노드를 살려보겠습니다.\n\n```sh\ndocker start <redis2_node_id>\n```\n\n\n\n![haproxy5](./haproxy5.PNG)\n\nredis2 노드가 다시 살아나고, sentinel에서도 role-change 작업이 이루어집니다.\n곧이어, HAProxy에서도 tcp-check를 통해 redis2노드가 slave가 되었음을 확인하고 5001 포트에서 분배가능한 서버로 분류됩니다.\n\n\n\n![haproxy6](./haproxy6.PNG)\n\n\n\n이와 같이 Application Server에서는 무조건 master port는 5000번, slave port는 5001번 이라고만 알고 있으면 Redis서버에서 failover가 진행되더라도, 설정을 바꿀 필요없이 사용이 가능합니다.\n\n\n\n\n\n# 참고\n\n* http://blog.whitelife.co.kr/321","slug":"2018-12-02-docker-8","published":1,"updated":"2018-12-08T08:32:55.287Z","comments":1,"photos":[],"link":"","_id":"cjrgbv3ry003mcr1t8nn5bpw7","content":"<h1 id=\"haproxy란\">HAProxy란?</h1>\n<p>HAProxy는 기존의 하드웨어 스위치(L4/L7)을 대체하는 소프트웨어 로드밸런서입니다.\n로드 밸런싱이란 부하 분산을 위해서 가상IP를 통해 여러서버에 접속하도록 트래픽을 분배해 주는 기능을 의미합니다.</p>\n<h1 id=\"redis-cluster에-haproxy가-필요한-이유\">Redis-Cluster에 HAProxy가 필요한 이유</h1>\n<p>Redis Cluster에서는 Failover가 일어날 수 있습니다.</p>\n<p>처음에 1번이 Master였다가, 2번이 Master가 되고, 3번이 Master가 될 수 있습니다.\n하지만 Redis Cluster를 사용하는 Application에서 항상 바뀌는 Master의 포트정보를 찾는것은 매우 비용을 낭비하는 행위라 볼 수 있습니다.</p>\n<p>따라서 HAProxy에서 Health check를 하면서 실시간으로 Master를 찾아 신호를 보내줄 수 있기 때문에 HAProxy를 Redis-Cluster에 접목하였습니다.</p>\n<h1 id=\"다시-한번-보는-redis-cluster-구성도\">다시 한번 보는 Redis Cluster 구성도</h1>\n<p><img src=\"./Redis-Cluster-archi.PNG\" alt=\"Redis-Cluster-archi\"></p>\n<p>HAProxy Port를 6개를 지정합니다. (각각 1개는 Master Port, Slave Port라고 가정하고 (1(master)+1(slave)) x 3 (서버대수))</p>\n<p>5000, 5002, 5004번 Port는 각 서버의 Master Redis를 체크합니다.\n따라서 5000, 5002, 5004으로 들어온 요청은 각각의 서버의 Master Redis에 전달 됩니다.</p>\n<p>다음으로 5001, 5003, 5005번 Port는 각 서버의 Slave Redis를 체크합니다.\n따라서 5001, 5003, 5005으로 들어온 요청은 각각의 서버의 Slave Redis들에게 전달됩니다. (HAProxy에는 여러 서버에 대한 분배방식을 설정 할 수 있는데 고루게 요청할 수 있도록 RoundRobin 방식으로 설정하였습니다)</p>\n<h1 id=\"haproxy-설치방법\">HAProxy 설치방법</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 관련 모듈을 yum으로 설치한다.</span></span><br><span class=\"line\">yum install gcc gcc-c++ pcre-devel openssl-devel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># wget명령어도 haproxy 다운로드</span></span><br><span class=\"line\">wget http://www.haproxy.org/download/1.8/src/haproxy-1.8.3.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 압축을 풀어준다.</span></span><br><span class=\"line\">tar zxvf haproxy-1.8.3.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 디렉토리 이동</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> haproxy-1.8.3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># c파일을 컴파일 해준다. https 사용이 필요한 경우 USE_OPENSSL=1 설정 추가</span></span><br><span class=\"line\">make TARGET=linux2628 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># /usr/local/haproxy 디렉토리에 설치</span></span><br><span class=\"line\">make PREFIX=/usr/<span class=\"built_in\">local</span>/haproxy DESTDIR= install</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"haproxycfg-파일-작성\">haproxy.cfg 파일 작성</h1>\n<p>haproxy.cfg 파일을 작성 할 때는 크게 2가지 관점으로 작성합니다.</p>\n<ul>\n<li>frontend : haproxy에서 사용할 포트 설정, 포트로 신호가 왔을 시 실행할 backend 연결</li>\n<li>backend : frontend로 부터 온 신호를 바탕으로 연결가능한 서버에 트래픽을 분배</li>\n</ul>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">global</span><br><span class=\"line\">  <span class=\"built_in\">log</span> 127.0.0.1 local0</span><br><span class=\"line\">  <span class=\"built_in\">log</span> 127.0.0.1 local1 notice</span><br><span class=\"line\"> </span><br><span class=\"line\">defaults REDIS</span><br><span class=\"line\">mode tcp</span><br><span class=\"line\">timeout connect 4s</span><br><span class=\"line\">timeout server 15s</span><br><span class=\"line\">timeout client 15s</span><br><span class=\"line\"><span class=\"comment\"># timeout tunnel 365d</span></span><br><span class=\"line\"> </span><br><span class=\"line\">frontend front_redis_master1</span><br><span class=\"line\"> <span class=\"built_in\">bind</span> *:5000 name redis                 <span class=\"comment\">#5000번 포트에 대한 bind 정보입니다.</span></span><br><span class=\"line\"> default_backend back_redis_master1     <span class=\"comment\">#5000번 포트로 신호가 들어오면 backend를 실행</span></span><br><span class=\"line\"> </span><br><span class=\"line\">backend back_redis_master1</span><br><span class=\"line\"> option tcp-check                       <span class=\"comment\">#tcp-check를 통해 접근가능한 서버 필터링</span></span><br><span class=\"line\"> tcp-check send AUTH\\ password1234\\r\\n  <span class=\"comment\">#비밀번호 password1234를 입력하고 Redis 서버에 접속합니다.</span></span><br><span class=\"line\"> tcp-check expect string +OK            <span class=\"comment\">#OK가 왔는지?</span></span><br><span class=\"line\"> tcp-check send PING\\r\\n                <span class=\"comment\">#PING을 날려 신호를 점검합니다.</span></span><br><span class=\"line\"> tcp-check expect string +PONG          <span class=\"comment\">#PONG이라는 응답이 왔는지?</span></span><br><span class=\"line\"> tcp-check send info\\ replication\\r\\n   <span class=\"comment\">#info replication 명령을 날려 Redis에 대한 정보를 받아옵니다.</span></span><br><span class=\"line\"> tcp-check expect string role:master    <span class=\"comment\">#role이 master인지 확인 합니다.</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">#repl_backlog_active의 값이 1인지 확인합니다 </span></span><br><span class=\"line\"> <span class=\"comment\">#이 조건을 추가한 이유는 Failover간 잠시의 시간동안 Master가 2대가 되는데 그것을 방지 하기 위함입니다.</span></span><br><span class=\"line\"> <span class=\"comment\">#(진짜 Master Redis에만 1, slave는 0)</span></span><br><span class=\"line\"> tcp-check expect string repl_backlog_active:1 </span><br><span class=\"line\"> tcp-check send QUIT\\r\\n                <span class=\"comment\">#QUIT 명령을 전송</span></span><br><span class=\"line\"> tcp-check expect string +OK</span><br><span class=\"line\"> server redis1 192.168.137.101:6379 check inter 1s  <span class=\"comment\">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class=\"line\"> server redis2 192.168.137.101:6380 check inter 1s  <span class=\"comment\">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class=\"line\"> server redis3 192.168.137.101:6381 check inter 1s  <span class=\"comment\">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class=\"line\"> </span><br><span class=\"line\">frontend front_redis_slave1</span><br><span class=\"line\"><span class=\"built_in\">bind</span> *:5001 name redis                <span class=\"comment\">#5001번 포트에 대한 bind 정보입니다.</span></span><br><span class=\"line\">default_backend back_redis_slave1</span><br><span class=\"line\"> </span><br><span class=\"line\">backend back_redis_slave1</span><br><span class=\"line\"> balance roundrobin                   <span class=\"comment\">#라운드 로빈 방식으로 분배</span></span><br><span class=\"line\"> option tcp-check</span><br><span class=\"line\"> tcp-check send AUTH\\ password1234\\r\\n        </span><br><span class=\"line\"> tcp-check expect string +OK</span><br><span class=\"line\"> tcp-check send PING\\r\\n              </span><br><span class=\"line\"> tcp-check expect string +PONG</span><br><span class=\"line\"> tcp-check send info\\ replication\\r\\n </span><br><span class=\"line\"> tcp-check expect string role:slave   <span class=\"comment\">#role key가 slave인지 확인 합니다.</span></span><br><span class=\"line\"> tcp-check send QUIT\\r\\n</span><br><span class=\"line\"> tcp-check expect string +OK</span><br><span class=\"line\"> server redis1 192.168.137.101:6379 check inter 1s  <span class=\"comment\">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class=\"line\"> server redis2 192.168.137.101:6380 check inter 1s  <span class=\"comment\">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class=\"line\"> server redis3 192.168.137.101:6381 check inter 1s  <span class=\"comment\">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#Listen on all IP's on port 9000 //9000 포트로 접근 시, Web Console에 진입할 수 있습니다. </span></span><br><span class=\"line\">listen stats</span><br><span class=\"line\">   <span class=\"built_in\">bind</span> 0.0.0.0:9000 </span><br><span class=\"line\">   mode http</span><br><span class=\"line\">   balance</span><br><span class=\"line\">   timeout client 5000</span><br><span class=\"line\">   timeout connect 4000</span><br><span class=\"line\">   timeout server 30000</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">#This is the virtual URL to access the stats page</span></span><br><span class=\"line\">   stats uri /haproxy_stats //URL주소는 ip:9000/haproxy_stats입니다.</span><br><span class=\"line\">   <span class=\"comment\">#Authentication realm. This can be set to anything. Escape space characters with a backslash.</span></span><br><span class=\"line\">   stats realm HAProxy\\ Statistics</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">#The user/pass you want to use. Change this password!</span></span><br><span class=\"line\">   stats auth admin:1234 <span class=\"comment\">#Web Console에 접근하는 계정/암호 설정</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">#This allows you to take down and bring up back end servers.</span></span><br><span class=\"line\">   <span class=\"comment\">#This will produce an error on older versions of HAProxy.</span></span><br><span class=\"line\">   stats admin <span class=\"keyword\">if</span> TRUE</span><br></pre></td></tr></table></figure></p>\n<p>위의 내용에서는 일단 하나의 Master-Slave에 대한 설정값만 있습니다.\n여태까지 설치 내용에서는 Master-Slave 구성이 3세트이기 때문에 실제 haproxy.cfg를 작성 할 경우에는\n5002~5005번 포트를 사용하는 설정에 대해서도 추가해야 합니다.</p>\n<h1 id=\"haproxy-web-console-확인하기\">HAProxy Web Console 확인하기</h1>\n<p><img src=\"./haproxy1.PNG\" alt=\"haproxy1\"></p>\n<p><strong>haproxy-server-ip:9000</strong> 으로 접속하였습니다\n현재 192.168.137.101 서버에는 6379, 6380, 6381 포트를 사용하는 Redis 노드가 3개가 동작하고 있습니다.\n현재 master 역할을 수행하는 것은 6380 포트를 사용하는 redis2 노드입니다.\n따라서 <strong>haproxy-server-ip:5000</strong> 으로 접속하게 되면 redis2 노드에 신호가 분배되어 Redis master서버에 대한 명령을 실행 할 수 있습니다.</p>\n<p>현재 slave 역할을 수행하는 것은 6379, 6381포트를 사용하는 redis1, redis3노드 입니다.\n따라서 <strong>haproxy-server-ip:5001</strong>으로 접속하게 되면 RoundRobin 방식으로 redis1, redis3 노드에 신호가 분배되어 Redis slave 서버에 대한 명령을 실행 할 수 있습니다</p>\n<blockquote>\n<p><strong>HAProxy를 구성한 이유</strong></p>\n<p>Application에서 Redis를 사용하면서, Master에만 데이터를 입력하고, Slave에서만 데이터를 조회하려는 행위를 많이 하게 됩니다. 아무래도 Redis서버에 대한 부하를 줄여주고자 이러한 행위를 하게 되는데, Haproxy를 설정 해 두면, Application Server에서 failover로 인해 변하는 master/slave 포트에 대한 걱정을 할 필요가 없습니다.\nHAProxy에서 알아서 tcp-check를 통해 master/slave를 정해주기 때문입니다.</p>\n</blockquote>\n<h1 id=\"failover-test\">Failover Test</h1>\n<p>Sentinel 테스트와 동일하게 Master를 죽여보도록 하겠습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop &lt;master-node-id&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./haproxy2.PNG\" alt=\"haproxy2\"></p>\n<p>Master node를 죽이니, 5000번 포트에서는 더이상 master로 갈 수 있는 서버가 없다고 나옵니다.\n(<strong>이 때 순단을 최소화 하려면 failover 시간과, HAProxy tcp-check 시간을 최소로 줄여야 합니다.</strong>)</p>\n<p><img src=\"./haproxy3.PNG\" alt=\"haproxy3\"></p>\n<p>잠시 시간이 지나고 Redis Failover가 진행됩니다. 진행이 완료되면, HAProxy에서도 tcp-check가 이루어집니다.</p>\n<p><img src=\"./haproxy4.PNG\" alt=\"haproxy4\"></p>\n<p>tcp-check가 끝나고 redis1 노드가 master로 선출되어, 5000번 포트로 접근 시, redis1 노드로 분산되게 됩니다.</p>\n<p>다시, 죽었던 redis2 노드를 살려보겠습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start &lt;redis2_node_id&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./haproxy5.PNG\" alt=\"haproxy5\"></p>\n<p>redis2 노드가 다시 살아나고, sentinel에서도 role-change 작업이 이루어집니다.\n곧이어, HAProxy에서도 tcp-check를 통해 redis2노드가 slave가 되었음을 확인하고 5001 포트에서 분배가능한 서버로 분류됩니다.</p>\n<p><img src=\"./haproxy6.PNG\" alt=\"haproxy6\"></p>\n<p>이와 같이 Application Server에서는 무조건 master port는 5000번, slave port는 5001번 이라고만 알고 있으면 Redis서버에서 failover가 진행되더라도, 설정을 바꿀 필요없이 사용이 가능합니다.</p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>http://blog.whitelife.co.kr/321</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>HAProxy란?</h1>\n<p>HAProxy는 기존의 하드웨어 스위치(L4/L7)을 대체하는 소프트웨어 로드밸런서입니다.\n로드 밸런싱이란 부하 분산을 위해서 가상IP를 통해 여러서버에 접속하도록 트래픽을 분배해 주는 기능을 의미합니다.</p>\n<h1>Redis-Cluster에 HAProxy가 필요한 이유</h1>\n<p>Redis Cluster에서는 Failover가 일어날 수 있습니다.</p>\n<p>처음에 1번이 Master였다가, 2번이 Master가 되고, 3번이 Master가 될 수 있습니다.\n하지만 Redis Cluster를 사용하는 Application에서 항상 바뀌는 Master의 포트정보를 찾는것은 매우 비용을 낭비하는 행위라 볼 수 있습니다.</p>\n<p>따라서 HAProxy에서 Health check를 하면서 실시간으로 Master를 찾아 신호를 보내줄 수 있기 때문에 HAProxy를 Redis-Cluster에 접목하였습니다.</p>\n<h1>다시 한번 보는 Redis Cluster 구성도</h1>\n<p><img src=\"./Redis-Cluster-archi.PNG\" alt=\"Redis-Cluster-archi\"></p>\n<p>HAProxy Port를 6개를 지정합니다. (각각 1개는 Master Port, Slave Port라고 가정하고 (1(master)+1(slave)) x 3 (서버대수))</p>\n<p>5000, 5002, 5004번 Port는 각 서버의 Master Redis를 체크합니다.\n따라서 5000, 5002, 5004으로 들어온 요청은 각각의 서버의 Master Redis에 전달 됩니다.</p>\n<p>다음으로 5001, 5003, 5005번 Port는 각 서버의 Slave Redis를 체크합니다.\n따라서 5001, 5003, 5005으로 들어온 요청은 각각의 서버의 Slave Redis들에게 전달됩니다. (HAProxy에는 여러 서버에 대한 분배방식을 설정 할 수 있는데 고루게 요청할 수 있도록 RoundRobin 방식으로 설정하였습니다)</p>\n<h1>HAProxy 설치방법</h1>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 관련 모듈을 yum으로 설치한다.</span></span><br><span class=\"line\">yum install gcc gcc-c++ pcre-devel openssl-devel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># wget명령어도 haproxy 다운로드</span></span><br><span class=\"line\">wget http://www.haproxy.org/download/1.8/src/haproxy-1.8.3.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 압축을 풀어준다.</span></span><br><span class=\"line\">tar zxvf haproxy-1.8.3.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 디렉토리 이동</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> haproxy-1.8.3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># c파일을 컴파일 해준다. https 사용이 필요한 경우 USE_OPENSSL=1 설정 추가</span></span><br><span class=\"line\">make TARGET=linux2628 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># /usr/local/haproxy 디렉토리에 설치</span></span><br><span class=\"line\">make PREFIX=/usr/<span class=\"built_in\">local</span>/haproxy DESTDIR= install</span><br></pre></td></tr></table></figure></p>\n<h1>haproxy.cfg 파일 작성</h1>\n<p>haproxy.cfg 파일을 작성 할 때는 크게 2가지 관점으로 작성합니다.</p>\n<ul>\n<li>frontend : haproxy에서 사용할 포트 설정, 포트로 신호가 왔을 시 실행할 backend 연결</li>\n<li>backend : frontend로 부터 온 신호를 바탕으로 연결가능한 서버에 트래픽을 분배</li>\n</ul>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">global</span><br><span class=\"line\">  <span class=\"built_in\">log</span> 127.0.0.1 local0</span><br><span class=\"line\">  <span class=\"built_in\">log</span> 127.0.0.1 local1 notice</span><br><span class=\"line\"> </span><br><span class=\"line\">defaults REDIS</span><br><span class=\"line\">mode tcp</span><br><span class=\"line\">timeout connect 4s</span><br><span class=\"line\">timeout server 15s</span><br><span class=\"line\">timeout client 15s</span><br><span class=\"line\"><span class=\"comment\"># timeout tunnel 365d</span></span><br><span class=\"line\"> </span><br><span class=\"line\">frontend front_redis_master1</span><br><span class=\"line\"> <span class=\"built_in\">bind</span> *:5000 name redis                 <span class=\"comment\">#5000번 포트에 대한 bind 정보입니다.</span></span><br><span class=\"line\"> default_backend back_redis_master1     <span class=\"comment\">#5000번 포트로 신호가 들어오면 backend를 실행</span></span><br><span class=\"line\"> </span><br><span class=\"line\">backend back_redis_master1</span><br><span class=\"line\"> option tcp-check                       <span class=\"comment\">#tcp-check를 통해 접근가능한 서버 필터링</span></span><br><span class=\"line\"> tcp-check send AUTH\\ password1234\\r\\n  <span class=\"comment\">#비밀번호 password1234를 입력하고 Redis 서버에 접속합니다.</span></span><br><span class=\"line\"> tcp-check expect string +OK            <span class=\"comment\">#OK가 왔는지?</span></span><br><span class=\"line\"> tcp-check send PING\\r\\n                <span class=\"comment\">#PING을 날려 신호를 점검합니다.</span></span><br><span class=\"line\"> tcp-check expect string +PONG          <span class=\"comment\">#PONG이라는 응답이 왔는지?</span></span><br><span class=\"line\"> tcp-check send info\\ replication\\r\\n   <span class=\"comment\">#info replication 명령을 날려 Redis에 대한 정보를 받아옵니다.</span></span><br><span class=\"line\"> tcp-check expect string role:master    <span class=\"comment\">#role이 master인지 확인 합니다.</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">#repl_backlog_active의 값이 1인지 확인합니다 </span></span><br><span class=\"line\"> <span class=\"comment\">#이 조건을 추가한 이유는 Failover간 잠시의 시간동안 Master가 2대가 되는데 그것을 방지 하기 위함입니다.</span></span><br><span class=\"line\"> <span class=\"comment\">#(진짜 Master Redis에만 1, slave는 0)</span></span><br><span class=\"line\"> tcp-check expect string repl_backlog_active:1 </span><br><span class=\"line\"> tcp-check send QUIT\\r\\n                <span class=\"comment\">#QUIT 명령을 전송</span></span><br><span class=\"line\"> tcp-check expect string +OK</span><br><span class=\"line\"> server redis1 192.168.137.101:6379 check inter 1s  <span class=\"comment\">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class=\"line\"> server redis2 192.168.137.101:6380 check inter 1s  <span class=\"comment\">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class=\"line\"> server redis3 192.168.137.101:6381 check inter 1s  <span class=\"comment\">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class=\"line\"> </span><br><span class=\"line\">frontend front_redis_slave1</span><br><span class=\"line\"><span class=\"built_in\">bind</span> *:5001 name redis                <span class=\"comment\">#5001번 포트에 대한 bind 정보입니다.</span></span><br><span class=\"line\">default_backend back_redis_slave1</span><br><span class=\"line\"> </span><br><span class=\"line\">backend back_redis_slave1</span><br><span class=\"line\"> balance roundrobin                   <span class=\"comment\">#라운드 로빈 방식으로 분배</span></span><br><span class=\"line\"> option tcp-check</span><br><span class=\"line\"> tcp-check send AUTH\\ password1234\\r\\n        </span><br><span class=\"line\"> tcp-check expect string +OK</span><br><span class=\"line\"> tcp-check send PING\\r\\n              </span><br><span class=\"line\"> tcp-check expect string +PONG</span><br><span class=\"line\"> tcp-check send info\\ replication\\r\\n </span><br><span class=\"line\"> tcp-check expect string role:slave   <span class=\"comment\">#role key가 slave인지 확인 합니다.</span></span><br><span class=\"line\"> tcp-check send QUIT\\r\\n</span><br><span class=\"line\"> tcp-check expect string +OK</span><br><span class=\"line\"> server redis1 192.168.137.101:6379 check inter 1s  <span class=\"comment\">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class=\"line\"> server redis2 192.168.137.101:6380 check inter 1s  <span class=\"comment\">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class=\"line\"> server redis3 192.168.137.101:6381 check inter 1s  <span class=\"comment\">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#Listen on all IP's on port 9000 //9000 포트로 접근 시, Web Console에 진입할 수 있습니다. </span></span><br><span class=\"line\">listen stats</span><br><span class=\"line\">   <span class=\"built_in\">bind</span> 0.0.0.0:9000 </span><br><span class=\"line\">   mode http</span><br><span class=\"line\">   balance</span><br><span class=\"line\">   timeout client 5000</span><br><span class=\"line\">   timeout connect 4000</span><br><span class=\"line\">   timeout server 30000</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">#This is the virtual URL to access the stats page</span></span><br><span class=\"line\">   stats uri /haproxy_stats //URL주소는 ip:9000/haproxy_stats입니다.</span><br><span class=\"line\">   <span class=\"comment\">#Authentication realm. This can be set to anything. Escape space characters with a backslash.</span></span><br><span class=\"line\">   stats realm HAProxy\\ Statistics</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">#The user/pass you want to use. Change this password!</span></span><br><span class=\"line\">   stats auth admin:1234 <span class=\"comment\">#Web Console에 접근하는 계정/암호 설정</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">#This allows you to take down and bring up back end servers.</span></span><br><span class=\"line\">   <span class=\"comment\">#This will produce an error on older versions of HAProxy.</span></span><br><span class=\"line\">   stats admin <span class=\"keyword\">if</span> TRUE</span><br></pre></td></tr></table></figure></p>\n<p>위의 내용에서는 일단 하나의 Master-Slave에 대한 설정값만 있습니다.\n여태까지 설치 내용에서는 Master-Slave 구성이 3세트이기 때문에 실제 haproxy.cfg를 작성 할 경우에는\n5002~5005번 포트를 사용하는 설정에 대해서도 추가해야 합니다.</p>\n<h1>HAProxy Web Console 확인하기</h1>\n<p><img src=\"./haproxy1.PNG\" alt=\"haproxy1\"></p>\n<p><strong>haproxy-server-ip:9000</strong> 으로 접속하였습니다\n현재 192.168.137.101 서버에는 6379, 6380, 6381 포트를 사용하는 Redis 노드가 3개가 동작하고 있습니다.\n현재 master 역할을 수행하는 것은 6380 포트를 사용하는 redis2 노드입니다.\n따라서 <strong>haproxy-server-ip:5000</strong> 으로 접속하게 되면 redis2 노드에 신호가 분배되어 Redis master서버에 대한 명령을 실행 할 수 있습니다.</p>\n<p>현재 slave 역할을 수행하는 것은 6379, 6381포트를 사용하는 redis1, redis3노드 입니다.\n따라서 <strong>haproxy-server-ip:5001</strong>으로 접속하게 되면 RoundRobin 방식으로 redis1, redis3 노드에 신호가 분배되어 Redis slave 서버에 대한 명령을 실행 할 수 있습니다</p>\n<blockquote>\n<p><strong>HAProxy를 구성한 이유</strong></p>\n<p>Application에서 Redis를 사용하면서, Master에만 데이터를 입력하고, Slave에서만 데이터를 조회하려는 행위를 많이 하게 됩니다. 아무래도 Redis서버에 대한 부하를 줄여주고자 이러한 행위를 하게 되는데, Haproxy를 설정 해 두면, Application Server에서 failover로 인해 변하는 master/slave 포트에 대한 걱정을 할 필요가 없습니다.\nHAProxy에서 알아서 tcp-check를 통해 master/slave를 정해주기 때문입니다.</p>\n</blockquote>\n<h1>Failover Test</h1>\n<p>Sentinel 테스트와 동일하게 Master를 죽여보도록 하겠습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop &lt;master-node-id&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./haproxy2.PNG\" alt=\"haproxy2\"></p>\n<p>Master node를 죽이니, 5000번 포트에서는 더이상 master로 갈 수 있는 서버가 없다고 나옵니다.\n(<strong>이 때 순단을 최소화 하려면 failover 시간과, HAProxy tcp-check 시간을 최소로 줄여야 합니다.</strong>)</p>\n<p><img src=\"./haproxy3.PNG\" alt=\"haproxy3\"></p>\n<p>잠시 시간이 지나고 Redis Failover가 진행됩니다. 진행이 완료되면, HAProxy에서도 tcp-check가 이루어집니다.</p>\n<p><img src=\"./haproxy4.PNG\" alt=\"haproxy4\"></p>\n<p>tcp-check가 끝나고 redis1 노드가 master로 선출되어, 5000번 포트로 접근 시, redis1 노드로 분산되게 됩니다.</p>\n<p>다시, 죽었던 redis2 노드를 살려보겠습니다.</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start &lt;redis2_node_id&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./haproxy5.PNG\" alt=\"haproxy5\"></p>\n<p>redis2 노드가 다시 살아나고, sentinel에서도 role-change 작업이 이루어집니다.\n곧이어, HAProxy에서도 tcp-check를 통해 redis2노드가 slave가 되었음을 확인하고 5001 포트에서 분배가능한 서버로 분류됩니다.</p>\n<p><img src=\"./haproxy6.PNG\" alt=\"haproxy6\"></p>\n<p>이와 같이 Application Server에서는 무조건 master port는 5000번, slave port는 5001번 이라고만 알고 있으면 Redis서버에서 failover가 진행되더라도, 설정을 바꿀 필요없이 사용이 가능합니다.</p>\n<h1>참고</h1>\n<ul>\n<li>http://blog.whitelife.co.kr/321</li>\n</ul>\n"},{"layout":"posts","title":"2018년 회고","date":"2018-12-16T06:59:38.000Z","_content":"\n# 새 직장으로 이직\n2017년 8월 중순 중소 SI업체를 용기있게(?) 뛰쳐나왔다.\n그 곳에서는 오직 나 한명으로 여러 프로젝트를 돌리고 있었고, 같이 일할 선임개발자도 없었기 때문에\n굉장히 나름대로 스트레스를 받고 있었다.\n그리고 모든 프로젝트가 나에게 의존적이었기 때문에 관리해야 할 사이트도 많았고..\n매일매일 프로젝트 했던 사이트들에 대한 유지보수 전화를 받아가며, 신규 프로젝트를 진행하고 있었다.\n이렇게 개발자로서 소모되어 가고 있다는 생각이 들어 과감하게 퇴사를 하게되었다. 다음에는 어느정도 조직이 구성되어있고 내가 조직원으로서 일할 수 있는 직장을 찾아야겠다! 라는 생각을 하게되었다.\n이직하고자 하는 회사의 조건은 이렇다.\n1. 개발자 한명이 기획, 개발, 유지보수, 영업을 담당하는 작은회사는 가지 않겠다.\n2. 더 이상 SI는 하지 않겠다. (지방 출장이 잦고, 프로젝트 단위로 사업이 돌아가는 곳은 가지 않겠다.)\n3. 근무지 한 곳에서만 근무 할 수 있는 환경 (예전에는 지방을 여기저기 많이 다녔다.)\n4. 시니어 개발자와 주니어 개발자 층이 어느정도 있고, 같이 의논하며 개발할 수 있는 환경\n5. Spring 4 / Java 1.8 이상을 사용하여 개발하는 조직\n6. 내가 더 발전할 수 있는 조직\n7. 연봉도 많이 올려주면 좋고~! ^^\n\n하지만 생각보다 이직은 쉽지 않았다. (특히나 선퇴사 후이직 이어서.. 11월쯤에는 굉장히 쫄렸다.)\n일단 서비스 회사로 이직을 목표로 잡았지만, 기존의 했던 업무가 제조업이나 MES관련 개발을 주로 했었기 때문에 서비스 회사에서는 대부분의 서류 낙방을 경험했다. (이력서를 처음 써봐서 정말 못써서 그럴 수도 있겠지만.)\n서류 한 군데만 붙어라... 면접은 완전 잘 볼 자신있다!라는 생각으로 서류만 2개월 이상 쓰다보니 10월쯤에는 서류 합격하는 회사가 몇 군데 있었다. 서류합격 메일을 받았을 때 기분이란....크 면접일자가 정해지고, 인터넷에 돌아다니는 예상 면접질문을 바탕으로 하나하나 정리를 하였다. 대게 기술질문은 그 테두리 안에서 나온다는 것이 여러사람들의 의견이었다.\n그리고 9월쯤엔 대기업 신입공채를 준비했어서, 오랜만에 컴퓨터 이론을 한번 정리 했었는데 이 부분이 정말 도움이 많이 되었다. 자주 안보는 만큼 지금도 기억에서 많이 사라졌는데, 가끔씩 리마인드를 해주는 것이 좋겠다.\n\n면접은 두 군데정도 봤는데 둘 다 자신감있게 봤었다.\n아무래도 SI하면서 고객사 상대로 발표도 하고 회의도 자주 하다보니, 남들이랑 대화하고 그런거는 긴장되지 않았다.\n그렇기 때문에 면접을 보면서 긴장을 덜하고 면접장에서 어필할 수 있었던 것 같다.\n결국 최종적으로 한 곳의 회사만 합격을 하였는데, 그 곳이 NHN티켓링크이다.\n최종합격 후 천만다행이라는 생각이 들었고, 2018년 1월 초에 입사를 하게 되었다.\n\n# 우리 팀의 개발문화\n예전 SI할 때는 혼자서 사이트를 다 만들어야 했기 때문에, 프론트엔드도 하고 백엔드도하고, 서버설치 등을 혼자 다했다. 하지만 여기와서는 인프라 관련해서는 시스템팀이 별도로 있었고, DBA팀도 별도로 있었다. 내가 할 업무는 티켓링크 백엔드 개발과 약간의 간단한 프론트엔드 작업만 하면되었다.\n기획팀도 별도로 나뉘어져 있다보니, 내가 직접 기획서를 쓰지 않아도 되고 개발에만 집중 할 수 있다는 환경이 참 좋았다.\n\n## git flow를 사용한 브랜치 전략\nSI할때는 SVN만 사용해봤는데 그냥 master에 커밋치던 나에게는 신세계였다. 뭔가 구글링하면서 지나쳤던 얘기들을 실천하고 있는 조직이라는 생각이 들었다.\ngit도 처음 사용해 봤는데, SVN보다 더 유연하고 좋다는 생각이 들었다. (특히 브랜치를 왔다갔다 하면서 작업할 수 있는 점이 좋았던 것 같다.)\n\n## Pull Request + 코드리뷰\n두 번째로는 Pull Request를 올려서 코드리뷰를 강제화 하도록 하는 문화이다.\n첫 업무를 받아서 PR을 올렸을 때는 Conversation이 50개 이상이 달려서 코드리뷰를 엄청나게 받았다.\n뭔가 탈탈 털렸다라는 느낌도 받았고, 앞으로 공부해야 할 게 많구나라는 생각이 들었다.\n한 가지 아쉬운점은... `코드리뷰를 하는 사람만 한다.` 다른사람들도 적극적으로 해주면 좋을텐데..라는 생각이 들었다.\n처음에는 나도 다른사람의 코드를 리뷰해줘야지! 라는 생각으로 코드리뷰에 참여하려고 했지만.. 한마디도 달 수 없었다. 그때 딱 드는 생각이, **\"내가 아는게 없어서 코드리뷰를 해줄 수가 없구나.. 코드리뷰에 한마디라도 할 수 있도록 공부하자\"** 라는 생각을 하게 되었다.\n돌이켜보면 나는 여태까지 `\"공부하지 않는 개발자\"`였다.\n팀원들을 보면 아침에 일찍와서 책을보는 분도 계셨고, 따로 스터디모임을 하시는 분도 계셨다.\n입사초기에 나는 살 좀 빼야지.. 라는 생각으로 아침운동을 다녀서 아침에 일찍 공부하기는 힘들었다. 그래서 주로 퇴근 후나 주말에 내가 하고자 하는 공부를 하였다. 그리고 꼭 공부한 내용은 블로그를 작성해서 남겨야겠다고 생각했다.\n공부는 조금조금씩 계속 했지만, 본격적으로 블로그를 설치하고 시작한 것은 7월 정도인 것 같다.\n현재 4년차에 Spring기반으로 개발을 계속 해왔다고는 하지만 Spring의 기본을 공부해본적이 없었다.\n여태까지는 그냥 `이렇게 하면 이렇게 되네~` 방식의 개발을 해와서, 뭐가 안되면 원인 파악하기가 무척이나 어려웠다.\n그래서 처음에는 **Spring core**에 대한 공부를 시작했다. 토비의 Spring 책도 사고, 회사 소스에 적용된 기술들을 하나하나 파보기 시작했다. 하나하나 익히고 나니 너무 유용한 기술들이 많이 있었고, 개발할 때 직접 써먹으면서 실전 응용력을 키울 수 있었던 것 같다.\n\n## 주간 기술공유\n세 번째는 매주 목요일 기술공유 시간을 짧게 갖는다.\n팀원 한 명씩 돌아가면서 신기술에 대한 공유나 코드리뷰등을 하는 시간이다. 이런 걸 해보지 않아서 처음에는 무슨 내용을 공유하지?라는 걱정이 앞섰는데, 다행히도 공유 순서가 가까워지면 항상 공유 할 내용이 있었다. 그리고 내 순서가 아니어도 최대한 공유를 하려고 노력했다. (순서가 아니어도 또 해도 된다. 하지만 내 순번에는 또 공유를 해야한다. ㅎㅎ) 최대한 공유를 많이 하려고 노력했고, 기술공유 준비를 하면서 내가 했던 일들이나 기술에 대해 다시 한번 정리하는 시간이 되어 개인적으로 기술에 대한 기억을 오랫동안 보존할 수 있는 방법이었다.\n또 다른사람의 기술공유를 들었다가 내가 필요할 때 써먹거나, 미처 몰랐던 내용들도 있어서 개발팀 문화 중에 나름 유의미한 시간이라고 생각하고 있다.\n\n# 블로그 시작\n\n올해 목표 중 하나가 블로그에 공부한 내용에 대한 글을 꾸준히 작성하는 것이었다.\n블로그는 7월쯤에 만들어서 꾸준히 작성하려고 노력하고 있다.\n\n현재까지 수를 보니..\n* 7월 - 5개\n* 8월 - 6개\n* 9월 - 3개\n* 10월 - 2개\n* 11월 - 7개\n* 12월 - 8개\n\n정도 해서 총 31개의 포스팅을 작성했다. 시리즈 물로 된 글도 많았고, 회사에서 사용한 기술들을 다시 좀 다듬어서 기록으로 남긴 것들도 있다. (회사 업무내용을 최대한 제외하려 한게 참 힘들었다ㅜㅜ)\n처음에는 블로그도 안써봐서 글 쓰는데 시간도 오래걸리고 뭐 어떻게 써야하나...라는 생각으로 다른 블로그들을 참고하며 많이 썼던것 같다. 그리고 하나 쓰는데 시간도 꽤 오래 걸린것 같다.\n한 30개의 글을 써보니 대충 블로그 쓰는 법도 감이 왔다.\n* 일단 내가 100% 이해하지 못한 상황에서 글을 쓸 수 없다.\n* 처음에는 블로그 포스팅 수를 늘리고 싶어서 무조건 post부터 생성하고 봤는데, 글의 진도가 나가지 않았다.\n* 블로그를 빠르고 쉽게 작성하기 위해서는 목차를 먼저 잡고 그에 대한 지식을 채운 다음에 각 섹션별로 담아내고자 하는 내용을 짧게 정리했다.\n* 예제가 필요한 경우 미리 예제에 대한 실습을 마쳐 놓아야 한다.\n  * 그때그때 예제코드 작성하면 시간이 오래걸리고, 내가 무슨 글을 쓰던 중이었는지 까먹게 된다.\n\n블로그를 쓰다보니 지식에 대한 인덱스도 나름 생기고, 나중에 기억 안나도 예제코드를 찾아볼 수 있어서 좋았다.\n앞으로도 계속 블로그를 작성할 예정인데, 제발 귀찮아지지만 않았으면 좋겠다..!\n\n# 회사 업무\n## 1~2월에는 회사 적응도 하고, 바로 또 업무를 할당 받았다.\n나의 첫 업무는 티켓링크 카카오톡 알림톡 연동이었다. 기존에는 SMS/MMS만 사용했는데, 카카오톡 알림톡을 지원하도록 하는 업무였다. 지금 생각해보면 업무는 단순했다. 카카오톡 API를 연동 인터페이스만 구현해주면 되는 것이었는데, 외부 API 연동을 처음 해보는터라 시간도 오래걸리고, 회사 소스를 파악하면서 해야해서 1달이상의 시간이 걸렸던 것 같다.\n기존 코드의 리팩토링도 해가면서 해서, 나름 재미있게 개발을 했던 첫 업무였다.\n\n## 3~4월에는 캡차 시스템 개발을 진행했다.\n티켓시스템에는 사람들이 좌석을 빨리 차지하기 위해 매크로를 많이 쓴다.\n최근에는 뉴스기사에도 아이돌 콘서트니, 인기 공연에 대해 매크로를 돌려서 빠르게 예매한 다음에 몇배의 가격으로 불려서 암표를 파는 사람이 많다는 기사가 나왔다. 최소한이라도 예방하기 위해 티켓링크에서는 캡차 도입을 고민하고 있었다. 구글의 리캡차나 국내의 캡차 솔루션을 도입하자라는 의견도 나왔고, 직접 구축하는 것이 좋다!라는 의견이 나오고 있을때쯤 집에서 한번 오픈소스를 이용해서 간단하게 캡차를 만들어보았다. 어렵지 않게 예시를 만들수 있었고, 다음날 바로 팀장님께 보여드렸다. 그렇게 캡차 개발은 내 업무가 되었다^^\n나름 보안과 성능을 생각하며, 이미지 캐싱등의 작업을 하였다. 그리고 캡차를 사용하기 위해서는 Global캐시 Store가 하나는 필요했다. 이로인해 팀에서 NoSQL 도입을 생각하게 되었다.\n캡차 개발 완료 후 nGrinder를 통해 성능테스트로 진행하였는데 15,000 TPS정도의 높은 성능이 나와서 나름 만족하고 있었다.(하지만 아직 회사에서 인기 공연이나 예매에 사용을 안해서.. 아쉬웠다.)\n\n## Redis 도입\n캡차 사용을 위해 Redis를 도입하게 되었다. 원래 사용하는 NoSQL이 있지만, 추가적으로 NoSQL서버를 자체 구축할 예정이었다. (이유는 따로 적지 않겠다.) 여러가지 NoSQL이 물망에 올랐다. Redis, Arcus등 여러가지 Key-value store가 거론되었지만, 내 욕심 상 Redis를 해보고 싶었다. (아무래도 Key-value store 1순위인 Redis를 써보고 싶었다.)\nRedis를 도입하면서 단순하게 서버에 Redis만 설치해서 쓰고 싶지는 않았다. 인프라 시스템은 항상 scale out을 고려해야 했기 때문에, 주변에서 Docker를 이용해서 설치 해보라는 얘기가 나왔다.\nDocker는 난생 처음 들어보는 거였는데.. Docker에 대한 삽질을 어마무시하게 하면서 거의 3주만에 Redis 설치와 Cluster 설치까지 완료했다. 이 기회를 가지면서 Redis에 대한 전반적인 이해가 생기게 되었고, 나름 삽질을 거치면서 Docker라는 시스템도 어느정도 이해하게 되었다. (다시는 까먹지 않게 팀내에서도 3일에 걸쳐 공유를 하고 11부작 정도로 블로그도 작성해 두었다^^)\n\n## 결제시스템 개편\n어쩌다보니 내가 티켓링크 결제 시스템 '부'가 되어서 티켓링크 결제시스템 개편 업무를 많이 했다.\nPayco결제, IC카드결제, 네이버페이 연동등을 경험하며, 외부 빌링업체의 결제 프로세스를 경험 할 수 있던 기회였다.\n네이버페이는 거의 처음부터 만들게 되었는데, Web에서의 결제, App에서의 결제를 모두 봐야 해서 꽤 고생했던 기억이 있다. 하지만 결제관련 Flow는 어느정도 알게 되었던 업무였다.\n\n## MSA시도 해보기\n티켓링크 시스템은 Monolothic 시스템 구조를 가지고 있다. 그렇기 때문에 빌드시간도 만만치않게 걸리고 배포하려고 해도 사이드 이펙트가 발생할 확률이 높다. 그렇기 때문에 올해 말부터 하나씩 하나씩 쪼개는 작업을 진행하고 있다. MSA까지는 아니어도 점진적으로 모듈을 분리하여, 빌드 시간을 단축 시키고, 시스템 안정성을 높이기 위함에 있다.\n이 부분에 대해서는 나도 의견을 많이 내고 시니어 개발자분들도 관심있게 보는 부분이어서, 내년에 더 활발하게 작업이 진행 될 것 같다.\n\n# 내년에는..\n내년 공부의 시작은 개발 필독 서적을 몇가지 읽어보려고 한다.\n* clean code\n* TDD 개발 방법론\n* Effective Java 3rd Edition\n(2rd Edition은 한번봤는데, Java8에 대한 내용이 추가되었다고 하니 한번더 봐야겠다.)\n* Java ORM 표준 JPA프로그래밍\n * 현재 MyBatis기반으로 시스템이 구성되어있는데, 새로 만드는 시스템은 무조건 JPA를 도입하자고 얘기가 나오고 있다. 이전 회사에서 JPA사용경험이 있어서 나도 JPA도입을 대찬성하고 있는데, 더 지식을 쌓고 개발할 필요성을 느끼고 있다. 그래서 이 책을 아마 1순위로 공부하지 않을까.. 싶다.\n\n회사 업무에서는 주니어 개발자이지만, 목소리를 내보려 노력하고 있다.\n팀에서도 그런 분위기를 조성하려하고 있는 것 같고, 내 의견이 묵살되더라도 생각이라도 해보고, 다른사람의 의견과 비교할 수 있기 때문에 적극적으로 목소리를 내보고자 한다.\n\n# 마무리..\n올해 회고를 쭉 작성해보니 생각보다 많은 일을 했다는 생각이 든다. 그리고 그 과정 속에서 한단계 더 성장한 개발자가 되었다고 나름 생각하고 만족하고 있다. 회고를 쓰면서 회사 얘기가 조금 나와서.. 글을 좀 수정해야 할 경우가 생길 수도 있지만.. 딱히 그럴만한 내용은 없다고 생각이 든다.\n앞으로는 1년 단위로 회고를 작성하여 한번씩 되돌아보고 추억할 수 있는 시간이 되면 좋겠다.","source":"_posts/2018-12-16-remind.md","raw":"---\nlayout: posts\ntitle: 2018년 회고\ndate: 2018-12-16 15:59:38\ntags:\n   2018-remind\n---\n\n# 새 직장으로 이직\n2017년 8월 중순 중소 SI업체를 용기있게(?) 뛰쳐나왔다.\n그 곳에서는 오직 나 한명으로 여러 프로젝트를 돌리고 있었고, 같이 일할 선임개발자도 없었기 때문에\n굉장히 나름대로 스트레스를 받고 있었다.\n그리고 모든 프로젝트가 나에게 의존적이었기 때문에 관리해야 할 사이트도 많았고..\n매일매일 프로젝트 했던 사이트들에 대한 유지보수 전화를 받아가며, 신규 프로젝트를 진행하고 있었다.\n이렇게 개발자로서 소모되어 가고 있다는 생각이 들어 과감하게 퇴사를 하게되었다. 다음에는 어느정도 조직이 구성되어있고 내가 조직원으로서 일할 수 있는 직장을 찾아야겠다! 라는 생각을 하게되었다.\n이직하고자 하는 회사의 조건은 이렇다.\n1. 개발자 한명이 기획, 개발, 유지보수, 영업을 담당하는 작은회사는 가지 않겠다.\n2. 더 이상 SI는 하지 않겠다. (지방 출장이 잦고, 프로젝트 단위로 사업이 돌아가는 곳은 가지 않겠다.)\n3. 근무지 한 곳에서만 근무 할 수 있는 환경 (예전에는 지방을 여기저기 많이 다녔다.)\n4. 시니어 개발자와 주니어 개발자 층이 어느정도 있고, 같이 의논하며 개발할 수 있는 환경\n5. Spring 4 / Java 1.8 이상을 사용하여 개발하는 조직\n6. 내가 더 발전할 수 있는 조직\n7. 연봉도 많이 올려주면 좋고~! ^^\n\n하지만 생각보다 이직은 쉽지 않았다. (특히나 선퇴사 후이직 이어서.. 11월쯤에는 굉장히 쫄렸다.)\n일단 서비스 회사로 이직을 목표로 잡았지만, 기존의 했던 업무가 제조업이나 MES관련 개발을 주로 했었기 때문에 서비스 회사에서는 대부분의 서류 낙방을 경험했다. (이력서를 처음 써봐서 정말 못써서 그럴 수도 있겠지만.)\n서류 한 군데만 붙어라... 면접은 완전 잘 볼 자신있다!라는 생각으로 서류만 2개월 이상 쓰다보니 10월쯤에는 서류 합격하는 회사가 몇 군데 있었다. 서류합격 메일을 받았을 때 기분이란....크 면접일자가 정해지고, 인터넷에 돌아다니는 예상 면접질문을 바탕으로 하나하나 정리를 하였다. 대게 기술질문은 그 테두리 안에서 나온다는 것이 여러사람들의 의견이었다.\n그리고 9월쯤엔 대기업 신입공채를 준비했어서, 오랜만에 컴퓨터 이론을 한번 정리 했었는데 이 부분이 정말 도움이 많이 되었다. 자주 안보는 만큼 지금도 기억에서 많이 사라졌는데, 가끔씩 리마인드를 해주는 것이 좋겠다.\n\n면접은 두 군데정도 봤는데 둘 다 자신감있게 봤었다.\n아무래도 SI하면서 고객사 상대로 발표도 하고 회의도 자주 하다보니, 남들이랑 대화하고 그런거는 긴장되지 않았다.\n그렇기 때문에 면접을 보면서 긴장을 덜하고 면접장에서 어필할 수 있었던 것 같다.\n결국 최종적으로 한 곳의 회사만 합격을 하였는데, 그 곳이 NHN티켓링크이다.\n최종합격 후 천만다행이라는 생각이 들었고, 2018년 1월 초에 입사를 하게 되었다.\n\n# 우리 팀의 개발문화\n예전 SI할 때는 혼자서 사이트를 다 만들어야 했기 때문에, 프론트엔드도 하고 백엔드도하고, 서버설치 등을 혼자 다했다. 하지만 여기와서는 인프라 관련해서는 시스템팀이 별도로 있었고, DBA팀도 별도로 있었다. 내가 할 업무는 티켓링크 백엔드 개발과 약간의 간단한 프론트엔드 작업만 하면되었다.\n기획팀도 별도로 나뉘어져 있다보니, 내가 직접 기획서를 쓰지 않아도 되고 개발에만 집중 할 수 있다는 환경이 참 좋았다.\n\n## git flow를 사용한 브랜치 전략\nSI할때는 SVN만 사용해봤는데 그냥 master에 커밋치던 나에게는 신세계였다. 뭔가 구글링하면서 지나쳤던 얘기들을 실천하고 있는 조직이라는 생각이 들었다.\ngit도 처음 사용해 봤는데, SVN보다 더 유연하고 좋다는 생각이 들었다. (특히 브랜치를 왔다갔다 하면서 작업할 수 있는 점이 좋았던 것 같다.)\n\n## Pull Request + 코드리뷰\n두 번째로는 Pull Request를 올려서 코드리뷰를 강제화 하도록 하는 문화이다.\n첫 업무를 받아서 PR을 올렸을 때는 Conversation이 50개 이상이 달려서 코드리뷰를 엄청나게 받았다.\n뭔가 탈탈 털렸다라는 느낌도 받았고, 앞으로 공부해야 할 게 많구나라는 생각이 들었다.\n한 가지 아쉬운점은... `코드리뷰를 하는 사람만 한다.` 다른사람들도 적극적으로 해주면 좋을텐데..라는 생각이 들었다.\n처음에는 나도 다른사람의 코드를 리뷰해줘야지! 라는 생각으로 코드리뷰에 참여하려고 했지만.. 한마디도 달 수 없었다. 그때 딱 드는 생각이, **\"내가 아는게 없어서 코드리뷰를 해줄 수가 없구나.. 코드리뷰에 한마디라도 할 수 있도록 공부하자\"** 라는 생각을 하게 되었다.\n돌이켜보면 나는 여태까지 `\"공부하지 않는 개발자\"`였다.\n팀원들을 보면 아침에 일찍와서 책을보는 분도 계셨고, 따로 스터디모임을 하시는 분도 계셨다.\n입사초기에 나는 살 좀 빼야지.. 라는 생각으로 아침운동을 다녀서 아침에 일찍 공부하기는 힘들었다. 그래서 주로 퇴근 후나 주말에 내가 하고자 하는 공부를 하였다. 그리고 꼭 공부한 내용은 블로그를 작성해서 남겨야겠다고 생각했다.\n공부는 조금조금씩 계속 했지만, 본격적으로 블로그를 설치하고 시작한 것은 7월 정도인 것 같다.\n현재 4년차에 Spring기반으로 개발을 계속 해왔다고는 하지만 Spring의 기본을 공부해본적이 없었다.\n여태까지는 그냥 `이렇게 하면 이렇게 되네~` 방식의 개발을 해와서, 뭐가 안되면 원인 파악하기가 무척이나 어려웠다.\n그래서 처음에는 **Spring core**에 대한 공부를 시작했다. 토비의 Spring 책도 사고, 회사 소스에 적용된 기술들을 하나하나 파보기 시작했다. 하나하나 익히고 나니 너무 유용한 기술들이 많이 있었고, 개발할 때 직접 써먹으면서 실전 응용력을 키울 수 있었던 것 같다.\n\n## 주간 기술공유\n세 번째는 매주 목요일 기술공유 시간을 짧게 갖는다.\n팀원 한 명씩 돌아가면서 신기술에 대한 공유나 코드리뷰등을 하는 시간이다. 이런 걸 해보지 않아서 처음에는 무슨 내용을 공유하지?라는 걱정이 앞섰는데, 다행히도 공유 순서가 가까워지면 항상 공유 할 내용이 있었다. 그리고 내 순서가 아니어도 최대한 공유를 하려고 노력했다. (순서가 아니어도 또 해도 된다. 하지만 내 순번에는 또 공유를 해야한다. ㅎㅎ) 최대한 공유를 많이 하려고 노력했고, 기술공유 준비를 하면서 내가 했던 일들이나 기술에 대해 다시 한번 정리하는 시간이 되어 개인적으로 기술에 대한 기억을 오랫동안 보존할 수 있는 방법이었다.\n또 다른사람의 기술공유를 들었다가 내가 필요할 때 써먹거나, 미처 몰랐던 내용들도 있어서 개발팀 문화 중에 나름 유의미한 시간이라고 생각하고 있다.\n\n# 블로그 시작\n\n올해 목표 중 하나가 블로그에 공부한 내용에 대한 글을 꾸준히 작성하는 것이었다.\n블로그는 7월쯤에 만들어서 꾸준히 작성하려고 노력하고 있다.\n\n현재까지 수를 보니..\n* 7월 - 5개\n* 8월 - 6개\n* 9월 - 3개\n* 10월 - 2개\n* 11월 - 7개\n* 12월 - 8개\n\n정도 해서 총 31개의 포스팅을 작성했다. 시리즈 물로 된 글도 많았고, 회사에서 사용한 기술들을 다시 좀 다듬어서 기록으로 남긴 것들도 있다. (회사 업무내용을 최대한 제외하려 한게 참 힘들었다ㅜㅜ)\n처음에는 블로그도 안써봐서 글 쓰는데 시간도 오래걸리고 뭐 어떻게 써야하나...라는 생각으로 다른 블로그들을 참고하며 많이 썼던것 같다. 그리고 하나 쓰는데 시간도 꽤 오래 걸린것 같다.\n한 30개의 글을 써보니 대충 블로그 쓰는 법도 감이 왔다.\n* 일단 내가 100% 이해하지 못한 상황에서 글을 쓸 수 없다.\n* 처음에는 블로그 포스팅 수를 늘리고 싶어서 무조건 post부터 생성하고 봤는데, 글의 진도가 나가지 않았다.\n* 블로그를 빠르고 쉽게 작성하기 위해서는 목차를 먼저 잡고 그에 대한 지식을 채운 다음에 각 섹션별로 담아내고자 하는 내용을 짧게 정리했다.\n* 예제가 필요한 경우 미리 예제에 대한 실습을 마쳐 놓아야 한다.\n  * 그때그때 예제코드 작성하면 시간이 오래걸리고, 내가 무슨 글을 쓰던 중이었는지 까먹게 된다.\n\n블로그를 쓰다보니 지식에 대한 인덱스도 나름 생기고, 나중에 기억 안나도 예제코드를 찾아볼 수 있어서 좋았다.\n앞으로도 계속 블로그를 작성할 예정인데, 제발 귀찮아지지만 않았으면 좋겠다..!\n\n# 회사 업무\n## 1~2월에는 회사 적응도 하고, 바로 또 업무를 할당 받았다.\n나의 첫 업무는 티켓링크 카카오톡 알림톡 연동이었다. 기존에는 SMS/MMS만 사용했는데, 카카오톡 알림톡을 지원하도록 하는 업무였다. 지금 생각해보면 업무는 단순했다. 카카오톡 API를 연동 인터페이스만 구현해주면 되는 것이었는데, 외부 API 연동을 처음 해보는터라 시간도 오래걸리고, 회사 소스를 파악하면서 해야해서 1달이상의 시간이 걸렸던 것 같다.\n기존 코드의 리팩토링도 해가면서 해서, 나름 재미있게 개발을 했던 첫 업무였다.\n\n## 3~4월에는 캡차 시스템 개발을 진행했다.\n티켓시스템에는 사람들이 좌석을 빨리 차지하기 위해 매크로를 많이 쓴다.\n최근에는 뉴스기사에도 아이돌 콘서트니, 인기 공연에 대해 매크로를 돌려서 빠르게 예매한 다음에 몇배의 가격으로 불려서 암표를 파는 사람이 많다는 기사가 나왔다. 최소한이라도 예방하기 위해 티켓링크에서는 캡차 도입을 고민하고 있었다. 구글의 리캡차나 국내의 캡차 솔루션을 도입하자라는 의견도 나왔고, 직접 구축하는 것이 좋다!라는 의견이 나오고 있을때쯤 집에서 한번 오픈소스를 이용해서 간단하게 캡차를 만들어보았다. 어렵지 않게 예시를 만들수 있었고, 다음날 바로 팀장님께 보여드렸다. 그렇게 캡차 개발은 내 업무가 되었다^^\n나름 보안과 성능을 생각하며, 이미지 캐싱등의 작업을 하였다. 그리고 캡차를 사용하기 위해서는 Global캐시 Store가 하나는 필요했다. 이로인해 팀에서 NoSQL 도입을 생각하게 되었다.\n캡차 개발 완료 후 nGrinder를 통해 성능테스트로 진행하였는데 15,000 TPS정도의 높은 성능이 나와서 나름 만족하고 있었다.(하지만 아직 회사에서 인기 공연이나 예매에 사용을 안해서.. 아쉬웠다.)\n\n## Redis 도입\n캡차 사용을 위해 Redis를 도입하게 되었다. 원래 사용하는 NoSQL이 있지만, 추가적으로 NoSQL서버를 자체 구축할 예정이었다. (이유는 따로 적지 않겠다.) 여러가지 NoSQL이 물망에 올랐다. Redis, Arcus등 여러가지 Key-value store가 거론되었지만, 내 욕심 상 Redis를 해보고 싶었다. (아무래도 Key-value store 1순위인 Redis를 써보고 싶었다.)\nRedis를 도입하면서 단순하게 서버에 Redis만 설치해서 쓰고 싶지는 않았다. 인프라 시스템은 항상 scale out을 고려해야 했기 때문에, 주변에서 Docker를 이용해서 설치 해보라는 얘기가 나왔다.\nDocker는 난생 처음 들어보는 거였는데.. Docker에 대한 삽질을 어마무시하게 하면서 거의 3주만에 Redis 설치와 Cluster 설치까지 완료했다. 이 기회를 가지면서 Redis에 대한 전반적인 이해가 생기게 되었고, 나름 삽질을 거치면서 Docker라는 시스템도 어느정도 이해하게 되었다. (다시는 까먹지 않게 팀내에서도 3일에 걸쳐 공유를 하고 11부작 정도로 블로그도 작성해 두었다^^)\n\n## 결제시스템 개편\n어쩌다보니 내가 티켓링크 결제 시스템 '부'가 되어서 티켓링크 결제시스템 개편 업무를 많이 했다.\nPayco결제, IC카드결제, 네이버페이 연동등을 경험하며, 외부 빌링업체의 결제 프로세스를 경험 할 수 있던 기회였다.\n네이버페이는 거의 처음부터 만들게 되었는데, Web에서의 결제, App에서의 결제를 모두 봐야 해서 꽤 고생했던 기억이 있다. 하지만 결제관련 Flow는 어느정도 알게 되었던 업무였다.\n\n## MSA시도 해보기\n티켓링크 시스템은 Monolothic 시스템 구조를 가지고 있다. 그렇기 때문에 빌드시간도 만만치않게 걸리고 배포하려고 해도 사이드 이펙트가 발생할 확률이 높다. 그렇기 때문에 올해 말부터 하나씩 하나씩 쪼개는 작업을 진행하고 있다. MSA까지는 아니어도 점진적으로 모듈을 분리하여, 빌드 시간을 단축 시키고, 시스템 안정성을 높이기 위함에 있다.\n이 부분에 대해서는 나도 의견을 많이 내고 시니어 개발자분들도 관심있게 보는 부분이어서, 내년에 더 활발하게 작업이 진행 될 것 같다.\n\n# 내년에는..\n내년 공부의 시작은 개발 필독 서적을 몇가지 읽어보려고 한다.\n* clean code\n* TDD 개발 방법론\n* Effective Java 3rd Edition\n(2rd Edition은 한번봤는데, Java8에 대한 내용이 추가되었다고 하니 한번더 봐야겠다.)\n* Java ORM 표준 JPA프로그래밍\n * 현재 MyBatis기반으로 시스템이 구성되어있는데, 새로 만드는 시스템은 무조건 JPA를 도입하자고 얘기가 나오고 있다. 이전 회사에서 JPA사용경험이 있어서 나도 JPA도입을 대찬성하고 있는데, 더 지식을 쌓고 개발할 필요성을 느끼고 있다. 그래서 이 책을 아마 1순위로 공부하지 않을까.. 싶다.\n\n회사 업무에서는 주니어 개발자이지만, 목소리를 내보려 노력하고 있다.\n팀에서도 그런 분위기를 조성하려하고 있는 것 같고, 내 의견이 묵살되더라도 생각이라도 해보고, 다른사람의 의견과 비교할 수 있기 때문에 적극적으로 목소리를 내보고자 한다.\n\n# 마무리..\n올해 회고를 쭉 작성해보니 생각보다 많은 일을 했다는 생각이 든다. 그리고 그 과정 속에서 한단계 더 성장한 개발자가 되었다고 나름 생각하고 만족하고 있다. 회고를 쓰면서 회사 얘기가 조금 나와서.. 글을 좀 수정해야 할 경우가 생길 수도 있지만.. 딱히 그럴만한 내용은 없다고 생각이 든다.\n앞으로는 1년 단위로 회고를 작성하여 한번씩 되돌아보고 추억할 수 있는 시간이 되면 좋겠다.","slug":"2018-12-16-remind","published":1,"updated":"2018-12-22T10:50:27.360Z","comments":1,"photos":[],"link":"","_id":"cjrgbv3rz003ocr1t6hd454fz","content":"<h1 id=\"새-직장으로-이직\">새 직장으로 이직</h1>\n<p>2017년 8월 중순 중소 SI업체를 용기있게(?) 뛰쳐나왔다.\n그 곳에서는 오직 나 한명으로 여러 프로젝트를 돌리고 있었고, 같이 일할 선임개발자도 없었기 때문에\n굉장히 나름대로 스트레스를 받고 있었다.\n그리고 모든 프로젝트가 나에게 의존적이었기 때문에 관리해야 할 사이트도 많았고..\n매일매일 프로젝트 했던 사이트들에 대한 유지보수 전화를 받아가며, 신규 프로젝트를 진행하고 있었다.\n이렇게 개발자로서 소모되어 가고 있다는 생각이 들어 과감하게 퇴사를 하게되었다. 다음에는 어느정도 조직이 구성되어있고 내가 조직원으로서 일할 수 있는 직장을 찾아야겠다! 라는 생각을 하게되었다.\n이직하고자 하는 회사의 조건은 이렇다.</p>\n<ol>\n<li>개발자 한명이 기획, 개발, 유지보수, 영업을 담당하는 작은회사는 가지 않겠다.</li>\n<li>더 이상 SI는 하지 않겠다. (지방 출장이 잦고, 프로젝트 단위로 사업이 돌아가는 곳은 가지 않겠다.)</li>\n<li>근무지 한 곳에서만 근무 할 수 있는 환경 (예전에는 지방을 여기저기 많이 다녔다.)</li>\n<li>시니어 개발자와 주니어 개발자 층이 어느정도 있고, 같이 의논하며 개발할 수 있는 환경</li>\n<li>Spring 4 / Java 1.8 이상을 사용하여 개발하는 조직</li>\n<li>내가 더 발전할 수 있는 조직</li>\n<li>연봉도 많이 올려주면 좋고~! ^^</li>\n</ol>\n<p>하지만 생각보다 이직은 쉽지 않았다. (특히나 선퇴사 후이직 이어서.. 11월쯤에는 굉장히 쫄렸다.)\n일단 서비스 회사로 이직을 목표로 잡았지만, 기존의 했던 업무가 제조업이나 MES관련 개발을 주로 했었기 때문에 서비스 회사에서는 대부분의 서류 낙방을 경험했다. (이력서를 처음 써봐서 정말 못써서 그럴 수도 있겠지만.)\n서류 한 군데만 붙어라... 면접은 완전 잘 볼 자신있다!라는 생각으로 서류만 2개월 이상 쓰다보니 10월쯤에는 서류 합격하는 회사가 몇 군데 있었다. 서류합격 메일을 받았을 때 기분이란....크 면접일자가 정해지고, 인터넷에 돌아다니는 예상 면접질문을 바탕으로 하나하나 정리를 하였다. 대게 기술질문은 그 테두리 안에서 나온다는 것이 여러사람들의 의견이었다.\n그리고 9월쯤엔 대기업 신입공채를 준비했어서, 오랜만에 컴퓨터 이론을 한번 정리 했었는데 이 부분이 정말 도움이 많이 되었다. 자주 안보는 만큼 지금도 기억에서 많이 사라졌는데, 가끔씩 리마인드를 해주는 것이 좋겠다.</p>\n<p>면접은 두 군데정도 봤는데 둘 다 자신감있게 봤었다.\n아무래도 SI하면서 고객사 상대로 발표도 하고 회의도 자주 하다보니, 남들이랑 대화하고 그런거는 긴장되지 않았다.\n그렇기 때문에 면접을 보면서 긴장을 덜하고 면접장에서 어필할 수 있었던 것 같다.\n결국 최종적으로 한 곳의 회사만 합격을 하였는데, 그 곳이 NHN티켓링크이다.\n최종합격 후 천만다행이라는 생각이 들었고, 2018년 1월 초에 입사를 하게 되었다.</p>\n<h1 id=\"우리-팀의-개발문화\">우리 팀의 개발문화</h1>\n<p>예전 SI할 때는 혼자서 사이트를 다 만들어야 했기 때문에, 프론트엔드도 하고 백엔드도하고, 서버설치 등을 혼자 다했다. 하지만 여기와서는 인프라 관련해서는 시스템팀이 별도로 있었고, DBA팀도 별도로 있었다. 내가 할 업무는 티켓링크 백엔드 개발과 약간의 간단한 프론트엔드 작업만 하면되었다.\n기획팀도 별도로 나뉘어져 있다보니, 내가 직접 기획서를 쓰지 않아도 되고 개발에만 집중 할 수 있다는 환경이 참 좋았다.</p>\n<h2 id=\"git-flow를-사용한-브랜치-전략\">git flow를 사용한 브랜치 전략</h2>\n<p>SI할때는 SVN만 사용해봤는데 그냥 master에 커밋치던 나에게는 신세계였다. 뭔가 구글링하면서 지나쳤던 얘기들을 실천하고 있는 조직이라는 생각이 들었다.\ngit도 처음 사용해 봤는데, SVN보다 더 유연하고 좋다는 생각이 들었다. (특히 브랜치를 왔다갔다 하면서 작업할 수 있는 점이 좋았던 것 같다.)</p>\n<h2 id=\"pull-request-코드리뷰\">Pull Request + 코드리뷰</h2>\n<p>두 번째로는 Pull Request를 올려서 코드리뷰를 강제화 하도록 하는 문화이다.\n첫 업무를 받아서 PR을 올렸을 때는 Conversation이 50개 이상이 달려서 코드리뷰를 엄청나게 받았다.\n뭔가 탈탈 털렸다라는 느낌도 받았고, 앞으로 공부해야 할 게 많구나라는 생각이 들었다.\n한 가지 아쉬운점은... <code>코드리뷰를 하는 사람만 한다.</code> 다른사람들도 적극적으로 해주면 좋을텐데..라는 생각이 들었다.\n처음에는 나도 다른사람의 코드를 리뷰해줘야지! 라는 생각으로 코드리뷰에 참여하려고 했지만.. 한마디도 달 수 없었다. 그때 딱 드는 생각이, <strong>&quot;내가 아는게 없어서 코드리뷰를 해줄 수가 없구나.. 코드리뷰에 한마디라도 할 수 있도록 공부하자&quot;</strong> 라는 생각을 하게 되었다.\n돌이켜보면 나는 여태까지 <code>&quot;공부하지 않는 개발자&quot;</code>였다.\n팀원들을 보면 아침에 일찍와서 책을보는 분도 계셨고, 따로 스터디모임을 하시는 분도 계셨다.\n입사초기에 나는 살 좀 빼야지.. 라는 생각으로 아침운동을 다녀서 아침에 일찍 공부하기는 힘들었다. 그래서 주로 퇴근 후나 주말에 내가 하고자 하는 공부를 하였다. 그리고 꼭 공부한 내용은 블로그를 작성해서 남겨야겠다고 생각했다.\n공부는 조금조금씩 계속 했지만, 본격적으로 블로그를 설치하고 시작한 것은 7월 정도인 것 같다.\n현재 4년차에 Spring기반으로 개발을 계속 해왔다고는 하지만 Spring의 기본을 공부해본적이 없었다.\n여태까지는 그냥 <code>이렇게 하면 이렇게 되네~</code> 방식의 개발을 해와서, 뭐가 안되면 원인 파악하기가 무척이나 어려웠다.\n그래서 처음에는 <strong>Spring core</strong>에 대한 공부를 시작했다. 토비의 Spring 책도 사고, 회사 소스에 적용된 기술들을 하나하나 파보기 시작했다. 하나하나 익히고 나니 너무 유용한 기술들이 많이 있었고, 개발할 때 직접 써먹으면서 실전 응용력을 키울 수 있었던 것 같다.</p>\n<h2 id=\"주간-기술공유\">주간 기술공유</h2>\n<p>세 번째는 매주 목요일 기술공유 시간을 짧게 갖는다.\n팀원 한 명씩 돌아가면서 신기술에 대한 공유나 코드리뷰등을 하는 시간이다. 이런 걸 해보지 않아서 처음에는 무슨 내용을 공유하지?라는 걱정이 앞섰는데, 다행히도 공유 순서가 가까워지면 항상 공유 할 내용이 있었다. 그리고 내 순서가 아니어도 최대한 공유를 하려고 노력했다. (순서가 아니어도 또 해도 된다. 하지만 내 순번에는 또 공유를 해야한다. ㅎㅎ) 최대한 공유를 많이 하려고 노력했고, 기술공유 준비를 하면서 내가 했던 일들이나 기술에 대해 다시 한번 정리하는 시간이 되어 개인적으로 기술에 대한 기억을 오랫동안 보존할 수 있는 방법이었다.\n또 다른사람의 기술공유를 들었다가 내가 필요할 때 써먹거나, 미처 몰랐던 내용들도 있어서 개발팀 문화 중에 나름 유의미한 시간이라고 생각하고 있다.</p>\n<h1 id=\"블로그-시작\">블로그 시작</h1>\n<p>올해 목표 중 하나가 블로그에 공부한 내용에 대한 글을 꾸준히 작성하는 것이었다.\n블로그는 7월쯤에 만들어서 꾸준히 작성하려고 노력하고 있다.</p>\n<p>현재까지 수를 보니..</p>\n<ul>\n<li>7월 - 5개</li>\n<li>8월 - 6개</li>\n<li>9월 - 3개</li>\n<li>10월 - 2개</li>\n<li>11월 - 7개</li>\n<li>12월 - 8개</li>\n</ul>\n<p>정도 해서 총 31개의 포스팅을 작성했다. 시리즈 물로 된 글도 많았고, 회사에서 사용한 기술들을 다시 좀 다듬어서 기록으로 남긴 것들도 있다. (회사 업무내용을 최대한 제외하려 한게 참 힘들었다ㅜㅜ)\n처음에는 블로그도 안써봐서 글 쓰는데 시간도 오래걸리고 뭐 어떻게 써야하나...라는 생각으로 다른 블로그들을 참고하며 많이 썼던것 같다. 그리고 하나 쓰는데 시간도 꽤 오래 걸린것 같다.\n한 30개의 글을 써보니 대충 블로그 쓰는 법도 감이 왔다.</p>\n<ul>\n<li>일단 내가 100% 이해하지 못한 상황에서 글을 쓸 수 없다.</li>\n<li>처음에는 블로그 포스팅 수를 늘리고 싶어서 무조건 post부터 생성하고 봤는데, 글의 진도가 나가지 않았다.</li>\n<li>블로그를 빠르고 쉽게 작성하기 위해서는 목차를 먼저 잡고 그에 대한 지식을 채운 다음에 각 섹션별로 담아내고자 하는 내용을 짧게 정리했다.</li>\n<li>예제가 필요한 경우 미리 예제에 대한 실습을 마쳐 놓아야 한다.\n<ul>\n<li>그때그때 예제코드 작성하면 시간이 오래걸리고, 내가 무슨 글을 쓰던 중이었는지 까먹게 된다.</li>\n</ul>\n</li>\n</ul>\n<p>블로그를 쓰다보니 지식에 대한 인덱스도 나름 생기고, 나중에 기억 안나도 예제코드를 찾아볼 수 있어서 좋았다.\n앞으로도 계속 블로그를 작성할 예정인데, 제발 귀찮아지지만 않았으면 좋겠다..!</p>\n<h1 id=\"회사-업무\">회사 업무</h1>\n<h2 id=\"1~2월에는-회사-적응도-하고-바로-또-업무를-할당-받았다\">1~2월에는 회사 적응도 하고, 바로 또 업무를 할당 받았다.</h2>\n<p>나의 첫 업무는 티켓링크 카카오톡 알림톡 연동이었다. 기존에는 SMS/MMS만 사용했는데, 카카오톡 알림톡을 지원하도록 하는 업무였다. 지금 생각해보면 업무는 단순했다. 카카오톡 API를 연동 인터페이스만 구현해주면 되는 것이었는데, 외부 API 연동을 처음 해보는터라 시간도 오래걸리고, 회사 소스를 파악하면서 해야해서 1달이상의 시간이 걸렸던 것 같다.\n기존 코드의 리팩토링도 해가면서 해서, 나름 재미있게 개발을 했던 첫 업무였다.</p>\n<h2 id=\"3~4월에는-캡차-시스템-개발을-진행했다\">3~4월에는 캡차 시스템 개발을 진행했다.</h2>\n<p>티켓시스템에는 사람들이 좌석을 빨리 차지하기 위해 매크로를 많이 쓴다.\n최근에는 뉴스기사에도 아이돌 콘서트니, 인기 공연에 대해 매크로를 돌려서 빠르게 예매한 다음에 몇배의 가격으로 불려서 암표를 파는 사람이 많다는 기사가 나왔다. 최소한이라도 예방하기 위해 티켓링크에서는 캡차 도입을 고민하고 있었다. 구글의 리캡차나 국내의 캡차 솔루션을 도입하자라는 의견도 나왔고, 직접 구축하는 것이 좋다!라는 의견이 나오고 있을때쯤 집에서 한번 오픈소스를 이용해서 간단하게 캡차를 만들어보았다. 어렵지 않게 예시를 만들수 있었고, 다음날 바로 팀장님께 보여드렸다. 그렇게 캡차 개발은 내 업무가 되었다^^\n나름 보안과 성능을 생각하며, 이미지 캐싱등의 작업을 하였다. 그리고 캡차를 사용하기 위해서는 Global캐시 Store가 하나는 필요했다. 이로인해 팀에서 NoSQL 도입을 생각하게 되었다.\n캡차 개발 완료 후 nGrinder를 통해 성능테스트로 진행하였는데 15,000 TPS정도의 높은 성능이 나와서 나름 만족하고 있었다.(하지만 아직 회사에서 인기 공연이나 예매에 사용을 안해서.. 아쉬웠다.)</p>\n<h2 id=\"redis-도입\">Redis 도입</h2>\n<p>캡차 사용을 위해 Redis를 도입하게 되었다. 원래 사용하는 NoSQL이 있지만, 추가적으로 NoSQL서버를 자체 구축할 예정이었다. (이유는 따로 적지 않겠다.) 여러가지 NoSQL이 물망에 올랐다. Redis, Arcus등 여러가지 Key-value store가 거론되었지만, 내 욕심 상 Redis를 해보고 싶었다. (아무래도 Key-value store 1순위인 Redis를 써보고 싶었다.)\nRedis를 도입하면서 단순하게 서버에 Redis만 설치해서 쓰고 싶지는 않았다. 인프라 시스템은 항상 scale out을 고려해야 했기 때문에, 주변에서 Docker를 이용해서 설치 해보라는 얘기가 나왔다.\nDocker는 난생 처음 들어보는 거였는데.. Docker에 대한 삽질을 어마무시하게 하면서 거의 3주만에 Redis 설치와 Cluster 설치까지 완료했다. 이 기회를 가지면서 Redis에 대한 전반적인 이해가 생기게 되었고, 나름 삽질을 거치면서 Docker라는 시스템도 어느정도 이해하게 되었다. (다시는 까먹지 않게 팀내에서도 3일에 걸쳐 공유를 하고 11부작 정도로 블로그도 작성해 두었다^^)</p>\n<h2 id=\"결제시스템-개편\">결제시스템 개편</h2>\n<p>어쩌다보니 내가 티켓링크 결제 시스템 '부'가 되어서 티켓링크 결제시스템 개편 업무를 많이 했다.\nPayco결제, IC카드결제, 네이버페이 연동등을 경험하며, 외부 빌링업체의 결제 프로세스를 경험 할 수 있던 기회였다.\n네이버페이는 거의 처음부터 만들게 되었는데, Web에서의 결제, App에서의 결제를 모두 봐야 해서 꽤 고생했던 기억이 있다. 하지만 결제관련 Flow는 어느정도 알게 되었던 업무였다.</p>\n<h2 id=\"msa시도-해보기\">MSA시도 해보기</h2>\n<p>티켓링크 시스템은 Monolothic 시스템 구조를 가지고 있다. 그렇기 때문에 빌드시간도 만만치않게 걸리고 배포하려고 해도 사이드 이펙트가 발생할 확률이 높다. 그렇기 때문에 올해 말부터 하나씩 하나씩 쪼개는 작업을 진행하고 있다. MSA까지는 아니어도 점진적으로 모듈을 분리하여, 빌드 시간을 단축 시키고, 시스템 안정성을 높이기 위함에 있다.\n이 부분에 대해서는 나도 의견을 많이 내고 시니어 개발자분들도 관심있게 보는 부분이어서, 내년에 더 활발하게 작업이 진행 될 것 같다.</p>\n<h1 id=\"내년에는\">내년에는..</h1>\n<p>내년 공부의 시작은 개발 필독 서적을 몇가지 읽어보려고 한다.</p>\n<ul>\n<li>clean code</li>\n<li>TDD 개발 방법론</li>\n<li>Effective Java 3rd Edition\n(2rd Edition은 한번봤는데, Java8에 대한 내용이 추가되었다고 하니 한번더 봐야겠다.)</li>\n<li>Java ORM 표준 JPA프로그래밍</li>\n<li>현재 MyBatis기반으로 시스템이 구성되어있는데, 새로 만드는 시스템은 무조건 JPA를 도입하자고 얘기가 나오고 있다. 이전 회사에서 JPA사용경험이 있어서 나도 JPA도입을 대찬성하고 있는데, 더 지식을 쌓고 개발할 필요성을 느끼고 있다. 그래서 이 책을 아마 1순위로 공부하지 않을까.. 싶다.</li>\n</ul>\n<p>회사 업무에서는 주니어 개발자이지만, 목소리를 내보려 노력하고 있다.\n팀에서도 그런 분위기를 조성하려하고 있는 것 같고, 내 의견이 묵살되더라도 생각이라도 해보고, 다른사람의 의견과 비교할 수 있기 때문에 적극적으로 목소리를 내보고자 한다.</p>\n<h1 id=\"마무리\">마무리..</h1>\n<p>올해 회고를 쭉 작성해보니 생각보다 많은 일을 했다는 생각이 든다. 그리고 그 과정 속에서 한단계 더 성장한 개발자가 되었다고 나름 생각하고 만족하고 있다. 회고를 쓰면서 회사 얘기가 조금 나와서.. 글을 좀 수정해야 할 경우가 생길 수도 있지만.. 딱히 그럴만한 내용은 없다고 생각이 든다.\n앞으로는 1년 단위로 회고를 작성하여 한번씩 되돌아보고 추억할 수 있는 시간이 되면 좋겠다.</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>새 직장으로 이직</h1>\n<p>2017년 8월 중순 중소 SI업체를 용기있게(?) 뛰쳐나왔다.\n그 곳에서는 오직 나 한명으로 여러 프로젝트를 돌리고 있었고, 같이 일할 선임개발자도 없었기 때문에\n굉장히 나름대로 스트레스를 받고 있었다.\n그리고 모든 프로젝트가 나에게 의존적이었기 때문에 관리해야 할 사이트도 많았고..\n매일매일 프로젝트 했던 사이트들에 대한 유지보수 전화를 받아가며, 신규 프로젝트를 진행하고 있었다.\n이렇게 개발자로서 소모되어 가고 있다는 생각이 들어 과감하게 퇴사를 하게되었다. 다음에는 어느정도 조직이 구성되어있고 내가 조직원으로서 일할 수 있는 직장을 찾아야겠다! 라는 생각을 하게되었다.\n이직하고자 하는 회사의 조건은 이렇다.</p>\n<ol>\n<li>개발자 한명이 기획, 개발, 유지보수, 영업을 담당하는 작은회사는 가지 않겠다.</li>\n<li>더 이상 SI는 하지 않겠다. (지방 출장이 잦고, 프로젝트 단위로 사업이 돌아가는 곳은 가지 않겠다.)</li>\n<li>근무지 한 곳에서만 근무 할 수 있는 환경 (예전에는 지방을 여기저기 많이 다녔다.)</li>\n<li>시니어 개발자와 주니어 개발자 층이 어느정도 있고, 같이 의논하며 개발할 수 있는 환경</li>\n<li>Spring 4 / Java 1.8 이상을 사용하여 개발하는 조직</li>\n<li>내가 더 발전할 수 있는 조직</li>\n<li>연봉도 많이 올려주면 좋고~! ^^</li>\n</ol>\n<p>하지만 생각보다 이직은 쉽지 않았다. (특히나 선퇴사 후이직 이어서.. 11월쯤에는 굉장히 쫄렸다.)\n일단 서비스 회사로 이직을 목표로 잡았지만, 기존의 했던 업무가 제조업이나 MES관련 개발을 주로 했었기 때문에 서비스 회사에서는 대부분의 서류 낙방을 경험했다. (이력서를 처음 써봐서 정말 못써서 그럴 수도 있겠지만.)\n서류 한 군데만 붙어라... 면접은 완전 잘 볼 자신있다!라는 생각으로 서류만 2개월 이상 쓰다보니 10월쯤에는 서류 합격하는 회사가 몇 군데 있었다. 서류합격 메일을 받았을 때 기분이란....크 면접일자가 정해지고, 인터넷에 돌아다니는 예상 면접질문을 바탕으로 하나하나 정리를 하였다. 대게 기술질문은 그 테두리 안에서 나온다는 것이 여러사람들의 의견이었다.\n그리고 9월쯤엔 대기업 신입공채를 준비했어서, 오랜만에 컴퓨터 이론을 한번 정리 했었는데 이 부분이 정말 도움이 많이 되었다. 자주 안보는 만큼 지금도 기억에서 많이 사라졌는데, 가끔씩 리마인드를 해주는 것이 좋겠다.</p>\n<p>면접은 두 군데정도 봤는데 둘 다 자신감있게 봤었다.\n아무래도 SI하면서 고객사 상대로 발표도 하고 회의도 자주 하다보니, 남들이랑 대화하고 그런거는 긴장되지 않았다.\n그렇기 때문에 면접을 보면서 긴장을 덜하고 면접장에서 어필할 수 있었던 것 같다.\n결국 최종적으로 한 곳의 회사만 합격을 하였는데, 그 곳이 NHN티켓링크이다.\n최종합격 후 천만다행이라는 생각이 들었고, 2018년 1월 초에 입사를 하게 되었다.</p>\n<h1>우리 팀의 개발문화</h1>\n<p>예전 SI할 때는 혼자서 사이트를 다 만들어야 했기 때문에, 프론트엔드도 하고 백엔드도하고, 서버설치 등을 혼자 다했다. 하지만 여기와서는 인프라 관련해서는 시스템팀이 별도로 있었고, DBA팀도 별도로 있었다. 내가 할 업무는 티켓링크 백엔드 개발과 약간의 간단한 프론트엔드 작업만 하면되었다.\n기획팀도 별도로 나뉘어져 있다보니, 내가 직접 기획서를 쓰지 않아도 되고 개발에만 집중 할 수 있다는 환경이 참 좋았다.</p>\n<h2>git flow를 사용한 브랜치 전략</h2>\n<p>SI할때는 SVN만 사용해봤는데 그냥 master에 커밋치던 나에게는 신세계였다. 뭔가 구글링하면서 지나쳤던 얘기들을 실천하고 있는 조직이라는 생각이 들었다.\ngit도 처음 사용해 봤는데, SVN보다 더 유연하고 좋다는 생각이 들었다. (특히 브랜치를 왔다갔다 하면서 작업할 수 있는 점이 좋았던 것 같다.)</p>\n<h2>Pull Request + 코드리뷰</h2>\n<p>두 번째로는 Pull Request를 올려서 코드리뷰를 강제화 하도록 하는 문화이다.\n첫 업무를 받아서 PR을 올렸을 때는 Conversation이 50개 이상이 달려서 코드리뷰를 엄청나게 받았다.\n뭔가 탈탈 털렸다라는 느낌도 받았고, 앞으로 공부해야 할 게 많구나라는 생각이 들었다.\n한 가지 아쉬운점은... <code>코드리뷰를 하는 사람만 한다.</code> 다른사람들도 적극적으로 해주면 좋을텐데..라는 생각이 들었다.\n처음에는 나도 다른사람의 코드를 리뷰해줘야지! 라는 생각으로 코드리뷰에 참여하려고 했지만.. 한마디도 달 수 없었다. 그때 딱 드는 생각이, <strong>&quot;내가 아는게 없어서 코드리뷰를 해줄 수가 없구나.. 코드리뷰에 한마디라도 할 수 있도록 공부하자&quot;</strong> 라는 생각을 하게 되었다.\n돌이켜보면 나는 여태까지 <code>&quot;공부하지 않는 개발자&quot;</code>였다.\n팀원들을 보면 아침에 일찍와서 책을보는 분도 계셨고, 따로 스터디모임을 하시는 분도 계셨다.\n입사초기에 나는 살 좀 빼야지.. 라는 생각으로 아침운동을 다녀서 아침에 일찍 공부하기는 힘들었다. 그래서 주로 퇴근 후나 주말에 내가 하고자 하는 공부를 하였다. 그리고 꼭 공부한 내용은 블로그를 작성해서 남겨야겠다고 생각했다.\n공부는 조금조금씩 계속 했지만, 본격적으로 블로그를 설치하고 시작한 것은 7월 정도인 것 같다.\n현재 4년차에 Spring기반으로 개발을 계속 해왔다고는 하지만 Spring의 기본을 공부해본적이 없었다.\n여태까지는 그냥 <code>이렇게 하면 이렇게 되네~</code> 방식의 개발을 해와서, 뭐가 안되면 원인 파악하기가 무척이나 어려웠다.\n그래서 처음에는 <strong>Spring core</strong>에 대한 공부를 시작했다. 토비의 Spring 책도 사고, 회사 소스에 적용된 기술들을 하나하나 파보기 시작했다. 하나하나 익히고 나니 너무 유용한 기술들이 많이 있었고, 개발할 때 직접 써먹으면서 실전 응용력을 키울 수 있었던 것 같다.</p>\n<h2>주간 기술공유</h2>\n<p>세 번째는 매주 목요일 기술공유 시간을 짧게 갖는다.\n팀원 한 명씩 돌아가면서 신기술에 대한 공유나 코드리뷰등을 하는 시간이다. 이런 걸 해보지 않아서 처음에는 무슨 내용을 공유하지?라는 걱정이 앞섰는데, 다행히도 공유 순서가 가까워지면 항상 공유 할 내용이 있었다. 그리고 내 순서가 아니어도 최대한 공유를 하려고 노력했다. (순서가 아니어도 또 해도 된다. 하지만 내 순번에는 또 공유를 해야한다. ㅎㅎ) 최대한 공유를 많이 하려고 노력했고, 기술공유 준비를 하면서 내가 했던 일들이나 기술에 대해 다시 한번 정리하는 시간이 되어 개인적으로 기술에 대한 기억을 오랫동안 보존할 수 있는 방법이었다.\n또 다른사람의 기술공유를 들었다가 내가 필요할 때 써먹거나, 미처 몰랐던 내용들도 있어서 개발팀 문화 중에 나름 유의미한 시간이라고 생각하고 있다.</p>\n<h1>블로그 시작</h1>\n<p>올해 목표 중 하나가 블로그에 공부한 내용에 대한 글을 꾸준히 작성하는 것이었다.\n블로그는 7월쯤에 만들어서 꾸준히 작성하려고 노력하고 있다.</p>\n<p>현재까지 수를 보니..</p>\n<ul>\n<li>7월 - 5개</li>\n<li>8월 - 6개</li>\n<li>9월 - 3개</li>\n<li>10월 - 2개</li>\n<li>11월 - 7개</li>\n<li>12월 - 8개</li>\n</ul>\n<p>정도 해서 총 31개의 포스팅을 작성했다. 시리즈 물로 된 글도 많았고, 회사에서 사용한 기술들을 다시 좀 다듬어서 기록으로 남긴 것들도 있다. (회사 업무내용을 최대한 제외하려 한게 참 힘들었다ㅜㅜ)\n처음에는 블로그도 안써봐서 글 쓰는데 시간도 오래걸리고 뭐 어떻게 써야하나...라는 생각으로 다른 블로그들을 참고하며 많이 썼던것 같다. 그리고 하나 쓰는데 시간도 꽤 오래 걸린것 같다.\n한 30개의 글을 써보니 대충 블로그 쓰는 법도 감이 왔다.</p>\n<ul>\n<li>일단 내가 100% 이해하지 못한 상황에서 글을 쓸 수 없다.</li>\n<li>처음에는 블로그 포스팅 수를 늘리고 싶어서 무조건 post부터 생성하고 봤는데, 글의 진도가 나가지 않았다.</li>\n<li>블로그를 빠르고 쉽게 작성하기 위해서는 목차를 먼저 잡고 그에 대한 지식을 채운 다음에 각 섹션별로 담아내고자 하는 내용을 짧게 정리했다.</li>\n<li>예제가 필요한 경우 미리 예제에 대한 실습을 마쳐 놓아야 한다.\n<ul>\n<li>그때그때 예제코드 작성하면 시간이 오래걸리고, 내가 무슨 글을 쓰던 중이었는지 까먹게 된다.</li>\n</ul>\n</li>\n</ul>\n<p>블로그를 쓰다보니 지식에 대한 인덱스도 나름 생기고, 나중에 기억 안나도 예제코드를 찾아볼 수 있어서 좋았다.\n앞으로도 계속 블로그를 작성할 예정인데, 제발 귀찮아지지만 않았으면 좋겠다..!</p>\n<h1>회사 업무</h1>\n<h2>1~2월에는 회사 적응도 하고, 바로 또 업무를 할당 받았다.</h2>\n<p>나의 첫 업무는 티켓링크 카카오톡 알림톡 연동이었다. 기존에는 SMS/MMS만 사용했는데, 카카오톡 알림톡을 지원하도록 하는 업무였다. 지금 생각해보면 업무는 단순했다. 카카오톡 API를 연동 인터페이스만 구현해주면 되는 것이었는데, 외부 API 연동을 처음 해보는터라 시간도 오래걸리고, 회사 소스를 파악하면서 해야해서 1달이상의 시간이 걸렸던 것 같다.\n기존 코드의 리팩토링도 해가면서 해서, 나름 재미있게 개발을 했던 첫 업무였다.</p>\n<h2>3~4월에는 캡차 시스템 개발을 진행했다.</h2>\n<p>티켓시스템에는 사람들이 좌석을 빨리 차지하기 위해 매크로를 많이 쓴다.\n최근에는 뉴스기사에도 아이돌 콘서트니, 인기 공연에 대해 매크로를 돌려서 빠르게 예매한 다음에 몇배의 가격으로 불려서 암표를 파는 사람이 많다는 기사가 나왔다. 최소한이라도 예방하기 위해 티켓링크에서는 캡차 도입을 고민하고 있었다. 구글의 리캡차나 국내의 캡차 솔루션을 도입하자라는 의견도 나왔고, 직접 구축하는 것이 좋다!라는 의견이 나오고 있을때쯤 집에서 한번 오픈소스를 이용해서 간단하게 캡차를 만들어보았다. 어렵지 않게 예시를 만들수 있었고, 다음날 바로 팀장님께 보여드렸다. 그렇게 캡차 개발은 내 업무가 되었다^^\n나름 보안과 성능을 생각하며, 이미지 캐싱등의 작업을 하였다. 그리고 캡차를 사용하기 위해서는 Global캐시 Store가 하나는 필요했다. 이로인해 팀에서 NoSQL 도입을 생각하게 되었다.\n캡차 개발 완료 후 nGrinder를 통해 성능테스트로 진행하였는데 15,000 TPS정도의 높은 성능이 나와서 나름 만족하고 있었다.(하지만 아직 회사에서 인기 공연이나 예매에 사용을 안해서.. 아쉬웠다.)</p>\n<h2>Redis 도입</h2>\n<p>캡차 사용을 위해 Redis를 도입하게 되었다. 원래 사용하는 NoSQL이 있지만, 추가적으로 NoSQL서버를 자체 구축할 예정이었다. (이유는 따로 적지 않겠다.) 여러가지 NoSQL이 물망에 올랐다. Redis, Arcus등 여러가지 Key-value store가 거론되었지만, 내 욕심 상 Redis를 해보고 싶었다. (아무래도 Key-value store 1순위인 Redis를 써보고 싶었다.)\nRedis를 도입하면서 단순하게 서버에 Redis만 설치해서 쓰고 싶지는 않았다. 인프라 시스템은 항상 scale out을 고려해야 했기 때문에, 주변에서 Docker를 이용해서 설치 해보라는 얘기가 나왔다.\nDocker는 난생 처음 들어보는 거였는데.. Docker에 대한 삽질을 어마무시하게 하면서 거의 3주만에 Redis 설치와 Cluster 설치까지 완료했다. 이 기회를 가지면서 Redis에 대한 전반적인 이해가 생기게 되었고, 나름 삽질을 거치면서 Docker라는 시스템도 어느정도 이해하게 되었다. (다시는 까먹지 않게 팀내에서도 3일에 걸쳐 공유를 하고 11부작 정도로 블로그도 작성해 두었다^^)</p>\n<h2>결제시스템 개편</h2>\n<p>어쩌다보니 내가 티켓링크 결제 시스템 '부'가 되어서 티켓링크 결제시스템 개편 업무를 많이 했다.\nPayco결제, IC카드결제, 네이버페이 연동등을 경험하며, 외부 빌링업체의 결제 프로세스를 경험 할 수 있던 기회였다.\n네이버페이는 거의 처음부터 만들게 되었는데, Web에서의 결제, App에서의 결제를 모두 봐야 해서 꽤 고생했던 기억이 있다. 하지만 결제관련 Flow는 어느정도 알게 되었던 업무였다.</p>\n<h2>MSA시도 해보기</h2>\n<p>티켓링크 시스템은 Monolothic 시스템 구조를 가지고 있다. 그렇기 때문에 빌드시간도 만만치않게 걸리고 배포하려고 해도 사이드 이펙트가 발생할 확률이 높다. 그렇기 때문에 올해 말부터 하나씩 하나씩 쪼개는 작업을 진행하고 있다. MSA까지는 아니어도 점진적으로 모듈을 분리하여, 빌드 시간을 단축 시키고, 시스템 안정성을 높이기 위함에 있다.\n이 부분에 대해서는 나도 의견을 많이 내고 시니어 개발자분들도 관심있게 보는 부분이어서, 내년에 더 활발하게 작업이 진행 될 것 같다.</p>\n<h1>내년에는..</h1>\n<p>내년 공부의 시작은 개발 필독 서적을 몇가지 읽어보려고 한다.</p>\n<ul>\n<li>clean code</li>\n<li>TDD 개발 방법론</li>\n<li>Effective Java 3rd Edition\n(2rd Edition은 한번봤는데, Java8에 대한 내용이 추가되었다고 하니 한번더 봐야겠다.)</li>\n<li>Java ORM 표준 JPA프로그래밍</li>\n<li>현재 MyBatis기반으로 시스템이 구성되어있는데, 새로 만드는 시스템은 무조건 JPA를 도입하자고 얘기가 나오고 있다. 이전 회사에서 JPA사용경험이 있어서 나도 JPA도입을 대찬성하고 있는데, 더 지식을 쌓고 개발할 필요성을 느끼고 있다. 그래서 이 책을 아마 1순위로 공부하지 않을까.. 싶다.</li>\n</ul>\n<p>회사 업무에서는 주니어 개발자이지만, 목소리를 내보려 노력하고 있다.\n팀에서도 그런 분위기를 조성하려하고 있는 것 같고, 내 의견이 묵살되더라도 생각이라도 해보고, 다른사람의 의견과 비교할 수 있기 때문에 적극적으로 목소리를 내보고자 한다.</p>\n<h1>마무리..</h1>\n<p>올해 회고를 쭉 작성해보니 생각보다 많은 일을 했다는 생각이 든다. 그리고 그 과정 속에서 한단계 더 성장한 개발자가 되었다고 나름 생각하고 만족하고 있다. 회고를 쓰면서 회사 얘기가 조금 나와서.. 글을 좀 수정해야 할 경우가 생길 수도 있지만.. 딱히 그럴만한 내용은 없다고 생각이 든다.\n앞으로는 1년 단위로 회고를 작성하여 한번씩 되돌아보고 추억할 수 있는 시간이 되면 좋겠다.</p>\n"},{"title":"Item 11. Equals를 재정의하려거든 Hashcode도 재정의하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item11","typora-copy-images-to":"effective-java-item11","date":"2019-01-12T13:22:20.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\n`equals를 재정의한 클래스에서는 hashcode도 재정의 해야한다.`  \n그렇지 않으면 hash를 사용하는 HashMap, HashSet과 같은 컬렉션의 원소로 사용될 때 문제가 발생할 것이다.\n\n이번 글을 읽기 전에 아래 글을 먼저 읽어 해시, 해시테이블에 대한 용어를 먼저 익히는 것이 도움이 될 것 같다.\n* [해쉬 테이블의 이해와 구현 (Hashtable) - 조대협의 블로그](http://bcho.tistory.com/1072)\n* [Java HashMap은 어떻게 동작하는가? - Naver D2](https://d2.naver.com/helloworld/831311)\n\n# hashcode의 규약\n* equals비교에 사용되는 정보가 변경되지 않았다면, 객체의 hashcode 메서드는 몇번을 호출해도 항상 일관된 값을 반환해야 한다.  \n(단, Application을 다시 실행한다면 값이 달라져도 상관없다. (메모리 소가 달라지기 때문))\n* equals메서드 통해 두 개의 객체가 같다고 판단했다면, 두 객체는 똑같은 hashcode 값을 반환해야 한다.\n* equals메서드가 두 개의 객체를 다르다고 판단했다 하더라도, 두 객체의 hashcode가 서로 다른 값을 가질 필요는 없다. (Hash Collision)  \n단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.\n\n# equals 메서드는 재정의했지만, hashcode를 재정의하지 않은 경우\nhashcode의 규약 2번째 조건을 위반하는 행위이다.  \nEffective Java 11장에서 설명하는 PhoneNumber 클래스를 생성해 테스트 해 보았다.\n```java\n@RunWith(JUnit4.class)\npublic class HashCodeTest {\n\n    @Test\n    public void hashcode_재정의() {\n        HashMap<ExtendedPhoneNumber, String> map = new HashMap<>();\n        map.put(new ExtendedPhoneNumber(707, 867, 5307), \"제니\");\n        System.out.println(\"Instance 1 hashcode : \" + new ExtendedPhoneNumber(707, 867, 5307).hashCode());\n        System.out.println(\"Instance 2 hashcode : \" + new ExtendedPhoneNumber(707, 867, 5307).hashCode());\n        Assert.assertEquals(map.get(new ExtendedPhoneNumber(707, 867, 5307)), \"제니\");\n    }\n\n    @Test\n    public void hashcode_재정의안함() {\n        HashMap<PhoneNumber, String> map = new HashMap<>();\n        map.put(new PhoneNumber(707, 867, 5307), \"제니\");\n        System.out.println(\"Instance 1 hashcode : \" + new PhoneNumber(707, 867, 5307).hashCode());\n        System.out.println(\"Instance 2 hashcode : \" + new PhoneNumber(707, 867, 5307).hashCode());\n        Assert.assertNotEquals(map.get(new PhoneNumber(707, 867, 5307)), \"제니\");\n    }\n\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class PhoneNumber {\n        protected int firstNumber;\n        protected int secondNumber;\n        protected int thirdNumber;\n\n        @Override\n        public boolean equals(Object o) {\n            if (!(o instanceof PhoneNumber)) {\n                return false;\n            }\n\n            PhoneNumber p = (PhoneNumber) o;\n            return this.firstNumber == p.firstNumber &&\n                    this.secondNumber == p.secondNumber &&\n                    this.thirdNumber == p.thirdNumber;\n        }\n    }\n\n    @NoArgsConstructor\n    public static class ExtendedPhoneNumber extends PhoneNumber {\n\n        public ExtendedPhoneNumber(int firstNumber, int secondNumber, int thirdNumber) {\n            super(firstNumber, secondNumber, thirdNumber);\n        }\n\n        @Override\n        public int hashCode() {\n            int c = 31;\n            int hashcode = Integer.hashCode(firstNumber);\n            hashcode = c * hashcode + Integer.hashCode(secondNumber);\n            hashcode = c * hashcode + Integer.hashCode(thirdNumber);\n            return hashcode;\n        }\n    }\n}\n```\n## Test.1 hashcode를 재정의 하지 않은 경우\nPhoneNumber 클래스에서는 객체 동치성 체크를 위해 equals메서드를 재정의했다. **하지만 hashcode 메서드는 재정의 하지 않았다.** \nnew를 통해 새로운 객체를 만들 때마다 늘 다른 hashcode를 리턴하여, 실제 HashMap에 key로 PhoneNumber클래스를 삽입하더라도  \nhashcode가 다르기 때문에 다른 버킷에가서 데이터를 조회 하려고해서 결과적으로 null이 나와 기댓값인 `\"제니\"`를 만족하지 못했다. \n\n실제 로그를 찍어보니\n```\nInstance 1 hashcode : 1686369710\nInstance 2 hashcode : 194706439\n```\n두 개의 다른 객체에 대해 다른 hashcode를 리턴하고 있었다.\n\n## Test.2 hashcode를 재정의 한 경우\nExtendPhoneNumber 클래스에서는 PhoneNumber를 상속 받은 뒤, hashCode 메서드를 재정의하였다.  \n(equals메서드는 PhoneNumber의 equals를 그대로 사용하였다.) \n\n실제 로그를 찍어보니\n```\nInstance 1 hashcode : 711611\nInstance 2 hashcode : 711611\n```\n두 개의 ExtendPhoneNumber 객체에 대해 같은 hashcode를 리턴하고 있었다.  \n그렇기 때문에 HashMap에 삽입한 ExtendPhoneNumber 객체에 대해 new ExtendPhoneNumber()로 조회를 하니 같은 hashCode의 버킷을 조회하여  \n`\"제니\"`라는 데이터를 얻어올 수 있었다.\n\n\n# 최악의 hashcode 구현\n```java\n@Override\npublic int hashCode() {\n  return 42;\n}\n```\n이 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하니 적법한 해시코드 처럼 보인다.  \n하지만, 모든 객체에 대해 똑같은 해시코드를 반환하니 모든 객체가 같은 해시테이블 버킷에 담겨 연결리스트(Linked List)처럼 동작하게 된다.  \n평균 수행시간이 O(1)에서 O(n)으로 느려져서, 성능이 매우 낮아질 뿐더러 버킷에 대한 overflow가 발생하는 경우 데이터가 누락될 수도 있다.\n\n## hashcode가 같으면 HashMap에서 어떻게 동작할까?\n```java\n@RunWith(JUnit4.class)\npublic class HashCodeTest2 {\n\n    @Test\n    public void hashcode_재정의() {\n        HashMap<ExtendedPhoneNumber, String> map = new HashMap<>();\n        map.put(new ExtendedPhoneNumber(707, 867, 5307), \"제니\");\n        System.out.println(\"Instance 1 hashcode : \" + new ExtendedPhoneNumber(707, 867, 5307).hashCode());\n        System.out.println(\"Instance 2 hashcode : \" + new ExtendedPhoneNumber(707, 867, 5301).hashCode());\n        //다른 객체를 넣어 데이터를 조회해 보았다.\n        Assert.assertEquals(map.get(new ExtendedPhoneNumber(707, 867, 5301)), \"제니\");\n    }\n\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class PhoneNumber {\n        protected int firstNumber;\n        protected int secondNumber;\n        protected int thirdNumber;\n\n        @Override\n        public boolean equals(Object o) {\n            if (!(o instanceof PhoneNumber)) {\n                return false;\n            }\n\n            PhoneNumber p = (PhoneNumber) o;\n            return this.firstNumber == p.firstNumber &&\n                    this.secondNumber == p.secondNumber &&\n                    this.thirdNumber == p.thirdNumber;\n        }\n    }\n\n    @NoArgsConstructor\n    public static class ExtendedPhoneNumber extends PhoneNumber {\n\n        public ExtendedPhoneNumber(int firstNumber, int secondNumber, int thirdNumber) {\n            super(firstNumber, secondNumber, thirdNumber);\n        }\n\n        @Override\n        public int hashCode() {\n            return 42;\n        }\n    }\n}\n```\n\n```\nInstance 1 hashcode : 42\nInstance 2 hashcode : 42\n\njava.lang.AssertionError: \nExpected :null\nActual   :제니\n <Click to see difference>\n```\n\n이 결과로 보아하니, hashcode가 같으면 같은 버킷에 LinkedList로 저장되면서 객체에 대해 equals 체크를 통해 데이터를 조회하는 것으로 판단 된다.\n\n> 설사 두 인스턴스가 같은 버킷에 담았더라도, hashmap.get메서드는 null을 반환한다.  \n만약 hashcode가 다른경우에는 동치성비교를 실행하지 않도록 최적화 되어있기 때문이다.  \nhashcode가 같더라도 동치성비교(equals)를 실행하여 객체에 대한 값(value)를 조회한다.\n\n# 좋은 해시 함수 만들기\n좋은 해시 함수는 서로 다른 인스턴스에 대해 다른 해시코드를 반환한다.  \n이게 바로 hashcode의 세번째 규약이 요구하는 속성이다.  \n이상적인 해시 함수는 주어진 (서로 다른) 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.\n\n```java\n@Override\npublic int hashCode() {\n    int c = 31;\n    //1. int변수 result를 선언한 후 첫번째 핵심 필드에 대한 hashcode로 초기화 한다.\n    int result = Integer.hashCode(firstNumber);\n\n    //2. 기본타입 필드라면 Type.hashCode()를 실행한다\n    //Type은 기본타입의 Boxing 클래스이다.\n    result = c * result + Integer.hashCode(secondNumber);\n\n    //3. 참조타입이라면 참조타입에 대한 hashcode 함수를 호출 한다.\n    //4. 값이 null이면 0을 더해 준다.\n    result = c * result + address == null ? 0 : address.hashCode();\n\n    //5. 필드가 배열이라면 핵심 원소를 각각 필드처럼 다룬다.\n    for (String elem : arr) {\n      result = c * result + elem == null ? 0 : elem.hashCode();\n    }\n\n    //6. 배열의 모든 원소가 핵심필드이면 Arrays.hashCode를 이용한다.\n    result = c * result + Arrays.hashCode(arr);\n\n    //7. result = 31 * result + c 형태로 초기화 하여 \n    //result를 리턴한다.\n    return result;\n}\n```\n\n* hashcode를 다 구현했다면, 이 메서드가 동치인 인스턴스에 대해 똑같은 해시코드를 반환할지 TestCase를 작성해보자\n* 파생필드는 hashcode 계산에서 제외해도 된다.\n* equals 비교에 사용되지 않는 필드는 반드시 제외한다.\n* 31 * result를 곱하는 순서에 따라 result 값이 달라진다.\n* 곱할 숫자를 31로 지정하는 이유는 31이 홀수 이면서 소수(prime)이기 때문이다. 2를 곱하는 것은 shift연산과 같은 결과를 내기 떄문에 추천하지 않는다.\n* 31을 이용하면 (i << 5) - i와 같이 최적화 할 수 있다.\n\n# hashcode를 편하게 만들어 주는 모듈\n* Objects.hash()\n  * 내부적으로 AutoBoxing이 일어나 성능이 떨어진다.\n* Lombok의 @EqualsAndHashCode\n* Google의 @AutoValue\n\n# hashcode를 재정의 할 때 주의 할 점!\n* 불변 객체에 대해서는 hashcode 생성비용이 많이 든다면, hashcode를 캐싱하는 것도 고려하자\n  * 스레드 안전성까지 고려해야 한다.\n* 성능을 높인답시고 hashcode를 계산할 떄 핵심필드를 생략해서는 안된다.\n  * 속도는 빨라지겠지만, hash품질이 나빠져 해시테이블 성능을 떨어뜨릴 수 있다 (Hashing Collision)\n* hashcode 생성규칙을 API사용자에게 공표하지 말자\n  * 그래야 클라이언트가 hashcode값에 의지한 코드를 짜지 않는다.\n  * 다음 릴리즈 시, 성능을 개선할 여지가 있다.\n\n# 참고\n* Effective Java 3rd Edition - Item 11. equals를 재정의하려거든 hashcode도 재정의하라","source":"_posts/effective-java-item11.md","raw":"---\ntitle: Item 11. equals를 재정의하려거든 hashcode도 재정의하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item11\ntypora-copy-images-to: effective-java-item11\ndate: 2019-01-12 22:22:20\nsubtitle:\nheader-img:\n---\n\n# 서론\n`equals를 재정의한 클래스에서는 hashcode도 재정의 해야한다.`  \n그렇지 않으면 hash를 사용하는 HashMap, HashSet과 같은 컬렉션의 원소로 사용될 때 문제가 발생할 것이다.\n\n이번 글을 읽기 전에 아래 글을 먼저 읽어 해시, 해시테이블에 대한 용어를 먼저 익히는 것이 도움이 될 것 같다.\n* [해쉬 테이블의 이해와 구현 (Hashtable) - 조대협의 블로그](http://bcho.tistory.com/1072)\n* [Java HashMap은 어떻게 동작하는가? - Naver D2](https://d2.naver.com/helloworld/831311)\n\n# hashcode의 규약\n* equals비교에 사용되는 정보가 변경되지 않았다면, 객체의 hashcode 메서드는 몇번을 호출해도 항상 일관된 값을 반환해야 한다.  \n(단, Application을 다시 실행한다면 값이 달라져도 상관없다. (메모리 소가 달라지기 때문))\n* equals메서드 통해 두 개의 객체가 같다고 판단했다면, 두 객체는 똑같은 hashcode 값을 반환해야 한다.\n* equals메서드가 두 개의 객체를 다르다고 판단했다 하더라도, 두 객체의 hashcode가 서로 다른 값을 가질 필요는 없다. (Hash Collision)  \n단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.\n\n# equals 메서드는 재정의했지만, hashcode를 재정의하지 않은 경우\nhashcode의 규약 2번째 조건을 위반하는 행위이다.  \nEffective Java 11장에서 설명하는 PhoneNumber 클래스를 생성해 테스트 해 보았다.\n```java\n@RunWith(JUnit4.class)\npublic class HashCodeTest {\n\n    @Test\n    public void hashcode_재정의() {\n        HashMap<ExtendedPhoneNumber, String> map = new HashMap<>();\n        map.put(new ExtendedPhoneNumber(707, 867, 5307), \"제니\");\n        System.out.println(\"Instance 1 hashcode : \" + new ExtendedPhoneNumber(707, 867, 5307).hashCode());\n        System.out.println(\"Instance 2 hashcode : \" + new ExtendedPhoneNumber(707, 867, 5307).hashCode());\n        Assert.assertEquals(map.get(new ExtendedPhoneNumber(707, 867, 5307)), \"제니\");\n    }\n\n    @Test\n    public void hashcode_재정의안함() {\n        HashMap<PhoneNumber, String> map = new HashMap<>();\n        map.put(new PhoneNumber(707, 867, 5307), \"제니\");\n        System.out.println(\"Instance 1 hashcode : \" + new PhoneNumber(707, 867, 5307).hashCode());\n        System.out.println(\"Instance 2 hashcode : \" + new PhoneNumber(707, 867, 5307).hashCode());\n        Assert.assertNotEquals(map.get(new PhoneNumber(707, 867, 5307)), \"제니\");\n    }\n\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class PhoneNumber {\n        protected int firstNumber;\n        protected int secondNumber;\n        protected int thirdNumber;\n\n        @Override\n        public boolean equals(Object o) {\n            if (!(o instanceof PhoneNumber)) {\n                return false;\n            }\n\n            PhoneNumber p = (PhoneNumber) o;\n            return this.firstNumber == p.firstNumber &&\n                    this.secondNumber == p.secondNumber &&\n                    this.thirdNumber == p.thirdNumber;\n        }\n    }\n\n    @NoArgsConstructor\n    public static class ExtendedPhoneNumber extends PhoneNumber {\n\n        public ExtendedPhoneNumber(int firstNumber, int secondNumber, int thirdNumber) {\n            super(firstNumber, secondNumber, thirdNumber);\n        }\n\n        @Override\n        public int hashCode() {\n            int c = 31;\n            int hashcode = Integer.hashCode(firstNumber);\n            hashcode = c * hashcode + Integer.hashCode(secondNumber);\n            hashcode = c * hashcode + Integer.hashCode(thirdNumber);\n            return hashcode;\n        }\n    }\n}\n```\n## Test.1 hashcode를 재정의 하지 않은 경우\nPhoneNumber 클래스에서는 객체 동치성 체크를 위해 equals메서드를 재정의했다. **하지만 hashcode 메서드는 재정의 하지 않았다.** \nnew를 통해 새로운 객체를 만들 때마다 늘 다른 hashcode를 리턴하여, 실제 HashMap에 key로 PhoneNumber클래스를 삽입하더라도  \nhashcode가 다르기 때문에 다른 버킷에가서 데이터를 조회 하려고해서 결과적으로 null이 나와 기댓값인 `\"제니\"`를 만족하지 못했다. \n\n실제 로그를 찍어보니\n```\nInstance 1 hashcode : 1686369710\nInstance 2 hashcode : 194706439\n```\n두 개의 다른 객체에 대해 다른 hashcode를 리턴하고 있었다.\n\n## Test.2 hashcode를 재정의 한 경우\nExtendPhoneNumber 클래스에서는 PhoneNumber를 상속 받은 뒤, hashCode 메서드를 재정의하였다.  \n(equals메서드는 PhoneNumber의 equals를 그대로 사용하였다.) \n\n실제 로그를 찍어보니\n```\nInstance 1 hashcode : 711611\nInstance 2 hashcode : 711611\n```\n두 개의 ExtendPhoneNumber 객체에 대해 같은 hashcode를 리턴하고 있었다.  \n그렇기 때문에 HashMap에 삽입한 ExtendPhoneNumber 객체에 대해 new ExtendPhoneNumber()로 조회를 하니 같은 hashCode의 버킷을 조회하여  \n`\"제니\"`라는 데이터를 얻어올 수 있었다.\n\n\n# 최악의 hashcode 구현\n```java\n@Override\npublic int hashCode() {\n  return 42;\n}\n```\n이 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하니 적법한 해시코드 처럼 보인다.  \n하지만, 모든 객체에 대해 똑같은 해시코드를 반환하니 모든 객체가 같은 해시테이블 버킷에 담겨 연결리스트(Linked List)처럼 동작하게 된다.  \n평균 수행시간이 O(1)에서 O(n)으로 느려져서, 성능이 매우 낮아질 뿐더러 버킷에 대한 overflow가 발생하는 경우 데이터가 누락될 수도 있다.\n\n## hashcode가 같으면 HashMap에서 어떻게 동작할까?\n```java\n@RunWith(JUnit4.class)\npublic class HashCodeTest2 {\n\n    @Test\n    public void hashcode_재정의() {\n        HashMap<ExtendedPhoneNumber, String> map = new HashMap<>();\n        map.put(new ExtendedPhoneNumber(707, 867, 5307), \"제니\");\n        System.out.println(\"Instance 1 hashcode : \" + new ExtendedPhoneNumber(707, 867, 5307).hashCode());\n        System.out.println(\"Instance 2 hashcode : \" + new ExtendedPhoneNumber(707, 867, 5301).hashCode());\n        //다른 객체를 넣어 데이터를 조회해 보았다.\n        Assert.assertEquals(map.get(new ExtendedPhoneNumber(707, 867, 5301)), \"제니\");\n    }\n\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class PhoneNumber {\n        protected int firstNumber;\n        protected int secondNumber;\n        protected int thirdNumber;\n\n        @Override\n        public boolean equals(Object o) {\n            if (!(o instanceof PhoneNumber)) {\n                return false;\n            }\n\n            PhoneNumber p = (PhoneNumber) o;\n            return this.firstNumber == p.firstNumber &&\n                    this.secondNumber == p.secondNumber &&\n                    this.thirdNumber == p.thirdNumber;\n        }\n    }\n\n    @NoArgsConstructor\n    public static class ExtendedPhoneNumber extends PhoneNumber {\n\n        public ExtendedPhoneNumber(int firstNumber, int secondNumber, int thirdNumber) {\n            super(firstNumber, secondNumber, thirdNumber);\n        }\n\n        @Override\n        public int hashCode() {\n            return 42;\n        }\n    }\n}\n```\n\n```\nInstance 1 hashcode : 42\nInstance 2 hashcode : 42\n\njava.lang.AssertionError: \nExpected :null\nActual   :제니\n <Click to see difference>\n```\n\n이 결과로 보아하니, hashcode가 같으면 같은 버킷에 LinkedList로 저장되면서 객체에 대해 equals 체크를 통해 데이터를 조회하는 것으로 판단 된다.\n\n> 설사 두 인스턴스가 같은 버킷에 담았더라도, hashmap.get메서드는 null을 반환한다.  \n만약 hashcode가 다른경우에는 동치성비교를 실행하지 않도록 최적화 되어있기 때문이다.  \nhashcode가 같더라도 동치성비교(equals)를 실행하여 객체에 대한 값(value)를 조회한다.\n\n# 좋은 해시 함수 만들기\n좋은 해시 함수는 서로 다른 인스턴스에 대해 다른 해시코드를 반환한다.  \n이게 바로 hashcode의 세번째 규약이 요구하는 속성이다.  \n이상적인 해시 함수는 주어진 (서로 다른) 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.\n\n```java\n@Override\npublic int hashCode() {\n    int c = 31;\n    //1. int변수 result를 선언한 후 첫번째 핵심 필드에 대한 hashcode로 초기화 한다.\n    int result = Integer.hashCode(firstNumber);\n\n    //2. 기본타입 필드라면 Type.hashCode()를 실행한다\n    //Type은 기본타입의 Boxing 클래스이다.\n    result = c * result + Integer.hashCode(secondNumber);\n\n    //3. 참조타입이라면 참조타입에 대한 hashcode 함수를 호출 한다.\n    //4. 값이 null이면 0을 더해 준다.\n    result = c * result + address == null ? 0 : address.hashCode();\n\n    //5. 필드가 배열이라면 핵심 원소를 각각 필드처럼 다룬다.\n    for (String elem : arr) {\n      result = c * result + elem == null ? 0 : elem.hashCode();\n    }\n\n    //6. 배열의 모든 원소가 핵심필드이면 Arrays.hashCode를 이용한다.\n    result = c * result + Arrays.hashCode(arr);\n\n    //7. result = 31 * result + c 형태로 초기화 하여 \n    //result를 리턴한다.\n    return result;\n}\n```\n\n* hashcode를 다 구현했다면, 이 메서드가 동치인 인스턴스에 대해 똑같은 해시코드를 반환할지 TestCase를 작성해보자\n* 파생필드는 hashcode 계산에서 제외해도 된다.\n* equals 비교에 사용되지 않는 필드는 반드시 제외한다.\n* 31 * result를 곱하는 순서에 따라 result 값이 달라진다.\n* 곱할 숫자를 31로 지정하는 이유는 31이 홀수 이면서 소수(prime)이기 때문이다. 2를 곱하는 것은 shift연산과 같은 결과를 내기 떄문에 추천하지 않는다.\n* 31을 이용하면 (i << 5) - i와 같이 최적화 할 수 있다.\n\n# hashcode를 편하게 만들어 주는 모듈\n* Objects.hash()\n  * 내부적으로 AutoBoxing이 일어나 성능이 떨어진다.\n* Lombok의 @EqualsAndHashCode\n* Google의 @AutoValue\n\n# hashcode를 재정의 할 때 주의 할 점!\n* 불변 객체에 대해서는 hashcode 생성비용이 많이 든다면, hashcode를 캐싱하는 것도 고려하자\n  * 스레드 안전성까지 고려해야 한다.\n* 성능을 높인답시고 hashcode를 계산할 떄 핵심필드를 생략해서는 안된다.\n  * 속도는 빨라지겠지만, hash품질이 나빠져 해시테이블 성능을 떨어뜨릴 수 있다 (Hashing Collision)\n* hashcode 생성규칙을 API사용자에게 공표하지 말자\n  * 그래야 클라이언트가 hashcode값에 의지한 코드를 짜지 않는다.\n  * 다음 릴리즈 시, 성능을 개선할 여지가 있다.\n\n# 참고\n* Effective Java 3rd Edition - Item 11. equals를 재정의하려거든 hashcode도 재정의하라","slug":"effective-java-item11","published":1,"updated":"2019-01-13T11:38:31.426Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv3s0003qcr1t682eq12t","content":"<h1 id=\"서론\">서론</h1>\n<p><code>equals를 재정의한 클래스에서는 hashcode도 재정의 해야한다.</code><br>\n그렇지 않으면 hash를 사용하는 HashMap, HashSet과 같은 컬렉션의 원소로 사용될 때 문제가 발생할 것이다.</p>\n<p>이번 글을 읽기 전에 아래 글을 먼저 읽어 해시, 해시테이블에 대한 용어를 먼저 익히는 것이 도움이 될 것 같다.</p>\n<ul>\n<li><a href=\"http://bcho.tistory.com/1072\" target=\"_blank\" rel=\"noopener\">해쉬 테이블의 이해와 구현 (Hashtable) - 조대협의 블로그</a></li>\n<li><a href=\"https://d2.naver.com/helloworld/831311\" target=\"_blank\" rel=\"noopener\">Java HashMap은 어떻게 동작하는가? - Naver D2</a></li>\n</ul>\n<h1 id=\"hashcode의-규약\">hashcode의 규약</h1>\n<ul>\n<li>equals비교에 사용되는 정보가 변경되지 않았다면, 객체의 hashcode 메서드는 몇번을 호출해도 항상 일관된 값을 반환해야 한다.<br>\n(단, Application을 다시 실행한다면 값이 달라져도 상관없다. (메모리 소가 달라지기 때문))</li>\n<li>equals메서드 통해 두 개의 객체가 같다고 판단했다면, 두 객체는 똑같은 hashcode 값을 반환해야 한다.</li>\n<li>equals메서드가 두 개의 객체를 다르다고 판단했다 하더라도, 두 객체의 hashcode가 서로 다른 값을 가질 필요는 없다. (Hash Collision)<br>\n단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.</li>\n</ul>\n<h1 id=\"equals-메서드는-재정의했지만-hashcode를-재정의하지-않은-경우\">equals 메서드는 재정의했지만, hashcode를 재정의하지 않은 경우</h1>\n<p>hashcode의 규약 2번째 조건을 위반하는 행위이다.<br>\nEffective Java 11장에서 설명하는 PhoneNumber 클래스를 생성해 테스트 해 보았다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(JUnit4.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashCodeTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> hashcode_재정의() &#123;</span><br><span class=\"line\">        HashMap&lt;ExtendedPhoneNumber, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>), <span class=\"string\">\"제니\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Instance 1 hashcode : \"</span> + <span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>).hashCode());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Instance 2 hashcode : \"</span> + <span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>).hashCode());</span><br><span class=\"line\">        Assert.assertEquals(map.get(<span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>)), <span class=\"string\">\"제니\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> hashcode_재정의안함() &#123;</span><br><span class=\"line\">        HashMap&lt;PhoneNumber, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"keyword\">new</span> PhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>), <span class=\"string\">\"제니\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Instance 1 hashcode : \"</span> + <span class=\"keyword\">new</span> PhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>).hashCode());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Instance 2 hashcode : \"</span> + <span class=\"keyword\">new</span> PhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>).hashCode());</span><br><span class=\"line\">        Assert.assertNotEquals(map.get(<span class=\"keyword\">new</span> PhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>)), <span class=\"string\">\"제니\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\">    <span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneNumber</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> firstNumber;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> secondNumber;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> thirdNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> PhoneNumber)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            PhoneNumber p = (PhoneNumber) o;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstNumber == p.firstNumber &amp;&amp;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.secondNumber == p.secondNumber &amp;&amp;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.thirdNumber == p.thirdNumber;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendedPhoneNumber</span> <span class=\"keyword\">extends</span> <span class=\"title\">PhoneNumber</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExtendedPhoneNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> firstNumber, <span class=\"keyword\">int</span> secondNumber, <span class=\"keyword\">int</span> thirdNumber)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(firstNumber, secondNumber, thirdNumber);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = <span class=\"number\">31</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> hashcode = Integer.hashCode(firstNumber);</span><br><span class=\"line\">            hashcode = c * hashcode + Integer.hashCode(secondNumber);</span><br><span class=\"line\">            hashcode = c * hashcode + Integer.hashCode(thirdNumber);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> hashcode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"test1-hashcode를-재정의-하지-않은-경우\">Test.1 hashcode를 재정의 하지 않은 경우</h2>\n<p>PhoneNumber 클래스에서는 객체 동치성 체크를 위해 equals메서드를 재정의했다. <strong>하지만 hashcode 메서드는 재정의 하지 않았다.</strong>\nnew를 통해 새로운 객체를 만들 때마다 늘 다른 hashcode를 리턴하여, 실제 HashMap에 key로 PhoneNumber클래스를 삽입하더라도<br>\nhashcode가 다르기 때문에 다른 버킷에가서 데이터를 조회 하려고해서 결과적으로 null이 나와 기댓값인 <code>&quot;제니&quot;</code>를 만족하지 못했다.</p>\n<p>실제 로그를 찍어보니\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instance 1 hashcode : 1686369710</span><br><span class=\"line\">Instance 2 hashcode : 194706439</span><br></pre></td></tr></table></figure></p>\n<p>두 개의 다른 객체에 대해 다른 hashcode를 리턴하고 있었다.</p>\n<h2 id=\"test2-hashcode를-재정의-한-경우\">Test.2 hashcode를 재정의 한 경우</h2>\n<p>ExtendPhoneNumber 클래스에서는 PhoneNumber를 상속 받은 뒤, hashCode 메서드를 재정의하였다.<br>\n(equals메서드는 PhoneNumber의 equals를 그대로 사용하였다.)</p>\n<p>실제 로그를 찍어보니\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instance 1 hashcode : 711611</span><br><span class=\"line\">Instance 2 hashcode : 711611</span><br></pre></td></tr></table></figure></p>\n<p>두 개의 ExtendPhoneNumber 객체에 대해 같은 hashcode를 리턴하고 있었다.<br>\n그렇기 때문에 HashMap에 삽입한 ExtendPhoneNumber 객체에 대해 new ExtendPhoneNumber()로 조회를 하니 같은 hashCode의 버킷을 조회하여<br>\n<code>&quot;제니&quot;</code>라는 데이터를 얻어올 수 있었다.</p>\n<h1 id=\"최악의-hashcode-구현\">최악의 hashcode 구현</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">42</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하니 적법한 해시코드 처럼 보인다.<br>\n하지만, 모든 객체에 대해 똑같은 해시코드를 반환하니 모든 객체가 같은 해시테이블 버킷에 담겨 연결리스트(Linked List)처럼 동작하게 된다.<br>\n평균 수행시간이 O(1)에서 O(n)으로 느려져서, 성능이 매우 낮아질 뿐더러 버킷에 대한 overflow가 발생하는 경우 데이터가 누락될 수도 있다.</p>\n<h2 id=\"hashcode가-같으면-hashmap에서-어떻게-동작할까\">hashcode가 같으면 HashMap에서 어떻게 동작할까?</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(JUnit4.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashCodeTest2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> hashcode_재정의() &#123;</span><br><span class=\"line\">        HashMap&lt;ExtendedPhoneNumber, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>), <span class=\"string\">\"제니\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Instance 1 hashcode : \"</span> + <span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>).hashCode());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Instance 2 hashcode : \"</span> + <span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5301</span>).hashCode());</span><br><span class=\"line\">        <span class=\"comment\">//다른 객체를 넣어 데이터를 조회해 보았다.</span></span><br><span class=\"line\">        Assert.assertEquals(map.get(<span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5301</span>)), <span class=\"string\">\"제니\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\">    <span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneNumber</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> firstNumber;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> secondNumber;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> thirdNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> PhoneNumber)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            PhoneNumber p = (PhoneNumber) o;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstNumber == p.firstNumber &amp;&amp;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.secondNumber == p.secondNumber &amp;&amp;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.thirdNumber == p.thirdNumber;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendedPhoneNumber</span> <span class=\"keyword\">extends</span> <span class=\"title\">PhoneNumber</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExtendedPhoneNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> firstNumber, <span class=\"keyword\">int</span> secondNumber, <span class=\"keyword\">int</span> thirdNumber)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(firstNumber, secondNumber, thirdNumber);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">42</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instance 1 hashcode : 42</span><br><span class=\"line\">Instance 2 hashcode : 42</span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.AssertionError: </span><br><span class=\"line\">Expected :null</span><br><span class=\"line\">Actual   :제니</span><br><span class=\"line\"> &lt;Click to see difference&gt;</span><br></pre></td></tr></table></figure></p>\n<p>이 결과로 보아하니, hashcode가 같으면 같은 버킷에 LinkedList로 저장되면서 객체에 대해 equals 체크를 통해 데이터를 조회하는 것으로 판단 된다.</p>\n<blockquote>\n<p>설사 두 인스턴스가 같은 버킷에 담았더라도, hashmap.get메서드는 null을 반환한다.<br>\n만약 hashcode가 다른경우에는 동치성비교를 실행하지 않도록 최적화 되어있기 때문이다.<br>\nhashcode가 같더라도 동치성비교(equals)를 실행하여 객체에 대한 값(value)를 조회한다.</p>\n</blockquote>\n<h1 id=\"좋은-해시-함수-만들기\">좋은 해시 함수 만들기</h1>\n<p>좋은 해시 함수는 서로 다른 인스턴스에 대해 다른 해시코드를 반환한다.<br>\n이게 바로 hashcode의 세번째 규약이 요구하는 속성이다.<br>\n이상적인 해시 함수는 주어진 (서로 다른) 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">31</span>;</span><br><span class=\"line\">    <span class=\"comment\">//1. int변수 result를 선언한 후 첫번째 핵심 필드에 대한 hashcode로 초기화 한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = Integer.hashCode(firstNumber);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2. 기본타입 필드라면 Type.hashCode()를 실행한다</span></span><br><span class=\"line\">    <span class=\"comment\">//Type은 기본타입의 Boxing 클래스이다.</span></span><br><span class=\"line\">    result = c * result + Integer.hashCode(secondNumber);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3. 참조타입이라면 참조타입에 대한 hashcode 함수를 호출 한다.</span></span><br><span class=\"line\">    <span class=\"comment\">//4. 값이 null이면 0을 더해 준다.</span></span><br><span class=\"line\">    result = c * result + address == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : address.hashCode();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//5. 필드가 배열이라면 핵심 원소를 각각 필드처럼 다룬다.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String elem : arr) &#123;</span><br><span class=\"line\">      result = c * result + elem == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : elem.hashCode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//6. 배열의 모든 원소가 핵심필드이면 Arrays.hashCode를 이용한다.</span></span><br><span class=\"line\">    result = c * result + Arrays.hashCode(arr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//7. result = 31 * result + c 형태로 초기화 하여 </span></span><br><span class=\"line\">    <span class=\"comment\">//result를 리턴한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>hashcode를 다 구현했다면, 이 메서드가 동치인 인스턴스에 대해 똑같은 해시코드를 반환할지 TestCase를 작성해보자</li>\n<li>파생필드는 hashcode 계산에서 제외해도 된다.</li>\n<li>equals 비교에 사용되지 않는 필드는 반드시 제외한다.</li>\n<li>31 * result를 곱하는 순서에 따라 result 값이 달라진다.</li>\n<li>곱할 숫자를 31로 지정하는 이유는 31이 홀수 이면서 소수(prime)이기 때문이다. 2를 곱하는 것은 shift연산과 같은 결과를 내기 떄문에 추천하지 않는다.</li>\n<li>31을 이용하면 (i &lt;&lt; 5) - i와 같이 최적화 할 수 있다.</li>\n</ul>\n<h1 id=\"hashcode를-편하게-만들어-주는-모듈\">hashcode를 편하게 만들어 주는 모듈</h1>\n<ul>\n<li>Objects.hash()\n<ul>\n<li>내부적으로 AutoBoxing이 일어나 성능이 떨어진다.</li>\n</ul>\n</li>\n<li>Lombok의 @EqualsAndHashCode</li>\n<li>Google의 @AutoValue</li>\n</ul>\n<h1 id=\"hashcode를-재정의-할-때-주의-할-점\">hashcode를 재정의 할 때 주의 할 점!</h1>\n<ul>\n<li>불변 객체에 대해서는 hashcode 생성비용이 많이 든다면, hashcode를 캐싱하는 것도 고려하자\n<ul>\n<li>스레드 안전성까지 고려해야 한다.</li>\n</ul>\n</li>\n<li>성능을 높인답시고 hashcode를 계산할 떄 핵심필드를 생략해서는 안된다.\n<ul>\n<li>속도는 빨라지겠지만, hash품질이 나빠져 해시테이블 성능을 떨어뜨릴 수 있다 (Hashing Collision)</li>\n</ul>\n</li>\n<li>hashcode 생성규칙을 API사용자에게 공표하지 말자\n<ul>\n<li>그래야 클라이언트가 hashcode값에 의지한 코드를 짜지 않는다.</li>\n<li>다음 릴리즈 시, 성능을 개선할 여지가 있다.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 11. equals를 재정의하려거든 hashcode도 재정의하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p><code>equals를 재정의한 클래스에서는 hashcode도 재정의 해야한다.</code><br>\n그렇지 않으면 hash를 사용하는 HashMap, HashSet과 같은 컬렉션의 원소로 사용될 때 문제가 발생할 것이다.</p>\n<p>이번 글을 읽기 전에 아래 글을 먼저 읽어 해시, 해시테이블에 대한 용어를 먼저 익히는 것이 도움이 될 것 같다.</p>\n<ul>\n<li><a href=\"http://bcho.tistory.com/1072\" target=\"_blank\" rel=\"noopener\">해쉬 테이블의 이해와 구현 (Hashtable) - 조대협의 블로그</a></li>\n<li><a href=\"https://d2.naver.com/helloworld/831311\" target=\"_blank\" rel=\"noopener\">Java HashMap은 어떻게 동작하는가? - Naver D2</a></li>\n</ul>\n<h1>hashcode의 규약</h1>\n<ul>\n<li>equals비교에 사용되는 정보가 변경되지 않았다면, 객체의 hashcode 메서드는 몇번을 호출해도 항상 일관된 값을 반환해야 한다.<br>\n(단, Application을 다시 실행한다면 값이 달라져도 상관없다. (메모리 소가 달라지기 때문))</li>\n<li>equals메서드 통해 두 개의 객체가 같다고 판단했다면, 두 객체는 똑같은 hashcode 값을 반환해야 한다.</li>\n<li>equals메서드가 두 개의 객체를 다르다고 판단했다 하더라도, 두 객체의 hashcode가 서로 다른 값을 가질 필요는 없다. (Hash Collision)<br>\n단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.</li>\n</ul>\n<h1>equals 메서드는 재정의했지만, hashcode를 재정의하지 않은 경우</h1>\n<p>hashcode의 규약 2번째 조건을 위반하는 행위이다.<br>\nEffective Java 11장에서 설명하는 PhoneNumber 클래스를 생성해 테스트 해 보았다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(JUnit4.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashCodeTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> hashcode_재정의() &#123;</span><br><span class=\"line\">        HashMap&lt;ExtendedPhoneNumber, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>), <span class=\"string\">\"제니\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Instance 1 hashcode : \"</span> + <span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>).hashCode());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Instance 2 hashcode : \"</span> + <span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>).hashCode());</span><br><span class=\"line\">        Assert.assertEquals(map.get(<span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>)), <span class=\"string\">\"제니\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> hashcode_재정의안함() &#123;</span><br><span class=\"line\">        HashMap&lt;PhoneNumber, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"keyword\">new</span> PhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>), <span class=\"string\">\"제니\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Instance 1 hashcode : \"</span> + <span class=\"keyword\">new</span> PhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>).hashCode());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Instance 2 hashcode : \"</span> + <span class=\"keyword\">new</span> PhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>).hashCode());</span><br><span class=\"line\">        Assert.assertNotEquals(map.get(<span class=\"keyword\">new</span> PhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>)), <span class=\"string\">\"제니\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\">    <span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneNumber</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> firstNumber;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> secondNumber;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> thirdNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> PhoneNumber)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            PhoneNumber p = (PhoneNumber) o;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstNumber == p.firstNumber &amp;&amp;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.secondNumber == p.secondNumber &amp;&amp;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.thirdNumber == p.thirdNumber;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendedPhoneNumber</span> <span class=\"keyword\">extends</span> <span class=\"title\">PhoneNumber</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExtendedPhoneNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> firstNumber, <span class=\"keyword\">int</span> secondNumber, <span class=\"keyword\">int</span> thirdNumber)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(firstNumber, secondNumber, thirdNumber);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = <span class=\"number\">31</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> hashcode = Integer.hashCode(firstNumber);</span><br><span class=\"line\">            hashcode = c * hashcode + Integer.hashCode(secondNumber);</span><br><span class=\"line\">            hashcode = c * hashcode + Integer.hashCode(thirdNumber);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> hashcode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>Test.1 hashcode를 재정의 하지 않은 경우</h2>\n<p>PhoneNumber 클래스에서는 객체 동치성 체크를 위해 equals메서드를 재정의했다. <strong>하지만 hashcode 메서드는 재정의 하지 않았다.</strong>\nnew를 통해 새로운 객체를 만들 때마다 늘 다른 hashcode를 리턴하여, 실제 HashMap에 key로 PhoneNumber클래스를 삽입하더라도<br>\nhashcode가 다르기 때문에 다른 버킷에가서 데이터를 조회 하려고해서 결과적으로 null이 나와 기댓값인 <code>&quot;제니&quot;</code>를 만족하지 못했다.</p>\n<p>실제 로그를 찍어보니\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instance 1 hashcode : 1686369710</span><br><span class=\"line\">Instance 2 hashcode : 194706439</span><br></pre></td></tr></table></figure></p>\n<p>두 개의 다른 객체에 대해 다른 hashcode를 리턴하고 있었다.</p>\n<h2>Test.2 hashcode를 재정의 한 경우</h2>\n<p>ExtendPhoneNumber 클래스에서는 PhoneNumber를 상속 받은 뒤, hashCode 메서드를 재정의하였다.<br>\n(equals메서드는 PhoneNumber의 equals를 그대로 사용하였다.)</p>\n<p>실제 로그를 찍어보니\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instance 1 hashcode : 711611</span><br><span class=\"line\">Instance 2 hashcode : 711611</span><br></pre></td></tr></table></figure></p>\n<p>두 개의 ExtendPhoneNumber 객체에 대해 같은 hashcode를 리턴하고 있었다.<br>\n그렇기 때문에 HashMap에 삽입한 ExtendPhoneNumber 객체에 대해 new ExtendPhoneNumber()로 조회를 하니 같은 hashCode의 버킷을 조회하여<br>\n<code>&quot;제니&quot;</code>라는 데이터를 얻어올 수 있었다.</p>\n<h1>최악의 hashcode 구현</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">42</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하니 적법한 해시코드 처럼 보인다.<br>\n하지만, 모든 객체에 대해 똑같은 해시코드를 반환하니 모든 객체가 같은 해시테이블 버킷에 담겨 연결리스트(Linked List)처럼 동작하게 된다.<br>\n평균 수행시간이 O(1)에서 O(n)으로 느려져서, 성능이 매우 낮아질 뿐더러 버킷에 대한 overflow가 발생하는 경우 데이터가 누락될 수도 있다.</p>\n<h2>hashcode가 같으면 HashMap에서 어떻게 동작할까?</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(JUnit4.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashCodeTest2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> hashcode_재정의() &#123;</span><br><span class=\"line\">        HashMap&lt;ExtendedPhoneNumber, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>), <span class=\"string\">\"제니\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Instance 1 hashcode : \"</span> + <span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5307</span>).hashCode());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Instance 2 hashcode : \"</span> + <span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5301</span>).hashCode());</span><br><span class=\"line\">        <span class=\"comment\">//다른 객체를 넣어 데이터를 조회해 보았다.</span></span><br><span class=\"line\">        Assert.assertEquals(map.get(<span class=\"keyword\">new</span> ExtendedPhoneNumber(<span class=\"number\">707</span>, <span class=\"number\">867</span>, <span class=\"number\">5301</span>)), <span class=\"string\">\"제니\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\">    <span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneNumber</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> firstNumber;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> secondNumber;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> thirdNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> PhoneNumber)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            PhoneNumber p = (PhoneNumber) o;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstNumber == p.firstNumber &amp;&amp;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.secondNumber == p.secondNumber &amp;&amp;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.thirdNumber == p.thirdNumber;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendedPhoneNumber</span> <span class=\"keyword\">extends</span> <span class=\"title\">PhoneNumber</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExtendedPhoneNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> firstNumber, <span class=\"keyword\">int</span> secondNumber, <span class=\"keyword\">int</span> thirdNumber)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(firstNumber, secondNumber, thirdNumber);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">42</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instance 1 hashcode : 42</span><br><span class=\"line\">Instance 2 hashcode : 42</span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.AssertionError: </span><br><span class=\"line\">Expected :null</span><br><span class=\"line\">Actual   :제니</span><br><span class=\"line\"> &lt;Click to see difference&gt;</span><br></pre></td></tr></table></figure></p>\n<p>이 결과로 보아하니, hashcode가 같으면 같은 버킷에 LinkedList로 저장되면서 객체에 대해 equals 체크를 통해 데이터를 조회하는 것으로 판단 된다.</p>\n<blockquote>\n<p>설사 두 인스턴스가 같은 버킷에 담았더라도, hashmap.get메서드는 null을 반환한다.<br>\n만약 hashcode가 다른경우에는 동치성비교를 실행하지 않도록 최적화 되어있기 때문이다.<br>\nhashcode가 같더라도 동치성비교(equals)를 실행하여 객체에 대한 값(value)를 조회한다.</p>\n</blockquote>\n<h1>좋은 해시 함수 만들기</h1>\n<p>좋은 해시 함수는 서로 다른 인스턴스에 대해 다른 해시코드를 반환한다.<br>\n이게 바로 hashcode의 세번째 규약이 요구하는 속성이다.<br>\n이상적인 해시 함수는 주어진 (서로 다른) 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">31</span>;</span><br><span class=\"line\">    <span class=\"comment\">//1. int변수 result를 선언한 후 첫번째 핵심 필드에 대한 hashcode로 초기화 한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = Integer.hashCode(firstNumber);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2. 기본타입 필드라면 Type.hashCode()를 실행한다</span></span><br><span class=\"line\">    <span class=\"comment\">//Type은 기본타입의 Boxing 클래스이다.</span></span><br><span class=\"line\">    result = c * result + Integer.hashCode(secondNumber);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3. 참조타입이라면 참조타입에 대한 hashcode 함수를 호출 한다.</span></span><br><span class=\"line\">    <span class=\"comment\">//4. 값이 null이면 0을 더해 준다.</span></span><br><span class=\"line\">    result = c * result + address == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : address.hashCode();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//5. 필드가 배열이라면 핵심 원소를 각각 필드처럼 다룬다.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String elem : arr) &#123;</span><br><span class=\"line\">      result = c * result + elem == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : elem.hashCode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//6. 배열의 모든 원소가 핵심필드이면 Arrays.hashCode를 이용한다.</span></span><br><span class=\"line\">    result = c * result + Arrays.hashCode(arr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//7. result = 31 * result + c 형태로 초기화 하여 </span></span><br><span class=\"line\">    <span class=\"comment\">//result를 리턴한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>hashcode를 다 구현했다면, 이 메서드가 동치인 인스턴스에 대해 똑같은 해시코드를 반환할지 TestCase를 작성해보자</li>\n<li>파생필드는 hashcode 계산에서 제외해도 된다.</li>\n<li>equals 비교에 사용되지 않는 필드는 반드시 제외한다.</li>\n<li>31 * result를 곱하는 순서에 따라 result 값이 달라진다.</li>\n<li>곱할 숫자를 31로 지정하는 이유는 31이 홀수 이면서 소수(prime)이기 때문이다. 2를 곱하는 것은 shift연산과 같은 결과를 내기 떄문에 추천하지 않는다.</li>\n<li>31을 이용하면 (i &lt;&lt; 5) - i와 같이 최적화 할 수 있다.</li>\n</ul>\n<h1>hashcode를 편하게 만들어 주는 모듈</h1>\n<ul>\n<li>Objects.hash()\n<ul>\n<li>내부적으로 AutoBoxing이 일어나 성능이 떨어진다.</li>\n</ul>\n</li>\n<li>Lombok의 @EqualsAndHashCode</li>\n<li>Google의 @AutoValue</li>\n</ul>\n<h1>hashcode를 재정의 할 때 주의 할 점!</h1>\n<ul>\n<li>불변 객체에 대해서는 hashcode 생성비용이 많이 든다면, hashcode를 캐싱하는 것도 고려하자\n<ul>\n<li>스레드 안전성까지 고려해야 한다.</li>\n</ul>\n</li>\n<li>성능을 높인답시고 hashcode를 계산할 떄 핵심필드를 생략해서는 안된다.\n<ul>\n<li>속도는 빨라지겠지만, hash품질이 나빠져 해시테이블 성능을 떨어뜨릴 수 있다 (Hashing Collision)</li>\n</ul>\n</li>\n<li>hashcode 생성규칙을 API사용자에게 공표하지 말자\n<ul>\n<li>그래야 클라이언트가 hashcode값에 의지한 코드를 짜지 않는다.</li>\n<li>다음 릴리즈 시, 성능을 개선할 여지가 있다.</li>\n</ul>\n</li>\n</ul>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 11. equals를 재정의하려거든 hashcode도 재정의하라</li>\n</ul>\n"},{"title":"Item 13. Clone 재정의는 주의해서 진행하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item13","typora-copy-images-to":"effective-java-item13","date":"2019-01-13T07:31:38.000Z","subtitle":null,"header-img":null,"_content":"# 서론\nCloneable은 복제해도 되는 인터페이스 임을 명시하는 용도의 믹스인 인터페이스이다.  \n하지만 아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라는데 있다. 그래서 Cloneable을 구현하는 것만으로는 외부에서 clone 메서드를 호출 할 수 없다.\n\n# Cloneable 인터페이스는 무슨일을 할까?\n```java\n/**\n * A class implements the <code>Cloneable</code> interface to\n * indicate to the {@link java.lang.Object#clone()} method that it\n * is legal for that method to make a\n * field-for-field copy of instances of that class.\n * <p>\n * Invoking Object's clone method on an instance that does not implement the\n * <code>Cloneable</code> interface results in the exception\n * <code>CloneNotSupportedException</code> being thrown.\n * <p>\n * By convention, classes that implement this interface should override\n * {@code Object.clone} (which is protected) with a public method.\n * See {@link java.lang.Object#clone()} for details on overriding this\n * method.\n * <p>\n * Note that this interface does <i>not</i> contain the {@code clone} method.\n * Therefore, it is not possible to clone an object merely by virtue of the\n * fact that it implements this interface.  Even if the clone method is invoked\n * reflectively, there is no guarantee that it will succeed.\n *\n * @author  unascribed\n * @see     java.lang.CloneNotSupportedException\n * @see     java.lang.Object#clone()\n * @since   1.0\n */\npublic interface Cloneable {\n}\n```\n자바의 Cloneable 인터페이스를 보면 아무런 메서드도 없다.  \n아무것도 없지만, 사실은 Object의 clone메서드의 동작방식을 결정한다.  \nCloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면, 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면, `ClassNotSupportedException`을 던진다.\n\n# Object 클래스의 clone 규약\n```java\n    /**\n     * Creates and returns a copy of this object.  The precise meaning\n     * of \"copy\" may depend on the class of the object. The general\n     * intent is that, for any object {@code x}, the expression:\n     * <blockquote>\n     * <pre>\n     * x.clone() != x</pre></blockquote>\n     * will be true, and that the expression:\n     * <blockquote>\n     * <pre>\n     * x.clone().getClass() == x.getClass()</pre></blockquote>\n     * will be {@code true}, but these are not absolute requirements.\n     * While it is typically the case that:\n     * <blockquote>\n     * <pre>\n     * x.clone().equals(x)</pre></blockquote>\n     * will be {@code true}, this is not an absolute requirement.\n     * <p>\n     * By convention, the returned object should be obtained by calling\n     * {@code super.clone}.  If a class and all of its superclasses (except\n     * {@code Object}) obey this convention, it will be the case that\n     * {@code x.clone().getClass() == x.getClass()}.\n     * <p>\n     * By convention, the object returned by this method should be independent\n     * of this object (which is being cloned).  To achieve this independence,\n     * it may be necessary to modify one or more fields of the object returned\n     * by {@code super.clone} before returning it.  Typically, this means\n     * copying any mutable objects that comprise the internal \"deep structure\"\n     * of the object being cloned and replacing the references to these\n     * objects with references to the copies.  If a class contains only\n     * primitive fields or references to immutable objects, then it is usually\n     * the case that no fields in the object returned by {@code super.clone}\n     * need to be modified.\n     * <p>\n     * The method {@code clone} for class {@code Object} performs a\n     * specific cloning operation. First, if the class of this object does\n     * not implement the interface {@code Cloneable}, then a\n     * {@code CloneNotSupportedException} is thrown. Note that all arrays\n     * are considered to implement the interface {@code Cloneable} and that\n     * the return type of the {@code clone} method of an array type {@code T[]}\n     * is {@code T[]} where T is any reference or primitive type.\n     * Otherwise, this method creates a new instance of the class of this\n     * object and initializes all its fields with exactly the contents of\n     * the corresponding fields of this object, as if by assignment; the\n     * contents of the fields are not themselves cloned. Thus, this method\n     * performs a \"shallow copy\" of this object, not a \"deep copy\" operation.\n     * <p>\n     * The class {@code Object} does not itself implement the interface\n     * {@code Cloneable}, so calling the {@code clone} method on an object\n     * whose class is {@code Object} will result in throwing an\n     * exception at run time.\n     *\n     * @return     a clone of this instance.\n     * @throws  CloneNotSupportedException  if the object's class does not\n     *               support the {@code Cloneable} interface. Subclasses\n     *               that override the {@code clone} method can also\n     *               throw this exception to indicate that an instance cannot\n     *               be cloned.\n     * @see java.lang.Cloneable\n     */\n    @HotSpotIntrinsicCandidate\n    protected native Object clone() throws CloneNotSupportedException;\n```\n\nObject에 명시된 clone 규약이 주석으로 쓰여져 있다.\n* x.clone() != x은 참이다.  \n복사한 객체와 원본 객체는 서로 다른 객체이다.\n* x.clone() .getClass() == x.getClass()은 일반적으로 참이다.\n하지만 반드시 만족해야 하는 것은 아니다.\n* x.clone.equals(x) 은 참이다.  \n복사한 객체와 원본객체는 논리적 동치성이 같다.\n* x.clone().getClass() == x.getClass()은 참이다.  \n관례상, 이 방법으로 반환된 객체는 독립성이 있어야 한다.  \n이를 만족하려면 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.\n* Cloneable을 구현하지 않은 클래스의 경우, CloneNotSupportedException이 throw된다.\n* 모든 Array는 Cloneable을 구현하도록 고려되었다. clone 메서드는 T[]를 리턴하도록 설계\n* T는 기본타입 또는 참조타입으로 설계\n* 기본적으로 Object.clone은 clone대상 클래스에 대해 새로운 객체를 new로 생성\n* 모든 필드들에 대해 초기화를 진행\n* 하지만 필드에 대한 객체를 다시 생성하지 않는 Shallow copy 방식으로 수행한다 (deep copy아님)\n* 클래스에 대한 복제본을 원하지 않는 경우 clone메서드를 재정의하여 CloneNotSupportedException을 throw하도록 함\n\n# clone 메서드 재정의 시, 주의할 점\n## 기본적인 clone메서드 재정의\n```java\nclass PhoneNumber implements Cloneable {\n  @Override\n  public PhoneNumber clone() {\n    try {\n      return (PhoneNumber) super.clone();\n    } catch(ClassNotSupportedException e) {\n      //아무처리를 하지 않거나, RuntimeException으로 감싸는 것이 사용하기 편하다.\n    }\n  }\n}\n```\n* super.clone()을 실행하면 PhoneNumber에 대한 완벽한 복제가 이루어진다.\n* super.clone()의 리턴 타입은 Object이지만, 자바의 공변 반환타이핑 기능을 통해 PhoneNumber 타입으로 캐스팅하여 리턴하는 것이 가능하다.  \n(추천하는 기능)\n* try-catch 부분으로 감싼것은 super.clone() 메서드에서 ClassNotSupportedException이라는 checked exception을 리턴하기 떄문에 처리 해주었다. \n  * 하지만 PhoneNumber가 Cloneable을 구현하기 떄문에 절대 실패하지 않는다.  \n  따라서 이부분은 RuntimeException으로 처리하거나, 아무것도 설정하지 않아야 한다.\n\n## 가변 상태를 갖는 필드에 대한 복제\n```java\npublic class Stack implements Cloneable{\n  private Object[] elements;\n  private int size = 0;\n  private static final int DEFAULT_INITIAL_CAPACITY = 16;\n\n  public Stack() {\n    this.elements = new Object[DEFAULT_INITIAL_CAPACITY];\n  }\n\n  public void push(Object o) {}\n  }\n  ...\n\n  @Override\n  public Stack clone() {\n    try {\n      Stack result = (Stack) super.clone();\n      result.elements = \n    } catch(CloneNotSupportedException e) {\n    }\n  }\n}\n```\n이 클래스가 단순히 clone메서드를 이용해 super.clone()만 실행하게 된다면,  \nnew Stack()을 통해 새로운 객체가 생성되고 필드모두 원본 객체와 동일하게 초기화가 될 것이다.  \n하지만, 위에서 얘기한 Object의 clone 기본규약에는 Deep copy가 아닌 Shallow Copy를 이용해 초기화를 진행한다고 적혀있다.  \n따라서 배열과 같은 가변필드는 원본 필드와 객체를 공유하게 된다. \n\nClone메서드는 사실상 생성자와 같은 효과를 낸다.  \n즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.  \n그렇기 때문에 제대로 복제하기 위해서는, elements라는 배열을 똑같이 복사해서 만들어줘야 한다.\n\n## 배열 복사 \n배열을 복제하는 방법 중 가장 권장하는 방법은 \narray.clone()을 이용해 복사하는 방법이다.  \n사실, 배열은 clone기능을 가장 제대로 사용하는 유일한 예이다.\n\n하지만, array 필드가 final이 적용되어 있다면 array.clone()을 통한 초기화는 할 수 없다. (final이기 떄문에 객체 생성 이후 초기화 불가)  \n**Cloneable 아키텍처는 가변객체를 참조하는 필드는 final로 선언하라 라는 일반 용법과 충돌한다.**  \n그래서 복제 할 수 있는 클래스를 만들기 위해 일부 필드에서 final 한정자를 제거해야 할 수도 있다.\n\n## Stack overflow 문제\n```java\npublic class HashTable implements Cloneable  {\n  private Entry[] buckets = ...;\n  private static class Entry {\n    final Object key;\n    Object value;\n    Entry next;\n\n    Entry(Object key, Object value, Entry next) {\n      this.key = key;\n      this.value = value;\n      this.next = next;\n    }\n  }\n\n  @Override\n  public HashTable clone() {\n    try {\n      HashTable result = (HashTable) super.clone();\n      result.buckets = buckets.clone();\n      return result;\n    } catch(CloneNotSupportedException e) {\n      throw new Assertion();\n    }\n  }\n}\n```\n복제본은 자신만의 버킷 배열은 갖지만, 배열내의 Entry는 원본과 같은 연결리스트를 참조하여, 불변성이 꺠지게 된다.\n\n그래서 HashTable.Entry 클래스는 내부적으로 deep copy를 지원하도록 보강되었다. 연결리스트에 대한 next를 복제할 때 재귀적으로 clone을 호출하도록 되어있는데, 재귀 호출 떄문에 연결리스트의 size만큼 스택프레임을 소비하여, 리스트가 길면 stackoverflow에러를 발생시킬 위험이 있다.  \n이 문제를 해결하기 위해서는 재귀 호출을 통한 deepcopy대신 반복자를 써서 순회하는 방법으로 수정해야 한다.\n\n## 안전하지만 느린 copy\nHashTable을 예로 들면, buckets필드를 새로운 배열로 초기화 한다음 원본테이블의 있는 버킷의 내용을 put(key, value) 메서드를 호출해  \n새로 버킷을 만드는 방법이 있다.  \n이 방법은 안전하긴 하지만, low level에서 작동하는 copy보다는 느리다.\n\n## 생성자 내에서는 재정의 될 수 있는 메서드를 호출 하지 말자\n만약 clone이 하위 클래스에서 재정의한 메서드를 호출하면, 하위 클래스는 복사과정에서 자신의 상태를 교정할 기회를 잃게되어  \n원본과 복제본의 상태가 달라질 수 있다.\n\n## ClassNotSupportedException\nObject의 clone메서드는 CloneNotSupportedException을 던진다고 선언했지만 재정의한 메서드는 그렇지 않다.  \npublic인 clone 메서드에서는 throws절을 없애던가, RuntimeException으로 throws 해야한다.  \n그렇지 않으면 clone 메서드를 호출 할 떄마다, 예외처리를 해야 해서 사용하기가 불편하다.\n\n하위 클래스에서 Clone을 방지하기 위해 동작하지 않게 만들수도 있다.\n```java\n@Override\nprotected final Object clone() throws CloneNotSupportedException {\n  throw new CloneNotSupportedException();\n}\n```\n\n## 스레드 안전성을 고려한다면 적절히 동기화해야 한다.\n스레드 안정성을 고려한다면 clone 메서드에 대해 적절히 동기화 처리 해야 한다.\n\n```java\n@Override\npublic synchronized Object clone() {\n  try {\n    Object result = super.clone();\n  } catch(CloneNotSupportedException e) {\n  }\n}\n```\n\n## 복사 생성자와 복사 팩터리 메서드\n```java\npublic Yum(Yum yum) {}\n```\n```java\npublic static Yum newInstance(Yum yum) {}\n```\n\n복사 생성자와 복사 팩터리 메서드는 Cloneable/clone 방식보다 나은 면이 많다. \n* 언어 모순적이고 위험한 객체 생성 메커니즘을 사용하지 않는다. (super.clone())\n* clone 규약에 기대지 않는다.\n* 정상적인 final필드 용법과도 충돌하지 않는다.\n* 불필요한 check exception 처리가 필요없다.\n* 형변환도 필요없다.\n* 복사 생성자와 복사 팩터리는 인터페이스 타입의 인스턴스를 인수로 받을 수 있다. \n\n# Deep copy vs Shallow copy\n[Shallow Copy와 Deep Copy](http://localhost:4000/2019/01/13/java-object-copy) - 이 포스팅을 참고하자\n\n\n# 참고\n* Effective Java 3rd Edition - Item 13. clone 재정의는 주의해서 진행하라","source":"_posts/effective-java-item13.md","raw":"---\ntitle: Item 13. clone 재정의는 주의해서 진행하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item13\ntypora-copy-images-to: effective-java-item13\ndate: 2019-01-13 16:31:38\nsubtitle:\nheader-img:\n---\n# 서론\nCloneable은 복제해도 되는 인터페이스 임을 명시하는 용도의 믹스인 인터페이스이다.  \n하지만 아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라는데 있다. 그래서 Cloneable을 구현하는 것만으로는 외부에서 clone 메서드를 호출 할 수 없다.\n\n# Cloneable 인터페이스는 무슨일을 할까?\n```java\n/**\n * A class implements the <code>Cloneable</code> interface to\n * indicate to the {@link java.lang.Object#clone()} method that it\n * is legal for that method to make a\n * field-for-field copy of instances of that class.\n * <p>\n * Invoking Object's clone method on an instance that does not implement the\n * <code>Cloneable</code> interface results in the exception\n * <code>CloneNotSupportedException</code> being thrown.\n * <p>\n * By convention, classes that implement this interface should override\n * {@code Object.clone} (which is protected) with a public method.\n * See {@link java.lang.Object#clone()} for details on overriding this\n * method.\n * <p>\n * Note that this interface does <i>not</i> contain the {@code clone} method.\n * Therefore, it is not possible to clone an object merely by virtue of the\n * fact that it implements this interface.  Even if the clone method is invoked\n * reflectively, there is no guarantee that it will succeed.\n *\n * @author  unascribed\n * @see     java.lang.CloneNotSupportedException\n * @see     java.lang.Object#clone()\n * @since   1.0\n */\npublic interface Cloneable {\n}\n```\n자바의 Cloneable 인터페이스를 보면 아무런 메서드도 없다.  \n아무것도 없지만, 사실은 Object의 clone메서드의 동작방식을 결정한다.  \nCloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면, 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면, `ClassNotSupportedException`을 던진다.\n\n# Object 클래스의 clone 규약\n```java\n    /**\n     * Creates and returns a copy of this object.  The precise meaning\n     * of \"copy\" may depend on the class of the object. The general\n     * intent is that, for any object {@code x}, the expression:\n     * <blockquote>\n     * <pre>\n     * x.clone() != x</pre></blockquote>\n     * will be true, and that the expression:\n     * <blockquote>\n     * <pre>\n     * x.clone().getClass() == x.getClass()</pre></blockquote>\n     * will be {@code true}, but these are not absolute requirements.\n     * While it is typically the case that:\n     * <blockquote>\n     * <pre>\n     * x.clone().equals(x)</pre></blockquote>\n     * will be {@code true}, this is not an absolute requirement.\n     * <p>\n     * By convention, the returned object should be obtained by calling\n     * {@code super.clone}.  If a class and all of its superclasses (except\n     * {@code Object}) obey this convention, it will be the case that\n     * {@code x.clone().getClass() == x.getClass()}.\n     * <p>\n     * By convention, the object returned by this method should be independent\n     * of this object (which is being cloned).  To achieve this independence,\n     * it may be necessary to modify one or more fields of the object returned\n     * by {@code super.clone} before returning it.  Typically, this means\n     * copying any mutable objects that comprise the internal \"deep structure\"\n     * of the object being cloned and replacing the references to these\n     * objects with references to the copies.  If a class contains only\n     * primitive fields or references to immutable objects, then it is usually\n     * the case that no fields in the object returned by {@code super.clone}\n     * need to be modified.\n     * <p>\n     * The method {@code clone} for class {@code Object} performs a\n     * specific cloning operation. First, if the class of this object does\n     * not implement the interface {@code Cloneable}, then a\n     * {@code CloneNotSupportedException} is thrown. Note that all arrays\n     * are considered to implement the interface {@code Cloneable} and that\n     * the return type of the {@code clone} method of an array type {@code T[]}\n     * is {@code T[]} where T is any reference or primitive type.\n     * Otherwise, this method creates a new instance of the class of this\n     * object and initializes all its fields with exactly the contents of\n     * the corresponding fields of this object, as if by assignment; the\n     * contents of the fields are not themselves cloned. Thus, this method\n     * performs a \"shallow copy\" of this object, not a \"deep copy\" operation.\n     * <p>\n     * The class {@code Object} does not itself implement the interface\n     * {@code Cloneable}, so calling the {@code clone} method on an object\n     * whose class is {@code Object} will result in throwing an\n     * exception at run time.\n     *\n     * @return     a clone of this instance.\n     * @throws  CloneNotSupportedException  if the object's class does not\n     *               support the {@code Cloneable} interface. Subclasses\n     *               that override the {@code clone} method can also\n     *               throw this exception to indicate that an instance cannot\n     *               be cloned.\n     * @see java.lang.Cloneable\n     */\n    @HotSpotIntrinsicCandidate\n    protected native Object clone() throws CloneNotSupportedException;\n```\n\nObject에 명시된 clone 규약이 주석으로 쓰여져 있다.\n* x.clone() != x은 참이다.  \n복사한 객체와 원본 객체는 서로 다른 객체이다.\n* x.clone() .getClass() == x.getClass()은 일반적으로 참이다.\n하지만 반드시 만족해야 하는 것은 아니다.\n* x.clone.equals(x) 은 참이다.  \n복사한 객체와 원본객체는 논리적 동치성이 같다.\n* x.clone().getClass() == x.getClass()은 참이다.  \n관례상, 이 방법으로 반환된 객체는 독립성이 있어야 한다.  \n이를 만족하려면 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.\n* Cloneable을 구현하지 않은 클래스의 경우, CloneNotSupportedException이 throw된다.\n* 모든 Array는 Cloneable을 구현하도록 고려되었다. clone 메서드는 T[]를 리턴하도록 설계\n* T는 기본타입 또는 참조타입으로 설계\n* 기본적으로 Object.clone은 clone대상 클래스에 대해 새로운 객체를 new로 생성\n* 모든 필드들에 대해 초기화를 진행\n* 하지만 필드에 대한 객체를 다시 생성하지 않는 Shallow copy 방식으로 수행한다 (deep copy아님)\n* 클래스에 대한 복제본을 원하지 않는 경우 clone메서드를 재정의하여 CloneNotSupportedException을 throw하도록 함\n\n# clone 메서드 재정의 시, 주의할 점\n## 기본적인 clone메서드 재정의\n```java\nclass PhoneNumber implements Cloneable {\n  @Override\n  public PhoneNumber clone() {\n    try {\n      return (PhoneNumber) super.clone();\n    } catch(ClassNotSupportedException e) {\n      //아무처리를 하지 않거나, RuntimeException으로 감싸는 것이 사용하기 편하다.\n    }\n  }\n}\n```\n* super.clone()을 실행하면 PhoneNumber에 대한 완벽한 복제가 이루어진다.\n* super.clone()의 리턴 타입은 Object이지만, 자바의 공변 반환타이핑 기능을 통해 PhoneNumber 타입으로 캐스팅하여 리턴하는 것이 가능하다.  \n(추천하는 기능)\n* try-catch 부분으로 감싼것은 super.clone() 메서드에서 ClassNotSupportedException이라는 checked exception을 리턴하기 떄문에 처리 해주었다. \n  * 하지만 PhoneNumber가 Cloneable을 구현하기 떄문에 절대 실패하지 않는다.  \n  따라서 이부분은 RuntimeException으로 처리하거나, 아무것도 설정하지 않아야 한다.\n\n## 가변 상태를 갖는 필드에 대한 복제\n```java\npublic class Stack implements Cloneable{\n  private Object[] elements;\n  private int size = 0;\n  private static final int DEFAULT_INITIAL_CAPACITY = 16;\n\n  public Stack() {\n    this.elements = new Object[DEFAULT_INITIAL_CAPACITY];\n  }\n\n  public void push(Object o) {}\n  }\n  ...\n\n  @Override\n  public Stack clone() {\n    try {\n      Stack result = (Stack) super.clone();\n      result.elements = \n    } catch(CloneNotSupportedException e) {\n    }\n  }\n}\n```\n이 클래스가 단순히 clone메서드를 이용해 super.clone()만 실행하게 된다면,  \nnew Stack()을 통해 새로운 객체가 생성되고 필드모두 원본 객체와 동일하게 초기화가 될 것이다.  \n하지만, 위에서 얘기한 Object의 clone 기본규약에는 Deep copy가 아닌 Shallow Copy를 이용해 초기화를 진행한다고 적혀있다.  \n따라서 배열과 같은 가변필드는 원본 필드와 객체를 공유하게 된다. \n\nClone메서드는 사실상 생성자와 같은 효과를 낸다.  \n즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.  \n그렇기 때문에 제대로 복제하기 위해서는, elements라는 배열을 똑같이 복사해서 만들어줘야 한다.\n\n## 배열 복사 \n배열을 복제하는 방법 중 가장 권장하는 방법은 \narray.clone()을 이용해 복사하는 방법이다.  \n사실, 배열은 clone기능을 가장 제대로 사용하는 유일한 예이다.\n\n하지만, array 필드가 final이 적용되어 있다면 array.clone()을 통한 초기화는 할 수 없다. (final이기 떄문에 객체 생성 이후 초기화 불가)  \n**Cloneable 아키텍처는 가변객체를 참조하는 필드는 final로 선언하라 라는 일반 용법과 충돌한다.**  \n그래서 복제 할 수 있는 클래스를 만들기 위해 일부 필드에서 final 한정자를 제거해야 할 수도 있다.\n\n## Stack overflow 문제\n```java\npublic class HashTable implements Cloneable  {\n  private Entry[] buckets = ...;\n  private static class Entry {\n    final Object key;\n    Object value;\n    Entry next;\n\n    Entry(Object key, Object value, Entry next) {\n      this.key = key;\n      this.value = value;\n      this.next = next;\n    }\n  }\n\n  @Override\n  public HashTable clone() {\n    try {\n      HashTable result = (HashTable) super.clone();\n      result.buckets = buckets.clone();\n      return result;\n    } catch(CloneNotSupportedException e) {\n      throw new Assertion();\n    }\n  }\n}\n```\n복제본은 자신만의 버킷 배열은 갖지만, 배열내의 Entry는 원본과 같은 연결리스트를 참조하여, 불변성이 꺠지게 된다.\n\n그래서 HashTable.Entry 클래스는 내부적으로 deep copy를 지원하도록 보강되었다. 연결리스트에 대한 next를 복제할 때 재귀적으로 clone을 호출하도록 되어있는데, 재귀 호출 떄문에 연결리스트의 size만큼 스택프레임을 소비하여, 리스트가 길면 stackoverflow에러를 발생시킬 위험이 있다.  \n이 문제를 해결하기 위해서는 재귀 호출을 통한 deepcopy대신 반복자를 써서 순회하는 방법으로 수정해야 한다.\n\n## 안전하지만 느린 copy\nHashTable을 예로 들면, buckets필드를 새로운 배열로 초기화 한다음 원본테이블의 있는 버킷의 내용을 put(key, value) 메서드를 호출해  \n새로 버킷을 만드는 방법이 있다.  \n이 방법은 안전하긴 하지만, low level에서 작동하는 copy보다는 느리다.\n\n## 생성자 내에서는 재정의 될 수 있는 메서드를 호출 하지 말자\n만약 clone이 하위 클래스에서 재정의한 메서드를 호출하면, 하위 클래스는 복사과정에서 자신의 상태를 교정할 기회를 잃게되어  \n원본과 복제본의 상태가 달라질 수 있다.\n\n## ClassNotSupportedException\nObject의 clone메서드는 CloneNotSupportedException을 던진다고 선언했지만 재정의한 메서드는 그렇지 않다.  \npublic인 clone 메서드에서는 throws절을 없애던가, RuntimeException으로 throws 해야한다.  \n그렇지 않으면 clone 메서드를 호출 할 떄마다, 예외처리를 해야 해서 사용하기가 불편하다.\n\n하위 클래스에서 Clone을 방지하기 위해 동작하지 않게 만들수도 있다.\n```java\n@Override\nprotected final Object clone() throws CloneNotSupportedException {\n  throw new CloneNotSupportedException();\n}\n```\n\n## 스레드 안전성을 고려한다면 적절히 동기화해야 한다.\n스레드 안정성을 고려한다면 clone 메서드에 대해 적절히 동기화 처리 해야 한다.\n\n```java\n@Override\npublic synchronized Object clone() {\n  try {\n    Object result = super.clone();\n  } catch(CloneNotSupportedException e) {\n  }\n}\n```\n\n## 복사 생성자와 복사 팩터리 메서드\n```java\npublic Yum(Yum yum) {}\n```\n```java\npublic static Yum newInstance(Yum yum) {}\n```\n\n복사 생성자와 복사 팩터리 메서드는 Cloneable/clone 방식보다 나은 면이 많다. \n* 언어 모순적이고 위험한 객체 생성 메커니즘을 사용하지 않는다. (super.clone())\n* clone 규약에 기대지 않는다.\n* 정상적인 final필드 용법과도 충돌하지 않는다.\n* 불필요한 check exception 처리가 필요없다.\n* 형변환도 필요없다.\n* 복사 생성자와 복사 팩터리는 인터페이스 타입의 인스턴스를 인수로 받을 수 있다. \n\n# Deep copy vs Shallow copy\n[Shallow Copy와 Deep Copy](http://localhost:4000/2019/01/13/java-object-copy) - 이 포스팅을 참고하자\n\n\n# 참고\n* Effective Java 3rd Edition - Item 13. clone 재정의는 주의해서 진행하라","slug":"effective-java-item13","published":1,"updated":"2019-01-13T11:38:31.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv3s1003tcr1tvwk42m33","content":"<h1 id=\"서론\">서론</h1>\n<p>Cloneable은 복제해도 되는 인터페이스 임을 명시하는 용도의 믹스인 인터페이스이다.<br>\n하지만 아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라는데 있다. 그래서 Cloneable을 구현하는 것만으로는 외부에서 clone 메서드를 호출 할 수 없다.</p>\n<h1 id=\"cloneable-인터페이스는-무슨일을-할까\">Cloneable 인터페이스는 무슨일을 할까?</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to</span></span><br><span class=\"line\"><span class=\"comment\"> * indicate to the &#123;<span class=\"doctag\">@link</span> java.lang.Object#clone()&#125; method that it</span></span><br><span class=\"line\"><span class=\"comment\"> * is legal for that method to make a</span></span><br><span class=\"line\"><span class=\"comment\"> * field-for-field copy of instances of that class.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Invoking Object's clone method on an instance that does not implement the</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * By convention, classes that implement this interface should override</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> Object.clone&#125; (which is protected) with a public method.</span></span><br><span class=\"line\"><span class=\"comment\"> * See &#123;<span class=\"doctag\">@link</span> java.lang.Object#clone()&#125; for details on overriding this</span></span><br><span class=\"line\"><span class=\"comment\"> * method.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &#123;<span class=\"doctag\">@code</span> clone&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\"> * Therefore, it is not possible to clone an object merely by virtue of the</span></span><br><span class=\"line\"><span class=\"comment\"> * fact that it implements this interface.  Even if the clone method is invoked</span></span><br><span class=\"line\"><span class=\"comment\"> * reflectively, there is no guarantee that it will succeed.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>  unascribed</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>     java.lang.CloneNotSupportedException</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>     java.lang.Object#clone()</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span>   1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>자바의 Cloneable 인터페이스를 보면 아무런 메서드도 없다.<br>\n아무것도 없지만, 사실은 Object의 clone메서드의 동작방식을 결정한다.<br>\nCloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면, 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면, <code>ClassNotSupportedException</code>을 던진다.</p>\n<h1 id=\"object-클래스의-clone-규약\">Object 클래스의 clone 규약</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates and returns a copy of this object.  The precise meaning</span></span><br><span class=\"line\"><span class=\"comment\"> * of \"copy\" may depend on the class of the object. The general</span></span><br><span class=\"line\"><span class=\"comment\"> * intent is that, for any object &#123;<span class=\"doctag\">@code</span> x&#125;, the expression:</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * will be true, and that the expression:</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * will be &#123;<span class=\"doctag\">@code</span> true&#125;, but these are not absolute requirements.</span></span><br><span class=\"line\"><span class=\"comment\"> * While it is typically the case that:</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * will be &#123;<span class=\"doctag\">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * By convention, the returned object should be obtained by calling</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> super.clone&#125;.  If a class and all of its superclasses (except</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> Object&#125;) obey this convention, it will be the case that</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> x.clone().getClass() == x.getClass()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * By convention, the object returned by this method should be independent</span></span><br><span class=\"line\"><span class=\"comment\"> * of this object (which is being cloned).  To achieve this independence,</span></span><br><span class=\"line\"><span class=\"comment\"> * it may be necessary to modify one or more fields of the object returned</span></span><br><span class=\"line\"><span class=\"comment\"> * by &#123;<span class=\"doctag\">@code</span> super.clone&#125; before returning it.  Typically, this means</span></span><br><span class=\"line\"><span class=\"comment\"> * copying any mutable objects that comprise the internal \"deep structure\"</span></span><br><span class=\"line\"><span class=\"comment\"> * of the object being cloned and replacing the references to these</span></span><br><span class=\"line\"><span class=\"comment\"> * objects with references to the copies.  If a class contains only</span></span><br><span class=\"line\"><span class=\"comment\"> * primitive fields or references to immutable objects, then it is usually</span></span><br><span class=\"line\"><span class=\"comment\"> * the case that no fields in the object returned by &#123;<span class=\"doctag\">@code</span> super.clone&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * need to be modified.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * The method &#123;<span class=\"doctag\">@code</span> clone&#125; for class &#123;<span class=\"doctag\">@code</span> Object&#125; performs a</span></span><br><span class=\"line\"><span class=\"comment\"> * specific cloning operation. First, if the class of this object does</span></span><br><span class=\"line\"><span class=\"comment\"> * not implement the interface &#123;<span class=\"doctag\">@code</span> Cloneable&#125;, then a</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> CloneNotSupportedException&#125; is thrown. Note that all arrays</span></span><br><span class=\"line\"><span class=\"comment\"> * are considered to implement the interface &#123;<span class=\"doctag\">@code</span> Cloneable&#125; and that</span></span><br><span class=\"line\"><span class=\"comment\"> * the return type of the &#123;<span class=\"doctag\">@code</span> clone&#125; method of an array type &#123;<span class=\"doctag\">@code</span> T[]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * is &#123;<span class=\"doctag\">@code</span> T[]&#125; where T is any reference or primitive type.</span></span><br><span class=\"line\"><span class=\"comment\"> * Otherwise, this method creates a new instance of the class of this</span></span><br><span class=\"line\"><span class=\"comment\"> * object and initializes all its fields with exactly the contents of</span></span><br><span class=\"line\"><span class=\"comment\"> * the corresponding fields of this object, as if by assignment; the</span></span><br><span class=\"line\"><span class=\"comment\"> * contents of the fields are not themselves cloned. Thus, this method</span></span><br><span class=\"line\"><span class=\"comment\"> * performs a \"shallow copy\" of this object, not a \"deep copy\" operation.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * The class &#123;<span class=\"doctag\">@code</span> Object&#125; does not itself implement the interface</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> Cloneable&#125;, so calling the &#123;<span class=\"doctag\">@code</span> clone&#125; method on an object</span></span><br><span class=\"line\"><span class=\"comment\"> * whose class is &#123;<span class=\"doctag\">@code</span> Object&#125; will result in throwing an</span></span><br><span class=\"line\"><span class=\"comment\"> * exception at run time.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span>     a clone of this instance.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span>  CloneNotSupportedException  if the object's class does not</span></span><br><span class=\"line\"><span class=\"comment\"> *               support the &#123;<span class=\"doctag\">@code</span> Cloneable&#125; interface. Subclasses</span></span><br><span class=\"line\"><span class=\"comment\"> *               that override the &#123;<span class=\"doctag\">@code</span> clone&#125; method can also</span></span><br><span class=\"line\"><span class=\"comment\"> *               throw this exception to indicate that an instance cannot</span></span><br><span class=\"line\"><span class=\"comment\"> *               be cloned.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> java.lang.Cloneable</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@HotSpotIntrinsicCandidate</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">native</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p>\n<p>Object에 명시된 clone 규약이 주석으로 쓰여져 있다.</p>\n<ul>\n<li>x.clone() != x은 참이다.<br>\n복사한 객체와 원본 객체는 서로 다른 객체이다.</li>\n<li>x.clone() .getClass() == x.getClass()은 일반적으로 참이다.\n하지만 반드시 만족해야 하는 것은 아니다.</li>\n<li>x.clone.equals(x) 은 참이다.<br>\n복사한 객체와 원본객체는 논리적 동치성이 같다.</li>\n<li>x.clone().getClass() == x.getClass()은 참이다.<br>\n관례상, 이 방법으로 반환된 객체는 독립성이 있어야 한다.<br>\n이를 만족하려면 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.</li>\n<li>Cloneable을 구현하지 않은 클래스의 경우, CloneNotSupportedException이 throw된다.</li>\n<li>모든 Array는 Cloneable을 구현하도록 고려되었다. clone 메서드는 T[]를 리턴하도록 설계</li>\n<li>T는 기본타입 또는 참조타입으로 설계</li>\n<li>기본적으로 Object.clone은 clone대상 클래스에 대해 새로운 객체를 new로 생성</li>\n<li>모든 필드들에 대해 초기화를 진행</li>\n<li>하지만 필드에 대한 객체를 다시 생성하지 않는 Shallow copy 방식으로 수행한다 (deep copy아님)</li>\n<li>클래스에 대한 복제본을 원하지 않는 경우 clone메서드를 재정의하여 CloneNotSupportedException을 throw하도록 함</li>\n</ul>\n<h1 id=\"clone-메서드-재정의-시-주의할-점\">clone 메서드 재정의 시, 주의할 점</h1>\n<h2 id=\"기본적인-clone메서드-재정의\">기본적인 clone메서드 재정의</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneNumber</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> PhoneNumber <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (PhoneNumber) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(ClassNotSupportedException e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//아무처리를 하지 않거나, RuntimeException으로 감싸는 것이 사용하기 편하다.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>super.clone()을 실행하면 PhoneNumber에 대한 완벽한 복제가 이루어진다.</li>\n<li>super.clone()의 리턴 타입은 Object이지만, 자바의 공변 반환타이핑 기능을 통해 PhoneNumber 타입으로 캐스팅하여 리턴하는 것이 가능하다.<br>\n(추천하는 기능)</li>\n<li>try-catch 부분으로 감싼것은 super.clone() 메서드에서 ClassNotSupportedException이라는 checked exception을 리턴하기 떄문에 처리 해주었다.\n<ul>\n<li>하지만 PhoneNumber가 Cloneable을 구현하기 떄문에 절대 실패하지 않는다.<br>\n따라서 이부분은 RuntimeException으로 처리하거나, 아무것도 설정하지 않아야 한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"가변-상태를-갖는-필드에-대한-복제\">가변 상태를 갖는 필드에 대한 복제</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Object[] elements;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Stack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elements = <span class=\"keyword\">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(Object o)</span> </span>&#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Stack <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Stack result = (Stack) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">      result.elements = </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이 클래스가 단순히 clone메서드를 이용해 super.clone()만 실행하게 된다면,<br>\nnew Stack()을 통해 새로운 객체가 생성되고 필드모두 원본 객체와 동일하게 초기화가 될 것이다.<br>\n하지만, 위에서 얘기한 Object의 clone 기본규약에는 Deep copy가 아닌 Shallow Copy를 이용해 초기화를 진행한다고 적혀있다.<br>\n따라서 배열과 같은 가변필드는 원본 필드와 객체를 공유하게 된다.</p>\n<p>Clone메서드는 사실상 생성자와 같은 효과를 낸다.<br>\n즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.<br>\n그렇기 때문에 제대로 복제하기 위해서는, elements라는 배열을 똑같이 복사해서 만들어줘야 한다.</p>\n<h2 id=\"배열-복사\">배열 복사</h2>\n<p>배열을 복제하는 방법 중 가장 권장하는 방법은\narray.clone()을 이용해 복사하는 방법이다.<br>\n사실, 배열은 clone기능을 가장 제대로 사용하는 유일한 예이다.</p>\n<p>하지만, array 필드가 final이 적용되어 있다면 array.clone()을 통한 초기화는 할 수 없다. (final이기 떄문에 객체 생성 이후 초기화 불가)<br>\n<strong>Cloneable 아키텍처는 가변객체를 참조하는 필드는 final로 선언하라 라는 일반 용법과 충돌한다.</strong><br>\n그래서 복제 할 수 있는 클래스를 만들기 위해 일부 필드에서 final 한정자를 제거해야 할 수도 있다.</p>\n<h2 id=\"stack-overflow-문제\">Stack overflow 문제</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span>  </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Entry[] buckets = ...;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object key;</span><br><span class=\"line\">    Object value;</span><br><span class=\"line\">    Entry next;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(Object key, Object value, Entry next) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> HashTable <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      HashTable result = (HashTable) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">      result.buckets = buckets.clone();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Assertion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>복제본은 자신만의 버킷 배열은 갖지만, 배열내의 Entry는 원본과 같은 연결리스트를 참조하여, 불변성이 꺠지게 된다.</p>\n<p>그래서 HashTable.Entry 클래스는 내부적으로 deep copy를 지원하도록 보강되었다. 연결리스트에 대한 next를 복제할 때 재귀적으로 clone을 호출하도록 되어있는데, 재귀 호출 떄문에 연결리스트의 size만큼 스택프레임을 소비하여, 리스트가 길면 stackoverflow에러를 발생시킬 위험이 있다.<br>\n이 문제를 해결하기 위해서는 재귀 호출을 통한 deepcopy대신 반복자를 써서 순회하는 방법으로 수정해야 한다.</p>\n<h2 id=\"안전하지만-느린-copy\">안전하지만 느린 copy</h2>\n<p>HashTable을 예로 들면, buckets필드를 새로운 배열로 초기화 한다음 원본테이블의 있는 버킷의 내용을 put(key, value) 메서드를 호출해<br>\n새로 버킷을 만드는 방법이 있다.<br>\n이 방법은 안전하긴 하지만, low level에서 작동하는 copy보다는 느리다.</p>\n<h2 id=\"생성자-내에서는-재정의-될-수-있는-메서드를-호출-하지-말자\">생성자 내에서는 재정의 될 수 있는 메서드를 호출 하지 말자</h2>\n<p>만약 clone이 하위 클래스에서 재정의한 메서드를 호출하면, 하위 클래스는 복사과정에서 자신의 상태를 교정할 기회를 잃게되어<br>\n원본과 복제본의 상태가 달라질 수 있다.</p>\n<h2 id=\"classnotsupportedexception\">ClassNotSupportedException</h2>\n<p>Object의 clone메서드는 CloneNotSupportedException을 던진다고 선언했지만 재정의한 메서드는 그렇지 않다.<br>\npublic인 clone 메서드에서는 throws절을 없애던가, RuntimeException으로 throws 해야한다.<br>\n그렇지 않으면 clone 메서드를 호출 할 떄마다, 예외처리를 해야 해서 사용하기가 불편하다.</p>\n<p>하위 클래스에서 Clone을 방지하기 위해 동작하지 않게 만들수도 있다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CloneNotSupportedException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"스레드-안전성을-고려한다면-적절히-동기화해야-한다\">스레드 안전성을 고려한다면 적절히 동기화해야 한다.</h2>\n<p>스레드 안정성을 고려한다면 clone 메서드에 대해 적절히 동기화 처리 해야 한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Object result = <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"복사-생성자와-복사-팩터리-메서드\">복사 생성자와 복사 팩터리 메서드</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Yum</span><span class=\"params\">(Yum yum)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Yum <span class=\"title\">newInstance</span><span class=\"params\">(Yum yum)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>복사 생성자와 복사 팩터리 메서드는 Cloneable/clone 방식보다 나은 면이 많다.</p>\n<ul>\n<li>언어 모순적이고 위험한 객체 생성 메커니즘을 사용하지 않는다. (super.clone())</li>\n<li>clone 규약에 기대지 않는다.</li>\n<li>정상적인 final필드 용법과도 충돌하지 않는다.</li>\n<li>불필요한 check exception 처리가 필요없다.</li>\n<li>형변환도 필요없다.</li>\n<li>복사 생성자와 복사 팩터리는 인터페이스 타입의 인스턴스를 인수로 받을 수 있다.</li>\n</ul>\n<h1 id=\"deep-copy-vs-shallow-copy\">Deep copy vs Shallow copy</h1>\n<p><a href=\"http://localhost:4000/2019/01/13/java-object-copy\" target=\"_blank\" rel=\"noopener\">Shallow Copy와 Deep Copy</a> - 이 포스팅을 참고하자</p>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 13. clone 재정의는 주의해서 진행하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>Cloneable은 복제해도 되는 인터페이스 임을 명시하는 용도의 믹스인 인터페이스이다.<br>\n하지만 아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라는데 있다. 그래서 Cloneable을 구현하는 것만으로는 외부에서 clone 메서드를 호출 할 수 없다.</p>\n<h1>Cloneable 인터페이스는 무슨일을 할까?</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to</span></span><br><span class=\"line\"><span class=\"comment\"> * indicate to the &#123;<span class=\"doctag\">@link</span> java.lang.Object#clone()&#125; method that it</span></span><br><span class=\"line\"><span class=\"comment\"> * is legal for that method to make a</span></span><br><span class=\"line\"><span class=\"comment\"> * field-for-field copy of instances of that class.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Invoking Object's clone method on an instance that does not implement the</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * By convention, classes that implement this interface should override</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> Object.clone&#125; (which is protected) with a public method.</span></span><br><span class=\"line\"><span class=\"comment\"> * See &#123;<span class=\"doctag\">@link</span> java.lang.Object#clone()&#125; for details on overriding this</span></span><br><span class=\"line\"><span class=\"comment\"> * method.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &#123;<span class=\"doctag\">@code</span> clone&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\"> * Therefore, it is not possible to clone an object merely by virtue of the</span></span><br><span class=\"line\"><span class=\"comment\"> * fact that it implements this interface.  Even if the clone method is invoked</span></span><br><span class=\"line\"><span class=\"comment\"> * reflectively, there is no guarantee that it will succeed.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>  unascribed</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>     java.lang.CloneNotSupportedException</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>     java.lang.Object#clone()</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span>   1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>자바의 Cloneable 인터페이스를 보면 아무런 메서드도 없다.<br>\n아무것도 없지만, 사실은 Object의 clone메서드의 동작방식을 결정한다.<br>\nCloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면, 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면, <code>ClassNotSupportedException</code>을 던진다.</p>\n<h1>Object 클래스의 clone 규약</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates and returns a copy of this object.  The precise meaning</span></span><br><span class=\"line\"><span class=\"comment\"> * of \"copy\" may depend on the class of the object. The general</span></span><br><span class=\"line\"><span class=\"comment\"> * intent is that, for any object &#123;<span class=\"doctag\">@code</span> x&#125;, the expression:</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * will be true, and that the expression:</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * will be &#123;<span class=\"doctag\">@code</span> true&#125;, but these are not absolute requirements.</span></span><br><span class=\"line\"><span class=\"comment\"> * While it is typically the case that:</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * will be &#123;<span class=\"doctag\">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * By convention, the returned object should be obtained by calling</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> super.clone&#125;.  If a class and all of its superclasses (except</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> Object&#125;) obey this convention, it will be the case that</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> x.clone().getClass() == x.getClass()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * By convention, the object returned by this method should be independent</span></span><br><span class=\"line\"><span class=\"comment\"> * of this object (which is being cloned).  To achieve this independence,</span></span><br><span class=\"line\"><span class=\"comment\"> * it may be necessary to modify one or more fields of the object returned</span></span><br><span class=\"line\"><span class=\"comment\"> * by &#123;<span class=\"doctag\">@code</span> super.clone&#125; before returning it.  Typically, this means</span></span><br><span class=\"line\"><span class=\"comment\"> * copying any mutable objects that comprise the internal \"deep structure\"</span></span><br><span class=\"line\"><span class=\"comment\"> * of the object being cloned and replacing the references to these</span></span><br><span class=\"line\"><span class=\"comment\"> * objects with references to the copies.  If a class contains only</span></span><br><span class=\"line\"><span class=\"comment\"> * primitive fields or references to immutable objects, then it is usually</span></span><br><span class=\"line\"><span class=\"comment\"> * the case that no fields in the object returned by &#123;<span class=\"doctag\">@code</span> super.clone&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * need to be modified.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * The method &#123;<span class=\"doctag\">@code</span> clone&#125; for class &#123;<span class=\"doctag\">@code</span> Object&#125; performs a</span></span><br><span class=\"line\"><span class=\"comment\"> * specific cloning operation. First, if the class of this object does</span></span><br><span class=\"line\"><span class=\"comment\"> * not implement the interface &#123;<span class=\"doctag\">@code</span> Cloneable&#125;, then a</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> CloneNotSupportedException&#125; is thrown. Note that all arrays</span></span><br><span class=\"line\"><span class=\"comment\"> * are considered to implement the interface &#123;<span class=\"doctag\">@code</span> Cloneable&#125; and that</span></span><br><span class=\"line\"><span class=\"comment\"> * the return type of the &#123;<span class=\"doctag\">@code</span> clone&#125; method of an array type &#123;<span class=\"doctag\">@code</span> T[]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * is &#123;<span class=\"doctag\">@code</span> T[]&#125; where T is any reference or primitive type.</span></span><br><span class=\"line\"><span class=\"comment\"> * Otherwise, this method creates a new instance of the class of this</span></span><br><span class=\"line\"><span class=\"comment\"> * object and initializes all its fields with exactly the contents of</span></span><br><span class=\"line\"><span class=\"comment\"> * the corresponding fields of this object, as if by assignment; the</span></span><br><span class=\"line\"><span class=\"comment\"> * contents of the fields are not themselves cloned. Thus, this method</span></span><br><span class=\"line\"><span class=\"comment\"> * performs a \"shallow copy\" of this object, not a \"deep copy\" operation.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * The class &#123;<span class=\"doctag\">@code</span> Object&#125; does not itself implement the interface</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> Cloneable&#125;, so calling the &#123;<span class=\"doctag\">@code</span> clone&#125; method on an object</span></span><br><span class=\"line\"><span class=\"comment\"> * whose class is &#123;<span class=\"doctag\">@code</span> Object&#125; will result in throwing an</span></span><br><span class=\"line\"><span class=\"comment\"> * exception at run time.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span>     a clone of this instance.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span>  CloneNotSupportedException  if the object's class does not</span></span><br><span class=\"line\"><span class=\"comment\"> *               support the &#123;<span class=\"doctag\">@code</span> Cloneable&#125; interface. Subclasses</span></span><br><span class=\"line\"><span class=\"comment\"> *               that override the &#123;<span class=\"doctag\">@code</span> clone&#125; method can also</span></span><br><span class=\"line\"><span class=\"comment\"> *               throw this exception to indicate that an instance cannot</span></span><br><span class=\"line\"><span class=\"comment\"> *               be cloned.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> java.lang.Cloneable</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@HotSpotIntrinsicCandidate</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">native</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p>\n<p>Object에 명시된 clone 규약이 주석으로 쓰여져 있다.</p>\n<ul>\n<li>x.clone() != x은 참이다.<br>\n복사한 객체와 원본 객체는 서로 다른 객체이다.</li>\n<li>x.clone() .getClass() == x.getClass()은 일반적으로 참이다.\n하지만 반드시 만족해야 하는 것은 아니다.</li>\n<li>x.clone.equals(x) 은 참이다.<br>\n복사한 객체와 원본객체는 논리적 동치성이 같다.</li>\n<li>x.clone().getClass() == x.getClass()은 참이다.<br>\n관례상, 이 방법으로 반환된 객체는 독립성이 있어야 한다.<br>\n이를 만족하려면 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.</li>\n<li>Cloneable을 구현하지 않은 클래스의 경우, CloneNotSupportedException이 throw된다.</li>\n<li>모든 Array는 Cloneable을 구현하도록 고려되었다. clone 메서드는 T[]를 리턴하도록 설계</li>\n<li>T는 기본타입 또는 참조타입으로 설계</li>\n<li>기본적으로 Object.clone은 clone대상 클래스에 대해 새로운 객체를 new로 생성</li>\n<li>모든 필드들에 대해 초기화를 진행</li>\n<li>하지만 필드에 대한 객체를 다시 생성하지 않는 Shallow copy 방식으로 수행한다 (deep copy아님)</li>\n<li>클래스에 대한 복제본을 원하지 않는 경우 clone메서드를 재정의하여 CloneNotSupportedException을 throw하도록 함</li>\n</ul>\n<h1>clone 메서드 재정의 시, 주의할 점</h1>\n<h2>기본적인 clone메서드 재정의</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneNumber</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> PhoneNumber <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (PhoneNumber) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(ClassNotSupportedException e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//아무처리를 하지 않거나, RuntimeException으로 감싸는 것이 사용하기 편하다.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>super.clone()을 실행하면 PhoneNumber에 대한 완벽한 복제가 이루어진다.</li>\n<li>super.clone()의 리턴 타입은 Object이지만, 자바의 공변 반환타이핑 기능을 통해 PhoneNumber 타입으로 캐스팅하여 리턴하는 것이 가능하다.<br>\n(추천하는 기능)</li>\n<li>try-catch 부분으로 감싼것은 super.clone() 메서드에서 ClassNotSupportedException이라는 checked exception을 리턴하기 떄문에 처리 해주었다.\n<ul>\n<li>하지만 PhoneNumber가 Cloneable을 구현하기 떄문에 절대 실패하지 않는다.<br>\n따라서 이부분은 RuntimeException으로 처리하거나, 아무것도 설정하지 않아야 한다.</li>\n</ul>\n</li>\n</ul>\n<h2>가변 상태를 갖는 필드에 대한 복제</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Object[] elements;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Stack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elements = <span class=\"keyword\">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(Object o)</span> </span>&#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Stack <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Stack result = (Stack) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">      result.elements = </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이 클래스가 단순히 clone메서드를 이용해 super.clone()만 실행하게 된다면,<br>\nnew Stack()을 통해 새로운 객체가 생성되고 필드모두 원본 객체와 동일하게 초기화가 될 것이다.<br>\n하지만, 위에서 얘기한 Object의 clone 기본규약에는 Deep copy가 아닌 Shallow Copy를 이용해 초기화를 진행한다고 적혀있다.<br>\n따라서 배열과 같은 가변필드는 원본 필드와 객체를 공유하게 된다.</p>\n<p>Clone메서드는 사실상 생성자와 같은 효과를 낸다.<br>\n즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.<br>\n그렇기 때문에 제대로 복제하기 위해서는, elements라는 배열을 똑같이 복사해서 만들어줘야 한다.</p>\n<h2>배열 복사</h2>\n<p>배열을 복제하는 방법 중 가장 권장하는 방법은\narray.clone()을 이용해 복사하는 방법이다.<br>\n사실, 배열은 clone기능을 가장 제대로 사용하는 유일한 예이다.</p>\n<p>하지만, array 필드가 final이 적용되어 있다면 array.clone()을 통한 초기화는 할 수 없다. (final이기 떄문에 객체 생성 이후 초기화 불가)<br>\n<strong>Cloneable 아키텍처는 가변객체를 참조하는 필드는 final로 선언하라 라는 일반 용법과 충돌한다.</strong><br>\n그래서 복제 할 수 있는 클래스를 만들기 위해 일부 필드에서 final 한정자를 제거해야 할 수도 있다.</p>\n<h2>Stack overflow 문제</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span>  </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Entry[] buckets = ...;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object key;</span><br><span class=\"line\">    Object value;</span><br><span class=\"line\">    Entry next;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(Object key, Object value, Entry next) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> HashTable <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      HashTable result = (HashTable) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">      result.buckets = buckets.clone();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Assertion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>복제본은 자신만의 버킷 배열은 갖지만, 배열내의 Entry는 원본과 같은 연결리스트를 참조하여, 불변성이 꺠지게 된다.</p>\n<p>그래서 HashTable.Entry 클래스는 내부적으로 deep copy를 지원하도록 보강되었다. 연결리스트에 대한 next를 복제할 때 재귀적으로 clone을 호출하도록 되어있는데, 재귀 호출 떄문에 연결리스트의 size만큼 스택프레임을 소비하여, 리스트가 길면 stackoverflow에러를 발생시킬 위험이 있다.<br>\n이 문제를 해결하기 위해서는 재귀 호출을 통한 deepcopy대신 반복자를 써서 순회하는 방법으로 수정해야 한다.</p>\n<h2>안전하지만 느린 copy</h2>\n<p>HashTable을 예로 들면, buckets필드를 새로운 배열로 초기화 한다음 원본테이블의 있는 버킷의 내용을 put(key, value) 메서드를 호출해<br>\n새로 버킷을 만드는 방법이 있다.<br>\n이 방법은 안전하긴 하지만, low level에서 작동하는 copy보다는 느리다.</p>\n<h2>생성자 내에서는 재정의 될 수 있는 메서드를 호출 하지 말자</h2>\n<p>만약 clone이 하위 클래스에서 재정의한 메서드를 호출하면, 하위 클래스는 복사과정에서 자신의 상태를 교정할 기회를 잃게되어<br>\n원본과 복제본의 상태가 달라질 수 있다.</p>\n<h2>ClassNotSupportedException</h2>\n<p>Object의 clone메서드는 CloneNotSupportedException을 던진다고 선언했지만 재정의한 메서드는 그렇지 않다.<br>\npublic인 clone 메서드에서는 throws절을 없애던가, RuntimeException으로 throws 해야한다.<br>\n그렇지 않으면 clone 메서드를 호출 할 떄마다, 예외처리를 해야 해서 사용하기가 불편하다.</p>\n<p>하위 클래스에서 Clone을 방지하기 위해 동작하지 않게 만들수도 있다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CloneNotSupportedException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>스레드 안전성을 고려한다면 적절히 동기화해야 한다.</h2>\n<p>스레드 안정성을 고려한다면 clone 메서드에 대해 적절히 동기화 처리 해야 한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Object result = <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>복사 생성자와 복사 팩터리 메서드</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Yum</span><span class=\"params\">(Yum yum)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Yum <span class=\"title\">newInstance</span><span class=\"params\">(Yum yum)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>복사 생성자와 복사 팩터리 메서드는 Cloneable/clone 방식보다 나은 면이 많다.</p>\n<ul>\n<li>언어 모순적이고 위험한 객체 생성 메커니즘을 사용하지 않는다. (super.clone())</li>\n<li>clone 규약에 기대지 않는다.</li>\n<li>정상적인 final필드 용법과도 충돌하지 않는다.</li>\n<li>불필요한 check exception 처리가 필요없다.</li>\n<li>형변환도 필요없다.</li>\n<li>복사 생성자와 복사 팩터리는 인터페이스 타입의 인스턴스를 인수로 받을 수 있다.</li>\n</ul>\n<h1>Deep copy vs Shallow copy</h1>\n<p><a href=\"http://localhost:4000/2019/01/13/java-object-copy\" target=\"_blank\" rel=\"noopener\">Shallow Copy와 Deep Copy</a> - 이 포스팅을 참고하자</p>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 13. clone 재정의는 주의해서 진행하라</li>\n</ul>\n"},{"title":"Item 15. 클래스와 멤버의 접근 권한을 최소화하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item15","typora-copy-images-to":"effective-java-item15","date":"2019-01-19T12:54:32.000Z","subtitle":null,"header-img":null,"_content":"# 서론\n잘 설계된 컴포넌트는 클래스는 모든 내부구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리 해놨다.  \n오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.  \n정보은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.\n\n# 정보 은닉의 장점\n## 시스템 개발 속도를 높인다.\n여러가지 컴포넌트를 병렬로 개발할 수 있기 때문이다.\n예를 들어, 회원탈퇴 기능을 개발한다고 해보자\n\n```java\npublic interface WithdrawalService {\n  void withdrawalMember(Member member);\n  List<Member> getMembers();\n  WithdrawalProcessType getProcessType(); \n  default startProcess() {\n    List<Member> members = getMembers();\n    members.stream().foreach(this::withdrawalMember);\n  }\n}\n```\n이러한 회원탈퇴 로직에 대한 인터페이스를 제공하고,\n일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴등의 로직이 상이하여 Service를 별도로 구현한다고하는 경우 Interface 스펙에 맞추어 여러 개발자가 개발할 수 있기 때문이다.\n\n## 시스템 관리 비용을 낮춘다.\n각 컴포넌트를 빨리 파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.  \n위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 로직에 변경이 생긴 경우  \n`WithdrawalService` interface를 구현한 비회원 탈퇴 서비스를 만들면 되기 때문이다.\n\n## 성능 최적화에 도움을 준다.\n완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있다.  \n위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 중 비회원 탈퇴에 대해 처리대상이 많아 startProcess 메서드를 확장하여 내부적으로 withdrawalMember 메서드를 사용하지 않고 회원 리스트에 대해 쿼리를 이용해 Insert~ Select로 한방에 처리 할 수도 있다.\n\n## 소프트웨어 재사용성을 높인다.\n외부에 의존하지 않고, 독자적으로 동작할 수 있는 컴포넌트라면, 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크다.  \n예를들면 알림톡 서버 API를 호출 할 수 있는 인터페이스가 있는 경우 그 인터페이스를 그대로 사용할 수 있다.\n\n\n## 큰 시스템을 제작하는 난이도를 낮춰준다.\n시스템 전체가 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있다.  \n쉬운 예로 Mockito를 이용한 TestCase 작성이다.\n\n```java\n\n@RunWith(MockitoJUnitRunner.class)\npublic class WithdrawalTest {\n\n    private class TestWithdrawalService implements WithdrawalService {\n\n        @Override\n        public String withdrawalMember(Member member) {\n            return null;\n        }\n\n        @Override\n        public List<Member> getMembers() {\n            return null;\n        }\n    }\n\n\n    @Mock\n    private TestWithdrawalService testWithdrawalService;\n\n    @Before\n    public void initMocks(){\n        MockitoAnnotations.initMocks(this);\n    }\n\n    @Test\n    public void 회원탈퇴_테스트() {\n\n        //given\n        doReturn(Arrays.asList(new Member(\"Carrey\"))).when(testWithdrawalService).getMembers();\n        doCallRealMethod().when(testWithdrawalService).startProcess();\n        //when\n        String result = testWithdrawalService.startProcess();\n        //then\n        assertThat(result, is(\"FINISHED\"));\n    }\n}\n```\n\n# Java의 접근제한자\n* private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. \n* package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 할 수 있다.\n* protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.\n* public: 모든 곳에서 접근 할 수 있다.\n\n# 모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.\n소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다.\n\n## 클래스 레벨 접근제한자\n톱레벨 수준(파일명 = 클래스명)이 같은 수준에서의 접근제한자는 public과 package-private만 사용 할 수 있다.\n* public으로 선언하는 경우 공개 API로 사용 - 하위호환을 평생 신경써야 한다.\n* package-private로 사용하는 경우 해당 패키지 안에서만 사용 가능 - 다음 릴리즈에 내부로직을 변경해도 괜찮다.\n\n## 이너클래스 사용하기\n* 한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 사용하는 클래스 안에 private static으로 중첩해보자\n* public일 필요가 없는 클래스의 접근 수준을 package-private로 해보자 - 다른 패키지에서 사용하지 못하게 막아야 한다.\n\n```java\npublic class Food {\n  private String name;\n  private int price;\n  private List<Shop> shops;\n}\n```\n\n```java\npublic class Shop {\n  private String name;\n  private String owner;\n}\n```\n\n```java\npublic class Food {\n  private String name;\n  private int price;\n  private List<Shop> shops;\n\n  private static class Shop {\n    private String name;\n    private String owner;\n  }\n}\n```\n\n## private과 package-private은 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다.\n* 일단 처음에는 모든 멤버는 private으로 만들어야 한다.\n* 같은 패키지에서 접근해야 하는 멤버가 있는 경우 package-private로 변경\n* 단, Serialize를 구현한 클래스의 경우 공개 API에 의도치 않게 공개 될 수도 있다.\n* 필드의 접근 권한을 package-private에서 protected로 바꾸는 순간 필드에 접근 할 수 있는 대상 범위가 늘어나니 주의해야 한다.\n\n## 메서드를 재정의 할 경우에는 접근 수준을 상위 클래스에서보다 좁게 설정 할 수 없다.\n* 상위 클래스에서 접근제한자가 protected인데 하위클래스에서 갑자기 package-private이나 private로 변경할 수 없다.\n* 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환원칙)을 위반하기 때문이다.\n* 단 인터페이스를 구현하는 경우에는 클래스의 메서드는 모두 public으로 해야 한다. \n\n## 코드를 테스트 하려는 목적으로 클래스, 인터페이스를 접근 범위를 넓히는 것을 주의하라\npublic 클래스의 private -> package-private으로 바꾸는거는 괜찮다. 하지만 그이상의 경우 공개 API에 문제가 될 수 있다.\n\n# public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.\n필드가 가변객체를 참조하거나(Collections이나 배열), final이 아닌 인스턴스 필드를 public으로 선언하면 **불변식을 보장할 수 없다.**  \npublic 가변 필드를 갖는 클래스는 일반적으로 thread safe 하지않다.  \n내부 구현을 바꾸고 싶어도 public 필드를 없애는 방식으로는 리팩터링이 불가하다.\n\n하지만 상수라면 관례대로 public static final 필드로 공개해도 좋다.  \n필드 명 네이밍은 관례 상 `대문자 + _(언더바)`로 구성한다.\n그리고 반드시 불변 객체를 참조하도록 한다.  \n불변성이 깨지는 순간 어마무시한 일이 일어난다.\n\n# 클래스에서 public static final 배열 필드를 두지말아라\n```java\npublic static final Thing[] VALUES = {...};\n```\n이런 경우 VALUES에 대한 참조를 변경할 수는 없지만, 배열내의 내용을 변경하는 것은 가능하다.\n\n## 해결책1. Thing 배열을 private로 만들고 public 불변 리스트를 추가한다. \n```java\nprivate static final Thing[] PRIVATE_VALUES = {...};\npublic static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));\n``` \n\n## 해결책2. Thing 배열을 private로 만들고 public 메서드를 추가한다.\n```java\nprivate static final Thing[] PRIVATE_VALUES = {...};\npublic static final Thing[] values() {\n  return PRIVATE_VALUES.clone(); //방어적 복사본\n}\n```\n\n# Java 9에 추가된 Modules (Project Jigsaw)\nJava9 부터는 Module시스템이라는 개념이 도입 되었다.  \n\n패키지는 클래스의 묶음인 것 처럼, 모듈(Modules)은 패키지의 묶음이다.\n모듈은 관례 상, 자신이 속하는 패키지 중 공개(export) 할 것을 선언한다.  \n관례상 **module-info.java** 에 선언한다.\n모듈을 정의하기 위해 3가지 정보를 작성해야 한다.\n1. module 명 - module 명칭\n2. 공개할 package (export) \n- 공개한 package의 public type에 접근제한자만 외부에서 접근할 수 있다.\n- 만약 export에 적지 않은 패키지의 클래스 중 public 접근제한자가 있어도 접근을 할 수 없다.\n3. module내 package의 클래스를 사용하기 위해 종속되는 package (require)\n- 다른 모듈의 대한 require를 작성하면 다른 모듈에서 export하는 클래스의 public type에 접근이 가능하다\n\n## Java 8에서 접근 제한자\n* private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. \n* package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.\n* protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.\n* public: 모든 곳에서 접근할 수 있다.\n\n## Java 9부터의 접근 제한자\n* private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. \n* package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.\n* protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.\n* 모듈 내부의 public: 모듈 내부의 모든 곳에서 접근할 수 있다.\n* required의 public: 모듈에 종속하는 모듈의 모든 패키지 내의 클래스에 접근할 수 있다.\n* export public: module-info.java에서 제공하는 모든 public에 접근할 수 있다.\n\n# 참고 \n* Effective Java 3rd Edition - Item 15. 클래스와 멤버의 접근 권한을 최소화하라\n* https://infoscis.github.io/2017/03/24/First-steps-with-java9-and-jigsaw-part-1/","source":"_posts/effective-java-item15.md","raw":"---\ntitle: Item 15. 클래스와 멤버의 접근 권한을 최소화하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item15\ntypora-copy-images-to: effective-java-item15\ndate: 2019-01-19 21:54:32\nsubtitle:\nheader-img:\n---\n# 서론\n잘 설계된 컴포넌트는 클래스는 모든 내부구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리 해놨다.  \n오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.  \n정보은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.\n\n# 정보 은닉의 장점\n## 시스템 개발 속도를 높인다.\n여러가지 컴포넌트를 병렬로 개발할 수 있기 때문이다.\n예를 들어, 회원탈퇴 기능을 개발한다고 해보자\n\n```java\npublic interface WithdrawalService {\n  void withdrawalMember(Member member);\n  List<Member> getMembers();\n  WithdrawalProcessType getProcessType(); \n  default startProcess() {\n    List<Member> members = getMembers();\n    members.stream().foreach(this::withdrawalMember);\n  }\n}\n```\n이러한 회원탈퇴 로직에 대한 인터페이스를 제공하고,\n일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴등의 로직이 상이하여 Service를 별도로 구현한다고하는 경우 Interface 스펙에 맞추어 여러 개발자가 개발할 수 있기 때문이다.\n\n## 시스템 관리 비용을 낮춘다.\n각 컴포넌트를 빨리 파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.  \n위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 로직에 변경이 생긴 경우  \n`WithdrawalService` interface를 구현한 비회원 탈퇴 서비스를 만들면 되기 때문이다.\n\n## 성능 최적화에 도움을 준다.\n완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있다.  \n위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 중 비회원 탈퇴에 대해 처리대상이 많아 startProcess 메서드를 확장하여 내부적으로 withdrawalMember 메서드를 사용하지 않고 회원 리스트에 대해 쿼리를 이용해 Insert~ Select로 한방에 처리 할 수도 있다.\n\n## 소프트웨어 재사용성을 높인다.\n외부에 의존하지 않고, 독자적으로 동작할 수 있는 컴포넌트라면, 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크다.  \n예를들면 알림톡 서버 API를 호출 할 수 있는 인터페이스가 있는 경우 그 인터페이스를 그대로 사용할 수 있다.\n\n\n## 큰 시스템을 제작하는 난이도를 낮춰준다.\n시스템 전체가 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있다.  \n쉬운 예로 Mockito를 이용한 TestCase 작성이다.\n\n```java\n\n@RunWith(MockitoJUnitRunner.class)\npublic class WithdrawalTest {\n\n    private class TestWithdrawalService implements WithdrawalService {\n\n        @Override\n        public String withdrawalMember(Member member) {\n            return null;\n        }\n\n        @Override\n        public List<Member> getMembers() {\n            return null;\n        }\n    }\n\n\n    @Mock\n    private TestWithdrawalService testWithdrawalService;\n\n    @Before\n    public void initMocks(){\n        MockitoAnnotations.initMocks(this);\n    }\n\n    @Test\n    public void 회원탈퇴_테스트() {\n\n        //given\n        doReturn(Arrays.asList(new Member(\"Carrey\"))).when(testWithdrawalService).getMembers();\n        doCallRealMethod().when(testWithdrawalService).startProcess();\n        //when\n        String result = testWithdrawalService.startProcess();\n        //then\n        assertThat(result, is(\"FINISHED\"));\n    }\n}\n```\n\n# Java의 접근제한자\n* private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. \n* package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 할 수 있다.\n* protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.\n* public: 모든 곳에서 접근 할 수 있다.\n\n# 모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.\n소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다.\n\n## 클래스 레벨 접근제한자\n톱레벨 수준(파일명 = 클래스명)이 같은 수준에서의 접근제한자는 public과 package-private만 사용 할 수 있다.\n* public으로 선언하는 경우 공개 API로 사용 - 하위호환을 평생 신경써야 한다.\n* package-private로 사용하는 경우 해당 패키지 안에서만 사용 가능 - 다음 릴리즈에 내부로직을 변경해도 괜찮다.\n\n## 이너클래스 사용하기\n* 한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 사용하는 클래스 안에 private static으로 중첩해보자\n* public일 필요가 없는 클래스의 접근 수준을 package-private로 해보자 - 다른 패키지에서 사용하지 못하게 막아야 한다.\n\n```java\npublic class Food {\n  private String name;\n  private int price;\n  private List<Shop> shops;\n}\n```\n\n```java\npublic class Shop {\n  private String name;\n  private String owner;\n}\n```\n\n```java\npublic class Food {\n  private String name;\n  private int price;\n  private List<Shop> shops;\n\n  private static class Shop {\n    private String name;\n    private String owner;\n  }\n}\n```\n\n## private과 package-private은 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다.\n* 일단 처음에는 모든 멤버는 private으로 만들어야 한다.\n* 같은 패키지에서 접근해야 하는 멤버가 있는 경우 package-private로 변경\n* 단, Serialize를 구현한 클래스의 경우 공개 API에 의도치 않게 공개 될 수도 있다.\n* 필드의 접근 권한을 package-private에서 protected로 바꾸는 순간 필드에 접근 할 수 있는 대상 범위가 늘어나니 주의해야 한다.\n\n## 메서드를 재정의 할 경우에는 접근 수준을 상위 클래스에서보다 좁게 설정 할 수 없다.\n* 상위 클래스에서 접근제한자가 protected인데 하위클래스에서 갑자기 package-private이나 private로 변경할 수 없다.\n* 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환원칙)을 위반하기 때문이다.\n* 단 인터페이스를 구현하는 경우에는 클래스의 메서드는 모두 public으로 해야 한다. \n\n## 코드를 테스트 하려는 목적으로 클래스, 인터페이스를 접근 범위를 넓히는 것을 주의하라\npublic 클래스의 private -> package-private으로 바꾸는거는 괜찮다. 하지만 그이상의 경우 공개 API에 문제가 될 수 있다.\n\n# public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.\n필드가 가변객체를 참조하거나(Collections이나 배열), final이 아닌 인스턴스 필드를 public으로 선언하면 **불변식을 보장할 수 없다.**  \npublic 가변 필드를 갖는 클래스는 일반적으로 thread safe 하지않다.  \n내부 구현을 바꾸고 싶어도 public 필드를 없애는 방식으로는 리팩터링이 불가하다.\n\n하지만 상수라면 관례대로 public static final 필드로 공개해도 좋다.  \n필드 명 네이밍은 관례 상 `대문자 + _(언더바)`로 구성한다.\n그리고 반드시 불변 객체를 참조하도록 한다.  \n불변성이 깨지는 순간 어마무시한 일이 일어난다.\n\n# 클래스에서 public static final 배열 필드를 두지말아라\n```java\npublic static final Thing[] VALUES = {...};\n```\n이런 경우 VALUES에 대한 참조를 변경할 수는 없지만, 배열내의 내용을 변경하는 것은 가능하다.\n\n## 해결책1. Thing 배열을 private로 만들고 public 불변 리스트를 추가한다. \n```java\nprivate static final Thing[] PRIVATE_VALUES = {...};\npublic static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));\n``` \n\n## 해결책2. Thing 배열을 private로 만들고 public 메서드를 추가한다.\n```java\nprivate static final Thing[] PRIVATE_VALUES = {...};\npublic static final Thing[] values() {\n  return PRIVATE_VALUES.clone(); //방어적 복사본\n}\n```\n\n# Java 9에 추가된 Modules (Project Jigsaw)\nJava9 부터는 Module시스템이라는 개념이 도입 되었다.  \n\n패키지는 클래스의 묶음인 것 처럼, 모듈(Modules)은 패키지의 묶음이다.\n모듈은 관례 상, 자신이 속하는 패키지 중 공개(export) 할 것을 선언한다.  \n관례상 **module-info.java** 에 선언한다.\n모듈을 정의하기 위해 3가지 정보를 작성해야 한다.\n1. module 명 - module 명칭\n2. 공개할 package (export) \n- 공개한 package의 public type에 접근제한자만 외부에서 접근할 수 있다.\n- 만약 export에 적지 않은 패키지의 클래스 중 public 접근제한자가 있어도 접근을 할 수 없다.\n3. module내 package의 클래스를 사용하기 위해 종속되는 package (require)\n- 다른 모듈의 대한 require를 작성하면 다른 모듈에서 export하는 클래스의 public type에 접근이 가능하다\n\n## Java 8에서 접근 제한자\n* private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. \n* package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.\n* protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.\n* public: 모든 곳에서 접근할 수 있다.\n\n## Java 9부터의 접근 제한자\n* private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. \n* package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.\n* protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.\n* 모듈 내부의 public: 모듈 내부의 모든 곳에서 접근할 수 있다.\n* required의 public: 모듈에 종속하는 모듈의 모든 패키지 내의 클래스에 접근할 수 있다.\n* export public: module-info.java에서 제공하는 모든 public에 접근할 수 있다.\n\n# 참고 \n* Effective Java 3rd Edition - Item 15. 클래스와 멤버의 접근 권한을 최소화하라\n* https://infoscis.github.io/2017/03/24/First-steps-with-java9-and-jigsaw-part-1/","slug":"effective-java-item15","published":1,"updated":"2019-01-28T12:46:25.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv3s2003vcr1tjxvyf0m6","content":"<h1 id=\"서론\">서론</h1>\n<p>잘 설계된 컴포넌트는 클래스는 모든 내부구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리 해놨다.<br>\n오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.<br>\n정보은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.</p>\n<h1 id=\"정보-은닉의-장점\">정보 은닉의 장점</h1>\n<h2 id=\"시스템-개발-속도를-높인다\">시스템 개발 속도를 높인다.</h2>\n<p>여러가지 컴포넌트를 병렬로 개발할 수 있기 때문이다.\n예를 들어, 회원탈퇴 기능을 개발한다고 해보자</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WithdrawalService</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">withdrawalMember</span><span class=\"params\">(Member member)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">List&lt;Member&gt; <span class=\"title\">getMembers</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\">WithdrawalProcessType <span class=\"title\">getProcessType</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"title\">startProcess</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Member&gt; members = getMembers();</span><br><span class=\"line\">    members.stream().foreach(<span class=\"keyword\">this</span>::withdrawalMember);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이러한 회원탈퇴 로직에 대한 인터페이스를 제공하고,\n일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴등의 로직이 상이하여 Service를 별도로 구현한다고하는 경우 Interface 스펙에 맞추어 여러 개발자가 개발할 수 있기 때문이다.</p>\n<h2 id=\"시스템-관리-비용을-낮춘다\">시스템 관리 비용을 낮춘다.</h2>\n<p>각 컴포넌트를 빨리 파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.<br>\n위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 로직에 변경이 생긴 경우<br>\n<code>WithdrawalService</code> interface를 구현한 비회원 탈퇴 서비스를 만들면 되기 때문이다.</p>\n<h2 id=\"성능-최적화에-도움을-준다\">성능 최적화에 도움을 준다.</h2>\n<p>완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있다.<br>\n위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 중 비회원 탈퇴에 대해 처리대상이 많아 startProcess 메서드를 확장하여 내부적으로 withdrawalMember 메서드를 사용하지 않고 회원 리스트에 대해 쿼리를 이용해 Insert~ Select로 한방에 처리 할 수도 있다.</p>\n<h2 id=\"소프트웨어-재사용성을-높인다\">소프트웨어 재사용성을 높인다.</h2>\n<p>외부에 의존하지 않고, 독자적으로 동작할 수 있는 컴포넌트라면, 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크다.<br>\n예를들면 알림톡 서버 API를 호출 할 수 있는 인터페이스가 있는 경우 그 인터페이스를 그대로 사용할 수 있다.</p>\n<h2 id=\"큰-시스템을-제작하는-난이도를-낮춰준다\">큰 시스템을 제작하는 난이도를 낮춰준다.</h2>\n<p>시스템 전체가 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있다.<br>\n쉬운 예로 Mockito를 이용한 TestCase 작성이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(MockitoJUnitRunner.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WithdrawalTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestWithdrawalService</span> <span class=\"keyword\">implements</span> <span class=\"title\">WithdrawalService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">withdrawalMember</span><span class=\"params\">(Member member)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Member&gt; <span class=\"title\">getMembers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Mock</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestWithdrawalService testWithdrawalService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initMocks</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        MockitoAnnotations.initMocks(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 회원탈퇴_테스트() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//given</span></span><br><span class=\"line\">        doReturn(Arrays.asList(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"Carrey\"</span>))).when(testWithdrawalService).getMembers();</span><br><span class=\"line\">        doCallRealMethod().when(testWithdrawalService).startProcess();</span><br><span class=\"line\">        <span class=\"comment\">//when</span></span><br><span class=\"line\">        String result = testWithdrawalService.startProcess();</span><br><span class=\"line\">        <span class=\"comment\">//then</span></span><br><span class=\"line\">        assertThat(result, is(<span class=\"string\">\"FINISHED\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"java의-접근제한자\">Java의 접근제한자</h1>\n<ul>\n<li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li>\n<li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 할 수 있다.</li>\n<li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li>\n<li>public: 모든 곳에서 접근 할 수 있다.</li>\n</ul>\n<h1 id=\"모든-클래스와-멤버의-접근성을-가능한-좁혀야-한다\">모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.</h1>\n<p>소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다.</p>\n<h2 id=\"클래스-레벨-접근제한자\">클래스 레벨 접근제한자</h2>\n<p>톱레벨 수준(파일명 = 클래스명)이 같은 수준에서의 접근제한자는 public과 package-private만 사용 할 수 있다.</p>\n<ul>\n<li>public으로 선언하는 경우 공개 API로 사용 - 하위호환을 평생 신경써야 한다.</li>\n<li>package-private로 사용하는 경우 해당 패키지 안에서만 사용 가능 - 다음 릴리즈에 내부로직을 변경해도 괜찮다.</li>\n</ul>\n<h2 id=\"이너클래스-사용하기\">이너클래스 사용하기</h2>\n<ul>\n<li>한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 사용하는 클래스 안에 private static으로 중첩해보자</li>\n<li>public일 필요가 없는 클래스의 접근 수준을 package-private로 해보자 - 다른 패키지에서 사용하지 못하게 막아야 한다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> price;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;Shop&gt; shops;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shop</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String owner;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> price;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;Shop&gt; shops;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shop</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String owner;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"private과-package-private은-해당-클래스의-구현에-해당하므로-공개-api에-영향을-주지-않는다\">private과 package-private은 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다.</h2>\n<ul>\n<li>일단 처음에는 모든 멤버는 private으로 만들어야 한다.</li>\n<li>같은 패키지에서 접근해야 하는 멤버가 있는 경우 package-private로 변경</li>\n<li>단, Serialize를 구현한 클래스의 경우 공개 API에 의도치 않게 공개 될 수도 있다.</li>\n<li>필드의 접근 권한을 package-private에서 protected로 바꾸는 순간 필드에 접근 할 수 있는 대상 범위가 늘어나니 주의해야 한다.</li>\n</ul>\n<h2 id=\"메서드를-재정의-할-경우에는-접근-수준을-상위-클래스에서보다-좁게-설정-할-수-없다\">메서드를 재정의 할 경우에는 접근 수준을 상위 클래스에서보다 좁게 설정 할 수 없다.</h2>\n<ul>\n<li>상위 클래스에서 접근제한자가 protected인데 하위클래스에서 갑자기 package-private이나 private로 변경할 수 없다.</li>\n<li>상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환원칙)을 위반하기 때문이다.</li>\n<li>단 인터페이스를 구현하는 경우에는 클래스의 메서드는 모두 public으로 해야 한다.</li>\n</ul>\n<h2 id=\"코드를-테스트-하려는-목적으로-클래스-인터페이스를-접근-범위를-넓히는-것을-주의하라\">코드를 테스트 하려는 목적으로 클래스, 인터페이스를 접근 범위를 넓히는 것을 주의하라</h2>\n<p>public 클래스의 private -&gt; package-private으로 바꾸는거는 괜찮다. 하지만 그이상의 경우 공개 API에 문제가 될 수 있다.</p>\n<h1 id=\"public-클래스의-인스턴스-필드는-되도록-public이-아니어야-한다\">public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.</h1>\n<p>필드가 가변객체를 참조하거나(Collections이나 배열), final이 아닌 인스턴스 필드를 public으로 선언하면 <strong>불변식을 보장할 수 없다.</strong><br>\npublic 가변 필드를 갖는 클래스는 일반적으로 thread safe 하지않다.<br>\n내부 구현을 바꾸고 싶어도 public 필드를 없애는 방식으로는 리팩터링이 불가하다.</p>\n<p>하지만 상수라면 관례대로 public static final 필드로 공개해도 좋다.<br>\n필드 명 네이밍은 관례 상 <code>대문자 + _(언더바)</code>로 구성한다.\n그리고 반드시 불변 객체를 참조하도록 한다.<br>\n불변성이 깨지는 순간 어마무시한 일이 일어난다.</p>\n<h1 id=\"클래스에서-public-static-final-배열-필드를-두지말아라\">클래스에서 public static final 배열 필드를 두지말아라</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] VALUES = &#123;...&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>이런 경우 VALUES에 대한 참조를 변경할 수는 없지만, 배열내의 내용을 변경하는 것은 가능하다.</p>\n<h2 id=\"해결책1-thing-배열을-private로-만들고-public-불변-리스트를-추가한다\">해결책1. Thing 배열을 private로 만들고 public 불변 리스트를 추가한다.</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">## 해결책2. Thing 배열을 private로 만들고 public 메서드를 추가한다.</span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] values() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> PRIVATE_VALUES.clone(); <span class=\"comment\">//방어적 복사본</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"java-9에-추가된-modules-project-jigsaw\">Java 9에 추가된 Modules (Project Jigsaw)</h1>\n<p>Java9 부터는 Module시스템이라는 개념이 도입 되었다.</p>\n<p>패키지는 클래스의 묶음인 것 처럼, 모듈(Modules)은 패키지의 묶음이다.\n모듈은 관례 상, 자신이 속하는 패키지 중 공개(export) 할 것을 선언한다.<br>\n관례상 <strong>module-info.java</strong> 에 선언한다.\n모듈을 정의하기 위해 3가지 정보를 작성해야 한다.</p>\n<ol>\n<li>module 명 - module 명칭</li>\n<li>공개할 package (export)</li>\n</ol>\n<ul>\n<li>공개한 package의 public type에 접근제한자만 외부에서 접근할 수 있다.</li>\n<li>만약 export에 적지 않은 패키지의 클래스 중 public 접근제한자가 있어도 접근을 할 수 없다.</li>\n</ul>\n<ol start=\"3\">\n<li>module내 package의 클래스를 사용하기 위해 종속되는 package (require)</li>\n</ol>\n<ul>\n<li>다른 모듈의 대한 require를 작성하면 다른 모듈에서 export하는 클래스의 public type에 접근이 가능하다</li>\n</ul>\n<h2 id=\"java-8에서-접근-제한자\">Java 8에서 접근 제한자</h2>\n<ul>\n<li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li>\n<li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li>\n<li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li>\n<li>public: 모든 곳에서 접근할 수 있다.</li>\n</ul>\n<h2 id=\"java-9부터의-접근-제한자\">Java 9부터의 접근 제한자</h2>\n<ul>\n<li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li>\n<li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li>\n<li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li>\n<li>모듈 내부의 public: 모듈 내부의 모든 곳에서 접근할 수 있다.</li>\n<li>required의 public: 모듈에 종속하는 모듈의 모든 패키지 내의 클래스에 접근할 수 있다.</li>\n<li>export public: module-info.java에서 제공하는 모든 public에 접근할 수 있다.</li>\n</ul>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 15. 클래스와 멤버의 접근 권한을 최소화하라</li>\n<li>https://infoscis.github.io/2017/03/24/First-steps-with-java9-and-jigsaw-part-1/</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>잘 설계된 컴포넌트는 클래스는 모든 내부구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리 해놨다.<br>\n오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.<br>\n정보은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.</p>\n<h1>정보 은닉의 장점</h1>\n<h2>시스템 개발 속도를 높인다.</h2>\n<p>여러가지 컴포넌트를 병렬로 개발할 수 있기 때문이다.\n예를 들어, 회원탈퇴 기능을 개발한다고 해보자</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WithdrawalService</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">withdrawalMember</span><span class=\"params\">(Member member)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">List&lt;Member&gt; <span class=\"title\">getMembers</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\">WithdrawalProcessType <span class=\"title\">getProcessType</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"title\">startProcess</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Member&gt; members = getMembers();</span><br><span class=\"line\">    members.stream().foreach(<span class=\"keyword\">this</span>::withdrawalMember);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이러한 회원탈퇴 로직에 대한 인터페이스를 제공하고,\n일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴등의 로직이 상이하여 Service를 별도로 구현한다고하는 경우 Interface 스펙에 맞추어 여러 개발자가 개발할 수 있기 때문이다.</p>\n<h2>시스템 관리 비용을 낮춘다.</h2>\n<p>각 컴포넌트를 빨리 파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.<br>\n위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 로직에 변경이 생긴 경우<br>\n<code>WithdrawalService</code> interface를 구현한 비회원 탈퇴 서비스를 만들면 되기 때문이다.</p>\n<h2>성능 최적화에 도움을 준다.</h2>\n<p>완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있다.<br>\n위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 중 비회원 탈퇴에 대해 처리대상이 많아 startProcess 메서드를 확장하여 내부적으로 withdrawalMember 메서드를 사용하지 않고 회원 리스트에 대해 쿼리를 이용해 Insert~ Select로 한방에 처리 할 수도 있다.</p>\n<h2>소프트웨어 재사용성을 높인다.</h2>\n<p>외부에 의존하지 않고, 독자적으로 동작할 수 있는 컴포넌트라면, 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크다.<br>\n예를들면 알림톡 서버 API를 호출 할 수 있는 인터페이스가 있는 경우 그 인터페이스를 그대로 사용할 수 있다.</p>\n<h2>큰 시스템을 제작하는 난이도를 낮춰준다.</h2>\n<p>시스템 전체가 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있다.<br>\n쉬운 예로 Mockito를 이용한 TestCase 작성이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(MockitoJUnitRunner.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WithdrawalTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestWithdrawalService</span> <span class=\"keyword\">implements</span> <span class=\"title\">WithdrawalService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">withdrawalMember</span><span class=\"params\">(Member member)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Member&gt; <span class=\"title\">getMembers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Mock</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestWithdrawalService testWithdrawalService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initMocks</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        MockitoAnnotations.initMocks(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 회원탈퇴_테스트() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//given</span></span><br><span class=\"line\">        doReturn(Arrays.asList(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"Carrey\"</span>))).when(testWithdrawalService).getMembers();</span><br><span class=\"line\">        doCallRealMethod().when(testWithdrawalService).startProcess();</span><br><span class=\"line\">        <span class=\"comment\">//when</span></span><br><span class=\"line\">        String result = testWithdrawalService.startProcess();</span><br><span class=\"line\">        <span class=\"comment\">//then</span></span><br><span class=\"line\">        assertThat(result, is(<span class=\"string\">\"FINISHED\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>Java의 접근제한자</h1>\n<ul>\n<li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li>\n<li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 할 수 있다.</li>\n<li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li>\n<li>public: 모든 곳에서 접근 할 수 있다.</li>\n</ul>\n<h1>모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.</h1>\n<p>소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다.</p>\n<h2>클래스 레벨 접근제한자</h2>\n<p>톱레벨 수준(파일명 = 클래스명)이 같은 수준에서의 접근제한자는 public과 package-private만 사용 할 수 있다.</p>\n<ul>\n<li>public으로 선언하는 경우 공개 API로 사용 - 하위호환을 평생 신경써야 한다.</li>\n<li>package-private로 사용하는 경우 해당 패키지 안에서만 사용 가능 - 다음 릴리즈에 내부로직을 변경해도 괜찮다.</li>\n</ul>\n<h2>이너클래스 사용하기</h2>\n<ul>\n<li>한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 사용하는 클래스 안에 private static으로 중첩해보자</li>\n<li>public일 필요가 없는 클래스의 접근 수준을 package-private로 해보자 - 다른 패키지에서 사용하지 못하게 막아야 한다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> price;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;Shop&gt; shops;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shop</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String owner;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> price;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;Shop&gt; shops;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shop</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String owner;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>private과 package-private은 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다.</h2>\n<ul>\n<li>일단 처음에는 모든 멤버는 private으로 만들어야 한다.</li>\n<li>같은 패키지에서 접근해야 하는 멤버가 있는 경우 package-private로 변경</li>\n<li>단, Serialize를 구현한 클래스의 경우 공개 API에 의도치 않게 공개 될 수도 있다.</li>\n<li>필드의 접근 권한을 package-private에서 protected로 바꾸는 순간 필드에 접근 할 수 있는 대상 범위가 늘어나니 주의해야 한다.</li>\n</ul>\n<h2>메서드를 재정의 할 경우에는 접근 수준을 상위 클래스에서보다 좁게 설정 할 수 없다.</h2>\n<ul>\n<li>상위 클래스에서 접근제한자가 protected인데 하위클래스에서 갑자기 package-private이나 private로 변경할 수 없다.</li>\n<li>상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환원칙)을 위반하기 때문이다.</li>\n<li>단 인터페이스를 구현하는 경우에는 클래스의 메서드는 모두 public으로 해야 한다.</li>\n</ul>\n<h2>코드를 테스트 하려는 목적으로 클래스, 인터페이스를 접근 범위를 넓히는 것을 주의하라</h2>\n<p>public 클래스의 private -&gt; package-private으로 바꾸는거는 괜찮다. 하지만 그이상의 경우 공개 API에 문제가 될 수 있다.</p>\n<h1>public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.</h1>\n<p>필드가 가변객체를 참조하거나(Collections이나 배열), final이 아닌 인스턴스 필드를 public으로 선언하면 <strong>불변식을 보장할 수 없다.</strong><br>\npublic 가변 필드를 갖는 클래스는 일반적으로 thread safe 하지않다.<br>\n내부 구현을 바꾸고 싶어도 public 필드를 없애는 방식으로는 리팩터링이 불가하다.</p>\n<p>하지만 상수라면 관례대로 public static final 필드로 공개해도 좋다.<br>\n필드 명 네이밍은 관례 상 <code>대문자 + _(언더바)</code>로 구성한다.\n그리고 반드시 불변 객체를 참조하도록 한다.<br>\n불변성이 깨지는 순간 어마무시한 일이 일어난다.</p>\n<h1>클래스에서 public static final 배열 필드를 두지말아라</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] VALUES = &#123;...&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>이런 경우 VALUES에 대한 참조를 변경할 수는 없지만, 배열내의 내용을 변경하는 것은 가능하다.</p>\n<h2>해결책1. Thing 배열을 private로 만들고 public 불변 리스트를 추가한다.</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">## 해결책2. Thing 배열을 private로 만들고 public 메서드를 추가한다.</span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] values() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> PRIVATE_VALUES.clone(); <span class=\"comment\">//방어적 복사본</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>Java 9에 추가된 Modules (Project Jigsaw)</h1>\n<p>Java9 부터는 Module시스템이라는 개념이 도입 되었다.</p>\n<p>패키지는 클래스의 묶음인 것 처럼, 모듈(Modules)은 패키지의 묶음이다.\n모듈은 관례 상, 자신이 속하는 패키지 중 공개(export) 할 것을 선언한다.<br>\n관례상 <strong>module-info.java</strong> 에 선언한다.\n모듈을 정의하기 위해 3가지 정보를 작성해야 한다.</p>\n<ol>\n<li>module 명 - module 명칭</li>\n<li>공개할 package (export)</li>\n</ol>\n<ul>\n<li>공개한 package의 public type에 접근제한자만 외부에서 접근할 수 있다.</li>\n<li>만약 export에 적지 않은 패키지의 클래스 중 public 접근제한자가 있어도 접근을 할 수 없다.</li>\n</ul>\n<ol start=\"3\">\n<li>module내 package의 클래스를 사용하기 위해 종속되는 package (require)</li>\n</ol>\n<ul>\n<li>다른 모듈의 대한 require를 작성하면 다른 모듈에서 export하는 클래스의 public type에 접근이 가능하다</li>\n</ul>\n<h2>Java 8에서 접근 제한자</h2>\n<ul>\n<li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li>\n<li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li>\n<li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li>\n<li>public: 모든 곳에서 접근할 수 있다.</li>\n</ul>\n<h2>Java 9부터의 접근 제한자</h2>\n<ul>\n<li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li>\n<li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li>\n<li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li>\n<li>모듈 내부의 public: 모듈 내부의 모든 곳에서 접근할 수 있다.</li>\n<li>required의 public: 모듈에 종속하는 모듈의 모든 패키지 내의 클래스에 접근할 수 있다.</li>\n<li>export public: module-info.java에서 제공하는 모든 public에 접근할 수 있다.</li>\n</ul>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 15. 클래스와 멤버의 접근 권한을 최소화하라</li>\n<li>https://infoscis.github.io/2017/03/24/First-steps-with-java9-and-jigsaw-part-1/</li>\n</ul>\n"},{"title":"Cache에 대하여.. (Spring+EHCache)","subtitle":null,"catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-10-03-spring-ehcache","typora-copy-images-to":"./2018-10-03-spring-ehcache","date":"2018-11-07T14:33:38.000Z","header-img":null,"_content":"\n\n\n# 들어가며..\n\n엔터프라이즈 급 Application에서는 DBMS의 부하를 줄이고, 성능을 높이기 위해 캐시(Cache)를 사용한다. 우리 회사에서도 EHCache, Redis를 사용하지만, EHCache쪽은 공부한 적이 없어서 이번 기회에 정리하면서 공부해 보게 되었다.\n대부분 `docs.spring.io`의 문서를 번역한 내용을 위주로 정리 하였다.\n\n\n\n# Cache란?\n\nCache의 사전적인 의미를 알아보기 위해 위키백과를 검색해 보았다.\n\n> **캐시**(cache, [문화어](https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4): 캐쉬, 고속완충기, 고속완충기억기)는 [컴퓨터 과학](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 캐시는 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.\n>\n> 캐시는 시스템의 효율성을 위해 여러 분야에서 두루 쓰인다.\n\n결국 캐시란, 반복적으로 데이터를 불러올 때 지속적으로 DBMS 혹은 서버에 요청하는 것이 아닌 메모리에 데이터를 저장하였다가 데이터를 불러다가 쓰는 것을 의미한다. 따라서 서버나 DBMS에 부담을 덜어주고, 엄청 빠르기 때문에 많은 시스템에서 사용하고 있다. \n대표적으로 Browser Cache, Apacha Cache, DNS Cache등 여러가지 형태로 캐시가 사용되고 있다.\n\nEHCache 사이트에서는 캐시에 대한 용어를 이렇게 정리 하였다.\n\n* **Cache** : 캐시는 `미래에 필요할 것이고 빠르게 검색할 수 있는 데이터를 담은 저장소` 라고 정의 한다. 캐시는 다른 곳에 있는 데이터를 복제하거나, 계산 결과를 임시적으로 저장하는 데이터 저장소이다. 캐시에 있는 데이터는 시간과 자원 면에서 최소한의 비용으로 반복적으로 접근 할 수 있다.\n* **Cache Hit** : 데이터 요소가 캐시에 요청되고 해당 키에 대한 요소가 존재하면 Cache Hit (또는 단순히 'Hit')라고 한다.\n* **Cache Miss**:데이터 요소가 캐시에 요청되고 해당 키에 대해 요소가 존재하지 않으면 Cache Miss (또는 단순히 'Miss')라고 한다.\n* **System-of-record** : 데이터에 대한 신뢰할 수있는 정보원. 이것을 흔히 시스템 레코드(SOR)이라고 한다. 캐시는 시스템 레코드에서 검색되거나 시스템 레코드에 저장된 데이터의 로컬 사본으로 작동된다. Ehcache를 사용하기 위해 SOR은 데이터베이스로 간주된다.\n\n\n# Long Tail 법칙\n\n![Long Tail](./17110B4350CC5EC51D.jpeg)\n\n\n\n20%의 요구가 시스템 리소스의 대부분을 잡아먹는다는 법칙. \n자주 사용되는 `20%의 기능에 캐시를 이용`하면 리소스 사용량을 대폭 줄일 수 있어, `시스템의 성능을 대폭 향상` 시킬 수 있다.\n\n\n\n# Local Cache vs Global Cache\n\n* Local Cache\n  * Local 장비 내에서만 사용 되는 캐시\n  * Local 장비의 Resource를 이용한다 (Memory, Disk)\n  * Local에서 작동 되기 때문에 속도가 빠르다.\n  * Local에서만 작동되기 때문에 다른 서버와 데이터 공유가 어렵다\n\n* Global Cache\n  * 여러 서버에서 Cache Server에 접근하여 사용하는 캐시\n  * 데이터를 분산하여 저장 할 수 있다. \n    * Replication - 데이터를 복제\n    * Sharding - 데이터를 분산하여 저장\n  * Local Cache에 비해 상대적으로 느리다 (네트워크 트래픽)\n  * 별도의 Cache Server를 이용하기 때문에 서버 간 데이터 공유가 쉽다.\n\n\n\n# Spring Cache Abstraction\n\nSpring 3.1버전부터 Spring Application에 캐시를 쉽게 추가할 수 있도록 기능을 제공하게 되었다. 유사 트랜잭션을 지원하고, 사용하고 있는 코드(메소드)에 영향을 최소화 하면서 일관된 방법으로 캐시를 사용 할 수 있게 되었다.\n\nSpring에서 캐시 추상화는 메소드를 통해 기능을 지원하는데, 메소드가 실행되는 시점에 파라미터에 대한 캐시 존재 여부를 판단하여 없으면 캐시를 등록하게 되고, 캐시가 있으면 메소드를 실행 시키지 않고 캐시 데이터를 Return 해주게 된다.\n\nSpring 캐시 추상화를 지원하기 때문에 개발자는 별도의 캐시 로직을 작성하지 않아도 된다. 하지만 캐시를 저장하는 저장소는 직접 설정을 해주어야 한다. Spring에서는 `CacheManager`라는 Interface를 제공하여 캐시를 구현하도록 하고 있다.\n\n<br/>\n\n~~~xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n~~~\n\nSpring Boot에서는 `spring-boot-starter-cache` Artifact를 추가 하여 CacheManager를 구성 할 수 있다. \n기본적으로 별도의 추가적인 서드파티 모듈이 없는 경우에는 Local Memory에 저장이 가능한 ConcurrentMap기반인 `ConcurrentMapCacheManager`가 Bean으로 자동 생성 된다.\n\n이외에도 EHCache, Redis등의 서드파티 모듈을 추가 하게 되면 `EHCacheCacheManager`, `RedisCacheManager`를 Bean으로 등록 하여 사용할 수 있다. 이렇게 되면 별도로 다른 설정 없이도  단순 Memory Cache가 아닌 Cache Server를 대상으로 캐시를 저장 할 수 있도록 지원하고 있다.\n\n\n\n# Spring Cache Annotation\n\nSpring에서는 Cache Annotation을 지원하여 좀 더 쉽게 메서드에 대한 캐시를 제어할 수 있다.\n\n* @EnableCaching\n  * Annotation 기반 캐싱 설정을 사용 (내부적으로 Spring AOP 이용)\n\n| 속성             | 설명                                                         | Default           |\n| ---------------- | ------------------------------------------------------------ | ----------------- |\n| proxyTargetClass | 클래스 기반의 Proxy생성 여부<br />false인 경우 JDK Dynamic Proxy 사용 (Interface 기반)<br />true인 경우 CGLIB Proxy 사용 (Class 기반) | false             |\n| mode             | 위빙 (Weaving) 모드에 대한 설정<br />PROXY : 기존의 Spring AOP 방식을 이용한 RTW방식 사용<br />ASPECTJ : aspectj 라이브러리를 이용한 CTW, LTW 방식 지원 | PROXY             |\n| order            | AOP order 설정                                               | Integer.MAX_VALUE |\n\n* @Cacheable\n  * 캐싱할 수 있는 메서드를 지정하기 위해 사용\n\n| 속성             | 설명                                                         | Default |\n| ---------------- | ------------------------------------------------------------ | ------- |\n| value, cacheName | 캐시 명                                                      | {}      |\n| key              | 같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.) | \"\"      |\n| keyGenerator     | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager     | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver    | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n| condition        | SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 `true`인 경우에만 캐싱 | \"\"      |\n| unless           | 캐싱이 이루어지지 않는 조건을 설정<br />연산 조건이 `true` 이면 경우에는 캐싱되지 않는다<br />예시 : id가 null아 아닌 경우에만 캐싱 (unless = \"#id == null\") | \"\"      |\n| sync             | 캐시 구현체가 Thread safe 하지 않는 경우, 자체적으로 캐시에 동기화를 거는 속성 | false   |\n\n* @CacheEvict\n  * 메서드 실행 시, 해당 캐시를 삭제\n\n| 속성             | 설명                                                         | Default |\n| ---------------- | ------------------------------------------------------------ | ------- |\n| value, cacheName | 캐시 명                                                      | {}      |\n| key              | 같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.) | \"\"      |\n| keyGenerator     | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager     | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver    | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n| condition        | SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 `true`인 경우에만 캐시 삭제 | \"\"      |\n| allEntries       | Cache Key에 대한 전체 데이터 삭제 여부                       | false   |\n| beforeInvocation | true면 메서드 실행 이전에 캐시 삭제, false면 메서드 실행 이후 삭제 | false   |\n\n\n* @CachePut\n  * 메서드 실행에 영향을 주지 않고 캐시를 갱신해야 하는 경우 사용\n  * 보통은 @Cacheable과 @CachePut Annotation을 같이 사용하지 않는다.\n    (둘은 다른 동작을 하기 때문에, 실행순서에 따라 다른 결과가 나올 수 있다.)\n  * @CachePut Annotation은 캐시 생성용으로만 사용한다.\n\n| 속성             | 설명                                                         | Default |\n| ---------------- | ------------------------------------------------------------ | ------- |\n| value, cacheName | 캐시 명                                                      | {}      |\n| key              | 같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.) | \"\"      |\n| keyGenerator     | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager     | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver    | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n| condition        | SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 `true`인 경우에만 캐싱 | \"\"      |\n| unless           | 캐싱이 이루어지지 않는 조건을 설정<br />연산 조건이 `true` 이면 경우에는 캐싱되지 않는다<br />예시 : id가 null아 아닌 경우에만 캐싱 (unless = \"#id == null\") | \"\"      |\n\n* @Caching\n  * @CacheEvict이나 @CachePut을 여러개 지정해야 하는 경우에 사용\n  * 조건식이나 표현식이 다른 경우에 사용한다.\n  * 여러가지의 key에 대한 캐시를 중첩적으로 삭제해야 할 때 사용\n\n| 속성        | 설명                                     | Default |\n| ----------- | ---------------------------------------- | ------- |\n| cacheable[] | @Cacheable 적용할 Annotation을 등록한다. | {}      |\n| put[]       | @CachePut 적용할 Annotation을 등록한다.  | {}      |\n| evict[]     | @CacheEvic 적용할 Annotation을 등록한다. | {}      |\n\n\n* @CacheConfig\n  * 클래스 단위로 캐시설정을 동일하게 하는데 사용\n  * 이 설정은 CacheManager가 여러개인 경우에만 사용\n  * Member조회 클래스에서는 Redis기반 캐시를 사용하고\n    Product 조회 클래스에서는 EHCache 기반 캐시를 사용할 때\n    각 클래스 별로 CacheManager를 지정 가능\n    \n| 속성          | 설명                                                         | Default |\n| ------------- | ------------------------------------------------------------ | ------- |\n| cacheNames    | 캐시 명                                                      | {}      |\n| keyGenerator  | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager  | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n\n\n\n# EHCache\n\n![EHCACHE](./EHCACHE.png)\n\n* EHCache는 오픈 소스 기반의 Local Cache이다. \n* 속도가 빠르며 경량 Cache라는 장점이 있다.\n* Disk, Memory 저장이 가능한 형태\n* 서버 간 분산 캐시를 지원한다 (동기/비동기 복제)\n* JSR107 JCache 표준을 지원한다. \n  따라서 JCache에서 제공하는 Annotation을 통해 이미 작성된 코드에 간단하게 기능 추가가 쉽다.\n>**JSR-107** : (JCACHE – Java Temporary Caching API) 객체 생성, 공유 액세스, 스풀링, 무효화 및 JVM 전반에 걸친 일관성을 포함하여 Java 객체의 메모리 캐싱에서 사용할 API 에 대한 기준으로 볼 수 있다.    해당 Spec 으로 구현된 cache로는 EhCache가 유명하며, Hazelcast, Infinispan, Couchbase, Redis, Caffeine 등도 해당 기준을 따르는 것으로 알려져 있다.\n\n\n\n# EHCache 설정 방법 \n\n내용이 길어 질 것 같아 별도의 포스트로 작성\n\n* [EHCache 설정방법 (Spring Framework)](http://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springframework/)\n* [EHCache 설정방법 (Spring Boot)]( http:/jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springboot/)\n\n\n\n\n# EHCache 예시 코드\n\n테스트 시나리오\n\n1. 가상으로 DBMS에서 데이터를 조회 하는 Repository를 생성\n2. 3초 정도 슬로우쿼리가 실행된다고 가정\n3. 최초 1회는 DB에서 조회, 2회차 부턴 캐시 사용\n4. 캐시를 조회했을 때, 걸리는 시간 확인\n5. 캐시가 만료되었을때, 걸리는 시간 확인\n\n~~~java\n@Slf4j\n@RestController\npublic class EHCacheController {\n\n    @Autowired\n    private EHCacheRepository repository;\n\n    @GetMapping(\"/data/{id}\")\n    public String getData(@PathVariable(\"id\") int id) throws InterruptedException {\n\n        long start = System.currentTimeMillis();\n        String data = repository.getData(id);\n        long end = System.currentTimeMillis();\n\n        log.info(\"쿼리 수행 시간 : {}ms\", end-start);\n        return data;\n    }\n\n    @GetMapping(\"/data/delete/{id}\")\n    public void getExpireCache(@PathVariable(\"id\") int id) {\n        repository.evictCache(id);\n    }\n}\n~~~\n\n```java\n@Slf4j\n@Repository\npublic class EHCacheRepository {\n\n    @Cacheable(cacheNames = \"testData\")\n    public String getData(int id) throws InterruptedException {\n        Thread.sleep(3000);\n        return \"test-data\";\n    }\n\n    @CacheEvict(cacheNames = \"testData\", allEntries = true)\n    public void evictCache(int id) {\n        log.info(\"delete cache all\");\n    }\n}\n```\n\n```java\n@Configuration\n@EnableCaching(proxyTargetClass = true, mode = AdviceMode.PROXY)\npublic class EHCacheConfig {\n    @Bean\n    public EhCacheManagerFactoryBean ehCacheManagerFactoryBean() {\n        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = new EhCacheManagerFactoryBean();\n        ehCacheManagerFactoryBean.setConfigLocation(new ClassPathResource(\"config/ehcache.xml\"));\n        ehCacheManagerFactoryBean.setShared(true);\n        return ehCacheManagerFactoryBean;\n    }\n\n    @Bean\n    public EhCacheCacheManager ehCacheCacheManager(EhCacheManagerFactoryBean ehCacheManagerFactoryBean) {\n        EhCacheCacheManager ehCacheCacheManager = new EhCacheCacheManager();\n        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());\n        return ehCacheCacheManager;\n    }\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         maxBytesLocalHeap=\"300M\"\n         updateCheck=\"false\">\n\n    <diskStore path=\"java.io.tmpdir\" />\n    <sizeOfPolicy maxDepth=\"100000\" maxDepthExceededBehavior=\"continue\"/>\n\n    <defaultCache\n            eternal=\"false\"\n            timeToIdleSeconds=\"0\"\n            timeToLiveSeconds=\"1200\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n\n    <cache name=\"LocalCacheData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n\n    <cache name=\"testData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"100\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n</ehcache>\n```\n\n<br/>\n\n결과\n\n![ehcache-test](./ehcache-test.png)\n\n1. 최초로 `GET localhost:8080/data/1` 요청 시, 3초 이상의 슬로우 쿼리가 실행\n2. 두번째로 동일하게 `GET localhost:8080/data/1` 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)\n3. `GET localhost:8080/data/delete/1` 요청으로 캐시 삭제\n4. `GET localhost:8080/data/1` 요청 시, 3초 이상의 슬로우 쿼리가 실행 (캐시 삭제 후 요청)\n5.  `GET localhost:8080/data/1` 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)\n\n> 주의 할 점! \n>\n> EHCache는 ehcache.xml 또는 Java 코드에서 addCache를 이용하여 반드시 Cache Key를 등록해 줘야 함\n> 이거를 안 등록하고 Cache Key를 막쓰다가.. 계속 Cache Key가 없다는 오류가 발생하여 잠깐 삽질..\n\n# 참고\n\n- http://www.ehcache.org/documentation/2.8/integrations/spring.html#introduction\n- https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache\n- http://blog.breakingthat.com/2018/03/19/springboot-ehcache-%EC%A0%81%EC%9A%A9/\n- https://jojoldu.tistory.com/57\n- http://www.ehcache.org/documentation/2.8/configuration/index.html\n- https://www.slideshare.net/heungrae_kim/spring-31-ehcache\n- https://shortstories.gitbooks.io/studybook/content/cache.html\n","source":"_posts/2018-10-03-spring-ehcache.md","raw":"---\ntitle: Cache에 대하여.. (Spring+EHCache)\nsubtitle:\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\ntypora-root-url: ./2018-10-03-spring-ehcache\ntypora-copy-images-to: ./2018-10-03-spring-ehcache\ndate: 2018-11-07 23:33:38\nheader-img:\n---\n\n\n\n# 들어가며..\n\n엔터프라이즈 급 Application에서는 DBMS의 부하를 줄이고, 성능을 높이기 위해 캐시(Cache)를 사용한다. 우리 회사에서도 EHCache, Redis를 사용하지만, EHCache쪽은 공부한 적이 없어서 이번 기회에 정리하면서 공부해 보게 되었다.\n대부분 `docs.spring.io`의 문서를 번역한 내용을 위주로 정리 하였다.\n\n\n\n# Cache란?\n\nCache의 사전적인 의미를 알아보기 위해 위키백과를 검색해 보았다.\n\n> **캐시**(cache, [문화어](https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4): 캐쉬, 고속완충기, 고속완충기억기)는 [컴퓨터 과학](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 캐시는 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.\n>\n> 캐시는 시스템의 효율성을 위해 여러 분야에서 두루 쓰인다.\n\n결국 캐시란, 반복적으로 데이터를 불러올 때 지속적으로 DBMS 혹은 서버에 요청하는 것이 아닌 메모리에 데이터를 저장하였다가 데이터를 불러다가 쓰는 것을 의미한다. 따라서 서버나 DBMS에 부담을 덜어주고, 엄청 빠르기 때문에 많은 시스템에서 사용하고 있다. \n대표적으로 Browser Cache, Apacha Cache, DNS Cache등 여러가지 형태로 캐시가 사용되고 있다.\n\nEHCache 사이트에서는 캐시에 대한 용어를 이렇게 정리 하였다.\n\n* **Cache** : 캐시는 `미래에 필요할 것이고 빠르게 검색할 수 있는 데이터를 담은 저장소` 라고 정의 한다. 캐시는 다른 곳에 있는 데이터를 복제하거나, 계산 결과를 임시적으로 저장하는 데이터 저장소이다. 캐시에 있는 데이터는 시간과 자원 면에서 최소한의 비용으로 반복적으로 접근 할 수 있다.\n* **Cache Hit** : 데이터 요소가 캐시에 요청되고 해당 키에 대한 요소가 존재하면 Cache Hit (또는 단순히 'Hit')라고 한다.\n* **Cache Miss**:데이터 요소가 캐시에 요청되고 해당 키에 대해 요소가 존재하지 않으면 Cache Miss (또는 단순히 'Miss')라고 한다.\n* **System-of-record** : 데이터에 대한 신뢰할 수있는 정보원. 이것을 흔히 시스템 레코드(SOR)이라고 한다. 캐시는 시스템 레코드에서 검색되거나 시스템 레코드에 저장된 데이터의 로컬 사본으로 작동된다. Ehcache를 사용하기 위해 SOR은 데이터베이스로 간주된다.\n\n\n# Long Tail 법칙\n\n![Long Tail](./17110B4350CC5EC51D.jpeg)\n\n\n\n20%의 요구가 시스템 리소스의 대부분을 잡아먹는다는 법칙. \n자주 사용되는 `20%의 기능에 캐시를 이용`하면 리소스 사용량을 대폭 줄일 수 있어, `시스템의 성능을 대폭 향상` 시킬 수 있다.\n\n\n\n# Local Cache vs Global Cache\n\n* Local Cache\n  * Local 장비 내에서만 사용 되는 캐시\n  * Local 장비의 Resource를 이용한다 (Memory, Disk)\n  * Local에서 작동 되기 때문에 속도가 빠르다.\n  * Local에서만 작동되기 때문에 다른 서버와 데이터 공유가 어렵다\n\n* Global Cache\n  * 여러 서버에서 Cache Server에 접근하여 사용하는 캐시\n  * 데이터를 분산하여 저장 할 수 있다. \n    * Replication - 데이터를 복제\n    * Sharding - 데이터를 분산하여 저장\n  * Local Cache에 비해 상대적으로 느리다 (네트워크 트래픽)\n  * 별도의 Cache Server를 이용하기 때문에 서버 간 데이터 공유가 쉽다.\n\n\n\n# Spring Cache Abstraction\n\nSpring 3.1버전부터 Spring Application에 캐시를 쉽게 추가할 수 있도록 기능을 제공하게 되었다. 유사 트랜잭션을 지원하고, 사용하고 있는 코드(메소드)에 영향을 최소화 하면서 일관된 방법으로 캐시를 사용 할 수 있게 되었다.\n\nSpring에서 캐시 추상화는 메소드를 통해 기능을 지원하는데, 메소드가 실행되는 시점에 파라미터에 대한 캐시 존재 여부를 판단하여 없으면 캐시를 등록하게 되고, 캐시가 있으면 메소드를 실행 시키지 않고 캐시 데이터를 Return 해주게 된다.\n\nSpring 캐시 추상화를 지원하기 때문에 개발자는 별도의 캐시 로직을 작성하지 않아도 된다. 하지만 캐시를 저장하는 저장소는 직접 설정을 해주어야 한다. Spring에서는 `CacheManager`라는 Interface를 제공하여 캐시를 구현하도록 하고 있다.\n\n<br/>\n\n~~~xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n~~~\n\nSpring Boot에서는 `spring-boot-starter-cache` Artifact를 추가 하여 CacheManager를 구성 할 수 있다. \n기본적으로 별도의 추가적인 서드파티 모듈이 없는 경우에는 Local Memory에 저장이 가능한 ConcurrentMap기반인 `ConcurrentMapCacheManager`가 Bean으로 자동 생성 된다.\n\n이외에도 EHCache, Redis등의 서드파티 모듈을 추가 하게 되면 `EHCacheCacheManager`, `RedisCacheManager`를 Bean으로 등록 하여 사용할 수 있다. 이렇게 되면 별도로 다른 설정 없이도  단순 Memory Cache가 아닌 Cache Server를 대상으로 캐시를 저장 할 수 있도록 지원하고 있다.\n\n\n\n# Spring Cache Annotation\n\nSpring에서는 Cache Annotation을 지원하여 좀 더 쉽게 메서드에 대한 캐시를 제어할 수 있다.\n\n* @EnableCaching\n  * Annotation 기반 캐싱 설정을 사용 (내부적으로 Spring AOP 이용)\n\n| 속성             | 설명                                                         | Default           |\n| ---------------- | ------------------------------------------------------------ | ----------------- |\n| proxyTargetClass | 클래스 기반의 Proxy생성 여부<br />false인 경우 JDK Dynamic Proxy 사용 (Interface 기반)<br />true인 경우 CGLIB Proxy 사용 (Class 기반) | false             |\n| mode             | 위빙 (Weaving) 모드에 대한 설정<br />PROXY : 기존의 Spring AOP 방식을 이용한 RTW방식 사용<br />ASPECTJ : aspectj 라이브러리를 이용한 CTW, LTW 방식 지원 | PROXY             |\n| order            | AOP order 설정                                               | Integer.MAX_VALUE |\n\n* @Cacheable\n  * 캐싱할 수 있는 메서드를 지정하기 위해 사용\n\n| 속성             | 설명                                                         | Default |\n| ---------------- | ------------------------------------------------------------ | ------- |\n| value, cacheName | 캐시 명                                                      | {}      |\n| key              | 같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.) | \"\"      |\n| keyGenerator     | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager     | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver    | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n| condition        | SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 `true`인 경우에만 캐싱 | \"\"      |\n| unless           | 캐싱이 이루어지지 않는 조건을 설정<br />연산 조건이 `true` 이면 경우에는 캐싱되지 않는다<br />예시 : id가 null아 아닌 경우에만 캐싱 (unless = \"#id == null\") | \"\"      |\n| sync             | 캐시 구현체가 Thread safe 하지 않는 경우, 자체적으로 캐시에 동기화를 거는 속성 | false   |\n\n* @CacheEvict\n  * 메서드 실행 시, 해당 캐시를 삭제\n\n| 속성             | 설명                                                         | Default |\n| ---------------- | ------------------------------------------------------------ | ------- |\n| value, cacheName | 캐시 명                                                      | {}      |\n| key              | 같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.) | \"\"      |\n| keyGenerator     | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager     | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver    | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n| condition        | SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 `true`인 경우에만 캐시 삭제 | \"\"      |\n| allEntries       | Cache Key에 대한 전체 데이터 삭제 여부                       | false   |\n| beforeInvocation | true면 메서드 실행 이전에 캐시 삭제, false면 메서드 실행 이후 삭제 | false   |\n\n\n* @CachePut\n  * 메서드 실행에 영향을 주지 않고 캐시를 갱신해야 하는 경우 사용\n  * 보통은 @Cacheable과 @CachePut Annotation을 같이 사용하지 않는다.\n    (둘은 다른 동작을 하기 때문에, 실행순서에 따라 다른 결과가 나올 수 있다.)\n  * @CachePut Annotation은 캐시 생성용으로만 사용한다.\n\n| 속성             | 설명                                                         | Default |\n| ---------------- | ------------------------------------------------------------ | ------- |\n| value, cacheName | 캐시 명                                                      | {}      |\n| key              | 같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.) | \"\"      |\n| keyGenerator     | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager     | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver    | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n| condition        | SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 `true`인 경우에만 캐싱 | \"\"      |\n| unless           | 캐싱이 이루어지지 않는 조건을 설정<br />연산 조건이 `true` 이면 경우에는 캐싱되지 않는다<br />예시 : id가 null아 아닌 경우에만 캐싱 (unless = \"#id == null\") | \"\"      |\n\n* @Caching\n  * @CacheEvict이나 @CachePut을 여러개 지정해야 하는 경우에 사용\n  * 조건식이나 표현식이 다른 경우에 사용한다.\n  * 여러가지의 key에 대한 캐시를 중첩적으로 삭제해야 할 때 사용\n\n| 속성        | 설명                                     | Default |\n| ----------- | ---------------------------------------- | ------- |\n| cacheable[] | @Cacheable 적용할 Annotation을 등록한다. | {}      |\n| put[]       | @CachePut 적용할 Annotation을 등록한다.  | {}      |\n| evict[]     | @CacheEvic 적용할 Annotation을 등록한다. | {}      |\n\n\n* @CacheConfig\n  * 클래스 단위로 캐시설정을 동일하게 하는데 사용\n  * 이 설정은 CacheManager가 여러개인 경우에만 사용\n  * Member조회 클래스에서는 Redis기반 캐시를 사용하고\n    Product 조회 클래스에서는 EHCache 기반 캐시를 사용할 때\n    각 클래스 별로 CacheManager를 지정 가능\n    \n| 속성          | 설명                                                         | Default |\n| ------------- | ------------------------------------------------------------ | ------- |\n| cacheNames    | 캐시 명                                                      | {}      |\n| keyGenerator  | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager  | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n\n\n\n# EHCache\n\n![EHCACHE](./EHCACHE.png)\n\n* EHCache는 오픈 소스 기반의 Local Cache이다. \n* 속도가 빠르며 경량 Cache라는 장점이 있다.\n* Disk, Memory 저장이 가능한 형태\n* 서버 간 분산 캐시를 지원한다 (동기/비동기 복제)\n* JSR107 JCache 표준을 지원한다. \n  따라서 JCache에서 제공하는 Annotation을 통해 이미 작성된 코드에 간단하게 기능 추가가 쉽다.\n>**JSR-107** : (JCACHE – Java Temporary Caching API) 객체 생성, 공유 액세스, 스풀링, 무효화 및 JVM 전반에 걸친 일관성을 포함하여 Java 객체의 메모리 캐싱에서 사용할 API 에 대한 기준으로 볼 수 있다.    해당 Spec 으로 구현된 cache로는 EhCache가 유명하며, Hazelcast, Infinispan, Couchbase, Redis, Caffeine 등도 해당 기준을 따르는 것으로 알려져 있다.\n\n\n\n# EHCache 설정 방법 \n\n내용이 길어 질 것 같아 별도의 포스트로 작성\n\n* [EHCache 설정방법 (Spring Framework)](http://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springframework/)\n* [EHCache 설정방법 (Spring Boot)]( http:/jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springboot/)\n\n\n\n\n# EHCache 예시 코드\n\n테스트 시나리오\n\n1. 가상으로 DBMS에서 데이터를 조회 하는 Repository를 생성\n2. 3초 정도 슬로우쿼리가 실행된다고 가정\n3. 최초 1회는 DB에서 조회, 2회차 부턴 캐시 사용\n4. 캐시를 조회했을 때, 걸리는 시간 확인\n5. 캐시가 만료되었을때, 걸리는 시간 확인\n\n~~~java\n@Slf4j\n@RestController\npublic class EHCacheController {\n\n    @Autowired\n    private EHCacheRepository repository;\n\n    @GetMapping(\"/data/{id}\")\n    public String getData(@PathVariable(\"id\") int id) throws InterruptedException {\n\n        long start = System.currentTimeMillis();\n        String data = repository.getData(id);\n        long end = System.currentTimeMillis();\n\n        log.info(\"쿼리 수행 시간 : {}ms\", end-start);\n        return data;\n    }\n\n    @GetMapping(\"/data/delete/{id}\")\n    public void getExpireCache(@PathVariable(\"id\") int id) {\n        repository.evictCache(id);\n    }\n}\n~~~\n\n```java\n@Slf4j\n@Repository\npublic class EHCacheRepository {\n\n    @Cacheable(cacheNames = \"testData\")\n    public String getData(int id) throws InterruptedException {\n        Thread.sleep(3000);\n        return \"test-data\";\n    }\n\n    @CacheEvict(cacheNames = \"testData\", allEntries = true)\n    public void evictCache(int id) {\n        log.info(\"delete cache all\");\n    }\n}\n```\n\n```java\n@Configuration\n@EnableCaching(proxyTargetClass = true, mode = AdviceMode.PROXY)\npublic class EHCacheConfig {\n    @Bean\n    public EhCacheManagerFactoryBean ehCacheManagerFactoryBean() {\n        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = new EhCacheManagerFactoryBean();\n        ehCacheManagerFactoryBean.setConfigLocation(new ClassPathResource(\"config/ehcache.xml\"));\n        ehCacheManagerFactoryBean.setShared(true);\n        return ehCacheManagerFactoryBean;\n    }\n\n    @Bean\n    public EhCacheCacheManager ehCacheCacheManager(EhCacheManagerFactoryBean ehCacheManagerFactoryBean) {\n        EhCacheCacheManager ehCacheCacheManager = new EhCacheCacheManager();\n        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());\n        return ehCacheCacheManager;\n    }\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         maxBytesLocalHeap=\"300M\"\n         updateCheck=\"false\">\n\n    <diskStore path=\"java.io.tmpdir\" />\n    <sizeOfPolicy maxDepth=\"100000\" maxDepthExceededBehavior=\"continue\"/>\n\n    <defaultCache\n            eternal=\"false\"\n            timeToIdleSeconds=\"0\"\n            timeToLiveSeconds=\"1200\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n\n    <cache name=\"LocalCacheData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n\n    <cache name=\"testData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"100\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n</ehcache>\n```\n\n<br/>\n\n결과\n\n![ehcache-test](./ehcache-test.png)\n\n1. 최초로 `GET localhost:8080/data/1` 요청 시, 3초 이상의 슬로우 쿼리가 실행\n2. 두번째로 동일하게 `GET localhost:8080/data/1` 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)\n3. `GET localhost:8080/data/delete/1` 요청으로 캐시 삭제\n4. `GET localhost:8080/data/1` 요청 시, 3초 이상의 슬로우 쿼리가 실행 (캐시 삭제 후 요청)\n5.  `GET localhost:8080/data/1` 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)\n\n> 주의 할 점! \n>\n> EHCache는 ehcache.xml 또는 Java 코드에서 addCache를 이용하여 반드시 Cache Key를 등록해 줘야 함\n> 이거를 안 등록하고 Cache Key를 막쓰다가.. 계속 Cache Key가 없다는 오류가 발생하여 잠깐 삽질..\n\n# 참고\n\n- http://www.ehcache.org/documentation/2.8/integrations/spring.html#introduction\n- https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache\n- http://blog.breakingthat.com/2018/03/19/springboot-ehcache-%EC%A0%81%EC%9A%A9/\n- https://jojoldu.tistory.com/57\n- http://www.ehcache.org/documentation/2.8/configuration/index.html\n- https://www.slideshare.net/heungrae_kim/spring-31-ehcache\n- https://shortstories.gitbooks.io/studybook/content/cache.html\n","slug":"2018-10-03-spring-ehcache","published":1,"updated":"2018-12-22T10:58:35.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv3tu0046cr1tw7jff952","content":"<h1 id=\"들어가며\">들어가며..</h1>\n<p>엔터프라이즈 급 Application에서는 DBMS의 부하를 줄이고, 성능을 높이기 위해 캐시(Cache)를 사용한다. 우리 회사에서도 EHCache, Redis를 사용하지만, EHCache쪽은 공부한 적이 없어서 이번 기회에 정리하면서 공부해 보게 되었다.\n대부분 <code>docs.spring.io</code>의 문서를 번역한 내용을 위주로 정리 하였다.</p>\n<h1 id=\"cache란\">Cache란?</h1>\n<p>Cache의 사전적인 의미를 알아보기 위해 위키백과를 검색해 보았다.</p>\n<blockquote>\n<p><strong>캐시</strong>(cache, <a href=\"https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4\" target=\"_blank\" rel=\"noopener\">문화어</a>: 캐쉬, 고속완충기, 고속완충기억기)는 <a href=\"https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99\" target=\"_blank\" rel=\"noopener\">컴퓨터 과학</a>에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 캐시는 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.</p>\n<p>캐시는 시스템의 효율성을 위해 여러 분야에서 두루 쓰인다.</p>\n</blockquote>\n<p>결국 캐시란, 반복적으로 데이터를 불러올 때 지속적으로 DBMS 혹은 서버에 요청하는 것이 아닌 메모리에 데이터를 저장하였다가 데이터를 불러다가 쓰는 것을 의미한다. 따라서 서버나 DBMS에 부담을 덜어주고, 엄청 빠르기 때문에 많은 시스템에서 사용하고 있다.\n대표적으로 Browser Cache, Apacha Cache, DNS Cache등 여러가지 형태로 캐시가 사용되고 있다.</p>\n<p>EHCache 사이트에서는 캐시에 대한 용어를 이렇게 정리 하였다.</p>\n<ul>\n<li><strong>Cache</strong> : 캐시는 <code>미래에 필요할 것이고 빠르게 검색할 수 있는 데이터를 담은 저장소</code> 라고 정의 한다. 캐시는 다른 곳에 있는 데이터를 복제하거나, 계산 결과를 임시적으로 저장하는 데이터 저장소이다. 캐시에 있는 데이터는 시간과 자원 면에서 최소한의 비용으로 반복적으로 접근 할 수 있다.</li>\n<li><strong>Cache Hit</strong> : 데이터 요소가 캐시에 요청되고 해당 키에 대한 요소가 존재하면 Cache Hit (또는 단순히 'Hit')라고 한다.</li>\n<li><strong>Cache Miss</strong>:데이터 요소가 캐시에 요청되고 해당 키에 대해 요소가 존재하지 않으면 Cache Miss (또는 단순히 'Miss')라고 한다.</li>\n<li><strong>System-of-record</strong> : 데이터에 대한 신뢰할 수있는 정보원. 이것을 흔히 시스템 레코드(SOR)이라고 한다. 캐시는 시스템 레코드에서 검색되거나 시스템 레코드에 저장된 데이터의 로컬 사본으로 작동된다. Ehcache를 사용하기 위해 SOR은 데이터베이스로 간주된다.</li>\n</ul>\n<h1 id=\"long-tail-법칙\">Long Tail 법칙</h1>\n<p><img src=\"./17110B4350CC5EC51D.jpeg\" alt=\"Long Tail\"></p>\n<p>20%의 요구가 시스템 리소스의 대부분을 잡아먹는다는 법칙.\n자주 사용되는 <code>20%의 기능에 캐시를 이용</code>하면 리소스 사용량을 대폭 줄일 수 있어, <code>시스템의 성능을 대폭 향상</code> 시킬 수 있다.</p>\n<h1 id=\"local-cache-vs-global-cache\">Local Cache vs Global Cache</h1>\n<ul>\n<li>\n<p>Local Cache</p>\n<ul>\n<li>Local 장비 내에서만 사용 되는 캐시</li>\n<li>Local 장비의 Resource를 이용한다 (Memory, Disk)</li>\n<li>Local에서 작동 되기 때문에 속도가 빠르다.</li>\n<li>Local에서만 작동되기 때문에 다른 서버와 데이터 공유가 어렵다</li>\n</ul>\n</li>\n<li>\n<p>Global Cache</p>\n<ul>\n<li>여러 서버에서 Cache Server에 접근하여 사용하는 캐시</li>\n<li>데이터를 분산하여 저장 할 수 있다.\n<ul>\n<li>Replication - 데이터를 복제</li>\n<li>Sharding - 데이터를 분산하여 저장</li>\n</ul>\n</li>\n<li>Local Cache에 비해 상대적으로 느리다 (네트워크 트래픽)</li>\n<li>별도의 Cache Server를 이용하기 때문에 서버 간 데이터 공유가 쉽다.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"spring-cache-abstraction\">Spring Cache Abstraction</h1>\n<p>Spring 3.1버전부터 Spring Application에 캐시를 쉽게 추가할 수 있도록 기능을 제공하게 되었다. 유사 트랜잭션을 지원하고, 사용하고 있는 코드(메소드)에 영향을 최소화 하면서 일관된 방법으로 캐시를 사용 할 수 있게 되었다.</p>\n<p>Spring에서 캐시 추상화는 메소드를 통해 기능을 지원하는데, 메소드가 실행되는 시점에 파라미터에 대한 캐시 존재 여부를 판단하여 없으면 캐시를 등록하게 되고, 캐시가 있으면 메소드를 실행 시키지 않고 캐시 데이터를 Return 해주게 된다.</p>\n<p>Spring 캐시 추상화를 지원하기 때문에 개발자는 별도의 캐시 로직을 작성하지 않아도 된다. 하지만 캐시를 저장하는 저장소는 직접 설정을 해주어야 한다. Spring에서는 <code>CacheManager</code>라는 Interface를 제공하여 캐시를 구현하도록 하고 있다.</p>\n<p>&lt;br/&gt;</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>Spring Boot에서는 <code>spring-boot-starter-cache</code> Artifact를 추가 하여 CacheManager를 구성 할 수 있다.\n기본적으로 별도의 추가적인 서드파티 모듈이 없는 경우에는 Local Memory에 저장이 가능한 ConcurrentMap기반인 <code>ConcurrentMapCacheManager</code>가 Bean으로 자동 생성 된다.</p>\n<p>이외에도 EHCache, Redis등의 서드파티 모듈을 추가 하게 되면 <code>EHCacheCacheManager</code>, <code>RedisCacheManager</code>를 Bean으로 등록 하여 사용할 수 있다. 이렇게 되면 별도로 다른 설정 없이도  단순 Memory Cache가 아닌 Cache Server를 대상으로 캐시를 저장 할 수 있도록 지원하고 있다.</p>\n<h1 id=\"spring-cache-annotation\">Spring Cache Annotation</h1>\n<p>Spring에서는 Cache Annotation을 지원하여 좀 더 쉽게 메서드에 대한 캐시를 제어할 수 있다.</p>\n<ul>\n<li>@EnableCaching\n<ul>\n<li>Annotation 기반 캐싱 설정을 사용 (내부적으로 Spring AOP 이용)</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>proxyTargetClass</td>\n<td>클래스 기반의 Proxy생성 여부&lt;br /&gt;false인 경우 JDK Dynamic Proxy 사용 (Interface 기반)&lt;br /&gt;true인 경우 CGLIB Proxy 사용 (Class 기반)</td>\n<td>false</td>\n</tr>\n<tr>\n<td>mode</td>\n<td>위빙 (Weaving) 모드에 대한 설정&lt;br /&gt;PROXY : 기존의 Spring AOP 방식을 이용한 RTW방식 사용&lt;br /&gt;ASPECTJ : aspectj 라이브러리를 이용한 CTW, LTW 방식 지원</td>\n<td>PROXY</td>\n</tr>\n<tr>\n<td>order</td>\n<td>AOP order 설정</td>\n<td>Integer.MAX_VALUE</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@Cacheable\n<ul>\n<li>캐싱할 수 있는 메서드를 지정하기 위해 사용</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value, cacheName</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용&lt;br /&gt;4.0이후 버전 부터 SimpleKeyGenerator를 사용&lt;br /&gt;Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)&lt;br /&gt;CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용&lt;br /&gt;and, or 표현식등을 통해 복수 조건 사용가능&lt;br /&gt;연산 조건이 <code>true</code>인 경우에만 캐싱</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>unless</td>\n<td>캐싱이 이루어지지 않는 조건을 설정&lt;br /&gt;연산 조건이 <code>true</code> 이면 경우에는 캐싱되지 않는다&lt;br /&gt;예시 : id가 null아 아닌 경우에만 캐싱 (unless = &quot;#id == null&quot;)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>캐시 구현체가 Thread safe 하지 않는 경우, 자체적으로 캐시에 동기화를 거는 속성</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@CacheEvict\n<ul>\n<li>메서드 실행 시, 해당 캐시를 삭제</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value, cacheName</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용&lt;br /&gt;4.0이후 버전 부터 SimpleKeyGenerator를 사용&lt;br /&gt;Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)&lt;br /&gt;CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용&lt;br /&gt;and, or 표현식등을 통해 복수 조건 사용가능&lt;br /&gt;연산 조건이 <code>true</code>인 경우에만 캐시 삭제</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>allEntries</td>\n<td>Cache Key에 대한 전체 데이터 삭제 여부</td>\n<td>false</td>\n</tr>\n<tr>\n<td>beforeInvocation</td>\n<td>true면 메서드 실행 이전에 캐시 삭제, false면 메서드 실행 이후 삭제</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@CachePut\n<ul>\n<li>메서드 실행에 영향을 주지 않고 캐시를 갱신해야 하는 경우 사용</li>\n<li>보통은 @Cacheable과 @CachePut Annotation을 같이 사용하지 않는다.\n(둘은 다른 동작을 하기 때문에, 실행순서에 따라 다른 결과가 나올 수 있다.)</li>\n<li>@CachePut Annotation은 캐시 생성용으로만 사용한다.</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value, cacheName</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용&lt;br /&gt;4.0이후 버전 부터 SimpleKeyGenerator를 사용&lt;br /&gt;Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)&lt;br /&gt;CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용&lt;br /&gt;and, or 표현식등을 통해 복수 조건 사용가능&lt;br /&gt;연산 조건이 <code>true</code>인 경우에만 캐싱</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>unless</td>\n<td>캐싱이 이루어지지 않는 조건을 설정&lt;br /&gt;연산 조건이 <code>true</code> 이면 경우에는 캐싱되지 않는다&lt;br /&gt;예시 : id가 null아 아닌 경우에만 캐싱 (unless = &quot;#id == null&quot;)</td>\n<td>&quot;&quot;</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@Caching\n<ul>\n<li>@CacheEvict이나 @CachePut을 여러개 지정해야 하는 경우에 사용</li>\n<li>조건식이나 표현식이 다른 경우에 사용한다.</li>\n<li>여러가지의 key에 대한 캐시를 중첩적으로 삭제해야 할 때 사용</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cacheable[]</td>\n<td>@Cacheable 적용할 Annotation을 등록한다.</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>put[]</td>\n<td>@CachePut 적용할 Annotation을 등록한다.</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>evict[]</td>\n<td>@CacheEvic 적용할 Annotation을 등록한다.</td>\n<td>{}</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@CacheConfig\n<ul>\n<li>클래스 단위로 캐시설정을 동일하게 하는데 사용</li>\n<li>이 설정은 CacheManager가 여러개인 경우에만 사용</li>\n<li>Member조회 클래스에서는 Redis기반 캐시를 사용하고\nProduct 조회 클래스에서는 EHCache 기반 캐시를 사용할 때\n각 클래스 별로 CacheManager를 지정 가능</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cacheNames</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용&lt;br /&gt;4.0이후 버전 부터 SimpleKeyGenerator를 사용&lt;br /&gt;Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)&lt;br /&gt;CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>&quot;&quot;</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"ehcache\">EHCache</h1>\n<p><img src=\"./EHCACHE.png\" alt=\"EHCACHE\"></p>\n<ul>\n<li>EHCache는 오픈 소스 기반의 Local Cache이다.</li>\n<li>속도가 빠르며 경량 Cache라는 장점이 있다.</li>\n<li>Disk, Memory 저장이 가능한 형태</li>\n<li>서버 간 분산 캐시를 지원한다 (동기/비동기 복제)</li>\n<li>JSR107 JCache 표준을 지원한다.\n따라서 JCache에서 제공하는 Annotation을 통해 이미 작성된 코드에 간단하게 기능 추가가 쉽다.</li>\n</ul>\n<blockquote>\n<p><strong>JSR-107</strong> : (JCACHE – Java Temporary Caching API) 객체 생성, 공유 액세스, 스풀링, 무효화 및 JVM 전반에 걸친 일관성을 포함하여 Java 객체의 메모리 캐싱에서 사용할 API 에 대한 기준으로 볼 수 있다.    해당 Spec 으로 구현된 cache로는 EhCache가 유명하며, Hazelcast, Infinispan, Couchbase, Redis, Caffeine 등도 해당 기준을 따르는 것으로 알려져 있다.</p>\n</blockquote>\n<h1 id=\"ehcache-설정-방법\">EHCache 설정 방법</h1>\n<p>내용이 길어 질 것 같아 별도의 포스트로 작성</p>\n<ul>\n<li><a href=\"http://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springframework/\">EHCache 설정방법 (Spring Framework)</a></li>\n<li><a href=\"http:/jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springboot/\" target=\"_blank\" rel=\"noopener\">EHCache 설정방법 (Spring Boot)</a></li>\n</ul>\n<h1 id=\"ehcache-예시-코드\">EHCache 예시 코드</h1>\n<p>테스트 시나리오</p>\n<ol>\n<li>가상으로 DBMS에서 데이터를 조회 하는 Repository를 생성</li>\n<li>3초 정도 슬로우쿼리가 실행된다고 가정</li>\n<li>최초 1회는 DB에서 조회, 2회차 부턴 캐시 사용</li>\n<li>캐시를 조회했을 때, 걸리는 시간 확인</li>\n<li>캐시가 만료되었을때, 걸리는 시간 확인</li>\n</ol>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EHCacheRepository repository;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/data/&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getData</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id) <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        String data = repository.getData(id);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">        log.info(<span class=\"string\">\"쿼리 수행 시간 : &#123;&#125;ms\"</span>, end-start);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/data/delete/&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getExpireCache</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id) </span>&#123;</span><br><span class=\"line\">        repository.evictCache(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheRepository</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Cacheable</span>(cacheNames = <span class=\"string\">\"testData\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getData</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"test-data\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CacheEvict</span>(cacheNames = <span class=\"string\">\"testData\"</span>, allEntries = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">evictCache</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"delete cache all\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>, mode = AdviceMode.PROXY)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheManagerFactoryBean <span class=\"title\">ehCacheManagerFactoryBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = <span class=\"keyword\">new</span> EhCacheManagerFactoryBean();</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setConfigLocation(<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">\"config/ehcache.xml\"</span>));</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setShared(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheManagerFactoryBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheCacheManager <span class=\"title\">ehCacheCacheManager</span><span class=\"params\">(EhCacheManagerFactoryBean ehCacheManagerFactoryBean)</span> </span>&#123;</span><br><span class=\"line\">        EhCacheCacheManager ehCacheCacheManager = <span class=\"keyword\">new</span> EhCacheCacheManager();</span><br><span class=\"line\">        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheCacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://ehcache.org/ehcache.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">maxBytesLocalHeap</span>=<span class=\"string\">\"300M\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">updateCheck</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sizeOfPolicy</span> <span class=\"attr\">maxDepth</span>=<span class=\"string\">\"100000\"</span> <span class=\"attr\">maxDepthExceededBehavior</span>=<span class=\"string\">\"continue\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultCache</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">defaultCache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"LocalCacheData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"testData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"100\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>&lt;br/&gt;</p>\n<p>결과</p>\n<p><img src=\"./ehcache-test.png\" alt=\"ehcache-test\"></p>\n<ol>\n<li>최초로 <code>GET localhost:8080/data/1</code> 요청 시, 3초 이상의 슬로우 쿼리가 실행</li>\n<li>두번째로 동일하게 <code>GET localhost:8080/data/1</code> 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)</li>\n<li><code>GET localhost:8080/data/delete/1</code> 요청으로 캐시 삭제</li>\n<li><code>GET localhost:8080/data/1</code> 요청 시, 3초 이상의 슬로우 쿼리가 실행 (캐시 삭제 후 요청)</li>\n<li><code>GET localhost:8080/data/1</code> 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)</li>\n</ol>\n<blockquote>\n<p>주의 할 점!</p>\n<p>EHCache는 ehcache.xml 또는 Java 코드에서 addCache를 이용하여 반드시 Cache Key를 등록해 줘야 함\n이거를 안 등록하고 Cache Key를 막쓰다가.. 계속 Cache Key가 없다는 오류가 발생하여 잠깐 삽질..</p>\n</blockquote>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>http://www.ehcache.org/documentation/2.8/integrations/spring.html#introduction</li>\n<li>https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache</li>\n<li>http://blog.breakingthat.com/2018/03/19/springboot-ehcache-%EC%A0%81%EC%9A%A9/</li>\n<li>https://jojoldu.tistory.com/57</li>\n<li>http://www.ehcache.org/documentation/2.8/configuration/index.html</li>\n<li>https://www.slideshare.net/heungrae_kim/spring-31-ehcache</li>\n<li>https://shortstories.gitbooks.io/studybook/content/cache.html</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>들어가며..</h1>\n<p>엔터프라이즈 급 Application에서는 DBMS의 부하를 줄이고, 성능을 높이기 위해 캐시(Cache)를 사용한다. 우리 회사에서도 EHCache, Redis를 사용하지만, EHCache쪽은 공부한 적이 없어서 이번 기회에 정리하면서 공부해 보게 되었다.\n대부분 <code>docs.spring.io</code>의 문서를 번역한 내용을 위주로 정리 하였다.</p>\n<h1>Cache란?</h1>\n<p>Cache의 사전적인 의미를 알아보기 위해 위키백과를 검색해 보았다.</p>\n<blockquote>\n<p><strong>캐시</strong>(cache, <a href=\"https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4\" target=\"_blank\" rel=\"noopener\">문화어</a>: 캐쉬, 고속완충기, 고속완충기억기)는 <a href=\"https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99\" target=\"_blank\" rel=\"noopener\">컴퓨터 과학</a>에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 캐시는 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.</p>\n<p>캐시는 시스템의 효율성을 위해 여러 분야에서 두루 쓰인다.</p>\n</blockquote>\n<p>결국 캐시란, 반복적으로 데이터를 불러올 때 지속적으로 DBMS 혹은 서버에 요청하는 것이 아닌 메모리에 데이터를 저장하였다가 데이터를 불러다가 쓰는 것을 의미한다. 따라서 서버나 DBMS에 부담을 덜어주고, 엄청 빠르기 때문에 많은 시스템에서 사용하고 있다.\n대표적으로 Browser Cache, Apacha Cache, DNS Cache등 여러가지 형태로 캐시가 사용되고 있다.</p>\n<p>EHCache 사이트에서는 캐시에 대한 용어를 이렇게 정리 하였다.</p>\n<ul>\n<li><strong>Cache</strong> : 캐시는 <code>미래에 필요할 것이고 빠르게 검색할 수 있는 데이터를 담은 저장소</code> 라고 정의 한다. 캐시는 다른 곳에 있는 데이터를 복제하거나, 계산 결과를 임시적으로 저장하는 데이터 저장소이다. 캐시에 있는 데이터는 시간과 자원 면에서 최소한의 비용으로 반복적으로 접근 할 수 있다.</li>\n<li><strong>Cache Hit</strong> : 데이터 요소가 캐시에 요청되고 해당 키에 대한 요소가 존재하면 Cache Hit (또는 단순히 'Hit')라고 한다.</li>\n<li><strong>Cache Miss</strong>:데이터 요소가 캐시에 요청되고 해당 키에 대해 요소가 존재하지 않으면 Cache Miss (또는 단순히 'Miss')라고 한다.</li>\n<li><strong>System-of-record</strong> : 데이터에 대한 신뢰할 수있는 정보원. 이것을 흔히 시스템 레코드(SOR)이라고 한다. 캐시는 시스템 레코드에서 검색되거나 시스템 레코드에 저장된 데이터의 로컬 사본으로 작동된다. Ehcache를 사용하기 위해 SOR은 데이터베이스로 간주된다.</li>\n</ul>\n<h1>Long Tail 법칙</h1>\n<p><img src=\"./17110B4350CC5EC51D.jpeg\" alt=\"Long Tail\"></p>\n<p>20%의 요구가 시스템 리소스의 대부분을 잡아먹는다는 법칙.\n자주 사용되는 <code>20%의 기능에 캐시를 이용</code>하면 리소스 사용량을 대폭 줄일 수 있어, <code>시스템의 성능을 대폭 향상</code> 시킬 수 있다.</p>\n<h1>Local Cache vs Global Cache</h1>\n<ul>\n<li>\n<p>Local Cache</p>\n<ul>\n<li>Local 장비 내에서만 사용 되는 캐시</li>\n<li>Local 장비의 Resource를 이용한다 (Memory, Disk)</li>\n<li>Local에서 작동 되기 때문에 속도가 빠르다.</li>\n<li>Local에서만 작동되기 때문에 다른 서버와 데이터 공유가 어렵다</li>\n</ul>\n</li>\n<li>\n<p>Global Cache</p>\n<ul>\n<li>여러 서버에서 Cache Server에 접근하여 사용하는 캐시</li>\n<li>데이터를 분산하여 저장 할 수 있다.\n<ul>\n<li>Replication - 데이터를 복제</li>\n<li>Sharding - 데이터를 분산하여 저장</li>\n</ul>\n</li>\n<li>Local Cache에 비해 상대적으로 느리다 (네트워크 트래픽)</li>\n<li>별도의 Cache Server를 이용하기 때문에 서버 간 데이터 공유가 쉽다.</li>\n</ul>\n</li>\n</ul>\n<h1>Spring Cache Abstraction</h1>\n<p>Spring 3.1버전부터 Spring Application에 캐시를 쉽게 추가할 수 있도록 기능을 제공하게 되었다. 유사 트랜잭션을 지원하고, 사용하고 있는 코드(메소드)에 영향을 최소화 하면서 일관된 방법으로 캐시를 사용 할 수 있게 되었다.</p>\n<p>Spring에서 캐시 추상화는 메소드를 통해 기능을 지원하는데, 메소드가 실행되는 시점에 파라미터에 대한 캐시 존재 여부를 판단하여 없으면 캐시를 등록하게 되고, 캐시가 있으면 메소드를 실행 시키지 않고 캐시 데이터를 Return 해주게 된다.</p>\n<p>Spring 캐시 추상화를 지원하기 때문에 개발자는 별도의 캐시 로직을 작성하지 않아도 된다. 하지만 캐시를 저장하는 저장소는 직접 설정을 해주어야 한다. Spring에서는 <code>CacheManager</code>라는 Interface를 제공하여 캐시를 구현하도록 하고 있다.</p>\n<p>&lt;br/&gt;</p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>Spring Boot에서는 <code>spring-boot-starter-cache</code> Artifact를 추가 하여 CacheManager를 구성 할 수 있다.\n기본적으로 별도의 추가적인 서드파티 모듈이 없는 경우에는 Local Memory에 저장이 가능한 ConcurrentMap기반인 <code>ConcurrentMapCacheManager</code>가 Bean으로 자동 생성 된다.</p>\n<p>이외에도 EHCache, Redis등의 서드파티 모듈을 추가 하게 되면 <code>EHCacheCacheManager</code>, <code>RedisCacheManager</code>를 Bean으로 등록 하여 사용할 수 있다. 이렇게 되면 별도로 다른 설정 없이도  단순 Memory Cache가 아닌 Cache Server를 대상으로 캐시를 저장 할 수 있도록 지원하고 있다.</p>\n<h1>Spring Cache Annotation</h1>\n<p>Spring에서는 Cache Annotation을 지원하여 좀 더 쉽게 메서드에 대한 캐시를 제어할 수 있다.</p>\n<ul>\n<li>@EnableCaching\n<ul>\n<li>Annotation 기반 캐싱 설정을 사용 (내부적으로 Spring AOP 이용)</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>proxyTargetClass</td>\n<td>클래스 기반의 Proxy생성 여부&lt;br /&gt;false인 경우 JDK Dynamic Proxy 사용 (Interface 기반)&lt;br /&gt;true인 경우 CGLIB Proxy 사용 (Class 기반)</td>\n<td>false</td>\n</tr>\n<tr>\n<td>mode</td>\n<td>위빙 (Weaving) 모드에 대한 설정&lt;br /&gt;PROXY : 기존의 Spring AOP 방식을 이용한 RTW방식 사용&lt;br /&gt;ASPECTJ : aspectj 라이브러리를 이용한 CTW, LTW 방식 지원</td>\n<td>PROXY</td>\n</tr>\n<tr>\n<td>order</td>\n<td>AOP order 설정</td>\n<td>Integer.MAX_VALUE</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@Cacheable\n<ul>\n<li>캐싱할 수 있는 메서드를 지정하기 위해 사용</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value, cacheName</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용&lt;br /&gt;4.0이후 버전 부터 SimpleKeyGenerator를 사용&lt;br /&gt;Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)&lt;br /&gt;CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용&lt;br /&gt;and, or 표현식등을 통해 복수 조건 사용가능&lt;br /&gt;연산 조건이 <code>true</code>인 경우에만 캐싱</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>unless</td>\n<td>캐싱이 이루어지지 않는 조건을 설정&lt;br /&gt;연산 조건이 <code>true</code> 이면 경우에는 캐싱되지 않는다&lt;br /&gt;예시 : id가 null아 아닌 경우에만 캐싱 (unless = &quot;#id == null&quot;)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>캐시 구현체가 Thread safe 하지 않는 경우, 자체적으로 캐시에 동기화를 거는 속성</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@CacheEvict\n<ul>\n<li>메서드 실행 시, 해당 캐시를 삭제</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value, cacheName</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용&lt;br /&gt;4.0이후 버전 부터 SimpleKeyGenerator를 사용&lt;br /&gt;Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)&lt;br /&gt;CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용&lt;br /&gt;and, or 표현식등을 통해 복수 조건 사용가능&lt;br /&gt;연산 조건이 <code>true</code>인 경우에만 캐시 삭제</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>allEntries</td>\n<td>Cache Key에 대한 전체 데이터 삭제 여부</td>\n<td>false</td>\n</tr>\n<tr>\n<td>beforeInvocation</td>\n<td>true면 메서드 실행 이전에 캐시 삭제, false면 메서드 실행 이후 삭제</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@CachePut\n<ul>\n<li>메서드 실행에 영향을 주지 않고 캐시를 갱신해야 하는 경우 사용</li>\n<li>보통은 @Cacheable과 @CachePut Annotation을 같이 사용하지 않는다.\n(둘은 다른 동작을 하기 때문에, 실행순서에 따라 다른 결과가 나올 수 있다.)</li>\n<li>@CachePut Annotation은 캐시 생성용으로만 사용한다.</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value, cacheName</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용&lt;br /&gt;4.0이후 버전 부터 SimpleKeyGenerator를 사용&lt;br /&gt;Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)&lt;br /&gt;CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용&lt;br /&gt;and, or 표현식등을 통해 복수 조건 사용가능&lt;br /&gt;연산 조건이 <code>true</code>인 경우에만 캐싱</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>unless</td>\n<td>캐싱이 이루어지지 않는 조건을 설정&lt;br /&gt;연산 조건이 <code>true</code> 이면 경우에는 캐싱되지 않는다&lt;br /&gt;예시 : id가 null아 아닌 경우에만 캐싱 (unless = &quot;#id == null&quot;)</td>\n<td>&quot;&quot;</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@Caching\n<ul>\n<li>@CacheEvict이나 @CachePut을 여러개 지정해야 하는 경우에 사용</li>\n<li>조건식이나 표현식이 다른 경우에 사용한다.</li>\n<li>여러가지의 key에 대한 캐시를 중첩적으로 삭제해야 할 때 사용</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cacheable[]</td>\n<td>@Cacheable 적용할 Annotation을 등록한다.</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>put[]</td>\n<td>@CachePut 적용할 Annotation을 등록한다.</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>evict[]</td>\n<td>@CacheEvic 적용할 Annotation을 등록한다.</td>\n<td>{}</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@CacheConfig\n<ul>\n<li>클래스 단위로 캐시설정을 동일하게 하는데 사용</li>\n<li>이 설정은 CacheManager가 여러개인 경우에만 사용</li>\n<li>Member조회 클래스에서는 Redis기반 캐시를 사용하고\nProduct 조회 클래스에서는 EHCache 기반 캐시를 사용할 때\n각 클래스 별로 CacheManager를 지정 가능</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cacheNames</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용&lt;br /&gt;4.0이후 버전 부터 SimpleKeyGenerator를 사용&lt;br /&gt;Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>&quot;&quot;</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)&lt;br /&gt;CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>&quot;&quot;</td>\n</tr>\n</tbody>\n</table>\n<h1>EHCache</h1>\n<p><img src=\"./EHCACHE.png\" alt=\"EHCACHE\"></p>\n<ul>\n<li>EHCache는 오픈 소스 기반의 Local Cache이다.</li>\n<li>속도가 빠르며 경량 Cache라는 장점이 있다.</li>\n<li>Disk, Memory 저장이 가능한 형태</li>\n<li>서버 간 분산 캐시를 지원한다 (동기/비동기 복제)</li>\n<li>JSR107 JCache 표준을 지원한다.\n따라서 JCache에서 제공하는 Annotation을 통해 이미 작성된 코드에 간단하게 기능 추가가 쉽다.</li>\n</ul>\n<blockquote>\n<p><strong>JSR-107</strong> : (JCACHE – Java Temporary Caching API) 객체 생성, 공유 액세스, 스풀링, 무효화 및 JVM 전반에 걸친 일관성을 포함하여 Java 객체의 메모리 캐싱에서 사용할 API 에 대한 기준으로 볼 수 있다.    해당 Spec 으로 구현된 cache로는 EhCache가 유명하며, Hazelcast, Infinispan, Couchbase, Redis, Caffeine 등도 해당 기준을 따르는 것으로 알려져 있다.</p>\n</blockquote>\n<h1>EHCache 설정 방법</h1>\n<p>내용이 길어 질 것 같아 별도의 포스트로 작성</p>\n<ul>\n<li><a href=\"http://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springframework/\">EHCache 설정방법 (Spring Framework)</a></li>\n<li><a href=\"http:/jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springboot/\" target=\"_blank\" rel=\"noopener\">EHCache 설정방법 (Spring Boot)</a></li>\n</ul>\n<h1>EHCache 예시 코드</h1>\n<p>테스트 시나리오</p>\n<ol>\n<li>가상으로 DBMS에서 데이터를 조회 하는 Repository를 생성</li>\n<li>3초 정도 슬로우쿼리가 실행된다고 가정</li>\n<li>최초 1회는 DB에서 조회, 2회차 부턴 캐시 사용</li>\n<li>캐시를 조회했을 때, 걸리는 시간 확인</li>\n<li>캐시가 만료되었을때, 걸리는 시간 확인</li>\n</ol>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EHCacheRepository repository;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/data/&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getData</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id) <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        String data = repository.getData(id);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">        log.info(<span class=\"string\">\"쿼리 수행 시간 : &#123;&#125;ms\"</span>, end-start);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/data/delete/&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getExpireCache</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id) </span>&#123;</span><br><span class=\"line\">        repository.evictCache(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheRepository</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Cacheable</span>(cacheNames = <span class=\"string\">\"testData\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getData</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"test-data\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CacheEvict</span>(cacheNames = <span class=\"string\">\"testData\"</span>, allEntries = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">evictCache</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"delete cache all\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>, mode = AdviceMode.PROXY)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheManagerFactoryBean <span class=\"title\">ehCacheManagerFactoryBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = <span class=\"keyword\">new</span> EhCacheManagerFactoryBean();</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setConfigLocation(<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">\"config/ehcache.xml\"</span>));</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setShared(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheManagerFactoryBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheCacheManager <span class=\"title\">ehCacheCacheManager</span><span class=\"params\">(EhCacheManagerFactoryBean ehCacheManagerFactoryBean)</span> </span>&#123;</span><br><span class=\"line\">        EhCacheCacheManager ehCacheCacheManager = <span class=\"keyword\">new</span> EhCacheCacheManager();</span><br><span class=\"line\">        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheCacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://ehcache.org/ehcache.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">maxBytesLocalHeap</span>=<span class=\"string\">\"300M\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">updateCheck</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sizeOfPolicy</span> <span class=\"attr\">maxDepth</span>=<span class=\"string\">\"100000\"</span> <span class=\"attr\">maxDepthExceededBehavior</span>=<span class=\"string\">\"continue\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultCache</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">defaultCache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"LocalCacheData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"testData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"100\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>&lt;br/&gt;</p>\n<p>결과</p>\n<p><img src=\"./ehcache-test.png\" alt=\"ehcache-test\"></p>\n<ol>\n<li>최초로 <code>GET localhost:8080/data/1</code> 요청 시, 3초 이상의 슬로우 쿼리가 실행</li>\n<li>두번째로 동일하게 <code>GET localhost:8080/data/1</code> 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)</li>\n<li><code>GET localhost:8080/data/delete/1</code> 요청으로 캐시 삭제</li>\n<li><code>GET localhost:8080/data/1</code> 요청 시, 3초 이상의 슬로우 쿼리가 실행 (캐시 삭제 후 요청)</li>\n<li><code>GET localhost:8080/data/1</code> 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)</li>\n</ol>\n<blockquote>\n<p>주의 할 점!</p>\n<p>EHCache는 ehcache.xml 또는 Java 코드에서 addCache를 이용하여 반드시 Cache Key를 등록해 줘야 함\n이거를 안 등록하고 Cache Key를 막쓰다가.. 계속 Cache Key가 없다는 오류가 발생하여 잠깐 삽질..</p>\n</blockquote>\n<h1>참고</h1>\n<ul>\n<li>http://www.ehcache.org/documentation/2.8/integrations/spring.html#introduction</li>\n<li>https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache</li>\n<li>http://blog.breakingthat.com/2018/03/19/springboot-ehcache-%EC%A0%81%EC%9A%A9/</li>\n<li>https://jojoldu.tistory.com/57</li>\n<li>http://www.ehcache.org/documentation/2.8/configuration/index.html</li>\n<li>https://www.slideshare.net/heungrae_kim/spring-31-ehcache</li>\n<li>https://shortstories.gitbooks.io/studybook/content/cache.html</li>\n</ul>\n"},{"layout":"posts","title":"SpEL Expression(2)","catalog":true,"Categories":["Spring"],"date":"2018-11-25T08:11:42.000Z","typora-root-url":"2018-11-25-spel-expression-2","typora-copy-images-to":"2018-11-25-spel-expression-2","_content":"\n# 리터럴 표현식 (Literal Expression)\n\n리터럴 표현식을 제공하는 타입은 문자열(String), 숫자(int, real, hex), boolean, null이다.\n\n* 문자열 (Strings)는 따옴표(')로 구분된다 `(쌍따옴표가 아님)` \\- 문자열 표현 시\\, `'Hello World'` 처럼 SpEL을 작성\n\n다음은 리터럴 표현식 (Literal Expression)에 대한 간단한 예제이다.\n\n``` java\nExpressionParser parser = new SpelExpressionParser();\n\n//따옴표로 이루어진 'Hello World' => Hello World라는 문자열로 평가 된다.\nString helloWorld = (String) parser.parseExpression(\"'Hello World'\").getValue();\n//Double 타입의 숫자로 평가\ndouble avogadrosNumber = (Double) parser.parseExpression(\"6.0221415E+23\").getValue();\n//2147483647로 평가\nint maxValue = (Integer) parser.parseExpression(\"0x7FFFFFFF\").getValue();\n\nboolean trueValue = (Boolean) parser.parseExpression(\"true\").getValue();\n//null로 평가 된다. -> null String이 아니다. (주의)\nObject nullValue = parser.parseExpression(\"null\").getValue();\n```\n\n* 숫자는 음수기호(-), 지수표시(E), 소수점(.)을 지원한다.\n* 기본적으로 실제 숫자는 Double.parseDouble()로 파싱한다.\n\n# 메서드 호출\n\n``` java\n//String 리터럴 abc에 대한 substring 메서드 호출 -> bc가 리턴된다.\nString c = parser.parseExpression(\"'abc'.substring(2, 3)\").getValue(String.class);\n\n//사용자 정의 메서드 호출 (Return Type : Boolean) -> boolean 타입으로 평가된다.\nboolean isMember = parser.parseExpression(\"isMember('Mihajlo Pupin')\").getValue(\n        societyContext, Boolean.class);\n```\n\n위의 코드는 메서드 호출에 대한 예제 코드이다.\n\n* 메서드는 Java 문법을 사용하여 호출 할 수 있다.\n* Literal에 대한 메서드 호출도 가능하다.\n* Varargs 형식의 파라미터도 지원하고 있다.\n\n# 프로퍼티, 배열, 리스트, 맵에 대한 접근 지원\n\n``` java\nExpressionParser parser = new SpelExpressionParser();\n\n// 발명품 배열\nStandardEvaluationContext teslaContext = new StandardEvaluationContext(tesla);\n\n// \"Induction motor\"로 평가된다.\nString invention = parser.parseExpression(\"inventions[3]\").getValue(teslaContext, String.class); \n\n// 회원 리스트\nStandardEvaluationContext societyContext = new StandardEvaluationContext(ieee);\n\n// \"Nikola Tesla\"로 평가된다.\nString name = parser.parseExpression(\"Members[0].Name\").getValue(societyContext, String.class);\n\n// 리스트와 배열 탐색\n// \"Wireless communication\"로 평가된다.\nString invention = parser.parseExpression(\"Members[0].Inventions[6]\").getValue(societyContext, String.class);\n```\n\n* 프로퍼티의 맨 첫글자는 대소문자를 구별하지 않는다.\n* SpEL은 표준 `dot 표기법`(예: prop1.prop2.prop3)을 사용해서 중첩된 프로퍼티와 프로퍼티의 값 설정도 지원한다.\n* public 필드에 대한 접근을 지원한다.\n\n``` java\n// Officer의 딕션어리\nInventor pupin = parser.parseExpression(\"Officers['president']\").getValue(societyContext, Inventor.class);\n\n// \"Idvor\"로 평가된다\nString city = parser.parseExpression(\"Officers['president'].PlaceOfBirth.City\").getValue(societyContext, String.class);\n\n// 값을 설정한다\nparser.parseExpression(\"Officers['advisors'][0].PlaceOfBirth.Country\").setValue(societyContext, \"Croatia\");\n```\n\n* 대괄호`[]` 를 사용하여 Map의 key를 바탕으로 데이터에 접근한다.\n  (위의 예제에서는 Officers가 `Map`, president가 `key`이다.)\n* SpEL은 표준 'dot' 표기법(예: prop1.prop2.prop3)을 사용해서 Map내의 value 객체의 프로퍼티에도 접근 가능하다.\n* setValue 메서드를 통해 데이터를 수정할 수 있다.\n\n# 인라인 리스트 (Inline list)\n\n리스트는 {} 표기법을 사용하여 리스트로 사용 할 수 있다.\n\n``` java\n// 4개의 숫자를 담고 있는 리스트로 평가된다\nList<Integer> numbers = (List) parser.parseExpression(\"{1,2,3,4}\").getValue(context); \n\n//List의 List의 형태의 List로 평가된다.\n//listOfLists[0] = {'a', 'b'}\n//listOfLists[1] = {'x', 'y'}\nList listOfLists = (List) parser.parseExpression(\"{{'a','b'},{'x','y'}}\").getValue(context);\n```\n\n# 배열 생성\n\n``` java\nint[] numbers1 = (int[]) parser.parseExpression(\"new int[4]\").getValue(context); \n\n// initializer가진 배열\nint[] numbers2 = (int[]) parser.parseExpression(\"new int[]{1,2,3}\").getValue(context); \n\n// 다차원 배열\nint[][] numbers3 = (int[][]) parser.parseExpression(\"new int[4][5]\").getValue(context);\n```\n\n* Java 문법과 같은 표현식을 사용하여 배열을 생성 할 수 있다.\n* {} 표현식을 통해 초기값을 세팅할 수 있다.\n* 2차원 배열이상의 다차원 배열도 선언이 가능하다. (`단, 다차원 배열은 초기값을 설정할 수 없다.`)\n\n# 연산자\n\n## 관계 연산자\n\n표준 관계 연산자를 사용한다. 사용 할 수 있는 관계 연산자는 아래와 같다.\n\n* 같음 (`==`)\n* 같지 않음 (`!=`)\n* 작음 (`<`)\n* 작거나 같음 (`<=`)\n* 큼 (`>`)\n* 크거나 같음 (`>=`)\n\n``` java\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"2 == 2\").getValue(Boolean.class);\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"2 < -5.0\").getValue(Boolean.class);\n\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"'black' < 'block'\").getValue(Boolean.class);\n```\n\n## 심볼릭 연산자\n\nXML과 같이 문서형식에 관계 연산자가 제한을 받는 경우, 사용 가능한 문자 표현식을 제공한다.\n연산자에 대한 대소문자는 구별하지 않는다.\n\n* 같음 (`eq`)\n* 같지 않음 (`ne`)\n* 작음 (`lt`)\n* 작거나 같음 (`le`)\n* 큼 (`gt`)\n* 크거나 같음 (`gt`)\n* div (`/`)\n* mod (`%`)\n* not (`!`)\n\n``` java\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"22 eq 22\").getValue(Boolean.class);\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"'test' eq 'test!'\").getValue(Boolean.class);\n```\n\n## 정규 표현식\n\nmatches를 이용한 정규표현식을 지원한다.\n\n``` java\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"'5.00' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n```\n\n## instanceof\n\nJava에서 super타입에 대한 연산을 위해 instanceof를 표현식으로 사용할 수 있다.\n\n``` java\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"'xyz' instanceof T(int)\").getValue(Boolean.class);\n\n// true로 평가된다.\nboolean trueValue = parser.parseExpression(\"'xyz' instanceof T(String)\").getValue(Boolean.class);\n```\n\n## 논리연산자\n\nAND, OR, NOT에 대한 표현식을 지원한다.\n\n``` java\n// -- AND --\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"true and false\").getValue(Boolean.class);\n\n// true로 평가된다\nString expression =  \"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\";\nboolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n\n// -- OR --\n\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"true or false\").getValue(Boolean.class);\n\n// true로 평가된다\nString expression =  \"isMember('Nikola Tesla') or isMember('Albert Einstien')\";\nboolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n\n// -- NOT --\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"!true\").getValue(Boolean.class);\n\n// -- AND and NOT --\nString expression =  \"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\";\nboolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n```\n\n## 수식 연산자\n\n* 더하기 (+) 연산자를 숫자, 날짜, 문자열에 사용할 수 있다.\n* 빼기(-) 연산자를 숫자, 날짜에 사용할 수 있다.\n* 곱하기(*), 나누기(/), 나머지(%)에 대한 연산은 숫자에만 사용 할 수 있다.\n* 연산자 우선 순위 법칙이 적용된다.\n\n``` java\n// 더하기\nint two = parser.parseExpression(\"1 + 1\").getValue(Integer.class); // 2\nString testString = parser.parseExpression(\"'test' + ' ' + 'string'\").getValue(String.class);  // 'test string'\n\n// 빼기\nint four =  parser.parseExpression(\"1 - -3\").getValue(Integer.class); // 4\ndouble d = parser.parseExpression(\"1000.00 - 1e4\").getValue(Double.class); // -9000\n\n// 곱하기\nint six =  parser.parseExpression(\"-2 * -3\").getValue(Integer.class); // 6\ndouble twentyFour = parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(Double.class); // 24.0\n\n// 나누기\nint minusTwo =  parser.parseExpression(\"6 / -3\").getValue(Integer.class); // -2\ndouble one = parser.parseExpression(\"8.0 / 4e0 / 2\").getValue(Double.class); // 1.0\n\n// 계수(Modulus)\nint three =  parser.parseExpression(\"7 % 4\").getValue(Integer.class); // 3\nint one = parser.parseExpression(\"8 / 5 % 2\").getValue(Integer.class); // 1\n\n// 연산자 우선순위\nint minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(Integer.class); // -21\n```\n\n## 3항 연산자 (If-Then-Else)\n\n표현식에서 3항연산자를 통해 if-then-else 로직을 수행할 수 있다.\n```java\n//falseExp로 평가 된다.\nString falseString = parser.parseExpression(\"false ? 'trueExp' : 'falseExp'\").getValue(String.class);\n```\n\n## Elvis 연산자\n* Elvis 연산자는 3항 연산자 구문을 단축시키고 Groovy 언어로 사용된다.\n* 3항 연산자는 변수를 2번 반복해서 써야하는 단점이 있다.\n\n```java\nString name = \"Elvis Presley\";\nString displayName = name != null ? name : \"Unknown\";\n```\n\n이런 조잡한 표현식 대신에 Elvis 연산자를 사용하면..\n```java\nExpressionParser parser = new SpelExpressionParser();\nString name = parser.parseExpression(\"name?:'Unknown'\").getValue(String.class);  \nSystem.out.println(name); // 'Unknown'\n```\n\n간단하게 변수에 대해 `?` 를 붙여주는 것만으로도 null 체크를 해준다.\n? 모양이 엘비스 프레슬리의 머리모양을 닮아서 Elvis 연산자라고 명명하였다고 한다.\n\n\n\n## 안전한탐색(Navigation) 연산자\n* 안전한 탐색 연산자는 NPE를 피하기 위해 사용, Groovy 언어로 제공\n* java로 코딩을 하다보면 습관적으로 if(variable == null) 과 같은 체크를 하게 된다.\n* 하지만 Safe Navigation 연산자를 사용하면 NPE를 발생시키지 않고, 그냥 null을 리턴해 준다.\n\n```java\nExpressionParser parser = new SpelExpressionParser();\n\nInventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\ntesla.setPlaceOfBirth(new PlaceOfBirth(\"Smiljan\"));\n\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\n\n//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행\nString city = parser.parseExpression(\"PlaceOfBirth?.City\").getValue(context, String.class);\nSystem.out.println(city); // Smiljan\n\ntesla.setPlaceOfBirth(null);\n\n //placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행\ncity = parser.parseExpression(\"PlaceOfBirth?.City\").getValue(context, String.class);\nSystem.out.println(city); // null - null pointer exception이 발생하지 않는다.\n```\n\n\n\n# 할당\n\n* 할당연산자(`=`)를 이용하여 Context내의 프로퍼티에 value를 할당 할 수 있다.\n* 보통은 setValue 메서드를 이용하여 value를 할당\n* getValue 메서드를 이용하여 할당 할 수도 있다.\n\n``` java\nInventor inventor = new Inventor();\nStandardEvaluationContext inventorContext = new StandardEvaluationContext(inventor);\n//inventor.name에 Alexander Seovic2 문자열을 할당\nparser.parseExpression(\"Name\").setValue(inventorContext, \"Alexander Seovic2\");\n\n//할당연산자(`=`)를 이용하여 inventor.name에 Alexander Seovic2 문자열을 할당\nString aleks = parser.parseExpression(\"Name = 'Alexandar Seovic'\").getValue(inventorContext, String.class);\n```\n\n# 클래스 표현식\n\n* `T` 연산자를 통해 클래스의 인스턴스를 지정하는데 사용할 수 있다.\n* `T` 연산자를 통해 클래스의 static method도 사용할 수 있다.\n* 웬만하면 full package를 적어준다.\n* StandardEvaluationContext는 타입을 찾으려고 TypeLocator를 사용\n* StandardTypeLocator는 java.lang 패키지로 만들어진다.\n* 따라서 java.lang.String과 같은 타입은 T(String)으로 간단하게 표현 가능하다.\n\n``` java\nClass dateClass = parser.parseExpression(\"T(java.util.Date)\").getValue(Class.class);\n\nClass stringClass = parser.parseExpression(\"T(String)\").getValue(Class.class);\n\nboolean trueValue = parser.parseExpression(\"T(java.math.RoundingMode).CEILING < T(java.math.RoundingMode).FLOOR\").getValue(Boolean.class);\n```\n\n# 생성자 호출\n\n* 생성자는 새로운 연산자를 사용해서 호출할 수 있다.\n* primitive type(원시 타입 int, double등..)과 String 외에는 모두 정규화된 클래스명을 사용해야 한다.\n\n``` java\nInventor einstein = p.parseExpression(\"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')\").getValue(Inventor.class);\n\n//리스트의 add 메서드내에서 새로운 inventor 인스턴스를 생성한다\np.parseExpression(\"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))\").getValue(societyContext);\n```\n\n# 변수\n\n* `#` 표현식을 통해 표현식 내에 변수를 참조할 수 있다.\n* StandardEvaluationContext에서 setVariable 메서드를 사용해서 변수를 설정한다.\n* 자주 쓰이는 표현식이다. (@Cacheable Annotation에서도 사용)\n\n``` java\nInventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\ncontext.setVariable(\"newName\", \"Mike Tesla\"); //newName변수에 대한 value할당\n\nparser.parseExpression(\"Name = #newName\").getValue(context);\n\nSystem.out.println(tesla.getName()) // \"Mike Tesla\"\n```\n\n## #root\n\n* 변수 #root는 항상 정의되며 루트 컨텍스트 개체의미\n* #root는 항상 루트를 나타낸다.\n* setRootObject 메서드를 통해 root를 정의한다.\n\n``` java\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\n\nSomeCustomObject someObject = new SomeCustomObject();\ncontext.setRootObject(someObject);\n\nString name = \"kocko\";\ncontext.setVariable(\"name\", kocko);\nString statement = \"#root.stringLength(#kocko) == 5\";\nExpression expression = parser.parseExpression(statement);\n\nboolean result = expression.getValue(context, Boolean.class);\n```\n\n* #root는 SomeCustomObject를 의미\n\n## #this\n```java\n// create an array of integers\nList<Integer> primes = new ArrayList<Integer>();\nprimes.addAll(Arrays.asList(2,3,5,7,11,13,17));\n\n// 파서를 생성하고 'primes' 변수를 정수 배열로 설정한다\nExpressionParser parser = new SpelExpressionParser();\nStandardEvaluationContext context = new StandardEvaluationContext();\ncontext.setVariable(\"primes\",primes);\n\n// 리스트에서 10보다 큰 모든 소수(?{...} 선택을 사용)\n// [11, 13, 17]로 평가된다\nList<Integer>\n primesGreaterThanTen = (List<Integer>) \nparser.parseExpression(\"#primes.?[#this>10]\").getValue(context);\n//#primes 변수에 대해 평가하며, #this는 2~17까지 값을 의미한다.\n```\n* #this는 항상 정의되어 있고, 현재 평가되는 객체를 가리킨다.\n* #this는 계속 변경될 수 있다. (위의 예제에서 보면 2,3,5,7등 평가 시점에 따라 달라질수 있다.)\n\n\n\n# 사용자 정의 함수\n* 표현식 문자열 내에서 호출 가능한 사용자 정의 함수를 등록하여 SpEL의 기능을 확장할 수 있다.\n* StandardEvaluationContext에 사용자정의 함수를 등록하여 사용하면 된다.\n\n예시로 문자열을 reverse 하는 메서드를 구현하였다.\n```java\npublic abstract class StringUtils {\n\n    public static String reverseString(String input) {\n        StringBuilder backwards = new StringBuilder();\n        for (int i = 0; i < input.length(); i++)\n            backwards.append(input.charAt(input.length() - 1 - i));\n        }\n        return backwards.toString();\n    }\n}\n```\n\n메서드를 StandardEvaluationContext에 등록\n```java\nExpressionParser parser = new SpelExpressionParser();\nStandardEvaluationContext context = new StandardEvaluationContext();\n\n//StringUtils 클래스에 정의된 reserveString 메서드를 등록한다.\n//파라미터 타입은 String 타입 객체 1개이다.\ncontext.registerFunction(\"reverseString\", StringUtils.class.getDeclaredMethod(\"reverseString\", new Class[] { String.class }));\n\n//hello 문자열을 뒤집은 olleh가 리턴된다.\nString helloWorldReversed = parser.parseExpression(\"#reverseString('hello')\").getValue(context, String.class);\n```\n\n# Bean 참조\n\nevaluation context에 Bean Resolver가 설정된 경우 `@` 표현식으로 bean을 사용할 수 있다.\nSpring Docs에 있는 예제는 잘 이해가 안되어 직접 테스트 해보았다.\n\n\nBean 클래스 생성\n```java\n@Component\npublic class TestBean {\n\n\tpublic String test(){\n\t\treturn \"do Test\";\n\t}\n}\n```\n\n```java\n@Controller\npublic class TestController {\n\n\t@Autowired\n\tprivate ApplicationContext applicationContext;\n\n\t@RequestMapping(\"/test\")\n\t@ResponseBody\n\tpublic String test() {\n\t\tExpressionParser parser = new SpelExpressionParser();\n\t\tStandardEvaluationContext context = new StandardEvaluationContext();\n\n\t\t//실용적인 테스트를 위해 Application Context의 BeanFactory를 설정\n\t\tDefaultListableBeanFactory factory = (DefaultListableBeanFactory) ((ConfigurableApplicationContext) applicationContext).getBeanFactory();\n\t\tcontext.setBeanResolver(new BeanFactoryResolver(factory));\n\n\t\t//Application Context에 등록된 testBean이라는 bean을 불러와 test메서드를 실행하였다.\n\t\tString result = parser.parseExpression(\"@testBean.test()\").getValue(context, String.class);\n\t\treturn result; //do Test가 리턴되었다.\n\t}\n}\n```\n\n\n# Collection 선택 기능\n\n* 컬렉션 (Collection) 선택 기능은 Context내의 Collection 필드에 접근하여 조건(Criteria)를 기반으로 서브 컬렉션을 반환 할 수 있다.\n* `?[selectionExpression]` 표현식을 이용한다.\n* 리스트, 맵에서 모두 사용 가능하다\n* 객체가 context로 들어오는 경우 object.?[필드에 대한 조건]\n* 컬렉션이 context로 들어오는 경우 .?[필드에 대한 조건] (별도의 필드가 없는 경우 #this를 사용)\n\nTwice 클래스를 선언\n```java\n@NoArgsConstructor\npublic static class Twice {\n    @Getter\n    private List<Member> members = new ArrayList<Member>() {\n        {\n            add(new Member(\"지효\", 23));\n            add(new Member(\"나연\", 24));\n            add(new Member(\"모모\", 23));\n            add(new Member(\"사나\", 23));\n            add(new Member(\"다현\", 21));\n            add(new Member(\"미나\", 23));\n            add(new Member(\"채영\", 19));\n            add(new Member(\"쯔위\", 19));\n            add(new Member(\"정연\", 23));\n        }\n    };\n}\n\n@NoArgsConstructor\n@AllArgsConstructor\n@Getter\npublic static class Member{\n    private String name;\n    private int age;\n}\n```\n\n```java\npublic List<Twice> twice() {\n    ExpressionParser parser = new SpelExpressionParser();\n    StandardEvaluationContext context = new StandardEvaluationContext();\n\n    // Twice의 멤버 필드에 접근\n    // 컬렉션의 age 필드에 대해 20 이하인 대상을 반환\n    List<Twice> filterList = (List<Twice>) parser.parseExpression(\"members.?[age < 20]\").getValue(new Twice());\n    return filterList; //[{\"name\":\"채영\",\"age\":19},{\"name\":\"쯔위\",\"age\":19}]\n}\n```\n\n# Collection 투영 기능\n* 투영기능은 컬렉션에 하위표현식을 반영하여 새로운 컬렉션을 리턴한다.\n* `![projectionExpression]` 표현식을 사용한다.\n\n위의 Twice 예제를 바탕으로 설명하겠다.\n```java\npublic List<String> twice2() {\n    ExpressionParser parser = new SpelExpressionParser();\n    StandardEvaluationContext context = new StandardEvaluationContext();\n\n    List<Member> testList = new ArrayList<Member>() {\n        {\n            add(new Member(\"지효\", 23));\n            add(new Member(\"나연\", 24));\n            add(new Member(\"모모\", 23));\n            add(new Member(\"사나\", 23));\n            add(new Member(\"다현\", 21));\n            add(new Member(\"미나\", 23));\n            add(new Member(\"채영\", 19));\n            add(new Member(\"쯔위\", 19));\n            add(new Member(\"정연\", 23));\n        }\n    };\n    // Twice 멤버 배열을 받아, 컬렉션 투영기능을 이용하여 그중 name에 대한 필드만 뽑아온 것이다.\n    List<String> filterList = (List<String>) parser.parseExpression(\"![name]\").getValue(testList);\n    return filterList; //[\"지효\",\"나연\",\"모모\",\"사나\",\"다현\",\"미나\",\"채영\",\"쯔위\",\"정연\"]\n}\n```\n\n\n\n# 표현식 템플릿\n* 표현식 템플릿을 사용하면 평가 블록과 Literal text를 혼합할 수 있다.\n* 평가블록은 prefix와 subfix로 구분\n* 일반적으로 `#{` 와 `}`로 구분한다.\n* parseExpression() 메서드의 두번째 파라미터로 사용자 정의 ParseContext 객체를 넣어준다.\n\n```java\npublic class TemplateParserContext implements ParserContext {\n\n  public String getExpressionPrefix() {\n    return \"#{\";\n  }\n\n  public String getExpressionSuffix() {\n    return \"}\";\n  }\n  \n  public boolean isTemplate() {\n    return true;\n  }\n}\n```\n\n```java\n// \"random number is 0.7038186818312008\"로 평가된다\nString randomPhrase = \n   parser.parseExpression(\"random number is #{T(java.lang.Math).random()}\", new TemplateParserContext()).getValue(String.class);\n\n```","source":"_posts/2018-11-25-spel-expression-2.md","raw":"---\nlayout: posts\ntitle: SpEL Expression(2)\ncatalog: true\nCategories:\n- Spring\ntags:\n- Spring\n- SpEL\ndate: 2018-11-25 17:11:42\ntypora-root-url: 2018-11-25-spel-expression-2\ntypora-copy-images-to: 2018-11-25-spel-expression-2\n---\n\n# 리터럴 표현식 (Literal Expression)\n\n리터럴 표현식을 제공하는 타입은 문자열(String), 숫자(int, real, hex), boolean, null이다.\n\n* 문자열 (Strings)는 따옴표(')로 구분된다 `(쌍따옴표가 아님)` \\- 문자열 표현 시\\, `'Hello World'` 처럼 SpEL을 작성\n\n다음은 리터럴 표현식 (Literal Expression)에 대한 간단한 예제이다.\n\n``` java\nExpressionParser parser = new SpelExpressionParser();\n\n//따옴표로 이루어진 'Hello World' => Hello World라는 문자열로 평가 된다.\nString helloWorld = (String) parser.parseExpression(\"'Hello World'\").getValue();\n//Double 타입의 숫자로 평가\ndouble avogadrosNumber = (Double) parser.parseExpression(\"6.0221415E+23\").getValue();\n//2147483647로 평가\nint maxValue = (Integer) parser.parseExpression(\"0x7FFFFFFF\").getValue();\n\nboolean trueValue = (Boolean) parser.parseExpression(\"true\").getValue();\n//null로 평가 된다. -> null String이 아니다. (주의)\nObject nullValue = parser.parseExpression(\"null\").getValue();\n```\n\n* 숫자는 음수기호(-), 지수표시(E), 소수점(.)을 지원한다.\n* 기본적으로 실제 숫자는 Double.parseDouble()로 파싱한다.\n\n# 메서드 호출\n\n``` java\n//String 리터럴 abc에 대한 substring 메서드 호출 -> bc가 리턴된다.\nString c = parser.parseExpression(\"'abc'.substring(2, 3)\").getValue(String.class);\n\n//사용자 정의 메서드 호출 (Return Type : Boolean) -> boolean 타입으로 평가된다.\nboolean isMember = parser.parseExpression(\"isMember('Mihajlo Pupin')\").getValue(\n        societyContext, Boolean.class);\n```\n\n위의 코드는 메서드 호출에 대한 예제 코드이다.\n\n* 메서드는 Java 문법을 사용하여 호출 할 수 있다.\n* Literal에 대한 메서드 호출도 가능하다.\n* Varargs 형식의 파라미터도 지원하고 있다.\n\n# 프로퍼티, 배열, 리스트, 맵에 대한 접근 지원\n\n``` java\nExpressionParser parser = new SpelExpressionParser();\n\n// 발명품 배열\nStandardEvaluationContext teslaContext = new StandardEvaluationContext(tesla);\n\n// \"Induction motor\"로 평가된다.\nString invention = parser.parseExpression(\"inventions[3]\").getValue(teslaContext, String.class); \n\n// 회원 리스트\nStandardEvaluationContext societyContext = new StandardEvaluationContext(ieee);\n\n// \"Nikola Tesla\"로 평가된다.\nString name = parser.parseExpression(\"Members[0].Name\").getValue(societyContext, String.class);\n\n// 리스트와 배열 탐색\n// \"Wireless communication\"로 평가된다.\nString invention = parser.parseExpression(\"Members[0].Inventions[6]\").getValue(societyContext, String.class);\n```\n\n* 프로퍼티의 맨 첫글자는 대소문자를 구별하지 않는다.\n* SpEL은 표준 `dot 표기법`(예: prop1.prop2.prop3)을 사용해서 중첩된 프로퍼티와 프로퍼티의 값 설정도 지원한다.\n* public 필드에 대한 접근을 지원한다.\n\n``` java\n// Officer의 딕션어리\nInventor pupin = parser.parseExpression(\"Officers['president']\").getValue(societyContext, Inventor.class);\n\n// \"Idvor\"로 평가된다\nString city = parser.parseExpression(\"Officers['president'].PlaceOfBirth.City\").getValue(societyContext, String.class);\n\n// 값을 설정한다\nparser.parseExpression(\"Officers['advisors'][0].PlaceOfBirth.Country\").setValue(societyContext, \"Croatia\");\n```\n\n* 대괄호`[]` 를 사용하여 Map의 key를 바탕으로 데이터에 접근한다.\n  (위의 예제에서는 Officers가 `Map`, president가 `key`이다.)\n* SpEL은 표준 'dot' 표기법(예: prop1.prop2.prop3)을 사용해서 Map내의 value 객체의 프로퍼티에도 접근 가능하다.\n* setValue 메서드를 통해 데이터를 수정할 수 있다.\n\n# 인라인 리스트 (Inline list)\n\n리스트는 {} 표기법을 사용하여 리스트로 사용 할 수 있다.\n\n``` java\n// 4개의 숫자를 담고 있는 리스트로 평가된다\nList<Integer> numbers = (List) parser.parseExpression(\"{1,2,3,4}\").getValue(context); \n\n//List의 List의 형태의 List로 평가된다.\n//listOfLists[0] = {'a', 'b'}\n//listOfLists[1] = {'x', 'y'}\nList listOfLists = (List) parser.parseExpression(\"{{'a','b'},{'x','y'}}\").getValue(context);\n```\n\n# 배열 생성\n\n``` java\nint[] numbers1 = (int[]) parser.parseExpression(\"new int[4]\").getValue(context); \n\n// initializer가진 배열\nint[] numbers2 = (int[]) parser.parseExpression(\"new int[]{1,2,3}\").getValue(context); \n\n// 다차원 배열\nint[][] numbers3 = (int[][]) parser.parseExpression(\"new int[4][5]\").getValue(context);\n```\n\n* Java 문법과 같은 표현식을 사용하여 배열을 생성 할 수 있다.\n* {} 표현식을 통해 초기값을 세팅할 수 있다.\n* 2차원 배열이상의 다차원 배열도 선언이 가능하다. (`단, 다차원 배열은 초기값을 설정할 수 없다.`)\n\n# 연산자\n\n## 관계 연산자\n\n표준 관계 연산자를 사용한다. 사용 할 수 있는 관계 연산자는 아래와 같다.\n\n* 같음 (`==`)\n* 같지 않음 (`!=`)\n* 작음 (`<`)\n* 작거나 같음 (`<=`)\n* 큼 (`>`)\n* 크거나 같음 (`>=`)\n\n``` java\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"2 == 2\").getValue(Boolean.class);\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"2 < -5.0\").getValue(Boolean.class);\n\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"'black' < 'block'\").getValue(Boolean.class);\n```\n\n## 심볼릭 연산자\n\nXML과 같이 문서형식에 관계 연산자가 제한을 받는 경우, 사용 가능한 문자 표현식을 제공한다.\n연산자에 대한 대소문자는 구별하지 않는다.\n\n* 같음 (`eq`)\n* 같지 않음 (`ne`)\n* 작음 (`lt`)\n* 작거나 같음 (`le`)\n* 큼 (`gt`)\n* 크거나 같음 (`gt`)\n* div (`/`)\n* mod (`%`)\n* not (`!`)\n\n``` java\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"22 eq 22\").getValue(Boolean.class);\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"'test' eq 'test!'\").getValue(Boolean.class);\n```\n\n## 정규 표현식\n\nmatches를 이용한 정규표현식을 지원한다.\n\n``` java\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"'5.00' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n```\n\n## instanceof\n\nJava에서 super타입에 대한 연산을 위해 instanceof를 표현식으로 사용할 수 있다.\n\n``` java\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"'xyz' instanceof T(int)\").getValue(Boolean.class);\n\n// true로 평가된다.\nboolean trueValue = parser.parseExpression(\"'xyz' instanceof T(String)\").getValue(Boolean.class);\n```\n\n## 논리연산자\n\nAND, OR, NOT에 대한 표현식을 지원한다.\n\n``` java\n// -- AND --\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"true and false\").getValue(Boolean.class);\n\n// true로 평가된다\nString expression =  \"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\";\nboolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n\n// -- OR --\n\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"true or false\").getValue(Boolean.class);\n\n// true로 평가된다\nString expression =  \"isMember('Nikola Tesla') or isMember('Albert Einstien')\";\nboolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n\n// -- NOT --\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"!true\").getValue(Boolean.class);\n\n// -- AND and NOT --\nString expression =  \"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\";\nboolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n```\n\n## 수식 연산자\n\n* 더하기 (+) 연산자를 숫자, 날짜, 문자열에 사용할 수 있다.\n* 빼기(-) 연산자를 숫자, 날짜에 사용할 수 있다.\n* 곱하기(*), 나누기(/), 나머지(%)에 대한 연산은 숫자에만 사용 할 수 있다.\n* 연산자 우선 순위 법칙이 적용된다.\n\n``` java\n// 더하기\nint two = parser.parseExpression(\"1 + 1\").getValue(Integer.class); // 2\nString testString = parser.parseExpression(\"'test' + ' ' + 'string'\").getValue(String.class);  // 'test string'\n\n// 빼기\nint four =  parser.parseExpression(\"1 - -3\").getValue(Integer.class); // 4\ndouble d = parser.parseExpression(\"1000.00 - 1e4\").getValue(Double.class); // -9000\n\n// 곱하기\nint six =  parser.parseExpression(\"-2 * -3\").getValue(Integer.class); // 6\ndouble twentyFour = parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(Double.class); // 24.0\n\n// 나누기\nint minusTwo =  parser.parseExpression(\"6 / -3\").getValue(Integer.class); // -2\ndouble one = parser.parseExpression(\"8.0 / 4e0 / 2\").getValue(Double.class); // 1.0\n\n// 계수(Modulus)\nint three =  parser.parseExpression(\"7 % 4\").getValue(Integer.class); // 3\nint one = parser.parseExpression(\"8 / 5 % 2\").getValue(Integer.class); // 1\n\n// 연산자 우선순위\nint minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(Integer.class); // -21\n```\n\n## 3항 연산자 (If-Then-Else)\n\n표현식에서 3항연산자를 통해 if-then-else 로직을 수행할 수 있다.\n```java\n//falseExp로 평가 된다.\nString falseString = parser.parseExpression(\"false ? 'trueExp' : 'falseExp'\").getValue(String.class);\n```\n\n## Elvis 연산자\n* Elvis 연산자는 3항 연산자 구문을 단축시키고 Groovy 언어로 사용된다.\n* 3항 연산자는 변수를 2번 반복해서 써야하는 단점이 있다.\n\n```java\nString name = \"Elvis Presley\";\nString displayName = name != null ? name : \"Unknown\";\n```\n\n이런 조잡한 표현식 대신에 Elvis 연산자를 사용하면..\n```java\nExpressionParser parser = new SpelExpressionParser();\nString name = parser.parseExpression(\"name?:'Unknown'\").getValue(String.class);  \nSystem.out.println(name); // 'Unknown'\n```\n\n간단하게 변수에 대해 `?` 를 붙여주는 것만으로도 null 체크를 해준다.\n? 모양이 엘비스 프레슬리의 머리모양을 닮아서 Elvis 연산자라고 명명하였다고 한다.\n\n\n\n## 안전한탐색(Navigation) 연산자\n* 안전한 탐색 연산자는 NPE를 피하기 위해 사용, Groovy 언어로 제공\n* java로 코딩을 하다보면 습관적으로 if(variable == null) 과 같은 체크를 하게 된다.\n* 하지만 Safe Navigation 연산자를 사용하면 NPE를 발생시키지 않고, 그냥 null을 리턴해 준다.\n\n```java\nExpressionParser parser = new SpelExpressionParser();\n\nInventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\ntesla.setPlaceOfBirth(new PlaceOfBirth(\"Smiljan\"));\n\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\n\n//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행\nString city = parser.parseExpression(\"PlaceOfBirth?.City\").getValue(context, String.class);\nSystem.out.println(city); // Smiljan\n\ntesla.setPlaceOfBirth(null);\n\n //placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행\ncity = parser.parseExpression(\"PlaceOfBirth?.City\").getValue(context, String.class);\nSystem.out.println(city); // null - null pointer exception이 발생하지 않는다.\n```\n\n\n\n# 할당\n\n* 할당연산자(`=`)를 이용하여 Context내의 프로퍼티에 value를 할당 할 수 있다.\n* 보통은 setValue 메서드를 이용하여 value를 할당\n* getValue 메서드를 이용하여 할당 할 수도 있다.\n\n``` java\nInventor inventor = new Inventor();\nStandardEvaluationContext inventorContext = new StandardEvaluationContext(inventor);\n//inventor.name에 Alexander Seovic2 문자열을 할당\nparser.parseExpression(\"Name\").setValue(inventorContext, \"Alexander Seovic2\");\n\n//할당연산자(`=`)를 이용하여 inventor.name에 Alexander Seovic2 문자열을 할당\nString aleks = parser.parseExpression(\"Name = 'Alexandar Seovic'\").getValue(inventorContext, String.class);\n```\n\n# 클래스 표현식\n\n* `T` 연산자를 통해 클래스의 인스턴스를 지정하는데 사용할 수 있다.\n* `T` 연산자를 통해 클래스의 static method도 사용할 수 있다.\n* 웬만하면 full package를 적어준다.\n* StandardEvaluationContext는 타입을 찾으려고 TypeLocator를 사용\n* StandardTypeLocator는 java.lang 패키지로 만들어진다.\n* 따라서 java.lang.String과 같은 타입은 T(String)으로 간단하게 표현 가능하다.\n\n``` java\nClass dateClass = parser.parseExpression(\"T(java.util.Date)\").getValue(Class.class);\n\nClass stringClass = parser.parseExpression(\"T(String)\").getValue(Class.class);\n\nboolean trueValue = parser.parseExpression(\"T(java.math.RoundingMode).CEILING < T(java.math.RoundingMode).FLOOR\").getValue(Boolean.class);\n```\n\n# 생성자 호출\n\n* 생성자는 새로운 연산자를 사용해서 호출할 수 있다.\n* primitive type(원시 타입 int, double등..)과 String 외에는 모두 정규화된 클래스명을 사용해야 한다.\n\n``` java\nInventor einstein = p.parseExpression(\"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')\").getValue(Inventor.class);\n\n//리스트의 add 메서드내에서 새로운 inventor 인스턴스를 생성한다\np.parseExpression(\"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))\").getValue(societyContext);\n```\n\n# 변수\n\n* `#` 표현식을 통해 표현식 내에 변수를 참조할 수 있다.\n* StandardEvaluationContext에서 setVariable 메서드를 사용해서 변수를 설정한다.\n* 자주 쓰이는 표현식이다. (@Cacheable Annotation에서도 사용)\n\n``` java\nInventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\ncontext.setVariable(\"newName\", \"Mike Tesla\"); //newName변수에 대한 value할당\n\nparser.parseExpression(\"Name = #newName\").getValue(context);\n\nSystem.out.println(tesla.getName()) // \"Mike Tesla\"\n```\n\n## #root\n\n* 변수 #root는 항상 정의되며 루트 컨텍스트 개체의미\n* #root는 항상 루트를 나타낸다.\n* setRootObject 메서드를 통해 root를 정의한다.\n\n``` java\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\n\nSomeCustomObject someObject = new SomeCustomObject();\ncontext.setRootObject(someObject);\n\nString name = \"kocko\";\ncontext.setVariable(\"name\", kocko);\nString statement = \"#root.stringLength(#kocko) == 5\";\nExpression expression = parser.parseExpression(statement);\n\nboolean result = expression.getValue(context, Boolean.class);\n```\n\n* #root는 SomeCustomObject를 의미\n\n## #this\n```java\n// create an array of integers\nList<Integer> primes = new ArrayList<Integer>();\nprimes.addAll(Arrays.asList(2,3,5,7,11,13,17));\n\n// 파서를 생성하고 'primes' 변수를 정수 배열로 설정한다\nExpressionParser parser = new SpelExpressionParser();\nStandardEvaluationContext context = new StandardEvaluationContext();\ncontext.setVariable(\"primes\",primes);\n\n// 리스트에서 10보다 큰 모든 소수(?{...} 선택을 사용)\n// [11, 13, 17]로 평가된다\nList<Integer>\n primesGreaterThanTen = (List<Integer>) \nparser.parseExpression(\"#primes.?[#this>10]\").getValue(context);\n//#primes 변수에 대해 평가하며, #this는 2~17까지 값을 의미한다.\n```\n* #this는 항상 정의되어 있고, 현재 평가되는 객체를 가리킨다.\n* #this는 계속 변경될 수 있다. (위의 예제에서 보면 2,3,5,7등 평가 시점에 따라 달라질수 있다.)\n\n\n\n# 사용자 정의 함수\n* 표현식 문자열 내에서 호출 가능한 사용자 정의 함수를 등록하여 SpEL의 기능을 확장할 수 있다.\n* StandardEvaluationContext에 사용자정의 함수를 등록하여 사용하면 된다.\n\n예시로 문자열을 reverse 하는 메서드를 구현하였다.\n```java\npublic abstract class StringUtils {\n\n    public static String reverseString(String input) {\n        StringBuilder backwards = new StringBuilder();\n        for (int i = 0; i < input.length(); i++)\n            backwards.append(input.charAt(input.length() - 1 - i));\n        }\n        return backwards.toString();\n    }\n}\n```\n\n메서드를 StandardEvaluationContext에 등록\n```java\nExpressionParser parser = new SpelExpressionParser();\nStandardEvaluationContext context = new StandardEvaluationContext();\n\n//StringUtils 클래스에 정의된 reserveString 메서드를 등록한다.\n//파라미터 타입은 String 타입 객체 1개이다.\ncontext.registerFunction(\"reverseString\", StringUtils.class.getDeclaredMethod(\"reverseString\", new Class[] { String.class }));\n\n//hello 문자열을 뒤집은 olleh가 리턴된다.\nString helloWorldReversed = parser.parseExpression(\"#reverseString('hello')\").getValue(context, String.class);\n```\n\n# Bean 참조\n\nevaluation context에 Bean Resolver가 설정된 경우 `@` 표현식으로 bean을 사용할 수 있다.\nSpring Docs에 있는 예제는 잘 이해가 안되어 직접 테스트 해보았다.\n\n\nBean 클래스 생성\n```java\n@Component\npublic class TestBean {\n\n\tpublic String test(){\n\t\treturn \"do Test\";\n\t}\n}\n```\n\n```java\n@Controller\npublic class TestController {\n\n\t@Autowired\n\tprivate ApplicationContext applicationContext;\n\n\t@RequestMapping(\"/test\")\n\t@ResponseBody\n\tpublic String test() {\n\t\tExpressionParser parser = new SpelExpressionParser();\n\t\tStandardEvaluationContext context = new StandardEvaluationContext();\n\n\t\t//실용적인 테스트를 위해 Application Context의 BeanFactory를 설정\n\t\tDefaultListableBeanFactory factory = (DefaultListableBeanFactory) ((ConfigurableApplicationContext) applicationContext).getBeanFactory();\n\t\tcontext.setBeanResolver(new BeanFactoryResolver(factory));\n\n\t\t//Application Context에 등록된 testBean이라는 bean을 불러와 test메서드를 실행하였다.\n\t\tString result = parser.parseExpression(\"@testBean.test()\").getValue(context, String.class);\n\t\treturn result; //do Test가 리턴되었다.\n\t}\n}\n```\n\n\n# Collection 선택 기능\n\n* 컬렉션 (Collection) 선택 기능은 Context내의 Collection 필드에 접근하여 조건(Criteria)를 기반으로 서브 컬렉션을 반환 할 수 있다.\n* `?[selectionExpression]` 표현식을 이용한다.\n* 리스트, 맵에서 모두 사용 가능하다\n* 객체가 context로 들어오는 경우 object.?[필드에 대한 조건]\n* 컬렉션이 context로 들어오는 경우 .?[필드에 대한 조건] (별도의 필드가 없는 경우 #this를 사용)\n\nTwice 클래스를 선언\n```java\n@NoArgsConstructor\npublic static class Twice {\n    @Getter\n    private List<Member> members = new ArrayList<Member>() {\n        {\n            add(new Member(\"지효\", 23));\n            add(new Member(\"나연\", 24));\n            add(new Member(\"모모\", 23));\n            add(new Member(\"사나\", 23));\n            add(new Member(\"다현\", 21));\n            add(new Member(\"미나\", 23));\n            add(new Member(\"채영\", 19));\n            add(new Member(\"쯔위\", 19));\n            add(new Member(\"정연\", 23));\n        }\n    };\n}\n\n@NoArgsConstructor\n@AllArgsConstructor\n@Getter\npublic static class Member{\n    private String name;\n    private int age;\n}\n```\n\n```java\npublic List<Twice> twice() {\n    ExpressionParser parser = new SpelExpressionParser();\n    StandardEvaluationContext context = new StandardEvaluationContext();\n\n    // Twice의 멤버 필드에 접근\n    // 컬렉션의 age 필드에 대해 20 이하인 대상을 반환\n    List<Twice> filterList = (List<Twice>) parser.parseExpression(\"members.?[age < 20]\").getValue(new Twice());\n    return filterList; //[{\"name\":\"채영\",\"age\":19},{\"name\":\"쯔위\",\"age\":19}]\n}\n```\n\n# Collection 투영 기능\n* 투영기능은 컬렉션에 하위표현식을 반영하여 새로운 컬렉션을 리턴한다.\n* `![projectionExpression]` 표현식을 사용한다.\n\n위의 Twice 예제를 바탕으로 설명하겠다.\n```java\npublic List<String> twice2() {\n    ExpressionParser parser = new SpelExpressionParser();\n    StandardEvaluationContext context = new StandardEvaluationContext();\n\n    List<Member> testList = new ArrayList<Member>() {\n        {\n            add(new Member(\"지효\", 23));\n            add(new Member(\"나연\", 24));\n            add(new Member(\"모모\", 23));\n            add(new Member(\"사나\", 23));\n            add(new Member(\"다현\", 21));\n            add(new Member(\"미나\", 23));\n            add(new Member(\"채영\", 19));\n            add(new Member(\"쯔위\", 19));\n            add(new Member(\"정연\", 23));\n        }\n    };\n    // Twice 멤버 배열을 받아, 컬렉션 투영기능을 이용하여 그중 name에 대한 필드만 뽑아온 것이다.\n    List<String> filterList = (List<String>) parser.parseExpression(\"![name]\").getValue(testList);\n    return filterList; //[\"지효\",\"나연\",\"모모\",\"사나\",\"다현\",\"미나\",\"채영\",\"쯔위\",\"정연\"]\n}\n```\n\n\n\n# 표현식 템플릿\n* 표현식 템플릿을 사용하면 평가 블록과 Literal text를 혼합할 수 있다.\n* 평가블록은 prefix와 subfix로 구분\n* 일반적으로 `#{` 와 `}`로 구분한다.\n* parseExpression() 메서드의 두번째 파라미터로 사용자 정의 ParseContext 객체를 넣어준다.\n\n```java\npublic class TemplateParserContext implements ParserContext {\n\n  public String getExpressionPrefix() {\n    return \"#{\";\n  }\n\n  public String getExpressionSuffix() {\n    return \"}\";\n  }\n  \n  public boolean isTemplate() {\n    return true;\n  }\n}\n```\n\n```java\n// \"random number is 0.7038186818312008\"로 평가된다\nString randomPhrase = \n   parser.parseExpression(\"random number is #{T(java.lang.Math).random()}\", new TemplateParserContext()).getValue(String.class);\n\n```","slug":"2018-11-25-spel-expression-2","published":1,"updated":"2018-11-27T07:23:32.394Z","comments":1,"photos":[],"link":"","_id":"cjrgbv3tv0047cr1t84r3e1sy","content":"<h1 id=\"리터럴-표현식-literal-expression\">리터럴 표현식 (Literal Expression)</h1>\n<p>리터럴 표현식을 제공하는 타입은 문자열(String), 숫자(int, real, hex), boolean, null이다.</p>\n<ul>\n<li>문자열 (Strings)는 따옴표(')로 구분된다 <code>(쌍따옴표가 아님)</code> - 문자열 표현 시, <code>'Hello World'</code> 처럼 SpEL을 작성</li>\n</ul>\n<p>다음은 리터럴 표현식 (Literal Expression)에 대한 간단한 예제이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//따옴표로 이루어진 'Hello World' =&gt; Hello World라는 문자열로 평가 된다.</span></span><br><span class=\"line\">String helloWorld = (String) parser.parseExpression(<span class=\"string\">\"'Hello World'\"</span>).getValue();</span><br><span class=\"line\"><span class=\"comment\">//Double 타입의 숫자로 평가</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> avogadrosNumber = (Double) parser.parseExpression(<span class=\"string\">\"6.0221415E+23\"</span>).getValue();</span><br><span class=\"line\"><span class=\"comment\">//2147483647로 평가</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> maxValue = (Integer) parser.parseExpression(<span class=\"string\">\"0x7FFFFFFF\"</span>).getValue();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = (Boolean) parser.parseExpression(<span class=\"string\">\"true\"</span>).getValue();</span><br><span class=\"line\"><span class=\"comment\">//null로 평가 된다. -&gt; null String이 아니다. (주의)</span></span><br><span class=\"line\">Object nullValue = parser.parseExpression(<span class=\"string\">\"null\"</span>).getValue();</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>숫자는 음수기호(-), 지수표시(E), 소수점(.)을 지원한다.</li>\n<li>기본적으로 실제 숫자는 Double.parseDouble()로 파싱한다.</li>\n</ul>\n<h1 id=\"메서드-호출\">메서드 호출</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//String 리터럴 abc에 대한 substring 메서드 호출 -&gt; bc가 리턴된다.</span></span><br><span class=\"line\">String c = parser.parseExpression(<span class=\"string\">\"'abc'.substring(2, 3)\"</span>).getValue(String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//사용자 정의 메서드 호출 (Return Type : Boolean) -&gt; boolean 타입으로 평가된다.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isMember = parser.parseExpression(<span class=\"string\">\"isMember('Mihajlo Pupin')\"</span>).getValue(</span><br><span class=\"line\">        societyContext, Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<p>위의 코드는 메서드 호출에 대한 예제 코드이다.</p>\n<ul>\n<li>메서드는 Java 문법을 사용하여 호출 할 수 있다.</li>\n<li>Literal에 대한 메서드 호출도 가능하다.</li>\n<li>Varargs 형식의 파라미터도 지원하고 있다.</li>\n</ul>\n<h1 id=\"프로퍼티-배열-리스트-맵에-대한-접근-지원\">프로퍼티, 배열, 리스트, 맵에 대한 접근 지원</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 발명품 배열</span></span><br><span class=\"line\">StandardEvaluationContext teslaContext = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Induction motor\"로 평가된다.</span></span><br><span class=\"line\">String invention = parser.parseExpression(<span class=\"string\">\"inventions[3]\"</span>).getValue(teslaContext, String.class); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 회원 리스트</span></span><br><span class=\"line\">StandardEvaluationContext societyContext = <span class=\"keyword\">new</span> StandardEvaluationContext(ieee);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Nikola Tesla\"로 평가된다.</span></span><br><span class=\"line\">String name = parser.parseExpression(<span class=\"string\">\"Members[0].Name\"</span>).getValue(societyContext, String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 리스트와 배열 탐색</span></span><br><span class=\"line\"><span class=\"comment\">// \"Wireless communication\"로 평가된다.</span></span><br><span class=\"line\">String invention = parser.parseExpression(<span class=\"string\">\"Members[0].Inventions[6]\"</span>).getValue(societyContext, String.class);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>프로퍼티의 맨 첫글자는 대소문자를 구별하지 않는다.</li>\n<li>SpEL은 표준 <code>dot 표기법</code>(예: prop1.prop2.prop3)을 사용해서 중첩된 프로퍼티와 프로퍼티의 값 설정도 지원한다.</li>\n<li>public 필드에 대한 접근을 지원한다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Officer의 딕션어리</span></span><br><span class=\"line\">Inventor pupin = parser.parseExpression(<span class=\"string\">\"Officers['president']\"</span>).getValue(societyContext, Inventor.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Idvor\"로 평가된다</span></span><br><span class=\"line\">String city = parser.parseExpression(<span class=\"string\">\"Officers['president'].PlaceOfBirth.City\"</span>).getValue(societyContext, String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 값을 설정한다</span></span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"Officers['advisors'][0].PlaceOfBirth.Country\"</span>).setValue(societyContext, <span class=\"string\">\"Croatia\"</span>);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>대괄호<code>[]</code> 를 사용하여 Map의 key를 바탕으로 데이터에 접근한다.\n(위의 예제에서는 Officers가 <code>Map</code>, president가 <code>key</code>이다.)</li>\n<li>SpEL은 표준 'dot' 표기법(예: prop1.prop2.prop3)을 사용해서 Map내의 value 객체의 프로퍼티에도 접근 가능하다.</li>\n<li>setValue 메서드를 통해 데이터를 수정할 수 있다.</li>\n</ul>\n<h1 id=\"인라인-리스트-inline-list\">인라인 리스트 (Inline list)</h1>\n<p>리스트는 {} 표기법을 사용하여 리스트로 사용 할 수 있다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 4개의 숫자를 담고 있는 리스트로 평가된다</span></span><br><span class=\"line\">List&lt;Integer&gt; numbers = (List) parser.parseExpression(<span class=\"string\">\"&#123;1,2,3,4&#125;\"</span>).getValue(context); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//List의 List의 형태의 List로 평가된다.</span></span><br><span class=\"line\"><span class=\"comment\">//listOfLists[0] = &#123;'a', 'b'&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//listOfLists[1] = &#123;'x', 'y'&#125;</span></span><br><span class=\"line\">List listOfLists = (List) parser.parseExpression(<span class=\"string\">\"&#123;&#123;'a','b'&#125;,&#123;'x','y'&#125;&#125;\"</span>).getValue(context);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"배열-생성\">배열 생성</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] numbers1 = (<span class=\"keyword\">int</span>[]) parser.parseExpression(<span class=\"string\">\"new int[4]\"</span>).getValue(context); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// initializer가진 배열</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] numbers2 = (<span class=\"keyword\">int</span>[]) parser.parseExpression(<span class=\"string\">\"new int[]&#123;1,2,3&#125;\"</span>).getValue(context); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 다차원 배열</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[][] numbers3 = (<span class=\"keyword\">int</span>[][]) parser.parseExpression(<span class=\"string\">\"new int[4][5]\"</span>).getValue(context);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>Java 문법과 같은 표현식을 사용하여 배열을 생성 할 수 있다.</li>\n<li>{} 표현식을 통해 초기값을 세팅할 수 있다.</li>\n<li>2차원 배열이상의 다차원 배열도 선언이 가능하다. (<code>단, 다차원 배열은 초기값을 설정할 수 없다.</code>)</li>\n</ul>\n<h1 id=\"연산자\">연산자</h1>\n<h2 id=\"관계-연산자\">관계 연산자</h2>\n<p>표준 관계 연산자를 사용한다. 사용 할 수 있는 관계 연산자는 아래와 같다.</p>\n<ul>\n<li>같음 (<code>==</code>)</li>\n<li>같지 않음 (<code>!=</code>)</li>\n<li>작음 (<code>&lt;</code>)</li>\n<li>작거나 같음 (<code>&lt;=</code>)</li>\n<li>큼 (<code>&gt;</code>)</li>\n<li>크거나 같음 (<code>&gt;=</code>)</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"2 == 2\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"2 &lt; -5.0\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"'black' &lt; 'block'\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"심볼릭-연산자\">심볼릭 연산자</h2>\n<p>XML과 같이 문서형식에 관계 연산자가 제한을 받는 경우, 사용 가능한 문자 표현식을 제공한다.\n연산자에 대한 대소문자는 구별하지 않는다.</p>\n<ul>\n<li>같음 (<code>eq</code>)</li>\n<li>같지 않음 (<code>ne</code>)</li>\n<li>작음 (<code>lt</code>)</li>\n<li>작거나 같음 (<code>le</code>)</li>\n<li>큼 (<code>gt</code>)</li>\n<li>크거나 같음 (<code>gt</code>)</li>\n<li>div (<code>/</code>)</li>\n<li>mod (<code>%</code>)</li>\n<li>not (<code>!</code>)</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"22 eq 22\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"'test' eq 'test!'\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"정규-표현식\">정규 표현식</h2>\n<p>matches를 이용한 정규표현식을 지원한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"'5.00' matches '^-?\\\\d+(\\\\.\\\\d&#123;2&#125;)?$'\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d&#123;2&#125;)?$'\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"instanceof\">instanceof</h2>\n<p>Java에서 super타입에 대한 연산을 위해 instanceof를 표현식으로 사용할 수 있다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"'xyz' instanceof T(int)\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"'xyz' instanceof T(String)\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"논리연산자\">논리연산자</h2>\n<p>AND, OR, NOT에 대한 표현식을 지원한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- AND --</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"true and false\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\">String expression =  <span class=\"string\">\"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- OR --</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"true or false\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\">String expression =  <span class=\"string\">\"isMember('Nikola Tesla') or isMember('Albert Einstien')\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- NOT --</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"!true\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- AND and NOT --</span></span><br><span class=\"line\">String expression =  <span class=\"string\">\"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"수식-연산자\">수식 연산자</h2>\n<ul>\n<li>더하기 (+) 연산자를 숫자, 날짜, 문자열에 사용할 수 있다.</li>\n<li>빼기(-) 연산자를 숫자, 날짜에 사용할 수 있다.</li>\n<li>곱하기(*), 나누기(/), 나머지(%)에 대한 연산은 숫자에만 사용 할 수 있다.</li>\n<li>연산자 우선 순위 법칙이 적용된다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 더하기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> two = parser.parseExpression(<span class=\"string\">\"1 + 1\"</span>).getValue(Integer.class); <span class=\"comment\">// 2</span></span><br><span class=\"line\">String testString = parser.parseExpression(<span class=\"string\">\"'test' + ' ' + 'string'\"</span>).getValue(String.class);  <span class=\"comment\">// 'test string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 빼기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> four =  parser.parseExpression(<span class=\"string\">\"1 - -3\"</span>).getValue(Integer.class); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> d = parser.parseExpression(<span class=\"string\">\"1000.00 - 1e4\"</span>).getValue(Double.class); <span class=\"comment\">// -9000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 곱하기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> six =  parser.parseExpression(<span class=\"string\">\"-2 * -3\"</span>).getValue(Integer.class); <span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> twentyFour = parser.parseExpression(<span class=\"string\">\"2.0 * 3e0 * 4\"</span>).getValue(Double.class); <span class=\"comment\">// 24.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 나누기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minusTwo =  parser.parseExpression(<span class=\"string\">\"6 / -3\"</span>).getValue(Integer.class); <span class=\"comment\">// -2</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> one = parser.parseExpression(<span class=\"string\">\"8.0 / 4e0 / 2\"</span>).getValue(Double.class); <span class=\"comment\">// 1.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 계수(Modulus)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> three =  parser.parseExpression(<span class=\"string\">\"7 % 4\"</span>).getValue(Integer.class); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> one = parser.parseExpression(<span class=\"string\">\"8 / 5 % 2\"</span>).getValue(Integer.class); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 연산자 우선순위</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minusTwentyOne = parser.parseExpression(<span class=\"string\">\"1+2-3*8\"</span>).getValue(Integer.class); <span class=\"comment\">// -21</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3항-연산자-if-then-else\">3항 연산자 (If-Then-Else)</h2>\n<p>표현식에서 3항연산자를 통해 if-then-else 로직을 수행할 수 있다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//falseExp로 평가 된다.</span></span><br><span class=\"line\">String falseString = parser.parseExpression(<span class=\"string\">\"false ? 'trueExp' : 'falseExp'\"</span>).getValue(String.class);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"elvis-연산자\">Elvis 연산자</h2>\n<ul>\n<li>Elvis 연산자는 3항 연산자 구문을 단축시키고 Groovy 언어로 사용된다.</li>\n<li>3항 연산자는 변수를 2번 반복해서 써야하는 단점이 있다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = <span class=\"string\">\"Elvis Presley\"</span>;</span><br><span class=\"line\">String displayName = name != <span class=\"keyword\">null</span> ? name : <span class=\"string\">\"Unknown\"</span>;</span><br></pre></td></tr></table></figure></p>\n<p>이런 조잡한 표현식 대신에 Elvis 연산자를 사용하면..\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">String name = parser.parseExpression(<span class=\"string\">\"name?:'Unknown'\"</span>).getValue(String.class);  </span><br><span class=\"line\">System.out.println(name); <span class=\"comment\">// 'Unknown'</span></span><br></pre></td></tr></table></figure></p>\n<p>간단하게 변수에 대해 <code>?</code> 를 붙여주는 것만으로도 null 체크를 해준다.\n? 모양이 엘비스 프레슬리의 머리모양을 닮아서 Elvis 연산자라고 명명하였다고 한다.</p>\n<h2 id=\"안전한탐색navigation-연산자\">안전한탐색(Navigation) 연산자</h2>\n<ul>\n<li>안전한 탐색 연산자는 NPE를 피하기 위해 사용, Groovy 언어로 제공</li>\n<li>java로 코딩을 하다보면 습관적으로 if(variable == null) 과 같은 체크를 하게 된다.</li>\n<li>하지만 Safe Navigation 연산자를 사용하면 NPE를 발생시키지 않고, 그냥 null을 리턴해 준다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\"></span><br><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\">tesla.setPlaceOfBirth(<span class=\"keyword\">new</span> PlaceOfBirth(<span class=\"string\">\"Smiljan\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행</span></span><br><span class=\"line\">String city = parser.parseExpression(<span class=\"string\">\"PlaceOfBirth?.City\"</span>).getValue(context, String.class);</span><br><span class=\"line\">System.out.println(city); <span class=\"comment\">// Smiljan</span></span><br><span class=\"line\"></span><br><span class=\"line\">tesla.setPlaceOfBirth(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행</span></span><br><span class=\"line\">city = parser.parseExpression(<span class=\"string\">\"PlaceOfBirth?.City\"</span>).getValue(context, String.class);</span><br><span class=\"line\">System.out.println(city); <span class=\"comment\">// null - null pointer exception이 발생하지 않는다.</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"할당\">할당</h1>\n<ul>\n<li>할당연산자(<code>=</code>)를 이용하여 Context내의 프로퍼티에 value를 할당 할 수 있다.</li>\n<li>보통은 setValue 메서드를 이용하여 value를 할당</li>\n<li>getValue 메서드를 이용하여 할당 할 수도 있다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventor inventor = <span class=\"keyword\">new</span> Inventor();</span><br><span class=\"line\">StandardEvaluationContext inventorContext = <span class=\"keyword\">new</span> StandardEvaluationContext(inventor);</span><br><span class=\"line\"><span class=\"comment\">//inventor.name에 Alexander Seovic2 문자열을 할당</span></span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"Name\"</span>).setValue(inventorContext, <span class=\"string\">\"Alexander Seovic2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//할당연산자(`=`)를 이용하여 inventor.name에 Alexander Seovic2 문자열을 할당</span></span><br><span class=\"line\">String aleks = parser.parseExpression(<span class=\"string\">\"Name = 'Alexandar Seovic'\"</span>).getValue(inventorContext, String.class);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"클래스-표현식\">클래스 표현식</h1>\n<ul>\n<li><code>T</code> 연산자를 통해 클래스의 인스턴스를 지정하는데 사용할 수 있다.</li>\n<li><code>T</code> 연산자를 통해 클래스의 static method도 사용할 수 있다.</li>\n<li>웬만하면 full package를 적어준다.</li>\n<li>StandardEvaluationContext는 타입을 찾으려고 TypeLocator를 사용</li>\n<li>StandardTypeLocator는 java.lang 패키지로 만들어진다.</li>\n<li>따라서 java.lang.String과 같은 타입은 T(String)으로 간단하게 표현 가능하다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class dateClass = parser.parseExpression(<span class=\"string\">\"T(java.util.Date)\"</span>).getValue(Class.class);</span><br><span class=\"line\"></span><br><span class=\"line\">Class stringClass = parser.parseExpression(<span class=\"string\">\"T(String)\"</span>).getValue(Class.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"생성자-호출\">생성자 호출</h1>\n<ul>\n<li>생성자는 새로운 연산자를 사용해서 호출할 수 있다.</li>\n<li>primitive type(원시 타입 int, double등..)과 String 외에는 모두 정규화된 클래스명을 사용해야 한다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventor einstein = p.parseExpression(<span class=\"string\">\"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')\"</span>).getValue(Inventor.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//리스트의 add 메서드내에서 새로운 inventor 인스턴스를 생성한다</span></span><br><span class=\"line\">p.parseExpression(<span class=\"string\">\"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))\"</span>).getValue(societyContext);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"변수\">변수</h1>\n<ul>\n<li><code>#</code> 표현식을 통해 표현식 내에 변수를 참조할 수 있다.</li>\n<li>StandardEvaluationContext에서 setVariable 메서드를 사용해서 변수를 설정한다.</li>\n<li>자주 쓰이는 표현식이다. (@Cacheable Annotation에서도 사용)</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\">context.setVariable(<span class=\"string\">\"newName\"</span>, <span class=\"string\">\"Mike Tesla\"</span>); <span class=\"comment\">//newName변수에 대한 value할당</span></span><br><span class=\"line\"></span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"Name = #newName\"</span>).getValue(context);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(tesla.getName()) <span class=\"comment\">// \"Mike Tesla\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"root\">#root</h2>\n<ul>\n<li>변수 #root는 항상 정의되며 루트 컨텍스트 개체의미</li>\n<li>#root는 항상 루트를 나타낸다.</li>\n<li>setRootObject 메서드를 통해 root를 정의한다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\"></span><br><span class=\"line\">SomeCustomObject someObject = <span class=\"keyword\">new</span> SomeCustomObject();</span><br><span class=\"line\">context.setRootObject(someObject);</span><br><span class=\"line\"></span><br><span class=\"line\">String name = <span class=\"string\">\"kocko\"</span>;</span><br><span class=\"line\">context.setVariable(<span class=\"string\">\"name\"</span>, kocko);</span><br><span class=\"line\">String statement = <span class=\"string\">\"#root.stringLength(#kocko) == 5\"</span>;</span><br><span class=\"line\">Expression expression = parser.parseExpression(statement);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> result = expression.getValue(context, Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>#root는 SomeCustomObject를 의미</li>\n</ul>\n<h2 id=\"this\">#this</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create an array of integers</span></span><br><span class=\"line\">List&lt;Integer&gt; primes = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">primes.addAll(Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">13</span>,<span class=\"number\">17</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 파서를 생성하고 'primes' 변수를 정수 배열로 설정한다</span></span><br><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\">context.setVariable(<span class=\"string\">\"primes\"</span>,primes);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 리스트에서 10보다 큰 모든 소수(?&#123;...&#125; 선택을 사용)</span></span><br><span class=\"line\"><span class=\"comment\">// [11, 13, 17]로 평가된다</span></span><br><span class=\"line\">List&lt;Integer&gt;</span><br><span class=\"line\"> primesGreaterThanTen = (List&lt;Integer&gt;) </span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"#primes.?[#this&gt;10]\"</span>).getValue(context);</span><br><span class=\"line\"><span class=\"comment\">//#primes 변수에 대해 평가하며, #this는 2~17까지 값을 의미한다.</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>#this는 항상 정의되어 있고, 현재 평가되는 객체를 가리킨다.</li>\n<li>#this는 계속 변경될 수 있다. (위의 예제에서 보면 2,3,5,7등 평가 시점에 따라 달라질수 있다.)</li>\n</ul>\n<h1 id=\"사용자-정의-함수\">사용자 정의 함수</h1>\n<ul>\n<li>표현식 문자열 내에서 호출 가능한 사용자 정의 함수를 등록하여 SpEL의 기능을 확장할 수 있다.</li>\n<li>StandardEvaluationContext에 사용자정의 함수를 등록하여 사용하면 된다.</li>\n</ul>\n<p>예시로 문자열을 reverse 하는 메서드를 구현하였다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringUtils</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">reverseString</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder backwards = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; input.length(); i++)</span><br><span class=\"line\">            backwards.append(input.charAt(input.length() - <span class=\"number\">1</span> - i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> backwards.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>메서드를 StandardEvaluationContext에 등록\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//StringUtils 클래스에 정의된 reserveString 메서드를 등록한다.</span></span><br><span class=\"line\"><span class=\"comment\">//파라미터 타입은 String 타입 객체 1개이다.</span></span><br><span class=\"line\">context.registerFunction(<span class=\"string\">\"reverseString\"</span>, StringUtils.class.getDeclaredMethod(<span class=\"string\">\"reverseString\"</span>, <span class=\"keyword\">new</span> Class[] &#123; String.class &#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//hello 문자열을 뒤집은 olleh가 리턴된다.</span></span><br><span class=\"line\">String helloWorldReversed = parser.parseExpression(<span class=\"string\">\"#reverseString('hello')\"</span>).getValue(context, String.class);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"bean-참조\">Bean 참조</h1>\n<p>evaluation context에 Bean Resolver가 설정된 경우 <code>@</code> 표현식으로 bean을 사용할 수 있다.\nSpring Docs에 있는 예제는 잘 이해가 안되어 직접 테스트 해보았다.</p>\n<p>Bean 클래스 생성\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"do Test\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ApplicationContext applicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/test\"</span>)</span><br><span class=\"line\">\t<span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">\t\tStandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//실용적인 테스트를 위해 Application Context의 BeanFactory를 설정</span></span><br><span class=\"line\">\t\tDefaultListableBeanFactory factory = (DefaultListableBeanFactory) ((ConfigurableApplicationContext) applicationContext).getBeanFactory();</span><br><span class=\"line\">\t\tcontext.setBeanResolver(<span class=\"keyword\">new</span> BeanFactoryResolver(factory));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//Application Context에 등록된 testBean이라는 bean을 불러와 test메서드를 실행하였다.</span></span><br><span class=\"line\">\t\tString result = parser.parseExpression(<span class=\"string\">\"@testBean.test()\"</span>).getValue(context, String.class);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result; <span class=\"comment\">//do Test가 리턴되었다.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"collection-선택-기능\">Collection 선택 기능</h1>\n<ul>\n<li>컬렉션 (Collection) 선택 기능은 Context내의 Collection 필드에 접근하여 조건(Criteria)를 기반으로 서브 컬렉션을 반환 할 수 있다.</li>\n<li><code>?[selectionExpression]</code> 표현식을 이용한다.</li>\n<li>리스트, 맵에서 모두 사용 가능하다</li>\n<li>객체가 context로 들어오는 경우 object.?[필드에 대한 조건]</li>\n<li>컬렉션이 context로 들어오는 경우 .?[필드에 대한 조건] (별도의 필드가 없는 경우 #this를 사용)</li>\n</ul>\n<p>Twice 클래스를 선언\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Twice</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Getter</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Member&gt; members = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;() &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"지효\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"나연\"</span>, <span class=\"number\">24</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"모모\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"사나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"다현\"</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"미나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"채영\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"쯔위\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"정연\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Twice&gt; <span class=\"title\">twice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">    StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Twice의 멤버 필드에 접근</span></span><br><span class=\"line\">    <span class=\"comment\">// 컬렉션의 age 필드에 대해 20 이하인 대상을 반환</span></span><br><span class=\"line\">    List&lt;Twice&gt; filterList = (List&lt;Twice&gt;) parser.parseExpression(<span class=\"string\">\"members.?[age &lt; 20]\"</span>).getValue(<span class=\"keyword\">new</span> Twice());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> filterList; <span class=\"comment\">//[&#123;\"name\":\"채영\",\"age\":19&#125;,&#123;\"name\":\"쯔위\",\"age\":19&#125;]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"collection-투영-기능\">Collection 투영 기능</h1>\n<ul>\n<li>투영기능은 컬렉션에 하위표현식을 반영하여 새로운 컬렉션을 리턴한다.</li>\n<li><code>![projectionExpression]</code> 표현식을 사용한다.</li>\n</ul>\n<p>위의 Twice 예제를 바탕으로 설명하겠다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">twice2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">    StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Member&gt; testList = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;() &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"지효\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"나연\"</span>, <span class=\"number\">24</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"모모\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"사나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"다현\"</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"미나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"채영\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"쯔위\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"정연\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Twice 멤버 배열을 받아, 컬렉션 투영기능을 이용하여 그중 name에 대한 필드만 뽑아온 것이다.</span></span><br><span class=\"line\">    List&lt;String&gt; filterList = (List&lt;String&gt;) parser.parseExpression(<span class=\"string\">\"![name]\"</span>).getValue(testList);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> filterList; <span class=\"comment\">//[\"지효\",\"나연\",\"모모\",\"사나\",\"다현\",\"미나\",\"채영\",\"쯔위\",\"정연\"]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"표현식-템플릿\">표현식 템플릿</h1>\n<ul>\n<li>표현식 템플릿을 사용하면 평가 블록과 Literal text를 혼합할 수 있다.</li>\n<li>평가블록은 prefix와 subfix로 구분</li>\n<li>일반적으로 <code>#{</code> 와 <code>}</code>로 구분한다.</li>\n<li>parseExpression() 메서드의 두번째 파라미터로 사용자 정의 ParseContext 객체를 넣어준다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TemplateParserContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">ParserContext</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getExpressionPrefix</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"#&#123;\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getExpressionSuffix</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"&#125;\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// \"random number is 0.7038186818312008\"로 평가된다</span></span><br><span class=\"line\">String randomPhrase = </span><br><span class=\"line\">   parser.parseExpression(<span class=\"string\">\"random number is #&#123;T(java.lang.Math).random()&#125;\"</span>, <span class=\"keyword\">new</span> TemplateParserContext()).getValue(String.class);</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>리터럴 표현식 (Literal Expression)</h1>\n<p>리터럴 표현식을 제공하는 타입은 문자열(String), 숫자(int, real, hex), boolean, null이다.</p>\n<ul>\n<li>문자열 (Strings)는 따옴표(')로 구분된다 <code>(쌍따옴표가 아님)</code> - 문자열 표현 시, <code>'Hello World'</code> 처럼 SpEL을 작성</li>\n</ul>\n<p>다음은 리터럴 표현식 (Literal Expression)에 대한 간단한 예제이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//따옴표로 이루어진 'Hello World' =&gt; Hello World라는 문자열로 평가 된다.</span></span><br><span class=\"line\">String helloWorld = (String) parser.parseExpression(<span class=\"string\">\"'Hello World'\"</span>).getValue();</span><br><span class=\"line\"><span class=\"comment\">//Double 타입의 숫자로 평가</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> avogadrosNumber = (Double) parser.parseExpression(<span class=\"string\">\"6.0221415E+23\"</span>).getValue();</span><br><span class=\"line\"><span class=\"comment\">//2147483647로 평가</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> maxValue = (Integer) parser.parseExpression(<span class=\"string\">\"0x7FFFFFFF\"</span>).getValue();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = (Boolean) parser.parseExpression(<span class=\"string\">\"true\"</span>).getValue();</span><br><span class=\"line\"><span class=\"comment\">//null로 평가 된다. -&gt; null String이 아니다. (주의)</span></span><br><span class=\"line\">Object nullValue = parser.parseExpression(<span class=\"string\">\"null\"</span>).getValue();</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>숫자는 음수기호(-), 지수표시(E), 소수점(.)을 지원한다.</li>\n<li>기본적으로 실제 숫자는 Double.parseDouble()로 파싱한다.</li>\n</ul>\n<h1>메서드 호출</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//String 리터럴 abc에 대한 substring 메서드 호출 -&gt; bc가 리턴된다.</span></span><br><span class=\"line\">String c = parser.parseExpression(<span class=\"string\">\"'abc'.substring(2, 3)\"</span>).getValue(String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//사용자 정의 메서드 호출 (Return Type : Boolean) -&gt; boolean 타입으로 평가된다.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isMember = parser.parseExpression(<span class=\"string\">\"isMember('Mihajlo Pupin')\"</span>).getValue(</span><br><span class=\"line\">        societyContext, Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<p>위의 코드는 메서드 호출에 대한 예제 코드이다.</p>\n<ul>\n<li>메서드는 Java 문법을 사용하여 호출 할 수 있다.</li>\n<li>Literal에 대한 메서드 호출도 가능하다.</li>\n<li>Varargs 형식의 파라미터도 지원하고 있다.</li>\n</ul>\n<h1>프로퍼티, 배열, 리스트, 맵에 대한 접근 지원</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 발명품 배열</span></span><br><span class=\"line\">StandardEvaluationContext teslaContext = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Induction motor\"로 평가된다.</span></span><br><span class=\"line\">String invention = parser.parseExpression(<span class=\"string\">\"inventions[3]\"</span>).getValue(teslaContext, String.class); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 회원 리스트</span></span><br><span class=\"line\">StandardEvaluationContext societyContext = <span class=\"keyword\">new</span> StandardEvaluationContext(ieee);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Nikola Tesla\"로 평가된다.</span></span><br><span class=\"line\">String name = parser.parseExpression(<span class=\"string\">\"Members[0].Name\"</span>).getValue(societyContext, String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 리스트와 배열 탐색</span></span><br><span class=\"line\"><span class=\"comment\">// \"Wireless communication\"로 평가된다.</span></span><br><span class=\"line\">String invention = parser.parseExpression(<span class=\"string\">\"Members[0].Inventions[6]\"</span>).getValue(societyContext, String.class);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>프로퍼티의 맨 첫글자는 대소문자를 구별하지 않는다.</li>\n<li>SpEL은 표준 <code>dot 표기법</code>(예: prop1.prop2.prop3)을 사용해서 중첩된 프로퍼티와 프로퍼티의 값 설정도 지원한다.</li>\n<li>public 필드에 대한 접근을 지원한다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Officer의 딕션어리</span></span><br><span class=\"line\">Inventor pupin = parser.parseExpression(<span class=\"string\">\"Officers['president']\"</span>).getValue(societyContext, Inventor.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Idvor\"로 평가된다</span></span><br><span class=\"line\">String city = parser.parseExpression(<span class=\"string\">\"Officers['president'].PlaceOfBirth.City\"</span>).getValue(societyContext, String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 값을 설정한다</span></span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"Officers['advisors'][0].PlaceOfBirth.Country\"</span>).setValue(societyContext, <span class=\"string\">\"Croatia\"</span>);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>대괄호<code>[]</code> 를 사용하여 Map의 key를 바탕으로 데이터에 접근한다.\n(위의 예제에서는 Officers가 <code>Map</code>, president가 <code>key</code>이다.)</li>\n<li>SpEL은 표준 'dot' 표기법(예: prop1.prop2.prop3)을 사용해서 Map내의 value 객체의 프로퍼티에도 접근 가능하다.</li>\n<li>setValue 메서드를 통해 데이터를 수정할 수 있다.</li>\n</ul>\n<h1>인라인 리스트 (Inline list)</h1>\n<p>리스트는 {} 표기법을 사용하여 리스트로 사용 할 수 있다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 4개의 숫자를 담고 있는 리스트로 평가된다</span></span><br><span class=\"line\">List&lt;Integer&gt; numbers = (List) parser.parseExpression(<span class=\"string\">\"&#123;1,2,3,4&#125;\"</span>).getValue(context); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//List의 List의 형태의 List로 평가된다.</span></span><br><span class=\"line\"><span class=\"comment\">//listOfLists[0] = &#123;'a', 'b'&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//listOfLists[1] = &#123;'x', 'y'&#125;</span></span><br><span class=\"line\">List listOfLists = (List) parser.parseExpression(<span class=\"string\">\"&#123;&#123;'a','b'&#125;,&#123;'x','y'&#125;&#125;\"</span>).getValue(context);</span><br></pre></td></tr></table></figure></p>\n<h1>배열 생성</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] numbers1 = (<span class=\"keyword\">int</span>[]) parser.parseExpression(<span class=\"string\">\"new int[4]\"</span>).getValue(context); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// initializer가진 배열</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] numbers2 = (<span class=\"keyword\">int</span>[]) parser.parseExpression(<span class=\"string\">\"new int[]&#123;1,2,3&#125;\"</span>).getValue(context); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 다차원 배열</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[][] numbers3 = (<span class=\"keyword\">int</span>[][]) parser.parseExpression(<span class=\"string\">\"new int[4][5]\"</span>).getValue(context);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>Java 문법과 같은 표현식을 사용하여 배열을 생성 할 수 있다.</li>\n<li>{} 표현식을 통해 초기값을 세팅할 수 있다.</li>\n<li>2차원 배열이상의 다차원 배열도 선언이 가능하다. (<code>단, 다차원 배열은 초기값을 설정할 수 없다.</code>)</li>\n</ul>\n<h1>연산자</h1>\n<h2>관계 연산자</h2>\n<p>표준 관계 연산자를 사용한다. 사용 할 수 있는 관계 연산자는 아래와 같다.</p>\n<ul>\n<li>같음 (<code>==</code>)</li>\n<li>같지 않음 (<code>!=</code>)</li>\n<li>작음 (<code>&lt;</code>)</li>\n<li>작거나 같음 (<code>&lt;=</code>)</li>\n<li>큼 (<code>&gt;</code>)</li>\n<li>크거나 같음 (<code>&gt;=</code>)</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"2 == 2\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"2 &lt; -5.0\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"'black' &lt; 'block'\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<h2>심볼릭 연산자</h2>\n<p>XML과 같이 문서형식에 관계 연산자가 제한을 받는 경우, 사용 가능한 문자 표현식을 제공한다.\n연산자에 대한 대소문자는 구별하지 않는다.</p>\n<ul>\n<li>같음 (<code>eq</code>)</li>\n<li>같지 않음 (<code>ne</code>)</li>\n<li>작음 (<code>lt</code>)</li>\n<li>작거나 같음 (<code>le</code>)</li>\n<li>큼 (<code>gt</code>)</li>\n<li>크거나 같음 (<code>gt</code>)</li>\n<li>div (<code>/</code>)</li>\n<li>mod (<code>%</code>)</li>\n<li>not (<code>!</code>)</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"22 eq 22\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"'test' eq 'test!'\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<h2>정규 표현식</h2>\n<p>matches를 이용한 정규표현식을 지원한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"'5.00' matches '^-?\\\\d+(\\\\.\\\\d&#123;2&#125;)?$'\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d&#123;2&#125;)?$'\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<h2>instanceof</h2>\n<p>Java에서 super타입에 대한 연산을 위해 instanceof를 표현식으로 사용할 수 있다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"'xyz' instanceof T(int)\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"'xyz' instanceof T(String)\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<h2>논리연산자</h2>\n<p>AND, OR, NOT에 대한 표현식을 지원한다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- AND --</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"true and false\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\">String expression =  <span class=\"string\">\"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- OR --</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"true or false\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\">String expression =  <span class=\"string\">\"isMember('Nikola Tesla') or isMember('Albert Einstien')\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- NOT --</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"!true\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- AND and NOT --</span></span><br><span class=\"line\">String expression =  <span class=\"string\">\"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<h2>수식 연산자</h2>\n<ul>\n<li>더하기 (+) 연산자를 숫자, 날짜, 문자열에 사용할 수 있다.</li>\n<li>빼기(-) 연산자를 숫자, 날짜에 사용할 수 있다.</li>\n<li>곱하기(*), 나누기(/), 나머지(%)에 대한 연산은 숫자에만 사용 할 수 있다.</li>\n<li>연산자 우선 순위 법칙이 적용된다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 더하기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> two = parser.parseExpression(<span class=\"string\">\"1 + 1\"</span>).getValue(Integer.class); <span class=\"comment\">// 2</span></span><br><span class=\"line\">String testString = parser.parseExpression(<span class=\"string\">\"'test' + ' ' + 'string'\"</span>).getValue(String.class);  <span class=\"comment\">// 'test string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 빼기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> four =  parser.parseExpression(<span class=\"string\">\"1 - -3\"</span>).getValue(Integer.class); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> d = parser.parseExpression(<span class=\"string\">\"1000.00 - 1e4\"</span>).getValue(Double.class); <span class=\"comment\">// -9000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 곱하기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> six =  parser.parseExpression(<span class=\"string\">\"-2 * -3\"</span>).getValue(Integer.class); <span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> twentyFour = parser.parseExpression(<span class=\"string\">\"2.0 * 3e0 * 4\"</span>).getValue(Double.class); <span class=\"comment\">// 24.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 나누기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minusTwo =  parser.parseExpression(<span class=\"string\">\"6 / -3\"</span>).getValue(Integer.class); <span class=\"comment\">// -2</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> one = parser.parseExpression(<span class=\"string\">\"8.0 / 4e0 / 2\"</span>).getValue(Double.class); <span class=\"comment\">// 1.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 계수(Modulus)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> three =  parser.parseExpression(<span class=\"string\">\"7 % 4\"</span>).getValue(Integer.class); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> one = parser.parseExpression(<span class=\"string\">\"8 / 5 % 2\"</span>).getValue(Integer.class); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 연산자 우선순위</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minusTwentyOne = parser.parseExpression(<span class=\"string\">\"1+2-3*8\"</span>).getValue(Integer.class); <span class=\"comment\">// -21</span></span><br></pre></td></tr></table></figure></p>\n<h2>3항 연산자 (If-Then-Else)</h2>\n<p>표현식에서 3항연산자를 통해 if-then-else 로직을 수행할 수 있다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//falseExp로 평가 된다.</span></span><br><span class=\"line\">String falseString = parser.parseExpression(<span class=\"string\">\"false ? 'trueExp' : 'falseExp'\"</span>).getValue(String.class);</span><br></pre></td></tr></table></figure></p>\n<h2>Elvis 연산자</h2>\n<ul>\n<li>Elvis 연산자는 3항 연산자 구문을 단축시키고 Groovy 언어로 사용된다.</li>\n<li>3항 연산자는 변수를 2번 반복해서 써야하는 단점이 있다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = <span class=\"string\">\"Elvis Presley\"</span>;</span><br><span class=\"line\">String displayName = name != <span class=\"keyword\">null</span> ? name : <span class=\"string\">\"Unknown\"</span>;</span><br></pre></td></tr></table></figure></p>\n<p>이런 조잡한 표현식 대신에 Elvis 연산자를 사용하면..\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">String name = parser.parseExpression(<span class=\"string\">\"name?:'Unknown'\"</span>).getValue(String.class);  </span><br><span class=\"line\">System.out.println(name); <span class=\"comment\">// 'Unknown'</span></span><br></pre></td></tr></table></figure></p>\n<p>간단하게 변수에 대해 <code>?</code> 를 붙여주는 것만으로도 null 체크를 해준다.\n? 모양이 엘비스 프레슬리의 머리모양을 닮아서 Elvis 연산자라고 명명하였다고 한다.</p>\n<h2>안전한탐색(Navigation) 연산자</h2>\n<ul>\n<li>안전한 탐색 연산자는 NPE를 피하기 위해 사용, Groovy 언어로 제공</li>\n<li>java로 코딩을 하다보면 습관적으로 if(variable == null) 과 같은 체크를 하게 된다.</li>\n<li>하지만 Safe Navigation 연산자를 사용하면 NPE를 발생시키지 않고, 그냥 null을 리턴해 준다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\"></span><br><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\">tesla.setPlaceOfBirth(<span class=\"keyword\">new</span> PlaceOfBirth(<span class=\"string\">\"Smiljan\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행</span></span><br><span class=\"line\">String city = parser.parseExpression(<span class=\"string\">\"PlaceOfBirth?.City\"</span>).getValue(context, String.class);</span><br><span class=\"line\">System.out.println(city); <span class=\"comment\">// Smiljan</span></span><br><span class=\"line\"></span><br><span class=\"line\">tesla.setPlaceOfBirth(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행</span></span><br><span class=\"line\">city = parser.parseExpression(<span class=\"string\">\"PlaceOfBirth?.City\"</span>).getValue(context, String.class);</span><br><span class=\"line\">System.out.println(city); <span class=\"comment\">// null - null pointer exception이 발생하지 않는다.</span></span><br></pre></td></tr></table></figure></p>\n<h1>할당</h1>\n<ul>\n<li>할당연산자(<code>=</code>)를 이용하여 Context내의 프로퍼티에 value를 할당 할 수 있다.</li>\n<li>보통은 setValue 메서드를 이용하여 value를 할당</li>\n<li>getValue 메서드를 이용하여 할당 할 수도 있다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventor inventor = <span class=\"keyword\">new</span> Inventor();</span><br><span class=\"line\">StandardEvaluationContext inventorContext = <span class=\"keyword\">new</span> StandardEvaluationContext(inventor);</span><br><span class=\"line\"><span class=\"comment\">//inventor.name에 Alexander Seovic2 문자열을 할당</span></span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"Name\"</span>).setValue(inventorContext, <span class=\"string\">\"Alexander Seovic2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//할당연산자(`=`)를 이용하여 inventor.name에 Alexander Seovic2 문자열을 할당</span></span><br><span class=\"line\">String aleks = parser.parseExpression(<span class=\"string\">\"Name = 'Alexandar Seovic'\"</span>).getValue(inventorContext, String.class);</span><br></pre></td></tr></table></figure></p>\n<h1>클래스 표현식</h1>\n<ul>\n<li><code>T</code> 연산자를 통해 클래스의 인스턴스를 지정하는데 사용할 수 있다.</li>\n<li><code>T</code> 연산자를 통해 클래스의 static method도 사용할 수 있다.</li>\n<li>웬만하면 full package를 적어준다.</li>\n<li>StandardEvaluationContext는 타입을 찾으려고 TypeLocator를 사용</li>\n<li>StandardTypeLocator는 java.lang 패키지로 만들어진다.</li>\n<li>따라서 java.lang.String과 같은 타입은 T(String)으로 간단하게 표현 가능하다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class dateClass = parser.parseExpression(<span class=\"string\">\"T(java.util.Date)\"</span>).getValue(Class.class);</span><br><span class=\"line\"></span><br><span class=\"line\">Class stringClass = parser.parseExpression(<span class=\"string\">\"T(String)\"</span>).getValue(Class.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<h1>생성자 호출</h1>\n<ul>\n<li>생성자는 새로운 연산자를 사용해서 호출할 수 있다.</li>\n<li>primitive type(원시 타입 int, double등..)과 String 외에는 모두 정규화된 클래스명을 사용해야 한다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventor einstein = p.parseExpression(<span class=\"string\">\"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')\"</span>).getValue(Inventor.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//리스트의 add 메서드내에서 새로운 inventor 인스턴스를 생성한다</span></span><br><span class=\"line\">p.parseExpression(<span class=\"string\">\"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))\"</span>).getValue(societyContext);</span><br></pre></td></tr></table></figure></p>\n<h1>변수</h1>\n<ul>\n<li><code>#</code> 표현식을 통해 표현식 내에 변수를 참조할 수 있다.</li>\n<li>StandardEvaluationContext에서 setVariable 메서드를 사용해서 변수를 설정한다.</li>\n<li>자주 쓰이는 표현식이다. (@Cacheable Annotation에서도 사용)</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\">context.setVariable(<span class=\"string\">\"newName\"</span>, <span class=\"string\">\"Mike Tesla\"</span>); <span class=\"comment\">//newName변수에 대한 value할당</span></span><br><span class=\"line\"></span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"Name = #newName\"</span>).getValue(context);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(tesla.getName()) <span class=\"comment\">// \"Mike Tesla\"</span></span><br></pre></td></tr></table></figure></p>\n<h2>#root</h2>\n<ul>\n<li>변수 #root는 항상 정의되며 루트 컨텍스트 개체의미</li>\n<li>#root는 항상 루트를 나타낸다.</li>\n<li>setRootObject 메서드를 통해 root를 정의한다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\"></span><br><span class=\"line\">SomeCustomObject someObject = <span class=\"keyword\">new</span> SomeCustomObject();</span><br><span class=\"line\">context.setRootObject(someObject);</span><br><span class=\"line\"></span><br><span class=\"line\">String name = <span class=\"string\">\"kocko\"</span>;</span><br><span class=\"line\">context.setVariable(<span class=\"string\">\"name\"</span>, kocko);</span><br><span class=\"line\">String statement = <span class=\"string\">\"#root.stringLength(#kocko) == 5\"</span>;</span><br><span class=\"line\">Expression expression = parser.parseExpression(statement);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> result = expression.getValue(context, Boolean.class);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>#root는 SomeCustomObject를 의미</li>\n</ul>\n<h2>#this</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create an array of integers</span></span><br><span class=\"line\">List&lt;Integer&gt; primes = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">primes.addAll(Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">13</span>,<span class=\"number\">17</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 파서를 생성하고 'primes' 변수를 정수 배열로 설정한다</span></span><br><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\">context.setVariable(<span class=\"string\">\"primes\"</span>,primes);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 리스트에서 10보다 큰 모든 소수(?&#123;...&#125; 선택을 사용)</span></span><br><span class=\"line\"><span class=\"comment\">// [11, 13, 17]로 평가된다</span></span><br><span class=\"line\">List&lt;Integer&gt;</span><br><span class=\"line\"> primesGreaterThanTen = (List&lt;Integer&gt;) </span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"#primes.?[#this&gt;10]\"</span>).getValue(context);</span><br><span class=\"line\"><span class=\"comment\">//#primes 변수에 대해 평가하며, #this는 2~17까지 값을 의미한다.</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>#this는 항상 정의되어 있고, 현재 평가되는 객체를 가리킨다.</li>\n<li>#this는 계속 변경될 수 있다. (위의 예제에서 보면 2,3,5,7등 평가 시점에 따라 달라질수 있다.)</li>\n</ul>\n<h1>사용자 정의 함수</h1>\n<ul>\n<li>표현식 문자열 내에서 호출 가능한 사용자 정의 함수를 등록하여 SpEL의 기능을 확장할 수 있다.</li>\n<li>StandardEvaluationContext에 사용자정의 함수를 등록하여 사용하면 된다.</li>\n</ul>\n<p>예시로 문자열을 reverse 하는 메서드를 구현하였다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringUtils</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">reverseString</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder backwards = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; input.length(); i++)</span><br><span class=\"line\">            backwards.append(input.charAt(input.length() - <span class=\"number\">1</span> - i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> backwards.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>메서드를 StandardEvaluationContext에 등록\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//StringUtils 클래스에 정의된 reserveString 메서드를 등록한다.</span></span><br><span class=\"line\"><span class=\"comment\">//파라미터 타입은 String 타입 객체 1개이다.</span></span><br><span class=\"line\">context.registerFunction(<span class=\"string\">\"reverseString\"</span>, StringUtils.class.getDeclaredMethod(<span class=\"string\">\"reverseString\"</span>, <span class=\"keyword\">new</span> Class[] &#123; String.class &#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//hello 문자열을 뒤집은 olleh가 리턴된다.</span></span><br><span class=\"line\">String helloWorldReversed = parser.parseExpression(<span class=\"string\">\"#reverseString('hello')\"</span>).getValue(context, String.class);</span><br></pre></td></tr></table></figure></p>\n<h1>Bean 참조</h1>\n<p>evaluation context에 Bean Resolver가 설정된 경우 <code>@</code> 표현식으로 bean을 사용할 수 있다.\nSpring Docs에 있는 예제는 잘 이해가 안되어 직접 테스트 해보았다.</p>\n<p>Bean 클래스 생성\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"do Test\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ApplicationContext applicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/test\"</span>)</span><br><span class=\"line\">\t<span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">\t\tStandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//실용적인 테스트를 위해 Application Context의 BeanFactory를 설정</span></span><br><span class=\"line\">\t\tDefaultListableBeanFactory factory = (DefaultListableBeanFactory) ((ConfigurableApplicationContext) applicationContext).getBeanFactory();</span><br><span class=\"line\">\t\tcontext.setBeanResolver(<span class=\"keyword\">new</span> BeanFactoryResolver(factory));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//Application Context에 등록된 testBean이라는 bean을 불러와 test메서드를 실행하였다.</span></span><br><span class=\"line\">\t\tString result = parser.parseExpression(<span class=\"string\">\"@testBean.test()\"</span>).getValue(context, String.class);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result; <span class=\"comment\">//do Test가 리턴되었다.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>Collection 선택 기능</h1>\n<ul>\n<li>컬렉션 (Collection) 선택 기능은 Context내의 Collection 필드에 접근하여 조건(Criteria)를 기반으로 서브 컬렉션을 반환 할 수 있다.</li>\n<li><code>?[selectionExpression]</code> 표현식을 이용한다.</li>\n<li>리스트, 맵에서 모두 사용 가능하다</li>\n<li>객체가 context로 들어오는 경우 object.?[필드에 대한 조건]</li>\n<li>컬렉션이 context로 들어오는 경우 .?[필드에 대한 조건] (별도의 필드가 없는 경우 #this를 사용)</li>\n</ul>\n<p>Twice 클래스를 선언\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Twice</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Getter</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Member&gt; members = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;() &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"지효\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"나연\"</span>, <span class=\"number\">24</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"모모\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"사나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"다현\"</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"미나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"채영\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"쯔위\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"정연\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Twice&gt; <span class=\"title\">twice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">    StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Twice의 멤버 필드에 접근</span></span><br><span class=\"line\">    <span class=\"comment\">// 컬렉션의 age 필드에 대해 20 이하인 대상을 반환</span></span><br><span class=\"line\">    List&lt;Twice&gt; filterList = (List&lt;Twice&gt;) parser.parseExpression(<span class=\"string\">\"members.?[age &lt; 20]\"</span>).getValue(<span class=\"keyword\">new</span> Twice());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> filterList; <span class=\"comment\">//[&#123;\"name\":\"채영\",\"age\":19&#125;,&#123;\"name\":\"쯔위\",\"age\":19&#125;]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>Collection 투영 기능</h1>\n<ul>\n<li>투영기능은 컬렉션에 하위표현식을 반영하여 새로운 컬렉션을 리턴한다.</li>\n<li><code>![projectionExpression]</code> 표현식을 사용한다.</li>\n</ul>\n<p>위의 Twice 예제를 바탕으로 설명하겠다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">twice2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">    StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Member&gt; testList = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;() &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"지효\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"나연\"</span>, <span class=\"number\">24</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"모모\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"사나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"다현\"</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"미나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"채영\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"쯔위\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"정연\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Twice 멤버 배열을 받아, 컬렉션 투영기능을 이용하여 그중 name에 대한 필드만 뽑아온 것이다.</span></span><br><span class=\"line\">    List&lt;String&gt; filterList = (List&lt;String&gt;) parser.parseExpression(<span class=\"string\">\"![name]\"</span>).getValue(testList);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> filterList; <span class=\"comment\">//[\"지효\",\"나연\",\"모모\",\"사나\",\"다현\",\"미나\",\"채영\",\"쯔위\",\"정연\"]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1>표현식 템플릿</h1>\n<ul>\n<li>표현식 템플릿을 사용하면 평가 블록과 Literal text를 혼합할 수 있다.</li>\n<li>평가블록은 prefix와 subfix로 구분</li>\n<li>일반적으로 <code>#{</code> 와 <code>}</code>로 구분한다.</li>\n<li>parseExpression() 메서드의 두번째 파라미터로 사용자 정의 ParseContext 객체를 넣어준다.</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TemplateParserContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">ParserContext</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getExpressionPrefix</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"#&#123;\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getExpressionSuffix</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"&#125;\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// \"random number is 0.7038186818312008\"로 평가된다</span></span><br><span class=\"line\">String randomPhrase = </span><br><span class=\"line\">   parser.parseExpression(<span class=\"string\">\"random number is #&#123;T(java.lang.Math).random()&#125;\"</span>, <span class=\"keyword\">new</span> TemplateParserContext()).getValue(String.class);</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Item 10. Equals는 일반 규약을 지켜 재정의하라","catalog":true,"Categories":["Effective-Java"],"typora-root-url":"effective-java-item10","typora-copy-images-to":"effective-java-item10","date":"2019-01-10T12:14:20.000Z","subtitle":null,"header-img":null,"_content":"\n# 서론\nequals 메서드는 Object 클래스에 구현된 메서드로 객체 내의 정보들에 대한 동등성(equality) 비교를 목적으로 하는 메서드이다.  \nequals 메서드를 잘못 작성하게 되면 의도하지 않는 결과들이 초래되므로 웬만하면 변경하지 않는 것이 좋다.\n\n# equals를 재정의 하지 않아도 되는 경우\n* 각 인스턴스가 본질적으로 고유 한 경우 - 값이 아닌 동작을 표현하는 클래스의 경우 (Thread가 좋은 예이다.)\n* 인스턴스의 논리적 동치성 (Logical Equality)를 검사할 일이 없는 경우 - `java.utils.regex.Pattern`의 equals는 내부의 정규표현식이 같은지를 검사하는 메서드이다.\n* 상위 클래스에서 재정의한 equals가 하위 클래스에서도 적용 되는 경우 - Set, Map, List의 경우 Abstract(Type)의 equals를 쓴다.\n* 클래스가 private이거나, package-private여서 equals를 호출할 일이 없는 경우\n* 싱글턴을 보장하는 클래스(인스턴스 통제 클래스, Enum (열거타입)) 인 경우 - 객체 간 동등성, 동일성이 보장된다.\n\n# equals를 재정의 하는 경우 지켜야 할 규약\nequals를 재정의 해야 하는 경우는 객체 동일성(식별성(Object Identity))를 확인해야 하는 경우가 아니라  \n논리적 동치성(동등성(Logical equality))를 비교 하도록 재정의 되지 않았을 경우이다.\n\n## 반사성(reflexivity)\n**null이 아닌 모든 참조 값 x에 대해 x.equals(x)를 만족해야한다.**  \n단순히 말하면 객체는 자기 자신과 비교했을 때 같아야 한다는 뜻이다.  \n이 조건을 만족하지 않는 예를 찾기가 더 어렵다.  \n만약 x.equals(x)가 성립하지 않는 객체라면, 컬렉션에서 contain 메서드를 사용하는 경우 방금 넣은 객체도 찾을 수 없을 것이다.\n\n## 대칭성 (symmetry)\n**null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true이면, y.equals(x)가 true를 만족해야 한다.**  \n\n예시 코드를 보면\n```java\npublic final class CaseInsensitiveString {\n  private final String s;\n\n  public CaseInsensitiveString(String s) {\n    this.s = Objects.requireNonNull(s);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if(o instanceof CaseInsensitiveString) {\n      return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);\n    }\n\n    if(o instanceof String) { //한 방향으로만 작동!!\n      return s.equalsIgnoreCase((String) o);\n    }\n    return false;\n  }\n}\n```\n\n위의 클래스를 기반으로 \n```java\nCaseInsensitiveString caseInsensitiveString = new CaseInsensitiveString(\"Test\");\nString test = \"test\";\nSystem.out.println(caseInsensitiveString.equals(test)); //true\nSystem.out.println(test.equals(caseInsensitiveString)); //false\n```\n위의 코드를 실행하게 되면, x.equals(y)가 true일 때, y.equals(x)가 false이므로 `대칭성`이 깨지는 코드가 된다.  \nString 클래스에서는 CaseInsensitiveString의 존재를 모르기 때문에 false가 날 수 밖에 없는 상황이다.\n\n```java\nList<CaseInsensitiveString> list = new ArrayList<>();\nlist.add(new CaseInsensitiveString(\"Test\"));\nSystem.out.println(list.contain(\"test\")); //false or true\n```\n위의 예제의 경우는 JDK버전에 따라 다를 수 있다. x.equals(y)로 비교할 수 도 있고, y.equals(x)로 비교될 수 있기 때문이다.\n\n위의 내용을 수정한다면, String과의 비교는 포기해야 한다.  \n같은 CaseInsensitiveString 타입인 경우에만 비교하도록 한다.\n```java\n@Override\npublic boolean equals(Object o) {\n  return o instanceof CaseInsensitiveString && ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);\n}\n```\n\n## 추이성 (transitivity)\n**null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y)가 true이고, y.equals(z)가 true이면 x.equals(z)도 true가 되야 한다는 조건이다.**\n\nPoint클래스와 ColorPoint 클래스를 가지고 예시를 들어보겠다.  \n(ColorPoint는 Point클래스를 확장(extends)한 클래스이다.)\n```java\nColorPoint a = new ColorPoint(1, 2, Color.RED);\nPoint b = new Point(1, 2);\nColorPoint c = new ColorPoint(1, 2, Color.BLUE);\n```\n위와 같은 인스턴스 a, b, c가 있다.\n이 때, a.equals(b)와 b.equals(c) 일 때, a.equals(c)\n가 되는 과정을 살펴 보자\n\n```java\nclass Point {\n  private final int x;\n  private final int y;\n\n  public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if(!(o instanceof Point)) return false;\n    Point p = (Point) o;\n    return this.x == p.x && this.y == p.y;\n  }\n}\n```\n\n### 대칭성이 위배되는 case\n```java\nclass ColorPoint extends Point {\n  \n  private final Color color;\n\n  @Override\n  public boolean equals(Object o) {\n    if(!(o instanceof ColorPoint)) return false;\n    \n    return super.equals(o) && this.color == ((ColorPoint) o).color;\n  }\n}\n```\n\n위 처럼 ColorPoint 클래스의 equals 메서드를 재정의 했다면... \n```java\nColorPoint a = new ColorPoint(1, 2, Color.RED);\nPoint b = new Point(1, 2);\n\nSystem.out.println(a.equals(b)); //false\nSystem.out.println(b.equals(a)); //true\n```\n1. `a.equals(b)`를 보면 a는 ColorPoint이기 떄문에 ColorPoint 클래스에서 재정의 된 equals 메서드를 타게 된다.  \n이렇게 되면 첫번째 if 조건에서 걸리게 된다. b는 Point이지만 ColorPoint는 아니기 떄문이다.  \n따라서 `a.equals(b)`는 `false`가 된다.\n\n2. `b.equals(a)`를 보면 b는 Point클래스이기 떄문에 Point클래스의 equals메서드를 타게 된다.  \n이렇게 되면 ColorPoint는 Point클래스를 상속하고 있기 때문에 첫번째 if조건을 통과하게 되고,  \nint x, int y값을 기준으로만 비교하기 떄문에 값이 참이 된다.  \n따라서 `b.equals(a)`는 `true`가 된다.\n\n위의 예시는 equals 정의 규약 중 하나인 대칭성을 위반하고 있으므로 다시 작성해야 한다.\n\n### 추이성이 위반되는 case\n```java\nclass ColorPoint extends Point {\n  \n  private final Color color;\n\n  @Override\n  public boolean equals(Object o) {\n    if(!(o instanceof Point)) return false;\n\n    //o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.\n    if(!(o instanceof ColorPoint)) return o.equals(this);\n    \n    //o가 ColorPoint이면 색상까지 비교한다.\n    return super.equals(o) && this.color == ((ColorPoint) o).color;\n  }\n}\n```\n위 처럼 ColorPoint 클래스의 equals메서드를 다시 재정의 했다면..  \n```java\nColorPoint a = new ColorPoint(1, 2, Color.RED);\nPoint b = new Point(1, 2);\nColorPoint c = new ColorPoint(1, 2, Color.BLUE);\n\nSystem.out.println(a.equals(b)); //true\nSystem.out.println(b.equals(c)); //true\nSystem.out.println(a.equals(c)); //false\n```\n1. `a.equals(b)`를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.  \nb가 Point인 경우이기 때문에 2번쨰 if 절을 타게 되어 Point의 x, y정보만 비교하게 되므로 결과는 `true`이다.\n2. `b.equals(c)`를 보면 b는 Point클래스의 인스턴스이므로 Point클래스의 equals 메서드를 실행하게 된다.  \nPoint의 x, y정보만 비교하게 되므로 결과는 `true`이다.\n3. `a.equals(c)`를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.  \n하지만, c가 ColorPoint클래스의 인스턴스이므로 x, y값 뿐만아니라 color까지 비교하게되어 결과는 `false`이다.\n\n이렇게 a.equals(b)는 `true`를 만족하고 b.equals(c)는 `true`를 만족하지만 a.equals(c)는 `false`가 되므로  \n위의 코드는 equals 정의 규약 중 `추이성`을 위반하는 코드가 된다.\n\n### 무한 재귀 (Infinite Recursion)이 발생하는 case\n```java\nclass SmellPoint extends Point {\n  \n  private final Smell smell;\n\n  @Override\n  public boolean equals(Object o) {\n    if(!(o instanceof Point)) return false;\n\n    //o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.\n    if(!(o instanceof SmellPoint)) return o.equals(this);\n    \n    //o가 ColorPoint이면 색상까지 비교한다.\n    return super.equals(o) && this.smell == ((SmellPoint) o).smell;\n  }\n}\n```\n위 처럼 Point를 상속받는 SmellPoint라는 클래스도 추가되었다고 가정해보자\n\n```java\nPoint cp = new ColorPoint(1, 2, Color.RED);\nPoint sp = new SmellPoint(1, 2, Smell.SWEET);\n\nSystem.out.println(cp.equals(sp));  //?\n```\n위와 같이 ColorPoint와 SmellPoint에 대해 equals비교를 한다고 하면 어떻게 될까??  \n이렇게 되면 두번째 if절에서 무한재귀(Infinite Recursion)이 발생하게 된다.  \n\n무슨 의미인지 자세히 설명하면, cp는 ColorPoint 클래스의 인스턴스이기 때문에  \n`cp.equals(sp)` 코드는 ColorPoint 클래스의 재정의 된 equals 메서드를 타게 된다.  \n이렇게 되면 두번째 if에서 걸리게 된다. 왜냐하면 o는 **SmellPoint** 타입이기 때문에 `!(o instanceof ColorPoint)` 이 조건식이 true가 된다.  \n그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 o는 SmellPoint 클래스의 인스턴스이기 때문에  \nSmellPoint 클래스의 재정의된 equals메서드를 타게 된다.\n\n다시 SmellPoint클래스의 입장에서 보게되면 두번째 if에서 걸리게 된다.  \n여기서 o는 ColorPoint타입이기 때문에 `!(o instanceof ColorPoint)` 이 조건식이 true가 된다.  \n그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 다시 ColorPoint 클래스의 재정의된 equals메서드를 타게 된다.\n\n이런 작업이 계속 재귀적으로 호출 되면서, 결국은 StackOverflowError를 내며 프로그램이 죽는 참사를 맞이 하게 될 것이다.\n\n### 리스코프 치환 원칙 (SOLID)\nSOLID원칙 중 3번째인 리스코프 치횐 원칙이란?\n>자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.\n\n쉽게 말해서, 자식클래스에서 부모클래스의 기능을 수행하지 못하는 건 리스코프 치환원칙에 위배된다고 볼 수 있다.\n\n위에서 equals 재정의에 실패해서 다시 또 변경하였다.\n```java\nclass Point {\n  \n  private final int x;\n  private final int y;\n\n  private static final Set<Point> unitCircle = Set.of(new Point(0, -1),\n   new Point(0, 1),\n   new Point(-1, 0),\n   new Point(1, 0)\n  );\n\n  public static boolean onUnitCircle(Point p) {\n    return unitCircle.contains(p);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if(o == null || o.getClass() != this.getClass()) {\n      return false;\n    }\n\n    Point p = (Point) o;\n    return this.x == p.x && this.y = p.y;\n  }\n}\n```\n\n이번에는 주어진 점이 반지름이 1인 원안에 포함되는지에 대한 여부를 판단하는 로직이다.\n\n```java \nColorPoint cp = new ColorPoint(1, 0, Color.RED);\nSystem.out.println(Point.onUnitCircle(cp)); //false\n```\n\nColorPoint는 Point를 상속한 클래스이다.  \n실제 oint.onUnitCircle 메서드의 contains 메서드에서 Set내의 element들에 대한 equals 비교가 일어나게 된다.  \n하지만 equals 메서드 첫번째 if문에서 걸리게 된다.  \nColorPoint 객체가 파라미터로 전달되어 null은 아니지만,  \n두번째 조건식인 o.getClass()에서 `ColorPoint.class`가 도출되고 this.getClass()에서는 `Point.class`가 도출되게 된다.  \n\n위 조건식 때문에 ColorPoint 클래스는 Point클래스로서 equals메서드 내에서 활용되지 못했기 때문에  \n위 코드는 리스코프 치환원칙에 위배되는 코드로 전락해 버렸다.\n\n```java\n@Override\npublic boolean equals(Object o) {\n  if(o == null || !(o instanceof Point)) {\n    return false;\n  }\n\n  Point p = (Point) o;\n  return this.x == p.x && this.y = p.y;\n}\n```\n차라리 이런식으로 instanceof를 사용했다면 좋았을 것이다.\n\n## 상속 대신 컴포지션(Composition)을 사용하라\n구체클래스의 하위클래스에서 값을 추가할 방법은 없지만, 우회방법이 있다.  \n상속 대신에 Point 변수를 갖도록 Composition(구성)을 이용하는 방법이다.  \n\n```java\npublic ColorPoint {\n  private Point point;\n  private Color color;\n\n  public ColorPoint(int x, int y, Color color) {\n    this.point = new Point(x, y);\n    this.color = Objects.requireNonNull(color);\n  }\n\n  public Point asPoint() {\n    return this.point;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if(!(o instanceof ColorPoint)) {\n      return false;\n    }\n    ColorPoint cp = (ColorPoint) o;\n    return this.point.equals(cp) && this.color.equals(cp.color);\n  }\n}\n```\n\n이와 같이 컴포지션을 이용하면 상속에 때문에 발생하는 대칭성, 추이성, 리스코프 치환원칙에 위배되지 않는 코드를 작성할 수 있다.\n\n## 일관성 (consistency)\n**null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.**  \n두 객체가 같다면 수정되지 않는 한 영원히 같아야 함을 의미한다.  \n가변객체는 비교시점에 따라 서로 달라질 수 있지만 불변객체라면 한번 다르면 끝까지 달라야 한다. (그래서 불변객체로 만드는 것이 나을때가 많다)\n\n하지만, 클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들어서는 안된다.  \n`java.net.URL` 클래스는 URL과 매핑된 host의 IP주소를 이용해 비교한다.  \n당장 우리회사 서버만 봐도 L4스위치가 적용되있기 때문에 로드밸런싱이 되어 같은 도메인주소라도 그떄그떄 나오는 IP정보가 다르다.\n\n```java\nURL url1 = new URL(\"www.site-name.co.kr\");\nURL url2 = new URL(\"www.site-name.co.kr\");\n\nSystem.out.println(url1.equals(url2)); //?\n```\n실제 url1이 10.0.0.1 이라는 IP가 나왔다면  \nurl2의 경우 10.0.0.1이 나올수도 있고, 같은 대역에 있는 10.0.0.2가 나올 수도 있다.  \n그렇기 떄문에 equals의 결과가 가변적이기 떄문에 다른 자원의 개입으로 인해 equals의 일관성이 깨지게 된다.  \n\n그렇게 때문에 항상 equals를 사용할 때는 메모리에 존재하는 객체만을 사용한 결정적(deterministic) 계산만 수행해야 한다.\n\n## not null\n**null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다**\n기본적으로 x.equals(null)이 true가 되는 일은 생각하기 어렵다.  \n\n```java\n@Override \npublic boolean equals(Object o) {\n  if(o == null) return false; //불필요\n  return this.x == o.x;\n}\n```\n하지만 equals를 재정의 할 때 이러한 코드를 작성하기 쉽다.\n\n```java\n@Override\npublic boolean equals(Object o) {\n  if(!(o instanceof MyClass)) return false; //묵시적 null검사\n  MyClass clazz = (MyClass) o;\n  return this.x == clazz.x;\n}\n```\n이런식으로 instanceof 키워드를 통해 묵시적 null 체크를 하는 방법이 좋다.\n\n# 요약 정리\n## equals 구현 절차\n* `==` 연산자를 사용해 입력된 파라미터와 자기자신이 같은 객체인지 검사한다. (동일성 검사 - Object Identity)\n  * 성능 향상을 위한 코드\n  * equals가 복잡할 때 같은 참조를 가진 객체에 대한 비교를 안하기 위함\n* `instanceof` 연산자로 파라미터의 타입이 올바른지 체크\n  * 묵시적 null체크 용도로도 사용\n  * equals중에서는 같은 interface를 구현한 클래스끼리도 비교하는 경우가 있다.\n* 입력을 올바른 타입으로 형변환한다.\n  * Object타입의 파라미터를 비교하고자 하는 타입으로 형변환한다.\n  * 앞서 `instanceof` 연산을 수행했기 때문에 100% 성공한다.\n* 파라미터 Object 객체와 자기자신의 대응되는 핵심필드들이 모두 일치하는지 확인한다.\n  * 하나라도 다르면 false를 리턴\n  * 만약 interface기반의 비교가 필요하다면 필드정보를 가져오는 메서드가 interface에 정의되어있어야하고,  \n  구현체 클래스에서는 메서드를 재정의 해야한다.\n* float, double을 제외한 기본타입은 `==`을 통해 비교\n* 참조(reference) 타입은 equals를 통해 비교\n* float, double은 Float.compare(float, float)와 Double.compare(double, double)로 비교한다.\n  * Float.Nan, -0.0f등을 비교하기 위함이다.\n  * 이 메서드들은 float -> Float, double -> Double로 변환하는 오토박싱 기능이 수반되므로 성능상 좋지 못하다.\n* 배열의 모든 원소가 핵심 필드라면 Arrays.equals를 사용하자\n* null이 의심되는 필드는 Objects.equals(obj, obj)를 이용해 NullPointerException을 예방하자\n* 성능을 올리고자 한다면\n   * 다를 확률이 높은 필드부터 비교한다.\n   * 비교하는 비용(시간복잡도)이 적은 비교를 먼저 수행\n\n# 주의사항\n* equals를 재정의 했다면, 대칭성, 추이성, 일관성에 대한 체크를 꼭 하자 (테스트 케이스 작성 요망)\n* equals를 작성할 때는 hashcode도 반드시 재정의하자 (Item.11)\n* 너무 복잡하게 해결하려 들지 말자\n* equals의 파라미터는 Object이외의 타입으로 선언하지 말자 (컴파일 에러 발생)\n* 구글에서 만든 @AutoValue을 이용해서 equals와 hashcode를 자동으로 재정의해보자 (Lombok의 @EqualsAndHashCode도 있다.)\n\n\n# 참고\n* Effective Java 3rd Edition - Item 10. equals는 일반 규약을 지켜 재정의하라\n","source":"_posts/effective-java-item10.md","raw":"---\ntitle: Item 10. equals는 일반 규약을 지켜 재정의하라\ncatalog: true\nCategories:\n  - Effective-Java\ntags:\n  - Effective-Java\ntypora-root-url: effective-java-item10\ntypora-copy-images-to: effective-java-item10\ndate: 2019-01-10 21:14:20\nsubtitle:\nheader-img:\n---\n\n# 서론\nequals 메서드는 Object 클래스에 구현된 메서드로 객체 내의 정보들에 대한 동등성(equality) 비교를 목적으로 하는 메서드이다.  \nequals 메서드를 잘못 작성하게 되면 의도하지 않는 결과들이 초래되므로 웬만하면 변경하지 않는 것이 좋다.\n\n# equals를 재정의 하지 않아도 되는 경우\n* 각 인스턴스가 본질적으로 고유 한 경우 - 값이 아닌 동작을 표현하는 클래스의 경우 (Thread가 좋은 예이다.)\n* 인스턴스의 논리적 동치성 (Logical Equality)를 검사할 일이 없는 경우 - `java.utils.regex.Pattern`의 equals는 내부의 정규표현식이 같은지를 검사하는 메서드이다.\n* 상위 클래스에서 재정의한 equals가 하위 클래스에서도 적용 되는 경우 - Set, Map, List의 경우 Abstract(Type)의 equals를 쓴다.\n* 클래스가 private이거나, package-private여서 equals를 호출할 일이 없는 경우\n* 싱글턴을 보장하는 클래스(인스턴스 통제 클래스, Enum (열거타입)) 인 경우 - 객체 간 동등성, 동일성이 보장된다.\n\n# equals를 재정의 하는 경우 지켜야 할 규약\nequals를 재정의 해야 하는 경우는 객체 동일성(식별성(Object Identity))를 확인해야 하는 경우가 아니라  \n논리적 동치성(동등성(Logical equality))를 비교 하도록 재정의 되지 않았을 경우이다.\n\n## 반사성(reflexivity)\n**null이 아닌 모든 참조 값 x에 대해 x.equals(x)를 만족해야한다.**  \n단순히 말하면 객체는 자기 자신과 비교했을 때 같아야 한다는 뜻이다.  \n이 조건을 만족하지 않는 예를 찾기가 더 어렵다.  \n만약 x.equals(x)가 성립하지 않는 객체라면, 컬렉션에서 contain 메서드를 사용하는 경우 방금 넣은 객체도 찾을 수 없을 것이다.\n\n## 대칭성 (symmetry)\n**null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true이면, y.equals(x)가 true를 만족해야 한다.**  \n\n예시 코드를 보면\n```java\npublic final class CaseInsensitiveString {\n  private final String s;\n\n  public CaseInsensitiveString(String s) {\n    this.s = Objects.requireNonNull(s);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if(o instanceof CaseInsensitiveString) {\n      return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);\n    }\n\n    if(o instanceof String) { //한 방향으로만 작동!!\n      return s.equalsIgnoreCase((String) o);\n    }\n    return false;\n  }\n}\n```\n\n위의 클래스를 기반으로 \n```java\nCaseInsensitiveString caseInsensitiveString = new CaseInsensitiveString(\"Test\");\nString test = \"test\";\nSystem.out.println(caseInsensitiveString.equals(test)); //true\nSystem.out.println(test.equals(caseInsensitiveString)); //false\n```\n위의 코드를 실행하게 되면, x.equals(y)가 true일 때, y.equals(x)가 false이므로 `대칭성`이 깨지는 코드가 된다.  \nString 클래스에서는 CaseInsensitiveString의 존재를 모르기 때문에 false가 날 수 밖에 없는 상황이다.\n\n```java\nList<CaseInsensitiveString> list = new ArrayList<>();\nlist.add(new CaseInsensitiveString(\"Test\"));\nSystem.out.println(list.contain(\"test\")); //false or true\n```\n위의 예제의 경우는 JDK버전에 따라 다를 수 있다. x.equals(y)로 비교할 수 도 있고, y.equals(x)로 비교될 수 있기 때문이다.\n\n위의 내용을 수정한다면, String과의 비교는 포기해야 한다.  \n같은 CaseInsensitiveString 타입인 경우에만 비교하도록 한다.\n```java\n@Override\npublic boolean equals(Object o) {\n  return o instanceof CaseInsensitiveString && ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);\n}\n```\n\n## 추이성 (transitivity)\n**null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y)가 true이고, y.equals(z)가 true이면 x.equals(z)도 true가 되야 한다는 조건이다.**\n\nPoint클래스와 ColorPoint 클래스를 가지고 예시를 들어보겠다.  \n(ColorPoint는 Point클래스를 확장(extends)한 클래스이다.)\n```java\nColorPoint a = new ColorPoint(1, 2, Color.RED);\nPoint b = new Point(1, 2);\nColorPoint c = new ColorPoint(1, 2, Color.BLUE);\n```\n위와 같은 인스턴스 a, b, c가 있다.\n이 때, a.equals(b)와 b.equals(c) 일 때, a.equals(c)\n가 되는 과정을 살펴 보자\n\n```java\nclass Point {\n  private final int x;\n  private final int y;\n\n  public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if(!(o instanceof Point)) return false;\n    Point p = (Point) o;\n    return this.x == p.x && this.y == p.y;\n  }\n}\n```\n\n### 대칭성이 위배되는 case\n```java\nclass ColorPoint extends Point {\n  \n  private final Color color;\n\n  @Override\n  public boolean equals(Object o) {\n    if(!(o instanceof ColorPoint)) return false;\n    \n    return super.equals(o) && this.color == ((ColorPoint) o).color;\n  }\n}\n```\n\n위 처럼 ColorPoint 클래스의 equals 메서드를 재정의 했다면... \n```java\nColorPoint a = new ColorPoint(1, 2, Color.RED);\nPoint b = new Point(1, 2);\n\nSystem.out.println(a.equals(b)); //false\nSystem.out.println(b.equals(a)); //true\n```\n1. `a.equals(b)`를 보면 a는 ColorPoint이기 떄문에 ColorPoint 클래스에서 재정의 된 equals 메서드를 타게 된다.  \n이렇게 되면 첫번째 if 조건에서 걸리게 된다. b는 Point이지만 ColorPoint는 아니기 떄문이다.  \n따라서 `a.equals(b)`는 `false`가 된다.\n\n2. `b.equals(a)`를 보면 b는 Point클래스이기 떄문에 Point클래스의 equals메서드를 타게 된다.  \n이렇게 되면 ColorPoint는 Point클래스를 상속하고 있기 때문에 첫번째 if조건을 통과하게 되고,  \nint x, int y값을 기준으로만 비교하기 떄문에 값이 참이 된다.  \n따라서 `b.equals(a)`는 `true`가 된다.\n\n위의 예시는 equals 정의 규약 중 하나인 대칭성을 위반하고 있으므로 다시 작성해야 한다.\n\n### 추이성이 위반되는 case\n```java\nclass ColorPoint extends Point {\n  \n  private final Color color;\n\n  @Override\n  public boolean equals(Object o) {\n    if(!(o instanceof Point)) return false;\n\n    //o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.\n    if(!(o instanceof ColorPoint)) return o.equals(this);\n    \n    //o가 ColorPoint이면 색상까지 비교한다.\n    return super.equals(o) && this.color == ((ColorPoint) o).color;\n  }\n}\n```\n위 처럼 ColorPoint 클래스의 equals메서드를 다시 재정의 했다면..  \n```java\nColorPoint a = new ColorPoint(1, 2, Color.RED);\nPoint b = new Point(1, 2);\nColorPoint c = new ColorPoint(1, 2, Color.BLUE);\n\nSystem.out.println(a.equals(b)); //true\nSystem.out.println(b.equals(c)); //true\nSystem.out.println(a.equals(c)); //false\n```\n1. `a.equals(b)`를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.  \nb가 Point인 경우이기 때문에 2번쨰 if 절을 타게 되어 Point의 x, y정보만 비교하게 되므로 결과는 `true`이다.\n2. `b.equals(c)`를 보면 b는 Point클래스의 인스턴스이므로 Point클래스의 equals 메서드를 실행하게 된다.  \nPoint의 x, y정보만 비교하게 되므로 결과는 `true`이다.\n3. `a.equals(c)`를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.  \n하지만, c가 ColorPoint클래스의 인스턴스이므로 x, y값 뿐만아니라 color까지 비교하게되어 결과는 `false`이다.\n\n이렇게 a.equals(b)는 `true`를 만족하고 b.equals(c)는 `true`를 만족하지만 a.equals(c)는 `false`가 되므로  \n위의 코드는 equals 정의 규약 중 `추이성`을 위반하는 코드가 된다.\n\n### 무한 재귀 (Infinite Recursion)이 발생하는 case\n```java\nclass SmellPoint extends Point {\n  \n  private final Smell smell;\n\n  @Override\n  public boolean equals(Object o) {\n    if(!(o instanceof Point)) return false;\n\n    //o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.\n    if(!(o instanceof SmellPoint)) return o.equals(this);\n    \n    //o가 ColorPoint이면 색상까지 비교한다.\n    return super.equals(o) && this.smell == ((SmellPoint) o).smell;\n  }\n}\n```\n위 처럼 Point를 상속받는 SmellPoint라는 클래스도 추가되었다고 가정해보자\n\n```java\nPoint cp = new ColorPoint(1, 2, Color.RED);\nPoint sp = new SmellPoint(1, 2, Smell.SWEET);\n\nSystem.out.println(cp.equals(sp));  //?\n```\n위와 같이 ColorPoint와 SmellPoint에 대해 equals비교를 한다고 하면 어떻게 될까??  \n이렇게 되면 두번째 if절에서 무한재귀(Infinite Recursion)이 발생하게 된다.  \n\n무슨 의미인지 자세히 설명하면, cp는 ColorPoint 클래스의 인스턴스이기 때문에  \n`cp.equals(sp)` 코드는 ColorPoint 클래스의 재정의 된 equals 메서드를 타게 된다.  \n이렇게 되면 두번째 if에서 걸리게 된다. 왜냐하면 o는 **SmellPoint** 타입이기 때문에 `!(o instanceof ColorPoint)` 이 조건식이 true가 된다.  \n그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 o는 SmellPoint 클래스의 인스턴스이기 때문에  \nSmellPoint 클래스의 재정의된 equals메서드를 타게 된다.\n\n다시 SmellPoint클래스의 입장에서 보게되면 두번째 if에서 걸리게 된다.  \n여기서 o는 ColorPoint타입이기 때문에 `!(o instanceof ColorPoint)` 이 조건식이 true가 된다.  \n그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 다시 ColorPoint 클래스의 재정의된 equals메서드를 타게 된다.\n\n이런 작업이 계속 재귀적으로 호출 되면서, 결국은 StackOverflowError를 내며 프로그램이 죽는 참사를 맞이 하게 될 것이다.\n\n### 리스코프 치환 원칙 (SOLID)\nSOLID원칙 중 3번째인 리스코프 치횐 원칙이란?\n>자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.\n\n쉽게 말해서, 자식클래스에서 부모클래스의 기능을 수행하지 못하는 건 리스코프 치환원칙에 위배된다고 볼 수 있다.\n\n위에서 equals 재정의에 실패해서 다시 또 변경하였다.\n```java\nclass Point {\n  \n  private final int x;\n  private final int y;\n\n  private static final Set<Point> unitCircle = Set.of(new Point(0, -1),\n   new Point(0, 1),\n   new Point(-1, 0),\n   new Point(1, 0)\n  );\n\n  public static boolean onUnitCircle(Point p) {\n    return unitCircle.contains(p);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if(o == null || o.getClass() != this.getClass()) {\n      return false;\n    }\n\n    Point p = (Point) o;\n    return this.x == p.x && this.y = p.y;\n  }\n}\n```\n\n이번에는 주어진 점이 반지름이 1인 원안에 포함되는지에 대한 여부를 판단하는 로직이다.\n\n```java \nColorPoint cp = new ColorPoint(1, 0, Color.RED);\nSystem.out.println(Point.onUnitCircle(cp)); //false\n```\n\nColorPoint는 Point를 상속한 클래스이다.  \n실제 oint.onUnitCircle 메서드의 contains 메서드에서 Set내의 element들에 대한 equals 비교가 일어나게 된다.  \n하지만 equals 메서드 첫번째 if문에서 걸리게 된다.  \nColorPoint 객체가 파라미터로 전달되어 null은 아니지만,  \n두번째 조건식인 o.getClass()에서 `ColorPoint.class`가 도출되고 this.getClass()에서는 `Point.class`가 도출되게 된다.  \n\n위 조건식 때문에 ColorPoint 클래스는 Point클래스로서 equals메서드 내에서 활용되지 못했기 때문에  \n위 코드는 리스코프 치환원칙에 위배되는 코드로 전락해 버렸다.\n\n```java\n@Override\npublic boolean equals(Object o) {\n  if(o == null || !(o instanceof Point)) {\n    return false;\n  }\n\n  Point p = (Point) o;\n  return this.x == p.x && this.y = p.y;\n}\n```\n차라리 이런식으로 instanceof를 사용했다면 좋았을 것이다.\n\n## 상속 대신 컴포지션(Composition)을 사용하라\n구체클래스의 하위클래스에서 값을 추가할 방법은 없지만, 우회방법이 있다.  \n상속 대신에 Point 변수를 갖도록 Composition(구성)을 이용하는 방법이다.  \n\n```java\npublic ColorPoint {\n  private Point point;\n  private Color color;\n\n  public ColorPoint(int x, int y, Color color) {\n    this.point = new Point(x, y);\n    this.color = Objects.requireNonNull(color);\n  }\n\n  public Point asPoint() {\n    return this.point;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if(!(o instanceof ColorPoint)) {\n      return false;\n    }\n    ColorPoint cp = (ColorPoint) o;\n    return this.point.equals(cp) && this.color.equals(cp.color);\n  }\n}\n```\n\n이와 같이 컴포지션을 이용하면 상속에 때문에 발생하는 대칭성, 추이성, 리스코프 치환원칙에 위배되지 않는 코드를 작성할 수 있다.\n\n## 일관성 (consistency)\n**null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.**  \n두 객체가 같다면 수정되지 않는 한 영원히 같아야 함을 의미한다.  \n가변객체는 비교시점에 따라 서로 달라질 수 있지만 불변객체라면 한번 다르면 끝까지 달라야 한다. (그래서 불변객체로 만드는 것이 나을때가 많다)\n\n하지만, 클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들어서는 안된다.  \n`java.net.URL` 클래스는 URL과 매핑된 host의 IP주소를 이용해 비교한다.  \n당장 우리회사 서버만 봐도 L4스위치가 적용되있기 때문에 로드밸런싱이 되어 같은 도메인주소라도 그떄그떄 나오는 IP정보가 다르다.\n\n```java\nURL url1 = new URL(\"www.site-name.co.kr\");\nURL url2 = new URL(\"www.site-name.co.kr\");\n\nSystem.out.println(url1.equals(url2)); //?\n```\n실제 url1이 10.0.0.1 이라는 IP가 나왔다면  \nurl2의 경우 10.0.0.1이 나올수도 있고, 같은 대역에 있는 10.0.0.2가 나올 수도 있다.  \n그렇기 떄문에 equals의 결과가 가변적이기 떄문에 다른 자원의 개입으로 인해 equals의 일관성이 깨지게 된다.  \n\n그렇게 때문에 항상 equals를 사용할 때는 메모리에 존재하는 객체만을 사용한 결정적(deterministic) 계산만 수행해야 한다.\n\n## not null\n**null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다**\n기본적으로 x.equals(null)이 true가 되는 일은 생각하기 어렵다.  \n\n```java\n@Override \npublic boolean equals(Object o) {\n  if(o == null) return false; //불필요\n  return this.x == o.x;\n}\n```\n하지만 equals를 재정의 할 때 이러한 코드를 작성하기 쉽다.\n\n```java\n@Override\npublic boolean equals(Object o) {\n  if(!(o instanceof MyClass)) return false; //묵시적 null검사\n  MyClass clazz = (MyClass) o;\n  return this.x == clazz.x;\n}\n```\n이런식으로 instanceof 키워드를 통해 묵시적 null 체크를 하는 방법이 좋다.\n\n# 요약 정리\n## equals 구현 절차\n* `==` 연산자를 사용해 입력된 파라미터와 자기자신이 같은 객체인지 검사한다. (동일성 검사 - Object Identity)\n  * 성능 향상을 위한 코드\n  * equals가 복잡할 때 같은 참조를 가진 객체에 대한 비교를 안하기 위함\n* `instanceof` 연산자로 파라미터의 타입이 올바른지 체크\n  * 묵시적 null체크 용도로도 사용\n  * equals중에서는 같은 interface를 구현한 클래스끼리도 비교하는 경우가 있다.\n* 입력을 올바른 타입으로 형변환한다.\n  * Object타입의 파라미터를 비교하고자 하는 타입으로 형변환한다.\n  * 앞서 `instanceof` 연산을 수행했기 때문에 100% 성공한다.\n* 파라미터 Object 객체와 자기자신의 대응되는 핵심필드들이 모두 일치하는지 확인한다.\n  * 하나라도 다르면 false를 리턴\n  * 만약 interface기반의 비교가 필요하다면 필드정보를 가져오는 메서드가 interface에 정의되어있어야하고,  \n  구현체 클래스에서는 메서드를 재정의 해야한다.\n* float, double을 제외한 기본타입은 `==`을 통해 비교\n* 참조(reference) 타입은 equals를 통해 비교\n* float, double은 Float.compare(float, float)와 Double.compare(double, double)로 비교한다.\n  * Float.Nan, -0.0f등을 비교하기 위함이다.\n  * 이 메서드들은 float -> Float, double -> Double로 변환하는 오토박싱 기능이 수반되므로 성능상 좋지 못하다.\n* 배열의 모든 원소가 핵심 필드라면 Arrays.equals를 사용하자\n* null이 의심되는 필드는 Objects.equals(obj, obj)를 이용해 NullPointerException을 예방하자\n* 성능을 올리고자 한다면\n   * 다를 확률이 높은 필드부터 비교한다.\n   * 비교하는 비용(시간복잡도)이 적은 비교를 먼저 수행\n\n# 주의사항\n* equals를 재정의 했다면, 대칭성, 추이성, 일관성에 대한 체크를 꼭 하자 (테스트 케이스 작성 요망)\n* equals를 작성할 때는 hashcode도 반드시 재정의하자 (Item.11)\n* 너무 복잡하게 해결하려 들지 말자\n* equals의 파라미터는 Object이외의 타입으로 선언하지 말자 (컴파일 에러 발생)\n* 구글에서 만든 @AutoValue을 이용해서 equals와 hashcode를 자동으로 재정의해보자 (Lombok의 @EqualsAndHashCode도 있다.)\n\n\n# 참고\n* Effective Java 3rd Edition - Item 10. equals는 일반 규약을 지켜 재정의하라\n","slug":"effective-java-item10","published":1,"updated":"2019-01-13T11:38:31.426Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrgbv3tv0049cr1tj32p9kph","content":"<h1 id=\"서론\">서론</h1>\n<p>equals 메서드는 Object 클래스에 구현된 메서드로 객체 내의 정보들에 대한 동등성(equality) 비교를 목적으로 하는 메서드이다.<br>\nequals 메서드를 잘못 작성하게 되면 의도하지 않는 결과들이 초래되므로 웬만하면 변경하지 않는 것이 좋다.</p>\n<h1 id=\"equals를-재정의-하지-않아도-되는-경우\">equals를 재정의 하지 않아도 되는 경우</h1>\n<ul>\n<li>각 인스턴스가 본질적으로 고유 한 경우 - 값이 아닌 동작을 표현하는 클래스의 경우 (Thread가 좋은 예이다.)</li>\n<li>인스턴스의 논리적 동치성 (Logical Equality)를 검사할 일이 없는 경우 - <code>java.utils.regex.Pattern</code>의 equals는 내부의 정규표현식이 같은지를 검사하는 메서드이다.</li>\n<li>상위 클래스에서 재정의한 equals가 하위 클래스에서도 적용 되는 경우 - Set, Map, List의 경우 Abstract(Type)의 equals를 쓴다.</li>\n<li>클래스가 private이거나, package-private여서 equals를 호출할 일이 없는 경우</li>\n<li>싱글턴을 보장하는 클래스(인스턴스 통제 클래스, Enum (열거타입)) 인 경우 - 객체 간 동등성, 동일성이 보장된다.</li>\n</ul>\n<h1 id=\"equals를-재정의-하는-경우-지켜야-할-규약\">equals를 재정의 하는 경우 지켜야 할 규약</h1>\n<p>equals를 재정의 해야 하는 경우는 객체 동일성(식별성(Object Identity))를 확인해야 하는 경우가 아니라<br>\n논리적 동치성(동등성(Logical equality))를 비교 하도록 재정의 되지 않았을 경우이다.</p>\n<h2 id=\"반사성reflexivity\">반사성(reflexivity)</h2>\n<p><strong>null이 아닌 모든 참조 값 x에 대해 x.equals(x)를 만족해야한다.</strong><br>\n단순히 말하면 객체는 자기 자신과 비교했을 때 같아야 한다는 뜻이다.<br>\n이 조건을 만족하지 않는 예를 찾기가 더 어렵다.<br>\n만약 x.equals(x)가 성립하지 않는 객체라면, 컬렉션에서 contain 메서드를 사용하는 경우 방금 넣은 객체도 찾을 수 없을 것이다.</p>\n<h2 id=\"대칭성-symmetry\">대칭성 (symmetry)</h2>\n<p><strong>null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true이면, y.equals(x)가 true를 만족해야 한다.</strong></p>\n<p>예시 코드를 보면\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaseInsensitiveString</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String s;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CaseInsensitiveString</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.s = Objects.requireNonNull(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(o <span class=\"keyword\">instanceof</span> CaseInsensitiveString) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.equalsIgnoreCase(((CaseInsensitiveString) o).s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(o <span class=\"keyword\">instanceof</span> String) &#123; <span class=\"comment\">//한 방향으로만 작동!!</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.equalsIgnoreCase((String) o);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 클래스를 기반으로\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CaseInsensitiveString caseInsensitiveString = <span class=\"keyword\">new</span> CaseInsensitiveString(<span class=\"string\">\"Test\"</span>);</span><br><span class=\"line\">String test = <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\">System.out.println(caseInsensitiveString.equals(test)); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(test.equals(caseInsensitiveString)); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>위의 코드를 실행하게 되면, x.equals(y)가 true일 때, y.equals(x)가 false이므로 <code>대칭성</code>이 깨지는 코드가 된다.<br>\nString 클래스에서는 CaseInsensitiveString의 존재를 모르기 때문에 false가 날 수 밖에 없는 상황이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;CaseInsensitiveString&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"keyword\">new</span> CaseInsensitiveString(<span class=\"string\">\"Test\"</span>));</span><br><span class=\"line\">System.out.println(list.contain(<span class=\"string\">\"test\"</span>)); <span class=\"comment\">//false or true</span></span><br></pre></td></tr></table></figure></p>\n<p>위의 예제의 경우는 JDK버전에 따라 다를 수 있다. x.equals(y)로 비교할 수 도 있고, y.equals(x)로 비교될 수 있기 때문이다.</p>\n<p>위의 내용을 수정한다면, String과의 비교는 포기해야 한다.<br>\n같은 CaseInsensitiveString 타입인 경우에만 비교하도록 한다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o <span class=\"keyword\">instanceof</span> CaseInsensitiveString &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"추이성-transitivity\">추이성 (transitivity)</h2>\n<p><strong>null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y)가 true이고, y.equals(z)가 true이면 x.equals(z)도 true가 되야 한다는 조건이다.</strong></p>\n<p>Point클래스와 ColorPoint 클래스를 가지고 예시를 들어보겠다.<br>\n(ColorPoint는 Point클래스를 확장(extends)한 클래스이다.)\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ColorPoint a = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Color.RED);</span><br><span class=\"line\">Point b = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">ColorPoint c = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Color.BLUE);</span><br></pre></td></tr></table></figure></p>\n<p>위와 같은 인스턴스 a, b, c가 있다.\n이 때, a.equals(b)와 b.equals(c) 일 때, a.equals(c)\n가 되는 과정을 살펴 보자</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> Point)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Point p = (Point) o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x == p.x &amp;&amp; <span class=\"keyword\">this</span>.y == p.y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"대칭성이-위배되는-case\">대칭성이 위배되는 case</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Color color;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> ColorPoint)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.equals(o) &amp;&amp; <span class=\"keyword\">this</span>.color == ((ColorPoint) o).color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위 처럼 ColorPoint 클래스의 equals 메서드를 재정의 했다면...\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ColorPoint a = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Color.RED);</span><br><span class=\"line\">Point b = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(a.equals(b)); <span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(b.equals(a)); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>\n<p><code>a.equals(b)</code>를 보면 a는 ColorPoint이기 떄문에 ColorPoint 클래스에서 재정의 된 equals 메서드를 타게 된다.<br>\n이렇게 되면 첫번째 if 조건에서 걸리게 된다. b는 Point이지만 ColorPoint는 아니기 떄문이다.<br>\n따라서 <code>a.equals(b)</code>는 <code>false</code>가 된다.</p>\n</li>\n<li>\n<p><code>b.equals(a)</code>를 보면 b는 Point클래스이기 떄문에 Point클래스의 equals메서드를 타게 된다.<br>\n이렇게 되면 ColorPoint는 Point클래스를 상속하고 있기 때문에 첫번째 if조건을 통과하게 되고,<br>\nint x, int y값을 기준으로만 비교하기 떄문에 값이 참이 된다.<br>\n따라서 <code>b.equals(a)</code>는 <code>true</code>가 된다.</p>\n</li>\n</ol>\n<p>위의 예시는 equals 정의 규약 중 하나인 대칭성을 위반하고 있으므로 다시 작성해야 한다.</p>\n<h3 id=\"추이성이-위반되는-case\">추이성이 위반되는 case</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Color color;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> Point)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> ColorPoint)) <span class=\"keyword\">return</span> o.equals(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//o가 ColorPoint이면 색상까지 비교한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.equals(o) &amp;&amp; <span class=\"keyword\">this</span>.color == ((ColorPoint) o).color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위 처럼 ColorPoint 클래스의 equals메서드를 다시 재정의 했다면..<br>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ColorPoint a = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Color.RED);</span><br><span class=\"line\">Point b = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">ColorPoint c = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Color.BLUE);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(a.equals(b)); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(b.equals(c)); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(a.equals(c)); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><code>a.equals(b)</code>를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.<br>\nb가 Point인 경우이기 때문에 2번쨰 if 절을 타게 되어 Point의 x, y정보만 비교하게 되므로 결과는 <code>true</code>이다.</li>\n<li><code>b.equals(c)</code>를 보면 b는 Point클래스의 인스턴스이므로 Point클래스의 equals 메서드를 실행하게 된다.<br>\nPoint의 x, y정보만 비교하게 되므로 결과는 <code>true</code>이다.</li>\n<li><code>a.equals(c)</code>를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.<br>\n하지만, c가 ColorPoint클래스의 인스턴스이므로 x, y값 뿐만아니라 color까지 비교하게되어 결과는 <code>false</code>이다.</li>\n</ol>\n<p>이렇게 a.equals(b)는 <code>true</code>를 만족하고 b.equals(c)는 <code>true</code>를 만족하지만 a.equals(c)는 <code>false</code>가 되므로<br>\n위의 코드는 equals 정의 규약 중 <code>추이성</code>을 위반하는 코드가 된다.</p>\n<h3 id=\"무한-재귀-infinite-recursion이-발생하는-case\">무한 재귀 (Infinite Recursion)이 발생하는 case</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmellPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Smell smell;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> Point)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> SmellPoint)) <span class=\"keyword\">return</span> o.equals(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//o가 ColorPoint이면 색상까지 비교한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.equals(o) &amp;&amp; <span class=\"keyword\">this</span>.smell == ((SmellPoint) o).smell;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위 처럼 Point를 상속받는 SmellPoint라는 클래스도 추가되었다고 가정해보자</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point cp = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Color.RED);</span><br><span class=\"line\">Point sp = <span class=\"keyword\">new</span> SmellPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Smell.SWEET);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(cp.equals(sp));  <span class=\"comment\">//?</span></span><br></pre></td></tr></table></figure></p>\n<p>위와 같이 ColorPoint와 SmellPoint에 대해 equals비교를 한다고 하면 어떻게 될까??<br>\n이렇게 되면 두번째 if절에서 무한재귀(Infinite Recursion)이 발생하게 된다.</p>\n<p>무슨 의미인지 자세히 설명하면, cp는 ColorPoint 클래스의 인스턴스이기 때문에<br>\n<code>cp.equals(sp)</code> 코드는 ColorPoint 클래스의 재정의 된 equals 메서드를 타게 된다.<br>\n이렇게 되면 두번째 if에서 걸리게 된다. 왜냐하면 o는 <strong>SmellPoint</strong> 타입이기 때문에 <code>!(o instanceof ColorPoint)</code> 이 조건식이 true가 된다.<br>\n그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 o는 SmellPoint 클래스의 인스턴스이기 때문에<br>\nSmellPoint 클래스의 재정의된 equals메서드를 타게 된다.</p>\n<p>다시 SmellPoint클래스의 입장에서 보게되면 두번째 if에서 걸리게 된다.<br>\n여기서 o는 ColorPoint타입이기 때문에 <code>!(o instanceof ColorPoint)</code> 이 조건식이 true가 된다.<br>\n그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 다시 ColorPoint 클래스의 재정의된 equals메서드를 타게 된다.</p>\n<p>이런 작업이 계속 재귀적으로 호출 되면서, 결국은 StackOverflowError를 내며 프로그램이 죽는 참사를 맞이 하게 될 것이다.</p>\n<h3 id=\"리스코프-치환-원칙-solid\">리스코프 치환 원칙 (SOLID)</h3>\n<p>SOLID원칙 중 3번째인 리스코프 치횐 원칙이란?</p>\n<blockquote>\n<p>자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.</p>\n</blockquote>\n<p>쉽게 말해서, 자식클래스에서 부모클래스의 기능을 수행하지 못하는 건 리스코프 치환원칙에 위배된다고 볼 수 있다.</p>\n<p>위에서 equals 재정의에 실패해서 다시 또 변경하였다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Set&lt;Point&gt; unitCircle = Set.of(<span class=\"keyword\">new</span> Point(<span class=\"number\">0</span>, -<span class=\"number\">1</span>),</span><br><span class=\"line\">   <span class=\"keyword\">new</span> Point(<span class=\"number\">0</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\">   <span class=\"keyword\">new</span> Point(-<span class=\"number\">1</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">   <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onUnitCircle</span><span class=\"params\">(Point p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unitCircle.contains(p);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(o == <span class=\"keyword\">null</span> || o.getClass() != <span class=\"keyword\">this</span>.getClass()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Point p = (Point) o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x == p.x &amp;&amp; <span class=\"keyword\">this</span>.y = p.y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이번에는 주어진 점이 반지름이 1인 원안에 포함되는지에 대한 여부를 판단하는 로직이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ColorPoint cp = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">0</span>, Color.RED);</span><br><span class=\"line\">System.out.println(Point.onUnitCircle(cp)); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>ColorPoint는 Point를 상속한 클래스이다.<br>\n실제 oint.onUnitCircle 메서드의 contains 메서드에서 Set내의 element들에 대한 equals 비교가 일어나게 된다.<br>\n하지만 equals 메서드 첫번째 if문에서 걸리게 된다.<br>\nColorPoint 객체가 파라미터로 전달되어 null은 아니지만,<br>\n두번째 조건식인 o.getClass()에서 <code>ColorPoint.class</code>가 도출되고 this.getClass()에서는 <code>Point.class</code>가 도출되게 된다.</p>\n<p>위 조건식 때문에 ColorPoint 클래스는 Point클래스로서 equals메서드 내에서 활용되지 못했기 때문에<br>\n위 코드는 리스코프 치환원칙에 위배되는 코드로 전락해 버렸다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(o == <span class=\"keyword\">null</span> || !(o <span class=\"keyword\">instanceof</span> Point)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point p = (Point) o;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x == p.x &amp;&amp; <span class=\"keyword\">this</span>.y = p.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>차라리 이런식으로 instanceof를 사용했다면 좋았을 것이다.</p>\n<h2 id=\"상속-대신-컴포지션composition을-사용하라\">상속 대신 컴포지션(Composition)을 사용하라</h2>\n<p>구체클래스의 하위클래스에서 값을 추가할 방법은 없지만, 우회방법이 있다.<br>\n상속 대신에 Point 변수를 갖도록 Composition(구성)을 이용하는 방법이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ColorPoint &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Point point;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Color color;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ColorPoint</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, Color color)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.point = <span class=\"keyword\">new</span> Point(x, y);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color = Objects.requireNonNull(color);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Point <span class=\"title\">asPoint</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.point;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> ColorPoint)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ColorPoint cp = (ColorPoint) o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.point.equals(cp) &amp;&amp; <span class=\"keyword\">this</span>.color.equals(cp.color);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이와 같이 컴포지션을 이용하면 상속에 때문에 발생하는 대칭성, 추이성, 리스코프 치환원칙에 위배되지 않는 코드를 작성할 수 있다.</p>\n<h2 id=\"일관성-consistency\">일관성 (consistency)</h2>\n<p><strong>null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.</strong><br>\n두 객체가 같다면 수정되지 않는 한 영원히 같아야 함을 의미한다.<br>\n가변객체는 비교시점에 따라 서로 달라질 수 있지만 불변객체라면 한번 다르면 끝까지 달라야 한다. (그래서 불변객체로 만드는 것이 나을때가 많다)</p>\n<p>하지만, 클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들어서는 안된다.<br>\n<code>java.net.URL</code> 클래스는 URL과 매핑된 host의 IP주소를 이용해 비교한다.<br>\n당장 우리회사 서버만 봐도 L4스위치가 적용되있기 때문에 로드밸런싱이 되어 같은 도메인주소라도 그떄그떄 나오는 IP정보가 다르다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL url1 = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"www.site-name.co.kr\"</span>);</span><br><span class=\"line\">URL url2 = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"www.site-name.co.kr\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(url1.equals(url2)); <span class=\"comment\">//?</span></span><br></pre></td></tr></table></figure></p>\n<p>실제 url1이 10.0.0.1 이라는 IP가 나왔다면<br>\nurl2의 경우 10.0.0.1이 나올수도 있고, 같은 대역에 있는 10.0.0.2가 나올 수도 있다.<br>\n그렇기 떄문에 equals의 결과가 가변적이기 떄문에 다른 자원의 개입으로 인해 equals의 일관성이 깨지게 된다.</p>\n<p>그렇게 때문에 항상 equals를 사용할 때는 메모리에 존재하는 객체만을 사용한 결정적(deterministic) 계산만 수행해야 한다.</p>\n<h2 id=\"not-null\">not null</h2>\n<p><strong>null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다</strong>\n기본적으로 x.equals(null)이 true가 되는 일은 생각하기 어렵다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(o == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">//불필요</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x == o.x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>하지만 equals를 재정의 할 때 이러한 코드를 작성하기 쉽다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> MyClass)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">//묵시적 null검사</span></span><br><span class=\"line\">  MyClass clazz = (MyClass) o;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x == clazz.x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이런식으로 instanceof 키워드를 통해 묵시적 null 체크를 하는 방법이 좋다.</p>\n<h1 id=\"요약-정리\">요약 정리</h1>\n<h2 id=\"equals-구현-절차\">equals 구현 절차</h2>\n<ul>\n<li><code>==</code> 연산자를 사용해 입력된 파라미터와 자기자신이 같은 객체인지 검사한다. (동일성 검사 - Object Identity)\n<ul>\n<li>성능 향상을 위한 코드</li>\n<li>equals가 복잡할 때 같은 참조를 가진 객체에 대한 비교를 안하기 위함</li>\n</ul>\n</li>\n<li><code>instanceof</code> 연산자로 파라미터의 타입이 올바른지 체크\n<ul>\n<li>묵시적 null체크 용도로도 사용</li>\n<li>equals중에서는 같은 interface를 구현한 클래스끼리도 비교하는 경우가 있다.</li>\n</ul>\n</li>\n<li>입력을 올바른 타입으로 형변환한다.\n<ul>\n<li>Object타입의 파라미터를 비교하고자 하는 타입으로 형변환한다.</li>\n<li>앞서 <code>instanceof</code> 연산을 수행했기 때문에 100% 성공한다.</li>\n</ul>\n</li>\n<li>파라미터 Object 객체와 자기자신의 대응되는 핵심필드들이 모두 일치하는지 확인한다.\n<ul>\n<li>하나라도 다르면 false를 리턴</li>\n<li>만약 interface기반의 비교가 필요하다면 필드정보를 가져오는 메서드가 interface에 정의되어있어야하고,<br>\n구현체 클래스에서는 메서드를 재정의 해야한다.</li>\n</ul>\n</li>\n<li>float, double을 제외한 기본타입은 <code>==</code>을 통해 비교</li>\n<li>참조(reference) 타입은 equals를 통해 비교</li>\n<li>float, double은 Float.compare(float, float)와 Double.compare(double, double)로 비교한다.\n<ul>\n<li>Float.Nan, -0.0f등을 비교하기 위함이다.</li>\n<li>이 메서드들은 float -&gt; Float, double -&gt; Double로 변환하는 오토박싱 기능이 수반되므로 성능상 좋지 못하다.</li>\n</ul>\n</li>\n<li>배열의 모든 원소가 핵심 필드라면 Arrays.equals를 사용하자</li>\n<li>null이 의심되는 필드는 Objects.equals(obj, obj)를 이용해 NullPointerException을 예방하자</li>\n<li>성능을 올리고자 한다면\n<ul>\n<li>다를 확률이 높은 필드부터 비교한다.</li>\n<li>비교하는 비용(시간복잡도)이 적은 비교를 먼저 수행</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"주의사항\">주의사항</h1>\n<ul>\n<li>equals를 재정의 했다면, 대칭성, 추이성, 일관성에 대한 체크를 꼭 하자 (테스트 케이스 작성 요망)</li>\n<li>equals를 작성할 때는 hashcode도 반드시 재정의하자 (Item.11)</li>\n<li>너무 복잡하게 해결하려 들지 말자</li>\n<li>equals의 파라미터는 Object이외의 타입으로 선언하지 말자 (컴파일 에러 발생)</li>\n<li>구글에서 만든 @AutoValue을 이용해서 equals와 hashcode를 자동으로 재정의해보자 (Lombok의 @EqualsAndHashCode도 있다.)</li>\n</ul>\n<h1 id=\"참고\">참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 10. equals는 일반 규약을 지켜 재정의하라</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300","top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":false,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":true,"shortname":"Carrey"},"since":2018,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Carrey`s 기술블로그","subtitle":"공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.","description":"","author":"Carrey","language":"lang","timezone":"Asia/seoul","url":"https://jaehun2841.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":["googleb6989b051cadc23a.html","naver06b931b9a92d9d3d74ae0c39217e61a6.html"],"new_post_name":":title.md","default_layout":"post","titlecase":true,"external_link":true,"filename_case":0,"render_drafts":true,"post_asset_folder":true,"relative_link":true,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"archives","theme":"melody","deploy":{"type":"git","repository":"https://github.com/jaehun2841/jaehun2841.github.io","branch":"master"},"ignore":[],"index_generator":{"per_page":10,"order_by":"-date","path":""},"home_posts_tag":true,"sitemap":{"path":"sitemap.xml"},"feed":{"type":"rss2","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"rss2.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"toc":{}}}}},"excerpt":"","more":"<h1>서론</h1>\n<p>equals 메서드는 Object 클래스에 구현된 메서드로 객체 내의 정보들에 대한 동등성(equality) 비교를 목적으로 하는 메서드이다.<br>\nequals 메서드를 잘못 작성하게 되면 의도하지 않는 결과들이 초래되므로 웬만하면 변경하지 않는 것이 좋다.</p>\n<h1>equals를 재정의 하지 않아도 되는 경우</h1>\n<ul>\n<li>각 인스턴스가 본질적으로 고유 한 경우 - 값이 아닌 동작을 표현하는 클래스의 경우 (Thread가 좋은 예이다.)</li>\n<li>인스턴스의 논리적 동치성 (Logical Equality)를 검사할 일이 없는 경우 - <code>java.utils.regex.Pattern</code>의 equals는 내부의 정규표현식이 같은지를 검사하는 메서드이다.</li>\n<li>상위 클래스에서 재정의한 equals가 하위 클래스에서도 적용 되는 경우 - Set, Map, List의 경우 Abstract(Type)의 equals를 쓴다.</li>\n<li>클래스가 private이거나, package-private여서 equals를 호출할 일이 없는 경우</li>\n<li>싱글턴을 보장하는 클래스(인스턴스 통제 클래스, Enum (열거타입)) 인 경우 - 객체 간 동등성, 동일성이 보장된다.</li>\n</ul>\n<h1>equals를 재정의 하는 경우 지켜야 할 규약</h1>\n<p>equals를 재정의 해야 하는 경우는 객체 동일성(식별성(Object Identity))를 확인해야 하는 경우가 아니라<br>\n논리적 동치성(동등성(Logical equality))를 비교 하도록 재정의 되지 않았을 경우이다.</p>\n<h2>반사성(reflexivity)</h2>\n<p><strong>null이 아닌 모든 참조 값 x에 대해 x.equals(x)를 만족해야한다.</strong><br>\n단순히 말하면 객체는 자기 자신과 비교했을 때 같아야 한다는 뜻이다.<br>\n이 조건을 만족하지 않는 예를 찾기가 더 어렵다.<br>\n만약 x.equals(x)가 성립하지 않는 객체라면, 컬렉션에서 contain 메서드를 사용하는 경우 방금 넣은 객체도 찾을 수 없을 것이다.</p>\n<h2>대칭성 (symmetry)</h2>\n<p><strong>null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true이면, y.equals(x)가 true를 만족해야 한다.</strong></p>\n<p>예시 코드를 보면\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaseInsensitiveString</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String s;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CaseInsensitiveString</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.s = Objects.requireNonNull(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(o <span class=\"keyword\">instanceof</span> CaseInsensitiveString) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.equalsIgnoreCase(((CaseInsensitiveString) o).s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(o <span class=\"keyword\">instanceof</span> String) &#123; <span class=\"comment\">//한 방향으로만 작동!!</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.equalsIgnoreCase((String) o);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위의 클래스를 기반으로\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CaseInsensitiveString caseInsensitiveString = <span class=\"keyword\">new</span> CaseInsensitiveString(<span class=\"string\">\"Test\"</span>);</span><br><span class=\"line\">String test = <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\">System.out.println(caseInsensitiveString.equals(test)); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(test.equals(caseInsensitiveString)); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>위의 코드를 실행하게 되면, x.equals(y)가 true일 때, y.equals(x)가 false이므로 <code>대칭성</code>이 깨지는 코드가 된다.<br>\nString 클래스에서는 CaseInsensitiveString의 존재를 모르기 때문에 false가 날 수 밖에 없는 상황이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;CaseInsensitiveString&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"keyword\">new</span> CaseInsensitiveString(<span class=\"string\">\"Test\"</span>));</span><br><span class=\"line\">System.out.println(list.contain(<span class=\"string\">\"test\"</span>)); <span class=\"comment\">//false or true</span></span><br></pre></td></tr></table></figure></p>\n<p>위의 예제의 경우는 JDK버전에 따라 다를 수 있다. x.equals(y)로 비교할 수 도 있고, y.equals(x)로 비교될 수 있기 때문이다.</p>\n<p>위의 내용을 수정한다면, String과의 비교는 포기해야 한다.<br>\n같은 CaseInsensitiveString 타입인 경우에만 비교하도록 한다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o <span class=\"keyword\">instanceof</span> CaseInsensitiveString &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2>추이성 (transitivity)</h2>\n<p><strong>null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y)가 true이고, y.equals(z)가 true이면 x.equals(z)도 true가 되야 한다는 조건이다.</strong></p>\n<p>Point클래스와 ColorPoint 클래스를 가지고 예시를 들어보겠다.<br>\n(ColorPoint는 Point클래스를 확장(extends)한 클래스이다.)\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ColorPoint a = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Color.RED);</span><br><span class=\"line\">Point b = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">ColorPoint c = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Color.BLUE);</span><br></pre></td></tr></table></figure></p>\n<p>위와 같은 인스턴스 a, b, c가 있다.\n이 때, a.equals(b)와 b.equals(c) 일 때, a.equals(c)\n가 되는 과정을 살펴 보자</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> Point)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Point p = (Point) o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x == p.x &amp;&amp; <span class=\"keyword\">this</span>.y == p.y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3>대칭성이 위배되는 case</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Color color;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> ColorPoint)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.equals(o) &amp;&amp; <span class=\"keyword\">this</span>.color == ((ColorPoint) o).color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위 처럼 ColorPoint 클래스의 equals 메서드를 재정의 했다면...\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ColorPoint a = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Color.RED);</span><br><span class=\"line\">Point b = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(a.equals(b)); <span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(b.equals(a)); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>\n<p><code>a.equals(b)</code>를 보면 a는 ColorPoint이기 떄문에 ColorPoint 클래스에서 재정의 된 equals 메서드를 타게 된다.<br>\n이렇게 되면 첫번째 if 조건에서 걸리게 된다. b는 Point이지만 ColorPoint는 아니기 떄문이다.<br>\n따라서 <code>a.equals(b)</code>는 <code>false</code>가 된다.</p>\n</li>\n<li>\n<p><code>b.equals(a)</code>를 보면 b는 Point클래스이기 떄문에 Point클래스의 equals메서드를 타게 된다.<br>\n이렇게 되면 ColorPoint는 Point클래스를 상속하고 있기 때문에 첫번째 if조건을 통과하게 되고,<br>\nint x, int y값을 기준으로만 비교하기 떄문에 값이 참이 된다.<br>\n따라서 <code>b.equals(a)</code>는 <code>true</code>가 된다.</p>\n</li>\n</ol>\n<p>위의 예시는 equals 정의 규약 중 하나인 대칭성을 위반하고 있으므로 다시 작성해야 한다.</p>\n<h3>추이성이 위반되는 case</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Color color;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> Point)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> ColorPoint)) <span class=\"keyword\">return</span> o.equals(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//o가 ColorPoint이면 색상까지 비교한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.equals(o) &amp;&amp; <span class=\"keyword\">this</span>.color == ((ColorPoint) o).color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위 처럼 ColorPoint 클래스의 equals메서드를 다시 재정의 했다면..<br>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ColorPoint a = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Color.RED);</span><br><span class=\"line\">Point b = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">ColorPoint c = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Color.BLUE);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(a.equals(b)); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(b.equals(c)); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(a.equals(c)); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><code>a.equals(b)</code>를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.<br>\nb가 Point인 경우이기 때문에 2번쨰 if 절을 타게 되어 Point의 x, y정보만 비교하게 되므로 결과는 <code>true</code>이다.</li>\n<li><code>b.equals(c)</code>를 보면 b는 Point클래스의 인스턴스이므로 Point클래스의 equals 메서드를 실행하게 된다.<br>\nPoint의 x, y정보만 비교하게 되므로 결과는 <code>true</code>이다.</li>\n<li><code>a.equals(c)</code>를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.<br>\n하지만, c가 ColorPoint클래스의 인스턴스이므로 x, y값 뿐만아니라 color까지 비교하게되어 결과는 <code>false</code>이다.</li>\n</ol>\n<p>이렇게 a.equals(b)는 <code>true</code>를 만족하고 b.equals(c)는 <code>true</code>를 만족하지만 a.equals(c)는 <code>false</code>가 되므로<br>\n위의 코드는 equals 정의 규약 중 <code>추이성</code>을 위반하는 코드가 된다.</p>\n<h3>무한 재귀 (Infinite Recursion)이 발생하는 case</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmellPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Smell smell;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> Point)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> SmellPoint)) <span class=\"keyword\">return</span> o.equals(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//o가 ColorPoint이면 색상까지 비교한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.equals(o) &amp;&amp; <span class=\"keyword\">this</span>.smell == ((SmellPoint) o).smell;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>위 처럼 Point를 상속받는 SmellPoint라는 클래스도 추가되었다고 가정해보자</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point cp = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Color.RED);</span><br><span class=\"line\">Point sp = <span class=\"keyword\">new</span> SmellPoint(<span class=\"number\">1</span>, <span class=\"number\">2</span>, Smell.SWEET);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(cp.equals(sp));  <span class=\"comment\">//?</span></span><br></pre></td></tr></table></figure></p>\n<p>위와 같이 ColorPoint와 SmellPoint에 대해 equals비교를 한다고 하면 어떻게 될까??<br>\n이렇게 되면 두번째 if절에서 무한재귀(Infinite Recursion)이 발생하게 된다.</p>\n<p>무슨 의미인지 자세히 설명하면, cp는 ColorPoint 클래스의 인스턴스이기 때문에<br>\n<code>cp.equals(sp)</code> 코드는 ColorPoint 클래스의 재정의 된 equals 메서드를 타게 된다.<br>\n이렇게 되면 두번째 if에서 걸리게 된다. 왜냐하면 o는 <strong>SmellPoint</strong> 타입이기 때문에 <code>!(o instanceof ColorPoint)</code> 이 조건식이 true가 된다.<br>\n그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 o는 SmellPoint 클래스의 인스턴스이기 때문에<br>\nSmellPoint 클래스의 재정의된 equals메서드를 타게 된다.</p>\n<p>다시 SmellPoint클래스의 입장에서 보게되면 두번째 if에서 걸리게 된다.<br>\n여기서 o는 ColorPoint타입이기 때문에 <code>!(o instanceof ColorPoint)</code> 이 조건식이 true가 된다.<br>\n그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 다시 ColorPoint 클래스의 재정의된 equals메서드를 타게 된다.</p>\n<p>이런 작업이 계속 재귀적으로 호출 되면서, 결국은 StackOverflowError를 내며 프로그램이 죽는 참사를 맞이 하게 될 것이다.</p>\n<h3>리스코프 치환 원칙 (SOLID)</h3>\n<p>SOLID원칙 중 3번째인 리스코프 치횐 원칙이란?</p>\n<blockquote>\n<p>자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.</p>\n</blockquote>\n<p>쉽게 말해서, 자식클래스에서 부모클래스의 기능을 수행하지 못하는 건 리스코프 치환원칙에 위배된다고 볼 수 있다.</p>\n<p>위에서 equals 재정의에 실패해서 다시 또 변경하였다.\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Set&lt;Point&gt; unitCircle = Set.of(<span class=\"keyword\">new</span> Point(<span class=\"number\">0</span>, -<span class=\"number\">1</span>),</span><br><span class=\"line\">   <span class=\"keyword\">new</span> Point(<span class=\"number\">0</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\">   <span class=\"keyword\">new</span> Point(-<span class=\"number\">1</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">   <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onUnitCircle</span><span class=\"params\">(Point p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unitCircle.contains(p);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(o == <span class=\"keyword\">null</span> || o.getClass() != <span class=\"keyword\">this</span>.getClass()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Point p = (Point) o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x == p.x &amp;&amp; <span class=\"keyword\">this</span>.y = p.y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이번에는 주어진 점이 반지름이 1인 원안에 포함되는지에 대한 여부를 판단하는 로직이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ColorPoint cp = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">1</span>, <span class=\"number\">0</span>, Color.RED);</span><br><span class=\"line\">System.out.println(Point.onUnitCircle(cp)); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>ColorPoint는 Point를 상속한 클래스이다.<br>\n실제 oint.onUnitCircle 메서드의 contains 메서드에서 Set내의 element들에 대한 equals 비교가 일어나게 된다.<br>\n하지만 equals 메서드 첫번째 if문에서 걸리게 된다.<br>\nColorPoint 객체가 파라미터로 전달되어 null은 아니지만,<br>\n두번째 조건식인 o.getClass()에서 <code>ColorPoint.class</code>가 도출되고 this.getClass()에서는 <code>Point.class</code>가 도출되게 된다.</p>\n<p>위 조건식 때문에 ColorPoint 클래스는 Point클래스로서 equals메서드 내에서 활용되지 못했기 때문에<br>\n위 코드는 리스코프 치환원칙에 위배되는 코드로 전락해 버렸다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(o == <span class=\"keyword\">null</span> || !(o <span class=\"keyword\">instanceof</span> Point)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point p = (Point) o;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x == p.x &amp;&amp; <span class=\"keyword\">this</span>.y = p.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>차라리 이런식으로 instanceof를 사용했다면 좋았을 것이다.</p>\n<h2>상속 대신 컴포지션(Composition)을 사용하라</h2>\n<p>구체클래스의 하위클래스에서 값을 추가할 방법은 없지만, 우회방법이 있다.<br>\n상속 대신에 Point 변수를 갖도록 Composition(구성)을 이용하는 방법이다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ColorPoint &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Point point;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Color color;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ColorPoint</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, Color color)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.point = <span class=\"keyword\">new</span> Point(x, y);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color = Objects.requireNonNull(color);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Point <span class=\"title\">asPoint</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.point;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> ColorPoint)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ColorPoint cp = (ColorPoint) o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.point.equals(cp) &amp;&amp; <span class=\"keyword\">this</span>.color.equals(cp.color);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이와 같이 컴포지션을 이용하면 상속에 때문에 발생하는 대칭성, 추이성, 리스코프 치환원칙에 위배되지 않는 코드를 작성할 수 있다.</p>\n<h2>일관성 (consistency)</h2>\n<p><strong>null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.</strong><br>\n두 객체가 같다면 수정되지 않는 한 영원히 같아야 함을 의미한다.<br>\n가변객체는 비교시점에 따라 서로 달라질 수 있지만 불변객체라면 한번 다르면 끝까지 달라야 한다. (그래서 불변객체로 만드는 것이 나을때가 많다)</p>\n<p>하지만, 클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들어서는 안된다.<br>\n<code>java.net.URL</code> 클래스는 URL과 매핑된 host의 IP주소를 이용해 비교한다.<br>\n당장 우리회사 서버만 봐도 L4스위치가 적용되있기 때문에 로드밸런싱이 되어 같은 도메인주소라도 그떄그떄 나오는 IP정보가 다르다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL url1 = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"www.site-name.co.kr\"</span>);</span><br><span class=\"line\">URL url2 = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"www.site-name.co.kr\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(url1.equals(url2)); <span class=\"comment\">//?</span></span><br></pre></td></tr></table></figure></p>\n<p>실제 url1이 10.0.0.1 이라는 IP가 나왔다면<br>\nurl2의 경우 10.0.0.1이 나올수도 있고, 같은 대역에 있는 10.0.0.2가 나올 수도 있다.<br>\n그렇기 떄문에 equals의 결과가 가변적이기 떄문에 다른 자원의 개입으로 인해 equals의 일관성이 깨지게 된다.</p>\n<p>그렇게 때문에 항상 equals를 사용할 때는 메모리에 존재하는 객체만을 사용한 결정적(deterministic) 계산만 수행해야 한다.</p>\n<h2>not null</h2>\n<p><strong>null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다</strong>\n기본적으로 x.equals(null)이 true가 되는 일은 생각하기 어렵다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(o == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">//불필요</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x == o.x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>하지만 equals를 재정의 할 때 이러한 코드를 작성하기 쉽다.</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> MyClass)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">//묵시적 null검사</span></span><br><span class=\"line\">  MyClass clazz = (MyClass) o;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x == clazz.x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>이런식으로 instanceof 키워드를 통해 묵시적 null 체크를 하는 방법이 좋다.</p>\n<h1>요약 정리</h1>\n<h2>equals 구현 절차</h2>\n<ul>\n<li><code>==</code> 연산자를 사용해 입력된 파라미터와 자기자신이 같은 객체인지 검사한다. (동일성 검사 - Object Identity)\n<ul>\n<li>성능 향상을 위한 코드</li>\n<li>equals가 복잡할 때 같은 참조를 가진 객체에 대한 비교를 안하기 위함</li>\n</ul>\n</li>\n<li><code>instanceof</code> 연산자로 파라미터의 타입이 올바른지 체크\n<ul>\n<li>묵시적 null체크 용도로도 사용</li>\n<li>equals중에서는 같은 interface를 구현한 클래스끼리도 비교하는 경우가 있다.</li>\n</ul>\n</li>\n<li>입력을 올바른 타입으로 형변환한다.\n<ul>\n<li>Object타입의 파라미터를 비교하고자 하는 타입으로 형변환한다.</li>\n<li>앞서 <code>instanceof</code> 연산을 수행했기 때문에 100% 성공한다.</li>\n</ul>\n</li>\n<li>파라미터 Object 객체와 자기자신의 대응되는 핵심필드들이 모두 일치하는지 확인한다.\n<ul>\n<li>하나라도 다르면 false를 리턴</li>\n<li>만약 interface기반의 비교가 필요하다면 필드정보를 가져오는 메서드가 interface에 정의되어있어야하고,<br>\n구현체 클래스에서는 메서드를 재정의 해야한다.</li>\n</ul>\n</li>\n<li>float, double을 제외한 기본타입은 <code>==</code>을 통해 비교</li>\n<li>참조(reference) 타입은 equals를 통해 비교</li>\n<li>float, double은 Float.compare(float, float)와 Double.compare(double, double)로 비교한다.\n<ul>\n<li>Float.Nan, -0.0f등을 비교하기 위함이다.</li>\n<li>이 메서드들은 float -&gt; Float, double -&gt; Double로 변환하는 오토박싱 기능이 수반되므로 성능상 좋지 못하다.</li>\n</ul>\n</li>\n<li>배열의 모든 원소가 핵심 필드라면 Arrays.equals를 사용하자</li>\n<li>null이 의심되는 필드는 Objects.equals(obj, obj)를 이용해 NullPointerException을 예방하자</li>\n<li>성능을 올리고자 한다면\n<ul>\n<li>다를 확률이 높은 필드부터 비교한다.</li>\n<li>비교하는 비용(시간복잡도)이 적은 비교를 먼저 수행</li>\n</ul>\n</li>\n</ul>\n<h1>주의사항</h1>\n<ul>\n<li>equals를 재정의 했다면, 대칭성, 추이성, 일관성에 대한 체크를 꼭 하자 (테스트 케이스 작성 요망)</li>\n<li>equals를 작성할 때는 hashcode도 반드시 재정의하자 (Item.11)</li>\n<li>너무 복잡하게 해결하려 들지 말자</li>\n<li>equals의 파라미터는 Object이외의 타입으로 선언하지 말자 (컴파일 에러 발생)</li>\n<li>구글에서 만든 @AutoValue을 이용해서 equals와 hashcode를 자동으로 재정의해보자 (Lombok의 @EqualsAndHashCode도 있다.)</li>\n</ul>\n<h1>참고</h1>\n<ul>\n<li>Effective Java 3rd Edition - Item 10. equals는 일반 규약을 지켜 재정의하라</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide setting.png","slug":"ide setting.png","post":"cjrgbv2rb0008cr1trwjpe3de","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide-setting.png","slug":"ide-setting.png","post":"cjrgbv2rb0008cr1trwjpe3de","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide설정.png","slug":"ide설정.png","post":"cjrgbv2rb0008cr1trwjpe3de","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/image-20180831235454808.png","slug":"image-20180831235454808.png","post":"cjrgbv3rg002wcr1tg0nkpx9j","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921153027741.png","slug":"image-20180921153027741.png","post":"cjrgbv3rk0031cr1t2a69lf9m","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-28-docker-2/redis-versions.png","slug":"redis-versions.png","post":"cjrgbv3ro0038cr1t1on8m91w","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-01-docker-5/ip.PNG","slug":"ip.PNG","post":"cjrgbv2rw000hcr1twf83zmm5","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-21-spring-context/99A34C3359FEAA8410.png","slug":"99A34C3359FEAA8410.png","post":"cjrgbv2ro000bcr1tqqpki2w0","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-30-mybatis-returnInstanceForEmptyRow/all_element_are_null.png","slug":"all_element_are_null.png","post":"cjrgbv2s0000mcr1tdmkqo6xp","modified":0,"renderable":0},{"_id":"source/_posts/java-object-copy/clone.jpg","slug":"clone.jpg","post":"cjrgbv2sf001kcr1this05zxz","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-redis-stats/redis-stat-1.PNG","slug":"redis-stat-1.PNG","post":"cjrgbv2ry000jcr1tokvfqok9","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-redis-stats/redis-stat-web.PNG","slug":"redis-stat-web.PNG","post":"cjrgbv2ry000jcr1tokvfqok9","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-redis-stats/redis-stat-web2.PNG","slug":"redis-stat-web2.PNG","post":"cjrgbv2ry000jcr1tokvfqok9","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-25-docker-1/docker-image.png","slug":"docker-image.png","post":"cjrgbv2rv000gcr1tbqm8jpqc","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-25-docker-1/docker-logo.png","slug":"docker-logo.png","post":"cjrgbv2rv000gcr1tbqm8jpqc","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-25-docker-1/docking-image.png","slug":"docking-image.png","post":"cjrgbv2rv000gcr1tbqm8jpqc","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-25-docker-1/vm-vs-docker.png","slug":"vm-vs-docker.png","post":"cjrgbv2rv000gcr1tbqm8jpqc","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ipv4.png","slug":"ipv4.png","post":"cjrgbv2rb0008cr1trwjpe3de","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ipv6.png","slug":"ipv6.png","post":"cjrgbv2rb0008cr1trwjpe3de","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-01-docker-5/docker-bridge-2.PNG","slug":"docker-bridge-2.PNG","post":"cjrgbv2rw000hcr1twf83zmm5","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-01-docker-5/docker-bridge-mode.png","slug":"docker-bridge-mode.png","post":"cjrgbv2rw000hcr1twf83zmm5","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-01-docker-5/docker0-interface.PNG","slug":"docker0-interface.PNG","post":"cjrgbv2rw000hcr1twf83zmm5","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-01-docker-5/httpd.PNG","slug":"httpd.PNG","post":"cjrgbv2rw000hcr1twf83zmm5","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-01-docker-5/none.PNG","slug":"none.PNG","post":"cjrgbv2rw000hcr1twf83zmm5","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-01-docker-5/redis1.PNG","slug":"redis1.PNG","post":"cjrgbv2rw000hcr1twf83zmm5","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-01-docker-5/redis2.PNG","slug":"redis2.PNG","post":"cjrgbv2rw000hcr1twf83zmm5","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-28-docker-2/docker-hub.png","slug":"docker-hub.png","post":"cjrgbv3ro0038cr1t1on8m91w","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-29-java-exception/Exception-Class.png","slug":"Exception-Class.png","post":"cjrgbv3rh002xcr1t3ic89qen","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-21-spring-ioc-2/containers.jpg","slug":"containers.jpg","post":"cjrgbv3rl0033cr1tvdiw7k6a","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet/Front-controller-pattern.png","slug":"Front-controller-pattern.png","post":"cjrgbv3re002scr1tkrpp7q2b","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet/dispatcher-servlet-lifecycle.jpg","slug":"dispatcher-servlet-lifecycle.jpg","post":"cjrgbv3re002scr1tkrpp7q2b","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor/filter-chain.gif","slug":"filter-chain.gif","post":"cjrgbv3rf002ucr1t5919901t","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor/spring-request-lifecycle.jpg","slug":"spring-request-lifecycle.jpg","post":"cjrgbv3rf002ucr1t5919901t","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/Dispatch-Seq.jpg","slug":"Dispatch-Seq.jpg","post":"cjrgbv3rd002rcr1t9i13e9is","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/RequestMappingHandlerAdapter.png","slug":"RequestMappingHandlerAdapter.png","post":"cjrgbv3rd002rcr1t9i13e9is","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/argument-resolver-result.png","slug":"argument-resolver-result.png","post":"cjrgbv3rd002rcr1t9i13e9is","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-01-servlet/Servlet-life-cycle.png","slug":"Servlet-life-cycle.png","post":"cjrgbv3ri002ycr1tqey5uu4s","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-01-servlet/jspToServlet.jpeg","slug":"jspToServlet.jpeg","post":"cjrgbv3ri002ycr1tqey5uu4s","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-01-servlet/servlet.png","slug":"servlet.png","post":"cjrgbv3ri002ycr1tqey5uu4s","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-01-docker-6/Redis-Cluster-archi.PNG","slug":"Redis-Cluster-archi.PNG","post":"cjrgbv3ru003gcr1tlpo0g916","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-01-docker-6/redis-replication-3746317.PNG","slug":"redis-replication-3746317.PNG","post":"cjrgbv3ru003gcr1tlpo0g916","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-01-docker-6/redis-replication2-3746337.PNG","slug":"redis-replication2-3746337.PNG","post":"cjrgbv3ru003gcr1tlpo0g916","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/Exception-Class.png","slug":"Exception-Class.png","post":"cjrgbv3rg002wcr1tg0nkpx9j","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/image-20180831234615081.png","slug":"image-20180831234615081.png","post":"cjrgbv3rg002wcr1tg0nkpx9j","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/spring-mvc-request.jpg","slug":"spring-mvc-request.jpg","post":"cjrgbv3rg002wcr1tg0nkpx9j","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921142925583.png","slug":"image-20180921142925583.png","post":"cjrgbv3rk0031cr1t2a69lf9m","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921142928480.png","slug":"image-20180921142928480.png","post":"cjrgbv3rk0031cr1t2a69lf9m","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921143924788.png","slug":"image-20180921143924788.png","post":"cjrgbv3rk0031cr1t2a69lf9m","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921145310488.png","slug":"image-20180921145310488.png","post":"cjrgbv3rk0031cr1t2a69lf9m","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-28-docker-2/docker-permission.png","slug":"docker-permission.png","post":"cjrgbv3ro0038cr1t1on8m91w","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-28-docker-2/image-layer.png","slug":"image-layer.png","post":"cjrgbv3ro0038cr1t1on8m91w","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-28-docker-2/sudo-docker.png","slug":"sudo-docker.png","post":"cjrgbv3ro0038cr1t1on8m91w","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-8/Redis-Cluster-archi.PNG","slug":"Redis-Cluster-archi.PNG","post":"cjrgbv3ry003mcr1t8nn5bpw7","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-8/haproxy1.PNG","slug":"haproxy1.PNG","post":"cjrgbv3ry003mcr1t8nn5bpw7","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-8/haproxy2.PNG","slug":"haproxy2.PNG","post":"cjrgbv3ry003mcr1t8nn5bpw7","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-8/haproxy3.PNG","slug":"haproxy3.PNG","post":"cjrgbv3ry003mcr1t8nn5bpw7","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-8/haproxy4.PNG","slug":"haproxy4.PNG","post":"cjrgbv3ry003mcr1t8nn5bpw7","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-8/haproxy5.PNG","slug":"haproxy5.PNG","post":"cjrgbv3ry003mcr1t8nn5bpw7","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-8/haproxy6.PNG","slug":"haproxy6.PNG","post":"cjrgbv3ry003mcr1t8nn5bpw7","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-7/Redis-failover-1.PNG","slug":"Redis-failover-1.PNG","post":"cjrgbv3rw003icr1tgxkyz66z","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-7/Redis-failover-2.PNG","slug":"Redis-failover-2.PNG","post":"cjrgbv3rw003icr1tgxkyz66z","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-7/redis-failover-3-3748019.PNG","slug":"redis-failover-3-3748019.PNG","post":"cjrgbv3rw003icr1tgxkyz66z","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-7/redis-failover-3.PNG","slug":"redis-failover-3.PNG","post":"cjrgbv3rw003icr1tgxkyz66z","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-7/redis-failover-4.PNG","slug":"redis-failover-4.PNG","post":"cjrgbv3rw003icr1tgxkyz66z","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-7/redis-failover-log.PNG","slug":"redis-failover-log.PNG","post":"cjrgbv3rw003icr1tgxkyz66z","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-7/redis-sentinel-log.PNG","slug":"redis-sentinel-log.PNG","post":"cjrgbv3rw003icr1tgxkyz66z","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-02-docker-7/sentinel.PNG","slug":"sentinel.PNG","post":"cjrgbv3rw003icr1tgxkyz66z","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/Redis-Cluster-archi.PNG","slug":"Redis-Cluster-archi.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/cluster-add-node-slave.PNG","slug":"cluster-add-node-slave.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/cluster-add.PNG","slug":"cluster-add.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/cluster-keys-command.PNG","slug":"cluster-keys-command.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/cluster-nodes.png","slug":"cluster-nodes.png","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/cluster-setting.PNG","slug":"cluster-setting.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/cluster-setting2.PNG","slug":"cluster-setting2.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/failover-1.png","slug":"failover-1.png","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/failover2.png","slug":"failover2.png","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/master-del-fail.png","slug":"master-del-fail.png","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/master-del-success.png","slug":"master-del-success.png","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/master-down.png","slug":"master-down.png","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/new-redis-cluster.PNG","slug":"new-redis-cluster.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/new-redis-cluster2.PNG","slug":"new-redis-cluster2.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/reshard-test-1-3831920.PNG","slug":"reshard-test-1-3831920.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/reshard-test-1.PNG","slug":"reshard-test-1.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/reshard-test-2-3832564.PNG","slug":"reshard-test-2-3832564.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/reshard-test-2.PNG","slug":"reshard-test-2.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/reshard-test-3.PNG","slug":"reshard-test-3.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/slave-add-result.png","slug":"slave-add-result.png","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/slave-del-result.png","slug":"slave-del-result.png","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/slave-del.png","slug":"slave-del.png","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-03-docker-10/sub-reshard.PNG","slug":"sub-reshard.PNG","post":"cjrgbv3rx003kcr1t7r5dhxm1","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-03-spring-ehcache/17110B4350CC5EC51D-20181011233534455.jpeg","slug":"17110B4350CC5EC51D-20181011233534455.jpeg","post":"cjrgbv3tu0046cr1tw7jff952","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-03-spring-ehcache/17110B4350CC5EC51D.jpeg","slug":"17110B4350CC5EC51D.jpeg","post":"cjrgbv3tu0046cr1tw7jff952","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-03-spring-ehcache/EHCACHE.png","slug":"EHCACHE.png","post":"cjrgbv3tu0046cr1tw7jff952","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-03-spring-ehcache/ehcache-test.png","slug":"ehcache-test.png","post":"cjrgbv3tu0046cr1tw7jff952","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-03-spring-ehcache/test-result.png","slug":"test-result.png","post":"cjrgbv3tu0046cr1tw7jff952","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjrgbv2rb0008cr1trwjpe3de","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv2ru000fcr1t83vz0d9y"},{"post_id":"cjrgbv2rf0009cr1tl647nrew","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv2s0000ncr1t9g01cokj"},{"post_id":"cjrgbv2rf0009cr1tl647nrew","tag_id":"cjrgbv2rx000icr1tnxm58c2c","_id":"cjrgbv2s1000pcr1tube0kn4z"},{"post_id":"cjrgbv2ro000bcr1tqqpki2w0","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv2s5000vcr1tjwcetkmn"},{"post_id":"cjrgbv2ro000bcr1tqqpki2w0","tag_id":"cjrgbv2s1000qcr1t31hs3esl","_id":"cjrgbv2s6000xcr1t9knh53j8"},{"post_id":"cjrgbv2rr000ccr1tn2vmhkx8","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv2s90013cr1t4plip8o4"},{"post_id":"cjrgbv2rr000ccr1tn2vmhkx8","tag_id":"cjrgbv2s4000tcr1tx41yftzc","_id":"cjrgbv2s90015cr1t2zlcgmad"},{"post_id":"cjrgbv2rr000ccr1tn2vmhkx8","tag_id":"cjrgbv2s6000ycr1t5ud5vpng","_id":"cjrgbv2sa0018cr1t0vjmijm4"},{"post_id":"cjrgbv2rs000dcr1ti03ghftm","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv2sb001acr1tb588imoj"},{"post_id":"cjrgbv2rs000dcr1ti03ghftm","tag_id":"cjrgbv2s6000ycr1t5ud5vpng","_id":"cjrgbv2sc001dcr1tbzzckct6"},{"post_id":"cjrgbv2rv000gcr1tbqm8jpqc","tag_id":"cjrgbv2sa0017cr1tik4wo2py","_id":"cjrgbv2sd001fcr1txh27f8r5"},{"post_id":"cjrgbv2rw000hcr1twf83zmm5","tag_id":"cjrgbv2sa0017cr1tik4wo2py","_id":"cjrgbv2sf001jcr1tw81kqzj1"},{"post_id":"cjrgbv2ry000jcr1tokvfqok9","tag_id":"cjrgbv2sa0017cr1tik4wo2py","_id":"cjrgbv2sg001mcr1tc2kg312c"},{"post_id":"cjrgbv2rz000kcr1tcxo6jk01","tag_id":"cjrgbv2sa0017cr1tik4wo2py","_id":"cjrgbv2sh001ocr1t9b695kfh"},{"post_id":"cjrgbv2s0000mcr1tdmkqo6xp","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv2sh001qcr1thvuyzdwj"},{"post_id":"cjrgbv2s0000mcr1tdmkqo6xp","tag_id":"cjrgbv2sg001ncr1ttfi1dqq4","_id":"cjrgbv2sh001rcr1ttnj0qoo8"},{"post_id":"cjrgbv2s1000ocr1t3f4rnrxo","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2si001tcr1tnh3go69b"},{"post_id":"cjrgbv2s2000rcr1ttebuk4gy","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2si001vcr1tcl8y1k1d"},{"post_id":"cjrgbv2s3000scr1tealiyhfh","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2sj001xcr1trala1ssc"},{"post_id":"cjrgbv2s4000ucr1tug53tbvg","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2sj001zcr1tshbog632"},{"post_id":"cjrgbv2s5000wcr1tnbjymsd5","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2sk0021cr1tof3f1wjb"},{"post_id":"cjrgbv2s6000zcr1thilkibt4","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2sk0023cr1tvse96vnf"},{"post_id":"cjrgbv2s70010cr1tpgdmgz6n","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2sl0025cr1tgn1b868k"},{"post_id":"cjrgbv2s70011cr1tzv7yhwr7","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2sl0027cr1t7mi55ufg"},{"post_id":"cjrgbv2s90014cr1th8j8cbb9","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2sm0029cr1tblc287xl"},{"post_id":"cjrgbv2sa0016cr1t8edk0gqf","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2sm002bcr1tdtf5bla1"},{"post_id":"cjrgbv2sb0019cr1tct5czqms","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2sm002dcr1tpag4zrto"},{"post_id":"cjrgbv2sb001bcr1ttzhpjnn3","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2sn002fcr1t5ub7k9dy"},{"post_id":"cjrgbv2sc001ecr1tns80s03f","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2sn002hcr1tgxtd031o"},{"post_id":"cjrgbv2sd001gcr1tt05lcc1r","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2so002jcr1t8yaqizcu"},{"post_id":"cjrgbv2se001icr1tldcu6bst","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2so002lcr1thjppe6i3"},{"post_id":"cjrgbv2sf001kcr1this05zxz","tag_id":"cjrgbv2so002kcr1tdiv7s1yh","_id":"cjrgbv2so002ncr1tcx744xi5"},{"post_id":"cjrgbv2sf001kcr1this05zxz","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv2so002ocr1tjkaofc8h"},{"post_id":"cjrgbv3rd002rcr1t9i13e9is","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv3rf002tcr1t5gb1isqk"},{"post_id":"cjrgbv3rh002xcr1t3ic89qen","tag_id":"cjrgbv2so002kcr1tdiv7s1yh","_id":"cjrgbv3rk0030cr1tkslqej6h"},{"post_id":"cjrgbv3re002scr1tkrpp7q2b","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv3rl0032cr1t1gj13z5g"},{"post_id":"cjrgbv3re002scr1tkrpp7q2b","tag_id":"cjrgbv3rg002vcr1tkyrs36zf","_id":"cjrgbv3rm0035cr1taiajw4t8"},{"post_id":"cjrgbv3rk0031cr1t2a69lf9m","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv3ro0037cr1tq7crmhaz"},{"post_id":"cjrgbv3rf002ucr1t5919901t","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv3rq003acr1tnjpa3355"},{"post_id":"cjrgbv3rf002ucr1t5919901t","tag_id":"cjrgbv3rj002zcr1tksfnrk25","_id":"cjrgbv3rt003ccr1tt5j3fhai"},{"post_id":"cjrgbv3rl0033cr1tvdiw7k6a","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv3ru003fcr1tya1mp60h"},{"post_id":"cjrgbv3rg002wcr1tg0nkpx9j","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv3rw003hcr1txrmb84mx"},{"post_id":"cjrgbv3rg002wcr1tg0nkpx9j","tag_id":"cjrgbv3rj002zcr1tksfnrk25","_id":"cjrgbv3rx003jcr1tvaugyrrh"},{"post_id":"cjrgbv3ro0038cr1t1on8m91w","tag_id":"cjrgbv2sa0017cr1tik4wo2py","_id":"cjrgbv3ry003lcr1t3pdew2l9"},{"post_id":"cjrgbv3rq003bcr1tsx820cbd","tag_id":"cjrgbv2sa0017cr1tik4wo2py","_id":"cjrgbv3rz003ncr1tdn4194zx"},{"post_id":"cjrgbv3ri002ycr1tqey5uu4s","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv3s0003pcr1t7t5qsmq0"},{"post_id":"cjrgbv3ri002ycr1tqey5uu4s","tag_id":"cjrgbv3rp0039cr1tld6mogn6","_id":"cjrgbv3s1003scr1tg5lrlat6"},{"post_id":"cjrgbv3rt003dcr1td0wqolx5","tag_id":"cjrgbv2sa0017cr1tik4wo2py","_id":"cjrgbv3s2003ucr1tskz2i029"},{"post_id":"cjrgbv3ru003gcr1tlpo0g916","tag_id":"cjrgbv2sa0017cr1tik4wo2py","_id":"cjrgbv3s4003wcr1t2fyaesgy"},{"post_id":"cjrgbv3rm0036cr1tfzkgl2dn","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv3s4003xcr1tpquqyont"},{"post_id":"cjrgbv3rm0036cr1tfzkgl2dn","tag_id":"cjrgbv3ru003ecr1tcbqm6h9o","_id":"cjrgbv3s4003ycr1ty9gp19k1"},{"post_id":"cjrgbv3rw003icr1tgxkyz66z","tag_id":"cjrgbv2sa0017cr1tik4wo2py","_id":"cjrgbv3s4003zcr1toszqsqjv"},{"post_id":"cjrgbv3rx003kcr1t7r5dhxm1","tag_id":"cjrgbv2sa0017cr1tik4wo2py","_id":"cjrgbv3s40040cr1tvy7ofkbk"},{"post_id":"cjrgbv3ry003mcr1t8nn5bpw7","tag_id":"cjrgbv2sa0017cr1tik4wo2py","_id":"cjrgbv3s40041cr1tx6nrlcyb"},{"post_id":"cjrgbv3s0003qcr1t682eq12t","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv3s50042cr1taef49r55"},{"post_id":"cjrgbv3s1003tcr1tvwk42m33","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv3s50043cr1t0n1exic9"},{"post_id":"cjrgbv3s2003vcr1tjxvyf0m6","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv3s50044cr1tybeszytx"},{"post_id":"cjrgbv3rz003ocr1t6hd454fz","tag_id":"cjrgbv3s1003rcr1t54jg0eie","_id":"cjrgbv3s50045cr1t53kq4w4d"},{"post_id":"cjrgbv3tu0046cr1tw7jff952","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv3tv0048cr1t15xes5g3"},{"post_id":"cjrgbv3tv0047cr1t84r3e1sy","tag_id":"cjrgbv2rl000acr1tzfoyla8b","_id":"cjrgbv3tw004acr1tbful0wc5"},{"post_id":"cjrgbv3tv0047cr1t84r3e1sy","tag_id":"cjrgbv3ru003ecr1tcbqm6h9o","_id":"cjrgbv3tw004bcr1tbr80u9ir"},{"post_id":"cjrgbv3tv0049cr1tj32p9kph","tag_id":"cjrgbv2sh001pcr1tgmnwkhug","_id":"cjrgbv3tw004ccr1t32o2h40h"}],"Tag":[{"name":"Spring","_id":"cjrgbv2rl000acr1tzfoyla8b"},{"name":"Java-Config","_id":"cjrgbv2rx000icr1tnxm58c2c"},{"name":"WAS","_id":"cjrgbv2s1000qcr1t31hs3esl"},{"name":"Spring Boot","_id":"cjrgbv2s4000tcr1tx41yftzc"},{"name":"EHCache","_id":"cjrgbv2s6000ycr1t5ud5vpng"},{"name":"Docker","_id":"cjrgbv2sa0017cr1tik4wo2py"},{"name":"Mybatis","_id":"cjrgbv2sg001ncr1ttfi1dqq4"},{"name":"Effective-Java","_id":"cjrgbv2sh001pcr1tgmnwkhug"},{"name":"Java","_id":"cjrgbv2so002kcr1tdiv7s1yh"},{"name":"core","_id":"cjrgbv3rg002vcr1tkyrs36zf"},{"name":"Spring Core","_id":"cjrgbv3rj002zcr1tksfnrk25"},{"name":"J2EE","_id":"cjrgbv3rp0039cr1tld6mogn6"},{"name":"SpEL","_id":"cjrgbv3ru003ecr1tcbqm6h9o"},{"name":"2018-remind","_id":"cjrgbv3s1003rcr1t54jg0eie"}]}}