{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":0,"renderable":0},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1543303412352},{"_id":"source/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1543303412352},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1543303412437},{"_id":"themes/beantech/_config.yml","hash":"6afd65c055d9b1c70ae67323cc869f1b4aa60348","modified":1543303412437},{"_id":"source/_posts/2018-07-15-spring-aop.md","hash":"b2416e01e18a07908eb9983f2792c1a47ca173e2","modified":1543303412352},{"_id":"source/_posts/2018-07-20-spring-aop2.md","hash":"47fed6344f090ef86329a1114640afd668d328ee","modified":1543303412353},{"_id":"source/_posts/2018-07-21-spring-aop3.md","hash":"f9ee48b62b7e238213e643ca4b1f98c3c9c557fa","modified":1543303412353},{"_id":"source/_posts/2018-08-10-httprequest-client-ip.md","hash":"3828a9d80ea5beb9f0348adc359eeb73c9728474","modified":1543303412354},{"_id":"source/_posts/2018-07-22-spring-aop4.md","hash":"a04545bdb9b27330fc63adf73bcca59129396fb8","modified":1543303412353},{"_id":"source/_posts/2018-07-24-spring-aop5.md","hash":"244f3300ca2f2610da52abedc1b29dc82b0fcfd5","modified":1543303412353},{"_id":"source/_posts/2018-08-10-spring-argument-resolver.md","hash":"5ccaaba3637ce3eb22d5eb4eb796e2daf1e9b51c","modified":1543303412359},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor.md","hash":"668125a8a615eb222a744caef8963d8a9a3d45be","modified":1543303412364},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception.md","hash":"6a4831c905f03bf985978ce75e75624c8a72cb77","modified":1543303412365},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet.md","hash":"31fd90d36ec76907d8ca9708a84690e86f3faa73","modified":1543303412363},{"_id":"source/_posts/2018-08-29-java-exception.md","hash":"823c4e7364092fdcb3c05d65e5d5f2adb46f667e","modified":1543303412369},{"_id":"source/_posts/2018-09-01-servlet.md","hash":"ebecd107dd150dff6b7f8c00ac10bd3333feb596","modified":1543303412370},{"_id":"source/_posts/2018-10-03-spring-ehcache.md","hash":"8b7e62928486638893f24f29b1a5c495be061df5","modified":1543303412377},{"_id":"source/_posts/2018-10-21-java-config-import.md","hash":"adbb213bd6f1d5bf09d7bdfaf5eeb40f3841af51","modified":1543303412380},{"_id":"source/_posts/2018-09-21-spring-ioc-2.md","hash":"c82ec3a2ef1964441b8ea15319016ac979ffe439","modified":1543303412375},{"_id":"source/_posts/2018-09-12-spring-ioc.md","hash":"3bdcfbfa9b0dc0e52bc1bc57d093e183b6375708","modified":1543303412371},{"_id":"source/_posts/2018-10-21-spring-context.md","hash":"c7d0baa58fcca09953bc2f1c05d1827930587e9a","modified":1543303412380},{"_id":"source/_posts/2018-11-21-spel-expression.md","hash":"5d069c8c4e2c9efbb425e565764d0fdada936761","modified":1543303412382},{"_id":"source/_posts/2018-11-25-docker-1.md","hash":"c220cc673a33fe4292e8b017364f45ab57b941db","modified":1543303412383},{"_id":"source/_posts/2018-11-04-ehcache-config-for-springboot.md","hash":"8a6af63923ece161c8db98b82364661c6fdce215","modified":1543303412381},{"_id":"source/_posts/2018-11-28-docker-2.md","hash":"e2be4bddb9406d4fc21a8925a33933335d7b3d2f","modified":1543420050299},{"_id":"source/_posts/2018-11-04-ehcache-config-for-springframework.md","hash":"1c465c63386e2fb807c20a6959900f2ba88d613b","modified":1543303412382},{"_id":"source/_posts/2018-11-25-spel-expression-2.md","hash":"6a504181692ee9c91fd00f64fa3c141be248eae9","modified":1543303412394},{"_id":"source/_posts/2018-12-01-docker-3.md","hash":"10a1fc17f3cb7575adcf8e8ff7f79697ab6db2f8","modified":1543650193616},{"_id":"source/about/index.md","hash":"54ffc05e694cda8607487a0e1d05bf38fbd14963","modified":1543303412407},{"_id":"source/archive/index.md","hash":"279ff19668395f5c6b26417da99d2c1f3ecd5886","modified":1543303412408},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1543303412432},{"_id":"source/tags/index.md","hash":"9d558ce28d0d44c3463517088689bbca44bbb364","modified":1543303412436},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1543303412437},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1543303412437},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1543303412438},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1543303412438},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1543303412438},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1543303412438},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1543303412438},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1543303412438},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1543303412439},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1543303412439},{"_id":"themes/beantech/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1543303412442},{"_id":"themes/beantech/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1543303412442},{"_id":"themes/beantech/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1543303412442},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1543303412442},{"_id":"themes/beantech/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1543303412443},{"_id":"themes/beantech/layout/page.ejs","hash":"c90797e4394c5cb63c2515109480e766d04e486e","modified":1543303412443},{"_id":"themes/beantech/layout/post.ejs","hash":"2d55684fc539dc281f9e2ec0409f09ea6ca43949","modified":1543303412443},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1543303412443},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/Dispatch-Seq.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1543303412359},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/argument-resolver-result.png","hash":"cd37d456fa0edc6c814db3e9a2cdfe77ebf11fa9","modified":1543303412362},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet/Front-controller-pattern.png","hash":"62befacb5ce536303e605341fc7dbf103172526d","modified":1543303412363},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor/filter-chain.gif","hash":"e9bbc8316a3611e64194628fb5f2d524be1ccf56","modified":1543303412364},{"_id":"source/_posts/2018-09-01-servlet/Servlet-life-cycle.png","hash":"25e5eba2e087ee76504a5ac69e0541dd5f97b020","modified":1543303412370},{"_id":"source/_posts/2018-09-01-servlet/jspToServlet.jpeg","hash":"df8c145eca3f082d95dd99d3e391406f75b7ea21","modified":1543303412371},{"_id":"source/_posts/2018-09-01-servlet/servlet.png","hash":"fcd04673f2b14d367a6c6dd3f97fdb6f8a348476","modified":1543303412371},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921142925583.png","hash":"66ef48b35f6b60d2788ea4aba67dd00b5bc481e3","modified":1543303412372},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921142928480.png","hash":"66ef48b35f6b60d2788ea4aba67dd00b5bc481e3","modified":1543303412372},{"_id":"source/_posts/2018-10-03-spring-ehcache/17110B4350CC5EC51D-20181011233534455.jpeg","hash":"cf45ea68e69cb2fe93b744283c00e6a4f26e1ed4","modified":1543303412377},{"_id":"source/_posts/2018-10-03-spring-ehcache/EHCACHE.png","hash":"c57ac4d44f0068d9bc08c350ad8b40d9603574ec","modified":1543303412378},{"_id":"source/_posts/2018-10-03-spring-ehcache/17110B4350CC5EC51D.jpeg","hash":"cf45ea68e69cb2fe93b744283c00e6a4f26e1ed4","modified":1543303412378},{"_id":"source/_posts/2018-11-25-docker-1/docker-logo.png","hash":"de9a2af4d09e151d367db146df980b33a7fdc63f","modified":1543303412386},{"_id":"source/_posts/2018-11-28-docker-2/docker-permission.png","hash":"51131b8ff5e6726a157e42eb65ea18c2b0ec3942","modified":1543417303447},{"_id":"source/_posts/2018-11-28-docker-2/sudo-docker.png","hash":"581b0ee3bc92733ca6f80f6a54ffab6ad31acf47","modified":1543417296357},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1543303412409},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ipv4.png","hash":"bee74710d25633b4e34472e1ed796ca6ea9c6c60","modified":1543303412358},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ipv6.png","hash":"b48a91102ad1481ef1d0c7a87ba774a255a1a780","modified":1543303412359},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet/dispatcher-servlet-lifecycle.jpg","hash":"52c983fadcf1cb7a6121885ea13a0944d9b4131f","modified":1543303412363},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/Exception-Class.png","hash":"97084943599629350623ab0ef20e32d22ced4500","modified":1543303412366},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor/spring-request-lifecycle.jpg","hash":"45c54cf5ba571c2061920fa1222af49a4520cb32","modified":1543303412365},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/spring-mvc-request.jpg","hash":"45c54cf5ba571c2061920fa1222af49a4520cb32","modified":1543303412368},{"_id":"source/_posts/2018-08-29-java-exception/Exception-Class.png","hash":"97084943599629350623ab0ef20e32d22ced4500","modified":1543303412370},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921143924788.png","hash":"bca18bb1036005442c3ca623245d2419b1863a9f","modified":1543303412373},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921145310488.png","hash":"a81cb156dfd22d05f43af23f97fac1da7c27356f","modified":1543303412374},{"_id":"source/_posts/2018-10-21-spring-context/99A34C3359FEAA8410.png","hash":"cb676e0e077ede3f019018de47abe2e4e5ecfc4d","modified":1543303412381},{"_id":"source/_posts/2018-10-03-spring-ehcache/ehcache-test.png","hash":"74382a7c336c655f52b0d2e6228ebc592f366772","modified":1543303412378},{"_id":"source/_posts/2018-11-28-docker-2/image-layer.png","hash":"02393659e78c4a5526e707f9a10797c7f2f77cb3","modified":1543418106520},{"_id":"source/_posts/2018-11-25-docker-1/vm-vs-docker.png","hash":"dbf080e55157d1c9ab8cca4939b9d2b3dd788e9b","modified":1543303412393},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1543303412414},{"_id":"source/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1543303412433},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"c31863b1fa66fd915bc4913440be6c610d12af80","modified":1543303412439},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"3542d15bdf73aa59f05f566b7ecd2255e83ee370","modified":1543303412439},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"aafb744601042f0270d2e6595129ac8a73ad2608","modified":1543303412440},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1543303412440},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1543303412440},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1543303412440},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1543303412440},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1543303412441},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1543303412441},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1543303412441},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1543303412441},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1543303412442},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"3b10bd768f6ef30a42b1703fbc9a88627f9bfdf1","modified":1543303412442},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1543303412444},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1543303412444},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1543303412444},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1543303412446},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1543303412446},{"_id":"themes/beantech/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1543303412447},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1543303412447},{"_id":"themes/beantech/source/css/toc.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1543303412447},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1543303412447},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1543303412447},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1543303412449},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1543303412449},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1543303412449},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1543303412450},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1543303412450},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1543303412451},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1543303412453},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1543303412453},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide setting.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1543303412355},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1543303412453},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1543303412453},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921153027741.png","hash":"b3ff77f45cfabe97517baee545932baf63ae11dd","modified":1543303412375},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1543303412436},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1543303412414},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1543303412446},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1543303412448},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1543303412450},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543303412452},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide설정.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1543303412357},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide-setting.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1543303412356},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/image-20180831235454808.png","hash":"752c481b2880b9ff4af53dc1f2ee4a2b0306528e","modified":1543303412368},{"_id":"source/_posts/2018-11-28-docker-2/redis-versions.png","hash":"1d272b044ddb91ca4661553b0a3d43fffc4354dd","modified":1543417789481},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1543303412407},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1543303412431},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1543303412435},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1543303412445},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1543303412446},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1543303412446},{"_id":"source/_posts/2018-11-28-docker-2/docker-hub.png","hash":"1ff9c745f8651f651c2f83529af792b4851689fc","modified":1543417686121},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1543303412405},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1543303412452},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/image-20180831234615081.png","hash":"c80e8087b73e4f149b9ab607a76187a6fc9fdf17","modified":1543303412367},{"_id":"source/_posts/2018-10-03-spring-ehcache/test-result.png","hash":"fbede59e379c89cf5c6630de0e22779923a59af2","modified":1543303412380},{"_id":"source/_posts/2018-11-25-docker-1/docker-image.png","hash":"3bd173b53ce8a8491633389df24444f0cd0fe579","modified":1543303412386},{"_id":"source/_posts/2018-09-21-spring-ioc-2/containers.jpg","hash":"b51257292a3497e4adcdf5560a7f09f7f1a8b5a6","modified":1543303412377},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/RequestMappingHandlerAdapter.png","hash":"71751889b49d402fe29355c7ea9bb172ead4b95c","modified":1543303412362},{"_id":"source/_posts/2018-11-25-docker-1/docking-image.png","hash":"6b64b14f241d12e7e2b9d9dd24bfff05af593a95","modified":1543303412392},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1543303412412},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1543303412430},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1543303412427},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1543303412403},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1543303412423},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1543303412419},{"_id":"public/post-sitemap.xml","hash":"d6da59c4caff2e1aee1808884bde97552340ae4d","modified":1543650206540},{"_id":"public/page-sitemap.xml","hash":"b1c68e28fd7ec15023b481a6f85d9be8919df7ec","modified":1543650206735},{"_id":"public/tag-sitemap.xml","hash":"86c6238aba39bf3095f4530ce2d17c1717288d42","modified":1543650206777},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1543650206782},{"_id":"public/sitemap.xml","hash":"f0c59e4cd6acead8c3075889f6258713b99de425","modified":1543650206782},{"_id":"public/404.html","hash":"662d7cb0a2cda6601a908a642cff1df53a5fbc0a","modified":1543650206796},{"_id":"public/tags/index.html","hash":"9c7217cee055fb0aac53f328008dc2dc40bbe29a","modified":1543650206798},{"_id":"public/2018/11/28/2018-11-28-docker-2/index.html","hash":"c7bc727b14deed039ed1f1d22b0dfd07c3d39b36","modified":1543650206799},{"_id":"public/2018/11/25/2018-11-25-docker-1/index.html","hash":"c9e9f0254995e96b7a5004fabe16f1fcfb95cedb","modified":1543650206799},{"_id":"public/2018/11/25/2018-11-25-spel-expression-2/index.html","hash":"44095675cc5f5f94b8aa251e5bda39107801fcde","modified":1543650206799},{"_id":"public/2018/11/21/2018-11-21-spel-expression/index.html","hash":"c2a80c0fed281ef4fa4fb804dfad2da3e650d47e","modified":1543650206800},{"_id":"public/2018/11/07/2018-11-04-ehcache-config-for-springboot/index.html","hash":"bf8d88973cf7a012a4af21e4e5a0b8fafd5ec9c9","modified":1543650206800},{"_id":"public/2018/11/07/2018-11-04-ehcache-config-for-springframework/index.html","hash":"e6fac164b02271b6f74792eadcd41a62f283f7d9","modified":1543650206800},{"_id":"public/2018/11/07/2018-10-03-spring-ehcache/index.html","hash":"7c317ce71a8a27c86b539f408904f3d12f5a3061","modified":1543650206800},{"_id":"public/2018/10/21/2018-10-21-spring-context/index.html","hash":"4d596d0fe8efb80d633bde0f711a2f9aa8b07b94","modified":1543650206800},{"_id":"public/2018/10/21/2018-10-21-java-config-import/index.html","hash":"460d2b7b16d6764cd0e6ec00a64cccae1092e7da","modified":1543650206800},{"_id":"public/2018/09/22/2018-09-21-spring-ioc-2/index.html","hash":"6d0b01658e522bcf541ca823b6d7d660ad857ff2","modified":1543650206800},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/index.html","hash":"090aa7cdbcc8708af79ccdd8a02e44263ff16be9","modified":1543650206800},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/index.html","hash":"e1c0c182986d9d842bfa85442a9f21b28e689334","modified":1543650206800},{"_id":"public/2018/09/01/2018-09-01-servlet/index.html","hash":"333e2bc4b76f6e0d3c2f2746f2570f81b6e88080","modified":1543650206800},{"_id":"public/2018/08/30/2018-08-29-java-exception/index.html","hash":"6bee31ab81e2819fa16fb1a484ce279878d950e8","modified":1543650206801},{"_id":"public/2018/08/25/2018-08-18-spring-filter-interceptor/index.html","hash":"aa37dc7b6bb611951acea7ac744e163cc461ad13","modified":1543650206801},{"_id":"public/2018/08/11/2018-08-11-spring-dispatcher-servlet/index.html","hash":"46911447f53a82292073ab927a4ad86d08b4ced2","modified":1543650206801},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/index.html","hash":"bea3dcec1d95def9ffcd0b840c87307d43574158","modified":1543650206801},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/index.html","hash":"fb5f6d55c7ad57430b0152d86344a977f2778de9","modified":1543650206801},{"_id":"public/2018/07/24/2018-07-24-spring-aop5/index.html","hash":"c842a37549523074b2470ff1646ec2c77faadf37","modified":1543650206801},{"_id":"public/2018/07/22/2018-07-22-spring-aop4/index.html","hash":"4ddac9583cdefca0306f13ff0686a6817d81bc2c","modified":1543650206801},{"_id":"public/2018/07/21/2018-07-21-spring-aop3/index.html","hash":"7e559d4dc3d2c53815854f841deffbaddf5f15e3","modified":1543650206801},{"_id":"public/2018/07/20/2018-07-20-spring-aop2/index.html","hash":"bf88a82c0f93a1779de41bf94337e04845cadd87","modified":1543650206801},{"_id":"public/2018/07/15/2018-07-15-spring-aop/index.html","hash":"2954a830c9f1f289a3ebf4920140299b3a85e5ac","modified":1543650206801},{"_id":"public/about/index.html","hash":"2e0230942e3dc6784c4c2a68cad15f74fd91a871","modified":1543650206802},{"_id":"public/archive/index.html","hash":"987f7d98bcf8fd5f4d81dcdd6c215c1c45821ca8","modified":1543650206802},{"_id":"public/archives/2/index.html","hash":"a6711df1925513b6f68eb2fd340da95edc9b7fec","modified":1543650206802},{"_id":"public/index.html","hash":"38f1698302b9f74819a4a933fcb6cb0062cfd8fe","modified":1543650206802},{"_id":"public/archives/3/index.html","hash":"ee3f90453bb04c5745da04f7bad40a2c50c32a35","modified":1543650206802},{"_id":"public/archives/index.html","hash":"b565865a2431976b0d48f46f312c48ba97e7edeb","modified":1543650206802},{"_id":"public/archives/archives/2/index.html","hash":"5cadc8707457cada822b3005eafc6003f386ed92","modified":1543650206802},{"_id":"public/archives/archives/3/index.html","hash":"c1dfc7fc2119fcb88fab2d393701ffd5762af12f","modified":1543650206802},{"_id":"public/archives/2018/index.html","hash":"ce0b6848e0a47cbd02498a6011eb3c78f8d86403","modified":1543650206802},{"_id":"public/archives/2018/archives/2/index.html","hash":"1c3be3dcc57d82df450928734029cb941608931a","modified":1543650206802},{"_id":"public/archives/2018/archives/3/index.html","hash":"abd5ec0fdb39f1fc4c2f982ece597d0f891a167d","modified":1543650206802},{"_id":"public/archives/2018/07/index.html","hash":"ee1cdee9cb9c25b47db83520a9b9243003e00b4f","modified":1543650206802},{"_id":"public/archives/2018/08/index.html","hash":"018404347e5106b148db2e69ca5d55778967ea37","modified":1543650206802},{"_id":"public/archives/2018/09/index.html","hash":"8935ab14b1d2d05e79b78dd2e814ad50e2f20437","modified":1543650206803},{"_id":"public/archives/2018/10/index.html","hash":"8294b93c6430da5bb58a233f85c04a50c3fe506d","modified":1543650206803},{"_id":"public/archives/2018/11/index.html","hash":"e27b09d284506e39fc309d935e7b0323333de62a","modified":1543650206803},{"_id":"public/tags/Spring/index.html","hash":"d21fd8a41f03122b76f949df5bdc1ddf9f4cb419","modified":1543650206803},{"_id":"public/tags/Spring/archives/2/index.html","hash":"9d0f289dde1db2f0d51e1675006d6a30d1d7398e","modified":1543650206803},{"_id":"public/tags/Java-Config/index.html","hash":"d35689f5551fcb048f89e17e4005b7df5ba63488","modified":1543650206803},{"_id":"public/tags/WAS/index.html","hash":"56cce56715d9960e251bcc88ed8e3620d7229685","modified":1543650206803},{"_id":"public/tags/Docker/index.html","hash":"f5e9c8cc241c0743ee9090b64b915335db54a5c3","modified":1543650206803},{"_id":"public/tags/Spring-Boot/index.html","hash":"bb8023e3742501175c4e4434c29b1cf3e44e7957","modified":1543650206803},{"_id":"public/tags/EHCache/index.html","hash":"9c71e6d07dc9307c5b22fb4d31c99ebe5e3e9637","modified":1543650206803},{"_id":"public/tags/Spring-Core/index.html","hash":"16f1073e4154934f55f0ba21a94f7d58b1b2dc3a","modified":1543650206803},{"_id":"public/tags/core/index.html","hash":"b15bc0a90a5c41ffe35443b054d67ad7afc13261","modified":1543650206803},{"_id":"public/tags/J2EE/index.html","hash":"167ab8a4cff9737e3d1c6a24ffab1d53acbf0b8c","modified":1543650206803},{"_id":"public/tags/Java/index.html","hash":"74dd2f24f53523ea412685d12d408315c0a8211a","modified":1543650206803},{"_id":"public/tags/SpEL/index.html","hash":"0d6716e17564b51c4c3658a542903c20c46e3d7a","modified":1543650206804},{"_id":"public/2018/12/01/2018-12-01-docker-3/index.html","hash":"ac1f3914df5a29a1b5cf3da19760ee20f5ab4451","modified":1543650206816},{"_id":"public/archives/2018/12/index.html","hash":"6966124d7ce4cc1e7611fe9d58919eeeb9d4b018","modified":1543650206886},{"_id":"public/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1543650206886},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1543650206886},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1543650206886},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1543650206886},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1543650206886},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1543650206886},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1543650206887},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1543650206887},{"_id":"public/2018/10/21/2018-10-21-spring-context/99A34C3359FEAA8410.png","hash":"cb676e0e077ede3f019018de47abe2e4e5ecfc4d","modified":1543650206887},{"_id":"public/2018/11/25/2018-11-25-docker-1/docker-logo.png","hash":"de9a2af4d09e151d367db146df980b33a7fdc63f","modified":1543650206887},{"_id":"public/2018/08/25/2018-08-18-spring-filter-interceptor/filter-chain.gif","hash":"e9bbc8316a3611e64194628fb5f2d524be1ccf56","modified":1543650206887},{"_id":"public/2018/08/11/2018-08-11-spring-dispatcher-servlet/Front-controller-pattern.png","hash":"62befacb5ce536303e605341fc7dbf103172526d","modified":1543650206887},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/Dispatch-Seq.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1543650206887},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/argument-resolver-result.png","hash":"cd37d456fa0edc6c814db3e9a2cdfe77ebf11fa9","modified":1543650206887},{"_id":"public/2018/09/01/2018-09-01-servlet/Servlet-life-cycle.png","hash":"25e5eba2e087ee76504a5ac69e0541dd5f97b020","modified":1543650206887},{"_id":"public/2018/09/01/2018-09-01-servlet/jspToServlet.jpeg","hash":"df8c145eca3f082d95dd99d3e391406f75b7ea21","modified":1543650206888},{"_id":"public/2018/09/01/2018-09-01-servlet/servlet.png","hash":"fcd04673f2b14d367a6c6dd3f97fdb6f8a348476","modified":1543650206888},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921142925583.png","hash":"66ef48b35f6b60d2788ea4aba67dd00b5bc481e3","modified":1543650206888},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921142928480.png","hash":"66ef48b35f6b60d2788ea4aba67dd00b5bc481e3","modified":1543650206888},{"_id":"public/2018/11/07/2018-10-03-spring-ehcache/17110B4350CC5EC51D-20181011233534455.jpeg","hash":"cf45ea68e69cb2fe93b744283c00e6a4f26e1ed4","modified":1543650206888},{"_id":"public/2018/11/07/2018-10-03-spring-ehcache/17110B4350CC5EC51D.jpeg","hash":"cf45ea68e69cb2fe93b744283c00e6a4f26e1ed4","modified":1543650206888},{"_id":"public/2018/11/07/2018-10-03-spring-ehcache/EHCACHE.png","hash":"c57ac4d44f0068d9bc08c350ad8b40d9603574ec","modified":1543650206888},{"_id":"public/2018/11/28/2018-11-28-docker-2/docker-permission.png","hash":"51131b8ff5e6726a157e42eb65ea18c2b0ec3942","modified":1543650206888},{"_id":"public/2018/11/28/2018-11-28-docker-2/sudo-docker.png","hash":"581b0ee3bc92733ca6f80f6a54ffab6ad31acf47","modified":1543650206888},{"_id":"public/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1543650207170},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1543650207170},{"_id":"public/2018/11/25/2018-11-25-docker-1/vm-vs-docker.png","hash":"dbf080e55157d1c9ab8cca4939b9d2b3dd788e9b","modified":1543650207171},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ipv4.png","hash":"bee74710d25633b4e34472e1ed796ca6ea9c6c60","modified":1543650207171},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ipv6.png","hash":"b48a91102ad1481ef1d0c7a87ba774a255a1a780","modified":1543650207171},{"_id":"public/2018/08/30/2018-08-29-java-exception/Exception-Class.png","hash":"97084943599629350623ab0ef20e32d22ced4500","modified":1543650207171},{"_id":"public/2018/08/25/2018-08-18-spring-filter-interceptor/spring-request-lifecycle.jpg","hash":"45c54cf5ba571c2061920fa1222af49a4520cb32","modified":1543650207171},{"_id":"public/2018/08/11/2018-08-11-spring-dispatcher-servlet/dispatcher-servlet-lifecycle.jpg","hash":"52c983fadcf1cb7a6121885ea13a0944d9b4131f","modified":1543650207171},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/Exception-Class.png","hash":"97084943599629350623ab0ef20e32d22ced4500","modified":1543650207171},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/spring-mvc-request.jpg","hash":"45c54cf5ba571c2061920fa1222af49a4520cb32","modified":1543650207171},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921143924788.png","hash":"bca18bb1036005442c3ca623245d2419b1863a9f","modified":1543650207171},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921145310488.png","hash":"a81cb156dfd22d05f43af23f97fac1da7c27356f","modified":1543650207171},{"_id":"public/2018/11/07/2018-10-03-spring-ehcache/ehcache-test.png","hash":"74382a7c336c655f52b0d2e6228ebc592f366772","modified":1543650207171},{"_id":"public/2018/11/28/2018-11-28-docker-2/image-layer.png","hash":"02393659e78c4a5526e707f9a10797c7f2f77cb3","modified":1543650207171},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1543650207178},{"_id":"public/css/highlight.css","hash":"03d1f0a648e9bdf7b1f57d217313cbac5d0c7eb1","modified":1543650207178},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1543650207179},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1543650207179},{"_id":"public/css/toc.css","hash":"2062bf4e5b219654e0d4bf470f5eef1be213da95","modified":1543650207179},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1543650207179},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1543650207179},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1543650207179},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1543650207179},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1543650207179},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1543650207179},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1543650207179},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1543650207179},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ide setting.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1543650207179},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ide설정.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1543650207179},{"_id":"public/2018/08/10/2018-08-10-httprequest-client-ip/ide-setting.png","hash":"8ccef8b0ae531a5945c77c27cfa51bc9d38b4e68","modified":1543650207179},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/image-20180831235454808.png","hash":"752c481b2880b9ff4af53dc1f2ee4a2b0306528e","modified":1543650207179},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1543650207184},{"_id":"public/2018/11/28/2018-11-28-docker-2/redis-versions.png","hash":"1d272b044ddb91ca4661553b0a3d43fffc4354dd","modified":1543650207185},{"_id":"public/2018/11/07/2018-10-03-spring-ehcache/test-result.png","hash":"fbede59e379c89cf5c6630de0e22779923a59af2","modified":1543650207185},{"_id":"public/2018/09/21/2018-09-12-spring-ioc/image-20180921153027741.png","hash":"b3ff77f45cfabe97517baee545932baf63ae11dd","modified":1543650207185},{"_id":"public/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1543650207189},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1543650207189},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1543650207189},{"_id":"public/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1543650207189},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1543650207189},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1543650207195},{"_id":"public/2018/11/28/2018-11-28-docker-2/docker-hub.png","hash":"1ff9c745f8651f651c2f83529af792b4851689fc","modified":1543650207195},{"_id":"public/2018/08/30/2018-08-25-spring-mvc-handle-exception/image-20180831234615081.png","hash":"c80e8087b73e4f149b9ab607a76187a6fc9fdf17","modified":1543650207195},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1543650207199},{"_id":"public/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1543650207202},{"_id":"public/2018/11/25/2018-11-25-docker-1/docker-image.png","hash":"3bd173b53ce8a8491633389df24444f0cd0fe579","modified":1543650207202},{"_id":"public/2018/09/22/2018-09-21-spring-ioc-2/containers.jpg","hash":"b51257292a3497e4adcdf5560a7f09f7f1a8b5a6","modified":1543650207202},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/RequestMappingHandlerAdapter.png","hash":"71751889b49d402fe29355c7ea9bb172ead4b95c","modified":1543650207202},{"_id":"public/2018/11/25/2018-11-25-docker-1/docking-image.png","hash":"6b64b14f241d12e7e2b9d9dd24bfff05af593a95","modified":1543650207205},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1543650207209},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543650207213},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1543650207219},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1543650207223},{"_id":"public/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1543650207228},{"_id":"public/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1543650207232},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1543650207237},{"_id":"public/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1543650207238},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1543650207238},{"_id":"public/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1543650207243}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2018-11-27T07:23:32.352Z","updated":"2018-11-27T07:23:32.352Z","path":"404.html","title":"","comments":1,"_id":"cjp55h5f600004f1tpijnc0by","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T19:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n> 개발 공부 열심히!!\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n> 개발 공부 열심히!!\n","updated":"2018-11-27T07:23:32.407Z","path":"about/index.html","_id":"cjp55h5hz000u4f1tkczu0ndx","content":"<blockquote>\n<p>개발 공부 열심히!!</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>개발 공부 열심히!!</p>\n</blockquote>\n"},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2018-11-27T07:23:32.436Z","updated":"2018-11-27T07:23:32.436Z","path":"tags/index.html","comments":1,"_id":"cjp55h5i0000w4f1ta4co6tc6","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T11:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2018-11-27T07:23:32.408Z","path":"archive/index.html","_id":"cjp55h5i1000y4f1tlzy2rw9j","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"Spring AOP (1)","subtitle":"1. AOP를 사용해야 하는 이유","date":"2018-07-15T13:28:13.000Z","background":"/img/posts/06.jpg","_content":"\n\n\n개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다. \nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.\n\n\n\n# 들어가면서..\n\n\n\n정리하고자 하는 내용\n\n1. AOP를 사용해야하는 이유\n2. AOP에서 사용되는 용어 정리\n3. \u0010Spring AOP\n4. AspectJ\n5. Custom Annotation\n\n\n\n내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.\n\n\n\n# 1. AOP를 사용 해야 하는 이유\n\n## AOP란?\n\n AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.\n\n예를 들어 결제를 담당하는 소스가 있다고 할 때\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n~~~\n\n\n\n위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.\n\n여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.\n\n이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.\n\n그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이 \n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.\n\n\n\nAOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    return response;\n}\n~~~\n\n\n\n~~~java\n@Aspect\n@Component\npublic class PaymentLogAdvisor {\n    \n    @Autowired\n    private PaymentLogRepository paymentLogRepository;\n    \n    @AfterReturning(\"execution(* com.example.payment.doPayment*(..))\", returning=\"paymentResponse\")\n    public void afterPayment(JoinPoint jp, PaymentResponse paymentResponse) {\n        Object[] args = jp.getArgs();\n        if(args.length == 0) {\n            throw new illegalArgumentException(\"argument is none\");\n        }\n        \n        if(!(args[0] instanceof PaymentRequest)) {\n            throw new Exception(\"argument is not PaymentRequest Type\");\n        }\n        \n        PaymentRequest paymentRequest = (PaymentRequest) args[0];\n        \n        //결제 로그 삽입\n        paymentLogRepository.insert(paymentRequest, paymentResponse);\n    }\n}\n~~~\n\n","source":"_posts/2018-07-15-spring-aop.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (1)\"\nsubtitle: \"1. AOP를 사용해야 하는 이유\"\ndate:   2018-07-15 22:28:13 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n\n\n개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다. \nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.\n\n\n\n# 들어가면서..\n\n\n\n정리하고자 하는 내용\n\n1. AOP를 사용해야하는 이유\n2. AOP에서 사용되는 용어 정리\n3. \u0010Spring AOP\n4. AspectJ\n5. Custom Annotation\n\n\n\n내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.\n\n\n\n# 1. AOP를 사용 해야 하는 이유\n\n## AOP란?\n\n AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.\n\n예를 들어 결제를 담당하는 소스가 있다고 할 때\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n~~~\n\n\n\n위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.\n\n여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.\n\n이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.\n\n그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이 \n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.\n\n\n\nAOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    return response;\n}\n~~~\n\n\n\n~~~java\n@Aspect\n@Component\npublic class PaymentLogAdvisor {\n    \n    @Autowired\n    private PaymentLogRepository paymentLogRepository;\n    \n    @AfterReturning(\"execution(* com.example.payment.doPayment*(..))\", returning=\"paymentResponse\")\n    public void afterPayment(JoinPoint jp, PaymentResponse paymentResponse) {\n        Object[] args = jp.getArgs();\n        if(args.length == 0) {\n            throw new illegalArgumentException(\"argument is none\");\n        }\n        \n        if(!(args[0] instanceof PaymentRequest)) {\n            throw new Exception(\"argument is not PaymentRequest Type\");\n        }\n        \n        PaymentRequest paymentRequest = (PaymentRequest) args[0];\n        \n        //결제 로그 삽입\n        paymentLogRepository.insert(paymentRequest, paymentResponse);\n    }\n}\n~~~\n\n","slug":"2018-07-15-spring-aop","published":1,"updated":"2018-11-27T07:23:32.352Z","comments":1,"photos":[],"link":"","_id":"cjp55h5g400014f1tu7ca2kpa","content":"<p>개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다.<br>\nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.</p>\n<h1><span id=\"들어가면서\">들어가면서…</span></h1>\n<p>정리하고자 하는 내용</p>\n<ol>\n<li>AOP를 사용해야하는 이유</li>\n<li>AOP에서 사용되는 용어 정리</li>\n<li>\u0010Spring AOP</li>\n<li>AspectJ</li>\n<li>Custom Annotation</li>\n</ol>\n<p>내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.</p>\n<h1><span id=\"1-aop를-사용-해야-하는-이유\">1. AOP를 사용 해야 하는 이유</span></h1>\n<h2><span id=\"aop란\">AOP란?</span></h2>\n<p>AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.<br>\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.<br>\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.</p>\n<p>예를 들어 결제를 담당하는 소스가 있다고 할 때</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.<br>\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.<br>\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.</p>\n<p>여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.<br>\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.</p>\n<p>이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.</p>\n<p>그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이<br>\n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.</p>\n<p>AOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PaymentLogAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PaymentLogRepository paymentLogRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning</span>(<span class=\"string\">\"execution(* com.example.payment.doPayment*(..))\"</span>, returning=<span class=\"string\">\"paymentResponse\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPayment</span><span class=\"params\">(JoinPoint jp, PaymentResponse paymentResponse)</span> </span>&#123;</span><br><span class=\"line\">        Object[] args = jp.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> illegalArgumentException(<span class=\"string\">\"argument is none\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(args[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> PaymentRequest)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"argument is not PaymentRequest Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        PaymentRequest paymentRequest = (PaymentRequest) args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//결제 로그 삽입</span></span><br><span class=\"line\">        paymentLogRepository.insert(paymentRequest, paymentResponse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다.<br>\nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.</p>\n<h1>들어가면서…</h1>\n<p>정리하고자 하는 내용</p>\n<ol>\n<li>AOP를 사용해야하는 이유</li>\n<li>AOP에서 사용되는 용어 정리</li>\n<li>\u0010Spring AOP</li>\n<li>AspectJ</li>\n<li>Custom Annotation</li>\n</ol>\n<p>내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.</p>\n<h1>1. AOP를 사용 해야 하는 이유</h1>\n<h2>AOP란?</h2>\n<p>AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.<br>\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.<br>\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.</p>\n<p>예를 들어 결제를 담당하는 소스가 있다고 할 때</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.<br>\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.<br>\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.</p>\n<p>여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.<br>\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.</p>\n<p>이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.</p>\n<p>그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이<br>\n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.</p>\n<p>AOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PaymentLogAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PaymentLogRepository paymentLogRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning</span>(<span class=\"string\">\"execution(* com.example.payment.doPayment*(..))\"</span>, returning=<span class=\"string\">\"paymentResponse\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPayment</span><span class=\"params\">(JoinPoint jp, PaymentResponse paymentResponse)</span> </span>&#123;</span><br><span class=\"line\">        Object[] args = jp.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> illegalArgumentException(<span class=\"string\">\"argument is none\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(args[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> PaymentRequest)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"argument is not PaymentRequest Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        PaymentRequest paymentRequest = (PaymentRequest) args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//결제 로그 삽입</span></span><br><span class=\"line\">        paymentLogRepository.insert(paymentRequest, paymentResponse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"Spring AOP (2)","subtitle":"2. AOP에서 사용되는 용어 정리","date":"2018-07-20T14:06:13.000Z","background":"/img/posts/06.jpg","_content":"\n앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.\n\n여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.\n\n\n\n# AOP(Aspect Oriented Programming) 란?\n\n## AOP의 등장배경\n\n AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.  \n\n 수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.\n\n 하지만 객체지향 프로그래밍 방식에도 헛점은 있었다. \n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. `횡단 관심사 (CrossCutting Concerns)`이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.\n\n\n\n## AOP의 개념\n\n 실제 핵심 로직(Core Concern)을 수행하면서 발생하는 `횡단 관심사 (CrossCutting Concerns)` 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.\n\n![횡단관심사와 핵심로직](https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png)\n\nAOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.\n\nAOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다. \nAspect를 정의 하자면, \n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다. \n\n이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.\n\n\n\n# AOP 에서 사용되는 용어들\n\n## Join Point\n\n말그대로 Join + Point이다. `횡단관심사(Cross Cutting Concern)` 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.\n\n## Advice\n\n`횡단관심사(Cross Cutting Concern)` 으로 분리 된 로직에 대한 코드\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어\n\n## Point Cut\n\n말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어\n\n## Weaving\n\nAdvice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.\n방법에 따라 \n* 런타임 시, Proxy로 생성하며 코드를 합치는 방법\n* 컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법\n이 있다.\n\n## Aspect\n\n여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.\n보안, 트랜잭션, 로깅등이 대표적인 예이다.\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.\n\n## Target\n\n핵심 로직을 구현하는 클래스 또는 객체\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.\n\n## Advisor\n\nAdvice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.\n\n\n\n------\n\n참고\n\nhttps://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttp://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106","source":"_posts/2018-07-20-spring-aop2.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (2)\"\nsubtitle: \"2. AOP에서 사용되는 용어 정리\"\ndate:   2018-07-20 23:06:13 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.\n\n여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.\n\n\n\n# AOP(Aspect Oriented Programming) 란?\n\n## AOP의 등장배경\n\n AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.  \n\n 수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.\n\n 하지만 객체지향 프로그래밍 방식에도 헛점은 있었다. \n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. `횡단 관심사 (CrossCutting Concerns)`이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.\n\n\n\n## AOP의 개념\n\n 실제 핵심 로직(Core Concern)을 수행하면서 발생하는 `횡단 관심사 (CrossCutting Concerns)` 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.\n\n![횡단관심사와 핵심로직](https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png)\n\nAOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.\n\nAOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다. \nAspect를 정의 하자면, \n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다. \n\n이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.\n\n\n\n# AOP 에서 사용되는 용어들\n\n## Join Point\n\n말그대로 Join + Point이다. `횡단관심사(Cross Cutting Concern)` 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.\n\n## Advice\n\n`횡단관심사(Cross Cutting Concern)` 으로 분리 된 로직에 대한 코드\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어\n\n## Point Cut\n\n말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어\n\n## Weaving\n\nAdvice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.\n방법에 따라 \n* 런타임 시, Proxy로 생성하며 코드를 합치는 방법\n* 컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법\n이 있다.\n\n## Aspect\n\n여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.\n보안, 트랜잭션, 로깅등이 대표적인 예이다.\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.\n\n## Target\n\n핵심 로직을 구현하는 클래스 또는 객체\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.\n\n## Advisor\n\nAdvice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.\n\n\n\n------\n\n참고\n\nhttps://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttp://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106","slug":"2018-07-20-spring-aop2","published":1,"updated":"2018-11-27T07:23:32.353Z","comments":1,"photos":[],"link":"","_id":"cjp55h5g900024f1twyupnofe","content":"<p>앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.</p>\n<p>여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.</p>\n<h1><span id=\"aopaspect-oriented-programming-란\">AOP(Aspect Oriented Programming) 란?</span></h1>\n<h2><span id=\"aop의-등장배경\">AOP의 등장배경</span></h2>\n<p>AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.</p>\n<p>수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.</p>\n<p>하지만 객체지향 프로그래밍 방식에도 헛점은 있었다.<br>\n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. <code>횡단 관심사 (CrossCutting Concerns)</code>이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.</p>\n<h2><span id=\"aop의-개념\">AOP의 개념</span></h2>\n<p>실제 핵심 로직(Core Concern)을 수행하면서 발생하는 <code>횡단 관심사 (CrossCutting Concerns)</code> 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.</p>\n<p><img src=\"https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png\" alt=\"횡단관심사와 핵심로직\"></p>\n<p>AOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.</p>\n<p>AOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다.<br>\nAspect를 정의 하자면,<br>\n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다.</p>\n<p>이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.<br>\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.</p>\n<h1><span id=\"aop-에서-사용되는-용어들\">AOP 에서 사용되는 용어들</span></h1>\n<h2><span id=\"join-point\">Join Point</span></h2>\n<p>말그대로 Join + Point이다. <code>횡단관심사(Cross Cutting Concern)</code> 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.</p>\n<h2><span id=\"advice\">Advice</span></h2>\n<p><code>횡단관심사(Cross Cutting Concern)</code> 으로 분리 된 로직에 대한 코드<br>\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어</p>\n<h2><span id=\"point-cut\">Point Cut</span></h2>\n<p>말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,<br>\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어</p>\n<h2><span id=\"weaving\">Weaving</span></h2>\n<p>Advice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.<br>\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.<br>\n방법에 따라</p>\n<ul>\n<li>런타임 시, Proxy로 생성하며 코드를 합치는 방법</li>\n<li>컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법<br>\n이 있다.</li>\n</ul>\n<h2><span id=\"aspect\">Aspect</span></h2>\n<p>여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.<br>\n보안, 트랜잭션, 로깅등이 대표적인 예이다.<br>\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.</p>\n<h2><span id=\"target\">Target</span></h2>\n<p>핵심 로직을 구현하는 클래스 또는 객체<br>\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.</p>\n<h2><span id=\"advisor\">Advisor</span></h2>\n<p>Advice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.<br>\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.</p>\n<hr>\n<p>참고</p>\n<p><a href=\"https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop의-등장-배경</a></p>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p>\n<p><a href=\"http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106\" target=\"_blank\" rel=\"noopener\">http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.</p>\n<p>여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.</p>\n<h1>AOP(Aspect Oriented Programming) 란?</h1>\n<h2>AOP의 등장배경</h2>\n<p>AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.</p>\n<p>수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.</p>\n<p>하지만 객체지향 프로그래밍 방식에도 헛점은 있었다.<br>\n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. <code>횡단 관심사 (CrossCutting Concerns)</code>이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.</p>\n<h2>AOP의 개념</h2>\n<p>실제 핵심 로직(Core Concern)을 수행하면서 발생하는 <code>횡단 관심사 (CrossCutting Concerns)</code> 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.</p>\n<p><img src=\"https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png\" alt=\"횡단관심사와 핵심로직\"></p>\n<p>AOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.</p>\n<p>AOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다.<br>\nAspect를 정의 하자면,<br>\n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다.</p>\n<p>이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.<br>\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.</p>\n<h1>AOP 에서 사용되는 용어들</h1>\n<h2>Join Point</h2>\n<p>말그대로 Join + Point이다. <code>횡단관심사(Cross Cutting Concern)</code> 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.</p>\n<h2>Advice</h2>\n<p><code>횡단관심사(Cross Cutting Concern)</code> 으로 분리 된 로직에 대한 코드<br>\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어</p>\n<h2>Point Cut</h2>\n<p>말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,<br>\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어</p>\n<h2>Weaving</h2>\n<p>Advice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.<br>\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.<br>\n방법에 따라</p>\n<ul>\n<li>런타임 시, Proxy로 생성하며 코드를 합치는 방법</li>\n<li>컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법<br>\n이 있다.</li>\n</ul>\n<h2>Aspect</h2>\n<p>여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.<br>\n보안, 트랜잭션, 로깅등이 대표적인 예이다.<br>\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.</p>\n<h2>Target</h2>\n<p>핵심 로직을 구현하는 클래스 또는 객체<br>\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.</p>\n<h2>Advisor</h2>\n<p>Advice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.<br>\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.</p>\n<hr>\n<p>참고</p>\n<p><a href=\"https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop의-등장-배경</a></p>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p>\n<p><a href=\"http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106\" target=\"_blank\" rel=\"noopener\">http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106</a></p>\n"},{"title":"Spring에서 Client IP구하기","catalog":true,"date":"2018-08-10T13:24:23.000Z","subtitle":null,"header-img":null,"typora-root-url":"./2018-08-10-httprequest-client-ip","typora-copy-images-to":"./2018-08-10-httprequest-client-ip","_content":"\n\n\n# HttpServletRequest에서 IP 구하기\n\n회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다. \n\n생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.\n\nHttpServletRequest에서 IP를 구하는 소스는 아래와 같다.\n\n이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 ([Spring Argument Resolver](https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/))\n\n~~~java\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            //Proxy 서버인 경우\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            //Weblogic 서버인 경우\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n~~~\n\n\n\n보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.\n구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.\n\n\n\n\n\n# IPv6 형식으로 나오는 IP를 IPv4로 변환\n\n위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.\n\n![ipv6](./ipv6.png)\n\n \n\n예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다. \n\n\n IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.\n\n1. Tomcat인 경우\n   1. $CATALINA_HOME\\bin\\catalina.bat(.sh) 을 찾는다.\n   2. `:noJuliConfig, :noJuliManager` 를 검색한다. \n   3. JAVA_OPTS에 `-Djava.net.preferIPv4Stack=true` 를 추가한다.\n\n~~~shell\nif not \"%LOGGING_CONFIG%\" == \"\" goto noJuliConfig\nset LOGGING_CONFIG=-Dnop\nif not exist \"%CATALINA_BASE%\\conf\\logging.properties\" goto noJuliConfig\nset LOGGING_CONFIG=-Djava.util.logging.config.file=\"%CATALINA_BASE%\\conf\\logging.properties\"\n:noJuliConfig\nset JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true\n\nif not \"%LOGGING_MANAGER%\" == \"\" goto noJuliManager\nset LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager\n:noJuliManager\nset JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true\n~~~\n\n\n\n2. 개발 환경에서 VM 속성 추가 하기\n   1. 사용 중인 IDE에서 VM Options에 `-Djava.net.preferIPv4Stack=true` 를 추가한다.\n\n![ide-setting](./ide-setting.png)\n\n\n\n확인 결과\n\n![ipv4](./ipv4.png)\n\n\n\n127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.\n\n\n\n# 참고\n\nhttp://all-record.tistory.com/168\nhttp://www.leafcats.com/35\nhttp://ooz.co.kr/138","source":"_posts/2018-08-10-httprequest-client-ip.md","raw":"---\ntitle: Spring에서 Client IP구하기\ncatalog: true\ndate: 2018-08-10 22:24:23\nsubtitle:\nheader-img:\ntags: Spring\ntypora-root-url: ./2018-08-10-httprequest-client-ip\ntypora-copy-images-to: ./2018-08-10-httprequest-client-ip\n---\n\n\n\n# HttpServletRequest에서 IP 구하기\n\n회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다. \n\n생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.\n\nHttpServletRequest에서 IP를 구하는 소스는 아래와 같다.\n\n이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 ([Spring Argument Resolver](https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/))\n\n~~~java\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            //Proxy 서버인 경우\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            //Weblogic 서버인 경우\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n~~~\n\n\n\n보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.\n구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.\n\n\n\n\n\n# IPv6 형식으로 나오는 IP를 IPv4로 변환\n\n위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.\n\n![ipv6](./ipv6.png)\n\n \n\n예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다. \n\n\n IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.\n\n1. Tomcat인 경우\n   1. $CATALINA_HOME\\bin\\catalina.bat(.sh) 을 찾는다.\n   2. `:noJuliConfig, :noJuliManager` 를 검색한다. \n   3. JAVA_OPTS에 `-Djava.net.preferIPv4Stack=true` 를 추가한다.\n\n~~~shell\nif not \"%LOGGING_CONFIG%\" == \"\" goto noJuliConfig\nset LOGGING_CONFIG=-Dnop\nif not exist \"%CATALINA_BASE%\\conf\\logging.properties\" goto noJuliConfig\nset LOGGING_CONFIG=-Djava.util.logging.config.file=\"%CATALINA_BASE%\\conf\\logging.properties\"\n:noJuliConfig\nset JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true\n\nif not \"%LOGGING_MANAGER%\" == \"\" goto noJuliManager\nset LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager\n:noJuliManager\nset JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true\n~~~\n\n\n\n2. 개발 환경에서 VM 속성 추가 하기\n   1. 사용 중인 IDE에서 VM Options에 `-Djava.net.preferIPv4Stack=true` 를 추가한다.\n\n![ide-setting](./ide-setting.png)\n\n\n\n확인 결과\n\n![ipv4](./ipv4.png)\n\n\n\n127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.\n\n\n\n# 참고\n\nhttp://all-record.tistory.com/168\nhttp://www.leafcats.com/35\nhttp://ooz.co.kr/138","slug":"2018-08-10-httprequest-client-ip","published":1,"updated":"2018-11-27T07:23:32.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp55h5gb00034f1tthlp6kqb","content":"<h1><span id=\"httpservletrequest에서-ip-구하기\">HttpServletRequest에서 IP 구하기</span></h1>\n<p>회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다.</p>\n<p>생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.</p>\n<p>HttpServletRequest에서 IP를 구하는 소스는 아래와 같다.</p>\n<p>이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 (<a href=\"https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/\" target=\"_blank\" rel=\"noopener\">Spring Argument Resolver</a>)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Proxy 서버인 경우</span></span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Weblogic 서버인 경우</span></span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getRemoteAddr();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.<br>\n구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.</p>\n<h1><span id=\"ipv6-형식으로-나오는-ip를-ipv4로-변환\">IPv6 형식으로 나오는 IP를 IPv4로 변환</span></h1>\n<p>위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.</p>\n<p><img src=\"./ipv6.png\" alt=\"ipv6\"></p>\n<p>예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다.</p>\n<p>IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.</p>\n<ol>\n<li>Tomcat인 경우\n<ol>\n<li>$CATALINA_HOME\\bin\\catalina.bat(.sh) 을 찾는다.</li>\n<li><code>:noJuliConfig, :noJuliManager</code> 를 검색한다.</li>\n<li>JAVA_OPTS에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if not \"%LOGGING_CONFIG%\" == \"\" goto noJuliConfig</span><br><span class=\"line\">set LOGGING_CONFIG=-Dnop</span><br><span class=\"line\">if not exist \"%CATALINA_BASE%\\conf\\logging.properties\" goto noJuliConfig</span><br><span class=\"line\">set LOGGING_CONFIG=-Djava.util.logging.config.file=\"%CATALINA_BASE%\\conf\\logging.properties\"</span><br><span class=\"line\">:noJuliConfig</span><br><span class=\"line\">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true</span><br><span class=\"line\"></span><br><span class=\"line\">if not \"%LOGGING_MANAGER%\" == \"\" goto noJuliManager</span><br><span class=\"line\">set LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class=\"line\">:noJuliManager</span><br><span class=\"line\">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>개발 환경에서 VM 속성 추가 하기\n<ol>\n<li>사용 중인 IDE에서 VM Options에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"./ide-setting.png\" alt=\"ide-setting\"></p>\n<p>확인 결과</p>\n<p><img src=\"./ipv4.png\" alt=\"ipv4\"></p>\n<p>127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.</p>\n<h1><span id=\"참고\">참고</span></h1>\n<p><a href=\"http://all-record.tistory.com/168\" target=\"_blank\" rel=\"noopener\">http://all-record.tistory.com/168</a><br>\n<a href=\"http://www.leafcats.com/35\" target=\"_blank\" rel=\"noopener\">http://www.leafcats.com/35</a><br>\n<a href=\"http://ooz.co.kr/138\" target=\"_blank\" rel=\"noopener\">http://ooz.co.kr/138</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>HttpServletRequest에서 IP 구하기</h1>\n<p>회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다.</p>\n<p>생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.</p>\n<p>HttpServletRequest에서 IP를 구하는 소스는 아래와 같다.</p>\n<p>이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 (<a href=\"https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/\" target=\"_blank\" rel=\"noopener\">Spring Argument Resolver</a>)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Proxy 서버인 경우</span></span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Weblogic 서버인 경우</span></span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">        clientIp = request.getRemoteAddr();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.<br>\n구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.</p>\n<h1>IPv6 형식으로 나오는 IP를 IPv4로 변환</h1>\n<p>위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.</p>\n<p><img src=\"./ipv6.png\" alt=\"ipv6\"></p>\n<p>예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다.</p>\n<p>IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.</p>\n<ol>\n<li>Tomcat인 경우\n<ol>\n<li>$CATALINA_HOME\\bin\\catalina.bat(.sh) 을 찾는다.</li>\n<li><code>:noJuliConfig, :noJuliManager</code> 를 검색한다.</li>\n<li>JAVA_OPTS에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if not \"%LOGGING_CONFIG%\" == \"\" goto noJuliConfig</span><br><span class=\"line\">set LOGGING_CONFIG=-Dnop</span><br><span class=\"line\">if not exist \"%CATALINA_BASE%\\conf\\logging.properties\" goto noJuliConfig</span><br><span class=\"line\">set LOGGING_CONFIG=-Djava.util.logging.config.file=\"%CATALINA_BASE%\\conf\\logging.properties\"</span><br><span class=\"line\">:noJuliConfig</span><br><span class=\"line\">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true</span><br><span class=\"line\"></span><br><span class=\"line\">if not \"%LOGGING_MANAGER%\" == \"\" goto noJuliManager</span><br><span class=\"line\">set LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class=\"line\">:noJuliManager</span><br><span class=\"line\">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>개발 환경에서 VM 속성 추가 하기\n<ol>\n<li>사용 중인 IDE에서 VM Options에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"./ide-setting.png\" alt=\"ide-setting\"></p>\n<p>확인 결과</p>\n<p><img src=\"./ipv4.png\" alt=\"ipv4\"></p>\n<p>127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.</p>\n<h1>참고</h1>\n<p><a href=\"http://all-record.tistory.com/168\" target=\"_blank\" rel=\"noopener\">http://all-record.tistory.com/168</a><br>\n<a href=\"http://www.leafcats.com/35\" target=\"_blank\" rel=\"noopener\">http://www.leafcats.com/35</a><br>\n<a href=\"http://ooz.co.kr/138\" target=\"_blank\" rel=\"noopener\">http://ooz.co.kr/138</a></p>\n"},{"layout":"post","title":"Spring AOP (5)","subtitle":"5. Custom Annotation Pointcut","date":"2018-07-24T14:14:33.000Z","background":"/img/posts/06.jpg","_content":"\n\n\nAOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.\n아래의 리뷰와 같다.\n\n![AOP코드리뷰](/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP코드리뷰.png)\n\n메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.\n\n이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.\n\n\n\n# Custom Annotation\n\nAPI에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.\n\n\n\n## Annotation 생성하기\n\n~~~java\nimport java.lang.annotation.*;\n\n@Inherited  //Annotation의 상속이 가능함 \n@Documented //JavaDoc 문서 추가 가능\n@Retention(RetentionPolicy.RUNTIME) // 컴파일 이후에도 JVM에 의해서 참조가 가능\n//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효\n//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)\n@Target({\n        ElementType.PACKAGE,         // 패키지 선언시\n        ElementType.TYPE,            // 타입 선언시\n        ElementType.CONSTRUCTOR,     // 생성자 선언시\n        ElementType.FIELD,           // 멤버 변수 선언시\n        ElementType.METHOD,          // 메소드 선언시\n        ElementType.ANNOTATION_TYPE, // 어노테이션 타입 선언시\n        ElementType.LOCAL_VARIABLE,  // 지역 변수 선언시\n        ElementType.PARAMETER,       // 매개 변수 선언시\n        ElementType.TYPE_PARAMETER,  // 매개 변수 타입 선언시\n        ElementType.TYPE_USE         // 타입 사용시\n})\npublic @interface CustomAnnotation {  //interface에 @를 붙여주면 Annotation으로 등록\n    /* enum 타입을 선언할 수 있습니다. */\n    public enum Quality {BAD, GOOD, VERYGOOD}\n    /* String은 기본 자료형은 아니지만 사용 가능합니다. */\n    String value();\n    /* 배열 형태로도 사용할 수 있습니다. */\n    int[] values();\n    /* enum 형태를 사용하는 방법입니다. */\n    Quality quality() default Quality.GOOD;\n}\n~~~\n\n\n\n## Annotation Pointcut 지정하기\n\n예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.\n\n~~~java\npackage com.example.aopexam;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.ComponentScan;\n\n@SpringBootApplication\n//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능\n@ComponentScan(value={\"com.example.aopexam\", \"com.example.custom.annotation\"})\npublic class AopExamApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AopExamApplication.class, args);\n    }\n}\n\n~~~\n\n~~~java\npackage com.example.aopexam;\n\nimport com.example.custom.annotation.CustomLog;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api/aop-test\")\npublic class ApiController {\n\n    @Autowired\n    private ApiService apiService;\n\n    @GetMapping\n    @CustomLog //get 메소드에 @CustomLog추가\n    public void getTest() {\n        apiService.method(ApiType.GET);\n    }\n\n    @PostMapping\n    public void postTest() {\n        apiService.method(ApiType.POST);\n    }\n\n    @PutMapping\n    public void putTest() {\n        apiService.method(ApiType.PUT);\n    }\n\n    @DeleteMapping\n    public void deleteTest() {\n        apiService.method(ApiType.DELETE);\n    }\n\n}\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD) //메소드 어노테이션 적용\npublic @interface CustomLog {\n}\n\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@EnableAspectJAutoProxy(proxyTargetClass = true) //cglib 사용 -> class기반 proxy생성\n@Component\npublic class CustomLogAdvisor {\n\n    //Annotation을 기준으로 pointcut설정\n    @Pointcut(\"@annotation(com.example.custom.annotation.CustomLog)\")\n    public void customLogPointcut() {\n    }\n\n    @Before(value=\"customLogPointcut()\")\n    public void pringLog() {\n        System.out.println(\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\");\n    }\n}\n~~~\n\n~~~log\nhttp://localhost:8080/api/aop-test\n\n메소드 실행 전 무조건 이 로그를 보게 될 것이야...\n[ApiService.method] apiType : GET\n~~~\n\n","source":"_posts/2018-07-24-spring-aop5.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (5)\"\nsubtitle: \"5. Custom Annotation Pointcut\"\ndate:   2018-07-24 23:14:33 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n\n\nAOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.\n아래의 리뷰와 같다.\n\n![AOP코드리뷰](/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP코드리뷰.png)\n\n메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.\n\n이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.\n\n\n\n# Custom Annotation\n\nAPI에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.\n\n\n\n## Annotation 생성하기\n\n~~~java\nimport java.lang.annotation.*;\n\n@Inherited  //Annotation의 상속이 가능함 \n@Documented //JavaDoc 문서 추가 가능\n@Retention(RetentionPolicy.RUNTIME) // 컴파일 이후에도 JVM에 의해서 참조가 가능\n//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효\n//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)\n@Target({\n        ElementType.PACKAGE,         // 패키지 선언시\n        ElementType.TYPE,            // 타입 선언시\n        ElementType.CONSTRUCTOR,     // 생성자 선언시\n        ElementType.FIELD,           // 멤버 변수 선언시\n        ElementType.METHOD,          // 메소드 선언시\n        ElementType.ANNOTATION_TYPE, // 어노테이션 타입 선언시\n        ElementType.LOCAL_VARIABLE,  // 지역 변수 선언시\n        ElementType.PARAMETER,       // 매개 변수 선언시\n        ElementType.TYPE_PARAMETER,  // 매개 변수 타입 선언시\n        ElementType.TYPE_USE         // 타입 사용시\n})\npublic @interface CustomAnnotation {  //interface에 @를 붙여주면 Annotation으로 등록\n    /* enum 타입을 선언할 수 있습니다. */\n    public enum Quality {BAD, GOOD, VERYGOOD}\n    /* String은 기본 자료형은 아니지만 사용 가능합니다. */\n    String value();\n    /* 배열 형태로도 사용할 수 있습니다. */\n    int[] values();\n    /* enum 형태를 사용하는 방법입니다. */\n    Quality quality() default Quality.GOOD;\n}\n~~~\n\n\n\n## Annotation Pointcut 지정하기\n\n예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.\n\n~~~java\npackage com.example.aopexam;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.ComponentScan;\n\n@SpringBootApplication\n//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능\n@ComponentScan(value={\"com.example.aopexam\", \"com.example.custom.annotation\"})\npublic class AopExamApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AopExamApplication.class, args);\n    }\n}\n\n~~~\n\n~~~java\npackage com.example.aopexam;\n\nimport com.example.custom.annotation.CustomLog;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api/aop-test\")\npublic class ApiController {\n\n    @Autowired\n    private ApiService apiService;\n\n    @GetMapping\n    @CustomLog //get 메소드에 @CustomLog추가\n    public void getTest() {\n        apiService.method(ApiType.GET);\n    }\n\n    @PostMapping\n    public void postTest() {\n        apiService.method(ApiType.POST);\n    }\n\n    @PutMapping\n    public void putTest() {\n        apiService.method(ApiType.PUT);\n    }\n\n    @DeleteMapping\n    public void deleteTest() {\n        apiService.method(ApiType.DELETE);\n    }\n\n}\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD) //메소드 어노테이션 적용\npublic @interface CustomLog {\n}\n\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@EnableAspectJAutoProxy(proxyTargetClass = true) //cglib 사용 -> class기반 proxy생성\n@Component\npublic class CustomLogAdvisor {\n\n    //Annotation을 기준으로 pointcut설정\n    @Pointcut(\"@annotation(com.example.custom.annotation.CustomLog)\")\n    public void customLogPointcut() {\n    }\n\n    @Before(value=\"customLogPointcut()\")\n    public void pringLog() {\n        System.out.println(\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\");\n    }\n}\n~~~\n\n~~~log\nhttp://localhost:8080/api/aop-test\n\n메소드 실행 전 무조건 이 로그를 보게 될 것이야...\n[ApiService.method] apiType : GET\n~~~\n\n","slug":"2018-07-24-spring-aop5","published":1,"updated":"2018-11-27T07:23:32.353Z","comments":1,"photos":[],"link":"","_id":"cjp55h5gc00044f1thl39ha77","content":"<p>AOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.<br>\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.<br>\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.<br>\n아래의 리뷰와 같다.</p>\n<p><img src=\"/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2.png\" alt=\"AOP코드리뷰\"></p>\n<p>메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.</p>\n<p>이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.</p>\n<h1><span id=\"custom-annotation\">Custom Annotation</span></h1>\n<p>API에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.</p>\n<h2><span id=\"annotation-생성하기\">Annotation 생성하기</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span>  <span class=\"comment\">//Annotation의 상속이 가능함 </span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span> <span class=\"comment\">//JavaDoc 문서 추가 가능</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME) <span class=\"comment\">// 컴파일 이후에도 JVM에 의해서 참조가 가능</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;</span><br><span class=\"line\">        ElementType.PACKAGE,         <span class=\"comment\">// 패키지 선언시</span></span><br><span class=\"line\">        ElementType.TYPE,            <span class=\"comment\">// 타입 선언시</span></span><br><span class=\"line\">        ElementType.CONSTRUCTOR,     <span class=\"comment\">// 생성자 선언시</span></span><br><span class=\"line\">        ElementType.FIELD,           <span class=\"comment\">// 멤버 변수 선언시</span></span><br><span class=\"line\">        ElementType.METHOD,          <span class=\"comment\">// 메소드 선언시</span></span><br><span class=\"line\">        ElementType.ANNOTATION_TYPE, <span class=\"comment\">// 어노테이션 타입 선언시</span></span><br><span class=\"line\">        ElementType.LOCAL_VARIABLE,  <span class=\"comment\">// 지역 변수 선언시</span></span><br><span class=\"line\">        ElementType.PARAMETER,       <span class=\"comment\">// 매개 변수 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_PARAMETER,  <span class=\"comment\">// 매개 변수 타입 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_USE         <span class=\"comment\">// 타입 사용시</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomAnnotation &#123;  <span class=\"comment\">//interface에 @를 붙여주면 Annotation으로 등록</span></span><br><span class=\"line\">    <span class=\"comment\">/* enum 타입을 선언할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Quality &#123;BAD, GOOD, VERYGOOD&#125;</span><br><span class=\"line\">    <span class=\"comment\">/* String은 기본 자료형은 아니지만 사용 가능합니다. */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 배열 형태로도 사용할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] values();</span><br><span class=\"line\">    <span class=\"comment\">/* enum 형태를 사용하는 방법입니다. */</span></span><br><span class=\"line\">    <span class=\"function\">Quality <span class=\"title\">quality</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Quality.GOOD</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"annotation-pointcut-지정하기\">Annotation Pointcut 지정하기</span></h2>\n<p>예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(value=&#123;<span class=\"string\">\"com.example.aopexam\"</span>, <span class=\"string\">\"com.example.custom.annotation\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AopExamApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(AopExamApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.custom.annotation.CustomLog;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/api/aop-test\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiService apiService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@CustomLog</span> <span class=\"comment\">//get 메소드에 @CustomLog추가</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.GET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.POST);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.PUT);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.DELETE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.ElementType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD) <span class=\"comment\">//메소드 어노테이션 적용</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomLog &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class=\"keyword\">true</span>) <span class=\"comment\">//cglib 사용 -&gt; class기반 proxy생성</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomLogAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Annotation을 기준으로 pointcut설정</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@annotation(com.example.custom.annotation.CustomLog)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">customLogPointcut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(value=<span class=\"string\">\"customLogPointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pringLog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/api/aop-test</span><br><span class=\"line\"></span><br><span class=\"line\">메소드 실행 전 무조건 이 로그를 보게 될 것이야...</span><br><span class=\"line\">[ApiService.method] apiType : GET</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>AOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.<br>\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.<br>\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.<br>\n아래의 리뷰와 같다.</p>\n<p><img src=\"/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2.png\" alt=\"AOP코드리뷰\"></p>\n<p>메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.</p>\n<p>이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.</p>\n<h1>Custom Annotation</h1>\n<p>API에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.</p>\n<h2>Annotation 생성하기</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span>  <span class=\"comment\">//Annotation의 상속이 가능함 </span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span> <span class=\"comment\">//JavaDoc 문서 추가 가능</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME) <span class=\"comment\">// 컴파일 이후에도 JVM에 의해서 참조가 가능</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;</span><br><span class=\"line\">        ElementType.PACKAGE,         <span class=\"comment\">// 패키지 선언시</span></span><br><span class=\"line\">        ElementType.TYPE,            <span class=\"comment\">// 타입 선언시</span></span><br><span class=\"line\">        ElementType.CONSTRUCTOR,     <span class=\"comment\">// 생성자 선언시</span></span><br><span class=\"line\">        ElementType.FIELD,           <span class=\"comment\">// 멤버 변수 선언시</span></span><br><span class=\"line\">        ElementType.METHOD,          <span class=\"comment\">// 메소드 선언시</span></span><br><span class=\"line\">        ElementType.ANNOTATION_TYPE, <span class=\"comment\">// 어노테이션 타입 선언시</span></span><br><span class=\"line\">        ElementType.LOCAL_VARIABLE,  <span class=\"comment\">// 지역 변수 선언시</span></span><br><span class=\"line\">        ElementType.PARAMETER,       <span class=\"comment\">// 매개 변수 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_PARAMETER,  <span class=\"comment\">// 매개 변수 타입 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_USE         <span class=\"comment\">// 타입 사용시</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomAnnotation &#123;  <span class=\"comment\">//interface에 @를 붙여주면 Annotation으로 등록</span></span><br><span class=\"line\">    <span class=\"comment\">/* enum 타입을 선언할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Quality &#123;BAD, GOOD, VERYGOOD&#125;</span><br><span class=\"line\">    <span class=\"comment\">/* String은 기본 자료형은 아니지만 사용 가능합니다. */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 배열 형태로도 사용할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] values();</span><br><span class=\"line\">    <span class=\"comment\">/* enum 형태를 사용하는 방법입니다. */</span></span><br><span class=\"line\">    <span class=\"function\">Quality <span class=\"title\">quality</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Quality.GOOD</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Annotation Pointcut 지정하기</h2>\n<p>예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(value=&#123;<span class=\"string\">\"com.example.aopexam\"</span>, <span class=\"string\">\"com.example.custom.annotation\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AopExamApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(AopExamApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.custom.annotation.CustomLog;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/api/aop-test\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiService apiService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@CustomLog</span> <span class=\"comment\">//get 메소드에 @CustomLog추가</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.GET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.POST);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.PUT);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.DELETE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.ElementType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD) <span class=\"comment\">//메소드 어노테이션 적용</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomLog &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class=\"keyword\">true</span>) <span class=\"comment\">//cglib 사용 -&gt; class기반 proxy생성</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomLogAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Annotation을 기준으로 pointcut설정</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@annotation(com.example.custom.annotation.CustomLog)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">customLogPointcut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(value=<span class=\"string\">\"customLogPointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pringLog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/api/aop-test</span><br><span class=\"line\"></span><br><span class=\"line\">메소드 실행 전 무조건 이 로그를 보게 될 것이야...</span><br><span class=\"line\">[ApiService.method] apiType : GET</span><br></pre></td></tr></table></figure>\n"},{"layout":"posts","title":"@Import와 @ImportResource Annotation","date":"2018-10-21T09:53:38.000Z","subtitle":"xml을 Java Config로 변경하기","catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-10-21-java-config-import","typora-copy-images-to":"./2018-10-21-java-config-import","_content":"\n\n\n# 들어가며\n\n회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.\n아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고 \n최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.\n그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.\n\n\n\n# @Import\n\n@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.\n사용하는 개념은 기존에 xml 파일을 import하는.. <import /> 구분과 동일하게 사용된다.\n\n예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면..\n\n\n\n**RedisClusterConfig**\n\n~~~java\n@Configuration\n@Import(value = RedisShardsConfig.class) // Redis Shard정보에 대한 Config이다.\npublic class RedisClusterConfig {\n\n\t@Autowired\n\t@Qualifier(\"redisConfig\")\n\tprivate Properties redisConfig;\n\n\t@Bean\n\tpublic GenericObjectPoolConfig jedisPoolConfig() {\n\t\tJedisPoolConfig poolConfig = new JedisPoolConfig();\n\t    poolConfig.setMaxTotal(redisConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setMaxIdle(commonConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setMinIdle(commonConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setNumTestsPerEvictionRun(2);\n\t\tpoolConfig.setTestOnBorrow(true);\n\t\tpoolConfig.setTestOnReturn(false);\n\t\tpoolConfig.setTestWhileIdle(true);\n\t\tpoolConfig.setTimeBetweenEvictionRunsMillis(300000);\n\t\treturn poolConfig;\n\t}\n    \n    //따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.\n\t@Bean\n\tpublic ShardedJedisPool masterShardedPool(GenericObjectPoolConfig jedisPoolConfig, List<JedisShardInfo> redisMasterShards) {\n\t\treturn new ShardedJedisPool(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);\n\t}\n\n\t@Bean\n\tpublic ShardedJedisPool slaveShardedPool(GenericObjectPoolConfig jedisPoolConfig, List<JedisShardInfo> redisSlaveShards) {\n\t\treturn new ShardedJedisPool(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);\n\t}\n}\n~~~\n\n\n\n**RedisShardsConfig.java**\n\n~~~java\n@Configuration\npublic class RedisShardsConfig {\n\n    @Autowired\n\t@Qualifier(\"redisConfig\")\n\tprivate Properties redisConfig;\n    \n\t@Bean\n\tpublic List<JedisShardInfo> redisMasterShards() {\n        \n        String url = redisConfig.getProperty(\"redis.cluster.url\");\n        //Integer 형변환 생략함...(길어져서 안보임)\n        Integer masterPort1 = redisConfig.getProperty(\"redis.cluster.master.port1\");\n        Integer masterPort2 = redisConfig.getProperty(\"redis.cluster.master.port2\");\n        Integer masterPort3 = redisConfig.getProperty(\"redis.cluster.master.port3\");\n        \n        String masterShardKey1 = redisConfig.getProperty(\"redis.cluster.master.key1\");\n        String masterShardKey2 = redisConfig.getProperty(\"redis.cluster.master.key2\");\n        String masterShardKey3 = redisConfig.getProperty(\"redis.cluster.master.key3\");\n        \n\t\treturn new ArrayList<JedisShardInfo>() {\n\t\t\t{\n\t\t\t\tadd(new JedisShardInfo(url, masterPort1, masterShardKey1));\n\t\t\t\tadd(new JedisShardInfo(url, masterPort2, masterShardKey2));\n\t\t\t\tadd(new JedisShardInfo(url, masterPort3, masterShardKey3));\n\t\t\t}\n\t\t};\n\t}\n\n\t@Bean\n\tpublic List<JedisShardInfo> redisSlaveShards() {\n        \n        String url = redisConfig.getProperty(\"redis.cluster.url\");\n        //Integer 형변환 생략함...(길어져서 안보임)\n        Integer slavePort1 = redisConfig.getProperty(\"redis.cluster.slave.port1\");\n        Integer slavePort2 = redisConfig.getProperty(\"redis.cluster.slave.port2\");\n        Integer slavePort3 = redisConfig.getProperty(\"redis.cluster.slave.port3\");\n        \n        String slaveShardKey1 = redisConfig.getProperty(\"redis.cluster.slave.key1\");\n        String slaveShardKey2 = redisConfig.getProperty(\"redis.cluster.slave.key2\");\n        String slaveShardKey3 = redisConfig.getProperty(\"redis.cluster.slave.key3\");\n        \n\t\treturn new ArrayList<JedisShardInfo>() {\n\t\t\t{\n\t\t\t\tadd(new JedisShardInfo(url, slavePort1, slaveShardKey1));\n\t\t\t\tadd(new JedisShardInfo(url, slavePort2, slaveShardKey2));\n\t\t\t\tadd(new JedisShardInfo(url, slavePort3, slaveShardKey3));\n\t\t\t}\n\t\t};\n\t}\n}\n~~~\n\n\n\nRedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.\nRedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다. \n이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.\n이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.\nxml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.\n\n\n\n# @ImportResource\n\n모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들...)\n\n그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.\n사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.\n\n예시는 아래와 같다.\n\n\n\n~~~java\n@Configuration\n@ImportResource(value = {\n\t\t\"classpath:applicationContextForExternalMember.xml\",    //External-Member\n\t\t\"classpath*:applicationContextForExternalAPI.xml\",      //External-API\n\t\t\"classpath*:applicationContextForExternalLogger.xml\"    //External-Logger\n})\npublic class ExternalConfig {\n}\n~~~\n\n 위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.","source":"_posts/2018-10-21-java-config-import.md","raw":"---\nlayout: posts\ntitle: \"@Import와 @ImportResource Annotation\"\ndate: 2018-10-21 18:53:38\nsubtitle: xml을 Java Config로 변경하기\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\n  - Java-Config\ntypora-root-url: ./2018-10-21-java-config-import\ntypora-copy-images-to: ./2018-10-21-java-config-import\n---\n\n\n\n# 들어가며\n\n회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.\n아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고 \n최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.\n그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.\n\n\n\n# @Import\n\n@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.\n사용하는 개념은 기존에 xml 파일을 import하는.. <import /> 구분과 동일하게 사용된다.\n\n예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면..\n\n\n\n**RedisClusterConfig**\n\n~~~java\n@Configuration\n@Import(value = RedisShardsConfig.class) // Redis Shard정보에 대한 Config이다.\npublic class RedisClusterConfig {\n\n\t@Autowired\n\t@Qualifier(\"redisConfig\")\n\tprivate Properties redisConfig;\n\n\t@Bean\n\tpublic GenericObjectPoolConfig jedisPoolConfig() {\n\t\tJedisPoolConfig poolConfig = new JedisPoolConfig();\n\t    poolConfig.setMaxTotal(redisConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setMaxIdle(commonConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setMinIdle(commonConfig.getProperty(\"redis.cluster.connectionCount\"));\n\t\tpoolConfig.setNumTestsPerEvictionRun(2);\n\t\tpoolConfig.setTestOnBorrow(true);\n\t\tpoolConfig.setTestOnReturn(false);\n\t\tpoolConfig.setTestWhileIdle(true);\n\t\tpoolConfig.setTimeBetweenEvictionRunsMillis(300000);\n\t\treturn poolConfig;\n\t}\n    \n    //따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.\n\t@Bean\n\tpublic ShardedJedisPool masterShardedPool(GenericObjectPoolConfig jedisPoolConfig, List<JedisShardInfo> redisMasterShards) {\n\t\treturn new ShardedJedisPool(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);\n\t}\n\n\t@Bean\n\tpublic ShardedJedisPool slaveShardedPool(GenericObjectPoolConfig jedisPoolConfig, List<JedisShardInfo> redisSlaveShards) {\n\t\treturn new ShardedJedisPool(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);\n\t}\n}\n~~~\n\n\n\n**RedisShardsConfig.java**\n\n~~~java\n@Configuration\npublic class RedisShardsConfig {\n\n    @Autowired\n\t@Qualifier(\"redisConfig\")\n\tprivate Properties redisConfig;\n    \n\t@Bean\n\tpublic List<JedisShardInfo> redisMasterShards() {\n        \n        String url = redisConfig.getProperty(\"redis.cluster.url\");\n        //Integer 형변환 생략함...(길어져서 안보임)\n        Integer masterPort1 = redisConfig.getProperty(\"redis.cluster.master.port1\");\n        Integer masterPort2 = redisConfig.getProperty(\"redis.cluster.master.port2\");\n        Integer masterPort3 = redisConfig.getProperty(\"redis.cluster.master.port3\");\n        \n        String masterShardKey1 = redisConfig.getProperty(\"redis.cluster.master.key1\");\n        String masterShardKey2 = redisConfig.getProperty(\"redis.cluster.master.key2\");\n        String masterShardKey3 = redisConfig.getProperty(\"redis.cluster.master.key3\");\n        \n\t\treturn new ArrayList<JedisShardInfo>() {\n\t\t\t{\n\t\t\t\tadd(new JedisShardInfo(url, masterPort1, masterShardKey1));\n\t\t\t\tadd(new JedisShardInfo(url, masterPort2, masterShardKey2));\n\t\t\t\tadd(new JedisShardInfo(url, masterPort3, masterShardKey3));\n\t\t\t}\n\t\t};\n\t}\n\n\t@Bean\n\tpublic List<JedisShardInfo> redisSlaveShards() {\n        \n        String url = redisConfig.getProperty(\"redis.cluster.url\");\n        //Integer 형변환 생략함...(길어져서 안보임)\n        Integer slavePort1 = redisConfig.getProperty(\"redis.cluster.slave.port1\");\n        Integer slavePort2 = redisConfig.getProperty(\"redis.cluster.slave.port2\");\n        Integer slavePort3 = redisConfig.getProperty(\"redis.cluster.slave.port3\");\n        \n        String slaveShardKey1 = redisConfig.getProperty(\"redis.cluster.slave.key1\");\n        String slaveShardKey2 = redisConfig.getProperty(\"redis.cluster.slave.key2\");\n        String slaveShardKey3 = redisConfig.getProperty(\"redis.cluster.slave.key3\");\n        \n\t\treturn new ArrayList<JedisShardInfo>() {\n\t\t\t{\n\t\t\t\tadd(new JedisShardInfo(url, slavePort1, slaveShardKey1));\n\t\t\t\tadd(new JedisShardInfo(url, slavePort2, slaveShardKey2));\n\t\t\t\tadd(new JedisShardInfo(url, slavePort3, slaveShardKey3));\n\t\t\t}\n\t\t};\n\t}\n}\n~~~\n\n\n\nRedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.\nRedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다. \n이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.\n이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.\nxml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.\n\n\n\n# @ImportResource\n\n모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들...)\n\n그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.\n사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.\n\n예시는 아래와 같다.\n\n\n\n~~~java\n@Configuration\n@ImportResource(value = {\n\t\t\"classpath:applicationContextForExternalMember.xml\",    //External-Member\n\t\t\"classpath*:applicationContextForExternalAPI.xml\",      //External-API\n\t\t\"classpath*:applicationContextForExternalLogger.xml\"    //External-Logger\n})\npublic class ExternalConfig {\n}\n~~~\n\n 위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.","slug":"2018-10-21-java-config-import","published":1,"updated":"2018-11-27T07:23:32.380Z","comments":1,"photos":[],"link":"","_id":"cjp55h5gg00064f1ta0x2popv","content":"<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.<br>\n아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고<br>\n최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.<br>\n그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.</p>\n<h1><span id=\"import\">@Import</span></h1>\n<p>@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.<br>\n사용하는 개념은 기존에 xml 파일을 import하는… <import> 구분과 동일하게 사용된다.</import></p>\n<p>예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면…</p>\n<p><strong>RedisClusterConfig</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(value = RedisShardsConfig.class) <span class=\"comment\">// Redis Shard정보에 대한 Config이다.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisClusterConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"redisConfig\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Properties redisConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> GenericObjectPoolConfig <span class=\"title\">jedisPoolConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tJedisPoolConfig poolConfig = <span class=\"keyword\">new</span> JedisPoolConfig();</span><br><span class=\"line\">\t    poolConfig.setMaxTotal(redisConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setMaxIdle(commonConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setMinIdle(commonConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setNumTestsPerEvictionRun(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestOnReturn(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestWhileIdle(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTimeBetweenEvictionRunsMillis(<span class=\"number\">300000</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> poolConfig;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ShardedJedisPool <span class=\"title\">masterShardedPool</span><span class=\"params\">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisMasterShards)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ShardedJedisPool(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ShardedJedisPool <span class=\"title\">slaveShardedPool</span><span class=\"params\">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisSlaveShards)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ShardedJedisPool(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>RedisShardsConfig.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisShardsConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"redisConfig\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Properties redisConfig;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;JedisShardInfo&gt; <span class=\"title\">redisMasterShards</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String url = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.url\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class=\"line\">        Integer masterPort1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port1\"</span>);</span><br><span class=\"line\">        Integer masterPort2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port2\"</span>);</span><br><span class=\"line\">        Integer masterPort3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        String masterShardKey1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key1\"</span>);</span><br><span class=\"line\">        String masterShardKey2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key2\"</span>);</span><br><span class=\"line\">        String masterShardKey3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort1, masterShardKey1));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort2, masterShardKey2));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort3, masterShardKey3));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;JedisShardInfo&gt; <span class=\"title\">redisSlaveShards</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String url = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.url\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class=\"line\">        Integer slavePort1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port1\"</span>);</span><br><span class=\"line\">        Integer slavePort2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port2\"</span>);</span><br><span class=\"line\">        Integer slavePort3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        String slaveShardKey1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key1\"</span>);</span><br><span class=\"line\">        String slaveShardKey2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key2\"</span>);</span><br><span class=\"line\">        String slaveShardKey3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort1, slaveShardKey1));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort2, slaveShardKey2));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort3, slaveShardKey3));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.<br>\nRedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다.<br>\n이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.<br>\n이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.<br>\nxml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.</p>\n<h1><span id=\"importresource\">@ImportResource</span></h1>\n<p>모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들…)</p>\n<p>그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.<br>\n사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.</p>\n<p>예시는 아래와 같다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource</span>(value = &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath:applicationContextForExternalMember.xml\"</span>,    <span class=\"comment\">//External-Member</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath*:applicationContextForExternalAPI.xml\"</span>,      <span class=\"comment\">//External-API</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath*:applicationContextForExternalLogger.xml\"</span>    <span class=\"comment\">//External-Logger</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExternalConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.<br>\n아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고<br>\n최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.<br>\n그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.</p>\n<h1>@Import</h1>\n<p>@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.<br>\n사용하는 개념은 기존에 xml 파일을 import하는… <import> 구분과 동일하게 사용된다.</import></p>\n<p>예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면…</p>\n<p><strong>RedisClusterConfig</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(value = RedisShardsConfig.class) <span class=\"comment\">// Redis Shard정보에 대한 Config이다.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisClusterConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"redisConfig\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Properties redisConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> GenericObjectPoolConfig <span class=\"title\">jedisPoolConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tJedisPoolConfig poolConfig = <span class=\"keyword\">new</span> JedisPoolConfig();</span><br><span class=\"line\">\t    poolConfig.setMaxTotal(redisConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setMaxIdle(commonConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setMinIdle(commonConfig.getProperty(<span class=\"string\">\"redis.cluster.connectionCount\"</span>));</span><br><span class=\"line\">\t\tpoolConfig.setNumTestsPerEvictionRun(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestOnReturn(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTestWhileIdle(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\tpoolConfig.setTimeBetweenEvictionRunsMillis(<span class=\"number\">300000</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> poolConfig;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ShardedJedisPool <span class=\"title\">masterShardedPool</span><span class=\"params\">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisMasterShards)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ShardedJedisPool(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ShardedJedisPool <span class=\"title\">slaveShardedPool</span><span class=\"params\">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisSlaveShards)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ShardedJedisPool(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>RedisShardsConfig.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisShardsConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"redisConfig\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Properties redisConfig;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;JedisShardInfo&gt; <span class=\"title\">redisMasterShards</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String url = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.url\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class=\"line\">        Integer masterPort1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port1\"</span>);</span><br><span class=\"line\">        Integer masterPort2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port2\"</span>);</span><br><span class=\"line\">        Integer masterPort3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.port3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        String masterShardKey1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key1\"</span>);</span><br><span class=\"line\">        String masterShardKey2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key2\"</span>);</span><br><span class=\"line\">        String masterShardKey3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.master.key3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort1, masterShardKey1));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort2, masterShardKey2));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, masterPort3, masterShardKey3));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;JedisShardInfo&gt; <span class=\"title\">redisSlaveShards</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String url = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.url\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class=\"line\">        Integer slavePort1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port1\"</span>);</span><br><span class=\"line\">        Integer slavePort2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port2\"</span>);</span><br><span class=\"line\">        Integer slavePort3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.port3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        String slaveShardKey1 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key1\"</span>);</span><br><span class=\"line\">        String slaveShardKey2 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key2\"</span>);</span><br><span class=\"line\">        String slaveShardKey3 = redisConfig.getProperty(<span class=\"string\">\"redis.cluster.slave.key3\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort1, slaveShardKey1));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort2, slaveShardKey2));</span><br><span class=\"line\">\t\t\t\tadd(<span class=\"keyword\">new</span> JedisShardInfo(url, slavePort3, slaveShardKey3));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.<br>\nRedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다.<br>\n이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.<br>\n이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.<br>\nxml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.</p>\n<h1>@ImportResource</h1>\n<p>모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들…)</p>\n<p>그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.<br>\n사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.</p>\n<p>예시는 아래와 같다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource</span>(value = &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath:applicationContextForExternalMember.xml\"</span>,    <span class=\"comment\">//External-Member</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath*:applicationContextForExternalAPI.xml\"</span>,      <span class=\"comment\">//External-API</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"classpath*:applicationContextForExternalLogger.xml\"</span>    <span class=\"comment\">//External-Logger</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExternalConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.</p>\n"},{"title":"Application-Context와 Servlet-Context","subtitle":"AOP가 적용되지 않아서...","catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-10-21-spring-context","typora-copy-images-to":"./2018-10-21-spring-context","date":"2018-10-21T08:00:54.000Z","header-img":null,"_content":"\n\n\n# 들어가며\n\n회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.\n문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.\ncore가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,\n각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.\nBean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.\n\n이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.\n\n\n\n# Web Application Context\n\n![img](./99A34C3359FEAA8410.png)\n\n\n\n## Application Context\n\n* Web Application 최상단에 위치하고 있는 Context\n* Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context\n* Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한\n  설정정보를 담은 파일 (Bean 선언 등..)\n* Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)\n* 특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)\n* 서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.\n* **Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.**\n\n\n\n## Servlet-Context (servlet-context.xml)\n\n* Servlet 단위로 생성되는 context\n* Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일\n  (Interceptor, Bean생성, ViewResolver등..)\n* URL설정이 있는 Bean을 생성 (@Controller, Interceptor)\n* Application Context를 자신의 부모 Context로 사용한다.\n* Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,\n  Servlet Context에 선언된 Bean을 사용한다.\n* Bean 찾는 순서 \n  * Servlet Context에서 먼저 찾는다.\n  * 만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.\n* **Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.**\n\n\n\n# web.xml 설정 살펴보기\n\n## web.xml 이란\n\n서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.\n여기서 서블릿 클래스를 등록하는 곳의 이름을 `Web application deployment descriptor`라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 `web.xml`이다. `web.xml` 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.\n\nDD는 WAS 구동 시 `/WEB-INF` 디렉토리에 존재하는 `web.xml`을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n <!-- The definition of the Root Spring Container shared by all Servlets and Filters -->\n      <!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 -->\n      <context-param>  \n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/spring/applicationContext.xml</param-value>\n      </context-param>\n      \n      <!-- Creates the Spring Container shared by all Servlets and Filters -->\n      <!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 -->\n      <listener>\n          <listener-class>\n              org.springframework.web.context.ContextLoaderListener\n          </listener-class>\n      </listener>\n    \n      <!-- Processes application requests -->\n      <servlet> \n          <servlet-name>dispatcherServlet</servlet-name>\n          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \n          <init-param>\n              <param-name>contextConfigLocation</param-name> \n              <param-value>\n                  <!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 -->\n                  /WEB-INF/spring/appServlet/servlet-context.xml\n              </param-value>\n          </init-param>\n          <load-on-startup>1</load-on-startup>\n      </servlet>\n            \n    <!-- dispatcherServlet 대한 url-pattern을 정의 \n        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 -->\n      <servlet-mapping>  \n            <servlet-name>dispatcherServlet</servlet-name>\n            <url-pattern>/</url-pattern>\n      </servlet-mapping>\n</web-app>\n~~~\n\n\n\n# 그래서 Context 설정은 어떻게 쓰냐?\n\nSpring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.\n\n* Application Context\n  * 공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등..)\n  * 각 Servlet에서 공유할 수 있는 Bean\n* Servlet Context\n  * Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등..)\n\n가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.\n각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.\n\n\n\nApplicationContext.xml\n\n~~~xml\n<context:component-scan base-package=\"com.myapp.core, com.myapp.app\">\n    <!-- Component-scan대상에서 @Controller annotation Class는 제외한다. -->\n    <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> \n</context:component-scan>\n~~~\n\n\n\nServlet-Context.xml\n\n~~~xml\n<context:component-scan base-package=\"com.myapp.app\" use-default-filters=\"false\">\n    <!-- Component-scan대상은 @Controller annotation Class만 scan한다. -->\n    <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> \n</context:component-scan>\n~~~\n\nServlet-Context.xml 설정 시, `use-default-filters` 속성을 `false`로 처리 하였다.\n`use-default-filters` 속성은 원래 `default가 true`인데, \n@Compont Annotation(@Controller, @Service, @Repository등..) 의 `클래스를 자동으로 Bean으로 등록해 주는 filter속성`이다. \n따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.\n\n\n\n# 참조\n\n* http://hoonmaro.tistory.com/31\n* https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html","source":"_posts/2018-10-21-spring-context.md","raw":"---\ntitle: Application-Context와 Servlet-Context\nsubtitle: AOP가 적용되지 않아서...\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\n  - WAS\ntypora-root-url: ./2018-10-21-spring-context\ntypora-copy-images-to: ./2018-10-21-spring-context\ndate: 2018-10-21 17:00:54\nheader-img:\n---\n\n\n\n# 들어가며\n\n회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.\n문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.\ncore가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,\n각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.\nBean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.\n\n이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.\n\n\n\n# Web Application Context\n\n![img](./99A34C3359FEAA8410.png)\n\n\n\n## Application Context\n\n* Web Application 최상단에 위치하고 있는 Context\n* Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context\n* Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한\n  설정정보를 담은 파일 (Bean 선언 등..)\n* Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)\n* 특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)\n* 서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.\n* **Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.**\n\n\n\n## Servlet-Context (servlet-context.xml)\n\n* Servlet 단위로 생성되는 context\n* Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일\n  (Interceptor, Bean생성, ViewResolver등..)\n* URL설정이 있는 Bean을 생성 (@Controller, Interceptor)\n* Application Context를 자신의 부모 Context로 사용한다.\n* Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,\n  Servlet Context에 선언된 Bean을 사용한다.\n* Bean 찾는 순서 \n  * Servlet Context에서 먼저 찾는다.\n  * 만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.\n* **Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.**\n\n\n\n# web.xml 설정 살펴보기\n\n## web.xml 이란\n\n서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.\n여기서 서블릿 클래스를 등록하는 곳의 이름을 `Web application deployment descriptor`라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 `web.xml`이다. `web.xml` 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.\n\nDD는 WAS 구동 시 `/WEB-INF` 디렉토리에 존재하는 `web.xml`을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n <!-- The definition of the Root Spring Container shared by all Servlets and Filters -->\n      <!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 -->\n      <context-param>  \n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/spring/applicationContext.xml</param-value>\n      </context-param>\n      \n      <!-- Creates the Spring Container shared by all Servlets and Filters -->\n      <!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 -->\n      <listener>\n          <listener-class>\n              org.springframework.web.context.ContextLoaderListener\n          </listener-class>\n      </listener>\n    \n      <!-- Processes application requests -->\n      <servlet> \n          <servlet-name>dispatcherServlet</servlet-name>\n          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \n          <init-param>\n              <param-name>contextConfigLocation</param-name> \n              <param-value>\n                  <!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 -->\n                  /WEB-INF/spring/appServlet/servlet-context.xml\n              </param-value>\n          </init-param>\n          <load-on-startup>1</load-on-startup>\n      </servlet>\n            \n    <!-- dispatcherServlet 대한 url-pattern을 정의 \n        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 -->\n      <servlet-mapping>  \n            <servlet-name>dispatcherServlet</servlet-name>\n            <url-pattern>/</url-pattern>\n      </servlet-mapping>\n</web-app>\n~~~\n\n\n\n# 그래서 Context 설정은 어떻게 쓰냐?\n\nSpring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.\n\n* Application Context\n  * 공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등..)\n  * 각 Servlet에서 공유할 수 있는 Bean\n* Servlet Context\n  * Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등..)\n\n가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.\n각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.\n\n\n\nApplicationContext.xml\n\n~~~xml\n<context:component-scan base-package=\"com.myapp.core, com.myapp.app\">\n    <!-- Component-scan대상에서 @Controller annotation Class는 제외한다. -->\n    <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> \n</context:component-scan>\n~~~\n\n\n\nServlet-Context.xml\n\n~~~xml\n<context:component-scan base-package=\"com.myapp.app\" use-default-filters=\"false\">\n    <!-- Component-scan대상은 @Controller annotation Class만 scan한다. -->\n    <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> \n</context:component-scan>\n~~~\n\nServlet-Context.xml 설정 시, `use-default-filters` 속성을 `false`로 처리 하였다.\n`use-default-filters` 속성은 원래 `default가 true`인데, \n@Compont Annotation(@Controller, @Service, @Repository등..) 의 `클래스를 자동으로 Bean으로 등록해 주는 filter속성`이다. \n따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.\n\n\n\n# 참조\n\n* http://hoonmaro.tistory.com/31\n* https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html","slug":"2018-10-21-spring-context","published":1,"updated":"2018-11-27T07:23:32.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp55h5gi00074f1tccd6t0va","content":"<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.<br>\n문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.<br>\ncore가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,<br>\n각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.<br>\nBean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.</p>\n<p>이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.</p>\n<h1><span id=\"web-application-context\">Web Application Context</span></h1>\n<p><img src=\"./99A34C3359FEAA8410.png\" alt=\"img\"></p>\n<h2><span id=\"application-context\">Application Context</span></h2>\n<ul>\n<li>Web Application 최상단에 위치하고 있는 Context</li>\n<li>Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context</li>\n<li>Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한<br>\n설정정보를 담은 파일 (Bean 선언 등…)</li>\n<li>Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)</li>\n<li>특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)</li>\n<li>서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.</li>\n<li><strong>Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.</strong></li>\n</ul>\n<h2><span id=\"servlet-context-servlet-contextxml\">Servlet-Context (servlet-context.xml)</span></h2>\n<ul>\n<li>Servlet 단위로 생성되는 context</li>\n<li>Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일<br>\n(Interceptor, Bean생성, ViewResolver등…)</li>\n<li>URL설정이 있는 Bean을 생성 (@Controller, Interceptor)</li>\n<li>Application Context를 자신의 부모 Context로 사용한다.</li>\n<li>Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,<br>\nServlet Context에 선언된 Bean을 사용한다.</li>\n<li>Bean 찾는 순서\n<ul>\n<li>Servlet Context에서 먼저 찾는다.</li>\n<li>만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.</li>\n</ul>\n</li>\n<li><strong>Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.</strong></li>\n</ul>\n<h1><span id=\"webxml-설정-살펴보기\">web.xml 설정 살펴보기</span></h1>\n<h2><span id=\"webxml-이란\">web.xml 이란</span></h2>\n<p>서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.<br>\n여기서 서블릿 클래스를 등록하는 곳의 이름을 <code>Web application deployment descriptor</code>라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 <code>web.xml</code>이다. <code>web.xml</code> 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.</p>\n<p>DD는 WAS 구동 시 <code>/WEB-INF</code> 디렉토리에 존재하는 <code>web.xml</code>을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span>&gt;</span></span><br><span class=\"line\"> <span class=\"comment\">&lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>/WEB-INF/spring/applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">              org.springframework.web.context.ContextLoaderListener</span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Processes application requests --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"comment\">&lt;!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 --&gt;</span></span><br><span class=\"line\">                  /WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dispatcherServlet 대한 url-pattern을 정의 </span></span><br><span class=\"line\"><span class=\"comment\">        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"그래서-context-설정은-어떻게-쓰냐\">그래서 Context 설정은 어떻게 쓰냐?</span></h1>\n<p>Spring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.</p>\n<ul>\n<li>Application Context\n<ul>\n<li>공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등…)</li>\n<li>각 Servlet에서 공유할 수 있는 Bean</li>\n</ul>\n</li>\n<li>Servlet Context\n<ul>\n<li>Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등…)</li>\n</ul>\n</li>\n</ul>\n<p>가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.<br>\n각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.</p>\n<p>ApplicationContext.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.myapp.core, com.myapp.app\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Component-scan대상에서 @Controller annotation Class는 제외한다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:exclude-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Controller\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Servlet-Context.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.myapp.app\"</span> <span class=\"attr\">use-default-filters</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Component-scan대상은 @Controller annotation Class만 scan한다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Controller\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Servlet-Context.xml 설정 시, <code>use-default-filters</code> 속성을 <code>false</code>로 처리 하였다.<br>\n<code>use-default-filters</code> 속성은 원래 <code>default가 true</code>인데,<br>\n@Compont Annotation(@Controller, @Service, @Repository등…) 의 <code>클래스를 자동으로 Bean으로 등록해 주는 filter속성</code>이다.<br>\n따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.</p>\n<h1><span id=\"참조\">참조</span></h1>\n<ul>\n<li><a href=\"http://hoonmaro.tistory.com/31\" target=\"_blank\" rel=\"noopener\">http://hoonmaro.tistory.com/31</a></li>\n<li><a href=\"https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html\" target=\"_blank\" rel=\"noopener\">https://plus4070.github.io/nhn entertainment devdays/Web.xml.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.<br>\n문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.<br>\ncore가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,<br>\n각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.<br>\nBean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.</p>\n<p>이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.</p>\n<h1>Web Application Context</h1>\n<p><img src=\"./99A34C3359FEAA8410.png\" alt=\"img\"></p>\n<h2>Application Context</h2>\n<ul>\n<li>Web Application 최상단에 위치하고 있는 Context</li>\n<li>Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context</li>\n<li>Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한<br>\n설정정보를 담은 파일 (Bean 선언 등…)</li>\n<li>Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)</li>\n<li>특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)</li>\n<li>서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.</li>\n<li><strong>Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.</strong></li>\n</ul>\n<h2>Servlet-Context (servlet-context.xml)</h2>\n<ul>\n<li>Servlet 단위로 생성되는 context</li>\n<li>Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일<br>\n(Interceptor, Bean생성, ViewResolver등…)</li>\n<li>URL설정이 있는 Bean을 생성 (@Controller, Interceptor)</li>\n<li>Application Context를 자신의 부모 Context로 사용한다.</li>\n<li>Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,<br>\nServlet Context에 선언된 Bean을 사용한다.</li>\n<li>Bean 찾는 순서\n<ul>\n<li>Servlet Context에서 먼저 찾는다.</li>\n<li>만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.</li>\n</ul>\n</li>\n<li><strong>Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.</strong></li>\n</ul>\n<h1>web.xml 설정 살펴보기</h1>\n<h2>web.xml 이란</h2>\n<p>서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.<br>\n여기서 서블릿 클래스를 등록하는 곳의 이름을 <code>Web application deployment descriptor</code>라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 <code>web.xml</code>이다. <code>web.xml</code> 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.</p>\n<p>DD는 WAS 구동 시 <code>/WEB-INF</code> 디렉토리에 존재하는 <code>web.xml</code>을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span>&gt;</span></span><br><span class=\"line\"> <span class=\"comment\">&lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>/WEB-INF/spring/applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">              org.springframework.web.context.ContextLoaderListener</span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Processes application requests --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"comment\">&lt;!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 --&gt;</span></span><br><span class=\"line\">                  /WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dispatcherServlet 대한 url-pattern을 정의 </span></span><br><span class=\"line\"><span class=\"comment\">        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1>그래서 Context 설정은 어떻게 쓰냐?</h1>\n<p>Spring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.</p>\n<ul>\n<li>Application Context\n<ul>\n<li>공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등…)</li>\n<li>각 Servlet에서 공유할 수 있는 Bean</li>\n</ul>\n</li>\n<li>Servlet Context\n<ul>\n<li>Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등…)</li>\n</ul>\n</li>\n</ul>\n<p>가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.<br>\n각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.</p>\n<p>ApplicationContext.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.myapp.core, com.myapp.app\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Component-scan대상에서 @Controller annotation Class는 제외한다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:exclude-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Controller\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Servlet-Context.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.myapp.app\"</span> <span class=\"attr\">use-default-filters</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Component-scan대상은 @Controller annotation Class만 scan한다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Controller\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Servlet-Context.xml 설정 시, <code>use-default-filters</code> 속성을 <code>false</code>로 처리 하였다.<br>\n<code>use-default-filters</code> 속성은 원래 <code>default가 true</code>인데,<br>\n@Compont Annotation(@Controller, @Service, @Repository등…) 의 <code>클래스를 자동으로 Bean으로 등록해 주는 filter속성</code>이다.<br>\n따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.</p>\n<h1>참조</h1>\n<ul>\n<li><a href=\"http://hoonmaro.tistory.com/31\" target=\"_blank\" rel=\"noopener\">http://hoonmaro.tistory.com/31</a></li>\n<li><a href=\"https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html\" target=\"_blank\" rel=\"noopener\">https://plus4070.github.io/nhn entertainment devdays/Web.xml.html</a></li>\n</ul>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (1)Docker란 무엇인가?","date":"2018-11-25T09:51:22.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-11-25-docker-1","typora-copy-images-to":"2018-11-25-docker-1","_content":"\n\n\n# Docker란 무엇인가?\n\n![docker-logo](./docker-logo.png)\n\nDocker란 **Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼** 입니다.\n\n위의 Docker 이미지처럼 선박에 화물을 수송하는 이미지를 떠올리면 이해하기가 쉬운데, 실제 선박에는 자동차, 오토바이, 전자제품등 여러 물건을 담을 수 있습니다.\n\n선박에 대한 이미지를 유지한 채, Web Service 운영환경을 생각해 보면..\nWeb Service 운영환경을 구성하기 위해서는 Web Application이 구동 될 수 있는 WAS와 DataBase가 필요합니다.\n\n이 2가지 프로그램을 Docker라는 선박에 담는다고 생각해 봅시다.\n그 다음 우리가 배포할 서버를 항구(Port)라고 생각하고, \n각 서버에 Web Service 운영환경을 싣고 있는 선박을 정착 시켜 서버에서 접근가능한 서비스로 이용할 수 있습니다. 따라서 어떤 서버에서도 Docker만 설치되어 있다면, 다양한 `프로그램과 실행환경을 추상화 하여 동일한 인터페이스를 제공`하고 서버관리를 쉽고 단순하게 만들어 줄 수 있습니다.\n\nDocker에서는 `Image`와 `Container`라는 개념을 사용하는데, 이 두 가지 개념에 대해 알아보도록 하겠습니다.\n\n\n\n# Docker Image\n\n![docker-image](./docker-image.png)\n\nDocker Image는 우리가 사용할 프로그램을 추상화 한 개념입니다.\n\nImage에는 Container 실행에 필요한 파일(redis.conf, redis.log...., docker-entrypoing.sh등)등을 포함하고,\n설정값(port, env, data directory등) 정보를 포함하고 있습니다.\n`1개의 이미지`를 바탕으로` 여러 개의 컨테이너`를 만들 수 있습니다. \n(ex. 하나의 Redis 이미지를 바탕으로 3개의 Redis Container를 구성하여 Cluster환경을 구성할 수 있습니다.)\n이 내용을 좀 더 쉽게 이해하자면, 한번 쯤은 WM에 Linux를 설치 해 본 경험이 있을텐데, Linux를 설치 하기 위해선 linux.iso 파일이 필요 합니다.\n이때 iso파일이 Linux를 구성하기 위한 파일과 설정 정보를 담고 있고 VM에 Linux를 설치 할 수 있게 해줍니다.\n여기서 `iso파일`을 `Image`라고 생각하고, `VM위에 설치되는 리눅스`를 `Container`라고 이해 할 수 있겠습니다.\n\nDocker를 이용한 운영 배포 시, 이미지를 `Docker Hub`라는 곳에 올려 각 서버에서 받아 사용할 수 있습니다. \n(Docker Hub는 github나 maven repository 같은 클라우드 저장소 같은 개념으로 이해 하시면 됩니다.)\n\n\n\n# Docker Container\n\nContainer란, **프로그램의 실행에 필요한 실행환경을 독립적으로 운용할 수 있도록, 다른 실행환경과의 간섭을 막고 독립성을 확보해 주는 운영체제 수준의 격리 기술**을 의미합니다.\n\n이러한 격리된 환경이 필요한 경우를 생각해 볼 수 있는데, 극단적인 예시로 Java 1.6 환경에서만 실행되는 프로그램과 Java 1.8이상 환경에서만 실행 되는 프로그램을 하나의 서버에 설치한다고 가정하겠습니다.\n\n프로그램이 실행 되기 위해서는 운영체제에 설치 된 라이브러리의 대해 의존성을 가질 수 밖에 없는데, 하나의 OS에서 Java Version에 대한 격리 환경을 가지게 하는 것은 상당히 번거로운 일입니다.\n이러한 경우 Docker를 사용하면 격리된 구역에서 실행 환경을 만들어 줄 수 있기 때문에 타 시스템에 영향을 주지 않고 안정적으로 운영환경을 구성 할 수 있습니다.\n\nDocker을 처음 공부할 때 Image와 Container 관계가 무척이나 헷갈렸는데.. 예시를 통해 이해해 보겠습니다.\nImage는 실행 환경에 대한 파일과 설정 정보를 담고 있다고 했습니다. 그리고 프로그램을 추상화 한 개념이라고 하였습니다.\n이는 Java의 Class와 같은 개념으로 인식 할 수 있습니다.\nContainer는 Image를 기반으로 생성된 격리 된 실행환경이라 했습니다. 그리고 Container를 실행 할 경우 파라미터를 통해 Container 내부 설정정보를 변경 할 수도 있습니다.\n이는 Class를 바탕으로 만들어진 Instance의 개념으로 이해 할 수 있습니다.\n이처럼 Java의 Class와 Instance의 관계로 이해한다면, Docker에서의 Image와 Container 관계에 대해 어렵지 않게 이해 할 수 있을 것 같습니다.\n\n![docking-image](./docking-image.png)\n\n도킹에 성공한 Container는 Host OS에 설치 된 프로그램 처럼 사용할 수 있다.\n\n\n\n# Docker vs Virtual Machine\n\n위에서 설명하길 \"Docker란 **Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼**입니다.\" 라고 이야기 하였습니다.\n가상화라고 하면 대표적인 예가 Virtual Machine 즉 VM을 떠올릴 수 있는데요.\n\nVM과 Docker는 몇가지 차이점이 있습니다.\n먼저 그림으로 그 구조를 확인해 보겠습니다.\n\n![vm-vs-docker](./vm-vs-docker.png)\n\n먼저 VM의 가상화 방식은 기존의 `Host OS위에 Hyper Visor를 이용`하여 가상화 OS를 띄우는 방식으로 많이 구현했습니다.\n주로 Windows에서 VMWare, Virtual Box, Hyper-V등 가상화 도구를 이용해 Guest OS를 설치하고 그 OS 위에 우리가 사용하고자 하는 프로그램을 설치하여 사용하였습니다.\n\n이러한 방식은 `완벽한 수준의 격리`이며, Host OS에서 Guest OS의 프로그램을 직접적으로 제어할 수 없습니다\n또한 Host OS에서 할당한 자원(Resource)밖에 사용할 수 없기 때문에 Host OS에서도 가상 OS에 점유한 자원을 유동적으로 사용할 수 없어 낭비가 생깁니다.\n\n반면에 Container 방식은 **기존의 Host OS위에 Docker를 이용하여 해당 프로그램의 의존성 라이브러리(프로그램 구동에 필요한 라이브러리)만 가지고 Container가 생성**됩니다. 그렇기에 `최소한의 용량으로 이미지를 구성` 할 수 있습니다.\nVM에서 사용되는 OS나 Kernel이 없기 때문에 부팅을 할 필요도 없으며, Host OS의 Resource 또한 유동적으로 사용할 수 있어 자원관리가 효율적입니다.\n\n단순히 프로세스를 격리시키는 것이기 때문에 `VM에 비해 매우 빠르게 동작`합니다.\n단점인 부분은 **Host OS에 종속적인 부분이 있습니다.** \nVM방식의 경우 각각의 OS에 대한 독립성을 가지고 있어, Host OS에 대해 독립적입니다. (예를들어 Host OS가 리눅스이고, Guest OS가 Windows인 경우, MSSQL을 Guest OS에서 사용할 수 있다)\n하지만 Container방식은 Host OS의 자원을 기반으로 생성 되기 때문에 `Host OS에서 작동할 수 없는 프로그램은 Container 내부에서 작동 할 수 없습니다.`\n\n\n\n# Docker for XX\n\nDocker는 리눅스 컨테이너 기반으로 동작하지만 최근 Windows와 Mac에 대해서도 Docker를 지원하고 있습니다.\n하지만 Linux기반 Docker와 조금 차이점이 있습니다.\n아무래도 Linux 기반 컨테이너이기 때문에 Windows에서는 Hyper-V에 리눅스를 설치하여 연동되게 되어있습니다.\n이 경우 Host OS가 Windows가 되는 것이 아니라, Hyper-V의 리눅스가 Host OS가 되는 것이기 때문에 Hyper-V에 할당된 메모리와 디스크 용량을 기반으로 자원을 활용하게 됩니다.\nLinux가 아닌 다른 운영체제에서 Docker 설치 시 유의해야 할 부분입니다.\n\n\n\n# 참고\n\n* <http://www.sauru.so/blog/getting-started-with-docker/>\n\n* <http://www.sauru.so/blog/getting-started-with-docker/>     \n* <https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html>\n\n* <https://www.docker.com/enterprise-edition#/platform>\n\n","source":"_posts/2018-11-25-docker-1.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (1)Docker란 무엇인가?\ndate: 2018-11-25 18:51:22\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-11-25-docker-1\ntypora-copy-images-to: 2018-11-25-docker-1\n---\n\n\n\n# Docker란 무엇인가?\n\n![docker-logo](./docker-logo.png)\n\nDocker란 **Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼** 입니다.\n\n위의 Docker 이미지처럼 선박에 화물을 수송하는 이미지를 떠올리면 이해하기가 쉬운데, 실제 선박에는 자동차, 오토바이, 전자제품등 여러 물건을 담을 수 있습니다.\n\n선박에 대한 이미지를 유지한 채, Web Service 운영환경을 생각해 보면..\nWeb Service 운영환경을 구성하기 위해서는 Web Application이 구동 될 수 있는 WAS와 DataBase가 필요합니다.\n\n이 2가지 프로그램을 Docker라는 선박에 담는다고 생각해 봅시다.\n그 다음 우리가 배포할 서버를 항구(Port)라고 생각하고, \n각 서버에 Web Service 운영환경을 싣고 있는 선박을 정착 시켜 서버에서 접근가능한 서비스로 이용할 수 있습니다. 따라서 어떤 서버에서도 Docker만 설치되어 있다면, 다양한 `프로그램과 실행환경을 추상화 하여 동일한 인터페이스를 제공`하고 서버관리를 쉽고 단순하게 만들어 줄 수 있습니다.\n\nDocker에서는 `Image`와 `Container`라는 개념을 사용하는데, 이 두 가지 개념에 대해 알아보도록 하겠습니다.\n\n\n\n# Docker Image\n\n![docker-image](./docker-image.png)\n\nDocker Image는 우리가 사용할 프로그램을 추상화 한 개념입니다.\n\nImage에는 Container 실행에 필요한 파일(redis.conf, redis.log...., docker-entrypoing.sh등)등을 포함하고,\n설정값(port, env, data directory등) 정보를 포함하고 있습니다.\n`1개의 이미지`를 바탕으로` 여러 개의 컨테이너`를 만들 수 있습니다. \n(ex. 하나의 Redis 이미지를 바탕으로 3개의 Redis Container를 구성하여 Cluster환경을 구성할 수 있습니다.)\n이 내용을 좀 더 쉽게 이해하자면, 한번 쯤은 WM에 Linux를 설치 해 본 경험이 있을텐데, Linux를 설치 하기 위해선 linux.iso 파일이 필요 합니다.\n이때 iso파일이 Linux를 구성하기 위한 파일과 설정 정보를 담고 있고 VM에 Linux를 설치 할 수 있게 해줍니다.\n여기서 `iso파일`을 `Image`라고 생각하고, `VM위에 설치되는 리눅스`를 `Container`라고 이해 할 수 있겠습니다.\n\nDocker를 이용한 운영 배포 시, 이미지를 `Docker Hub`라는 곳에 올려 각 서버에서 받아 사용할 수 있습니다. \n(Docker Hub는 github나 maven repository 같은 클라우드 저장소 같은 개념으로 이해 하시면 됩니다.)\n\n\n\n# Docker Container\n\nContainer란, **프로그램의 실행에 필요한 실행환경을 독립적으로 운용할 수 있도록, 다른 실행환경과의 간섭을 막고 독립성을 확보해 주는 운영체제 수준의 격리 기술**을 의미합니다.\n\n이러한 격리된 환경이 필요한 경우를 생각해 볼 수 있는데, 극단적인 예시로 Java 1.6 환경에서만 실행되는 프로그램과 Java 1.8이상 환경에서만 실행 되는 프로그램을 하나의 서버에 설치한다고 가정하겠습니다.\n\n프로그램이 실행 되기 위해서는 운영체제에 설치 된 라이브러리의 대해 의존성을 가질 수 밖에 없는데, 하나의 OS에서 Java Version에 대한 격리 환경을 가지게 하는 것은 상당히 번거로운 일입니다.\n이러한 경우 Docker를 사용하면 격리된 구역에서 실행 환경을 만들어 줄 수 있기 때문에 타 시스템에 영향을 주지 않고 안정적으로 운영환경을 구성 할 수 있습니다.\n\nDocker을 처음 공부할 때 Image와 Container 관계가 무척이나 헷갈렸는데.. 예시를 통해 이해해 보겠습니다.\nImage는 실행 환경에 대한 파일과 설정 정보를 담고 있다고 했습니다. 그리고 프로그램을 추상화 한 개념이라고 하였습니다.\n이는 Java의 Class와 같은 개념으로 인식 할 수 있습니다.\nContainer는 Image를 기반으로 생성된 격리 된 실행환경이라 했습니다. 그리고 Container를 실행 할 경우 파라미터를 통해 Container 내부 설정정보를 변경 할 수도 있습니다.\n이는 Class를 바탕으로 만들어진 Instance의 개념으로 이해 할 수 있습니다.\n이처럼 Java의 Class와 Instance의 관계로 이해한다면, Docker에서의 Image와 Container 관계에 대해 어렵지 않게 이해 할 수 있을 것 같습니다.\n\n![docking-image](./docking-image.png)\n\n도킹에 성공한 Container는 Host OS에 설치 된 프로그램 처럼 사용할 수 있다.\n\n\n\n# Docker vs Virtual Machine\n\n위에서 설명하길 \"Docker란 **Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼**입니다.\" 라고 이야기 하였습니다.\n가상화라고 하면 대표적인 예가 Virtual Machine 즉 VM을 떠올릴 수 있는데요.\n\nVM과 Docker는 몇가지 차이점이 있습니다.\n먼저 그림으로 그 구조를 확인해 보겠습니다.\n\n![vm-vs-docker](./vm-vs-docker.png)\n\n먼저 VM의 가상화 방식은 기존의 `Host OS위에 Hyper Visor를 이용`하여 가상화 OS를 띄우는 방식으로 많이 구현했습니다.\n주로 Windows에서 VMWare, Virtual Box, Hyper-V등 가상화 도구를 이용해 Guest OS를 설치하고 그 OS 위에 우리가 사용하고자 하는 프로그램을 설치하여 사용하였습니다.\n\n이러한 방식은 `완벽한 수준의 격리`이며, Host OS에서 Guest OS의 프로그램을 직접적으로 제어할 수 없습니다\n또한 Host OS에서 할당한 자원(Resource)밖에 사용할 수 없기 때문에 Host OS에서도 가상 OS에 점유한 자원을 유동적으로 사용할 수 없어 낭비가 생깁니다.\n\n반면에 Container 방식은 **기존의 Host OS위에 Docker를 이용하여 해당 프로그램의 의존성 라이브러리(프로그램 구동에 필요한 라이브러리)만 가지고 Container가 생성**됩니다. 그렇기에 `최소한의 용량으로 이미지를 구성` 할 수 있습니다.\nVM에서 사용되는 OS나 Kernel이 없기 때문에 부팅을 할 필요도 없으며, Host OS의 Resource 또한 유동적으로 사용할 수 있어 자원관리가 효율적입니다.\n\n단순히 프로세스를 격리시키는 것이기 때문에 `VM에 비해 매우 빠르게 동작`합니다.\n단점인 부분은 **Host OS에 종속적인 부분이 있습니다.** \nVM방식의 경우 각각의 OS에 대한 독립성을 가지고 있어, Host OS에 대해 독립적입니다. (예를들어 Host OS가 리눅스이고, Guest OS가 Windows인 경우, MSSQL을 Guest OS에서 사용할 수 있다)\n하지만 Container방식은 Host OS의 자원을 기반으로 생성 되기 때문에 `Host OS에서 작동할 수 없는 프로그램은 Container 내부에서 작동 할 수 없습니다.`\n\n\n\n# Docker for XX\n\nDocker는 리눅스 컨테이너 기반으로 동작하지만 최근 Windows와 Mac에 대해서도 Docker를 지원하고 있습니다.\n하지만 Linux기반 Docker와 조금 차이점이 있습니다.\n아무래도 Linux 기반 컨테이너이기 때문에 Windows에서는 Hyper-V에 리눅스를 설치하여 연동되게 되어있습니다.\n이 경우 Host OS가 Windows가 되는 것이 아니라, Hyper-V의 리눅스가 Host OS가 되는 것이기 때문에 Hyper-V에 할당된 메모리와 디스크 용량을 기반으로 자원을 활용하게 됩니다.\nLinux가 아닌 다른 운영체제에서 Docker 설치 시 유의해야 할 부분입니다.\n\n\n\n# 참고\n\n* <http://www.sauru.so/blog/getting-started-with-docker/>\n\n* <http://www.sauru.so/blog/getting-started-with-docker/>     \n* <https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html>\n\n* <https://www.docker.com/enterprise-edition#/platform>\n\n","slug":"2018-11-25-docker-1","published":1,"updated":"2018-11-27T07:23:32.383Z","comments":1,"photos":[],"link":"","_id":"cjp55h5gj00084f1t03dqnd9c","content":"<h1><span id=\"docker란-무엇인가\">Docker란 무엇인가?</span></h1>\n<p><img src=\"./docker-logo.png\" alt=\"docker-logo\"></p>\n<p>Docker란 <strong>Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼</strong> 입니다.</p>\n<p>위의 Docker 이미지처럼 선박에 화물을 수송하는 이미지를 떠올리면 이해하기가 쉬운데, 실제 선박에는 자동차, 오토바이, 전자제품등 여러 물건을 담을 수 있습니다.</p>\n<p>선박에 대한 이미지를 유지한 채, Web Service 운영환경을 생각해 보면…<br>\nWeb Service 운영환경을 구성하기 위해서는 Web Application이 구동 될 수 있는 WAS와 DataBase가 필요합니다.</p>\n<p>이 2가지 프로그램을 Docker라는 선박에 담는다고 생각해 봅시다.<br>\n그 다음 우리가 배포할 서버를 항구(Port)라고 생각하고,<br>\n각 서버에 Web Service 운영환경을 싣고 있는 선박을 정착 시켜 서버에서 접근가능한 서비스로 이용할 수 있습니다. 따라서 어떤 서버에서도 Docker만 설치되어 있다면, 다양한 <code>프로그램과 실행환경을 추상화 하여 동일한 인터페이스를 제공</code>하고 서버관리를 쉽고 단순하게 만들어 줄 수 있습니다.</p>\n<p>Docker에서는 <code>Image</code>와 <code>Container</code>라는 개념을 사용하는데, 이 두 가지 개념에 대해 알아보도록 하겠습니다.</p>\n<h1><span id=\"docker-image\">Docker Image</span></h1>\n<p><img src=\"./docker-image.png\" alt=\"docker-image\"></p>\n<p>Docker Image는 우리가 사용할 프로그램을 추상화 한 개념입니다.</p>\n<p>Image에는 Container 실행에 필요한 파일(redis.conf, redis.log…, docker-entrypoing.sh등)등을 포함하고,<br>\n설정값(port, env, data directory등) 정보를 포함하고 있습니다.<br>\n<code>1개의 이미지</code>를 바탕으로<code>여러 개의 컨테이너</code>를 만들 수 있습니다.<br>\n(ex. 하나의 Redis 이미지를 바탕으로 3개의 Redis Container를 구성하여 Cluster환경을 구성할 수 있습니다.)<br>\n이 내용을 좀 더 쉽게 이해하자면, 한번 쯤은 WM에 Linux를 설치 해 본 경험이 있을텐데, Linux를 설치 하기 위해선 linux.iso 파일이 필요 합니다.<br>\n이때 iso파일이 Linux를 구성하기 위한 파일과 설정 정보를 담고 있고 VM에 Linux를 설치 할 수 있게 해줍니다.<br>\n여기서 <code>iso파일</code>을 <code>Image</code>라고 생각하고, <code>VM위에 설치되는 리눅스</code>를 <code>Container</code>라고 이해 할 수 있겠습니다.</p>\n<p>Docker를 이용한 운영 배포 시, 이미지를 <code>Docker Hub</code>라는 곳에 올려 각 서버에서 받아 사용할 수 있습니다.<br>\n(Docker Hub는 github나 maven repository 같은 클라우드 저장소 같은 개념으로 이해 하시면 됩니다.)</p>\n<h1><span id=\"docker-container\">Docker Container</span></h1>\n<p>Container란, <strong>프로그램의 실행에 필요한 실행환경을 독립적으로 운용할 수 있도록, 다른 실행환경과의 간섭을 막고 독립성을 확보해 주는 운영체제 수준의 격리 기술</strong>을 의미합니다.</p>\n<p>이러한 격리된 환경이 필요한 경우를 생각해 볼 수 있는데, 극단적인 예시로 Java 1.6 환경에서만 실행되는 프로그램과 Java 1.8이상 환경에서만 실행 되는 프로그램을 하나의 서버에 설치한다고 가정하겠습니다.</p>\n<p>프로그램이 실행 되기 위해서는 운영체제에 설치 된 라이브러리의 대해 의존성을 가질 수 밖에 없는데, 하나의 OS에서 Java Version에 대한 격리 환경을 가지게 하는 것은 상당히 번거로운 일입니다.<br>\n이러한 경우 Docker를 사용하면 격리된 구역에서 실행 환경을 만들어 줄 수 있기 때문에 타 시스템에 영향을 주지 않고 안정적으로 운영환경을 구성 할 수 있습니다.</p>\n<p>Docker을 처음 공부할 때 Image와 Container 관계가 무척이나 헷갈렸는데… 예시를 통해 이해해 보겠습니다.<br>\nImage는 실행 환경에 대한 파일과 설정 정보를 담고 있다고 했습니다. 그리고 프로그램을 추상화 한 개념이라고 하였습니다.<br>\n이는 Java의 Class와 같은 개념으로 인식 할 수 있습니다.<br>\nContainer는 Image를 기반으로 생성된 격리 된 실행환경이라 했습니다. 그리고 Container를 실행 할 경우 파라미터를 통해 Container 내부 설정정보를 변경 할 수도 있습니다.<br>\n이는 Class를 바탕으로 만들어진 Instance의 개념으로 이해 할 수 있습니다.<br>\n이처럼 Java의 Class와 Instance의 관계로 이해한다면, Docker에서의 Image와 Container 관계에 대해 어렵지 않게 이해 할 수 있을 것 같습니다.</p>\n<p><img src=\"./docking-image.png\" alt=\"docking-image\"></p>\n<p>도킹에 성공한 Container는 Host OS에 설치 된 프로그램 처럼 사용할 수 있다.</p>\n<h1><span id=\"docker-vs-virtual-machine\">Docker vs Virtual Machine</span></h1>\n<p>위에서 설명하길 “Docker란 <strong>Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼</strong>입니다.” 라고 이야기 하였습니다.<br>\n가상화라고 하면 대표적인 예가 Virtual Machine 즉 VM을 떠올릴 수 있는데요.</p>\n<p>VM과 Docker는 몇가지 차이점이 있습니다.<br>\n먼저 그림으로 그 구조를 확인해 보겠습니다.</p>\n<p><img src=\"./vm-vs-docker.png\" alt=\"vm-vs-docker\"></p>\n<p>먼저 VM의 가상화 방식은 기존의 <code>Host OS위에 Hyper Visor를 이용</code>하여 가상화 OS를 띄우는 방식으로 많이 구현했습니다.<br>\n주로 Windows에서 VMWare, Virtual Box, Hyper-V등 가상화 도구를 이용해 Guest OS를 설치하고 그 OS 위에 우리가 사용하고자 하는 프로그램을 설치하여 사용하였습니다.</p>\n<p>이러한 방식은 <code>완벽한 수준의 격리</code>이며, Host OS에서 Guest OS의 프로그램을 직접적으로 제어할 수 없습니다<br>\n또한 Host OS에서 할당한 자원(Resource)밖에 사용할 수 없기 때문에 Host OS에서도 가상 OS에 점유한 자원을 유동적으로 사용할 수 없어 낭비가 생깁니다.</p>\n<p>반면에 Container 방식은 <strong>기존의 Host OS위에 Docker를 이용하여 해당 프로그램의 의존성 라이브러리(프로그램 구동에 필요한 라이브러리)만 가지고 Container가 생성</strong>됩니다. 그렇기에 <code>최소한의 용량으로 이미지를 구성</code> 할 수 있습니다.<br>\nVM에서 사용되는 OS나 Kernel이 없기 때문에 부팅을 할 필요도 없으며, Host OS의 Resource 또한 유동적으로 사용할 수 있어 자원관리가 효율적입니다.</p>\n<p>단순히 프로세스를 격리시키는 것이기 때문에 <code>VM에 비해 매우 빠르게 동작</code>합니다.<br>\n단점인 부분은 <strong>Host OS에 종속적인 부분이 있습니다.</strong><br>\nVM방식의 경우 각각의 OS에 대한 독립성을 가지고 있어, Host OS에 대해 독립적입니다. (예를들어 Host OS가 리눅스이고, Guest OS가 Windows인 경우, MSSQL을 Guest OS에서 사용할 수 있다)<br>\n하지만 Container방식은 Host OS의 자원을 기반으로 생성 되기 때문에 <code>Host OS에서 작동할 수 없는 프로그램은 Container 내부에서 작동 할 수 없습니다.</code></p>\n<h1><span id=\"docker-for-xx\">Docker for XX</span></h1>\n<p>Docker는 리눅스 컨테이너 기반으로 동작하지만 최근 Windows와 Mac에 대해서도 Docker를 지원하고 있습니다.<br>\n하지만 Linux기반 Docker와 조금 차이점이 있습니다.<br>\n아무래도 Linux 기반 컨테이너이기 때문에 Windows에서는 Hyper-V에 리눅스를 설치하여 연동되게 되어있습니다.<br>\n이 경우 Host OS가 Windows가 되는 것이 아니라, Hyper-V의 리눅스가 Host OS가 되는 것이기 때문에 Hyper-V에 할당된 메모리와 디스크 용량을 기반으로 자원을 활용하게 됩니다.<br>\nLinux가 아닌 다른 운영체제에서 Docker 설치 시 유의해야 할 부분입니다.</p>\n<h1><span id=\"참고\">참고</span></h1>\n<ul>\n<li>\n<p><a href=\"http://www.sauru.so/blog/getting-started-with-docker/\" target=\"_blank\" rel=\"noopener\">http://www.sauru.so/blog/getting-started-with-docker/</a></p>\n</li>\n<li>\n<p><a href=\"http://www.sauru.so/blog/getting-started-with-docker/\" target=\"_blank\" rel=\"noopener\">http://www.sauru.so/blog/getting-started-with-docker/</a></p>\n</li>\n<li>\n<p><a href=\"https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html\" target=\"_blank\" rel=\"noopener\">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p>\n</li>\n<li>\n<p><a href=\"https://www.docker.com/enterprise-edition#/platform\" target=\"_blank\" rel=\"noopener\">https://www.docker.com/enterprise-edition#/platform</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>Docker란 무엇인가?</h1>\n<p><img src=\"./docker-logo.png\" alt=\"docker-logo\"></p>\n<p>Docker란 <strong>Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼</strong> 입니다.</p>\n<p>위의 Docker 이미지처럼 선박에 화물을 수송하는 이미지를 떠올리면 이해하기가 쉬운데, 실제 선박에는 자동차, 오토바이, 전자제품등 여러 물건을 담을 수 있습니다.</p>\n<p>선박에 대한 이미지를 유지한 채, Web Service 운영환경을 생각해 보면…<br>\nWeb Service 운영환경을 구성하기 위해서는 Web Application이 구동 될 수 있는 WAS와 DataBase가 필요합니다.</p>\n<p>이 2가지 프로그램을 Docker라는 선박에 담는다고 생각해 봅시다.<br>\n그 다음 우리가 배포할 서버를 항구(Port)라고 생각하고,<br>\n각 서버에 Web Service 운영환경을 싣고 있는 선박을 정착 시켜 서버에서 접근가능한 서비스로 이용할 수 있습니다. 따라서 어떤 서버에서도 Docker만 설치되어 있다면, 다양한 <code>프로그램과 실행환경을 추상화 하여 동일한 인터페이스를 제공</code>하고 서버관리를 쉽고 단순하게 만들어 줄 수 있습니다.</p>\n<p>Docker에서는 <code>Image</code>와 <code>Container</code>라는 개념을 사용하는데, 이 두 가지 개념에 대해 알아보도록 하겠습니다.</p>\n<h1>Docker Image</h1>\n<p><img src=\"./docker-image.png\" alt=\"docker-image\"></p>\n<p>Docker Image는 우리가 사용할 프로그램을 추상화 한 개념입니다.</p>\n<p>Image에는 Container 실행에 필요한 파일(redis.conf, redis.log…, docker-entrypoing.sh등)등을 포함하고,<br>\n설정값(port, env, data directory등) 정보를 포함하고 있습니다.<br>\n<code>1개의 이미지</code>를 바탕으로<code>여러 개의 컨테이너</code>를 만들 수 있습니다.<br>\n(ex. 하나의 Redis 이미지를 바탕으로 3개의 Redis Container를 구성하여 Cluster환경을 구성할 수 있습니다.)<br>\n이 내용을 좀 더 쉽게 이해하자면, 한번 쯤은 WM에 Linux를 설치 해 본 경험이 있을텐데, Linux를 설치 하기 위해선 linux.iso 파일이 필요 합니다.<br>\n이때 iso파일이 Linux를 구성하기 위한 파일과 설정 정보를 담고 있고 VM에 Linux를 설치 할 수 있게 해줍니다.<br>\n여기서 <code>iso파일</code>을 <code>Image</code>라고 생각하고, <code>VM위에 설치되는 리눅스</code>를 <code>Container</code>라고 이해 할 수 있겠습니다.</p>\n<p>Docker를 이용한 운영 배포 시, 이미지를 <code>Docker Hub</code>라는 곳에 올려 각 서버에서 받아 사용할 수 있습니다.<br>\n(Docker Hub는 github나 maven repository 같은 클라우드 저장소 같은 개념으로 이해 하시면 됩니다.)</p>\n<h1>Docker Container</h1>\n<p>Container란, <strong>프로그램의 실행에 필요한 실행환경을 독립적으로 운용할 수 있도록, 다른 실행환경과의 간섭을 막고 독립성을 확보해 주는 운영체제 수준의 격리 기술</strong>을 의미합니다.</p>\n<p>이러한 격리된 환경이 필요한 경우를 생각해 볼 수 있는데, 극단적인 예시로 Java 1.6 환경에서만 실행되는 프로그램과 Java 1.8이상 환경에서만 실행 되는 프로그램을 하나의 서버에 설치한다고 가정하겠습니다.</p>\n<p>프로그램이 실행 되기 위해서는 운영체제에 설치 된 라이브러리의 대해 의존성을 가질 수 밖에 없는데, 하나의 OS에서 Java Version에 대한 격리 환경을 가지게 하는 것은 상당히 번거로운 일입니다.<br>\n이러한 경우 Docker를 사용하면 격리된 구역에서 실행 환경을 만들어 줄 수 있기 때문에 타 시스템에 영향을 주지 않고 안정적으로 운영환경을 구성 할 수 있습니다.</p>\n<p>Docker을 처음 공부할 때 Image와 Container 관계가 무척이나 헷갈렸는데… 예시를 통해 이해해 보겠습니다.<br>\nImage는 실행 환경에 대한 파일과 설정 정보를 담고 있다고 했습니다. 그리고 프로그램을 추상화 한 개념이라고 하였습니다.<br>\n이는 Java의 Class와 같은 개념으로 인식 할 수 있습니다.<br>\nContainer는 Image를 기반으로 생성된 격리 된 실행환경이라 했습니다. 그리고 Container를 실행 할 경우 파라미터를 통해 Container 내부 설정정보를 변경 할 수도 있습니다.<br>\n이는 Class를 바탕으로 만들어진 Instance의 개념으로 이해 할 수 있습니다.<br>\n이처럼 Java의 Class와 Instance의 관계로 이해한다면, Docker에서의 Image와 Container 관계에 대해 어렵지 않게 이해 할 수 있을 것 같습니다.</p>\n<p><img src=\"./docking-image.png\" alt=\"docking-image\"></p>\n<p>도킹에 성공한 Container는 Host OS에 설치 된 프로그램 처럼 사용할 수 있다.</p>\n<h1>Docker vs Virtual Machine</h1>\n<p>위에서 설명하길 “Docker란 <strong>Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼</strong>입니다.” 라고 이야기 하였습니다.<br>\n가상화라고 하면 대표적인 예가 Virtual Machine 즉 VM을 떠올릴 수 있는데요.</p>\n<p>VM과 Docker는 몇가지 차이점이 있습니다.<br>\n먼저 그림으로 그 구조를 확인해 보겠습니다.</p>\n<p><img src=\"./vm-vs-docker.png\" alt=\"vm-vs-docker\"></p>\n<p>먼저 VM의 가상화 방식은 기존의 <code>Host OS위에 Hyper Visor를 이용</code>하여 가상화 OS를 띄우는 방식으로 많이 구현했습니다.<br>\n주로 Windows에서 VMWare, Virtual Box, Hyper-V등 가상화 도구를 이용해 Guest OS를 설치하고 그 OS 위에 우리가 사용하고자 하는 프로그램을 설치하여 사용하였습니다.</p>\n<p>이러한 방식은 <code>완벽한 수준의 격리</code>이며, Host OS에서 Guest OS의 프로그램을 직접적으로 제어할 수 없습니다<br>\n또한 Host OS에서 할당한 자원(Resource)밖에 사용할 수 없기 때문에 Host OS에서도 가상 OS에 점유한 자원을 유동적으로 사용할 수 없어 낭비가 생깁니다.</p>\n<p>반면에 Container 방식은 <strong>기존의 Host OS위에 Docker를 이용하여 해당 프로그램의 의존성 라이브러리(프로그램 구동에 필요한 라이브러리)만 가지고 Container가 생성</strong>됩니다. 그렇기에 <code>최소한의 용량으로 이미지를 구성</code> 할 수 있습니다.<br>\nVM에서 사용되는 OS나 Kernel이 없기 때문에 부팅을 할 필요도 없으며, Host OS의 Resource 또한 유동적으로 사용할 수 있어 자원관리가 효율적입니다.</p>\n<p>단순히 프로세스를 격리시키는 것이기 때문에 <code>VM에 비해 매우 빠르게 동작</code>합니다.<br>\n단점인 부분은 <strong>Host OS에 종속적인 부분이 있습니다.</strong><br>\nVM방식의 경우 각각의 OS에 대한 독립성을 가지고 있어, Host OS에 대해 독립적입니다. (예를들어 Host OS가 리눅스이고, Guest OS가 Windows인 경우, MSSQL을 Guest OS에서 사용할 수 있다)<br>\n하지만 Container방식은 Host OS의 자원을 기반으로 생성 되기 때문에 <code>Host OS에서 작동할 수 없는 프로그램은 Container 내부에서 작동 할 수 없습니다.</code></p>\n<h1>Docker for XX</h1>\n<p>Docker는 리눅스 컨테이너 기반으로 동작하지만 최근 Windows와 Mac에 대해서도 Docker를 지원하고 있습니다.<br>\n하지만 Linux기반 Docker와 조금 차이점이 있습니다.<br>\n아무래도 Linux 기반 컨테이너이기 때문에 Windows에서는 Hyper-V에 리눅스를 설치하여 연동되게 되어있습니다.<br>\n이 경우 Host OS가 Windows가 되는 것이 아니라, Hyper-V의 리눅스가 Host OS가 되는 것이기 때문에 Hyper-V에 할당된 메모리와 디스크 용량을 기반으로 자원을 활용하게 됩니다.<br>\nLinux가 아닌 다른 운영체제에서 Docker 설치 시 유의해야 할 부분입니다.</p>\n<h1>참고</h1>\n<ul>\n<li>\n<p><a href=\"http://www.sauru.so/blog/getting-started-with-docker/\" target=\"_blank\" rel=\"noopener\">http://www.sauru.so/blog/getting-started-with-docker/</a></p>\n</li>\n<li>\n<p><a href=\"http://www.sauru.so/blog/getting-started-with-docker/\" target=\"_blank\" rel=\"noopener\">http://www.sauru.so/blog/getting-started-with-docker/</a></p>\n</li>\n<li>\n<p><a href=\"https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html\" target=\"_blank\" rel=\"noopener\">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p>\n</li>\n<li>\n<p><a href=\"https://www.docker.com/enterprise-edition#/platform\" target=\"_blank\" rel=\"noopener\">https://www.docker.com/enterprise-edition#/platform</a></p>\n</li>\n</ul>\n"},{"title":"EHCache 설정방법 (Spring Boot)","catalog":true,"Categories":["Spring"],"typora-root-url":"2018-11-04-ehcache-config-for-springboot","typora-copy-images-to":"2018-11-04-ehcache-config-for-springboot","date":"2018-11-07T14:38:43.000Z","header-img":null,"_content":"\n# EHCache 설정하기\n\n설정 순서는 아래와 같다.\n\n1. Maven Dependency 설정\n2. Ehcache.xml 작성 (ehcache 설정파일)\n3. @EnableCaching 설정\n\n\n\n# Maven Dependency 설정\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n    <version>2.10.6</version>\n</dependency>\n```\n\n# Ehcache.xml 작성 (ehcache 설정파일)\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         maxBytesLocalHeap=\"300M\" <!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 -->\n         updateCheck=\"false\">\n\n    <!-- 임시저장 경로를 설정 -->\n    <diskStore path=\"java.io.tmpdir\" />\n    <!-- \n        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,\n        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색\n        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환\n    -->\n    <sizeOfPolicy maxDepth=\"100000\" maxDepthExceededBehavior=\"continue\"/>\n\n   <!-- default Cache 설정 (반드시 선언해야 하는 Cache) -->\n    <defaultCache\n            eternal=\"false\"\n            timeToIdleSeconds=\"0\"\n            timeToLiveSeconds=\"1200\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n\n    <!-- 사용하고자 하는 캐시 별 설정 -->\n    <cache name=\"LocalCacheData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n\n   <cache name=\"AuthMemberList\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n</ehcache>\n~~~\n\n* defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)\n* cache는 하나의 캐시를 사용할 때마다 구현\n* name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.\n\n| 속성                            | 설명 | Default |\n| ------------------------------- | ---- | ------------------------------- |\n| name                            | 코드에서 사용할 캐시 name | 필수 |\n|  maxEntriesLocalHeap                                   |메모리에 생성 될 최대 캐시 갯수| 0 |\n|  maxEntriesLocalDisk                                  |디스크에 생성 될 최대 캐시 갯수| 0 |\n| eternal                         | 영속성 캐시 설정 (지워지는 캐시인지?) <br />external = \"true\"이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨 | false |\n| timeToIdleSecond                | 해당 초동안 캐시가 호출 되지 않으면 삭제 | 0 |\n| timeToLiveSeconds               | 해당 초가 지나면 캐시가 삭제 | 0 |\n| overflowToDisk                  | 오버플로우 된 항목에 대해 disk에 저장할 지 여부 | false |\n| diskPersistent                  | 캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정 | false |\n| diskExpiryThreadIntervalSeconds | Disk Expiry 스레드의 작업 수행 간격 설정 | 0 |\n| memoryStoreEvictionPolicy | 캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br />LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br />LFU : 호출 빈도가 가장 적은 캐시를 삭제<br />FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제 | LRU |\n\n \n\n\n#@EnableCaching 설정 \n\n~~~java\n@Configuration\n@EnableCaching(proxyTargetClass = true, mode = AdviceMode.PROXY)\npublic class EHCacheConfig {\n    @Bean\n    public EhCacheManagerFactoryBean ehCacheManagerFactoryBean() {\n        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = new EhCacheManagerFactoryBean();\n        ehCacheManagerFactoryBean.setConfigLocation(new ClassPathResource(\"config/ehcache.xml\"));\n        ehCacheManagerFactoryBean.setShared(true);\n        return ehCacheManagerFactoryBean;\n    }\n\n    @Bean\n    public EhCacheCacheManager ehCacheCacheManager(EhCacheManagerFactoryBean ehCacheManagerFactoryBean) {\n        EhCacheCacheManager ehCacheCacheManager = new EhCacheCacheManager();\n        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());\n        return ehCacheCacheManager;\n    }\n}\n~~~\n\n* @EnableCaching Annotation은 `<cache:annotation-driven>`와 마찬가지로 어노테이션 기반 캐시를 사용 할 수 있는 설정\n* 내부적으로 Spring AOP를 통해 @Cacheable, @CacheEvict와 같은 어노테이션을 Pointcut으로 이용해서 Cache기능을 구현하는 듯 하다.\n* proxyTargetClass : class 기반 프록시를 생성함을 의미 (CGLIB라이브러리에 대한 의존성 필요)\n* Mode : 어떤 Advisor 모듈을 선택할지에 대한 설정 \n  * PROXY : Spring AOP Proxy방식을 이용\n  * ASPECTJ : LTW, CTW기능을 이용한 위빙","source":"_posts/2018-11-04-ehcache-config-for-springboot.md","raw":"---\ntitle: EHCache 설정방법 (Spring Boot)\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\n  - Spring Boot\n  - EHCache\ntypora-root-url: 2018-11-04-ehcache-config-for-springboot\ntypora-copy-images-to: 2018-11-04-ehcache-config-for-springboot\ndate: 2018-11-07 23:38:43\nheader-img:\n---\n\n# EHCache 설정하기\n\n설정 순서는 아래와 같다.\n\n1. Maven Dependency 설정\n2. Ehcache.xml 작성 (ehcache 설정파일)\n3. @EnableCaching 설정\n\n\n\n# Maven Dependency 설정\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n    <version>2.10.6</version>\n</dependency>\n```\n\n# Ehcache.xml 작성 (ehcache 설정파일)\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         maxBytesLocalHeap=\"300M\" <!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 -->\n         updateCheck=\"false\">\n\n    <!-- 임시저장 경로를 설정 -->\n    <diskStore path=\"java.io.tmpdir\" />\n    <!-- \n        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,\n        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색\n        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환\n    -->\n    <sizeOfPolicy maxDepth=\"100000\" maxDepthExceededBehavior=\"continue\"/>\n\n   <!-- default Cache 설정 (반드시 선언해야 하는 Cache) -->\n    <defaultCache\n            eternal=\"false\"\n            timeToIdleSeconds=\"0\"\n            timeToLiveSeconds=\"1200\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n\n    <!-- 사용하고자 하는 캐시 별 설정 -->\n    <cache name=\"LocalCacheData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n\n   <cache name=\"AuthMemberList\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n</ehcache>\n~~~\n\n* defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)\n* cache는 하나의 캐시를 사용할 때마다 구현\n* name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.\n\n| 속성                            | 설명 | Default |\n| ------------------------------- | ---- | ------------------------------- |\n| name                            | 코드에서 사용할 캐시 name | 필수 |\n|  maxEntriesLocalHeap                                   |메모리에 생성 될 최대 캐시 갯수| 0 |\n|  maxEntriesLocalDisk                                  |디스크에 생성 될 최대 캐시 갯수| 0 |\n| eternal                         | 영속성 캐시 설정 (지워지는 캐시인지?) <br />external = \"true\"이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨 | false |\n| timeToIdleSecond                | 해당 초동안 캐시가 호출 되지 않으면 삭제 | 0 |\n| timeToLiveSeconds               | 해당 초가 지나면 캐시가 삭제 | 0 |\n| overflowToDisk                  | 오버플로우 된 항목에 대해 disk에 저장할 지 여부 | false |\n| diskPersistent                  | 캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정 | false |\n| diskExpiryThreadIntervalSeconds | Disk Expiry 스레드의 작업 수행 간격 설정 | 0 |\n| memoryStoreEvictionPolicy | 캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br />LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br />LFU : 호출 빈도가 가장 적은 캐시를 삭제<br />FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제 | LRU |\n\n \n\n\n#@EnableCaching 설정 \n\n~~~java\n@Configuration\n@EnableCaching(proxyTargetClass = true, mode = AdviceMode.PROXY)\npublic class EHCacheConfig {\n    @Bean\n    public EhCacheManagerFactoryBean ehCacheManagerFactoryBean() {\n        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = new EhCacheManagerFactoryBean();\n        ehCacheManagerFactoryBean.setConfigLocation(new ClassPathResource(\"config/ehcache.xml\"));\n        ehCacheManagerFactoryBean.setShared(true);\n        return ehCacheManagerFactoryBean;\n    }\n\n    @Bean\n    public EhCacheCacheManager ehCacheCacheManager(EhCacheManagerFactoryBean ehCacheManagerFactoryBean) {\n        EhCacheCacheManager ehCacheCacheManager = new EhCacheCacheManager();\n        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());\n        return ehCacheCacheManager;\n    }\n}\n~~~\n\n* @EnableCaching Annotation은 `<cache:annotation-driven>`와 마찬가지로 어노테이션 기반 캐시를 사용 할 수 있는 설정\n* 내부적으로 Spring AOP를 통해 @Cacheable, @CacheEvict와 같은 어노테이션을 Pointcut으로 이용해서 Cache기능을 구현하는 듯 하다.\n* proxyTargetClass : class 기반 프록시를 생성함을 의미 (CGLIB라이브러리에 대한 의존성 필요)\n* Mode : 어떤 Advisor 모듈을 선택할지에 대한 설정 \n  * PROXY : Spring AOP Proxy방식을 이용\n  * ASPECTJ : LTW, CTW기능을 이용한 위빙","slug":"2018-11-04-ehcache-config-for-springboot","published":1,"updated":"2018-11-27T07:23:32.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp55h5go000b4f1t5o6yhtiy","content":"<h1><span id=\"ehcache-설정하기\">EHCache 설정하기</span></h1>\n<p>설정 순서는 아래와 같다.</p>\n<ol>\n<li>Maven Dependency 설정</li>\n<li>Ehcache.xml 작성 (ehcache 설정파일)</li>\n<li>@EnableCaching 설정</li>\n</ol>\n<h1><span id=\"maven-dependency-설정\">Maven Dependency 설정</span></h1>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.sf.ehcache<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ehcache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.10.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"ehcachexml-작성-ehcache-설정파일\">Ehcache.xml 작성 (ehcache 설정파일)</span></h1>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://ehcache.org/ehcache.xsd\"</span></span></span><br><span class=\"line\">         maxBytesLocalHeap=\"300M\" &lt;!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 --&gt;</span><br><span class=\"line\">         updateCheck=\"false\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 임시저장 경로를 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sizeOfPolicy</span> <span class=\"attr\">maxDepth</span>=<span class=\"string\">\"100000\"</span> <span class=\"attr\">maxDepthExceededBehavior</span>=<span class=\"string\">\"continue\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">&lt;!-- default Cache 설정 (반드시 선언해야 하는 Cache) --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultCache</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">defaultCache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 사용하고자 하는 캐시 별 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"LocalCacheData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"AuthMemberList\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)</li>\n<li>cache는 하나의 캐시를 사용할 때마다 구현</li>\n<li>name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>코드에서 사용할 캐시 name</td>\n<td>필수</td>\n</tr>\n<tr>\n<td>maxEntriesLocalHeap</td>\n<td>메모리에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>maxEntriesLocalDisk</td>\n<td>디스크에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>eternal</td>\n<td>영속성 캐시 설정 (지워지는 캐시인지?) <br>external = &quot;true&quot;이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨</td>\n<td>false</td>\n</tr>\n<tr>\n<td>timeToIdleSecond</td>\n<td>해당 초동안 캐시가 호출 되지 않으면 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>timeToLiveSeconds</td>\n<td>해당 초가 지나면 캐시가 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>overflowToDisk</td>\n<td>오버플로우 된 항목에 대해 disk에 저장할 지 여부</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskPersistent</td>\n<td>캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskExpiryThreadIntervalSeconds</td>\n<td>Disk Expiry 스레드의 작업 수행 간격 설정</td>\n<td>0</td>\n</tr>\n<tr>\n<td>memoryStoreEvictionPolicy</td>\n<td>캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br>LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br>LFU : 호출 빈도가 가장 적은 캐시를 삭제<br>FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제</td>\n<td>LRU</td>\n</tr>\n</tbody>\n</table>\n<p>#@EnableCaching 설정</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>, mode = AdviceMode.PROXY)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheManagerFactoryBean <span class=\"title\">ehCacheManagerFactoryBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = <span class=\"keyword\">new</span> EhCacheManagerFactoryBean();</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setConfigLocation(<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">\"config/ehcache.xml\"</span>));</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setShared(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheManagerFactoryBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheCacheManager <span class=\"title\">ehCacheCacheManager</span><span class=\"params\">(EhCacheManagerFactoryBean ehCacheManagerFactoryBean)</span> </span>&#123;</span><br><span class=\"line\">        EhCacheCacheManager ehCacheCacheManager = <span class=\"keyword\">new</span> EhCacheCacheManager();</span><br><span class=\"line\">        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheCacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@EnableCaching Annotation은 <code>&lt;cache:annotation-driven&gt;</code>와 마찬가지로 어노테이션 기반 캐시를 사용 할 수 있는 설정</li>\n<li>내부적으로 Spring AOP를 통해 @Cacheable, @CacheEvict와 같은 어노테이션을 Pointcut으로 이용해서 Cache기능을 구현하는 듯 하다.</li>\n<li>proxyTargetClass : class 기반 프록시를 생성함을 의미 (CGLIB라이브러리에 대한 의존성 필요)</li>\n<li>Mode : 어떤 Advisor 모듈을 선택할지에 대한 설정\n<ul>\n<li>PROXY : Spring AOP Proxy방식을 이용</li>\n<li>ASPECTJ : LTW, CTW기능을 이용한 위빙</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>EHCache 설정하기</h1>\n<p>설정 순서는 아래와 같다.</p>\n<ol>\n<li>Maven Dependency 설정</li>\n<li>Ehcache.xml 작성 (ehcache 설정파일)</li>\n<li>@EnableCaching 설정</li>\n</ol>\n<h1>Maven Dependency 설정</h1>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.sf.ehcache<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ehcache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.10.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1>Ehcache.xml 작성 (ehcache 설정파일)</h1>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://ehcache.org/ehcache.xsd\"</span></span></span><br><span class=\"line\">         maxBytesLocalHeap=\"300M\" &lt;!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 --&gt;</span><br><span class=\"line\">         updateCheck=\"false\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 임시저장 경로를 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sizeOfPolicy</span> <span class=\"attr\">maxDepth</span>=<span class=\"string\">\"100000\"</span> <span class=\"attr\">maxDepthExceededBehavior</span>=<span class=\"string\">\"continue\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">&lt;!-- default Cache 설정 (반드시 선언해야 하는 Cache) --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultCache</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">defaultCache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 사용하고자 하는 캐시 별 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"LocalCacheData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"AuthMemberList\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)</li>\n<li>cache는 하나의 캐시를 사용할 때마다 구현</li>\n<li>name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>코드에서 사용할 캐시 name</td>\n<td>필수</td>\n</tr>\n<tr>\n<td>maxEntriesLocalHeap</td>\n<td>메모리에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>maxEntriesLocalDisk</td>\n<td>디스크에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>eternal</td>\n<td>영속성 캐시 설정 (지워지는 캐시인지?) <br>external = &quot;true&quot;이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨</td>\n<td>false</td>\n</tr>\n<tr>\n<td>timeToIdleSecond</td>\n<td>해당 초동안 캐시가 호출 되지 않으면 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>timeToLiveSeconds</td>\n<td>해당 초가 지나면 캐시가 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>overflowToDisk</td>\n<td>오버플로우 된 항목에 대해 disk에 저장할 지 여부</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskPersistent</td>\n<td>캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskExpiryThreadIntervalSeconds</td>\n<td>Disk Expiry 스레드의 작업 수행 간격 설정</td>\n<td>0</td>\n</tr>\n<tr>\n<td>memoryStoreEvictionPolicy</td>\n<td>캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br>LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br>LFU : 호출 빈도가 가장 적은 캐시를 삭제<br>FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제</td>\n<td>LRU</td>\n</tr>\n</tbody>\n</table>\n<p>#@EnableCaching 설정</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>, mode = AdviceMode.PROXY)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheManagerFactoryBean <span class=\"title\">ehCacheManagerFactoryBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = <span class=\"keyword\">new</span> EhCacheManagerFactoryBean();</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setConfigLocation(<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">\"config/ehcache.xml\"</span>));</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setShared(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheManagerFactoryBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheCacheManager <span class=\"title\">ehCacheCacheManager</span><span class=\"params\">(EhCacheManagerFactoryBean ehCacheManagerFactoryBean)</span> </span>&#123;</span><br><span class=\"line\">        EhCacheCacheManager ehCacheCacheManager = <span class=\"keyword\">new</span> EhCacheCacheManager();</span><br><span class=\"line\">        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheCacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@EnableCaching Annotation은 <code>&lt;cache:annotation-driven&gt;</code>와 마찬가지로 어노테이션 기반 캐시를 사용 할 수 있는 설정</li>\n<li>내부적으로 Spring AOP를 통해 @Cacheable, @CacheEvict와 같은 어노테이션을 Pointcut으로 이용해서 Cache기능을 구현하는 듯 하다.</li>\n<li>proxyTargetClass : class 기반 프록시를 생성함을 의미 (CGLIB라이브러리에 대한 의존성 필요)</li>\n<li>Mode : 어떤 Advisor 모듈을 선택할지에 대한 설정\n<ul>\n<li>PROXY : Spring AOP Proxy방식을 이용</li>\n<li>ASPECTJ : LTW, CTW기능을 이용한 위빙</li>\n</ul>\n</li>\n</ul>\n"},{"title":"EHCache 설정방법 (Spring Framework)","subtitle":null,"catalog":true,"Categories":["Spring"],"typora-root-url":"2018-11-04-ehcache-config-for-springframework","typora-copy-images-to":"2018-11-04-ehcache-config-for-springframework","date":"2018-11-07T14:38:22.000Z","header-img":null,"_content":"\n# EHCache 설정하기\n\n설정 순서는 아래와 같다.\n\n1. Maven Dependency 설정\n2. Ehcache.xml 작성 (ehcache 설정파일)\n3. CacheManager 설정 (xml)\n\n\n\n# Maven Dependency 설정\n\n~~~xml\n<!-- EHCache 모듈 (블로그 작성 시점에서 2.10.6이 최신이다.) -->\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n    <version>2.10.6</version> \n</dependency>\n\n<!-- Spring Caching Interface -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>4.3.20.RELEASE</version>\n</dependency>\n\n<!-- EHCache Support 모듈, 다른 Caching 지원모듈 -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context-support</artifactId>\n    <version>4.3.20.RELEASE</version>\n</dependency>\n~~~\n\n\n\n# ehcache.xml 작성\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         maxBytesLocalHeap=\"300M\" <!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 -->\n         updateCheck=\"false\">\n\n    <!-- 임시저장 경로를 설정 -->\n    <diskStore path=\"java.io.tmpdir\" />\n    <!-- \n        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,\n        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색\n        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환\n    -->\n    <sizeOfPolicy maxDepth=\"100000\" maxDepthExceededBehavior=\"continue\"/>\n\n   <!-- default Cache 설정 (반드시 선언해야 하는 Cache) -->\n    <defaultCache\n            eternal=\"false\"\n            timeToIdleSeconds=\"0\"\n            timeToLiveSeconds=\"1200\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n\n    <!-- 사용하고자 하는 캐시 별 설정 -->\n    <cache name=\"LocalCacheData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n\n   <cache name=\"AuthMemberList\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n</ehcache>\n~~~\n\n- defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)\n- cache는 하나의 캐시를 사용할 때마다 구현\n- name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.\n\n| 속성                            | 설명                                                         | Default |\n| ------------------------------- | ------------------------------------------------------------ | ------- |\n| name                            | 코드에서 사용할 캐시 name                                    | 필수    |\n| maxEntriesLocalHeap             | 메모리에 생성 될 최대 캐시 갯수                              | 0       |\n| maxEntriesLocalDisk             | 디스크에 생성 될 최대 캐시 갯수                              | 0       |\n| eternal                         | 영속성 캐시 설정 (지워지는 캐시인지?) <br />external = \"true\"이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨 | false   |\n| timeToIdleSecond                | 해당 초동안 캐시가 호출 되지 않으면 삭제                     | 0       |\n| timeToLiveSeconds               | 해당 초가 지나면 캐시가 삭제                                 | 0       |\n| overflowToDisk                  | 오버플로우 된 항목에 대해 disk에 저장할 지 여부              | false   |\n| diskPersistent                  | 캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정   | false   |\n| diskExpiryThreadIntervalSeconds | Disk Expiry 스레드의 작업 수행 간격 설정                     | 0       |\n| memoryStoreEvictionPolicy       | 캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br />LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br />LFU : 호출 빈도가 가장 적은 캐시를 삭제<br />FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제 | LRU     |\n\n \n\n# CacheManager Bean 설정\n\n~~~xml\nz<!-- Annotation 기반 캐시 사용 (@Cacheable, @CacheEvict..) -->\n<cache:annotation-driven/>\n\n<!-- EHCache 기반 CacheManager 설정 -->\n<bean id=\"cacheManager\" class=\"org.springframework.cache.ehcache.EhCacheCacheManager\">\n    <property name=\"cacheManager\" ref=\"ehcache\"/>\n</bean>\n\n<!-- ehcache.xml 설정 로드 -->\n<bean id=\"ehcache\" class=\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\">\n    <property name=\"configLocation\" value=\"classpath:config/ehcache.xml\"/>\n    <property name=\"shared\" value=\"true\"/>\n</bean>\n~~~\n\n\n\n# 참고\n\n* https://github.com/skoh/common/blob/master/common-web/src/main/resources/ehcache.xml\n* https://www.mkyong.com/spring/spring-caching-and-ehcache-example/\n* http://hyeooona825.tistory.com/86\n* http://blog.naver.com/PostView.nhn?blogId=kyung778&logNo=60164009610","source":"_posts/2018-11-04-ehcache-config-for-springframework.md","raw":"---\ntitle: EHCache 설정방법 (Spring framework)\nsubtitle:\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\n  - EHCache\ntypora-root-url: 2018-11-04-ehcache-config-for-springframework\ntypora-copy-images-to: 2018-11-04-ehcache-config-for-springframework\ndate: 2018-11-07 23:38:22\nheader-img:\n---\n\n# EHCache 설정하기\n\n설정 순서는 아래와 같다.\n\n1. Maven Dependency 설정\n2. Ehcache.xml 작성 (ehcache 설정파일)\n3. CacheManager 설정 (xml)\n\n\n\n# Maven Dependency 설정\n\n~~~xml\n<!-- EHCache 모듈 (블로그 작성 시점에서 2.10.6이 최신이다.) -->\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n    <version>2.10.6</version> \n</dependency>\n\n<!-- Spring Caching Interface -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>4.3.20.RELEASE</version>\n</dependency>\n\n<!-- EHCache Support 모듈, 다른 Caching 지원모듈 -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context-support</artifactId>\n    <version>4.3.20.RELEASE</version>\n</dependency>\n~~~\n\n\n\n# ehcache.xml 작성\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         maxBytesLocalHeap=\"300M\" <!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 -->\n         updateCheck=\"false\">\n\n    <!-- 임시저장 경로를 설정 -->\n    <diskStore path=\"java.io.tmpdir\" />\n    <!-- \n        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,\n        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색\n        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환\n    -->\n    <sizeOfPolicy maxDepth=\"100000\" maxDepthExceededBehavior=\"continue\"/>\n\n   <!-- default Cache 설정 (반드시 선언해야 하는 Cache) -->\n    <defaultCache\n            eternal=\"false\"\n            timeToIdleSeconds=\"0\"\n            timeToLiveSeconds=\"1200\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n\n    <!-- 사용하고자 하는 캐시 별 설정 -->\n    <cache name=\"LocalCacheData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n\n   <cache name=\"AuthMemberList\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n</ehcache>\n~~~\n\n- defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)\n- cache는 하나의 캐시를 사용할 때마다 구현\n- name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.\n\n| 속성                            | 설명                                                         | Default |\n| ------------------------------- | ------------------------------------------------------------ | ------- |\n| name                            | 코드에서 사용할 캐시 name                                    | 필수    |\n| maxEntriesLocalHeap             | 메모리에 생성 될 최대 캐시 갯수                              | 0       |\n| maxEntriesLocalDisk             | 디스크에 생성 될 최대 캐시 갯수                              | 0       |\n| eternal                         | 영속성 캐시 설정 (지워지는 캐시인지?) <br />external = \"true\"이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨 | false   |\n| timeToIdleSecond                | 해당 초동안 캐시가 호출 되지 않으면 삭제                     | 0       |\n| timeToLiveSeconds               | 해당 초가 지나면 캐시가 삭제                                 | 0       |\n| overflowToDisk                  | 오버플로우 된 항목에 대해 disk에 저장할 지 여부              | false   |\n| diskPersistent                  | 캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정   | false   |\n| diskExpiryThreadIntervalSeconds | Disk Expiry 스레드의 작업 수행 간격 설정                     | 0       |\n| memoryStoreEvictionPolicy       | 캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br />LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br />LFU : 호출 빈도가 가장 적은 캐시를 삭제<br />FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제 | LRU     |\n\n \n\n# CacheManager Bean 설정\n\n~~~xml\nz<!-- Annotation 기반 캐시 사용 (@Cacheable, @CacheEvict..) -->\n<cache:annotation-driven/>\n\n<!-- EHCache 기반 CacheManager 설정 -->\n<bean id=\"cacheManager\" class=\"org.springframework.cache.ehcache.EhCacheCacheManager\">\n    <property name=\"cacheManager\" ref=\"ehcache\"/>\n</bean>\n\n<!-- ehcache.xml 설정 로드 -->\n<bean id=\"ehcache\" class=\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\">\n    <property name=\"configLocation\" value=\"classpath:config/ehcache.xml\"/>\n    <property name=\"shared\" value=\"true\"/>\n</bean>\n~~~\n\n\n\n# 참고\n\n* https://github.com/skoh/common/blob/master/common-web/src/main/resources/ehcache.xml\n* https://www.mkyong.com/spring/spring-caching-and-ehcache-example/\n* http://hyeooona825.tistory.com/86\n* http://blog.naver.com/PostView.nhn?blogId=kyung778&logNo=60164009610","slug":"2018-11-04-ehcache-config-for-springframework","published":1,"updated":"2018-11-27T07:23:32.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp55h5gq000c4f1tdvel1fve","content":"<h1><span id=\"ehcache-설정하기\">EHCache 설정하기</span></h1>\n<p>설정 순서는 아래와 같다.</p>\n<ol>\n<li>Maven Dependency 설정</li>\n<li>Ehcache.xml 작성 (ehcache 설정파일)</li>\n<li>CacheManager 설정 (xml)</li>\n</ol>\n<h1><span id=\"maven-dependency-설정\">Maven Dependency 설정</span></h1>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- EHCache 모듈 (블로그 작성 시점에서 2.10.6이 최신이다.) --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.sf.ehcache<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ehcache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.10.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Spring Caching Interface --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.3.20.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- EHCache Support 모듈, 다른 Caching 지원모듈 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context-support<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.3.20.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"ehcachexml-작성\">ehcache.xml 작성</span></h1>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://ehcache.org/ehcache.xsd\"</span></span></span><br><span class=\"line\">         maxBytesLocalHeap=\"300M\" &lt;!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 --&gt;</span><br><span class=\"line\">         updateCheck=\"false\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 임시저장 경로를 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sizeOfPolicy</span> <span class=\"attr\">maxDepth</span>=<span class=\"string\">\"100000\"</span> <span class=\"attr\">maxDepthExceededBehavior</span>=<span class=\"string\">\"continue\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">&lt;!-- default Cache 설정 (반드시 선언해야 하는 Cache) --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultCache</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">defaultCache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 사용하고자 하는 캐시 별 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"LocalCacheData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"AuthMemberList\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)</li>\n<li>cache는 하나의 캐시를 사용할 때마다 구현</li>\n<li>name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>코드에서 사용할 캐시 name</td>\n<td>필수</td>\n</tr>\n<tr>\n<td>maxEntriesLocalHeap</td>\n<td>메모리에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>maxEntriesLocalDisk</td>\n<td>디스크에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>eternal</td>\n<td>영속성 캐시 설정 (지워지는 캐시인지?) <br>external = &quot;true&quot;이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨</td>\n<td>false</td>\n</tr>\n<tr>\n<td>timeToIdleSecond</td>\n<td>해당 초동안 캐시가 호출 되지 않으면 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>timeToLiveSeconds</td>\n<td>해당 초가 지나면 캐시가 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>overflowToDisk</td>\n<td>오버플로우 된 항목에 대해 disk에 저장할 지 여부</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskPersistent</td>\n<td>캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskExpiryThreadIntervalSeconds</td>\n<td>Disk Expiry 스레드의 작업 수행 간격 설정</td>\n<td>0</td>\n</tr>\n<tr>\n<td>memoryStoreEvictionPolicy</td>\n<td>캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br>LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br>LFU : 호출 빈도가 가장 적은 캐시를 삭제<br>FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제</td>\n<td>LRU</td>\n</tr>\n</tbody>\n</table>\n<h1><span id=\"cachemanager-bean-설정\">CacheManager Bean 설정</span></h1>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z<span class=\"comment\">&lt;!-- Annotation 기반 캐시 사용 (@Cacheable, @CacheEvict..) --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">cache:annotation-driven</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- EHCache 기반 CacheManager 설정 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cacheManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.cache.ehcache.EhCacheCacheManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cacheManager\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"ehcache\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- ehcache.xml 설정 로드 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ehcache\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"configLocation\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"classpath:config/ehcache.xml\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"shared\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"참고\">참고</span></h1>\n<ul>\n<li><a href=\"https://github.com/skoh/common/blob/master/common-web/src/main/resources/ehcache.xml\" target=\"_blank\" rel=\"noopener\">https://github.com/skoh/common/blob/master/common-web/src/main/resources/ehcache.xml</a></li>\n<li><a href=\"https://www.mkyong.com/spring/spring-caching-and-ehcache-example/\" target=\"_blank\" rel=\"noopener\">https://www.mkyong.com/spring/spring-caching-and-ehcache-example/</a></li>\n<li><a href=\"http://hyeooona825.tistory.com/86\" target=\"_blank\" rel=\"noopener\">http://hyeooona825.tistory.com/86</a></li>\n<li><a href=\"http://blog.naver.com/PostView.nhn?blogId=kyung778&amp;logNo=60164009610\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=kyung778&amp;logNo=60164009610</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>EHCache 설정하기</h1>\n<p>설정 순서는 아래와 같다.</p>\n<ol>\n<li>Maven Dependency 설정</li>\n<li>Ehcache.xml 작성 (ehcache 설정파일)</li>\n<li>CacheManager 설정 (xml)</li>\n</ol>\n<h1>Maven Dependency 설정</h1>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- EHCache 모듈 (블로그 작성 시점에서 2.10.6이 최신이다.) --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.sf.ehcache<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ehcache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.10.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Spring Caching Interface --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.3.20.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- EHCache Support 모듈, 다른 Caching 지원모듈 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context-support<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.3.20.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1>ehcache.xml 작성</h1>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://ehcache.org/ehcache.xsd\"</span></span></span><br><span class=\"line\">         maxBytesLocalHeap=\"300M\" &lt;!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 --&gt;</span><br><span class=\"line\">         updateCheck=\"false\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 임시저장 경로를 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"continue\" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색</span></span><br><span class=\"line\"><span class=\"comment\">        maxDepthExceededBehavior = \"abort\" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sizeOfPolicy</span> <span class=\"attr\">maxDepth</span>=<span class=\"string\">\"100000\"</span> <span class=\"attr\">maxDepthExceededBehavior</span>=<span class=\"string\">\"continue\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">&lt;!-- default Cache 설정 (반드시 선언해야 하는 Cache) --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultCache</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">defaultCache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 사용하고자 하는 캐시 별 설정 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"LocalCacheData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"AuthMemberList\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)</li>\n<li>cache는 하나의 캐시를 사용할 때마다 구현</li>\n<li>name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>코드에서 사용할 캐시 name</td>\n<td>필수</td>\n</tr>\n<tr>\n<td>maxEntriesLocalHeap</td>\n<td>메모리에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>maxEntriesLocalDisk</td>\n<td>디스크에 생성 될 최대 캐시 갯수</td>\n<td>0</td>\n</tr>\n<tr>\n<td>eternal</td>\n<td>영속성 캐시 설정 (지워지는 캐시인지?) <br>external = &quot;true&quot;이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨</td>\n<td>false</td>\n</tr>\n<tr>\n<td>timeToIdleSecond</td>\n<td>해당 초동안 캐시가 호출 되지 않으면 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>timeToLiveSeconds</td>\n<td>해당 초가 지나면 캐시가 삭제</td>\n<td>0</td>\n</tr>\n<tr>\n<td>overflowToDisk</td>\n<td>오버플로우 된 항목에 대해 disk에 저장할 지 여부</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskPersistent</td>\n<td>캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정</td>\n<td>false</td>\n</tr>\n<tr>\n<td>diskExpiryThreadIntervalSeconds</td>\n<td>Disk Expiry 스레드의 작업 수행 간격 설정</td>\n<td>0</td>\n</tr>\n<tr>\n<td>memoryStoreEvictionPolicy</td>\n<td>캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br>LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br>LFU : 호출 빈도가 가장 적은 캐시를 삭제<br>FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제</td>\n<td>LRU</td>\n</tr>\n</tbody>\n</table>\n<h1>CacheManager Bean 설정</h1>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z<span class=\"comment\">&lt;!-- Annotation 기반 캐시 사용 (@Cacheable, @CacheEvict..) --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">cache:annotation-driven</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- EHCache 기반 CacheManager 설정 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cacheManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.cache.ehcache.EhCacheCacheManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cacheManager\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"ehcache\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- ehcache.xml 설정 로드 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ehcache\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"configLocation\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"classpath:config/ehcache.xml\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"shared\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1>참고</h1>\n<ul>\n<li><a href=\"https://github.com/skoh/common/blob/master/common-web/src/main/resources/ehcache.xml\" target=\"_blank\" rel=\"noopener\">https://github.com/skoh/common/blob/master/common-web/src/main/resources/ehcache.xml</a></li>\n<li><a href=\"https://www.mkyong.com/spring/spring-caching-and-ehcache-example/\" target=\"_blank\" rel=\"noopener\">https://www.mkyong.com/spring/spring-caching-and-ehcache-example/</a></li>\n<li><a href=\"http://hyeooona825.tistory.com/86\" target=\"_blank\" rel=\"noopener\">http://hyeooona825.tistory.com/86</a></li>\n<li><a href=\"http://blog.naver.com/PostView.nhn?blogId=kyung778&amp;logNo=60164009610\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=kyung778&amp;logNo=60164009610</a></li>\n</ul>\n"},{"layout":"post","title":"Spring AOP (3)","subtitle":"3. Spring AOP","date":"2018-07-21T03:52:33.000Z","background":"/img/posts/06.jpg","_content":"\n앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.\n\n이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.\n\n\n\n# Spring AOP\n\nAOP란 `횡단 관심사 (Cross Cutting Concern)` 을 한데 모아 로직을 설계한다음\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다. \n\n이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.\n\n\n\n# Proxy란?\n\n![Proxy구성도](https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336)\n\n\n\n> Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.\n>\n> 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.\n>\n> 토비의 스프링 vol.1 (p. 430)\n\n\n\n토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다. \n\nSpring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.\n\n\n\n> OCP (Open-Close Principal : 개방 폐쇄의 원칙)\n>\n> **개방-폐쇄 원칙**(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.  \n\n실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.\n\n\n\n# Proxy vs Proxy Pattern\n\n일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.\n비슷한 개념이지만, 내용이 조금 다르다.\n\n일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.\n\nProxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.\n\n\n\n# JDK Dynamic Proxy\n\n![JDK Dynamic Proxy](https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif)\n\n\n\nJDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다. \n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다. \n\n내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.\n\n~~~java\npublic class ExamDynamicHandler implements InvocationHandler {\n    private ExamInterface target; // 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용\n     \n    public ExamDynamicHandler(ExamInterface target) {\n        this.target = target;\n    }\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args)\n            throws Throwable {\n        // TODO Auto-generated method stub\n        // 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용\n        String ret = (String)method.invoke(target, args); //타입 Safe하지 않는 단점이 있다.\n        return ret.toUpperCase(); //메소드 기능에 대한 확장\n    }\n}\n~~~\n\n\n\n# CGLIB Proxy\n\nCGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다. \n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.\n\n하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다. \n\nCGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.\n\n![CGLIB Proxy](http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png)\n\n\n\n* CGLIB Proxy 설정법\n\n* ~~~yaml\n  spring.aop.proxy-target-class=false\n  ~~~\n\n  ~~~xml\n  <aop:config proxy-target-class=\"true\">\n  </aop:config>\n  <aop:aspectj-autoproxy proxy-target-class=\"true\"/> <!-- AspectJ를 사용하는 경우 -->\n  ~~~\n\n  ~~~java\n  //AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다\n  @EnableAsync(proxyTargetClass = true)\n  @EnableCaching(proxyTargetClass = true) \n  ~~~\n\n\n\n# Spring Bean에 대한 Proxy는?\n\nSpring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데.. 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?\n\n![00.png](https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png)\n\n\n\nSpring에서는 `자동 프록시 생성기` 라는 것이 있다.\n\n빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  `DefaultAdvisorAutoProxyCreator` 라는 클래스를 사용한다. \n이 클래스는 어드바이저를 이용한 `자동 프록시 생성기` 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.\n\nDefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.\n\n1. 후처리기는 `빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해` 전달받은 빈이 프록시 적용 대상인지 확인한다.\n2. 프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 `프록시를 생성하고 어드바이저를 연결한다.`\n3. 프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.\n4. 컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.\n\n이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.\n\n \n\n# 요약..\n\n* Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.\n* Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n  * JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)\n  * CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)\n    따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)\n* Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.\n  (그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)\n\n\n\n# 참고\n\n토비의 스프링 vol.1\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttps://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99","source":"_posts/2018-07-21-spring-aop3.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (3)\"\nsubtitle: \"3. Spring AOP\"\ndate:   2018-07-21 12:52:33 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.\n\n이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.\n\n\n\n# Spring AOP\n\nAOP란 `횡단 관심사 (Cross Cutting Concern)` 을 한데 모아 로직을 설계한다음\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다. \n\n이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.\n\n\n\n# Proxy란?\n\n![Proxy구성도](https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336)\n\n\n\n> Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.\n>\n> 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.\n>\n> 토비의 스프링 vol.1 (p. 430)\n\n\n\n토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다. \n\nSpring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.\n\n\n\n> OCP (Open-Close Principal : 개방 폐쇄의 원칙)\n>\n> **개방-폐쇄 원칙**(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.  \n\n실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.\n\n\n\n# Proxy vs Proxy Pattern\n\n일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.\n비슷한 개념이지만, 내용이 조금 다르다.\n\n일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.\n\nProxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.\n\n\n\n# JDK Dynamic Proxy\n\n![JDK Dynamic Proxy](https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif)\n\n\n\nJDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다. \n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다. \n\n내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.\n\n~~~java\npublic class ExamDynamicHandler implements InvocationHandler {\n    private ExamInterface target; // 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용\n     \n    public ExamDynamicHandler(ExamInterface target) {\n        this.target = target;\n    }\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args)\n            throws Throwable {\n        // TODO Auto-generated method stub\n        // 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용\n        String ret = (String)method.invoke(target, args); //타입 Safe하지 않는 단점이 있다.\n        return ret.toUpperCase(); //메소드 기능에 대한 확장\n    }\n}\n~~~\n\n\n\n# CGLIB Proxy\n\nCGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다. \n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.\n\n하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다. \n\nCGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.\n\n![CGLIB Proxy](http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png)\n\n\n\n* CGLIB Proxy 설정법\n\n* ~~~yaml\n  spring.aop.proxy-target-class=false\n  ~~~\n\n  ~~~xml\n  <aop:config proxy-target-class=\"true\">\n  </aop:config>\n  <aop:aspectj-autoproxy proxy-target-class=\"true\"/> <!-- AspectJ를 사용하는 경우 -->\n  ~~~\n\n  ~~~java\n  //AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다\n  @EnableAsync(proxyTargetClass = true)\n  @EnableCaching(proxyTargetClass = true) \n  ~~~\n\n\n\n# Spring Bean에 대한 Proxy는?\n\nSpring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데.. 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?\n\n![00.png](https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png)\n\n\n\nSpring에서는 `자동 프록시 생성기` 라는 것이 있다.\n\n빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  `DefaultAdvisorAutoProxyCreator` 라는 클래스를 사용한다. \n이 클래스는 어드바이저를 이용한 `자동 프록시 생성기` 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.\n\nDefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.\n\n1. 후처리기는 `빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해` 전달받은 빈이 프록시 적용 대상인지 확인한다.\n2. 프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 `프록시를 생성하고 어드바이저를 연결한다.`\n3. 프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.\n4. 컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.\n\n이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.\n\n \n\n# 요약..\n\n* Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.\n* Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n  * JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)\n  * CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)\n    따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)\n* Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.\n  (그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)\n\n\n\n# 참고\n\n토비의 스프링 vol.1\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttps://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99","slug":"2018-07-21-spring-aop3","published":1,"updated":"2018-11-27T07:23:32.353Z","comments":1,"photos":[],"link":"","_id":"cjp55h5hy000t4f1tde7vzo66","content":"<p>앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.</p>\n<p>이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.</p>\n<h1><span id=\"spring-aop\">Spring AOP</span></h1>\n<p>AOP란 <code>횡단 관심사 (Cross Cutting Concern)</code> 을 한데 모아 로직을 설계한다음<br>\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다.</p>\n<p>이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.<br>\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.<br>\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.</p>\n<h1><span id=\"proxy란\">Proxy란?</span></h1>\n<p><img src=\"https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336\" alt=\"Proxy구성도\"></p>\n<blockquote>\n<p>Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.</p>\n<p>그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.</p>\n<p>토비의 스프링 vol.1 (p. 430)</p>\n</blockquote>\n<p>토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다.</p>\n<p>Spring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.</p>\n<blockquote>\n<p>OCP (Open-Close Principal : 개방 폐쇄의 원칙)</p>\n<p><strong>개방-폐쇄 원칙</strong>(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.</p>\n</blockquote>\n<p>실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.</p>\n<h1><span id=\"proxy-vs-proxy-pattern\">Proxy vs Proxy Pattern</span></h1>\n<p>일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.<br>\n비슷한 개념이지만, 내용이 조금 다르다.</p>\n<p>일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.</p>\n<p>Proxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.</p>\n<h1><span id=\"jdk-dynamic-proxy\">JDK Dynamic Proxy</span></h1>\n<p><img src=\"https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif\" alt=\"JDK Dynamic Proxy\"></p>\n<p>JDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.<br>\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다.<br>\n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.<br>\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다.</p>\n<p>내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExamDynamicHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExamInterface target; <span class=\"comment\">// 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExamDynamicHandler</span><span class=\"params\">(ExamInterface target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        <span class=\"comment\">// 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용</span></span><br><span class=\"line\">        String ret = (String)method.invoke(target, args); <span class=\"comment\">//타입 Safe하지 않는 단점이 있다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret.toUpperCase(); <span class=\"comment\">//메소드 기능에 대한 확장</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"cglib-proxy\">CGLIB Proxy</span></h1>\n<p>CGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다.<br>\n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.</p>\n<p>하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다.</p>\n<p>CGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.</p>\n<p><img src=\"http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png\" alt=\"CGLIB Proxy\"></p>\n<ul>\n<li>\n<p>CGLIB Proxy 설정법</p>\n</li>\n<li>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.aop.proxy-target-class=false</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>/&gt;</span> <span class=\"comment\">&lt;!-- AspectJ를 사용하는 경우 --&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAsync</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1><span id=\"spring-bean에-대한-proxy는\">Spring Bean에 대한 Proxy는?</span></h1>\n<p>Spring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.<br>\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데… 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?</p>\n<p><img src=\"https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png\" alt=\"00.png\"></p>\n<p>Spring에서는 <code>자동 프록시 생성기</code> 라는 것이 있다.</p>\n<p>빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  <code>DefaultAdvisorAutoProxyCreator</code> 라는 클래스를 사용한다.<br>\n이 클래스는 어드바이저를 이용한 <code>자동 프록시 생성기</code> 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.</p>\n<p>DefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.</p>\n<ol>\n<li>후처리기는 <code>빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해</code> 전달받은 빈이 프록시 적용 대상인지 확인한다.</li>\n<li>프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 <code>프록시를 생성하고 어드바이저를 연결한다.</code></li>\n<li>프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.</li>\n<li>컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.</li>\n</ol>\n<p>이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.</p>\n<h1><span id=\"요약\">요약…</span></h1>\n<ul>\n<li>Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.</li>\n<li>Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n<ul>\n<li>JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)</li>\n<li>CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)<br>\n따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)</li>\n</ul>\n</li>\n<li>Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.<br>\n(그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)</li>\n</ul>\n<h1><span id=\"참고\">참고</span></h1>\n<p>토비의 스프링 vol.1</p>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99\" target=\"_blank\" rel=\"noopener\">https://ko.wikipedia.org/wiki/개방-폐쇄_원칙</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.</p>\n<p>이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.</p>\n<h1>Spring AOP</h1>\n<p>AOP란 <code>횡단 관심사 (Cross Cutting Concern)</code> 을 한데 모아 로직을 설계한다음<br>\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다.</p>\n<p>이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.<br>\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.<br>\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.</p>\n<h1>Proxy란?</h1>\n<p><img src=\"https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336\" alt=\"Proxy구성도\"></p>\n<blockquote>\n<p>Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.</p>\n<p>그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.</p>\n<p>토비의 스프링 vol.1 (p. 430)</p>\n</blockquote>\n<p>토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다.</p>\n<p>Spring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.</p>\n<blockquote>\n<p>OCP (Open-Close Principal : 개방 폐쇄의 원칙)</p>\n<p><strong>개방-폐쇄 원칙</strong>(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.</p>\n</blockquote>\n<p>실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.</p>\n<h1>Proxy vs Proxy Pattern</h1>\n<p>일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.<br>\n비슷한 개념이지만, 내용이 조금 다르다.</p>\n<p>일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.</p>\n<p>Proxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.</p>\n<h1>JDK Dynamic Proxy</h1>\n<p><img src=\"https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif\" alt=\"JDK Dynamic Proxy\"></p>\n<p>JDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.<br>\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다.<br>\n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.<br>\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다.</p>\n<p>내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExamDynamicHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExamInterface target; <span class=\"comment\">// 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExamDynamicHandler</span><span class=\"params\">(ExamInterface target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        <span class=\"comment\">// 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용</span></span><br><span class=\"line\">        String ret = (String)method.invoke(target, args); <span class=\"comment\">//타입 Safe하지 않는 단점이 있다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret.toUpperCase(); <span class=\"comment\">//메소드 기능에 대한 확장</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>CGLIB Proxy</h1>\n<p>CGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다.<br>\n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.</p>\n<p>하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다.</p>\n<p>CGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.</p>\n<p><img src=\"http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png\" alt=\"CGLIB Proxy\"></p>\n<ul>\n<li>\n<p>CGLIB Proxy 설정법</p>\n</li>\n<li>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.aop.proxy-target-class=false</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>/&gt;</span> <span class=\"comment\">&lt;!-- AspectJ를 사용하는 경우 --&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAsync</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1>Spring Bean에 대한 Proxy는?</h1>\n<p>Spring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.<br>\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데… 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?</p>\n<p><img src=\"https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png\" alt=\"00.png\"></p>\n<p>Spring에서는 <code>자동 프록시 생성기</code> 라는 것이 있다.</p>\n<p>빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  <code>DefaultAdvisorAutoProxyCreator</code> 라는 클래스를 사용한다.<br>\n이 클래스는 어드바이저를 이용한 <code>자동 프록시 생성기</code> 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.</p>\n<p>DefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.</p>\n<ol>\n<li>후처리기는 <code>빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해</code> 전달받은 빈이 프록시 적용 대상인지 확인한다.</li>\n<li>프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 <code>프록시를 생성하고 어드바이저를 연결한다.</code></li>\n<li>프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.</li>\n<li>컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.</li>\n</ol>\n<p>이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.</p>\n<h1>요약…</h1>\n<ul>\n<li>Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.</li>\n<li>Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n<ul>\n<li>JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)</li>\n<li>CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)<br>\n따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)</li>\n</ul>\n</li>\n<li>Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.<br>\n(그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)</li>\n</ul>\n<h1>참고</h1>\n<p>토비의 스프링 vol.1</p>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99\" target=\"_blank\" rel=\"noopener\">https://ko.wikipedia.org/wiki/개방-폐쇄_원칙</a></p>\n"},{"layout":"post","title":"Spring AOP (4)","subtitle":"4. AspectJ","date":"2018-07-22T03:52:33.000Z","background":"/img/posts/06.jpg","_content":"\n# AspectJ란?\n\n> AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.\n\nAspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, `CTW, LTW`과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.\n\n\n\n> Aspect란?\n>\n> Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.\n> 그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.\n> 구조적으로 보자면 Aspect = PointCut + Advisor이다.\n\n \n\n# 위빙 Weaving\n\n위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.\n\n\n\n##런타임 시, 위빙 (RTW: Runtime Weaving)\n\nSpring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.\n\n![Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw)\n\n\n\n\n\n\n\n## 컴파일 시, 위빙 (CTW: Compile time Weaving)\n\nAspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)\n\n\n\n### CTW를 사용하기 위한 메이븐 설정\n\n**라이브러리 추가:** (pom.xml)\n\n```xml\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjrt</artifactId>\n    <version>1.8.6</version>\n    <scope>runtime</scope>\n</dependency>\n \n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjtools</artifactId>\n    <version>1.8.6</version>\n</dependency> \n```\n\n**플러그인 설정:** (pom.xml)\n\n```xml\n<plugin>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>aspectj-maven-plugin</artifactId>\n    <version>1.7</version>\n    <configuration>\n        <showWeaveInfo>true</showWeaveInfo>\n            <source>${aspectj-compiler.version}</source>\n            <target>${aspectj-compiler.version}</target>\n            <verbose>true</verbose>\n            <complianceLevel>${aspectj-compiler.version}</complianceLevel>\n            <outxml>true</outxml>\n    </configuration>\n    <executions>\n        <execution>\n            <goals>\n                <goal>compile</goal>\n                <goal>test-compile</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n*(\\*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)*\n\n위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용 \n\nAspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용\n\n\n\n## 클래스 로드 시, 위빙 (LTW: Load time Weaving)\n\n ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.\n\n그리고 설정이 가장 복잡하지 않은가 싶다..\n\n아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.\n\n~~~xml\n<context:load-time-weaver/> <!-- 스프링 설정 파일에 추가 servlet.xml -->\n~~~\n\n~~~java\n@EnableLoadTimeWeaving //Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.\n~~~\n\n~~~vm\n//IDE에서 개발 시, 해당 설정을 추가\n-javaagent:/fullpath/aspectjweaver-1.8.1.jar \n-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar \n~~~\n\n~~~\n//톰캣 시작 시, jvmargs 옵션에 추가\n-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar\n~~~\n\n\n\n# Annotations\n\n## JoinPoint 관련 Annotations\n\n공통적으로 pointcut에 대한 표현식을 인자로 받는다.\n\n* @Before\n  * 메소드 실행 이전 부분에 대한 Joinpoint 설정\n* @Around\n  * ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.\n  * 메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.\n* @After\n  * 메소드 실행 이후 부분의 대한 Joinpoint 설정\n* @AfterReturning\n  * 메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정\n* @AfterThrowable\n  * 메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정\n\n\n\n## Pointcut 관련 Annotation\n\n* @Pointcut\n  * Pointcut에 대한 표현식을 값으로 가짐\n  * @Pointcut이 적용된 메소드는 무조건 리턴타입이 void\n\n\n\n\n\n# Point Cut\n\n포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.\n\n![pointcut 개념](https://t1.daumcdn.net/cfile/tistory/223B623D548C415631)\n\n\n\n## 포인트 컷 표현식\n\nExpression을 이용한 pointcut 표현식\n\n![pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg)\n\n\n\n1. 접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)\n   * \\* 인 경우 모든 접근제어자에 대해 설정 가능\n   * 생략 시, \\* 과 같은 효과\n\n2. 리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)\n   * 필수 적으로 기재해야 한다.\n   * \\* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.\n3. Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)\n   * 단, 패키지 명도 기재해야 함 \n   * com.springframework.aop.. 처럼 ..으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리\n   * 필수 적으로 기재해야 한다.\n4. 메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * 모든 메소드에 적용 하려면 \\* 을 사용\n5. 파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * ,로 구분하여 순서대로 파라미터를 기재한다.\n   * 타입과 갯수에 상관없다면 .. 또는 \\* 를 기재한다.\n6. 예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)\n\n\n\n## 예시\n\n- **execution(int minus(int, int))**: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(int, int))**: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(..))**: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드\n\n- **execution(\\* *(..))**: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드\n\n- **execution(\\* *())**: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드\n\n- **execution(\\* springbook.aop.Target.*(..))**: springbook.aop.Target 클래스의 모든 메소드\n\n- **execution(\\* springbook.aop.*.*(..))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.\n\n- **execution(\\* springbook.aop..*.*(..))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함\n\n- **execution(\\* *..Target.*(..))**: 패키지에는 상관없이 Target 클래스의 모든 메소드\n\n- **execution(* *(..) throws Exception) **: Exception을 throw하는 모든 메소드\n\n- **within(com.springbook.aop.service.***) : service 패키지 내의 모든 Joinpoint\n\n- **within(com.springbook.aop.service..***) : service 패키지의 하위패키지 내의 모든 Joinpoint\n\n- **this(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint\n\n- **target(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint\n\n- **args(java.utils.List)** : 파라미터가 1개이고 List타입인 모든 Joinpoint\n\n- **@target(org.springframework.transaction.annotation.Transactional)** :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@within(org.springframework.transaction.annotation.Transactional)** : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@annotation(org.springframework.transaction.annotation.Transactional)** : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점\n\n* **@args(com.xyz.security.Classified)** : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점\n\n* **bean(UserRepository)** : “UserRepository” 빈\n\n* **!bean(UserRepository)** :  “UserRepository” 빈을 제외한 모든 빈\n\n* **bean(*)** : 모든 빈\n\n* **bean(user*)** : 이름이 'user'로 시작되는 모든 빈\n\n* **bean(*Repository)** : 이름이 “Repository”로 끝나는 모든 빈\n\n* **bean(user/*)** : 이름이 “user/“로 시작하는 모든 빈\n\n* **bean(*dataSource) || bean(*DataSource)** : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈\n\n \n\n# 예시코드\n\n## Aspect 파일 사용\n\n~~~java\npublic aspect TestAdvisor {\n    pointcut advicePoint() : execution(* com.example.advice..*(..));\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n    \n    //order는 어떻게 주는건지 모르겠다.\n}\n~~~\n\n\n\n## @Aspect 어노테이션 사용\n\n~~~java\n@Aspect\npublic class TestAdvisor {\n    \n    /**\n    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut\n    */\n    @Pointcut(\"execution(* com.example.advice..*(..))\")\n    public void pointcut(){\n        \n    }\n    \n    @order(2) //order가 높은 순으로 먼저 실행\n    @After(pointcut=\"pointcut()\")\n    public void afterAdvice(Joinpoint joinpoint) {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    @order(1)\n    @After(pointcut=\"pointcut()\")\n    public void showLog(Joinpoint joinpoint) {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n}\n~~~\n\n\n\n\n\n# 참고\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220564638014\n\nhttp://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\n\nhttps://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5","source":"_posts/2018-07-22-spring-aop4.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (4)\"\nsubtitle: \"4. AspectJ\"\ndate:   2018-07-22 12:52:33 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n# AspectJ란?\n\n> AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.\n\nAspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, `CTW, LTW`과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.\n\n\n\n> Aspect란?\n>\n> Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.\n> 그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.\n> 구조적으로 보자면 Aspect = PointCut + Advisor이다.\n\n \n\n# 위빙 Weaving\n\n위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.\n\n\n\n##런타임 시, 위빙 (RTW: Runtime Weaving)\n\nSpring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.\n\n![Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw)\n\n\n\n\n\n\n\n## 컴파일 시, 위빙 (CTW: Compile time Weaving)\n\nAspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)\n\n\n\n### CTW를 사용하기 위한 메이븐 설정\n\n**라이브러리 추가:** (pom.xml)\n\n```xml\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjrt</artifactId>\n    <version>1.8.6</version>\n    <scope>runtime</scope>\n</dependency>\n \n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjtools</artifactId>\n    <version>1.8.6</version>\n</dependency> \n```\n\n**플러그인 설정:** (pom.xml)\n\n```xml\n<plugin>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>aspectj-maven-plugin</artifactId>\n    <version>1.7</version>\n    <configuration>\n        <showWeaveInfo>true</showWeaveInfo>\n            <source>${aspectj-compiler.version}</source>\n            <target>${aspectj-compiler.version}</target>\n            <verbose>true</verbose>\n            <complianceLevel>${aspectj-compiler.version}</complianceLevel>\n            <outxml>true</outxml>\n    </configuration>\n    <executions>\n        <execution>\n            <goals>\n                <goal>compile</goal>\n                <goal>test-compile</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n*(\\*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)*\n\n위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용 \n\nAspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용\n\n\n\n## 클래스 로드 시, 위빙 (LTW: Load time Weaving)\n\n ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.\n\n그리고 설정이 가장 복잡하지 않은가 싶다..\n\n아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.\n\n~~~xml\n<context:load-time-weaver/> <!-- 스프링 설정 파일에 추가 servlet.xml -->\n~~~\n\n~~~java\n@EnableLoadTimeWeaving //Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.\n~~~\n\n~~~vm\n//IDE에서 개발 시, 해당 설정을 추가\n-javaagent:/fullpath/aspectjweaver-1.8.1.jar \n-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar \n~~~\n\n~~~\n//톰캣 시작 시, jvmargs 옵션에 추가\n-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar\n~~~\n\n\n\n# Annotations\n\n## JoinPoint 관련 Annotations\n\n공통적으로 pointcut에 대한 표현식을 인자로 받는다.\n\n* @Before\n  * 메소드 실행 이전 부분에 대한 Joinpoint 설정\n* @Around\n  * ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.\n  * 메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.\n* @After\n  * 메소드 실행 이후 부분의 대한 Joinpoint 설정\n* @AfterReturning\n  * 메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정\n* @AfterThrowable\n  * 메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정\n\n\n\n## Pointcut 관련 Annotation\n\n* @Pointcut\n  * Pointcut에 대한 표현식을 값으로 가짐\n  * @Pointcut이 적용된 메소드는 무조건 리턴타입이 void\n\n\n\n\n\n# Point Cut\n\n포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.\n\n![pointcut 개념](https://t1.daumcdn.net/cfile/tistory/223B623D548C415631)\n\n\n\n## 포인트 컷 표현식\n\nExpression을 이용한 pointcut 표현식\n\n![pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg)\n\n\n\n1. 접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)\n   * \\* 인 경우 모든 접근제어자에 대해 설정 가능\n   * 생략 시, \\* 과 같은 효과\n\n2. 리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)\n   * 필수 적으로 기재해야 한다.\n   * \\* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.\n3. Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)\n   * 단, 패키지 명도 기재해야 함 \n   * com.springframework.aop.. 처럼 ..으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리\n   * 필수 적으로 기재해야 한다.\n4. 메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * 모든 메소드에 적용 하려면 \\* 을 사용\n5. 파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * ,로 구분하여 순서대로 파라미터를 기재한다.\n   * 타입과 갯수에 상관없다면 .. 또는 \\* 를 기재한다.\n6. 예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)\n\n\n\n## 예시\n\n- **execution(int minus(int, int))**: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(int, int))**: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(..))**: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드\n\n- **execution(\\* *(..))**: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드\n\n- **execution(\\* *())**: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드\n\n- **execution(\\* springbook.aop.Target.*(..))**: springbook.aop.Target 클래스의 모든 메소드\n\n- **execution(\\* springbook.aop.*.*(..))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.\n\n- **execution(\\* springbook.aop..*.*(..))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함\n\n- **execution(\\* *..Target.*(..))**: 패키지에는 상관없이 Target 클래스의 모든 메소드\n\n- **execution(* *(..) throws Exception) **: Exception을 throw하는 모든 메소드\n\n- **within(com.springbook.aop.service.***) : service 패키지 내의 모든 Joinpoint\n\n- **within(com.springbook.aop.service..***) : service 패키지의 하위패키지 내의 모든 Joinpoint\n\n- **this(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint\n\n- **target(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint\n\n- **args(java.utils.List)** : 파라미터가 1개이고 List타입인 모든 Joinpoint\n\n- **@target(org.springframework.transaction.annotation.Transactional)** :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@within(org.springframework.transaction.annotation.Transactional)** : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@annotation(org.springframework.transaction.annotation.Transactional)** : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점\n\n* **@args(com.xyz.security.Classified)** : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점\n\n* **bean(UserRepository)** : “UserRepository” 빈\n\n* **!bean(UserRepository)** :  “UserRepository” 빈을 제외한 모든 빈\n\n* **bean(*)** : 모든 빈\n\n* **bean(user*)** : 이름이 'user'로 시작되는 모든 빈\n\n* **bean(*Repository)** : 이름이 “Repository”로 끝나는 모든 빈\n\n* **bean(user/*)** : 이름이 “user/“로 시작하는 모든 빈\n\n* **bean(*dataSource) || bean(*DataSource)** : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈\n\n \n\n# 예시코드\n\n## Aspect 파일 사용\n\n~~~java\npublic aspect TestAdvisor {\n    pointcut advicePoint() : execution(* com.example.advice..*(..));\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n    \n    //order는 어떻게 주는건지 모르겠다.\n}\n~~~\n\n\n\n## @Aspect 어노테이션 사용\n\n~~~java\n@Aspect\npublic class TestAdvisor {\n    \n    /**\n    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut\n    */\n    @Pointcut(\"execution(* com.example.advice..*(..))\")\n    public void pointcut(){\n        \n    }\n    \n    @order(2) //order가 높은 순으로 먼저 실행\n    @After(pointcut=\"pointcut()\")\n    public void afterAdvice(Joinpoint joinpoint) {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    @order(1)\n    @After(pointcut=\"pointcut()\")\n    public void showLog(Joinpoint joinpoint) {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n}\n~~~\n\n\n\n\n\n# 참고\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220564638014\n\nhttp://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\n\nhttps://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5","slug":"2018-07-22-spring-aop4","published":1,"updated":"2018-11-27T07:23:32.353Z","comments":1,"photos":[],"link":"","_id":"cjp55h5hz000v4f1t10e6g90y","content":"<h1><span id=\"aspectj란\">AspectJ란?</span></h1>\n<blockquote>\n<p>AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.</p>\n</blockquote>\n<p>AspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, <code>CTW, LTW</code>과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.<br>\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.<br>\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.</p>\n<blockquote>\n<p>Aspect란?</p>\n<p>Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.<br>\n그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.<br>\n구조적으로 보자면 Aspect = PointCut + Advisor이다.</p>\n</blockquote>\n<h1><span id=\"위빙-weaving\">위빙 Weaving</span></h1>\n<p>위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.<br>\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.</p>\n<p>##런타임 시, 위빙 (RTW: Runtime Weaving)</p>\n<p>Spring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.<br>\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.<br>\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.</p>\n<p><img src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw\" alt=\"Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<h2><span id=\"컴파일-시-위빙-ctw-compile-time-weaving\">컴파일 시, 위빙 (CTW: Compile time Weaving)</span></h2>\n<p>AspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.<br>\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.<br>\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)</p>\n<h3><span id=\"ctw를-사용하기-위한-메이븐-설정\">CTW를 사용하기 위한 메이븐 설정</span></h3>\n<p><strong>라이브러리 추가:</strong> (pom.xml)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>플러그인 설정:</strong> (pom.xml)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectj-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">showWeaveInfo</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">showWeaveInfo</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">verbose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">verbose</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">complianceLevel</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">complianceLevel</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outxml</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">outxml</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>test-compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><em>(*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)</em></p>\n<p>위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용</p>\n<p>AspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용</p>\n<h2><span id=\"클래스-로드-시-위빙-ltw-load-time-weaving\">클래스 로드 시, 위빙 (LTW: Load time Weaving)</span></h2>\n<p>ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식<br>\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.<br>\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.</p>\n<p>그리고 설정이 가장 복잡하지 않은가 싶다…</p>\n<p>아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:load-time-weaver</span>/&gt;</span> <span class=\"comment\">&lt;!-- 스프링 설정 파일에 추가 servlet.xml --&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableLoadTimeWeaving</span> <span class=\"comment\">//Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//IDE에서 개발 시, 해당 설정을 추가</span><br><span class=\"line\">-javaagent:/fullpath/aspectjweaver-1.8.1.jar </span><br><span class=\"line\">-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//톰캣 시작 시, jvmargs 옵션에 추가</span><br><span class=\"line\">-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure>\n<h1><span id=\"annotations\">Annotations</span></h1>\n<h2><span id=\"joinpoint-관련-annotations\">JoinPoint 관련 Annotations</span></h2>\n<p>공통적으로 pointcut에 대한 표현식을 인자로 받는다.</p>\n<ul>\n<li>@Before\n<ul>\n<li>메소드 실행 이전 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@Around\n<ul>\n<li>ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.</li>\n<li>메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.</li>\n</ul>\n</li>\n<li>@After\n<ul>\n<li>메소드 실행 이후 부분의 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterReturning\n<ul>\n<li>메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterThrowable\n<ul>\n<li>메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n</ul>\n<h2><span id=\"pointcut-관련-annotation\">Pointcut 관련 Annotation</span></h2>\n<ul>\n<li>@Pointcut\n<ul>\n<li>Pointcut에 대한 표현식을 값으로 가짐</li>\n<li>@Pointcut이 적용된 메소드는 무조건 리턴타입이 void</li>\n</ul>\n</li>\n</ul>\n<h1><span id=\"point-cut\">Point Cut</span></h1>\n<p>포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.<br>\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/223B623D548C415631\" alt=\"pointcut 개념\"></p>\n<h2><span id=\"포인트-컷-표현식\">포인트 컷 표현식</span></h2>\n<p>Expression을 이용한 pointcut 표현식</p>\n<p><img src=\"http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg\" alt=\"pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<ol>\n<li>\n<p>접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)</p>\n<ul>\n<li>* 인 경우 모든 접근제어자에 대해 설정 가능</li>\n<li>생략 시, * 과 같은 효과</li>\n</ul>\n</li>\n<li>\n<p>리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)</p>\n<ul>\n<li>단, 패키지 명도 기재해야 함</li>\n<li>com.springframework.aop… 처럼 …으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리</li>\n<li>필수 적으로 기재해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>모든 메소드에 적용 하려면 * 을 사용</li>\n</ul>\n</li>\n<li>\n<p>파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>,로 구분하여 순서대로 파라미터를 기재한다.</li>\n<li>타입과 갯수에 상관없다면 … 또는 * 를 기재한다.</li>\n</ul>\n</li>\n<li>\n<p>예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)</p>\n</li>\n</ol>\n<h2><span id=\"예시\">예시</span></h2>\n<ul>\n<li>\n<p><strong>execution(int minus(int, int))</strong>: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(int, int))</strong>: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(…))</strong>: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>(…))</em></em>: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>())</em></em>: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.Target.</em>(…))</em>*: springbook.aop.Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.</em>.</em>(…))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop…</em>.</em>(…))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함</p>\n</li>\n<li>\n<p><strong>execution(* <em>…Target.</em>(…))</strong>: 패키지에는 상관없이 Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(</em> *(…) throws Exception) **: Exception을 throw하는 모든 메소드</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service.</strong>*) : service 패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service…</strong>*) : service 패키지의 하위패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>this(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>target(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>args(java.utils.List)</strong> : 파라미터가 1개이고 List타입인 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>@target(org.springframework.transaction.annotation.Transactional)</strong> :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@within(org.springframework.transaction.annotation.Transactional)</strong> : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@annotation(org.springframework.transaction.annotation.Transactional)</strong> : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n</ul>\n<ul>\n<li>\n<p><strong>@args(com.xyz.security.Classified)</strong> : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>bean(UserRepository)</strong> : “UserRepository” 빈</p>\n</li>\n<li>\n<p><strong>!bean(UserRepository)</strong> :  “UserRepository” 빈을 제외한 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(</em>)</em>* : 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user</em>)</em>* : 이름이 'user’로 시작되는 모든 빈</p>\n</li>\n<li>\n<p>*<em>bean(<em>Repository)</em></em> : 이름이 “Repository”로 끝나는 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user/</em>)</em>* : 이름이 “user/“로 시작하는 모든 빈</p>\n</li>\n<li>\n<p>**bean(<em>dataSource) || bean(<em>DataSource)</em></em> : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈</p>\n</li>\n</ul>\n<h1><span id=\"예시코드\">예시코드</span></h1>\n<h2><span id=\"aspect-파일-사용\">Aspect 파일 사용</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> aspect TestAdvisor &#123;</span><br><span class=\"line\">    <span class=\"function\">pointcut <span class=\"title\">advicePoint</span><span class=\"params\">()</span> : <span class=\"title\">execution</span><span class=\"params\">(* com.example.advice..*(..)</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//order는 어떻게 주는건지 모르겠다.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"aspect-어노테이션-사용\">@Aspect 어노테이션 사용</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.example.advice..*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pointcut</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">2</span>) <span class=\"comment\">//order가 높은 순으로 먼저 실행</span></span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterAdvice</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showLog</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"참고\">참고</span></h1>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014</a></p>\n<p><a href=\"http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\" target=\"_blank\" rel=\"noopener\">http://netframework.tistory.com/entry/LTW-CTW를-이용한-Transactional의-사용</a></p>\n<p><a href=\"https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5\" target=\"_blank\" rel=\"noopener\">https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>AspectJ란?</h1>\n<blockquote>\n<p>AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.</p>\n</blockquote>\n<p>AspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, <code>CTW, LTW</code>과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.<br>\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.<br>\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.</p>\n<blockquote>\n<p>Aspect란?</p>\n<p>Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.<br>\n그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.<br>\n구조적으로 보자면 Aspect = PointCut + Advisor이다.</p>\n</blockquote>\n<h1>위빙 Weaving</h1>\n<p>위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.<br>\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.</p>\n<p>##런타임 시, 위빙 (RTW: Runtime Weaving)</p>\n<p>Spring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.<br>\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.<br>\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.</p>\n<p><img src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw\" alt=\"Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<h2>컴파일 시, 위빙 (CTW: Compile time Weaving)</h2>\n<p>AspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.<br>\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.<br>\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)</p>\n<h3>CTW를 사용하기 위한 메이븐 설정</h3>\n<p><strong>라이브러리 추가:</strong> (pom.xml)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>플러그인 설정:</strong> (pom.xml)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectj-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">showWeaveInfo</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">showWeaveInfo</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">verbose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">verbose</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">complianceLevel</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">complianceLevel</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outxml</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">outxml</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>test-compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><em>(*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)</em></p>\n<p>위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용</p>\n<p>AspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용</p>\n<h2>클래스 로드 시, 위빙 (LTW: Load time Weaving)</h2>\n<p>ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식<br>\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.<br>\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.</p>\n<p>그리고 설정이 가장 복잡하지 않은가 싶다…</p>\n<p>아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:load-time-weaver</span>/&gt;</span> <span class=\"comment\">&lt;!-- 스프링 설정 파일에 추가 servlet.xml --&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableLoadTimeWeaving</span> <span class=\"comment\">//Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//IDE에서 개발 시, 해당 설정을 추가</span><br><span class=\"line\">-javaagent:/fullpath/aspectjweaver-1.8.1.jar </span><br><span class=\"line\">-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//톰캣 시작 시, jvmargs 옵션에 추가</span><br><span class=\"line\">-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure>\n<h1>Annotations</h1>\n<h2>JoinPoint 관련 Annotations</h2>\n<p>공통적으로 pointcut에 대한 표현식을 인자로 받는다.</p>\n<ul>\n<li>@Before\n<ul>\n<li>메소드 실행 이전 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@Around\n<ul>\n<li>ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.</li>\n<li>메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.</li>\n</ul>\n</li>\n<li>@After\n<ul>\n<li>메소드 실행 이후 부분의 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterReturning\n<ul>\n<li>메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterThrowable\n<ul>\n<li>메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n</ul>\n<h2>Pointcut 관련 Annotation</h2>\n<ul>\n<li>@Pointcut\n<ul>\n<li>Pointcut에 대한 표현식을 값으로 가짐</li>\n<li>@Pointcut이 적용된 메소드는 무조건 리턴타입이 void</li>\n</ul>\n</li>\n</ul>\n<h1>Point Cut</h1>\n<p>포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.<br>\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/223B623D548C415631\" alt=\"pointcut 개념\"></p>\n<h2>포인트 컷 표현식</h2>\n<p>Expression을 이용한 pointcut 표현식</p>\n<p><img src=\"http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg\" alt=\"pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<ol>\n<li>\n<p>접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)</p>\n<ul>\n<li>* 인 경우 모든 접근제어자에 대해 설정 가능</li>\n<li>생략 시, * 과 같은 효과</li>\n</ul>\n</li>\n<li>\n<p>리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)</p>\n<ul>\n<li>단, 패키지 명도 기재해야 함</li>\n<li>com.springframework.aop… 처럼 …으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리</li>\n<li>필수 적으로 기재해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>모든 메소드에 적용 하려면 * 을 사용</li>\n</ul>\n</li>\n<li>\n<p>파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>,로 구분하여 순서대로 파라미터를 기재한다.</li>\n<li>타입과 갯수에 상관없다면 … 또는 * 를 기재한다.</li>\n</ul>\n</li>\n<li>\n<p>예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)</p>\n</li>\n</ol>\n<h2>예시</h2>\n<ul>\n<li>\n<p><strong>execution(int minus(int, int))</strong>: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(int, int))</strong>: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(…))</strong>: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>(…))</em></em>: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>())</em></em>: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.Target.</em>(…))</em>*: springbook.aop.Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.</em>.</em>(…))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop…</em>.</em>(…))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함</p>\n</li>\n<li>\n<p><strong>execution(* <em>…Target.</em>(…))</strong>: 패키지에는 상관없이 Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(</em> *(…) throws Exception) **: Exception을 throw하는 모든 메소드</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service.</strong>*) : service 패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service…</strong>*) : service 패키지의 하위패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>this(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>target(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>args(java.utils.List)</strong> : 파라미터가 1개이고 List타입인 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>@target(org.springframework.transaction.annotation.Transactional)</strong> :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@within(org.springframework.transaction.annotation.Transactional)</strong> : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@annotation(org.springframework.transaction.annotation.Transactional)</strong> : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n</ul>\n<ul>\n<li>\n<p><strong>@args(com.xyz.security.Classified)</strong> : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>bean(UserRepository)</strong> : “UserRepository” 빈</p>\n</li>\n<li>\n<p><strong>!bean(UserRepository)</strong> :  “UserRepository” 빈을 제외한 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(</em>)</em>* : 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user</em>)</em>* : 이름이 'user’로 시작되는 모든 빈</p>\n</li>\n<li>\n<p>*<em>bean(<em>Repository)</em></em> : 이름이 “Repository”로 끝나는 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user/</em>)</em>* : 이름이 “user/“로 시작하는 모든 빈</p>\n</li>\n<li>\n<p>**bean(<em>dataSource) || bean(<em>DataSource)</em></em> : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈</p>\n</li>\n</ul>\n<h1>예시코드</h1>\n<h2>Aspect 파일 사용</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> aspect TestAdvisor &#123;</span><br><span class=\"line\">    <span class=\"function\">pointcut <span class=\"title\">advicePoint</span><span class=\"params\">()</span> : <span class=\"title\">execution</span><span class=\"params\">(* com.example.advice..*(..)</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//order는 어떻게 주는건지 모르겠다.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>@Aspect 어노테이션 사용</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.example.advice..*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pointcut</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">2</span>) <span class=\"comment\">//order가 높은 순으로 먼저 실행</span></span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterAdvice</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showLog</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>참고</h1>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014</a></p>\n<p><a href=\"http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\" target=\"_blank\" rel=\"noopener\">http://netframework.tistory.com/entry/LTW-CTW를-이용한-Transactional의-사용</a></p>\n<p><a href=\"https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5\" target=\"_blank\" rel=\"noopener\">https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5</a></p>\n"},{"title":"Spring Argument Resovler","catalog":true,"date":"2018-08-09T16:53:17.000Z","subtitle":"Controller를 깔끔하게 해주는 Argument Resolver","header-img":null,"typora-root-url":"./2018-08-10-spring-argument-resolver","typora-copy-images-to":"./2018-08-10-spring-argument-resolver","_content":"\n\n\n회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나.. 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.\n\n그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.\n\n하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다.. (Client IP를 구하는 코드가 한 10줄 정도는 된다.)\n\n그래서 중간에 Filter나 Interceptor로 해볼까..? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.\n\n\n\n# Spring Argument Resolver\n\nSpring Argument Resolver는 `Controller에 들어오는 파라미터를 가공` 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공/추가/수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.\nSpring에서는 `HandlerMethodArgumentResolver`라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.\n\n\n\n# Argument Resolver 동작 방식\n\n![Dispatch-Seq](./Dispatch-Seq.jpg)\n\n\n\n(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)\n\n1. Client Request 요청\n2. Dispatcher Servlet에서 해당 요청을 처리\n3. Client Request에 대한 Handler Mapping \n   1. RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)\n   2. Interceptor처리\n   3. `Argument Resolver 처리` <-- 바로 여기서 우리가 지정한 Argument Resolver 실행\n   4. Message Converter 처리\n4. Controller Method invoke\n\n\n\n![RequestMappingHandlerAdapter](./RequestMappingHandlerAdapter.png)\n\n\n\nRequestHandlerMappingAdapter.java > getDefaultArgumentResolvers\n\n위에서 지정 된 순서대로 Argument Resolver를 실행 한다.\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.\n\n\n\n# Custom Argument Resolver 만들기\n\n내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에..)\n\n기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.\nCustom Argument Resolver를 만들기 위해서는 `HandlerMethodArgumentResolver` 인터페이스를 구현하여 만든다.\n\n```java\npackage com.example.springstudy.resolver;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.support.WebDataBinderFactory;\nimport org.springframework.web.context.request.NativeWebRequest;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.method.support.ModelAndViewContainer;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class ClientIpArgumentResolver implements HandlerMethodArgumentResolver {\n\n    /**\n     * resolveArgument를 실행 할 수 있는 method인지 판별\n     * @param methodParameter\n     * @return\n     */\n    @Override\n    public boolean supportsParameter(MethodParameter methodParameter) {\n        //@ClientIP 어노테이션이 붙은 파라미터에 대해 적용\n        return methodParameter.hasParameterAnnotation(ClientIP.class);\n    }\n\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n}\n\n```\n\n\n\nHandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.\n\n- supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n  - 물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.\n- resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.\n\n\n\n# Custom Argument Resolver 등록하기\n\n개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.\n\n전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.\n\n\n\n1. ServletContext.xml 에 등록하는 방법\n\n```xml\n<mvc:annotation-driven>\n    <mvc:argument-resolvers>\n        <bean class=\"com.example.springstudy.resolver.ClientIpArgumentResolver\"></bean>      \n    </mvc:argument-resolvers>\n</mvc:annotation-driven>\n```\n\n\n\n1. Java Config를 이용하는 방법\n\n```java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\nimport java.util.List;\n\n//WebMvcConfigurationSupport를 상속 \n//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n    \n    //우리가 만든 ArgumentResolver를 추가한다.\n    @Override\n    protected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        super.addArgumentResolvers(argumentResolvers);\n        argumentResolvers.add(new ClientIpArgumentResolver());\n    }\n}\n```\n\n\n\n# Controller에 적용\n\n```java\npackage com.example.springstudy.controller;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class ClientController {\n\n    /**\n     * 요청을 보낸 Client Ip를 return\n     * @param clientIp\n     * @return\n     */\n    @GetMapping(\"/client\")\n    public String getClientIp(@ClientIP String clientIp) {\n\n        return String.format(\"Request Client Ip = %s\", clientIp);\n    }\n}\n```\n\n\n\nController 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.\n\n\n\n실행 결과\n\n![argument-resolver-result](./argument-resolver-result.png)\n\n\n\n\n\n# 참조\n\n토비의 스프링 vol.2\n\nhttp://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\n\nhttp://zgundam.tistory.com/38\n\nhttp://rstoyanchev.github.io/spring-mvc-31-update/#13","source":"_posts/2018-08-10-spring-argument-resolver.md","raw":"---\ntitle: Spring Argument Resovler\ncatalog: true\ndate: 2018-08-10 01:53:17\nsubtitle: Controller를 깔끔하게 해주는 Argument Resolver\nheader-img:\ntags: Spring\ntypora-root-url: ./2018-08-10-spring-argument-resolver\ntypora-copy-images-to: ./2018-08-10-spring-argument-resolver\n---\n\n\n\n회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나.. 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.\n\n그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.\n\n하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다.. (Client IP를 구하는 코드가 한 10줄 정도는 된다.)\n\n그래서 중간에 Filter나 Interceptor로 해볼까..? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.\n\n\n\n# Spring Argument Resolver\n\nSpring Argument Resolver는 `Controller에 들어오는 파라미터를 가공` 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공/추가/수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.\nSpring에서는 `HandlerMethodArgumentResolver`라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.\n\n\n\n# Argument Resolver 동작 방식\n\n![Dispatch-Seq](./Dispatch-Seq.jpg)\n\n\n\n(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)\n\n1. Client Request 요청\n2. Dispatcher Servlet에서 해당 요청을 처리\n3. Client Request에 대한 Handler Mapping \n   1. RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)\n   2. Interceptor처리\n   3. `Argument Resolver 처리` <-- 바로 여기서 우리가 지정한 Argument Resolver 실행\n   4. Message Converter 처리\n4. Controller Method invoke\n\n\n\n![RequestMappingHandlerAdapter](./RequestMappingHandlerAdapter.png)\n\n\n\nRequestHandlerMappingAdapter.java > getDefaultArgumentResolvers\n\n위에서 지정 된 순서대로 Argument Resolver를 실행 한다.\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.\n\n\n\n# Custom Argument Resolver 만들기\n\n내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에..)\n\n기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.\nCustom Argument Resolver를 만들기 위해서는 `HandlerMethodArgumentResolver` 인터페이스를 구현하여 만든다.\n\n```java\npackage com.example.springstudy.resolver;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.support.WebDataBinderFactory;\nimport org.springframework.web.context.request.NativeWebRequest;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.method.support.ModelAndViewContainer;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class ClientIpArgumentResolver implements HandlerMethodArgumentResolver {\n\n    /**\n     * resolveArgument를 실행 할 수 있는 method인지 판별\n     * @param methodParameter\n     * @return\n     */\n    @Override\n    public boolean supportsParameter(MethodParameter methodParameter) {\n        //@ClientIP 어노테이션이 붙은 파라미터에 대해 적용\n        return methodParameter.hasParameterAnnotation(ClientIP.class);\n    }\n\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n}\n\n```\n\n\n\nHandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.\n\n- supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n  - 물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.\n- resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.\n\n\n\n# Custom Argument Resolver 등록하기\n\n개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.\n\n전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.\n\n\n\n1. ServletContext.xml 에 등록하는 방법\n\n```xml\n<mvc:annotation-driven>\n    <mvc:argument-resolvers>\n        <bean class=\"com.example.springstudy.resolver.ClientIpArgumentResolver\"></bean>      \n    </mvc:argument-resolvers>\n</mvc:annotation-driven>\n```\n\n\n\n1. Java Config를 이용하는 방법\n\n```java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\nimport java.util.List;\n\n//WebMvcConfigurationSupport를 상속 \n//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n    \n    //우리가 만든 ArgumentResolver를 추가한다.\n    @Override\n    protected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        super.addArgumentResolvers(argumentResolvers);\n        argumentResolvers.add(new ClientIpArgumentResolver());\n    }\n}\n```\n\n\n\n# Controller에 적용\n\n```java\npackage com.example.springstudy.controller;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class ClientController {\n\n    /**\n     * 요청을 보낸 Client Ip를 return\n     * @param clientIp\n     * @return\n     */\n    @GetMapping(\"/client\")\n    public String getClientIp(@ClientIP String clientIp) {\n\n        return String.format(\"Request Client Ip = %s\", clientIp);\n    }\n}\n```\n\n\n\nController 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.\n\n\n\n실행 결과\n\n![argument-resolver-result](./argument-resolver-result.png)\n\n\n\n\n\n# 참조\n\n토비의 스프링 vol.2\n\nhttp://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\n\nhttp://zgundam.tistory.com/38\n\nhttp://rstoyanchev.github.io/spring-mvc-31-update/#13","slug":"2018-08-10-spring-argument-resolver","published":1,"updated":"2018-11-27T07:23:32.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp55h5i1000x4f1tosf4itxh","content":"<p>회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나… 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.</p>\n<p>그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.</p>\n<p>하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다… (Client IP를 구하는 코드가 한 10줄 정도는 된다.)</p>\n<p>그래서 중간에 Filter나 Interceptor로 해볼까…? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.</p>\n<h1><span id=\"spring-argument-resolver\">Spring Argument Resolver</span></h1>\n<p>Spring Argument Resolver는 <code>Controller에 들어오는 파라미터를 가공</code> 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공/추가/수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.<br>\nSpring에서는 <code>HandlerMethodArgumentResolver</code>라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.</p>\n<h1><span id=\"argument-resolver-동작-방식\">Argument Resolver 동작 방식</span></h1>\n<p><img src=\"./Dispatch-Seq.jpg\" alt=\"Dispatch-Seq\"></p>\n<p>(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)</p>\n<ol>\n<li>Client Request 요청</li>\n<li>Dispatcher Servlet에서 해당 요청을 처리</li>\n<li>Client Request에 대한 Handler Mapping\n<ol>\n<li>RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)</li>\n<li>Interceptor처리</li>\n<li><code>Argument Resolver 처리</code> &lt;-- 바로 여기서 우리가 지정한 Argument Resolver 실행</li>\n<li>Message Converter 처리</li>\n</ol>\n</li>\n<li>Controller Method invoke</li>\n</ol>\n<p><img src=\"./RequestMappingHandlerAdapter.png\" alt=\"RequestMappingHandlerAdapter\"></p>\n<p>RequestHandlerMappingAdapter.java &gt; getDefaultArgumentResolvers</p>\n<p>위에서 지정 된 순서대로 Argument Resolver를 실행 한다.<br>\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.<br>\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.</p>\n<h1><span id=\"custom-argument-resolver-만들기\">Custom Argument Resolver 만들기</span></h1>\n<p>내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에…)</p>\n<p>기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.<br>\nCustom Argument Resolver를 만들기 위해서는 <code>HandlerMethodArgumentResolver</code> 인터페이스를 구현하여 만든다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.resolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.MethodParameter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.util.StringUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientIpArgumentResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * resolveArgument를 실행 할 수 있는 method인지 판별</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supportsParameter</span><span class=\"params\">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//@ClientIP 어노테이션이 붙은 파라미터에 대해 적용</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> methodParameter.hasParameterAnnotation(ClientIP.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">        String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getRemoteAddr();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.</p>\n<ul>\n<li>supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n<ul>\n<li>물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.</li>\n</ul>\n</li>\n<li>resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.</li>\n</ul>\n<h1><span id=\"custom-argument-resolver-등록하기\">Custom Argument Resolver 등록하기</span></h1>\n<p>개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.</p>\n<p>전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.</p>\n<ol>\n<li>ServletContext.xml 에 등록하는 방법</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.resolver.ClientIpArgumentResolver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span>      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>Java Config를 이용하는 방법</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//WebMvcConfigurationSupport를 상속 </span></span><br><span class=\"line\"><span class=\"comment\">//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//우리가 만든 ArgumentResolver를 추가한다.</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addArgumentResolvers</span><span class=\"params\">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addArgumentResolvers(argumentResolvers);</span><br><span class=\"line\">        argumentResolvers.add(<span class=\"keyword\">new</span> ClientIpArgumentResolver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"controller에-적용\">Controller에 적용</span></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 요청을 보낸 Client Ip를 return</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> clientIp</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/client\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getClientIp</span><span class=\"params\">(@ClientIP String clientIp)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.format(<span class=\"string\">\"Request Client Ip = %s\"</span>, clientIp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Controller 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.</p>\n<p>실행 결과</p>\n<p><img src=\"./argument-resolver-result.png\" alt=\"argument-resolver-result\"></p>\n<h1><span id=\"참조\">참조</span></h1>\n<p>토비의 스프링 vol.2</p>\n<p><a href=\"http://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"noopener\">http://jekalmin.tistory.com/entry/커스텀-ArgumentResolver-등록하기</a></p>\n<p><a href=\"http://zgundam.tistory.com/38\" target=\"_blank\" rel=\"noopener\">http://zgundam.tistory.com/38</a></p>\n<p><a href=\"http://rstoyanchev.github.io/spring-mvc-31-update/#13\" target=\"_blank\" rel=\"noopener\">http://rstoyanchev.github.io/spring-mvc-31-update/#13</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나… 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.</p>\n<p>그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.</p>\n<p>하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다… (Client IP를 구하는 코드가 한 10줄 정도는 된다.)</p>\n<p>그래서 중간에 Filter나 Interceptor로 해볼까…? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.</p>\n<h1>Spring Argument Resolver</h1>\n<p>Spring Argument Resolver는 <code>Controller에 들어오는 파라미터를 가공</code> 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공/추가/수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.<br>\nSpring에서는 <code>HandlerMethodArgumentResolver</code>라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.</p>\n<h1>Argument Resolver 동작 방식</h1>\n<p><img src=\"./Dispatch-Seq.jpg\" alt=\"Dispatch-Seq\"></p>\n<p>(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)</p>\n<ol>\n<li>Client Request 요청</li>\n<li>Dispatcher Servlet에서 해당 요청을 처리</li>\n<li>Client Request에 대한 Handler Mapping\n<ol>\n<li>RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)</li>\n<li>Interceptor처리</li>\n<li><code>Argument Resolver 처리</code> &lt;-- 바로 여기서 우리가 지정한 Argument Resolver 실행</li>\n<li>Message Converter 처리</li>\n</ol>\n</li>\n<li>Controller Method invoke</li>\n</ol>\n<p><img src=\"./RequestMappingHandlerAdapter.png\" alt=\"RequestMappingHandlerAdapter\"></p>\n<p>RequestHandlerMappingAdapter.java &gt; getDefaultArgumentResolvers</p>\n<p>위에서 지정 된 순서대로 Argument Resolver를 실행 한다.<br>\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.<br>\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.</p>\n<h1>Custom Argument Resolver 만들기</h1>\n<p>내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에…)</p>\n<p>기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.<br>\nCustom Argument Resolver를 만들기 위해서는 <code>HandlerMethodArgumentResolver</code> 인터페이스를 구현하여 만든다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.resolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.MethodParameter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.util.StringUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientIpArgumentResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * resolveArgument를 실행 할 수 있는 method인지 판별</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supportsParameter</span><span class=\"params\">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//@ClientIP 어노테이션이 붙은 파라미터에 대해 적용</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> methodParameter.hasParameterAnnotation(ClientIP.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">        String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getRemoteAddr();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.</p>\n<ul>\n<li>supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n<ul>\n<li>물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.</li>\n</ul>\n</li>\n<li>resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.</li>\n</ul>\n<h1>Custom Argument Resolver 등록하기</h1>\n<p>개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.</p>\n<p>전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.</p>\n<ol>\n<li>ServletContext.xml 에 등록하는 방법</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.resolver.ClientIpArgumentResolver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span>      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>Java Config를 이용하는 방법</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//WebMvcConfigurationSupport를 상속 </span></span><br><span class=\"line\"><span class=\"comment\">//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//우리가 만든 ArgumentResolver를 추가한다.</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addArgumentResolvers</span><span class=\"params\">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addArgumentResolvers(argumentResolvers);</span><br><span class=\"line\">        argumentResolvers.add(<span class=\"keyword\">new</span> ClientIpArgumentResolver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>Controller에 적용</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 요청을 보낸 Client Ip를 return</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> clientIp</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/client\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getClientIp</span><span class=\"params\">(@ClientIP String clientIp)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.format(<span class=\"string\">\"Request Client Ip = %s\"</span>, clientIp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Controller 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.</p>\n<p>실행 결과</p>\n<p><img src=\"./argument-resolver-result.png\" alt=\"argument-resolver-result\"></p>\n<h1>참조</h1>\n<p>토비의 스프링 vol.2</p>\n<p><a href=\"http://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"noopener\">http://jekalmin.tistory.com/entry/커스텀-ArgumentResolver-등록하기</a></p>\n<p><a href=\"http://zgundam.tistory.com/38\" target=\"_blank\" rel=\"noopener\">http://zgundam.tistory.com/38</a></p>\n<p><a href=\"http://rstoyanchev.github.io/spring-mvc-31-update/#13\" target=\"_blank\" rel=\"noopener\">http://rstoyanchev.github.io/spring-mvc-31-update/#13</a></p>\n"},{"title":"Spring Filter와 Interceptor","catalog":true,"date":"2018-08-25T09:30:26.000Z","subtitle":null,"header-img":null,"Categories":["Spring"],"typora-root-url":"./2018-08-18-spring-filter-interceptor","typora-copy-images-to":"./2018-08-18-spring-filter-interceptor","_content":"\n# 들어가며..\n\n개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다. \n회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.\nFilter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.\n\n\n\n# Spring Request Flow\n\n![spring-request-lifecycle](./spring-request-lifecycle.jpg)\n\n\n\n이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.\n(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)\n\n\n\n그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.\nFilter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 `J2EE 표준스펙`이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다. \n\nInterceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.\n따라서 Interceptor는 `Spring Framework에서 제공하는 API`이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.\n\n\n\n# Filter\n\n위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.\n실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 `Spring Security, CORS Filter`등이 있다.\n\n\n\n## Filter Chain\n\n![filter-chain](./filter-chain.gif)\n\nFilter의 큰 특징으로는 Filter chain이라는 개념이 있다.\n실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 `Standard Context`에 `FilterMap`이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 `Filter chain`을 구성하게 되어 순차적으로 실행 되게 된다. \n\n* [Request에 대한 Filter Chain 생성](https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705)\n* [Request URL에 대한 FilterMap 생성](https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53)\n\n※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.\n\n\n\nFilter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.\n\n1. url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.\n2. servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.\n\n\n\n## Filter 생성\n\n~~~java\npackage com.example.springstudy.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\npublic class TestFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\t\t//filter 생성 시 처리\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        //다음 Filter 실행 전 처리 (preHandle)\n        \n        //다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)\n\t\tfilterChain.doFilter(servletRequest, servletResponse);\n        \n        //다음 Filter 실행 후 처리 (postHandle)\n    }\n\n    @Override\n    public void destroy() {\n\t\t//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)\n    }\n}\n\n~~~\n\n\n\n## 설정 방법\n\nFilter를 등록하는 방식을 크게 4가지 정도 있다.\n\n1. web.xml 등록 방식\n2. Java config 등록 방식 -> FilterRegistration Bean을 정의하여 추가할 Filter를 정의\n3. java config 등록 방식 -> AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가\n4. @WebFilter Annotation 등록 방식\n\n\n\n### 1. web.xml 등록 방식\n\n```xml\n<filter>\n    <filter-name>testFilter</filter-name>\n    <filter-class>com.example.springstudy.filter.TestFilter</filter-class>\n</filter>\n<filter>\n    <filter-name>testFilter2</filter-name>\n    <filter-class>com.example.springstudy.filter.TestFilter</filter-class>\n</filter>\n\n<filter-mapping>\n    <filter-name>testFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n    <!-- url-pattern 대신 Servlet을 지정할 수도 있다. -->\n    <servlet-name>testServlet</servlet-name> \n</filter-mapping>\n<filter-mapping>\n    <filter-name>testFilter2</filter-name>\n    <url-pattern>/*</url-pattern>\n    <!-- url-pattern 대신 Servlet을 지정할 수도 있다. -->\n    <servlet-name>testServlet</servlet-name> \n</filter-mapping>\n```\n\n\n\n### 2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의\n\n~~~java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class WebApplicationFilterConfig {\n\n    @Bean\n    public FilterRegistrationBean testFilterRegistration() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n        filterRegistrationBean.setFilter(new TestFilter());\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        filterRegistrationBean.setName(\"Test-Filter\");\n        filterRegistrationBean.setOrder(1);\n\n        return filterRegistrationBean;\n    }\n    \n    @Bean\n    public FilterRegistrationBean testFilter2Registration() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n        filterRegistrationBean.setFilter(new TestFilter2());\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        filterRegistrationBean.setName(\"Test-Filter2\");\n        filterRegistrationBean.setOrder(2);\n\n        return filterRegistrationBean;\n    }\n}\n~~~\n\n\n\nFilter chain의 실행 순서는 Filter1(Prehandle) -> Filter2(Prehandle) -> Filter2 (Posthandle) -> Filter1 (Posthandle) 순으로 실행 된다. \n\n\n\n### 3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가\n\n※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)\n\n~~~java\npackage com.example.springstudy.config;\n\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\nimport javax.servlet.Filter;\n\n@Configuration\npublic class WebInitializerConfig extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Filter[] getServletFilters() {\n        //추가할 필터 리스트를 추가한다.\n        return new Filter[]{new TestFilter(), new TestFilter2()};\n    }\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[0];\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class[0];\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[0];\n    }\n}\n\n~~~\n\n\n\n### 4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록\n\n~~~java\npackage com.example.springstudy.filter;\n\nimport org.springframework.core.annotation.Order;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n@Component\n@WebFilter(\n        description = \"1번째 필터\",\n        urlPatterns = \"/*\",\n        filterName = \"Test-Filter1\"\n)\n@Order(2)\npublic class TestFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"start testFilter1\");\n        filterChain.doFilter(servletRequest, servletResponse);\n        System.out.println(\"finish testFilter1\");\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n~~~\n\n다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.\n@Component -> Component-scan 시 Spring Bean으로 등록 된다.\n@WebFIlter -> Filter등록에 필요한 Interface를 제공한다.\n@Order -> @Component 어노테이션 사용 시 `Order Interface` 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다. \n개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.\n\n\n\n# Interceptor\n\n인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.\n\n인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 `preHandle(), postHandle()` 메소드가 구분 되어져 있어, 분기가 명확하다.\n또한 Filter와는 다르게 `handlerMethod`를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.\n\n\n\n## Interceptor 동작 방식\n\n1. 외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.\n2. DispatcherServlet의 doDispatch() 메소드에서 [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013) 메소드로 HandlerExecutionChain를 호출 한다.\n   (정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)\n3.  [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227) 메소드 내부에는 [getHandlerInternal()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401) 메소드로 handler를 가져오는 부분이 있다.\n   이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.\n4. 그 다음 [getHandlerExecutionChain()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480) 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.\n5. 추출 된 interceptor들에 대해 [preHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032) 메소드를 실행 시킨다.\n   (preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)\n6. 그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.\n7. 메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 [postHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044) 메소드를 실행 시킨다.\n\n\n\n## 설정 방법\n\n설정 방법은 크게 2가지로 이루어져 있다.\n\n1. servlet-context.xml에 등록\n\n2. Java-config 방식을 이용한 등록 -> WebMvcConfigurationSupport 이용하여 등록\n\n\n###  1. Servlet-context.xml에 등록\n\n~~~xml\n<mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/client\"/>\n            <mvc:mapping path=\"/client/test1\"/>\n            <bean id=\"testInterceptor\"\n                  class=\"com.example.springstudy.interceptor.TestInterceptor\"/>\n        </mvc:interceptor>\n</mvc:interceptors>\n~~~\n\n\n\n### 2. WebMvcConfigurationSupport 이용하여 등록\n\n~~~java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.interceptor.TestInterceptor;\nimport com.example.springstudy.interceptor.TestInterceptor2;\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n\nimport java.util.List;\n\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n\n    /**\n    * addInterceptors 메소드를 통해 Interceptor 등록\n    */\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) {\n        super.addInterceptors(registry);\n        //String... 타입으로 여러개 지정 가능\n        registry.addInterceptor(new TestInterceptor())\n                .addPathPatterns(\"/client/test1\", \"/client/help\");\n        //List 타입으로 여러개 지정 가능\n        registry.addInterceptor(new TestInterceptor2())\n                .addPathPatterns(Lists.newArrayList(\"/client\", \"/client/test1\"));\n    }\n}\n\n~~~\n\n\n\n# 참조\n\nhttp://javacan.tistory.com/entry/58\nhttp://www.leafcats.com/39\nhttps://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/","source":"_posts/2018-08-18-spring-filter-interceptor.md","raw":"---\ntitle: Spring Filter와 Interceptor\ncatalog: true\ndate: 2018-08-25 18:30:26\nsubtitle:\nheader-img:\nCategories:\n - Spring\ntags: \n - Spring\n - Spring Core\ntypora-root-url: ./2018-08-18-spring-filter-interceptor\ntypora-copy-images-to: ./2018-08-18-spring-filter-interceptor\n---\n\n# 들어가며..\n\n개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다. \n회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.\nFilter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.\n\n\n\n# Spring Request Flow\n\n![spring-request-lifecycle](./spring-request-lifecycle.jpg)\n\n\n\n이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.\n(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)\n\n\n\n그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.\nFilter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 `J2EE 표준스펙`이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다. \n\nInterceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.\n따라서 Interceptor는 `Spring Framework에서 제공하는 API`이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.\n\n\n\n# Filter\n\n위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.\n실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 `Spring Security, CORS Filter`등이 있다.\n\n\n\n## Filter Chain\n\n![filter-chain](./filter-chain.gif)\n\nFilter의 큰 특징으로는 Filter chain이라는 개념이 있다.\n실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 `Standard Context`에 `FilterMap`이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 `Filter chain`을 구성하게 되어 순차적으로 실행 되게 된다. \n\n* [Request에 대한 Filter Chain 생성](https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705)\n* [Request URL에 대한 FilterMap 생성](https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53)\n\n※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.\n\n\n\nFilter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.\n\n1. url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.\n2. servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.\n\n\n\n## Filter 생성\n\n~~~java\npackage com.example.springstudy.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\npublic class TestFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\t\t//filter 생성 시 처리\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        //다음 Filter 실행 전 처리 (preHandle)\n        \n        //다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)\n\t\tfilterChain.doFilter(servletRequest, servletResponse);\n        \n        //다음 Filter 실행 후 처리 (postHandle)\n    }\n\n    @Override\n    public void destroy() {\n\t\t//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)\n    }\n}\n\n~~~\n\n\n\n## 설정 방법\n\nFilter를 등록하는 방식을 크게 4가지 정도 있다.\n\n1. web.xml 등록 방식\n2. Java config 등록 방식 -> FilterRegistration Bean을 정의하여 추가할 Filter를 정의\n3. java config 등록 방식 -> AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가\n4. @WebFilter Annotation 등록 방식\n\n\n\n### 1. web.xml 등록 방식\n\n```xml\n<filter>\n    <filter-name>testFilter</filter-name>\n    <filter-class>com.example.springstudy.filter.TestFilter</filter-class>\n</filter>\n<filter>\n    <filter-name>testFilter2</filter-name>\n    <filter-class>com.example.springstudy.filter.TestFilter</filter-class>\n</filter>\n\n<filter-mapping>\n    <filter-name>testFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n    <!-- url-pattern 대신 Servlet을 지정할 수도 있다. -->\n    <servlet-name>testServlet</servlet-name> \n</filter-mapping>\n<filter-mapping>\n    <filter-name>testFilter2</filter-name>\n    <url-pattern>/*</url-pattern>\n    <!-- url-pattern 대신 Servlet을 지정할 수도 있다. -->\n    <servlet-name>testServlet</servlet-name> \n</filter-mapping>\n```\n\n\n\n### 2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의\n\n~~~java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class WebApplicationFilterConfig {\n\n    @Bean\n    public FilterRegistrationBean testFilterRegistration() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n        filterRegistrationBean.setFilter(new TestFilter());\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        filterRegistrationBean.setName(\"Test-Filter\");\n        filterRegistrationBean.setOrder(1);\n\n        return filterRegistrationBean;\n    }\n    \n    @Bean\n    public FilterRegistrationBean testFilter2Registration() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n        filterRegistrationBean.setFilter(new TestFilter2());\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        filterRegistrationBean.setName(\"Test-Filter2\");\n        filterRegistrationBean.setOrder(2);\n\n        return filterRegistrationBean;\n    }\n}\n~~~\n\n\n\nFilter chain의 실행 순서는 Filter1(Prehandle) -> Filter2(Prehandle) -> Filter2 (Posthandle) -> Filter1 (Posthandle) 순으로 실행 된다. \n\n\n\n### 3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가\n\n※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)\n\n~~~java\npackage com.example.springstudy.config;\n\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\nimport javax.servlet.Filter;\n\n@Configuration\npublic class WebInitializerConfig extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Filter[] getServletFilters() {\n        //추가할 필터 리스트를 추가한다.\n        return new Filter[]{new TestFilter(), new TestFilter2()};\n    }\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[0];\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class[0];\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[0];\n    }\n}\n\n~~~\n\n\n\n### 4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록\n\n~~~java\npackage com.example.springstudy.filter;\n\nimport org.springframework.core.annotation.Order;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n@Component\n@WebFilter(\n        description = \"1번째 필터\",\n        urlPatterns = \"/*\",\n        filterName = \"Test-Filter1\"\n)\n@Order(2)\npublic class TestFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"start testFilter1\");\n        filterChain.doFilter(servletRequest, servletResponse);\n        System.out.println(\"finish testFilter1\");\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n~~~\n\n다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.\n@Component -> Component-scan 시 Spring Bean으로 등록 된다.\n@WebFIlter -> Filter등록에 필요한 Interface를 제공한다.\n@Order -> @Component 어노테이션 사용 시 `Order Interface` 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다. \n개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.\n\n\n\n# Interceptor\n\n인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.\n\n인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 `preHandle(), postHandle()` 메소드가 구분 되어져 있어, 분기가 명확하다.\n또한 Filter와는 다르게 `handlerMethod`를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.\n\n\n\n## Interceptor 동작 방식\n\n1. 외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.\n2. DispatcherServlet의 doDispatch() 메소드에서 [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013) 메소드로 HandlerExecutionChain를 호출 한다.\n   (정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)\n3.  [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227) 메소드 내부에는 [getHandlerInternal()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401) 메소드로 handler를 가져오는 부분이 있다.\n   이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.\n4. 그 다음 [getHandlerExecutionChain()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480) 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.\n5. 추출 된 interceptor들에 대해 [preHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032) 메소드를 실행 시킨다.\n   (preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)\n6. 그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.\n7. 메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 [postHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044) 메소드를 실행 시킨다.\n\n\n\n## 설정 방법\n\n설정 방법은 크게 2가지로 이루어져 있다.\n\n1. servlet-context.xml에 등록\n\n2. Java-config 방식을 이용한 등록 -> WebMvcConfigurationSupport 이용하여 등록\n\n\n###  1. Servlet-context.xml에 등록\n\n~~~xml\n<mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/client\"/>\n            <mvc:mapping path=\"/client/test1\"/>\n            <bean id=\"testInterceptor\"\n                  class=\"com.example.springstudy.interceptor.TestInterceptor\"/>\n        </mvc:interceptor>\n</mvc:interceptors>\n~~~\n\n\n\n### 2. WebMvcConfigurationSupport 이용하여 등록\n\n~~~java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.interceptor.TestInterceptor;\nimport com.example.springstudy.interceptor.TestInterceptor2;\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n\nimport java.util.List;\n\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n\n    /**\n    * addInterceptors 메소드를 통해 Interceptor 등록\n    */\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) {\n        super.addInterceptors(registry);\n        //String... 타입으로 여러개 지정 가능\n        registry.addInterceptor(new TestInterceptor())\n                .addPathPatterns(\"/client/test1\", \"/client/help\");\n        //List 타입으로 여러개 지정 가능\n        registry.addInterceptor(new TestInterceptor2())\n                .addPathPatterns(Lists.newArrayList(\"/client\", \"/client/test1\"));\n    }\n}\n\n~~~\n\n\n\n# 참조\n\nhttp://javacan.tistory.com/entry/58\nhttp://www.leafcats.com/39\nhttps://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/","slug":"2018-08-18-spring-filter-interceptor","published":1,"updated":"2018-11-27T07:23:32.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp55h5i2000z4f1tuku4je3q","content":"<h1><span id=\"들어가며\">들어가며…</span></h1>\n<p>개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다.<br>\n회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.<br>\nFilter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.</p>\n<h1><span id=\"spring-request-flow\">Spring Request Flow</span></h1>\n<p><img src=\"./spring-request-lifecycle.jpg\" alt=\"spring-request-lifecycle\"></p>\n<p>이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.<br>\n(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)</p>\n<p>그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.<br>\nFilter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 <code>J2EE 표준스펙</code>이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다.</p>\n<p>Interceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.<br>\n따라서 Interceptor는 <code>Spring Framework에서 제공하는 API</code>이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.</p>\n<h1><span id=\"filter\">Filter</span></h1>\n<p>위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.<br>\n실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 <code>Spring Security, CORS Filter</code>등이 있다.</p>\n<h2><span id=\"filter-chain\">Filter Chain</span></h2>\n<p><img src=\"./filter-chain.gif\" alt=\"filter-chain\"></p>\n<p>Filter의 큰 특징으로는 Filter chain이라는 개념이 있다.<br>\n실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 <code>Standard Context</code>에 <code>FilterMap</code>이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 <code>Filter chain</code>을 구성하게 되어 순차적으로 실행 되게 된다.</p>\n<ul>\n<li><a href=\"https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705\" target=\"_blank\" rel=\"noopener\">Request에 대한 Filter Chain 생성</a></li>\n<li><a href=\"https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53\" target=\"_blank\" rel=\"noopener\">Request URL에 대한 FilterMap 생성</a></li>\n</ul>\n<p>※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.</p>\n<p>Filter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.</p>\n<ol>\n<li>url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>\n<li>servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>\n</ol>\n<h2><span id=\"filter-생성\">Filter 생성</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.annotation.WebFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//filter 생성 시 처리</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//다음 Filter 실행 전 처리 (preHandle)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)</span></span><br><span class=\"line\">\t\tfilterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//다음 Filter 실행 후 처리 (postHandle)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"설정-방법\">설정 방법</span></h2>\n<p>Filter를 등록하는 방식을 크게 4가지 정도 있다.</p>\n<ol>\n<li>web.xml 등록 방식</li>\n<li>Java config 등록 방식 -&gt; FilterRegistration Bean을 정의하여 추가할 Filter를 정의</li>\n<li>java config 등록 방식 -&gt; AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</li>\n<li>@WebFilter Annotation 등록 방식</li>\n</ol>\n<h3><span id=\"1-webxml-등록-방식\">1. web.xml 등록 방식</span></h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"2-filterregistration-bean을-정의하여-추가할-filter를-정의\">2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.filter.TestFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebApplicationFilterConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">testFilterRegistration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean filterRegistrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        filterRegistrationBean.setFilter(<span class=\"keyword\">new</span> TestFilter());</span><br><span class=\"line\">        filterRegistrationBean.addUrlPatterns(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setName(<span class=\"string\">\"Test-Filter\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setOrder(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">testFilter2Registration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean filterRegistrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        filterRegistrationBean.setFilter(<span class=\"keyword\">new</span> TestFilter2());</span><br><span class=\"line\">        filterRegistrationBean.addUrlPatterns(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setName(<span class=\"string\">\"Test-Filter2\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setOrder(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Filter chain의 실행 순서는 Filter1(Prehandle) -&gt; Filter2(Prehandle) -&gt; Filter2 (Posthandle) -&gt; Filter1 (Posthandle) 순으로 실행 된다.</p>\n<h3><span id=\"3-abstractannotationconfigdispatcherservletinitializer에서-getservletfilter에-추가\">3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</span></h3>\n<p>※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.Filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebInitializerConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Filter[] getServletFilters() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//추가할 필터 리스트를 추가한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Filter[]&#123;<span class=\"keyword\">new</span> TestFilter(), <span class=\"keyword\">new</span> TestFilter2()&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String[] getServletMappings() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"4-component-webfilter-order-어노테이션을-이용한-필터-등록\">4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.annotation.Order;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.annotation.WebFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@WebFilter</span>(</span><br><span class=\"line\">        description = <span class=\"string\">\"1번째 필터\"</span>,</span><br><span class=\"line\">        urlPatterns = <span class=\"string\">\"/*\"</span>,</span><br><span class=\"line\">        filterName = <span class=\"string\">\"Test-Filter1\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"meta\">@Order</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"start testFilter1\"</span>);</span><br><span class=\"line\">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"finish testFilter1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.<br>\n@Component -&gt; Component-scan 시 Spring Bean으로 등록 된다.<br>\n@WebFIlter -&gt; Filter등록에 필요한 Interface를 제공한다.<br>\n@Order -&gt; @Component 어노테이션 사용 시 <code>Order Interface</code> 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다.<br>\n개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.</p>\n<h1><span id=\"interceptor\">Interceptor</span></h1>\n<p>인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.</p>\n<p>인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 <code>preHandle(), postHandle()</code> 메소드가 구분 되어져 있어, 분기가 명확하다.<br>\n또한 Filter와는 다르게 <code>handlerMethod</code>를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.</p>\n<h2><span id=\"interceptor-동작-방식\">Interceptor 동작 방식</span></h2>\n<ol>\n<li>외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.</li>\n<li>DispatcherServlet의 doDispatch() 메소드에서 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드로 HandlerExecutionChain를 호출 한다.<br>\n(정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드 내부에는 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401\" target=\"_blank\" rel=\"noopener\">getHandlerInternal()</a> 메소드로 handler를 가져오는 부분이 있다.<br>\n이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.</li>\n<li>그 다음 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480\" target=\"_blank\" rel=\"noopener\">getHandlerExecutionChain()</a> 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.</li>\n<li>추출 된 interceptor들에 대해 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032\" target=\"_blank\" rel=\"noopener\">preHandle()</a> 메소드를 실행 시킨다.<br>\n(preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)</li>\n<li>그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.</li>\n<li>메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044\" target=\"_blank\" rel=\"noopener\">postHandle()</a> 메소드를 실행 시킨다.</li>\n</ol>\n<h2><span id=\"설정-방법\">설정 방법</span></h2>\n<p>설정 방법은 크게 2가지로 이루어져 있다.</p>\n<ol>\n<li>\n<p>servlet-context.xml에 등록</p>\n</li>\n<li>\n<p>Java-config 방식을 이용한 등록 -&gt; WebMvcConfigurationSupport 이용하여 등록</p>\n</li>\n</ol>\n<h3><span id=\"1-servlet-contextxml에-등록\">1. Servlet-context.xml에 등록</span></h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/client\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/client/test1\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testInterceptor\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                  <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.interceptor.TestInterceptor\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"2-webmvcconfigurationsupport-이용하여-등록\">2. WebMvcConfigurationSupport 이용하여 등록</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.interceptor.TestInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.interceptor.TestInterceptor2;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * addInterceptors 메소드를 통해 Interceptor 등록</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addInterceptors(registry);</span><br><span class=\"line\">        <span class=\"comment\">//String... 타입으로 여러개 지정 가능</span></span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> TestInterceptor())</span><br><span class=\"line\">                .addPathPatterns(<span class=\"string\">\"/client/test1\"</span>, <span class=\"string\">\"/client/help\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//List 타입으로 여러개 지정 가능</span></span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> TestInterceptor2())</span><br><span class=\"line\">                .addPathPatterns(Lists.newArrayList(<span class=\"string\">\"/client\"</span>, <span class=\"string\">\"/client/test1\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"참조\">참조</span></h1>\n<p><a href=\"http://javacan.tistory.com/entry/58\" target=\"_blank\" rel=\"noopener\">http://javacan.tistory.com/entry/58</a><br>\n<a href=\"http://www.leafcats.com/39\" target=\"_blank\" rel=\"noopener\">http://www.leafcats.com/39</a><br>\n<a href=\"https://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war</a><br>\n<a href=\"https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/\" target=\"_blank\" rel=\"noopener\">https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며…</h1>\n<p>개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다.<br>\n회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.<br>\nFilter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.</p>\n<h1>Spring Request Flow</h1>\n<p><img src=\"./spring-request-lifecycle.jpg\" alt=\"spring-request-lifecycle\"></p>\n<p>이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.<br>\n(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)</p>\n<p>그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.<br>\nFilter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 <code>J2EE 표준스펙</code>이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다.</p>\n<p>Interceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.<br>\n따라서 Interceptor는 <code>Spring Framework에서 제공하는 API</code>이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.</p>\n<h1>Filter</h1>\n<p>위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.<br>\n실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 <code>Spring Security, CORS Filter</code>등이 있다.</p>\n<h2>Filter Chain</h2>\n<p><img src=\"./filter-chain.gif\" alt=\"filter-chain\"></p>\n<p>Filter의 큰 특징으로는 Filter chain이라는 개념이 있다.<br>\n실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 <code>Standard Context</code>에 <code>FilterMap</code>이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 <code>Filter chain</code>을 구성하게 되어 순차적으로 실행 되게 된다.</p>\n<ul>\n<li><a href=\"https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705\" target=\"_blank\" rel=\"noopener\">Request에 대한 Filter Chain 생성</a></li>\n<li><a href=\"https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53\" target=\"_blank\" rel=\"noopener\">Request URL에 대한 FilterMap 생성</a></li>\n</ul>\n<p>※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.</p>\n<p>Filter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.</p>\n<ol>\n<li>url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>\n<li>servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>\n</ol>\n<h2>Filter 생성</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.annotation.WebFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//filter 생성 시 처리</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//다음 Filter 실행 전 처리 (preHandle)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)</span></span><br><span class=\"line\">\t\tfilterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//다음 Filter 실행 후 처리 (postHandle)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>설정 방법</h2>\n<p>Filter를 등록하는 방식을 크게 4가지 정도 있다.</p>\n<ol>\n<li>web.xml 등록 방식</li>\n<li>Java config 등록 방식 -&gt; FilterRegistration Bean을 정의하여 추가할 Filter를 정의</li>\n<li>java config 등록 방식 -&gt; AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</li>\n<li>@WebFilter Annotation 등록 방식</li>\n</ol>\n<h3>1. web.xml 등록 방식</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>testFilter2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.filter.TestFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebApplicationFilterConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">testFilterRegistration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean filterRegistrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        filterRegistrationBean.setFilter(<span class=\"keyword\">new</span> TestFilter());</span><br><span class=\"line\">        filterRegistrationBean.addUrlPatterns(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setName(<span class=\"string\">\"Test-Filter\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setOrder(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">testFilter2Registration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean filterRegistrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        filterRegistrationBean.setFilter(<span class=\"keyword\">new</span> TestFilter2());</span><br><span class=\"line\">        filterRegistrationBean.addUrlPatterns(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setName(<span class=\"string\">\"Test-Filter2\"</span>);</span><br><span class=\"line\">        filterRegistrationBean.setOrder(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Filter chain의 실행 순서는 Filter1(Prehandle) -&gt; Filter2(Prehandle) -&gt; Filter2 (Posthandle) -&gt; Filter1 (Posthandle) 순으로 실행 된다.</p>\n<h3>3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</h3>\n<p>※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.Filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebInitializerConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Filter[] getServletFilters() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//추가할 필터 리스트를 추가한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Filter[]&#123;<span class=\"keyword\">new</span> TestFilter(), <span class=\"keyword\">new</span> TestFilter2()&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String[] getServletMappings() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.filter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.annotation.Order;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.annotation.WebFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@WebFilter</span>(</span><br><span class=\"line\">        description = <span class=\"string\">\"1번째 필터\"</span>,</span><br><span class=\"line\">        urlPatterns = <span class=\"string\">\"/*\"</span>,</span><br><span class=\"line\">        filterName = <span class=\"string\">\"Test-Filter1\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"meta\">@Order</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"start testFilter1\"</span>);</span><br><span class=\"line\">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"finish testFilter1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.<br>\n@Component -&gt; Component-scan 시 Spring Bean으로 등록 된다.<br>\n@WebFIlter -&gt; Filter등록에 필요한 Interface를 제공한다.<br>\n@Order -&gt; @Component 어노테이션 사용 시 <code>Order Interface</code> 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다.<br>\n개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.</p>\n<h1>Interceptor</h1>\n<p>인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.</p>\n<p>인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 <code>preHandle(), postHandle()</code> 메소드가 구분 되어져 있어, 분기가 명확하다.<br>\n또한 Filter와는 다르게 <code>handlerMethod</code>를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.</p>\n<h2>Interceptor 동작 방식</h2>\n<ol>\n<li>외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.</li>\n<li>DispatcherServlet의 doDispatch() 메소드에서 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드로 HandlerExecutionChain를 호출 한다.<br>\n(정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드 내부에는 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401\" target=\"_blank\" rel=\"noopener\">getHandlerInternal()</a> 메소드로 handler를 가져오는 부분이 있다.<br>\n이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.</li>\n<li>그 다음 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480\" target=\"_blank\" rel=\"noopener\">getHandlerExecutionChain()</a> 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.</li>\n<li>추출 된 interceptor들에 대해 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032\" target=\"_blank\" rel=\"noopener\">preHandle()</a> 메소드를 실행 시킨다.<br>\n(preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)</li>\n<li>그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.</li>\n<li>메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044\" target=\"_blank\" rel=\"noopener\">postHandle()</a> 메소드를 실행 시킨다.</li>\n</ol>\n<h2>설정 방법</h2>\n<p>설정 방법은 크게 2가지로 이루어져 있다.</p>\n<ol>\n<li>\n<p>servlet-context.xml에 등록</p>\n</li>\n<li>\n<p>Java-config 방식을 이용한 등록 -&gt; WebMvcConfigurationSupport 이용하여 등록</p>\n</li>\n</ol>\n<h3>1. Servlet-context.xml에 등록</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/client\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/client/test1\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testInterceptor\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                  <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.interceptor.TestInterceptor\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>2. WebMvcConfigurationSupport 이용하여 등록</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.interceptor.TestInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.interceptor.TestInterceptor2;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * addInterceptors 메소드를 통해 Interceptor 등록</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addInterceptors(registry);</span><br><span class=\"line\">        <span class=\"comment\">//String... 타입으로 여러개 지정 가능</span></span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> TestInterceptor())</span><br><span class=\"line\">                .addPathPatterns(<span class=\"string\">\"/client/test1\"</span>, <span class=\"string\">\"/client/help\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//List 타입으로 여러개 지정 가능</span></span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> TestInterceptor2())</span><br><span class=\"line\">                .addPathPatterns(Lists.newArrayList(<span class=\"string\">\"/client\"</span>, <span class=\"string\">\"/client/test1\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>참조</h1>\n<p><a href=\"http://javacan.tistory.com/entry/58\" target=\"_blank\" rel=\"noopener\">http://javacan.tistory.com/entry/58</a><br>\n<a href=\"http://www.leafcats.com/39\" target=\"_blank\" rel=\"noopener\">http://www.leafcats.com/39</a><br>\n<a href=\"https://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war</a><br>\n<a href=\"https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/\" target=\"_blank\" rel=\"noopener\">https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</a></p>\n"},{"title":"Spring Handle Exception","catalog":true,"date":"2018-08-30T14:30:26.000Z","subtitle":"Spring에서 지원하는 다양한 예외처리 방법","header-img":null,"Categories":["Spring"],"typora-root-url":"./2018-08-25-spring-mvc-handle-exception","typora-copy-images-to":"./2018-08-25-spring-mvc-handle-exception","_content":"\n# 들어가며\n\nSpring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.\nDispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.\nSpring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.\n\n\n\n# 예외(Exception) 처리는 어떻게?\n\nSpring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.\n\n1. Controller 레벨에서 처리\n2. Global 레벨에서 처리\n3. HandlerExceptionResolver를 이용한 처리\n\n\n\n# Controller 레벨에서의 처리\n\nSpring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.\n`@ExceptionHandler` 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.\n\n예제 코드\n\n~~~java\npackage com.example.springstudy.demo2.controller;\n\nimport com.example.springstudy.demo2.exception.DemoException;\nimport com.example.springstudy.demo2.exception.FilterException;\nimport com.example.springstudy.demo2.exception.InterceptorException;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@Slf4j\n@Controller\npublic class DemoController {\n\n    @GetMapping(path=\"/exception/demo\")\n    public String occurDemoException() {\n        //강제로 DemoException을 발생 시켜 보았다.\n        throw new DemoException(); //occur DemoException (RuntimeException)\n    }\n    \n    @GetMapping(path=\"/exception/demo2\")\n    public String occurDemoException2() {\n        //강제로 DemoException을 발생 시켜 보았다.\n        throw new DemoException(); //occur DemoException (RuntimeException)\n    }\n\n    @ExceptionHandler(value=DemoException.class)\n    public String handleDemoException(DemoException e) {\n        log.error(e.getMessage());\n        return \"/error/404\";\n    }\n}\n~~~\n\nDemoController내에서 발생한 DemoException에 대해서는 `handleDemoException` 메소드에서 모두 처리를 해준다.\n\n* Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면` @ExceptionHandler` 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.\n* Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.\n\nSpring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.\n\n\n\n# Global 레벨에서의 처리\n\n만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?\n위의 방식 처럼 Controller 별로 `@ExceptionHandler` 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.\nSpring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.\n\n* `@ControllerAdvice` - Exception 처리 후 Error Page등을 통해 처리가 가능하다.\n* `@RestControllerAdvice`\n  * REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)\n  * @RestControllerAdvice = @ControllerAdvice + @ResponseBody\n\n위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.\n\n**주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!**\n\n\n\n예제 코드\n\n~~~java\nimport com.example.springstudy.demo2.exception.DemoException;\nimport com.example.springstudy.demo2.exception.FilterException;\nimport com.example.springstudy.demo2.exception.InterceptorException;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\n\n@Slf4j\n@ControllerAdvice\npublic class DemoControllerAdvisor {\n\n    //모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리\n    @ExceptionHandler(value = DemoException.class)\n    public String handleDemoExceptionForGlobal(DemoException e) {\n        log.error(e.getMessage());\n        return \"/error/404\";\n    }\n}\n~~~\n\n\n\n## 여기서 궁금한 점...\n\nController 클래스 내에 `@ExceptionHandler`, `@ControllerAdvice` 클래스 내의 `@ExceptionHandler` 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?\n\n\n\n실험을 해보았다.\n준비물은 아래와 같다.\n\n1. DemoException을 throw하는 DemoController1, DemoController2\n2. DemoController1에서는 DemoException에 대해 `@ExceptionHandler`를 구현하였다.\n3. DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.\n4. 전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고\n   `@ExceptionHandler`를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.\n\n\n\n### Test-Case\n\n1. DemoController1 -> throw DemoException\n2. DemoController2 -> throw DemoException\n\n\n\n### 어떤 결과가 나왔을까?\n\n1. DemoController1 -> throw DemoException\n   * 예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.\n   * 예외처리가 끝난 후 404페이지가 리턴 되었다.\n   * `@ControllerAdvice내의 @ExceptionHandler`는 실행 되지 않았다.\n\n   **=> **@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.**\n        더 상위로 Exception을 throw하더라도 `@ControllerAdvice의 @ExceptionHandler`에서 예외처리를 하지 않는다.**\n\n\n\n2. DemoController2 -> throw DemoException\n\n   * 예상대로 DemoControllerAdvice 내의 `@ExceptionHandler` 메소드에서 예외처리가 되었다.\n   * DemoController2에는 `@ExceptionHandler`가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.\n\n\n\n# HandlerExceptionResolver를 이용한 처리\n\nHandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.\n`DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것`이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.\n(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)\n\nHandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.\n\n~~~java\npackage org.springframework.web.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.lang.Nullable;\n\npublic interface HandlerExceptionResolver {\n    @Nullable\n    ModelAndView resolveException(HttpServletRequest var1, HttpServletResponse var2, @Nullable Object var3, Exception var4);\n}\n~~~\n\nDispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.\n사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.\nSpring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.\n\n\n\nDispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.\n\n1. ExceptionHandlerExceptionResolver\n2. ResponseStatusExceptionResolver\n3. DefaultHandlerExceptionResolver\n\n순으로 Resolver가 실행된다.\n\n![image-20180831234615081](./image-20180831234615081.png)\n\n\n\n## ExceptionHandlerExceptionResolver\n\nSpring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.\n위에서 사용한 `@ExceptionHandler` 어노테이션에 대한 Resolver 클래스이다.\n\n\n\n## ResponseStatusExceptionResolver\n\nResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다. \n특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.\n\n사용 예제 (@ExceptionHandler와 함께 사용)\n\n~~~java\n//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.\n//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.\n@ResponseStatus(value = HttpStatus.FORBIDDEN, reason = \"Permission Denied\")\n@ExceptionHandler(value=DemoException.class)\npublic String handleDemoException(DemoException e) {\n    log.error(e.getMessage());\n    return \"/error/403\";\n}\n~~~\n\n![image-20180831235454808](./image-20180831235454808.png)\n\n위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.\n(403에 대한 페이지는 못만들었다 ^^;)\n\n\n\n## DefaultHandlerExceptionResolver\n\nDispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 `DefaultHandlerExceptionResolver`에서 예외처리를 해준다.\n\nDefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.\n각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다. \n\n* Request URL에 맞는 Controller를 못찾는 경우 ==> 404 Not Found\n* Controller 메소드 실행 중 예외가 발생하는 경우 ==> 500 Internal Server error\n* Controller의 파라미터 형식이 잘못된 경우 ==> 400 Bad Request\n\n\n\n## SimpleMappingExceptionResolver\n\nSimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.\nException별로 error-page를 매핑할 수 있는 기능을 제공한다.\n\n설정방법은 2가지로 설명하도록 하겠다.\n\n1. Java config 방식\n\n~~~java\n@Configuration\n@EnableWebMvc\npublic WebMvcConfig extends WebMvcConfigurerAdapter {\n    @Bean(name=“customMappingExceptionResolver”)\n    public SimpleMappingExceptionResolver customMappingExceptionResolver() {\n    \tSimpleMappingExceptionResolver r = new SimpleMappingExceptionResolver();\n\n        Properties mappings = new Properties();\n        mappings.setProperty(\"DatabaseException\", \"databaseError\");\n        mappings.setProperty(\"DemoException\", \"demoError\");\n\n        r.setExceptionMappings(mappings);  \n        r.setDefaultErrorView(\"default-error-page\");    \n        r.setExceptionAttribute(\"ex\");     \n        return r;\n    }\n}\n~~~\n\n2. xml 방식\n\n~~~xml\n<bean id=\"simpleMappingExceptionResolver\" class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\n    <property name=\"exceptionMappings\"> \n        <map> \n            <entry key=\"DatabaseException\" value=\"databaseError\"/> \n            <entry key=\"DemoException\" value=\"demoError\"/> \n        </map> \n    </property> \n    <property name=\"defaultErrorView\" value=\"error\"/> \n    <property name=\"exceptionAttribute\" value=\"ex\"/>\n</bean>\n~~~\n\n\n\n자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.\n근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?\n\n# 다시 한번 Spring MVC를 보자 (자꾸 보게되네?)\n\n![spring-mvc-request](./spring-mvc-request.jpg)\n\n\n\nSpring MVC의 대한 처리는 99프로가 `Dispatcher Servlet`에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.\n하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 `HandlerExceptionResolver`의 처리를 받을 수 없다. 이럴때는 어떡할건가?\n지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.\n\n\n\n# Filter에서 예외가 발생하면?\n\nfilter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.\n\nFilter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.\n\n* web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현\n* Filter 내부에서 try-catch 구문을 통해 예외 발생 시, `request.getRequestDispatcher(String)`를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.\n  (웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.\n   Interceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)\n\n\n\n# 참조\n\nhttps://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc\nhttps://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver\nhttp://www.nextree.co.kr/p3239/\nhttp://springsource.tistory.com/7\nhttp://stewie38.tistory.com/59\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/","source":"_posts/2018-08-25-spring-mvc-handle-exception.md","raw":"---\ntitle: Spring Handle Exception\ncatalog: true\ndate: 2018-08-30 23:30:26\nsubtitle: Spring에서 지원하는 다양한 예외처리 방법\nheader-img:\nCategories:\n - Spring\ntags: \n - Spring\n - Spring Core\ntypora-root-url: ./2018-08-25-spring-mvc-handle-exception\ntypora-copy-images-to: ./2018-08-25-spring-mvc-handle-exception\n---\n\n# 들어가며\n\nSpring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.\nDispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.\nSpring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.\n\n\n\n# 예외(Exception) 처리는 어떻게?\n\nSpring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.\n\n1. Controller 레벨에서 처리\n2. Global 레벨에서 처리\n3. HandlerExceptionResolver를 이용한 처리\n\n\n\n# Controller 레벨에서의 처리\n\nSpring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.\n`@ExceptionHandler` 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.\n\n예제 코드\n\n~~~java\npackage com.example.springstudy.demo2.controller;\n\nimport com.example.springstudy.demo2.exception.DemoException;\nimport com.example.springstudy.demo2.exception.FilterException;\nimport com.example.springstudy.demo2.exception.InterceptorException;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@Slf4j\n@Controller\npublic class DemoController {\n\n    @GetMapping(path=\"/exception/demo\")\n    public String occurDemoException() {\n        //강제로 DemoException을 발생 시켜 보았다.\n        throw new DemoException(); //occur DemoException (RuntimeException)\n    }\n    \n    @GetMapping(path=\"/exception/demo2\")\n    public String occurDemoException2() {\n        //강제로 DemoException을 발생 시켜 보았다.\n        throw new DemoException(); //occur DemoException (RuntimeException)\n    }\n\n    @ExceptionHandler(value=DemoException.class)\n    public String handleDemoException(DemoException e) {\n        log.error(e.getMessage());\n        return \"/error/404\";\n    }\n}\n~~~\n\nDemoController내에서 발생한 DemoException에 대해서는 `handleDemoException` 메소드에서 모두 처리를 해준다.\n\n* Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면` @ExceptionHandler` 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.\n* Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.\n\nSpring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.\n\n\n\n# Global 레벨에서의 처리\n\n만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?\n위의 방식 처럼 Controller 별로 `@ExceptionHandler` 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.\nSpring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.\n\n* `@ControllerAdvice` - Exception 처리 후 Error Page등을 통해 처리가 가능하다.\n* `@RestControllerAdvice`\n  * REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)\n  * @RestControllerAdvice = @ControllerAdvice + @ResponseBody\n\n위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.\n\n**주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!**\n\n\n\n예제 코드\n\n~~~java\nimport com.example.springstudy.demo2.exception.DemoException;\nimport com.example.springstudy.demo2.exception.FilterException;\nimport com.example.springstudy.demo2.exception.InterceptorException;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\n\n@Slf4j\n@ControllerAdvice\npublic class DemoControllerAdvisor {\n\n    //모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리\n    @ExceptionHandler(value = DemoException.class)\n    public String handleDemoExceptionForGlobal(DemoException e) {\n        log.error(e.getMessage());\n        return \"/error/404\";\n    }\n}\n~~~\n\n\n\n## 여기서 궁금한 점...\n\nController 클래스 내에 `@ExceptionHandler`, `@ControllerAdvice` 클래스 내의 `@ExceptionHandler` 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?\n\n\n\n실험을 해보았다.\n준비물은 아래와 같다.\n\n1. DemoException을 throw하는 DemoController1, DemoController2\n2. DemoController1에서는 DemoException에 대해 `@ExceptionHandler`를 구현하였다.\n3. DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.\n4. 전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고\n   `@ExceptionHandler`를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.\n\n\n\n### Test-Case\n\n1. DemoController1 -> throw DemoException\n2. DemoController2 -> throw DemoException\n\n\n\n### 어떤 결과가 나왔을까?\n\n1. DemoController1 -> throw DemoException\n   * 예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.\n   * 예외처리가 끝난 후 404페이지가 리턴 되었다.\n   * `@ControllerAdvice내의 @ExceptionHandler`는 실행 되지 않았다.\n\n   **=> **@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.**\n        더 상위로 Exception을 throw하더라도 `@ControllerAdvice의 @ExceptionHandler`에서 예외처리를 하지 않는다.**\n\n\n\n2. DemoController2 -> throw DemoException\n\n   * 예상대로 DemoControllerAdvice 내의 `@ExceptionHandler` 메소드에서 예외처리가 되었다.\n   * DemoController2에는 `@ExceptionHandler`가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.\n\n\n\n# HandlerExceptionResolver를 이용한 처리\n\nHandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.\n`DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것`이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.\n(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)\n\nHandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.\n\n~~~java\npackage org.springframework.web.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.lang.Nullable;\n\npublic interface HandlerExceptionResolver {\n    @Nullable\n    ModelAndView resolveException(HttpServletRequest var1, HttpServletResponse var2, @Nullable Object var3, Exception var4);\n}\n~~~\n\nDispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.\n사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.\nSpring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.\n\n\n\nDispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.\n\n1. ExceptionHandlerExceptionResolver\n2. ResponseStatusExceptionResolver\n3. DefaultHandlerExceptionResolver\n\n순으로 Resolver가 실행된다.\n\n![image-20180831234615081](./image-20180831234615081.png)\n\n\n\n## ExceptionHandlerExceptionResolver\n\nSpring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.\n위에서 사용한 `@ExceptionHandler` 어노테이션에 대한 Resolver 클래스이다.\n\n\n\n## ResponseStatusExceptionResolver\n\nResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다. \n특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.\n\n사용 예제 (@ExceptionHandler와 함께 사용)\n\n~~~java\n//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.\n//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.\n@ResponseStatus(value = HttpStatus.FORBIDDEN, reason = \"Permission Denied\")\n@ExceptionHandler(value=DemoException.class)\npublic String handleDemoException(DemoException e) {\n    log.error(e.getMessage());\n    return \"/error/403\";\n}\n~~~\n\n![image-20180831235454808](./image-20180831235454808.png)\n\n위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.\n(403에 대한 페이지는 못만들었다 ^^;)\n\n\n\n## DefaultHandlerExceptionResolver\n\nDispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 `DefaultHandlerExceptionResolver`에서 예외처리를 해준다.\n\nDefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.\n각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다. \n\n* Request URL에 맞는 Controller를 못찾는 경우 ==> 404 Not Found\n* Controller 메소드 실행 중 예외가 발생하는 경우 ==> 500 Internal Server error\n* Controller의 파라미터 형식이 잘못된 경우 ==> 400 Bad Request\n\n\n\n## SimpleMappingExceptionResolver\n\nSimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.\nException별로 error-page를 매핑할 수 있는 기능을 제공한다.\n\n설정방법은 2가지로 설명하도록 하겠다.\n\n1. Java config 방식\n\n~~~java\n@Configuration\n@EnableWebMvc\npublic WebMvcConfig extends WebMvcConfigurerAdapter {\n    @Bean(name=“customMappingExceptionResolver”)\n    public SimpleMappingExceptionResolver customMappingExceptionResolver() {\n    \tSimpleMappingExceptionResolver r = new SimpleMappingExceptionResolver();\n\n        Properties mappings = new Properties();\n        mappings.setProperty(\"DatabaseException\", \"databaseError\");\n        mappings.setProperty(\"DemoException\", \"demoError\");\n\n        r.setExceptionMappings(mappings);  \n        r.setDefaultErrorView(\"default-error-page\");    \n        r.setExceptionAttribute(\"ex\");     \n        return r;\n    }\n}\n~~~\n\n2. xml 방식\n\n~~~xml\n<bean id=\"simpleMappingExceptionResolver\" class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\n    <property name=\"exceptionMappings\"> \n        <map> \n            <entry key=\"DatabaseException\" value=\"databaseError\"/> \n            <entry key=\"DemoException\" value=\"demoError\"/> \n        </map> \n    </property> \n    <property name=\"defaultErrorView\" value=\"error\"/> \n    <property name=\"exceptionAttribute\" value=\"ex\"/>\n</bean>\n~~~\n\n\n\n자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.\n근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?\n\n# 다시 한번 Spring MVC를 보자 (자꾸 보게되네?)\n\n![spring-mvc-request](./spring-mvc-request.jpg)\n\n\n\nSpring MVC의 대한 처리는 99프로가 `Dispatcher Servlet`에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.\n하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 `HandlerExceptionResolver`의 처리를 받을 수 없다. 이럴때는 어떡할건가?\n지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.\n\n\n\n# Filter에서 예외가 발생하면?\n\nfilter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.\n\nFilter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.\n\n* web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현\n* Filter 내부에서 try-catch 구문을 통해 예외 발생 시, `request.getRequestDispatcher(String)`를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.\n  (웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.\n   Interceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)\n\n\n\n# 참조\n\nhttps://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc\nhttps://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver\nhttp://www.nextree.co.kr/p3239/\nhttp://springsource.tistory.com/7\nhttp://stewie38.tistory.com/59\nhttps://supawer0728.github.io/2018/04/04/spring-filter-interceptor/","slug":"2018-08-25-spring-mvc-handle-exception","published":1,"updated":"2018-11-27T07:23:32.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp55h5i300114f1t7vavujt0","content":"<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>Spring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.<br>\nDispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.<br>\nSpring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.</p>\n<h1><span id=\"예외exception-처리는-어떻게\">예외(Exception) 처리는 어떻게?</span></h1>\n<p>Spring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.</p>\n<ol>\n<li>Controller 레벨에서 처리</li>\n<li>Global 레벨에서 처리</li>\n<li>HandlerExceptionResolver를 이용한 처리</li>\n</ol>\n<h1><span id=\"controller-레벨에서의-처리\">Controller 레벨에서의 처리</span></h1>\n<p>Spring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.<br>\n<code>@ExceptionHandler</code> 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.</p>\n<p>예제 코드</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo2.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(path=<span class=\"string\">\"/exception/demo\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">occurDemoException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DemoException(); <span class=\"comment\">//occur DemoException (RuntimeException)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(path=<span class=\"string\">\"/exception/demo2\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">occurDemoException2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DemoException(); <span class=\"comment\">//occur DemoException (RuntimeException)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value=DemoException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoException</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">        log.error(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"/error/404\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DemoController내에서 발생한 DemoException에 대해서는 <code>handleDemoException</code> 메소드에서 모두 처리를 해준다.</p>\n<ul>\n<li>Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면<code>@ExceptionHandler</code> 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.</li>\n<li>Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.</li>\n</ul>\n<p>Spring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.</p>\n<h1><span id=\"global-레벨에서의-처리\">Global 레벨에서의 처리</span></h1>\n<p>만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?<br>\n위의 방식 처럼 Controller 별로 <code>@ExceptionHandler</code> 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.<br>\nSpring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.</p>\n<ul>\n<li><code>@ControllerAdvice</code> - Exception 처리 후 Error Page등을 통해 처리가 가능하다.</li>\n<li><code>@RestControllerAdvice</code>\n<ul>\n<li>REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)</li>\n<li>@RestControllerAdvice = @ControllerAdvice + @ResponseBody</li>\n</ul>\n</li>\n</ul>\n<p>위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.</p>\n<p><strong>주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!</strong></p>\n<p>예제 코드</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@ControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoControllerAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리</span></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value = DemoException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoExceptionForGlobal</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">        log.error(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"/error/404\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"여기서-궁금한-점\">여기서 궁금한 점…</span></h2>\n<p>Controller 클래스 내에 <code>@ExceptionHandler</code>, <code>@ControllerAdvice</code> 클래스 내의 <code>@ExceptionHandler</code> 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?</p>\n<p>실험을 해보았다.<br>\n준비물은 아래와 같다.</p>\n<ol>\n<li>DemoException을 throw하는 DemoController1, DemoController2</li>\n<li>DemoController1에서는 DemoException에 대해 <code>@ExceptionHandler</code>를 구현하였다.</li>\n<li>DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.</li>\n<li>전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고<br>\n<code>@ExceptionHandler</code>를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.</li>\n</ol>\n<h3><span id=\"test-case\">Test-Case</span></h3>\n<ol>\n<li>DemoController1 -&gt; throw DemoException</li>\n<li>DemoController2 -&gt; throw DemoException</li>\n</ol>\n<h3><span id=\"어떤-결과가-나왔을까\">어떤 결과가 나왔을까?</span></h3>\n<ol>\n<li>\n<p>DemoController1 -&gt; throw DemoException</p>\n<ul>\n<li>예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.</li>\n<li>예외처리가 끝난 후 404페이지가 리턴 되었다.</li>\n<li><code>@ControllerAdvice내의 @ExceptionHandler</code>는 실행 되지 않았다.</li>\n</ul>\n<p><strong>=&gt; <strong>@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.</strong><br>\n더 상위로 Exception을 throw하더라도 <code>@ControllerAdvice의 @ExceptionHandler</code>에서 예외처리를 하지 않는다.</strong></p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>DemoController2 -&gt; throw DemoException</p>\n<ul>\n<li>예상대로 DemoControllerAdvice 내의 <code>@ExceptionHandler</code> 메소드에서 예외처리가 되었다.</li>\n<li>DemoController2에는 <code>@ExceptionHandler</code>가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.</li>\n</ul>\n</li>\n</ol>\n<h1><span id=\"handlerexceptionresolver를-이용한-처리\">HandlerExceptionResolver를 이용한 처리</span></h1>\n<p>HandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.<br>\n<code>DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것</code>이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.<br>\n(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)</p>\n<p>HandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.web.servlet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.lang.Nullable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandlerExceptionResolver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"function\">ModelAndView <span class=\"title\">resolveException</span><span class=\"params\">(HttpServletRequest var1, HttpServletResponse var2, @Nullable Object var3, Exception var4)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.<br>\n사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.<br>\nSpring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.</p>\n<p>Dispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.</p>\n<ol>\n<li>ExceptionHandlerExceptionResolver</li>\n<li>ResponseStatusExceptionResolver</li>\n<li>DefaultHandlerExceptionResolver</li>\n</ol>\n<p>순으로 Resolver가 실행된다.</p>\n<p><img src=\"./image-20180831234615081.png\" alt=\"image-20180831234615081\"></p>\n<h2><span id=\"exceptionhandlerexceptionresolver\">ExceptionHandlerExceptionResolver</span></h2>\n<p>Spring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.<br>\n위에서 사용한 <code>@ExceptionHandler</code> 어노테이션에 대한 Resolver 클래스이다.</p>\n<h2><span id=\"responsestatusexceptionresolver\">ResponseStatusExceptionResolver</span></h2>\n<p>ResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다.<br>\n특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.</p>\n<p>사용 예제 (@ExceptionHandler와 함께 사용)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseStatus</span>(value = HttpStatus.FORBIDDEN, reason = <span class=\"string\">\"Permission Denied\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ExceptionHandler</span>(value=DemoException.class)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoException</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">    log.error(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"/error/403\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"./image-20180831235454808.png\" alt=\"image-20180831235454808\"></p>\n<p>위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.<br>\n(403에 대한 페이지는 못만들었다 ^^;)</p>\n<h2><span id=\"defaulthandlerexceptionresolver\">DefaultHandlerExceptionResolver</span></h2>\n<p>DispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 <code>DefaultHandlerExceptionResolver</code>에서 예외처리를 해준다.</p>\n<p>DefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.<br>\n각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다.</p>\n<ul>\n<li>Request URL에 맞는 Controller를 못찾는 경우 ==&gt; 404 Not Found</li>\n<li>Controller 메소드 실행 중 예외가 발생하는 경우 ==&gt; 500 Internal Server error</li>\n<li>Controller의 파라미터 형식이 잘못된 경우 ==&gt; 400 Bad Request</li>\n</ul>\n<h2><span id=\"simplemappingexceptionresolver\">SimpleMappingExceptionResolver</span></h2>\n<p>SimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.<br>\nException별로 error-page를 매핑할 수 있는 기능을 제공한다.</p>\n<p>설정방법은 2가지로 설명하도록 하겠다.</p>\n<ol>\n<li>Java config 방식</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> WebMvcConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=“customMappingExceptionResolver”)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SimpleMappingExceptionResolver <span class=\"title\">customMappingExceptionResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \tSimpleMappingExceptionResolver r = <span class=\"keyword\">new</span> SimpleMappingExceptionResolver();</span><br><span class=\"line\"></span><br><span class=\"line\">        Properties mappings = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        mappings.setProperty(<span class=\"string\">\"DatabaseException\"</span>, <span class=\"string\">\"databaseError\"</span>);</span><br><span class=\"line\">        mappings.setProperty(<span class=\"string\">\"DemoException\"</span>, <span class=\"string\">\"demoError\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        r.setExceptionMappings(mappings);  </span><br><span class=\"line\">        r.setDefaultErrorView(<span class=\"string\">\"default-error-page\"</span>);    </span><br><span class=\"line\">        r.setExceptionAttribute(<span class=\"string\">\"ex\"</span>);     </span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>xml 방식</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"simpleMappingExceptionResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionMappings\"</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span> </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"DatabaseException\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"databaseError\"</span>/&gt;</span> </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"DemoException\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"demoError\"</span>/&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"defaultErrorView\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"error\"</span>/&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionAttribute\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"ex\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.<br>\n근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?</p>\n<h1><span id=\"다시-한번-spring-mvc를-보자-자꾸-보게되네\">다시 한번 Spring MVC를 보자 (자꾸 보게되네?)</span></h1>\n<p><img src=\"./spring-mvc-request.jpg\" alt=\"spring-mvc-request\"></p>\n<p>Spring MVC의 대한 처리는 99프로가 <code>Dispatcher Servlet</code>에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.<br>\n하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 <code>HandlerExceptionResolver</code>의 처리를 받을 수 없다. 이럴때는 어떡할건가?<br>\n지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.</p>\n<h1><span id=\"filter에서-예외가-발생하면\">Filter에서 예외가 발생하면?</span></h1>\n<p>filter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.</p>\n<p>Filter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.</p>\n<ul>\n<li>web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현</li>\n<li>Filter 내부에서 try-catch 구문을 통해 예외 발생 시, <code>request.getRequestDispatcher(String)</code>를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.<br>\n(웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.<br>\nInterceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)</li>\n</ul>\n<h1><span id=\"참조\">참조</span></h1>\n<p><a href=\"https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc\" target=\"_blank\" rel=\"noopener\">https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc</a><br>\n<a href=\"https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver\" target=\"_blank\" rel=\"noopener\">https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver</a><br>\n<a href=\"http://www.nextree.co.kr/p3239/\" target=\"_blank\" rel=\"noopener\">http://www.nextree.co.kr/p3239/</a><br>\n<a href=\"http://springsource.tistory.com/7\" target=\"_blank\" rel=\"noopener\">http://springsource.tistory.com/7</a><br>\n<a href=\"http://stewie38.tistory.com/59\" target=\"_blank\" rel=\"noopener\">http://stewie38.tistory.com/59</a><br>\n<a href=\"https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/\" target=\"_blank\" rel=\"noopener\">https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>Spring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.<br>\nDispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.<br>\nSpring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.</p>\n<h1>예외(Exception) 처리는 어떻게?</h1>\n<p>Spring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.</p>\n<ol>\n<li>Controller 레벨에서 처리</li>\n<li>Global 레벨에서 처리</li>\n<li>HandlerExceptionResolver를 이용한 처리</li>\n</ol>\n<h1>Controller 레벨에서의 처리</h1>\n<p>Spring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.<br>\n<code>@ExceptionHandler</code> 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.</p>\n<p>예제 코드</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo2.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(path=<span class=\"string\">\"/exception/demo\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">occurDemoException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DemoException(); <span class=\"comment\">//occur DemoException (RuntimeException)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(path=<span class=\"string\">\"/exception/demo2\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">occurDemoException2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DemoException(); <span class=\"comment\">//occur DemoException (RuntimeException)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value=DemoException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoException</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">        log.error(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"/error/404\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DemoController내에서 발생한 DemoException에 대해서는 <code>handleDemoException</code> 메소드에서 모두 처리를 해준다.</p>\n<ul>\n<li>Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면<code>@ExceptionHandler</code> 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.</li>\n<li>Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.</li>\n</ul>\n<p>Spring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.</p>\n<h1>Global 레벨에서의 처리</h1>\n<p>만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?<br>\n위의 방식 처럼 Controller 별로 <code>@ExceptionHandler</code> 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.<br>\nSpring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.</p>\n<ul>\n<li><code>@ControllerAdvice</code> - Exception 처리 후 Error Page등을 통해 처리가 가능하다.</li>\n<li><code>@RestControllerAdvice</code>\n<ul>\n<li>REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)</li>\n<li>@RestControllerAdvice = @ControllerAdvice + @ResponseBody</li>\n</ul>\n</li>\n</ul>\n<p>위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.</p>\n<p><strong>주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!</strong></p>\n<p>예제 코드</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@ControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoControllerAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리</span></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value = DemoException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoExceptionForGlobal</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">        log.error(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"/error/404\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>여기서 궁금한 점…</h2>\n<p>Controller 클래스 내에 <code>@ExceptionHandler</code>, <code>@ControllerAdvice</code> 클래스 내의 <code>@ExceptionHandler</code> 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?</p>\n<p>실험을 해보았다.<br>\n준비물은 아래와 같다.</p>\n<ol>\n<li>DemoException을 throw하는 DemoController1, DemoController2</li>\n<li>DemoController1에서는 DemoException에 대해 <code>@ExceptionHandler</code>를 구현하였다.</li>\n<li>DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.</li>\n<li>전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고<br>\n<code>@ExceptionHandler</code>를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.</li>\n</ol>\n<h3>Test-Case</h3>\n<ol>\n<li>DemoController1 -&gt; throw DemoException</li>\n<li>DemoController2 -&gt; throw DemoException</li>\n</ol>\n<h3>어떤 결과가 나왔을까?</h3>\n<ol>\n<li>\n<p>DemoController1 -&gt; throw DemoException</p>\n<ul>\n<li>예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.</li>\n<li>예외처리가 끝난 후 404페이지가 리턴 되었다.</li>\n<li><code>@ControllerAdvice내의 @ExceptionHandler</code>는 실행 되지 않았다.</li>\n</ul>\n<p><strong>=&gt; <strong>@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.</strong><br>\n더 상위로 Exception을 throw하더라도 <code>@ControllerAdvice의 @ExceptionHandler</code>에서 예외처리를 하지 않는다.</strong></p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>DemoController2 -&gt; throw DemoException</p>\n<ul>\n<li>예상대로 DemoControllerAdvice 내의 <code>@ExceptionHandler</code> 메소드에서 예외처리가 되었다.</li>\n<li>DemoController2에는 <code>@ExceptionHandler</code>가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.</li>\n</ul>\n</li>\n</ol>\n<h1>HandlerExceptionResolver를 이용한 처리</h1>\n<p>HandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.<br>\n<code>DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것</code>이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.<br>\n(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)</p>\n<p>HandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.web.servlet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.lang.Nullable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandlerExceptionResolver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"function\">ModelAndView <span class=\"title\">resolveException</span><span class=\"params\">(HttpServletRequest var1, HttpServletResponse var2, @Nullable Object var3, Exception var4)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.<br>\n사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.<br>\nSpring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.</p>\n<p>Dispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.</p>\n<ol>\n<li>ExceptionHandlerExceptionResolver</li>\n<li>ResponseStatusExceptionResolver</li>\n<li>DefaultHandlerExceptionResolver</li>\n</ol>\n<p>순으로 Resolver가 실행된다.</p>\n<p><img src=\"./image-20180831234615081.png\" alt=\"image-20180831234615081\"></p>\n<h2>ExceptionHandlerExceptionResolver</h2>\n<p>Spring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.<br>\n위에서 사용한 <code>@ExceptionHandler</code> 어노테이션에 대한 Resolver 클래스이다.</p>\n<h2>ResponseStatusExceptionResolver</h2>\n<p>ResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다.<br>\n특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.</p>\n<p>사용 예제 (@ExceptionHandler와 함께 사용)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseStatus</span>(value = HttpStatus.FORBIDDEN, reason = <span class=\"string\">\"Permission Denied\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ExceptionHandler</span>(value=DemoException.class)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleDemoException</span><span class=\"params\">(DemoException e)</span> </span>&#123;</span><br><span class=\"line\">    log.error(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"/error/403\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"./image-20180831235454808.png\" alt=\"image-20180831235454808\"></p>\n<p>위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.<br>\n(403에 대한 페이지는 못만들었다 ^^;)</p>\n<h2>DefaultHandlerExceptionResolver</h2>\n<p>DispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 <code>DefaultHandlerExceptionResolver</code>에서 예외처리를 해준다.</p>\n<p>DefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.<br>\n각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다.</p>\n<ul>\n<li>Request URL에 맞는 Controller를 못찾는 경우 ==&gt; 404 Not Found</li>\n<li>Controller 메소드 실행 중 예외가 발생하는 경우 ==&gt; 500 Internal Server error</li>\n<li>Controller의 파라미터 형식이 잘못된 경우 ==&gt; 400 Bad Request</li>\n</ul>\n<h2>SimpleMappingExceptionResolver</h2>\n<p>SimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.<br>\nException별로 error-page를 매핑할 수 있는 기능을 제공한다.</p>\n<p>설정방법은 2가지로 설명하도록 하겠다.</p>\n<ol>\n<li>Java config 방식</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> WebMvcConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=“customMappingExceptionResolver”)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SimpleMappingExceptionResolver <span class=\"title\">customMappingExceptionResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \tSimpleMappingExceptionResolver r = <span class=\"keyword\">new</span> SimpleMappingExceptionResolver();</span><br><span class=\"line\"></span><br><span class=\"line\">        Properties mappings = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        mappings.setProperty(<span class=\"string\">\"DatabaseException\"</span>, <span class=\"string\">\"databaseError\"</span>);</span><br><span class=\"line\">        mappings.setProperty(<span class=\"string\">\"DemoException\"</span>, <span class=\"string\">\"demoError\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        r.setExceptionMappings(mappings);  </span><br><span class=\"line\">        r.setDefaultErrorView(<span class=\"string\">\"default-error-page\"</span>);    </span><br><span class=\"line\">        r.setExceptionAttribute(<span class=\"string\">\"ex\"</span>);     </span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>xml 방식</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"simpleMappingExceptionResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionMappings\"</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span> </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"DatabaseException\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"databaseError\"</span>/&gt;</span> </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"DemoException\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"demoError\"</span>/&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"defaultErrorView\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"error\"</span>/&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionAttribute\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"ex\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.<br>\n근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?</p>\n<h1>다시 한번 Spring MVC를 보자 (자꾸 보게되네?)</h1>\n<p><img src=\"./spring-mvc-request.jpg\" alt=\"spring-mvc-request\"></p>\n<p>Spring MVC의 대한 처리는 99프로가 <code>Dispatcher Servlet</code>에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.<br>\n하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 <code>HandlerExceptionResolver</code>의 처리를 받을 수 없다. 이럴때는 어떡할건가?<br>\n지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.</p>\n<h1>Filter에서 예외가 발생하면?</h1>\n<p>filter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.</p>\n<p>Filter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.</p>\n<ul>\n<li>web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현</li>\n<li>Filter 내부에서 try-catch 구문을 통해 예외 발생 시, <code>request.getRequestDispatcher(String)</code>를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.<br>\n(웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.<br>\nInterceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)</li>\n</ul>\n<h1>참조</h1>\n<p><a href=\"https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc\" target=\"_blank\" rel=\"noopener\">https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc</a><br>\n<a href=\"https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver\" target=\"_blank\" rel=\"noopener\">https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver</a><br>\n<a href=\"http://www.nextree.co.kr/p3239/\" target=\"_blank\" rel=\"noopener\">http://www.nextree.co.kr/p3239/</a><br>\n<a href=\"http://springsource.tistory.com/7\" target=\"_blank\" rel=\"noopener\">http://springsource.tistory.com/7</a><br>\n<a href=\"http://stewie38.tistory.com/59\" target=\"_blank\" rel=\"noopener\">http://stewie38.tistory.com/59</a><br>\n<a href=\"https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/\" target=\"_blank\" rel=\"noopener\">https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</a></p>\n"},{"title":"Spring Dispatcher Servlet","catalog":true,"date":"2018-08-11T08:17:36.000Z","subtitle":null,"header-img":null,"Categories":["Spring"],"typora-root-url":"./2018-08-11-spring-dispatcher-servlet","typora-copy-images-to":"./2018-08-11-spring-dispatcher-servlet","_content":"\n# Spring Dispatcher Servlet\n\nSpring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다. \n\n\n\n# Front Controller Pattern\n\nDispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.\n\n\n\n![Front-controller-pattern](./Front-controller-pattern.png)\n\n\n\nSpring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.\n모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다. \n자세한 Cycle은 아래 그림과 같다.\n\n\n\n# Dispatcher Servlet Cycle\n\n![dispatcher-servlet-lifecycle](./dispatcher-servlet-lifecycle.jpg)\n\n\n\n1. doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 [doDispatch()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942) 메소드를 호출한다. \n2. 아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.\n3. [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017)  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.\n4. 요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.\n5. 실행될 interceptor들이 있다면 interceptor의 [preHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036) 메소드를 차례로 실행한다.\n6. Controller의 인스턴스는 HandlerExecutionChain의 [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017) 메소드를 이용해서 얻는다.\n7. HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, [getHandlerAdaptor()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024) 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.\n8. 선택된 HanlderAdaptor의 [handle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041) 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.\n9. 계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 [invoke()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894)한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)\n10. interceptor의 [postHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048) 메소드가 실행된다.\n11. [resolveViewName()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409) 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.\n12. Model 객체의 데이터를 보여주기 위해 해당 View 객체의 [render()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119) 메소드가 수행된다.\n\n\n\n# web.xml 설정하기\n\n### 기본 설정\n\n~~~xml\n<web-app> <!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--> \n    <servlet> \n        <servlet-name>appServlet</servlet-name> \n    \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    </servlet> \n\n    <servlet-mapping>\n        <servlet-name>appServlet</servlet-name>\n        <url-pattern>/</url-pattern> <!-- Default Servlet을 의미 --> \n    </servlet-mapping>\n</web-app>\n~~~\n\nappServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.\nDispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, `/` prefix로 들어오는 모든 요청을 처리한다.\n\nservlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 `/WEB-INF/appServlet-servlet.xml`을 찾게 된다. \n\n\n\n### contextConfigLocation을 이용한 설정\n\n빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다. \n\n```xml\n<servlet>\n    <servlet-name>appServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>\n        \t/WEB-INF/spring/appServlet/servlet-context.xml\n\t\t<!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --> \n        </param-value>\n    </init-param>\n</servlet>\n```\n\n\n\n### ContextLoaderListener를 이용한 설정\n\n일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.\n또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.\n이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.\n공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고, \nweb layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.\n\n~~~xml\n<!-- ApplicationContext 빈 설정 파일--> \n<context-param> \n    <param-name>contextConfigLocation</param-name> \n    <param-value> \n        <!--빈 설정 파일들간에 구분은 줄바꿈(\\n),컴마(,),세미콜론(;)등으로 한다.--> \n        /WEB-INF/config/myapp-service.xml,\n        /WEB-INF/config/myapp-dao.xml \t\t\n    </param-value> \n</context-param> \n\n<!-- \n웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, \n로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.\n--> \n<listener> \n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> </listener> \n\n<servlet> \n    <servlet-name>employee</servlet-name> \n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \t\t<init-param> \n    \t<param-name>contextConfigLocation</param-name> \t\n    \t<param-value> /WEB-INF/config/myapp-servlet.xml </param-value> \n    </init-param> \n</servlet> \n\n<servlet> \n    <servlet-name>webservice</servlet-name> \n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \t\t<init-param> \n    \t<param-name>contextConfigLocation</param-name> \n    \t<param-value> /WEB-INF/config/myapp-webservice.xml </param-value> \n    </init-param> \n</servlet>\n~~~\n\n맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.\n(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)\n\n따라서\nemployee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,\nwebServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.\n\n\n\n\n\n\n\n# 참고\n\nhttp://mangkyu.tistory.com/18\nhttp://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet\nhttp://hermeslog.tistory.com/156\nhttps://github.com/dongmyo/dispatcher2\nhttps://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/\nhttps://nesoy.github.io/articles/2017-02/Front-Controller\nhttp://wonwoo.ml/index.php/post/1590","source":"_posts/2018-08-11-spring-dispatcher-servlet.md","raw":"---\ntitle: Spring Dispatcher Servlet\ncatalog: true\ndate: 2018-08-11 17:17:36\nsubtitle:\nheader-img:\nCategories:\n - Spring\ntags: \n - Spring\n - core\ntypora-root-url: ./2018-08-11-spring-dispatcher-servlet\ntypora-copy-images-to: ./2018-08-11-spring-dispatcher-servlet\n---\n\n# Spring Dispatcher Servlet\n\nSpring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다. \n\n\n\n# Front Controller Pattern\n\nDispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.\n\n\n\n![Front-controller-pattern](./Front-controller-pattern.png)\n\n\n\nSpring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.\n모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다. \n자세한 Cycle은 아래 그림과 같다.\n\n\n\n# Dispatcher Servlet Cycle\n\n![dispatcher-servlet-lifecycle](./dispatcher-servlet-lifecycle.jpg)\n\n\n\n1. doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 [doDispatch()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942) 메소드를 호출한다. \n2. 아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.\n3. [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017)  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.\n4. 요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.\n5. 실행될 interceptor들이 있다면 interceptor의 [preHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036) 메소드를 차례로 실행한다.\n6. Controller의 인스턴스는 HandlerExecutionChain의 [getHandler()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017) 메소드를 이용해서 얻는다.\n7. HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, [getHandlerAdaptor()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024) 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.\n8. 선택된 HanlderAdaptor의 [handle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041) 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.\n9. 계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 [invoke()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894)한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)\n10. interceptor의 [postHandle()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048) 메소드가 실행된다.\n11. [resolveViewName()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409) 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.\n12. Model 객체의 데이터를 보여주기 위해 해당 View 객체의 [render()](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119) 메소드가 수행된다.\n\n\n\n# web.xml 설정하기\n\n### 기본 설정\n\n~~~xml\n<web-app> <!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--> \n    <servlet> \n        <servlet-name>appServlet</servlet-name> \n    \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    </servlet> \n\n    <servlet-mapping>\n        <servlet-name>appServlet</servlet-name>\n        <url-pattern>/</url-pattern> <!-- Default Servlet을 의미 --> \n    </servlet-mapping>\n</web-app>\n~~~\n\nappServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.\nDispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, `/` prefix로 들어오는 모든 요청을 처리한다.\n\nservlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 `/WEB-INF/appServlet-servlet.xml`을 찾게 된다. \n\n\n\n### contextConfigLocation을 이용한 설정\n\n빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다. \n\n```xml\n<servlet>\n    <servlet-name>appServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>\n        \t/WEB-INF/spring/appServlet/servlet-context.xml\n\t\t<!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --> \n        </param-value>\n    </init-param>\n</servlet>\n```\n\n\n\n### ContextLoaderListener를 이용한 설정\n\n일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.\n또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.\n이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.\n공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고, \nweb layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.\n\n~~~xml\n<!-- ApplicationContext 빈 설정 파일--> \n<context-param> \n    <param-name>contextConfigLocation</param-name> \n    <param-value> \n        <!--빈 설정 파일들간에 구분은 줄바꿈(\\n),컴마(,),세미콜론(;)등으로 한다.--> \n        /WEB-INF/config/myapp-service.xml,\n        /WEB-INF/config/myapp-dao.xml \t\t\n    </param-value> \n</context-param> \n\n<!-- \n웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, \n로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.\n--> \n<listener> \n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> </listener> \n\n<servlet> \n    <servlet-name>employee</servlet-name> \n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \t\t<init-param> \n    \t<param-name>contextConfigLocation</param-name> \t\n    \t<param-value> /WEB-INF/config/myapp-servlet.xml </param-value> \n    </init-param> \n</servlet> \n\n<servlet> \n    <servlet-name>webservice</servlet-name> \n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \t\t<init-param> \n    \t<param-name>contextConfigLocation</param-name> \n    \t<param-value> /WEB-INF/config/myapp-webservice.xml </param-value> \n    </init-param> \n</servlet>\n~~~\n\n맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.\n(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)\n\n따라서\nemployee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,\nwebServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.\n\n\n\n\n\n\n\n# 참고\n\nhttp://mangkyu.tistory.com/18\nhttp://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet\nhttp://hermeslog.tistory.com/156\nhttps://github.com/dongmyo/dispatcher2\nhttps://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/\nhttps://nesoy.github.io/articles/2017-02/Front-Controller\nhttp://wonwoo.ml/index.php/post/1590","slug":"2018-08-11-spring-dispatcher-servlet","published":1,"updated":"2018-11-27T07:23:32.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp55h5i400134f1tolzozlhw","content":"<h1><span id=\"spring-dispatcher-servlet\">Spring Dispatcher Servlet</span></h1>\n<p>Spring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다.</p>\n<h1><span id=\"front-controller-pattern\">Front Controller Pattern</span></h1>\n<p>Dispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.</p>\n<p><img src=\"./Front-controller-pattern.png\" alt=\"Front-controller-pattern\"></p>\n<p>Spring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.<br>\n모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다.<br>\n자세한 Cycle은 아래 그림과 같다.</p>\n<h1><span id=\"dispatcher-servlet-cycle\">Dispatcher Servlet Cycle</span></h1>\n<p><img src=\"./dispatcher-servlet-lifecycle.jpg\" alt=\"dispatcher-servlet-lifecycle\"></p>\n<ol>\n<li>doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942\" target=\"_blank\" rel=\"noopener\">doDispatch()</a> 메소드를 호출한다.</li>\n<li>아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017\" target=\"_blank\" rel=\"noopener\">getHandler()</a>  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.</li>\n<li>요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.</li>\n<li>실행될 interceptor들이 있다면 interceptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036\" target=\"_blank\" rel=\"noopener\">preHandle()</a> 메소드를 차례로 실행한다.</li>\n<li>Controller의 인스턴스는 HandlerExecutionChain의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드를 이용해서 얻는다.</li>\n<li>HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024\" target=\"_blank\" rel=\"noopener\">getHandlerAdaptor()</a> 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.</li>\n<li>선택된 HanlderAdaptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041\" target=\"_blank\" rel=\"noopener\">handle()</a> 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.</li>\n<li>계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894\" target=\"_blank\" rel=\"noopener\">invoke()</a>한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)</li>\n<li>interceptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048\" target=\"_blank\" rel=\"noopener\">postHandle()</a> 메소드가 실행된다.</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409\" target=\"_blank\" rel=\"noopener\">resolveViewName()</a> 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.</li>\n<li>Model 객체의 데이터를 보여주기 위해 해당 View 객체의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119\" target=\"_blank\" rel=\"noopener\">render()</a> 메소드가 수행된다.</li>\n</ol>\n<h1><span id=\"webxml-설정하기\">web.xml 설정하기</span></h1>\n<h3><span id=\"기본-설정\">기본 설정</span></h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span>&gt;</span> <span class=\"comment\">&lt;!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span> <span class=\"comment\">&lt;!-- Default Servlet을 의미 --&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>appServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.<br>\nDispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, <code>/</code> prefix로 들어오는 모든 요청을 처리한다.</p>\n<p>servlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 <code>/WEB-INF/appServlet-servlet.xml</code>을 찾게 된다.</p>\n<h3><span id=\"contextconfiglocation을-이용한-설정\">contextConfigLocation을 이용한 설정</span></h3>\n<p>빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        \t/WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"contextloaderlistener를-이용한-설정\">ContextLoaderListener를 이용한 설정</span></h3>\n<p>일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.<br>\n또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.<br>\n이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.<br>\n공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고,<br>\nweb layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- ApplicationContext 빈 설정 파일--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"comment\">&lt;!--빈 설정 파일들간에 구분은 줄바꿈(\\n),컴마(,),세미콜론(;)등으로 한다.--&gt;</span> </span><br><span class=\"line\">        /WEB-INF/config/myapp-service.xml,</span><br><span class=\"line\">        /WEB-INF/config/myapp-dao.xml \t\t</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, </span></span><br><span class=\"line\"><span class=\"comment\">로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>employee<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> \t\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> \t</span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> /WEB-INF/config/myapp-servlet.xml <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>webservice<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> \t\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> /WEB-INF/config/myapp-webservice.xml <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.<br>\n(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)</p>\n<p>따라서<br>\nemployee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,<br>\nwebServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.</p>\n<h1><span id=\"참고\">참고</span></h1>\n<p><a href=\"http://mangkyu.tistory.com/18\" target=\"_blank\" rel=\"noopener\">http://mangkyu.tistory.com/18</a><br>\n<a href=\"http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet\" target=\"_blank\" rel=\"noopener\">http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet</a><br>\n<a href=\"http://hermeslog.tistory.com/156\" target=\"_blank\" rel=\"noopener\">http://hermeslog.tistory.com/156</a><br>\n<a href=\"https://github.com/dongmyo/dispatcher2\" target=\"_blank\" rel=\"noopener\">https://github.com/dongmyo/dispatcher2</a><br>\n<a href=\"https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/\" target=\"_blank\" rel=\"noopener\">https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/</a><br>\n<a href=\"https://nesoy.github.io/articles/2017-02/Front-Controller\" target=\"_blank\" rel=\"noopener\">https://nesoy.github.io/articles/2017-02/Front-Controller</a><br>\n<a href=\"http://wonwoo.ml/index.php/post/1590\" target=\"_blank\" rel=\"noopener\">http://wonwoo.ml/index.php/post/1590</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>Spring Dispatcher Servlet</h1>\n<p>Spring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다.</p>\n<h1>Front Controller Pattern</h1>\n<p>Dispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.</p>\n<p><img src=\"./Front-controller-pattern.png\" alt=\"Front-controller-pattern\"></p>\n<p>Spring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.<br>\n모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다.<br>\n자세한 Cycle은 아래 그림과 같다.</p>\n<h1>Dispatcher Servlet Cycle</h1>\n<p><img src=\"./dispatcher-servlet-lifecycle.jpg\" alt=\"dispatcher-servlet-lifecycle\"></p>\n<ol>\n<li>doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942\" target=\"_blank\" rel=\"noopener\">doDispatch()</a> 메소드를 호출한다.</li>\n<li>아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017\" target=\"_blank\" rel=\"noopener\">getHandler()</a>  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.</li>\n<li>요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.</li>\n<li>실행될 interceptor들이 있다면 interceptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036\" target=\"_blank\" rel=\"noopener\">preHandle()</a> 메소드를 차례로 실행한다.</li>\n<li>Controller의 인스턴스는 HandlerExecutionChain의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017\" target=\"_blank\" rel=\"noopener\">getHandler()</a> 메소드를 이용해서 얻는다.</li>\n<li>HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024\" target=\"_blank\" rel=\"noopener\">getHandlerAdaptor()</a> 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.</li>\n<li>선택된 HanlderAdaptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041\" target=\"_blank\" rel=\"noopener\">handle()</a> 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.</li>\n<li>계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894\" target=\"_blank\" rel=\"noopener\">invoke()</a>한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)</li>\n<li>interceptor의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048\" target=\"_blank\" rel=\"noopener\">postHandle()</a> 메소드가 실행된다.</li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409\" target=\"_blank\" rel=\"noopener\">resolveViewName()</a> 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.</li>\n<li>Model 객체의 데이터를 보여주기 위해 해당 View 객체의 <a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119\" target=\"_blank\" rel=\"noopener\">render()</a> 메소드가 수행된다.</li>\n</ol>\n<h1>web.xml 설정하기</h1>\n<h3>기본 설정</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span>&gt;</span> <span class=\"comment\">&lt;!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span> <span class=\"comment\">&lt;!-- Default Servlet을 의미 --&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>appServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.<br>\nDispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, <code>/</code> prefix로 들어오는 모든 요청을 처리한다.</p>\n<p>servlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 <code>/WEB-INF/appServlet-servlet.xml</code>을 찾게 된다.</p>\n<h3>contextConfigLocation을 이용한 설정</h3>\n<p>빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        \t/WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>ContextLoaderListener를 이용한 설정</h3>\n<p>일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.<br>\n또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.<br>\n이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.<br>\n공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고,<br>\nweb layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- ApplicationContext 빈 설정 파일--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"comment\">&lt;!--빈 설정 파일들간에 구분은 줄바꿈(\\n),컴마(,),세미콜론(;)등으로 한다.--&gt;</span> </span><br><span class=\"line\">        /WEB-INF/config/myapp-service.xml,</span><br><span class=\"line\">        /WEB-INF/config/myapp-dao.xml \t\t</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, </span></span><br><span class=\"line\"><span class=\"comment\">로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>employee<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> \t\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> \t</span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> /WEB-INF/config/myapp-servlet.xml <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>webservice<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> \t\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span> /WEB-INF/config/myapp-webservice.xml <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.<br>\n(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)</p>\n<p>따라서<br>\nemployee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,<br>\nwebServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.</p>\n<h1>참고</h1>\n<p><a href=\"http://mangkyu.tistory.com/18\" target=\"_blank\" rel=\"noopener\">http://mangkyu.tistory.com/18</a><br>\n<a href=\"http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet\" target=\"_blank\" rel=\"noopener\">http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet</a><br>\n<a href=\"http://hermeslog.tistory.com/156\" target=\"_blank\" rel=\"noopener\">http://hermeslog.tistory.com/156</a><br>\n<a href=\"https://github.com/dongmyo/dispatcher2\" target=\"_blank\" rel=\"noopener\">https://github.com/dongmyo/dispatcher2</a><br>\n<a href=\"https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/\" target=\"_blank\" rel=\"noopener\">https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/</a><br>\n<a href=\"https://nesoy.github.io/articles/2017-02/Front-Controller\" target=\"_blank\" rel=\"noopener\">https://nesoy.github.io/articles/2017-02/Front-Controller</a><br>\n<a href=\"http://wonwoo.ml/index.php/post/1590\" target=\"_blank\" rel=\"noopener\">http://wonwoo.ml/index.php/post/1590</a></p>\n"},{"title":"Servlet이란?","catalog":true,"date":"2018-09-01T04:50:06.000Z","subtitle":"Servlet.. 항상 이름만 들어본 그대여","header-img":null,"Categories":["Spring"],"typora-root-url":"./2018-09-01-servlet","typora-copy-images-to":"./2018-09-01-servlet","_content":"\n![servlet](./servlet.png)\n\n# 들어가며\n\n약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, \"이렇게 코딩하면 이렇게 동작하네~\" 라는 생각만 가지고 개발을 해왔었다. 근 1~2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 \"이게 이래서 이렇게 동작하는구나~\" 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.\n\n최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.\n\n\n<br/>\n\n# Servlet\n\nServlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데... 이제와서 알아보게 되었다.\n\nServlet의 정의에 대해 찾아보게 되었다. (출처 : [wikipedia](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF))\n\n>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 \"서블릿\"이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.\n\n결국은 `웹 서버에서 돌아가는 Java 코드`라는 뜻이다.\nJava 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.\n`HttpServlet` 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.\n\n\n\n## **Servlet의 특징**\n\n* Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술\n* 흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.\n* 클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.\n* Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.\n  (doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)\n* 클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다. \n  (WAS 내의 Thread pool의 Thread 객체를 이용한다.)\n* Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다\n  (내부적으로 Sington을 구현하고 있지는 않다고한다.)\n  여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.\n* 요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.\n  (오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)\n* `MVC에서 컨트롤러로 이용됨..` 이라고 다른 블로그에 많이들 써있는데..\n  솔직히 맞는 얘기가 아니라고 생각한다.\n  Spring MVC에서 Servlet이 하던 역할을 Controller단에서 @RequestMapping 어노테이션을 이용해 서블릿의 기능과 유사하게 만들어 놓은 것 뿐이다.\n  실제 URL-Pattern에 따른 Servlet-mapping 방식과 @RequestMapping 어노테이션을 이용한 mappingHandler처리 시, 유사하게 만들어 놓은 것 뿐이라는 의미이다.\n  따라서 Spring MVC에서 서블릿이 컨트롤러로 이용된다는 것은 엄연히 틀린 말이다.\n\n\n\n<br/>\n\n# Servlet Container\n\nServlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?\n당연히 있다. WAS라고 불리우는 프로그램이 있다.\nJava 진영에서 자주 사용하는 WAS는 단연 으뜸으로 `Apache Tomcat`이 있다. \n(다른거로는 `Jeus`나, `jBoss` 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)\n\nWAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.\n\n* Web Server (apache, nginx)와의 통신 지원\n  * 클라이언트 요청(Request)에 대한 Socket 통신 지원\n\n* Servlet Lifecycle 관리\n\n* Client 접근 URL에 대한 Servlet Mapping \n* 클라이언트 요청(Request)에 대한 멀티 스레드 관리\n* 선언적인 보안관리\n  * 보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.\n  * Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문\n  * DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.\n    대표적인 예로 Spring Security가 있다.\n\n\n\n\n<br/>\n\n# Servlet LifeCycle\n\n![Servlet-life-cycle](./Servlet-life-cycle.png)\n\nServlet의 LifeCycle은 3단계로 이루어 진다.\n\n* init() \n  *  WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.\n  * 주로 Servlet 객체에 대한 초기화 로직을 작성한다.\n  * 실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고\n    다시 서블릿 생성과 동시에 init()이 실행\n* service()\n  * Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.\n    (doGet(), doPost(), doPut(), doDel())\n* destroy()\n  * WAS shutdown 시 호출 된다.\n  * 주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다\n  * 자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.\n\n\n<br/>\n\n# Servlet 설정하기\n\n## Servlet class 생성하기\n\n~~~java\npackage com.example.springstudy.demo3.servlet;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@Slf4j\n@WebServlet(name=\"demoServlet\", url-pattern=\"/servlet/demo\")\npublic class DemoServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        log.info(\"doGet() 실행실행실행!!!\");\n        Thread thread = Thread.currentThread();\n        log.info(\"Thread ID : \" + thread.getId());\n        super.doGet(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n\n    @Override\n    public void destroy() {\n        log.info(\"Servlet destroy()\");\n        super.destroy();\n    }\n\n    @Override\n    public void init() throws ServletException {\n        log.info(\"Servlet init()\");\n        super.init();\n    }\n}\n\n~~~\n\n@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.\n(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)\n\n기본적으로 Servlet 클래스 생성은 `HttpServlet` 클래스를 상속 받아 생성한다.\nHttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.\n\n\n\n## web.xml 기반 설정\n\n~~~xml\n<servlet>\n     <servlet-name>demoServlet</servlet-name>\n     <servlet-class>com.example.springstudy.demo3.servlet.DemoServlet</servlet-class>\n</servlet>\n\n<servlet-mapping>\n    <servlet-name>demoServlet</servlet-name> \n    <url-pattern>/servlet/demo</url-pattern> \n</servlet-mapping>\n~~~\n\nweb.xml에 servlet 클래스를 선언하고 <servlet-mapping> 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.\n\n\n\n## Java Config 기반 설정\n\n~~~java\npackage com.example.springstudy.demo3.config;\n\nimport com.example.springstudy.demo3.servlet.DemoServlet;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class DemoServletConfig {\n\n    @Bean\n    public ServletRegistrationBean demoServletRegistrationBean() {\n        ServletRegistrationBean demoServletRegistrationBean = new ServletRegistrationBean();\n        demoServletRegistrationBean.setServlet(new DemoServlet());\n        demoServletRegistrationBean.addUrlMappings(\"/servlet/demo\");\n        return demoServletRegistrationBean;\n    }\n}\n\n~~~\n\n@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.\nServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.\n\n\n\n\n<br/>\n\n# JSP vs Servlet\n\n**JSP와 Servlet의 차이점**\n\n* JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태\n* Servlet은 html 태그가 out.println(\"<html>\") 형태로 들어간 형태\n\n\n\n## JSP -> Servlet 변환 과정\n\n![jspToServlet](./jspToServlet.jpeg)\n\n\n\nServlet의 최종 형태는 out.println(\"<html>\") 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.\n\n\n\n# 참조\n\nhttp://mangkyu.tistory.com/14\nhttp://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\nhttp://til0804.tistory.com/25","source":"_posts/2018-09-01-servlet.md","raw":"---\ntitle: Servlet이란?\ncatalog: true\ndate: 2018-09-01 13:50:06\nsubtitle: Servlet.. 항상 이름만 들어본 그대여\nheader-img:\nCategories:\n - Spring\ntags: \n - Spring\n - J2EE\ntypora-root-url: ./2018-09-01-servlet\ntypora-copy-images-to: ./2018-09-01-servlet\n---\n\n![servlet](./servlet.png)\n\n# 들어가며\n\n약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, \"이렇게 코딩하면 이렇게 동작하네~\" 라는 생각만 가지고 개발을 해왔었다. 근 1~2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 \"이게 이래서 이렇게 동작하는구나~\" 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.\n\n최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.\n\n\n<br/>\n\n# Servlet\n\nServlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데... 이제와서 알아보게 되었다.\n\nServlet의 정의에 대해 찾아보게 되었다. (출처 : [wikipedia](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF))\n\n>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 \"서블릿\"이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.\n\n결국은 `웹 서버에서 돌아가는 Java 코드`라는 뜻이다.\nJava 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.\n`HttpServlet` 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.\n\n\n\n## **Servlet의 특징**\n\n* Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술\n* 흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.\n* 클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.\n* Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.\n  (doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)\n* 클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다. \n  (WAS 내의 Thread pool의 Thread 객체를 이용한다.)\n* Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다\n  (내부적으로 Sington을 구현하고 있지는 않다고한다.)\n  여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.\n* 요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.\n  (오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)\n* `MVC에서 컨트롤러로 이용됨..` 이라고 다른 블로그에 많이들 써있는데..\n  솔직히 맞는 얘기가 아니라고 생각한다.\n  Spring MVC에서 Servlet이 하던 역할을 Controller단에서 @RequestMapping 어노테이션을 이용해 서블릿의 기능과 유사하게 만들어 놓은 것 뿐이다.\n  실제 URL-Pattern에 따른 Servlet-mapping 방식과 @RequestMapping 어노테이션을 이용한 mappingHandler처리 시, 유사하게 만들어 놓은 것 뿐이라는 의미이다.\n  따라서 Spring MVC에서 서블릿이 컨트롤러로 이용된다는 것은 엄연히 틀린 말이다.\n\n\n\n<br/>\n\n# Servlet Container\n\nServlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?\n당연히 있다. WAS라고 불리우는 프로그램이 있다.\nJava 진영에서 자주 사용하는 WAS는 단연 으뜸으로 `Apache Tomcat`이 있다. \n(다른거로는 `Jeus`나, `jBoss` 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)\n\nWAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.\n\n* Web Server (apache, nginx)와의 통신 지원\n  * 클라이언트 요청(Request)에 대한 Socket 통신 지원\n\n* Servlet Lifecycle 관리\n\n* Client 접근 URL에 대한 Servlet Mapping \n* 클라이언트 요청(Request)에 대한 멀티 스레드 관리\n* 선언적인 보안관리\n  * 보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.\n  * Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문\n  * DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.\n    대표적인 예로 Spring Security가 있다.\n\n\n\n\n<br/>\n\n# Servlet LifeCycle\n\n![Servlet-life-cycle](./Servlet-life-cycle.png)\n\nServlet의 LifeCycle은 3단계로 이루어 진다.\n\n* init() \n  *  WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.\n  * 주로 Servlet 객체에 대한 초기화 로직을 작성한다.\n  * 실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고\n    다시 서블릿 생성과 동시에 init()이 실행\n* service()\n  * Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.\n    (doGet(), doPost(), doPut(), doDel())\n* destroy()\n  * WAS shutdown 시 호출 된다.\n  * 주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다\n  * 자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.\n\n\n<br/>\n\n# Servlet 설정하기\n\n## Servlet class 생성하기\n\n~~~java\npackage com.example.springstudy.demo3.servlet;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@Slf4j\n@WebServlet(name=\"demoServlet\", url-pattern=\"/servlet/demo\")\npublic class DemoServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        log.info(\"doGet() 실행실행실행!!!\");\n        Thread thread = Thread.currentThread();\n        log.info(\"Thread ID : \" + thread.getId());\n        super.doGet(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n\n    @Override\n    public void destroy() {\n        log.info(\"Servlet destroy()\");\n        super.destroy();\n    }\n\n    @Override\n    public void init() throws ServletException {\n        log.info(\"Servlet init()\");\n        super.init();\n    }\n}\n\n~~~\n\n@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.\n(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)\n\n기본적으로 Servlet 클래스 생성은 `HttpServlet` 클래스를 상속 받아 생성한다.\nHttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.\n\n\n\n## web.xml 기반 설정\n\n~~~xml\n<servlet>\n     <servlet-name>demoServlet</servlet-name>\n     <servlet-class>com.example.springstudy.demo3.servlet.DemoServlet</servlet-class>\n</servlet>\n\n<servlet-mapping>\n    <servlet-name>demoServlet</servlet-name> \n    <url-pattern>/servlet/demo</url-pattern> \n</servlet-mapping>\n~~~\n\nweb.xml에 servlet 클래스를 선언하고 <servlet-mapping> 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.\n\n\n\n## Java Config 기반 설정\n\n~~~java\npackage com.example.springstudy.demo3.config;\n\nimport com.example.springstudy.demo3.servlet.DemoServlet;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class DemoServletConfig {\n\n    @Bean\n    public ServletRegistrationBean demoServletRegistrationBean() {\n        ServletRegistrationBean demoServletRegistrationBean = new ServletRegistrationBean();\n        demoServletRegistrationBean.setServlet(new DemoServlet());\n        demoServletRegistrationBean.addUrlMappings(\"/servlet/demo\");\n        return demoServletRegistrationBean;\n    }\n}\n\n~~~\n\n@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.\nServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.\n\n\n\n\n<br/>\n\n# JSP vs Servlet\n\n**JSP와 Servlet의 차이점**\n\n* JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태\n* Servlet은 html 태그가 out.println(\"<html>\") 형태로 들어간 형태\n\n\n\n## JSP -> Servlet 변환 과정\n\n![jspToServlet](./jspToServlet.jpeg)\n\n\n\nServlet의 최종 형태는 out.println(\"<html>\") 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.\n\n\n\n# 참조\n\nhttp://mangkyu.tistory.com/14\nhttp://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\nhttp://til0804.tistory.com/25","slug":"2018-09-01-servlet","published":1,"updated":"2018-11-27T07:23:32.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp55h5i500144f1t39gbwrl9","content":"<p><img src=\"./servlet.png\" alt=\"servlet\"></p>\n<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, “이렇게 코딩하면 이렇게 동작하네~” 라는 생각만 가지고 개발을 해왔었다. 근 1~2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 “이게 이래서 이렇게 동작하는구나~” 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.</p>\n<p>최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.</p>\n<br>\n<h1><span id=\"servlet\">Servlet</span></h1>\n<p>Servlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데… 이제와서 알아보게 되었다.</p>\n<p>Servlet의 정의에 대해 찾아보게 되었다. (출처 : <a href=\"https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF\" target=\"_blank\" rel=\"noopener\">wikipedia</a>)</p>\n<blockquote>\n<p>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 &quot;서블릿&quot;이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.</p>\n</blockquote>\n<p>결국은 <code>웹 서버에서 돌아가는 Java 코드</code>라는 뜻이다.<br>\nJava 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.<br>\n<code>HttpServlet</code> 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.</p>\n<h2><span id=\"servlet의-특징\"><strong>Servlet의 특징</strong></span></h2>\n<ul>\n<li>Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술</li>\n<li>흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.</li>\n<li>클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.</li>\n<li>Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.<br>\n(doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)</li>\n<li>클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다.<br>\n(WAS 내의 Thread pool의 Thread 객체를 이용한다.)</li>\n<li>Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다<br>\n(내부적으로 Sington을 구현하고 있지는 않다고한다.)<br>\n여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.</li>\n<li>요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.<br>\n(오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)</li>\n<li><code>MVC에서 컨트롤러로 이용됨..</code> 이라고 다른 블로그에 많이들 써있는데…<br>\n솔직히 맞는 얘기가 아니라고 생각한다.<br>\nSpring MVC에서 Servlet이 하던 역할을 Controller단에서 @RequestMapping 어노테이션을 이용해 서블릿의 기능과 유사하게 만들어 놓은 것 뿐이다.<br>\n실제 URL-Pattern에 따른 Servlet-mapping 방식과 @RequestMapping 어노테이션을 이용한 mappingHandler처리 시, 유사하게 만들어 놓은 것 뿐이라는 의미이다.<br>\n따라서 Spring MVC에서 서블릿이 컨트롤러로 이용된다는 것은 엄연히 틀린 말이다.</li>\n</ul>\n<br>\n<h1><span id=\"servlet-container\">Servlet Container</span></h1>\n<p>Servlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?<br>\n당연히 있다. WAS라고 불리우는 프로그램이 있다.<br>\nJava 진영에서 자주 사용하는 WAS는 단연 으뜸으로 <code>Apache Tomcat</code>이 있다.<br>\n(다른거로는 <code>Jeus</code>나, <code>jBoss</code> 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)</p>\n<p>WAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.</p>\n<ul>\n<li>\n<p>Web Server (apache, nginx)와의 통신 지원</p>\n<ul>\n<li>클라이언트 요청(Request)에 대한 Socket 통신 지원</li>\n</ul>\n</li>\n<li>\n<p>Servlet Lifecycle 관리</p>\n</li>\n<li>\n<p>Client 접근 URL에 대한 Servlet Mapping</p>\n</li>\n<li>\n<p>클라이언트 요청(Request)에 대한 멀티 스레드 관리</p>\n</li>\n<li>\n<p>선언적인 보안관리</p>\n<ul>\n<li>보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.</li>\n<li>Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문</li>\n<li>DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.<br>\n대표적인 예로 Spring Security가 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h1><span id=\"servlet-lifecycle\">Servlet LifeCycle</span></h1>\n<p><img src=\"./Servlet-life-cycle.png\" alt=\"Servlet-life-cycle\"></p>\n<p>Servlet의 LifeCycle은 3단계로 이루어 진다.</p>\n<ul>\n<li>init()\n<ul>\n<li>WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.</li>\n<li>주로 Servlet 객체에 대한 초기화 로직을 작성한다.</li>\n<li>실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고<br>\n다시 서블릿 생성과 동시에 init()이 실행</li>\n</ul>\n</li>\n<li>service()\n<ul>\n<li>Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.<br>\n(doGet(), doPost(), doPut(), doDel())</li>\n</ul>\n</li>\n<li>destroy()\n<ul>\n<li>WAS shutdown 시 호출 된다.</li>\n<li>주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다</li>\n<li>자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h1><span id=\"servlet-설정하기\">Servlet 설정하기</span></h1>\n<h2><span id=\"servlet-class-생성하기\">Servlet class 생성하기</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo3.servlet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@WebServlet</span>(name=<span class=\"string\">\"demoServlet\"</span>, url-pattern=<span class=\"string\">\"/servlet/demo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"doGet() 실행실행실행!!!\"</span>);</span><br><span class=\"line\">        Thread thread = Thread.currentThread();</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Thread ID : \"</span> + thread.getId());</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doGet(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doPost(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Servlet destroy()\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Servlet init()\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.<br>\n(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)</p>\n<p>기본적으로 Servlet 클래스 생성은 <code>HttpServlet</code> 클래스를 상속 받아 생성한다.<br>\nHttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.</p>\n<h2><span id=\"webxml-기반-설정\">web.xml 기반 설정</span></h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.example.springstudy.demo3.servlet.DemoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/servlet/demo<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>web.xml에 servlet 클래스를 선언하고 <servlet-mapping> 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.</servlet-mapping></p>\n<h2><span id=\"java-config-기반-설정\">Java Config 기반 설정</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo3.servlet.DemoServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServletConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServletRegistrationBean <span class=\"title\">demoServletRegistrationBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ServletRegistrationBean demoServletRegistrationBean = <span class=\"keyword\">new</span> ServletRegistrationBean();</span><br><span class=\"line\">        demoServletRegistrationBean.setServlet(<span class=\"keyword\">new</span> DemoServlet());</span><br><span class=\"line\">        demoServletRegistrationBean.addUrlMappings(<span class=\"string\">\"/servlet/demo\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> demoServletRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.<br>\nServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.</p>\n<br>\n<h1><span id=\"jsp-vs-servlet\">JSP vs Servlet</span></h1>\n<p><strong>JSP와 Servlet의 차이점</strong></p>\n<ul>\n<li>JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태</li>\n<li>Servlet은 html 태그가 out.println(&quot;<html>&quot;) 형태로 들어간 형태</html></li>\n</ul>\n<h2><span id=\"jsp-gt-servlet-변환-과정\">JSP -&gt; Servlet 변환 과정</span></h2>\n<p><img src=\"./jspToServlet.jpeg\" alt=\"jspToServlet\"></p>\n<p>Servlet의 최종 형태는 out.println(&quot;<html>&quot;) 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.</html></p>\n<h1><span id=\"참조\">참조</span></h1>\n<p><a href=\"http://mangkyu.tistory.com/14\" target=\"_blank\" rel=\"noopener\">http://mangkyu.tistory.com/14</a><br>\n<a href=\"http://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" target=\"_blank\" rel=\"noopener\">http://breath91.tistory.com/entry/Servlet-이란-무엇인가</a><br>\n<a href=\"http://til0804.tistory.com/25\" target=\"_blank\" rel=\"noopener\">http://til0804.tistory.com/25</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"./servlet.png\" alt=\"servlet\"></p>\n<h1>들어가며</h1>\n<p>약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, “이렇게 코딩하면 이렇게 동작하네~” 라는 생각만 가지고 개발을 해왔었다. 근 1~2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 “이게 이래서 이렇게 동작하는구나~” 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.</p>\n<p>최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.</p>\n<br>\n<h1>Servlet</h1>\n<p>Servlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데… 이제와서 알아보게 되었다.</p>\n<p>Servlet의 정의에 대해 찾아보게 되었다. (출처 : <a href=\"https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF\" target=\"_blank\" rel=\"noopener\">wikipedia</a>)</p>\n<blockquote>\n<p>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 &quot;서블릿&quot;이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.</p>\n</blockquote>\n<p>결국은 <code>웹 서버에서 돌아가는 Java 코드</code>라는 뜻이다.<br>\nJava 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.<br>\n<code>HttpServlet</code> 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.</p>\n<h2><strong>Servlet의 특징</strong></h2>\n<ul>\n<li>Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술</li>\n<li>흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.</li>\n<li>클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.</li>\n<li>Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.<br>\n(doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)</li>\n<li>클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다.<br>\n(WAS 내의 Thread pool의 Thread 객체를 이용한다.)</li>\n<li>Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다<br>\n(내부적으로 Sington을 구현하고 있지는 않다고한다.)<br>\n여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.</li>\n<li>요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.<br>\n(오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)</li>\n<li><code>MVC에서 컨트롤러로 이용됨..</code> 이라고 다른 블로그에 많이들 써있는데…<br>\n솔직히 맞는 얘기가 아니라고 생각한다.<br>\nSpring MVC에서 Servlet이 하던 역할을 Controller단에서 @RequestMapping 어노테이션을 이용해 서블릿의 기능과 유사하게 만들어 놓은 것 뿐이다.<br>\n실제 URL-Pattern에 따른 Servlet-mapping 방식과 @RequestMapping 어노테이션을 이용한 mappingHandler처리 시, 유사하게 만들어 놓은 것 뿐이라는 의미이다.<br>\n따라서 Spring MVC에서 서블릿이 컨트롤러로 이용된다는 것은 엄연히 틀린 말이다.</li>\n</ul>\n<br>\n<h1>Servlet Container</h1>\n<p>Servlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?<br>\n당연히 있다. WAS라고 불리우는 프로그램이 있다.<br>\nJava 진영에서 자주 사용하는 WAS는 단연 으뜸으로 <code>Apache Tomcat</code>이 있다.<br>\n(다른거로는 <code>Jeus</code>나, <code>jBoss</code> 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)</p>\n<p>WAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.</p>\n<ul>\n<li>\n<p>Web Server (apache, nginx)와의 통신 지원</p>\n<ul>\n<li>클라이언트 요청(Request)에 대한 Socket 통신 지원</li>\n</ul>\n</li>\n<li>\n<p>Servlet Lifecycle 관리</p>\n</li>\n<li>\n<p>Client 접근 URL에 대한 Servlet Mapping</p>\n</li>\n<li>\n<p>클라이언트 요청(Request)에 대한 멀티 스레드 관리</p>\n</li>\n<li>\n<p>선언적인 보안관리</p>\n<ul>\n<li>보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.</li>\n<li>Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문</li>\n<li>DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.<br>\n대표적인 예로 Spring Security가 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h1>Servlet LifeCycle</h1>\n<p><img src=\"./Servlet-life-cycle.png\" alt=\"Servlet-life-cycle\"></p>\n<p>Servlet의 LifeCycle은 3단계로 이루어 진다.</p>\n<ul>\n<li>init()\n<ul>\n<li>WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.</li>\n<li>주로 Servlet 객체에 대한 초기화 로직을 작성한다.</li>\n<li>실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고<br>\n다시 서블릿 생성과 동시에 init()이 실행</li>\n</ul>\n</li>\n<li>service()\n<ul>\n<li>Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.<br>\n(doGet(), doPost(), doPut(), doDel())</li>\n</ul>\n</li>\n<li>destroy()\n<ul>\n<li>WAS shutdown 시 호출 된다.</li>\n<li>주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다</li>\n<li>자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h1>Servlet 설정하기</h1>\n<h2>Servlet class 생성하기</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo3.servlet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@WebServlet</span>(name=<span class=\"string\">\"demoServlet\"</span>, url-pattern=<span class=\"string\">\"/servlet/demo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"doGet() 실행실행실행!!!\"</span>);</span><br><span class=\"line\">        Thread thread = Thread.currentThread();</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Thread ID : \"</span> + thread.getId());</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doGet(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doPost(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Servlet destroy()\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Servlet init()\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.<br>\n(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)</p>\n<p>기본적으로 Servlet 클래스 생성은 <code>HttpServlet</code> 클래스를 상속 받아 생성한다.<br>\nHttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.</p>\n<h2>web.xml 기반 설정</h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.example.springstudy.demo3.servlet.DemoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demoServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/servlet/demo<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>web.xml에 servlet 클래스를 선언하고 <servlet-mapping> 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.</servlet-mapping></p>\n<h2>Java Config 기반 설정</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.demo3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.demo3.servlet.DemoServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServletConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServletRegistrationBean <span class=\"title\">demoServletRegistrationBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ServletRegistrationBean demoServletRegistrationBean = <span class=\"keyword\">new</span> ServletRegistrationBean();</span><br><span class=\"line\">        demoServletRegistrationBean.setServlet(<span class=\"keyword\">new</span> DemoServlet());</span><br><span class=\"line\">        demoServletRegistrationBean.addUrlMappings(<span class=\"string\">\"/servlet/demo\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> demoServletRegistrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.<br>\nServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.</p>\n<br>\n<h1>JSP vs Servlet</h1>\n<p><strong>JSP와 Servlet의 차이점</strong></p>\n<ul>\n<li>JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태</li>\n<li>Servlet은 html 태그가 out.println(&quot;<html>&quot;) 형태로 들어간 형태</html></li>\n</ul>\n<h2>JSP -&gt; Servlet 변환 과정</h2>\n<p><img src=\"./jspToServlet.jpeg\" alt=\"jspToServlet\"></p>\n<p>Servlet의 최종 형태는 out.println(&quot;<html>&quot;) 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.</html></p>\n<h1>참조</h1>\n<p><a href=\"http://mangkyu.tistory.com/14\" target=\"_blank\" rel=\"noopener\">http://mangkyu.tistory.com/14</a><br>\n<a href=\"http://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" target=\"_blank\" rel=\"noopener\">http://breath91.tistory.com/entry/Servlet-이란-무엇인가</a><br>\n<a href=\"http://til0804.tistory.com/25\" target=\"_blank\" rel=\"noopener\">http://til0804.tistory.com/25</a></p>\n"},{"title":"Java Exception","catalog":true,"date":"2018-08-29T15:07:03.000Z","subtitle":"Java의 기본 예외처리","header-img":null,"Categories":["Java"],"typora-root-url":"./2018-08-29-java-exception","typora-copy-images-to":"./2018-08-29-java-exception","_content":"\n\n# 들어가며\n\nJava/Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.\n예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.\n이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.\n\n\n\n# 에러(Error)와 예외(Exception)\n\n![Exception-Class](./Exception-Class.png)\n\nJava에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.\nException은 또 2가지 종류로 구분 할 수 있다.\n\n* Error \n  * 주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.\n  * 주로 `복구 불가능한 상황`에 대해 사용한다.\n  * 주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.\n  * 관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.\n    (어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)\n* Checked Exception \n  * 점검지정 예외\n  * Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.\n  * 예외처리를 하지 않을 시, `컴파일 오류가 발생`\n  * 주로 `복구 가능한 상황`에 Checked Exception을 사용한다.\n  * Custom Checked Exception을 만들 경우 `Exception` 클래스를 상속하여 만든다.\n* Unchecked Exception\n  * 무점검 예외\n  * 프로그래밍 오류를 표현하는 경우 사용\n  * 개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.\n  * 주로 `복구 불가능한 상황`에 대해 사용한다.\n  * Custom Unchecked Exception을 만들 경우 `RuntimeException` 클래스를 상속하여 만든다\n\n\n\n## 추가적으로..\n\n개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.\n아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.\nChecked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.\n지원자가 했던 \"Checked Exception 절대 쓰지 말자!\" \"Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!\"라는 의견도 어느정도는 맞는 소리이다.\n새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의....로 간다고 하면 밑에서 부터 계속 throw..throw.. 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다. \n다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.\n\n\n\n# Java에서의 기본적인 예외처리\n\n## try-catch-finally\n\ntry-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.\n프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.\n\n~~~java\ntry {\n    //핵심 로직 수행\n} catch(Exception e) {\n    //예외 발생 시, 예외에 대한 처리\n} finally {\n   //try block, catch block 실행 후 반드시 실행하는 로직\n   //주로 자원에 대한 해제 로직이 추가된다. \n}\n~~~\n\n\n\n## try-catch-resources\n\nJava 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.\n\n~~~java\ntry (InputStream is = new FileInputStream(file)) { \n     //try block이 종료 되면 InputStream에 대한 close() 메소드를 실행\n     //핵심 로직 수행\n} catch (Exception e) {\n    //예외 발생 시, 예외에 대한 처리\n}\n~~~\n\n\n\n## Multi catch\n\nJava 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.\n\n~~~java\ntry (InputStream is = new FileInputStream(file)) { \n     //try block이 종료 되면 InputStream에 대한 close() 메소드를 실행\n     //핵심 로직 수행\n} catch (NullPointerException | ArrayIndexBoundException e) {\n    //예외 발생 시, 예외에 대한 처리\n}\n~~~\n\n\n\n# Exception Handling\n\nChecked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.\n\n* Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기\n* try-catch구문을 통한 예외처리를 하도록 유도\n\n보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.\n하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.\n\n\n\n# Anti Pattern\n\n1. Exception을 무시 하지 말 것\n2. exception.printStackTrace()는 쓰는게 아니다.\n3. 반복문 내에서는 Checked Exception에 대한 처리는 지양하자\n\n\n\n## Exception을 무시 하지 말 것 \n\n간혹 코드를 보다 보면..\n\n~~~java\ntry {\n    //열심히 작성\n    veryHardDo();\n} catch (Exception e) {\n    //아무것도 안해요~\n}\n~~~\n\n이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고.. 막상 catch구문에 작성할 코드는 없어보이고... 할 때 저런 코드들이 나오게 된다.\n이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고.. 왜 에러나는지 모르는 코드가 되어버린다. \n되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자.. (로그라도 남겨줘 ㅜㅜ)\n\n\n\n## exception.printStackTrace()는 쓰는게 아니다.\n\nexception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)\n하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.\n\n\n\n## 반복문 내에서는 Checked Exception에 대한 처리는 지양하자\n\n~~~java\nfor (String item : items) {\n    try {\n        insert(item);\n    }catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n~~~\n\n반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.\n이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.\n\n\n\n# 참조\n\nEffective Java 2nd Edition (Joshua Bloch)\n가장 빨리 만나는 자바8 (카이 호스트만)","source":"_posts/2018-08-29-java-exception.md","raw":"---\ntitle: Java Exception\ncatalog: true\ndate: 2018-08-30 00:07:03\nsubtitle: Java의 기본 예외처리\nheader-img:\nCategories:\n - Java\ntags: \n - Java\ntypora-root-url: ./2018-08-29-java-exception\ntypora-copy-images-to: ./2018-08-29-java-exception\n---\n\n\n# 들어가며\n\nJava/Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.\n예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.\n이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.\n\n\n\n# 에러(Error)와 예외(Exception)\n\n![Exception-Class](./Exception-Class.png)\n\nJava에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.\nException은 또 2가지 종류로 구분 할 수 있다.\n\n* Error \n  * 주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.\n  * 주로 `복구 불가능한 상황`에 대해 사용한다.\n  * 주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.\n  * 관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.\n    (어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)\n* Checked Exception \n  * 점검지정 예외\n  * Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.\n  * 예외처리를 하지 않을 시, `컴파일 오류가 발생`\n  * 주로 `복구 가능한 상황`에 Checked Exception을 사용한다.\n  * Custom Checked Exception을 만들 경우 `Exception` 클래스를 상속하여 만든다.\n* Unchecked Exception\n  * 무점검 예외\n  * 프로그래밍 오류를 표현하는 경우 사용\n  * 개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.\n  * 주로 `복구 불가능한 상황`에 대해 사용한다.\n  * Custom Unchecked Exception을 만들 경우 `RuntimeException` 클래스를 상속하여 만든다\n\n\n\n## 추가적으로..\n\n개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.\n아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.\nChecked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.\n지원자가 했던 \"Checked Exception 절대 쓰지 말자!\" \"Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!\"라는 의견도 어느정도는 맞는 소리이다.\n새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의....로 간다고 하면 밑에서 부터 계속 throw..throw.. 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다. \n다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.\n\n\n\n# Java에서의 기본적인 예외처리\n\n## try-catch-finally\n\ntry-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.\n프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.\n\n~~~java\ntry {\n    //핵심 로직 수행\n} catch(Exception e) {\n    //예외 발생 시, 예외에 대한 처리\n} finally {\n   //try block, catch block 실행 후 반드시 실행하는 로직\n   //주로 자원에 대한 해제 로직이 추가된다. \n}\n~~~\n\n\n\n## try-catch-resources\n\nJava 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.\n\n~~~java\ntry (InputStream is = new FileInputStream(file)) { \n     //try block이 종료 되면 InputStream에 대한 close() 메소드를 실행\n     //핵심 로직 수행\n} catch (Exception e) {\n    //예외 발생 시, 예외에 대한 처리\n}\n~~~\n\n\n\n## Multi catch\n\nJava 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.\n\n~~~java\ntry (InputStream is = new FileInputStream(file)) { \n     //try block이 종료 되면 InputStream에 대한 close() 메소드를 실행\n     //핵심 로직 수행\n} catch (NullPointerException | ArrayIndexBoundException e) {\n    //예외 발생 시, 예외에 대한 처리\n}\n~~~\n\n\n\n# Exception Handling\n\nChecked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.\n\n* Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기\n* try-catch구문을 통한 예외처리를 하도록 유도\n\n보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.\n하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.\n\n\n\n# Anti Pattern\n\n1. Exception을 무시 하지 말 것\n2. exception.printStackTrace()는 쓰는게 아니다.\n3. 반복문 내에서는 Checked Exception에 대한 처리는 지양하자\n\n\n\n## Exception을 무시 하지 말 것 \n\n간혹 코드를 보다 보면..\n\n~~~java\ntry {\n    //열심히 작성\n    veryHardDo();\n} catch (Exception e) {\n    //아무것도 안해요~\n}\n~~~\n\n이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고.. 막상 catch구문에 작성할 코드는 없어보이고... 할 때 저런 코드들이 나오게 된다.\n이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고.. 왜 에러나는지 모르는 코드가 되어버린다. \n되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자.. (로그라도 남겨줘 ㅜㅜ)\n\n\n\n## exception.printStackTrace()는 쓰는게 아니다.\n\nexception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)\n하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.\n\n\n\n## 반복문 내에서는 Checked Exception에 대한 처리는 지양하자\n\n~~~java\nfor (String item : items) {\n    try {\n        insert(item);\n    }catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n~~~\n\n반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.\n이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.\n\n\n\n# 참조\n\nEffective Java 2nd Edition (Joshua Bloch)\n가장 빨리 만나는 자바8 (카이 호스트만)","slug":"2018-08-29-java-exception","published":1,"updated":"2018-11-27T07:23:32.369Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp55h5i600154f1tye4tk7bg","content":"<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>Java/Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.<br>\n예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.<br>\n이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.</p>\n<h1><span id=\"에러error와-예외exception\">에러(Error)와 예외(Exception)</span></h1>\n<p><img src=\"./Exception-Class.png\" alt=\"Exception-Class\"></p>\n<p>Java에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.<br>\nException은 또 2가지 종류로 구분 할 수 있다.</p>\n<ul>\n<li>Error\n<ul>\n<li>주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.</li>\n<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>\n<li>주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.</li>\n<li>관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.<br>\n(어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)</li>\n</ul>\n</li>\n<li>Checked Exception\n<ul>\n<li>점검지정 예외</li>\n<li>Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.</li>\n<li>예외처리를 하지 않을 시, <code>컴파일 오류가 발생</code></li>\n<li>주로 <code>복구 가능한 상황</code>에 Checked Exception을 사용한다.</li>\n<li>Custom Checked Exception을 만들 경우 <code>Exception</code> 클래스를 상속하여 만든다.</li>\n</ul>\n</li>\n<li>Unchecked Exception\n<ul>\n<li>무점검 예외</li>\n<li>프로그래밍 오류를 표현하는 경우 사용</li>\n<li>개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.</li>\n<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>\n<li>Custom Unchecked Exception을 만들 경우 <code>RuntimeException</code> 클래스를 상속하여 만든다</li>\n</ul>\n</li>\n</ul>\n<h2><span id=\"추가적으로\">추가적으로…</span></h2>\n<p>개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.<br>\n아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.<br>\nChecked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.<br>\n지원자가 했던 “Checked Exception 절대 쓰지 말자!” &quot;Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!&quot;라는 의견도 어느정도는 맞는 소리이다.<br>\n새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의…로 간다고 하면 밑에서 부터 계속 throw…throw… 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다.<br>\n다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.</p>\n<h1><span id=\"java에서의-기본적인-예외처리\">Java에서의 기본적인 예외처리</span></h1>\n<h2><span id=\"try-catch-finally\">try-catch-finally</span></h2>\n<p>try-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.<br>\n프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//try block, catch block 실행 후 반드시 실행하는 로직</span></span><br><span class=\"line\">   <span class=\"comment\">//주로 자원에 대한 해제 로직이 추가된다. </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"try-catch-resources\">try-catch-resources</span></h2>\n<p>Java 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream is = <span class=\"keyword\">new</span> FileInputStream(file)) &#123; </span><br><span class=\"line\">     <span class=\"comment\">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class=\"line\">     <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"multi-catch\">Multi catch</span></h2>\n<p>Java 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream is = <span class=\"keyword\">new</span> FileInputStream(file)) &#123; </span><br><span class=\"line\">     <span class=\"comment\">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class=\"line\">     <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (NullPointerException | ArrayIndexBoundException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"exception-handling\">Exception Handling</span></h1>\n<p>Checked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.</p>\n<ul>\n<li>Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기</li>\n<li>try-catch구문을 통한 예외처리를 하도록 유도</li>\n</ul>\n<p>보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.<br>\n하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.</p>\n<h1><span id=\"anti-pattern\">Anti Pattern</span></h1>\n<ol>\n<li>Exception을 무시 하지 말 것</li>\n<li>exception.printStackTrace()는 쓰는게 아니다.</li>\n<li>반복문 내에서는 Checked Exception에 대한 처리는 지양하자</li>\n</ol>\n<h2><span id=\"exception을-무시-하지-말-것\">Exception을 무시 하지 말 것</span></h2>\n<p>간혹 코드를 보다 보면…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//열심히 작성</span></span><br><span class=\"line\">    veryHardDo();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//아무것도 안해요~</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고… 막상 catch구문에 작성할 코드는 없어보이고… 할 때 저런 코드들이 나오게 된다.<br>\n이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고… 왜 에러나는지 모르는 코드가 되어버린다.<br>\n되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자… (로그라도 남겨줘 ㅜㅜ)</p>\n<h2><span id=\"exceptionprintstacktrace는-쓰는게-아니다\">exception.printStackTrace()는 쓰는게 아니다.</span></h2>\n<p>exception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)<br>\n하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.</p>\n<h2><span id=\"반복문-내에서는-checked-exception에-대한-처리는-지양하자\">반복문 내에서는 Checked Exception에 대한 처리는 지양하자</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (String item : items) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        insert(item);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.<br>\n이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.</p>\n<h1><span id=\"참조\">참조</span></h1>\n<p>Effective Java 2nd Edition (Joshua Bloch)<br>\n가장 빨리 만나는 자바8 (카이 호스트만)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>Java/Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.<br>\n예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.<br>\n이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.</p>\n<h1>에러(Error)와 예외(Exception)</h1>\n<p><img src=\"./Exception-Class.png\" alt=\"Exception-Class\"></p>\n<p>Java에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.<br>\nException은 또 2가지 종류로 구분 할 수 있다.</p>\n<ul>\n<li>Error\n<ul>\n<li>주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.</li>\n<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>\n<li>주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.</li>\n<li>관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.<br>\n(어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)</li>\n</ul>\n</li>\n<li>Checked Exception\n<ul>\n<li>점검지정 예외</li>\n<li>Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.</li>\n<li>예외처리를 하지 않을 시, <code>컴파일 오류가 발생</code></li>\n<li>주로 <code>복구 가능한 상황</code>에 Checked Exception을 사용한다.</li>\n<li>Custom Checked Exception을 만들 경우 <code>Exception</code> 클래스를 상속하여 만든다.</li>\n</ul>\n</li>\n<li>Unchecked Exception\n<ul>\n<li>무점검 예외</li>\n<li>프로그래밍 오류를 표현하는 경우 사용</li>\n<li>개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.</li>\n<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>\n<li>Custom Unchecked Exception을 만들 경우 <code>RuntimeException</code> 클래스를 상속하여 만든다</li>\n</ul>\n</li>\n</ul>\n<h2>추가적으로…</h2>\n<p>개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.<br>\n아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.<br>\nChecked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.<br>\n지원자가 했던 “Checked Exception 절대 쓰지 말자!” &quot;Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!&quot;라는 의견도 어느정도는 맞는 소리이다.<br>\n새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의…로 간다고 하면 밑에서 부터 계속 throw…throw… 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다.<br>\n다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.</p>\n<h1>Java에서의 기본적인 예외처리</h1>\n<h2>try-catch-finally</h2>\n<p>try-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.<br>\n프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//try block, catch block 실행 후 반드시 실행하는 로직</span></span><br><span class=\"line\">   <span class=\"comment\">//주로 자원에 대한 해제 로직이 추가된다. </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>try-catch-resources</h2>\n<p>Java 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream is = <span class=\"keyword\">new</span> FileInputStream(file)) &#123; </span><br><span class=\"line\">     <span class=\"comment\">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class=\"line\">     <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Multi catch</h2>\n<p>Java 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream is = <span class=\"keyword\">new</span> FileInputStream(file)) &#123; </span><br><span class=\"line\">     <span class=\"comment\">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class=\"line\">     <span class=\"comment\">//핵심 로직 수행</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (NullPointerException | ArrayIndexBoundException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//예외 발생 시, 예외에 대한 처리</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>Exception Handling</h1>\n<p>Checked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.</p>\n<ul>\n<li>Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기</li>\n<li>try-catch구문을 통한 예외처리를 하도록 유도</li>\n</ul>\n<p>보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.<br>\n하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.</p>\n<h1>Anti Pattern</h1>\n<ol>\n<li>Exception을 무시 하지 말 것</li>\n<li>exception.printStackTrace()는 쓰는게 아니다.</li>\n<li>반복문 내에서는 Checked Exception에 대한 처리는 지양하자</li>\n</ol>\n<h2>Exception을 무시 하지 말 것</h2>\n<p>간혹 코드를 보다 보면…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//열심히 작성</span></span><br><span class=\"line\">    veryHardDo();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//아무것도 안해요~</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고… 막상 catch구문에 작성할 코드는 없어보이고… 할 때 저런 코드들이 나오게 된다.<br>\n이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고… 왜 에러나는지 모르는 코드가 되어버린다.<br>\n되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자… (로그라도 남겨줘 ㅜㅜ)</p>\n<h2>exception.printStackTrace()는 쓰는게 아니다.</h2>\n<p>exception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)<br>\n하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.</p>\n<h2>반복문 내에서는 Checked Exception에 대한 처리는 지양하자</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (String item : items) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        insert(item);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.<br>\n이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.</p>\n<h1>참조</h1>\n<p>Effective Java 2nd Edition (Joshua Bloch)<br>\n가장 빨리 만나는 자바8 (카이 호스트만)</p>\n"},{"title":"Spring IoC & DI(2)","subtitle":"Spring IoC와 DI","catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-09-21-spring-ioc-2","typora-copy-images-to":"./2018-09-21-spring-ioc-2","date":"2018-09-22T08:00:54.000Z","header-img":null,"_content":"\n# IoC란?\n\nInversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.\n보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.\n하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며\n개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.\n\n따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여\n제어의 역전 (Inversion of Control)이라 불린다.\n\n\n\n# Container가 도데체 뭐람?\n\n![containers](./containers.jpg)\n\n\n\n개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다. \nSpring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등.. Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까? \n위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다. \n이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.\n컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는.. 컨테이너를 생각하는 것이 도움이 될 것 같다.\n실제 프레임워크에서의 컨테이너도 같은 역할을 한다. \n\n**이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체**라고 할 수 있다. \n\n위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면\n\n서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,\n외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.\n\nSpring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.\n\n\n\n# DI란?\n\nDI란 Dependency Injection의 의미로 IoC를 구현한 대표적인 예야\nPojo 객체내의 종속적인 객체를 IoC Container에서 직접 객체를 Injection해주는 걸 의미해\n스프링 개발에서는 99프로 DI방식을 통해 개발자가 직접 필요한 객체를 선언하지 않고 \nIoC Container에서 넣어줘서 사용해 —> 이거는 Bean 초기화시에 이루어져\nDL (Dependency Lookup) 이라는 기능도 있는데 이거는 거의 사용하지는 않아\n이 기능은 IoC Container에서 Bean의 메타정보를 이용해서 개발자가 Bean을 직접 찾는 행위야\n\nDI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.\nDI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.\n개념 자체는 `IoC의 형태 중 하나`라고 볼 수 있다.\n\nDI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.\n클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.\n\n\n\nSpring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며\n객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.\n\n1. Constructor Injection\n2. Dependency Constructor Injection\n3. Setter Injection\n4. Field Injection\n\n\n\n# 의존성 주입 Annotation\n\nSpring/Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.\n\n* @Autowired\n  * Spring에서 지원하는 Annotation\n  * `Type`에 맞춰서 주입이 된다.\n  * Interface에 상응하는 Bean이 2개 이상 인 경우에는 `@Qualifier(\"beanName\")을 혼용`하여 \n    필요한 Bean객체를 주입한다.\n* @Inject\n  * Java에서 지원하는 Annotation\n  * `Type`에 맞춰서 주입이 된다.\n* @Resource\n  * Java에서 지원하는 Annotation\n  * `이름`에 맞춰서 주입이 된다.\n\nSpring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject/@Resource를 사용하면 문제는 없을 것이나.. 대부분은 @Autowired를 사용한다.\n\n\n\n# DI 구현방식\n\n## Constructor Injection\n\n생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.\n이 방법은 xml 설정 시에 유용한 방법이다.\n객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    \n    @Autowired\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\n~~~xml\n<bean id=\"userRepository\" class=\"com.example.user.UserRepository\"></bean>\n<bean id=\"userService\", class=\"com.example.user.UserService\">\n\t<construct-args>\n        <ref bean=\"userRepository\"></ref>\n    </construct-args>\n</bean>\n~~~\n\n\n\n## Extension Constructor Injection\n\nSpring 4에 추가된 DI방법이다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\nUserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.\n어찌보면 당연한 내용 같은데...  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.\n\n\n\n~~~java\n@AllArgsConstructor\npublic Class UserService {\n    private UserRepository userRepository;\n}\n~~~\n\n\n\n## Setter Injection\n\nSetter를 통해 DI하는 방법이다.\n이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    \n    @Autowired\n    public setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\n\n\n## Field Injection\n\nSpring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.\n아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.\n\n~~~java\npublic Class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}\n~~~\n\n\n\n# 용어 설명\n\n* Bean\n  * Spring Container에 등록 되는 POJO객체 \n  * Spring Application의 Component들이 등록 된다.\n  * 기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.\n* Bean Factory\n  * Spring IoC를 담당하는 핵심 컨테이너\n  * Bean에 대한 등록/생성/조회/소멸을 관리한다.\n  * BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.\n  * 대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)\n* Application Context\n  * BeanFactory 인터페이스의 구현체 ()\n    * 정확히는 ListableBeanFactory\n    * Bean을 Listable하게 보관하는 인터페이스를 말한다.\n  * BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.\n    * ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.\n    * ApplicationEventPublisher - 이벤트 발생을 관장한다.\n    * MessageSource - properties파일을 통해 다국어 설정이 가능\n    * BeanLifecycle - Bean의 초기화, 소멸을 담당한다.\n* Configuration Meta Data \n  * Application Context에서 IoC 설정을 위해 사용되는 메타정보\n  * 컨테이너에 어떤 기능을 세팅할때 사용\n  * Bean 생성/구성할 경우에도 사용\n  * @Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능\n\n\n\n# Bean 등록 방법\n\n## Component-Scan\n\nSpring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.\nSpring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.\n분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에 \n불필요한 메모리 할당이 이루어질 수 있다.\n그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 `가장 많이 하는 설정`이 아닐까 싶다.\n\n* @Component 종류\n  * @Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)\n  * @Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)\n  * @Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)\n  * @Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)\n\n\n\n## Servlet-Context.xml\n\n기존 Bean 생성을 xml로 등록하는 방식이다.\n이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만...\n보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.\n위에서 언급한 `Component-scan`을 주로 사용하는 것이 좋다.\n\n~~~xml\n <bean name=\"beanNameViewResolver\" class=\"org.springframework.web.servlet.view.BeanNameViewResolver\">\n        <property name=\"order\" value=\"1\"/>\n    </bean>\n    <bean name=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/views/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n        <property name=\"order\" value=\"2\"/>\n    </bean>\n~~~\n\n\n\n## @Configuration\n\nxml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.\n뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.\nBean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 `@Bean` 어노테이션을 붙여주면 된다.\n\n~~~java\n@Configuration\npublic class UserConfig {\n    @Bean\n    public UserService userService() { //메소드 명이 기본적으로 Bean Name으로 추가된다.\n        return new UserService();\n    }\n}\n~~~\n\nJava Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우 \n아주 유용한 방법이라 할 수 있겠다.\n\n\n\n# Bean 생명주기\n\nSpring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.\nBean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.\n\nBean 생명주기 처리를 하는 방법은 3가지 방식이 있다.\n\n1. InitializingBean, DisposableBean 인터페이스 구현\n2. Bean정의 시 , 메소드 지정\n3. @PostConstruct, @PreDestroy Annotation 사용\n\n\n\n## InitializingBean, DisposableBean 인터페이스 구현\n\nInitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시 \n기능을 확장 할 수 있다.\n\nInitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에\nSpring에 종속적이게 된다.\n\n~~~java\npublic class TestBeanClass implements InitializingBean, DisposableBean{\n\t\n    private Connection conn;\n    \n    @Override\n    public void afterPropertiesSet() throws Exception {\n        //자원의 할당 처리\n        conn = DBConnectionCaller.getConnection();\n        System.out.println(\"bean 생성 및 초기화 : afterPropertiesSet() 호출됨\");\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        //주로 할당된 자원의 해제를 한다.\n        if(conn != null) conn.close();\n        System.out.println(\"bean 소멸 : destroy 호출됨\");\n    }\n}\n\n~~~\n\n\n\n## Bean정의 시 , 메소드 지정\n\n~~~xml\n<bean id=\"testBean\" class=\"com.example.TestBeanClass\"                      \n   init-method=\"init\" destroy-method=\"destroy\"/>\n~~~\n\n* xml설정 파일 <bean>에서 **init-method** 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출\n* xml설정 파일 <bean>에서 **destroy-method** 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출\n\n\n\n## @PostConstruct, @PreDestroy Annotation 사용\n\n~~~java\npublic class TestBeanClass {be\n\t\n    private Connection conn;\n    \n    @PostConstruct\n    public void init() {\n        //자원의 할당 처리\n        conn = DBConnectionCaller.getConnection();\n        System.out.println(\"bean 생성 및 초기화\");\n    }\n\n    @PreDestroy\n    public void destroy() {\n        //주로 할당된 자원의 해제를 한다.\n        if(conn != null) conn.close();\n        System.out.println(\"bean 소멸\");\n    }\n}\n~~~\n\n@PostConstuct, @PreDestroy 은 `JSR-250 Annotation` 기반이다 (한마디로 자바기반)\n따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.\n\n\n\n@PostConstuct, @PreDestroy 을 사용하기 위해서는\n`<annotation-config/> `설정이나, `@AnnotationDrivenConfig `어노테이션을 붙여줘야 한다.\n\n\n\n# Bean Scope\n\nhttps://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html 을 참고함\n\n* Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.\n* Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.\n* Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용\n* Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.\n  (이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)\n* Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다. \n\n\n\n# 참조\n\nhttp://www.javajigi.net/pages/viewpage.action?pageId=3664&focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\nhttps://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3\n토비의 스프링 VOL.2 Spring IoC","source":"_posts/2018-09-21-spring-ioc-2.md","raw":"---\ntitle: Spring IoC & DI(2)\nsubtitle: Spring IoC와 DI\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\ntypora-root-url: ./2018-09-21-spring-ioc-2\ntypora-copy-images-to: ./2018-09-21-spring-ioc-2\ndate: 2018-09-22 17:00:54\nheader-img:\n---\n\n# IoC란?\n\nInversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.\n보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.\n하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며\n개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.\n\n따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여\n제어의 역전 (Inversion of Control)이라 불린다.\n\n\n\n# Container가 도데체 뭐람?\n\n![containers](./containers.jpg)\n\n\n\n개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다. \nSpring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등.. Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까? \n위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다. \n이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.\n컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는.. 컨테이너를 생각하는 것이 도움이 될 것 같다.\n실제 프레임워크에서의 컨테이너도 같은 역할을 한다. \n\n**이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체**라고 할 수 있다. \n\n위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면\n\n서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,\n외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.\n\nSpring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.\n\n\n\n# DI란?\n\nDI란 Dependency Injection의 의미로 IoC를 구현한 대표적인 예야\nPojo 객체내의 종속적인 객체를 IoC Container에서 직접 객체를 Injection해주는 걸 의미해\n스프링 개발에서는 99프로 DI방식을 통해 개발자가 직접 필요한 객체를 선언하지 않고 \nIoC Container에서 넣어줘서 사용해 —> 이거는 Bean 초기화시에 이루어져\nDL (Dependency Lookup) 이라는 기능도 있는데 이거는 거의 사용하지는 않아\n이 기능은 IoC Container에서 Bean의 메타정보를 이용해서 개발자가 Bean을 직접 찾는 행위야\n\nDI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.\nDI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.\n개념 자체는 `IoC의 형태 중 하나`라고 볼 수 있다.\n\nDI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.\n클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.\n\n\n\nSpring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며\n객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.\n\n1. Constructor Injection\n2. Dependency Constructor Injection\n3. Setter Injection\n4. Field Injection\n\n\n\n# 의존성 주입 Annotation\n\nSpring/Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.\n\n* @Autowired\n  * Spring에서 지원하는 Annotation\n  * `Type`에 맞춰서 주입이 된다.\n  * Interface에 상응하는 Bean이 2개 이상 인 경우에는 `@Qualifier(\"beanName\")을 혼용`하여 \n    필요한 Bean객체를 주입한다.\n* @Inject\n  * Java에서 지원하는 Annotation\n  * `Type`에 맞춰서 주입이 된다.\n* @Resource\n  * Java에서 지원하는 Annotation\n  * `이름`에 맞춰서 주입이 된다.\n\nSpring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject/@Resource를 사용하면 문제는 없을 것이나.. 대부분은 @Autowired를 사용한다.\n\n\n\n# DI 구현방식\n\n## Constructor Injection\n\n생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.\n이 방법은 xml 설정 시에 유용한 방법이다.\n객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    \n    @Autowired\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\n~~~xml\n<bean id=\"userRepository\" class=\"com.example.user.UserRepository\"></bean>\n<bean id=\"userService\", class=\"com.example.user.UserService\">\n\t<construct-args>\n        <ref bean=\"userRepository\"></ref>\n    </construct-args>\n</bean>\n~~~\n\n\n\n## Extension Constructor Injection\n\nSpring 4에 추가된 DI방법이다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\nUserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.\n어찌보면 당연한 내용 같은데...  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.\n\n\n\n~~~java\n@AllArgsConstructor\npublic Class UserService {\n    private UserRepository userRepository;\n}\n~~~\n\n\n\n## Setter Injection\n\nSetter를 통해 DI하는 방법이다.\n이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.\n\n~~~java\npublic Class UserService {\n    \n    private UserRepository userRepository;\n    \n    @Autowired\n    public setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n~~~\n\n\n\n## Field Injection\n\nSpring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.\n아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.\n\n~~~java\npublic Class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}\n~~~\n\n\n\n# 용어 설명\n\n* Bean\n  * Spring Container에 등록 되는 POJO객체 \n  * Spring Application의 Component들이 등록 된다.\n  * 기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.\n* Bean Factory\n  * Spring IoC를 담당하는 핵심 컨테이너\n  * Bean에 대한 등록/생성/조회/소멸을 관리한다.\n  * BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.\n  * 대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)\n* Application Context\n  * BeanFactory 인터페이스의 구현체 ()\n    * 정확히는 ListableBeanFactory\n    * Bean을 Listable하게 보관하는 인터페이스를 말한다.\n  * BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.\n    * ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.\n    * ApplicationEventPublisher - 이벤트 발생을 관장한다.\n    * MessageSource - properties파일을 통해 다국어 설정이 가능\n    * BeanLifecycle - Bean의 초기화, 소멸을 담당한다.\n* Configuration Meta Data \n  * Application Context에서 IoC 설정을 위해 사용되는 메타정보\n  * 컨테이너에 어떤 기능을 세팅할때 사용\n  * Bean 생성/구성할 경우에도 사용\n  * @Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능\n\n\n\n# Bean 등록 방법\n\n## Component-Scan\n\nSpring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.\nSpring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.\n분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에 \n불필요한 메모리 할당이 이루어질 수 있다.\n그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 `가장 많이 하는 설정`이 아닐까 싶다.\n\n* @Component 종류\n  * @Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)\n  * @Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)\n  * @Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)\n  * @Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)\n\n\n\n## Servlet-Context.xml\n\n기존 Bean 생성을 xml로 등록하는 방식이다.\n이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만...\n보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.\n위에서 언급한 `Component-scan`을 주로 사용하는 것이 좋다.\n\n~~~xml\n <bean name=\"beanNameViewResolver\" class=\"org.springframework.web.servlet.view.BeanNameViewResolver\">\n        <property name=\"order\" value=\"1\"/>\n    </bean>\n    <bean name=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/views/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n        <property name=\"order\" value=\"2\"/>\n    </bean>\n~~~\n\n\n\n## @Configuration\n\nxml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.\n뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.\nBean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 `@Bean` 어노테이션을 붙여주면 된다.\n\n~~~java\n@Configuration\npublic class UserConfig {\n    @Bean\n    public UserService userService() { //메소드 명이 기본적으로 Bean Name으로 추가된다.\n        return new UserService();\n    }\n}\n~~~\n\nJava Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우 \n아주 유용한 방법이라 할 수 있겠다.\n\n\n\n# Bean 생명주기\n\nSpring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.\nBean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.\n\nBean 생명주기 처리를 하는 방법은 3가지 방식이 있다.\n\n1. InitializingBean, DisposableBean 인터페이스 구현\n2. Bean정의 시 , 메소드 지정\n3. @PostConstruct, @PreDestroy Annotation 사용\n\n\n\n## InitializingBean, DisposableBean 인터페이스 구현\n\nInitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시 \n기능을 확장 할 수 있다.\n\nInitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에\nSpring에 종속적이게 된다.\n\n~~~java\npublic class TestBeanClass implements InitializingBean, DisposableBean{\n\t\n    private Connection conn;\n    \n    @Override\n    public void afterPropertiesSet() throws Exception {\n        //자원의 할당 처리\n        conn = DBConnectionCaller.getConnection();\n        System.out.println(\"bean 생성 및 초기화 : afterPropertiesSet() 호출됨\");\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        //주로 할당된 자원의 해제를 한다.\n        if(conn != null) conn.close();\n        System.out.println(\"bean 소멸 : destroy 호출됨\");\n    }\n}\n\n~~~\n\n\n\n## Bean정의 시 , 메소드 지정\n\n~~~xml\n<bean id=\"testBean\" class=\"com.example.TestBeanClass\"                      \n   init-method=\"init\" destroy-method=\"destroy\"/>\n~~~\n\n* xml설정 파일 <bean>에서 **init-method** 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출\n* xml설정 파일 <bean>에서 **destroy-method** 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출\n\n\n\n## @PostConstruct, @PreDestroy Annotation 사용\n\n~~~java\npublic class TestBeanClass {be\n\t\n    private Connection conn;\n    \n    @PostConstruct\n    public void init() {\n        //자원의 할당 처리\n        conn = DBConnectionCaller.getConnection();\n        System.out.println(\"bean 생성 및 초기화\");\n    }\n\n    @PreDestroy\n    public void destroy() {\n        //주로 할당된 자원의 해제를 한다.\n        if(conn != null) conn.close();\n        System.out.println(\"bean 소멸\");\n    }\n}\n~~~\n\n@PostConstuct, @PreDestroy 은 `JSR-250 Annotation` 기반이다 (한마디로 자바기반)\n따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.\n\n\n\n@PostConstuct, @PreDestroy 을 사용하기 위해서는\n`<annotation-config/> `설정이나, `@AnnotationDrivenConfig `어노테이션을 붙여줘야 한다.\n\n\n\n# Bean Scope\n\nhttps://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html 을 참고함\n\n* Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.\n* Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.\n* Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용\n* Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.\n  (이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)\n* Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다. \n\n\n\n# 참조\n\nhttp://www.javajigi.net/pages/viewpage.action?pageId=3664&focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\nhttps://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3\n토비의 스프링 VOL.2 Spring IoC","slug":"2018-09-21-spring-ioc-2","published":1,"updated":"2018-11-27T07:23:32.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp55h5i700184f1t8sz99tfn","content":"<h1><span id=\"ioc란\">IoC란?</span></h1>\n<p>Inversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.<br>\n보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.<br>\n하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며<br>\n개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.</p>\n<p>따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여<br>\n제어의 역전 (Inversion of Control)이라 불린다.</p>\n<h1><span id=\"container가-도데체-뭐람\">Container가 도데체 뭐람?</span></h1>\n<p><img src=\"./containers.jpg\" alt=\"containers\"></p>\n<p>개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다.<br>\nSpring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등… Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까?<br>\n위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다.<br>\n이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.<br>\n컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는… 컨테이너를 생각하는 것이 도움이 될 것 같다.<br>\n실제 프레임워크에서의 컨테이너도 같은 역할을 한다.</p>\n<p><strong>이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체</strong>라고 할 수 있다.</p>\n<p>위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면</p>\n<p>서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,<br>\n외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.</p>\n<p>Spring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.</p>\n<h1><span id=\"di란\">DI란?</span></h1>\n<p>DI란 Dependency Injection의 의미로 IoC를 구현한 대표적인 예야<br>\nPojo 객체내의 종속적인 객체를 IoC Container에서 직접 객체를 Injection해주는 걸 의미해<br>\n스프링 개발에서는 99프로 DI방식을 통해 개발자가 직접 필요한 객체를 선언하지 않고<br>\nIoC Container에서 넣어줘서 사용해 —&gt; 이거는 Bean 초기화시에 이루어져<br>\nDL (Dependency Lookup) 이라는 기능도 있는데 이거는 거의 사용하지는 않아<br>\n이 기능은 IoC Container에서 Bean의 메타정보를 이용해서 개발자가 Bean을 직접 찾는 행위야</p>\n<p>DI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.<br>\nDI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.<br>\n개념 자체는 <code>IoC의 형태 중 하나</code>라고 볼 수 있다.</p>\n<p>DI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.<br>\n클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.</p>\n<p>Spring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며<br>\n객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.</p>\n<ol>\n<li>Constructor Injection</li>\n<li>Dependency Constructor Injection</li>\n<li>Setter Injection</li>\n<li>Field Injection</li>\n</ol>\n<h1><span id=\"의존성-주입-annotation\">의존성 주입 Annotation</span></h1>\n<p>Spring/Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.</p>\n<ul>\n<li>@Autowired\n<ul>\n<li>Spring에서 지원하는 Annotation</li>\n<li><code>Type</code>에 맞춰서 주입이 된다.</li>\n<li>Interface에 상응하는 Bean이 2개 이상 인 경우에는 <code>@Qualifier(&quot;beanName&quot;)을 혼용</code>하여<br>\n필요한 Bean객체를 주입한다.</li>\n</ul>\n</li>\n<li>@Inject\n<ul>\n<li>Java에서 지원하는 Annotation</li>\n<li><code>Type</code>에 맞춰서 주입이 된다.</li>\n</ul>\n</li>\n<li>@Resource\n<ul>\n<li>Java에서 지원하는 Annotation</li>\n<li><code>이름</code>에 맞춰서 주입이 된다.</li>\n</ul>\n</li>\n</ul>\n<p>Spring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject/@Resource를 사용하면 문제는 없을 것이나… 대부분은 @Autowired를 사용한다.</p>\n<h1><span id=\"di-구현방식\">DI 구현방식</span></h1>\n<h2><span id=\"constructor-injection\">Constructor Injection</span></h2>\n<p>생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.<br>\n이 방법은 xml 설정 시에 유용한 방법이다.<br>\n객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userRepository\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.user.UserRepository\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span>, <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.user.UserService\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">construct-args</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userRepository\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ref</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">construct-args</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"extension-constructor-injection\">Extension Constructor Injection</span></h2>\n<p>Spring 4에 추가된 DI방법이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>UserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.<br>\n어찌보면 당연한 내용 같은데…  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"setter-injection\">Setter Injection</span></h2>\n<p>Setter를 통해 DI하는 방법이다.<br>\n이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">setUserRepository</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"field-injection\">Field Injection</span></h2>\n<p>Spring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.<br>\n아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"용어-설명\">용어 설명</span></h1>\n<ul>\n<li>Bean\n<ul>\n<li>Spring Container에 등록 되는 POJO객체</li>\n<li>Spring Application의 Component들이 등록 된다.</li>\n<li>기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.</li>\n</ul>\n</li>\n<li>Bean Factory\n<ul>\n<li>Spring IoC를 담당하는 핵심 컨테이너</li>\n<li>Bean에 대한 등록/생성/조회/소멸을 관리한다.</li>\n<li>BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.</li>\n<li>대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)</li>\n</ul>\n</li>\n<li>Application Context\n<ul>\n<li>BeanFactory 인터페이스의 구현체 ()\n<ul>\n<li>정확히는 ListableBeanFactory</li>\n<li>Bean을 Listable하게 보관하는 인터페이스를 말한다.</li>\n</ul>\n</li>\n<li>BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.\n<ul>\n<li>ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.</li>\n<li>ApplicationEventPublisher - 이벤트 발생을 관장한다.</li>\n<li>MessageSource - properties파일을 통해 다국어 설정이 가능</li>\n<li>BeanLifecycle - Bean의 초기화, 소멸을 담당한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Configuration Meta Data\n<ul>\n<li>Application Context에서 IoC 설정을 위해 사용되는 메타정보</li>\n<li>컨테이너에 어떤 기능을 세팅할때 사용</li>\n<li>Bean 생성/구성할 경우에도 사용</li>\n<li>@Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능</li>\n</ul>\n</li>\n</ul>\n<h1><span id=\"bean-등록-방법\">Bean 등록 방법</span></h1>\n<h2><span id=\"component-scan\">Component-Scan</span></h2>\n<p>Spring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.<br>\nSpring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.<br>\n분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에<br>\n불필요한 메모리 할당이 이루어질 수 있다.<br>\n그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 <code>가장 많이 하는 설정</code>이 아닐까 싶다.</p>\n<ul>\n<li>@Component 종류\n<ul>\n<li>@Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)</li>\n<li>@Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)</li>\n<li>@Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)</li>\n<li>@Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)</li>\n</ul>\n</li>\n</ul>\n<h2><span id=\"servlet-contextxml\">Servlet-Context.xml</span></h2>\n<p>기존 Bean 생성을 xml로 등록하는 방식이다.<br>\n이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만…<br>\n보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.<br>\n위에서 언급한 <code>Component-scan</code>을 주로 사용하는 것이 좋다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"beanNameViewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.BeanNameViewResolver\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"order\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"internalResourceViewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/WEB-INF/views/\"</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"order\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"2\"</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"configuration\">@Configuration</span></h2>\n<p>xml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.<br>\n뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.<br>\nBean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 <code>@Bean</code> 어노테이션을 붙여주면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserService <span class=\"title\">userService</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//메소드 명이 기본적으로 Bean Name으로 추가된다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserService();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우<br>\n아주 유용한 방법이라 할 수 있겠다.</p>\n<h1><span id=\"bean-생명주기\">Bean 생명주기</span></h1>\n<p>Spring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.<br>\nBean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.</p>\n<p>Bean 생명주기 처리를 하는 방법은 3가지 방식이 있다.</p>\n<ol>\n<li>InitializingBean, DisposableBean 인터페이스 구현</li>\n<li>Bean정의 시 , 메소드 지정</li>\n<li>@PostConstruct, @PreDestroy Annotation 사용</li>\n</ol>\n<h2><span id=\"initializingbean-disposablebean-인터페이스-구현\">InitializingBean, DisposableBean 인터페이스 구현</span></h2>\n<p>InitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시<br>\n기능을 확장 할 수 있다.</p>\n<p>InitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에<br>\nSpring에 종속적이게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBeanClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span>, <span class=\"title\">DisposableBean</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection conn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//자원의 할당 처리</span></span><br><span class=\"line\">        conn = DBConnectionCaller.getConnection();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 생성 및 초기화 : afterPropertiesSet() 호출됨\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//주로 할당된 자원의 해제를 한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) conn.close();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 소멸 : destroy 호출됨\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"bean정의-시-메소드-지정\">Bean정의 시 , 메소드 지정</span></h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.TestBeanClass\"</span>                      </span></span><br><span class=\"line\"><span class=\"tag\">   <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"destroy\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>xml설정 파일 <bean>에서 <strong>init-method</strong> 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출</bean></li>\n<li>xml설정 파일 <bean>에서 <strong>destroy-method</strong> 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출</bean></li>\n</ul>\n<h2><span id=\"postconstruct-predestroy-annotation-사용\">@PostConstruct, @PreDestroy Annotation 사용</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBeanClass</span> </span>&#123;be</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection conn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//자원의 할당 처리</span></span><br><span class=\"line\">        conn = DBConnectionCaller.getConnection();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 생성 및 초기화\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//주로 할당된 자원의 해제를 한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) conn.close();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 소멸\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@PostConstuct, @PreDestroy 은 <code>JSR-250 Annotation</code> 기반이다 (한마디로 자바기반)<br>\n따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.</p>\n<p>@PostConstuct, @PreDestroy 을 사용하기 위해서는<br>\n<code>&lt;annotation-config/&gt;</code>설정이나, <code>@AnnotationDrivenConfig</code>어노테이션을 붙여줘야 한다.</p>\n<h1><span id=\"bean-scope\">Bean Scope</span></h1>\n<p><a href=\"https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html</a> 을 참고함</p>\n<ul>\n<li>Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.</li>\n<li>Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.</li>\n<li>Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용</li>\n<li>Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.<br>\n(이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)</li>\n<li>Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다.</li>\n</ul>\n<h1><span id=\"참조\">참조</span></h1>\n<p><a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring프레임워크소개와IoC및SpringIoC의개념-2.1IoC란무엇인가%3F</a><br>\n<a href=\"http://wiki.javajigi.net/pages/viewpage.action?pageId=281\" target=\"_blank\" rel=\"noopener\">http://wiki.javajigi.net/pages/viewpage.action?pageId=281</a><br>\n<a href=\"https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/</a><br>\n<a href=\"https://okky.kr/article/415474\" target=\"_blank\" rel=\"noopener\">https://okky.kr/article/415474</a><br>\n<a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=68\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=68</a><br>\n<a href=\"http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1</a><br>\n<a href=\"http://isstory83.tistory.com/91\" target=\"_blank\" rel=\"noopener\">http://isstory83.tistory.com/91</a><br>\n<a href=\"https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3\" target=\"_blank\" rel=\"noopener\">https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3</a><br>\n토비의 스프링 VOL.2 Spring IoC</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>IoC란?</h1>\n<p>Inversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.<br>\n보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.<br>\n하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며<br>\n개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.</p>\n<p>따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여<br>\n제어의 역전 (Inversion of Control)이라 불린다.</p>\n<h1>Container가 도데체 뭐람?</h1>\n<p><img src=\"./containers.jpg\" alt=\"containers\"></p>\n<p>개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다.<br>\nSpring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등… Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까?<br>\n위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다.<br>\n이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.<br>\n컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는… 컨테이너를 생각하는 것이 도움이 될 것 같다.<br>\n실제 프레임워크에서의 컨테이너도 같은 역할을 한다.</p>\n<p><strong>이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체</strong>라고 할 수 있다.</p>\n<p>위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면</p>\n<p>서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,<br>\n외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.</p>\n<p>Spring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.</p>\n<h1>DI란?</h1>\n<p>DI란 Dependency Injection의 의미로 IoC를 구현한 대표적인 예야<br>\nPojo 객체내의 종속적인 객체를 IoC Container에서 직접 객체를 Injection해주는 걸 의미해<br>\n스프링 개발에서는 99프로 DI방식을 통해 개발자가 직접 필요한 객체를 선언하지 않고<br>\nIoC Container에서 넣어줘서 사용해 —&gt; 이거는 Bean 초기화시에 이루어져<br>\nDL (Dependency Lookup) 이라는 기능도 있는데 이거는 거의 사용하지는 않아<br>\n이 기능은 IoC Container에서 Bean의 메타정보를 이용해서 개발자가 Bean을 직접 찾는 행위야</p>\n<p>DI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.<br>\nDI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.<br>\n개념 자체는 <code>IoC의 형태 중 하나</code>라고 볼 수 있다.</p>\n<p>DI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.<br>\n클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.</p>\n<p>Spring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며<br>\n객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.</p>\n<ol>\n<li>Constructor Injection</li>\n<li>Dependency Constructor Injection</li>\n<li>Setter Injection</li>\n<li>Field Injection</li>\n</ol>\n<h1>의존성 주입 Annotation</h1>\n<p>Spring/Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.</p>\n<ul>\n<li>@Autowired\n<ul>\n<li>Spring에서 지원하는 Annotation</li>\n<li><code>Type</code>에 맞춰서 주입이 된다.</li>\n<li>Interface에 상응하는 Bean이 2개 이상 인 경우에는 <code>@Qualifier(&quot;beanName&quot;)을 혼용</code>하여<br>\n필요한 Bean객체를 주입한다.</li>\n</ul>\n</li>\n<li>@Inject\n<ul>\n<li>Java에서 지원하는 Annotation</li>\n<li><code>Type</code>에 맞춰서 주입이 된다.</li>\n</ul>\n</li>\n<li>@Resource\n<ul>\n<li>Java에서 지원하는 Annotation</li>\n<li><code>이름</code>에 맞춰서 주입이 된다.</li>\n</ul>\n</li>\n</ul>\n<p>Spring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject/@Resource를 사용하면 문제는 없을 것이나… 대부분은 @Autowired를 사용한다.</p>\n<h1>DI 구현방식</h1>\n<h2>Constructor Injection</h2>\n<p>생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.<br>\n이 방법은 xml 설정 시에 유용한 방법이다.<br>\n객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userRepository\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.user.UserRepository\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span>, <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.user.UserService\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">construct-args</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userRepository\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ref</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">construct-args</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2>Extension Constructor Injection</h2>\n<p>Spring 4에 추가된 DI방법이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>UserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.<br>\n어찌보면 당연한 내용 같은데…  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Setter Injection</h2>\n<p>Setter를 통해 DI하는 방법이다.<br>\n이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">setUserRepository</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Field Injection</h2>\n<p>Spring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.<br>\n아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class UserService &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>용어 설명</h1>\n<ul>\n<li>Bean\n<ul>\n<li>Spring Container에 등록 되는 POJO객체</li>\n<li>Spring Application의 Component들이 등록 된다.</li>\n<li>기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.</li>\n</ul>\n</li>\n<li>Bean Factory\n<ul>\n<li>Spring IoC를 담당하는 핵심 컨테이너</li>\n<li>Bean에 대한 등록/생성/조회/소멸을 관리한다.</li>\n<li>BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.</li>\n<li>대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)</li>\n</ul>\n</li>\n<li>Application Context\n<ul>\n<li>BeanFactory 인터페이스의 구현체 ()\n<ul>\n<li>정확히는 ListableBeanFactory</li>\n<li>Bean을 Listable하게 보관하는 인터페이스를 말한다.</li>\n</ul>\n</li>\n<li>BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.\n<ul>\n<li>ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.</li>\n<li>ApplicationEventPublisher - 이벤트 발생을 관장한다.</li>\n<li>MessageSource - properties파일을 통해 다국어 설정이 가능</li>\n<li>BeanLifecycle - Bean의 초기화, 소멸을 담당한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Configuration Meta Data\n<ul>\n<li>Application Context에서 IoC 설정을 위해 사용되는 메타정보</li>\n<li>컨테이너에 어떤 기능을 세팅할때 사용</li>\n<li>Bean 생성/구성할 경우에도 사용</li>\n<li>@Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능</li>\n</ul>\n</li>\n</ul>\n<h1>Bean 등록 방법</h1>\n<h2>Component-Scan</h2>\n<p>Spring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.<br>\nSpring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.<br>\n분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에<br>\n불필요한 메모리 할당이 이루어질 수 있다.<br>\n그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 <code>가장 많이 하는 설정</code>이 아닐까 싶다.</p>\n<ul>\n<li>@Component 종류\n<ul>\n<li>@Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)</li>\n<li>@Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)</li>\n<li>@Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)</li>\n<li>@Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)</li>\n</ul>\n</li>\n</ul>\n<h2>Servlet-Context.xml</h2>\n<p>기존 Bean 생성을 xml로 등록하는 방식이다.<br>\n이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만…<br>\n보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.<br>\n위에서 언급한 <code>Component-scan</code>을 주로 사용하는 것이 좋다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"beanNameViewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.BeanNameViewResolver\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"order\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"internalResourceViewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/WEB-INF/views/\"</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"order\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"2\"</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2>@Configuration</h2>\n<p>xml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.<br>\n뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.<br>\nBean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 <code>@Bean</code> 어노테이션을 붙여주면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserService <span class=\"title\">userService</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//메소드 명이 기본적으로 Bean Name으로 추가된다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserService();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우<br>\n아주 유용한 방법이라 할 수 있겠다.</p>\n<h1>Bean 생명주기</h1>\n<p>Spring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.<br>\nBean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.</p>\n<p>Bean 생명주기 처리를 하는 방법은 3가지 방식이 있다.</p>\n<ol>\n<li>InitializingBean, DisposableBean 인터페이스 구현</li>\n<li>Bean정의 시 , 메소드 지정</li>\n<li>@PostConstruct, @PreDestroy Annotation 사용</li>\n</ol>\n<h2>InitializingBean, DisposableBean 인터페이스 구현</h2>\n<p>InitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시<br>\n기능을 확장 할 수 있다.</p>\n<p>InitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에<br>\nSpring에 종속적이게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBeanClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span>, <span class=\"title\">DisposableBean</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection conn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//자원의 할당 처리</span></span><br><span class=\"line\">        conn = DBConnectionCaller.getConnection();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 생성 및 초기화 : afterPropertiesSet() 호출됨\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//주로 할당된 자원의 해제를 한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) conn.close();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 소멸 : destroy 호출됨\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Bean정의 시 , 메소드 지정</h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.TestBeanClass\"</span>                      </span></span><br><span class=\"line\"><span class=\"tag\">   <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"destroy\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>xml설정 파일 <bean>에서 <strong>init-method</strong> 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출</bean></li>\n<li>xml설정 파일 <bean>에서 <strong>destroy-method</strong> 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출</bean></li>\n</ul>\n<h2>@PostConstruct, @PreDestroy Annotation 사용</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBeanClass</span> </span>&#123;be</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection conn;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//자원의 할당 처리</span></span><br><span class=\"line\">        conn = DBConnectionCaller.getConnection();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 생성 및 초기화\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//주로 할당된 자원의 해제를 한다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) conn.close();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"bean 소멸\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@PostConstuct, @PreDestroy 은 <code>JSR-250 Annotation</code> 기반이다 (한마디로 자바기반)<br>\n따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.</p>\n<p>@PostConstuct, @PreDestroy 을 사용하기 위해서는<br>\n<code>&lt;annotation-config/&gt;</code>설정이나, <code>@AnnotationDrivenConfig</code>어노테이션을 붙여줘야 한다.</p>\n<h1>Bean Scope</h1>\n<p><a href=\"https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html</a> 을 참고함</p>\n<ul>\n<li>Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.</li>\n<li>Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.</li>\n<li>Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용</li>\n<li>Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.<br>\n(이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)</li>\n<li>Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다.</li>\n</ul>\n<h1>참조</h1>\n<p><a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring프레임워크소개와IoC및SpringIoC의개념-2.1IoC란무엇인가%3F</a><br>\n<a href=\"http://wiki.javajigi.net/pages/viewpage.action?pageId=281\" target=\"_blank\" rel=\"noopener\">http://wiki.javajigi.net/pages/viewpage.action?pageId=281</a><br>\n<a href=\"https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/</a><br>\n<a href=\"https://okky.kr/article/415474\" target=\"_blank\" rel=\"noopener\">https://okky.kr/article/415474</a><br>\n<a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=68\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=68</a><br>\n<a href=\"http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1</a><br>\n<a href=\"http://isstory83.tistory.com/91\" target=\"_blank\" rel=\"noopener\">http://isstory83.tistory.com/91</a><br>\n<a href=\"https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3\" target=\"_blank\" rel=\"noopener\">https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3</a><br>\n토비의 스프링 VOL.2 Spring IoC</p>\n"},{"title":"Spring IoC & DI(1) - IoC 등장배경(과정)","subtitle":"IoC/DI의 발전과정","header-img":null,"catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-09-12-spring-ioc","typora-copy-images-to":"./2018-09-12-spring-ioc","date":"2018-09-21T14:33:21.000Z","_content":"\n\n\n# IoC 등장배경\n\nIoC의 등장배경을 알기 위해서는 EJB나 Spring과 같은 프레임워크를 사용하기 이전 시대의 개발 방식에 대해 얘기를 해야한다.\n온고지신(?)이라 하였던가.. IoC를 이해하기 위해 옛날이야기를 해보도록 하겠다.\n\n태초에 Java로 만든 프로그램은 main()이라는 메소드에서 시작이 되었다.\nmain() 메소드 내에서 필요한 클래스를 개발자가 직접 코드내에서 생성하여 사용하였다. \n어떠한 프로그램을 만들던지 간에 프로그램에는 `모델(Model)`이라는 개념이 생겨나게 된다.\n이렇게 만들어진 클래스 간에서는 `관계(Relation)`과 `의존성(Dependency)`가 생기게 된다. \n\n`의존성이란?` A클래스에서 B클래스의 기능을 사용할 때 클래스A는 클래스B에 의존적이다 라고 하며\nA --> B 라고 표현한다 (UML에서는 클래스 간의 Dependency를 점선으로 표현한다.)\n즉, B클래스의 기능이 변하게 되면 A클래스에도 영향이 생긴다는 말로 직역할 수 있다.\n\n이해를 돕기위해 급식을 받는 학생에 대한 예제를 들어보겠다.\n(이 학교는 아침/점심/저녁을 다 주는 좋은 학교이다)\n\n\n\n## 클래스 -> 클래스 호출 관계\n\n![image-20180921143924788](./image-20180921143924788.png)\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eatBreakfast();\n        restaurant.eatLunch();\n        restaurant.eatDinner();\n\t}\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eatBreakfast() {\n        Breakfast breakfast = new Breakfast();\n        System.out.println(breakfast.getInfo() + \"을 먹었습니다.\");\n    }\n    \n    public void eatLunch() {\n        Lunch lunch = new Lunch();\n        System.out.println(lunch.getInfo() + \"을 먹었습니다.\");\n    }\n    \n    public void eatDinner() {\n        Dinner dinner = new Dinner();\n        System.out.println(dinner.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\nStudent 클래스는 밥을 먹기위해 Restaurant클래스를 new로 생성하였다.\nRestaurant클래스 내에서는 아침/점심/저녁을 먹을 수 있도록 각각 Breakfast, Lunch, Dinner클래스를 new로 생성하였다.\n위의 의존성에 대해 위 예제를 풀어보면 Student는 Restaurant에 대해 의존적이다. (Student ---> Restaurant)\nStudent클래스에서 Restaurant클래스를 생성하여 밥을 먹기 때문이다. 만약에 Restaurant 클래스에서 밥을 못먹게 하면\nStudent클래스는 정상적으로 밥을 먹는 기능을 수행할 수 없다.\nRestaurant클래스는 Breakfast/Lunch/Dinner에 대해 의존적이다.\n각각의 메소드에서 Breakfast/Lunch/Dinner클래스를 생성하여 밥을 먹는 행위를 하도록 하고있다.\n\n가만히 보게 되면 의존성에 대한 공통점을 발견할 수 있다.\n그것은 바로 `new`이다. `클래스 내에서의 new는 곧 의존성을 의미`하게 된다. new로 생성한 클래스가 문제가 생기면 사용을 하는 클래스의 기능에도 문제가 생기기 떄문이다.\n\n따라서 **프로그래밍의 의존성은 new이다** 로 간단하게 정의를 내릴 수 있겠다.\n\n\n\n## 클래스 -> 인터페이스(interface) -> 클래스 구조\n\n클래스 내에서 클래스를 생성하여 호출 하는 경우에는 변경에 많은 비용이 발생하게 된다.\n만약에 학교에서 야식까지 먹어가며 밤을 새는 경우에는 야식이라는 의존성을 또 추가하게 된다.\n뿐만 아니라 Breakfast/Lunch/Dinner 클래스에 변경이 생기는 경우에도 Restaurant 클래스는 영향을 받게 된다.\n\n이와 같은 문제를 쪼금 더 편하게 해결 할 수 있게 Java에서는 interface라는게 있다.\n(개인적으로 Service나 Repository 같은 클래스들을 생성 할 때 웬만하면 interface를 선언하는 편이다.)\n\n차후에 Mock객체 생성하기도 좋고, 요구사항이 변경 되었을 때 유연하게 대응 할 수 있어 개인적으로는 Interface를 자주 사용하는 편이다.\n\nBreakfast/Lunch/Dinner클래스를 자세히 보면… getInfo() 메소드가 공통적으로 쓰이고 있다.\n(getInfo메소드는 식단에 대한 정보이다.)\n따라서 하나의 interface로 Breakfast/Lunch/Dinner클래스를 추상화 할 수 있다.\n그렇게 되면 eat이라는 메소드 하나만으로도 아침~저녁을 먹을 수 있는 기능을 구현할 수 있다.\n위에서 말로 한 얘기를 코드로 풀어보면..\n\n![image-20180921145310488](./image-20180921145310488.png)\n\n\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eat(new Breakfast());\n        restaurant.eat(new Lunch());\n        restaurant.eat(new Dinner());\n\t}\n}\n~~~\n\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\n위의 클래스 -> 클래스 간의 Dependency 구조보다는 interface를 사용하므로써 많이 결합도가 완화된 모습이다.\n이전에는 Restaurant 클래스가 Break/Lunch/Dinner에 대해 모두 Dependency를 가지고 가는 구조여서 결합도가 강한 형태였는데, interface를 사용하여 결합도를 많이 약화 시켰다.\n\n자세히 보면 `Student클래스에서 Break/Lunch/Dinner를 생성하여 Restaurant에 주입`해 주었다.\n이러한 모습이 향후 DI의 개념과 비슷한 개념으로 발전하게 된다.\nRestaurant입장에서는 개발자가 생성한 객체가 아닌 `외부로 부터 주입받은 형태`로 Break/Lunch/Dinner에 대해 사용을 하기 때문이다.\n이 부분을 잘 이해하면 차후 IoC와 DI를 이해하는데 크게 도움이 된다.\n\n\n\n## 클래스 -> 팩토리(factory) 패턴\n\n디자인 패턴 중에는 팩토리(Factory) 패턴이라는 구현 방식이 있다.\n팩토리 패턴에 대해 간단하게 설명하자면, 객체의 상태(State) 또는 구분자(Type)을 통해 필요한 객체를 Return 해주는 패턴이다. 위에서 설명한 클래스 -> 인터페이스 방식을 차용하여 한 단계 더 Wrapping한 개념이라고 생각하면 편하다.\n팩토리 패턴을 이용하면 아예 `개발자에게 객체 생성에 대한 권한을 주지 않겠다! `를 구현 할 수 있게 된다.\n**개발자가 객체 생성을 직접 하지 않고도 시스템에 요청하여 원하는 객체를 얻어낼 수 있다.** <-- 이 내용은 DL(Dependency Lookup)과 비슷한 개념으로 통할 수 있을 것 같다.\n\n팩토리 패턴으로 만든 코드를 만들게 된다면, 아래와 같이 만들 수 있을 것이다.\n\n![image-20180921153027741](./image-20180921153027741.png)\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eat(EatFactory.get(Meal.BREAKFAST));\n        restaurant.eat(EatFactory.get(Meal.LUNCH));\n        restaurant.eat(EatFactory.get(Meal.DINNER));\n\t}\n}\n~~~\n~~~java\npublic enum Meal {\n   BREAKFAST, LUNCH, DINNER;\n}\n~~~\n~~~java\npublic class EatFactory() {\n    public static Eatable get(Meal meal) {\n        switch(meal) {\n            case BREAKFAST : return new Breakfast();\n            case LUNCH : return new Lunch();\n            case DINNER : return new Dinner();\n            default: throw new IllegalArgumentException(\"Not using Meal Type\");\n        }\n    }\n}\n~~~\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\n\n\n이제 개발자가 개발하는 코드에서 Breakfast/Lunch/Dinner에 대한 Dependency는 완전히 제거 되었다.\n야식이라는 식사 메뉴가 추가되어도 Meal enum에 야식 항목을 추가하고, EatFactory에 야식에 대한 case만 추가 해 주면 \nStudent 클래스는 유연하게 추가된 기능에 대해 대처가 가능하다.\n\n\n\n## IoC 패턴\n\nIoC패턴을 알기 전에 IoC에 대해 간단히 설명하자면.. \n기능을 담당하는 POJO class를 프로그램 시작 시, IoC 컨테이너에 Bean이라는 이름으로 객체를 생성해 둔다.\n이렇게 싱글톤으로 생성된 객체들을 필요한 시점에 IoC 컨테이너에서 의존성을 가지는 객체에 직접 주입을 해주는 패턴을 IoC패턴이라 한다.\n\n쉽게 말하면 객체의 멤버에 대한 상태가 없고(stateless) 기능의 역할을 담은 클래스들을 1개씩 IoC컨테이너라는 상자에 담아두고, 의존성 객체가 필요한 경우 IoC컨테이너에서 필요한 객체를 주입해준다. 라고 생각하면 편할 것 같다.\n객체에 대해 new 생성자를 통해 객체를 생성할 필요가 없으니, 메모리적인 낭비가 없다는 장점이 있을 뿐 더러 개발자에게 객체 관리에 대한 미시적인 역할을 맡기지 않아도 되는 장점이 있다. 자세한 내용은 다음 장에 기술하도록 하겠다.\n\n위의 내용을 Spring을 사용한 개발이라고 한다면... 아래와 같이 코드를 짤 수 있겠다.\n\n~~~java\n@SpringBootApplication(scanBasePackages = \"com.example.ioc\")\npublic class Student {\n    \n    @Autowired\n    private Restaurant restaurant;\n    @Autowired\n    private EatFactory eatFactory;\n    \n    public static void main(String[] args) {\n        \n\t\tSpringApplication.run(SpringStudyApplication.class, args);\n        //식사 시작\n        restaurant.eat(eatFactory.get(Meal.BREAKFAST));\n        restaurant.eat(eatFactory.get(Meal.LUNCH));\n        restaurant.eat(eatFactory.get(Meal.DINNER));\n\t}\n}\n~~~\n~~~java\npublic enum Meal {\n   BREAKFAST, LUNCH, DINNER;\n}\n~~~\n~~~java\n@Component\npublic class EatFactory() {\n\t\n    @Autowired @Qualifier(\"breakfast\")\n    private Eatable breakfast;\n    @Autowired @Qualifier(\"lunch\")\n    private Eatable lunch;\n    @Autowired @Qualifier(\"dinner\")\n    private Eatable dinner;\n    \n    public Eatable get(Meal meal) {\n        switch(meal) {\n            case BREAKFAST : breakfast;\n            case LUNCH : lunch;\n            case DINNER : dinner;\n            default: throw new IllegalArgumentException(\"Not using Meal Type\");\n        }\n    }\n}\n~~~\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\n@Service\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\nSpring에서는 component-scan이라는 기능을 통해 @Component 어노테이션이 붙은 클래스는 IoC 컨테이너에 Bean으로써 자동 등록 해준다. 이러한 Bean은 @Autowired / @Inject 와 같은 어노테이션을 통해 클래스에 주입을 해줄 수 있다.\n이렇게 되면 개발자가 new를 통해 의존성을 강제화 하지 않고 프레임워크가 이 역할을 대신 수행해 준다.\n\n개발자가 객체 생성과 의존성 주입에 대한 역할을 대신 해준다 \nInversion of Control (객체 관리과 의존성 관리를 시스템에서 해준다 : 제어의 역전) 이라고 불리게 되었다.\n\n\n\n# 참조\n\nhttp://www.javajigi.net/pages/viewpage.action?pageId=3664&focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\n토비의 스프링 VOL.2 Spring IoC","source":"_posts/2018-09-12-spring-ioc.md","raw":"---\ntitle: Spring IoC & DI(1) - IoC 등장배경(과정)\nsubtitle: IoC/DI의 발전과정\nheader-img:\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\ntypora-root-url: ./2018-09-12-spring-ioc\ntypora-copy-images-to: ./2018-09-12-spring-ioc\ndate: 2018-09-21 23:33:21\n---\n\n\n\n# IoC 등장배경\n\nIoC의 등장배경을 알기 위해서는 EJB나 Spring과 같은 프레임워크를 사용하기 이전 시대의 개발 방식에 대해 얘기를 해야한다.\n온고지신(?)이라 하였던가.. IoC를 이해하기 위해 옛날이야기를 해보도록 하겠다.\n\n태초에 Java로 만든 프로그램은 main()이라는 메소드에서 시작이 되었다.\nmain() 메소드 내에서 필요한 클래스를 개발자가 직접 코드내에서 생성하여 사용하였다. \n어떠한 프로그램을 만들던지 간에 프로그램에는 `모델(Model)`이라는 개념이 생겨나게 된다.\n이렇게 만들어진 클래스 간에서는 `관계(Relation)`과 `의존성(Dependency)`가 생기게 된다. \n\n`의존성이란?` A클래스에서 B클래스의 기능을 사용할 때 클래스A는 클래스B에 의존적이다 라고 하며\nA --> B 라고 표현한다 (UML에서는 클래스 간의 Dependency를 점선으로 표현한다.)\n즉, B클래스의 기능이 변하게 되면 A클래스에도 영향이 생긴다는 말로 직역할 수 있다.\n\n이해를 돕기위해 급식을 받는 학생에 대한 예제를 들어보겠다.\n(이 학교는 아침/점심/저녁을 다 주는 좋은 학교이다)\n\n\n\n## 클래스 -> 클래스 호출 관계\n\n![image-20180921143924788](./image-20180921143924788.png)\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eatBreakfast();\n        restaurant.eatLunch();\n        restaurant.eatDinner();\n\t}\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eatBreakfast() {\n        Breakfast breakfast = new Breakfast();\n        System.out.println(breakfast.getInfo() + \"을 먹었습니다.\");\n    }\n    \n    public void eatLunch() {\n        Lunch lunch = new Lunch();\n        System.out.println(lunch.getInfo() + \"을 먹었습니다.\");\n    }\n    \n    public void eatDinner() {\n        Dinner dinner = new Dinner();\n        System.out.println(dinner.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\nStudent 클래스는 밥을 먹기위해 Restaurant클래스를 new로 생성하였다.\nRestaurant클래스 내에서는 아침/점심/저녁을 먹을 수 있도록 각각 Breakfast, Lunch, Dinner클래스를 new로 생성하였다.\n위의 의존성에 대해 위 예제를 풀어보면 Student는 Restaurant에 대해 의존적이다. (Student ---> Restaurant)\nStudent클래스에서 Restaurant클래스를 생성하여 밥을 먹기 때문이다. 만약에 Restaurant 클래스에서 밥을 못먹게 하면\nStudent클래스는 정상적으로 밥을 먹는 기능을 수행할 수 없다.\nRestaurant클래스는 Breakfast/Lunch/Dinner에 대해 의존적이다.\n각각의 메소드에서 Breakfast/Lunch/Dinner클래스를 생성하여 밥을 먹는 행위를 하도록 하고있다.\n\n가만히 보게 되면 의존성에 대한 공통점을 발견할 수 있다.\n그것은 바로 `new`이다. `클래스 내에서의 new는 곧 의존성을 의미`하게 된다. new로 생성한 클래스가 문제가 생기면 사용을 하는 클래스의 기능에도 문제가 생기기 떄문이다.\n\n따라서 **프로그래밍의 의존성은 new이다** 로 간단하게 정의를 내릴 수 있겠다.\n\n\n\n## 클래스 -> 인터페이스(interface) -> 클래스 구조\n\n클래스 내에서 클래스를 생성하여 호출 하는 경우에는 변경에 많은 비용이 발생하게 된다.\n만약에 학교에서 야식까지 먹어가며 밤을 새는 경우에는 야식이라는 의존성을 또 추가하게 된다.\n뿐만 아니라 Breakfast/Lunch/Dinner 클래스에 변경이 생기는 경우에도 Restaurant 클래스는 영향을 받게 된다.\n\n이와 같은 문제를 쪼금 더 편하게 해결 할 수 있게 Java에서는 interface라는게 있다.\n(개인적으로 Service나 Repository 같은 클래스들을 생성 할 때 웬만하면 interface를 선언하는 편이다.)\n\n차후에 Mock객체 생성하기도 좋고, 요구사항이 변경 되었을 때 유연하게 대응 할 수 있어 개인적으로는 Interface를 자주 사용하는 편이다.\n\nBreakfast/Lunch/Dinner클래스를 자세히 보면… getInfo() 메소드가 공통적으로 쓰이고 있다.\n(getInfo메소드는 식단에 대한 정보이다.)\n따라서 하나의 interface로 Breakfast/Lunch/Dinner클래스를 추상화 할 수 있다.\n그렇게 되면 eat이라는 메소드 하나만으로도 아침~저녁을 먹을 수 있는 기능을 구현할 수 있다.\n위에서 말로 한 얘기를 코드로 풀어보면..\n\n![image-20180921145310488](./image-20180921145310488.png)\n\n\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eat(new Breakfast());\n        restaurant.eat(new Lunch());\n        restaurant.eat(new Dinner());\n\t}\n}\n~~~\n\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\n위의 클래스 -> 클래스 간의 Dependency 구조보다는 interface를 사용하므로써 많이 결합도가 완화된 모습이다.\n이전에는 Restaurant 클래스가 Break/Lunch/Dinner에 대해 모두 Dependency를 가지고 가는 구조여서 결합도가 강한 형태였는데, interface를 사용하여 결합도를 많이 약화 시켰다.\n\n자세히 보면 `Student클래스에서 Break/Lunch/Dinner를 생성하여 Restaurant에 주입`해 주었다.\n이러한 모습이 향후 DI의 개념과 비슷한 개념으로 발전하게 된다.\nRestaurant입장에서는 개발자가 생성한 객체가 아닌 `외부로 부터 주입받은 형태`로 Break/Lunch/Dinner에 대해 사용을 하기 때문이다.\n이 부분을 잘 이해하면 차후 IoC와 DI를 이해하는데 크게 도움이 된다.\n\n\n\n## 클래스 -> 팩토리(factory) 패턴\n\n디자인 패턴 중에는 팩토리(Factory) 패턴이라는 구현 방식이 있다.\n팩토리 패턴에 대해 간단하게 설명하자면, 객체의 상태(State) 또는 구분자(Type)을 통해 필요한 객체를 Return 해주는 패턴이다. 위에서 설명한 클래스 -> 인터페이스 방식을 차용하여 한 단계 더 Wrapping한 개념이라고 생각하면 편하다.\n팩토리 패턴을 이용하면 아예 `개발자에게 객체 생성에 대한 권한을 주지 않겠다! `를 구현 할 수 있게 된다.\n**개발자가 객체 생성을 직접 하지 않고도 시스템에 요청하여 원하는 객체를 얻어낼 수 있다.** <-- 이 내용은 DL(Dependency Lookup)과 비슷한 개념으로 통할 수 있을 것 같다.\n\n팩토리 패턴으로 만든 코드를 만들게 된다면, 아래와 같이 만들 수 있을 것이다.\n\n![image-20180921153027741](./image-20180921153027741.png)\n\n~~~java\npublic class Student {\n    public static void main(String[] args) {\n\t\t\n        Restaurant restaurant = new Restaurant();\n        //식사 시작\n        restaurant.eat(EatFactory.get(Meal.BREAKFAST));\n        restaurant.eat(EatFactory.get(Meal.LUNCH));\n        restaurant.eat(EatFactory.get(Meal.DINNER));\n\t}\n}\n~~~\n~~~java\npublic enum Meal {\n   BREAKFAST, LUNCH, DINNER;\n}\n~~~\n~~~java\npublic class EatFactory() {\n    public static Eatable get(Meal meal) {\n        switch(meal) {\n            case BREAKFAST : return new Breakfast();\n            case LUNCH : return new Lunch();\n            case DINNER : return new Dinner();\n            default: throw new IllegalArgumentException(\"Not using Meal Type\");\n        }\n    }\n}\n~~~\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\n\n\n이제 개발자가 개발하는 코드에서 Breakfast/Lunch/Dinner에 대한 Dependency는 완전히 제거 되었다.\n야식이라는 식사 메뉴가 추가되어도 Meal enum에 야식 항목을 추가하고, EatFactory에 야식에 대한 case만 추가 해 주면 \nStudent 클래스는 유연하게 추가된 기능에 대해 대처가 가능하다.\n\n\n\n## IoC 패턴\n\nIoC패턴을 알기 전에 IoC에 대해 간단히 설명하자면.. \n기능을 담당하는 POJO class를 프로그램 시작 시, IoC 컨테이너에 Bean이라는 이름으로 객체를 생성해 둔다.\n이렇게 싱글톤으로 생성된 객체들을 필요한 시점에 IoC 컨테이너에서 의존성을 가지는 객체에 직접 주입을 해주는 패턴을 IoC패턴이라 한다.\n\n쉽게 말하면 객체의 멤버에 대한 상태가 없고(stateless) 기능의 역할을 담은 클래스들을 1개씩 IoC컨테이너라는 상자에 담아두고, 의존성 객체가 필요한 경우 IoC컨테이너에서 필요한 객체를 주입해준다. 라고 생각하면 편할 것 같다.\n객체에 대해 new 생성자를 통해 객체를 생성할 필요가 없으니, 메모리적인 낭비가 없다는 장점이 있을 뿐 더러 개발자에게 객체 관리에 대한 미시적인 역할을 맡기지 않아도 되는 장점이 있다. 자세한 내용은 다음 장에 기술하도록 하겠다.\n\n위의 내용을 Spring을 사용한 개발이라고 한다면... 아래와 같이 코드를 짤 수 있겠다.\n\n~~~java\n@SpringBootApplication(scanBasePackages = \"com.example.ioc\")\npublic class Student {\n    \n    @Autowired\n    private Restaurant restaurant;\n    @Autowired\n    private EatFactory eatFactory;\n    \n    public static void main(String[] args) {\n        \n\t\tSpringApplication.run(SpringStudyApplication.class, args);\n        //식사 시작\n        restaurant.eat(eatFactory.get(Meal.BREAKFAST));\n        restaurant.eat(eatFactory.get(Meal.LUNCH));\n        restaurant.eat(eatFactory.get(Meal.DINNER));\n\t}\n}\n~~~\n~~~java\npublic enum Meal {\n   BREAKFAST, LUNCH, DINNER;\n}\n~~~\n~~~java\n@Component\npublic class EatFactory() {\n\t\n    @Autowired @Qualifier(\"breakfast\")\n    private Eatable breakfast;\n    @Autowired @Qualifier(\"lunch\")\n    private Eatable lunch;\n    @Autowired @Qualifier(\"dinner\")\n    private Eatable dinner;\n    \n    public Eatable get(Meal meal) {\n        switch(meal) {\n            case BREAKFAST : breakfast;\n            case LUNCH : lunch;\n            case DINNER : dinner;\n            default: throw new IllegalArgumentException(\"Not using Meal Type\");\n        }\n    }\n}\n~~~\n~~~java\npublic interface Eatable() {\n\tString getInfo();\n}\n~~~\n\n~~~java\n@Service\npublic class Restaurant {\n    \n    public void eat(Eatable eatable) {\n        System.out.println(eatable.getInfo() + \"을 먹었습니다.\");\n    }\n}\n~~~\n\nSpring에서는 component-scan이라는 기능을 통해 @Component 어노테이션이 붙은 클래스는 IoC 컨테이너에 Bean으로써 자동 등록 해준다. 이러한 Bean은 @Autowired / @Inject 와 같은 어노테이션을 통해 클래스에 주입을 해줄 수 있다.\n이렇게 되면 개발자가 new를 통해 의존성을 강제화 하지 않고 프레임워크가 이 역할을 대신 수행해 준다.\n\n개발자가 객체 생성과 의존성 주입에 대한 역할을 대신 해준다 \nInversion of Control (객체 관리과 의존성 관리를 시스템에서 해준다 : 제어의 역전) 이라고 불리게 되었다.\n\n\n\n# 참조\n\nhttp://www.javajigi.net/pages/viewpage.action?pageId=3664&focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\nhttp://wiki.javajigi.net/pages/viewpage.action?pageId=281\nhttps://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\nhttps://okky.kr/article/415474\nhttp://www.javajigi.net/pages/viewpage.action?pageId=68\nhttp://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\nhttp://isstory83.tistory.com/91\n토비의 스프링 VOL.2 Spring IoC","slug":"2018-09-12-spring-ioc","published":1,"updated":"2018-11-27T07:23:32.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp55h5ib001a4f1to44qqx0c","content":"<h1><span id=\"ioc-등장배경\">IoC 등장배경</span></h1>\n<p>IoC의 등장배경을 알기 위해서는 EJB나 Spring과 같은 프레임워크를 사용하기 이전 시대의 개발 방식에 대해 얘기를 해야한다.<br>\n온고지신(?)이라 하였던가… IoC를 이해하기 위해 옛날이야기를 해보도록 하겠다.</p>\n<p>태초에 Java로 만든 프로그램은 main()이라는 메소드에서 시작이 되었다.<br>\nmain() 메소드 내에서 필요한 클래스를 개발자가 직접 코드내에서 생성하여 사용하였다.<br>\n어떠한 프로그램을 만들던지 간에 프로그램에는 <code>모델(Model)</code>이라는 개념이 생겨나게 된다.<br>\n이렇게 만들어진 클래스 간에서는 <code>관계(Relation)</code>과 <code>의존성(Dependency)</code>가 생기게 된다.</p>\n<p><code>의존성이란?</code> A클래스에서 B클래스의 기능을 사용할 때 클래스A는 클래스B에 의존적이다 라고 하며<br>\nA --&gt; B 라고 표현한다 (UML에서는 클래스 간의 Dependency를 점선으로 표현한다.)<br>\n즉, B클래스의 기능이 변하게 되면 A클래스에도 영향이 생긴다는 말로 직역할 수 있다.</p>\n<p>이해를 돕기위해 급식을 받는 학생에 대한 예제를 들어보겠다.<br>\n(이 학교는 아침/점심/저녁을 다 주는 좋은 학교이다)</p>\n<h2><span id=\"클래스-gt-클래스-호출-관계\">클래스 -&gt; 클래스 호출 관계</span></h2>\n<p><img src=\"./image-20180921143924788.png\" alt=\"image-20180921143924788\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eatBreakfast();</span><br><span class=\"line\">        restaurant.eatLunch();</span><br><span class=\"line\">        restaurant.eatDinner();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatBreakfast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Breakfast breakfast = <span class=\"keyword\">new</span> Breakfast();</span><br><span class=\"line\">        System.out.println(breakfast.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatLunch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Lunch lunch = <span class=\"keyword\">new</span> Lunch();</span><br><span class=\"line\">        System.out.println(lunch.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatDinner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Dinner dinner = <span class=\"keyword\">new</span> Dinner();</span><br><span class=\"line\">        System.out.println(dinner.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Student 클래스는 밥을 먹기위해 Restaurant클래스를 new로 생성하였다.<br>\nRestaurant클래스 내에서는 아침/점심/저녁을 먹을 수 있도록 각각 Breakfast, Lunch, Dinner클래스를 new로 생성하였다.<br>\n위의 의존성에 대해 위 예제를 풀어보면 Student는 Restaurant에 대해 의존적이다. (Student —&gt; Restaurant)<br>\nStudent클래스에서 Restaurant클래스를 생성하여 밥을 먹기 때문이다. 만약에 Restaurant 클래스에서 밥을 못먹게 하면<br>\nStudent클래스는 정상적으로 밥을 먹는 기능을 수행할 수 없다.<br>\nRestaurant클래스는 Breakfast/Lunch/Dinner에 대해 의존적이다.<br>\n각각의 메소드에서 Breakfast/Lunch/Dinner클래스를 생성하여 밥을 먹는 행위를 하도록 하고있다.</p>\n<p>가만히 보게 되면 의존성에 대한 공통점을 발견할 수 있다.<br>\n그것은 바로 <code>new</code>이다. <code>클래스 내에서의 new는 곧 의존성을 의미</code>하게 된다. new로 생성한 클래스가 문제가 생기면 사용을 하는 클래스의 기능에도 문제가 생기기 떄문이다.</p>\n<p>따라서 <strong>프로그래밍의 의존성은 new이다</strong> 로 간단하게 정의를 내릴 수 있겠다.</p>\n<h2><span id=\"클래스-gt-인터페이스interface-gt-클래스-구조\">클래스 -&gt; 인터페이스(interface) -&gt; 클래스 구조</span></h2>\n<p>클래스 내에서 클래스를 생성하여 호출 하는 경우에는 변경에 많은 비용이 발생하게 된다.<br>\n만약에 학교에서 야식까지 먹어가며 밤을 새는 경우에는 야식이라는 의존성을 또 추가하게 된다.<br>\n뿐만 아니라 Breakfast/Lunch/Dinner 클래스에 변경이 생기는 경우에도 Restaurant 클래스는 영향을 받게 된다.</p>\n<p>이와 같은 문제를 쪼금 더 편하게 해결 할 수 있게 Java에서는 interface라는게 있다.<br>\n(개인적으로 Service나 Repository 같은 클래스들을 생성 할 때 웬만하면 interface를 선언하는 편이다.)</p>\n<p>차후에 Mock객체 생성하기도 좋고, 요구사항이 변경 되었을 때 유연하게 대응 할 수 있어 개인적으로는 Interface를 자주 사용하는 편이다.</p>\n<p>Breakfast/Lunch/Dinner클래스를 자세히 보면… getInfo() 메소드가 공통적으로 쓰이고 있다.<br>\n(getInfo메소드는 식단에 대한 정보이다.)<br>\n따라서 하나의 interface로 Breakfast/Lunch/Dinner클래스를 추상화 할 수 있다.<br>\n그렇게 되면 eat이라는 메소드 하나만으로도 아침~저녁을 먹을 수 있는 기능을 구현할 수 있다.<br>\n위에서 말로 한 얘기를 코드로 풀어보면…</p>\n<p><img src=\"./image-20180921145310488.png\" alt=\"image-20180921145310488\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Breakfast());</span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Lunch());</span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Dinner());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 클래스 -&gt; 클래스 간의 Dependency 구조보다는 interface를 사용하므로써 많이 결합도가 완화된 모습이다.<br>\n이전에는 Restaurant 클래스가 Break/Lunch/Dinner에 대해 모두 Dependency를 가지고 가는 구조여서 결합도가 강한 형태였는데, interface를 사용하여 결합도를 많이 약화 시켰다.</p>\n<p>자세히 보면 <code>Student클래스에서 Break/Lunch/Dinner를 생성하여 Restaurant에 주입</code>해 주었다.<br>\n이러한 모습이 향후 DI의 개념과 비슷한 개념으로 발전하게 된다.<br>\nRestaurant입장에서는 개발자가 생성한 객체가 아닌 <code>외부로 부터 주입받은 형태</code>로 Break/Lunch/Dinner에 대해 사용을 하기 때문이다.<br>\n이 부분을 잘 이해하면 차후 IoC와 DI를 이해하는데 크게 도움이 된다.</p>\n<h2><span id=\"클래스-gt-팩토리factory-패턴\">클래스 -&gt; 팩토리(factory) 패턴</span></h2>\n<p>디자인 패턴 중에는 팩토리(Factory) 패턴이라는 구현 방식이 있다.<br>\n팩토리 패턴에 대해 간단하게 설명하자면, 객체의 상태(State) 또는 구분자(Type)을 통해 필요한 객체를 Return 해주는 패턴이다. 위에서 설명한 클래스 -&gt; 인터페이스 방식을 차용하여 한 단계 더 Wrapping한 개념이라고 생각하면 편하다.<br>\n팩토리 패턴을 이용하면 아예 <code>개발자에게 객체 생성에 대한 권한을 주지 않겠다!</code>를 구현 할 수 있게 된다.<br>\n<strong>개발자가 객체 생성을 직접 하지 않고도 시스템에 요청하여 원하는 객체를 얻어낼 수 있다.</strong> &lt;-- 이 내용은 DL(Dependency Lookup)과 비슷한 개념으로 통할 수 있을 것 같다.</p>\n<p>팩토리 패턴으로 만든 코드를 만들게 된다면, 아래와 같이 만들 수 있을 것이다.</p>\n<p><img src=\"./image-20180921153027741.png\" alt=\"image-20180921153027741\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.BREAKFAST));</span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.LUNCH));</span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.DINNER));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Meal &#123;</span><br><span class=\"line\">   BREAKFAST, LUNCH, DINNER;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">EatFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Eatable <span class=\"title\">get</span><span class=\"params\">(Meal meal)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(meal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BREAKFAST : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Breakfast();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LUNCH : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Lunch();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> DINNER : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Dinner();</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Not using Meal Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 개발자가 개발하는 코드에서 Breakfast/Lunch/Dinner에 대한 Dependency는 완전히 제거 되었다.<br>\n야식이라는 식사 메뉴가 추가되어도 Meal enum에 야식 항목을 추가하고, EatFactory에 야식에 대한 case만 추가 해 주면<br>\nStudent 클래스는 유연하게 추가된 기능에 대해 대처가 가능하다.</p>\n<h2><span id=\"ioc-패턴\">IoC 패턴</span></h2>\n<p>IoC패턴을 알기 전에 IoC에 대해 간단히 설명하자면…<br>\n기능을 담당하는 POJO class를 프로그램 시작 시, IoC 컨테이너에 Bean이라는 이름으로 객체를 생성해 둔다.<br>\n이렇게 싱글톤으로 생성된 객체들을 필요한 시점에 IoC 컨테이너에서 의존성을 가지는 객체에 직접 주입을 해주는 패턴을 IoC패턴이라 한다.</p>\n<p>쉽게 말하면 객체의 멤버에 대한 상태가 없고(stateless) 기능의 역할을 담은 클래스들을 1개씩 IoC컨테이너라는 상자에 담아두고, 의존성 객체가 필요한 경우 IoC컨테이너에서 필요한 객체를 주입해준다. 라고 생각하면 편할 것 같다.<br>\n객체에 대해 new 생성자를 통해 객체를 생성할 필요가 없으니, 메모리적인 낭비가 없다는 장점이 있을 뿐 더러 개발자에게 객체 관리에 대한 미시적인 역할을 맡기지 않아도 되는 장점이 있다. 자세한 내용은 다음 장에 기술하도록 하겠다.</p>\n<p>위의 내용을 Spring을 사용한 개발이라고 한다면… 아래와 같이 코드를 짤 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span>(scanBasePackages = <span class=\"string\">\"com.example.ioc\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Restaurant restaurant;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EatFactory eatFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\tSpringApplication.run(SpringStudyApplication.class, args);</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.BREAKFAST));</span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.LUNCH));</span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.DINNER));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Meal &#123;</span><br><span class=\"line\">   BREAKFAST, LUNCH, DINNER;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">EatFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"breakfast\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable breakfast;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"lunch\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable lunch;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"dinner\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable dinner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Eatable <span class=\"title\">get</span><span class=\"params\">(Meal meal)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(meal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BREAKFAST : breakfast;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LUNCH : lunch;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> DINNER : dinner;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Not using Meal Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Spring에서는 component-scan이라는 기능을 통해 @Component 어노테이션이 붙은 클래스는 IoC 컨테이너에 Bean으로써 자동 등록 해준다. 이러한 Bean은 @Autowired / @Inject 와 같은 어노테이션을 통해 클래스에 주입을 해줄 수 있다.<br>\n이렇게 되면 개발자가 new를 통해 의존성을 강제화 하지 않고 프레임워크가 이 역할을 대신 수행해 준다.</p>\n<p>개발자가 객체 생성과 의존성 주입에 대한 역할을 대신 해준다<br>\nInversion of Control (객체 관리과 의존성 관리를 시스템에서 해준다 : 제어의 역전) 이라고 불리게 되었다.</p>\n<h1><span id=\"참조\">참조</span></h1>\n<p><a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring프레임워크소개와IoC및SpringIoC의개념-2.1IoC란무엇인가%3F</a><br>\n<a href=\"http://wiki.javajigi.net/pages/viewpage.action?pageId=281\" target=\"_blank\" rel=\"noopener\">http://wiki.javajigi.net/pages/viewpage.action?pageId=281</a><br>\n<a href=\"https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/</a><br>\n<a href=\"https://okky.kr/article/415474\" target=\"_blank\" rel=\"noopener\">https://okky.kr/article/415474</a><br>\n<a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=68\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=68</a><br>\n<a href=\"http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1</a><br>\n<a href=\"http://isstory83.tistory.com/91\" target=\"_blank\" rel=\"noopener\">http://isstory83.tistory.com/91</a><br>\n토비의 스프링 VOL.2 Spring IoC</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>IoC 등장배경</h1>\n<p>IoC의 등장배경을 알기 위해서는 EJB나 Spring과 같은 프레임워크를 사용하기 이전 시대의 개발 방식에 대해 얘기를 해야한다.<br>\n온고지신(?)이라 하였던가… IoC를 이해하기 위해 옛날이야기를 해보도록 하겠다.</p>\n<p>태초에 Java로 만든 프로그램은 main()이라는 메소드에서 시작이 되었다.<br>\nmain() 메소드 내에서 필요한 클래스를 개발자가 직접 코드내에서 생성하여 사용하였다.<br>\n어떠한 프로그램을 만들던지 간에 프로그램에는 <code>모델(Model)</code>이라는 개념이 생겨나게 된다.<br>\n이렇게 만들어진 클래스 간에서는 <code>관계(Relation)</code>과 <code>의존성(Dependency)</code>가 생기게 된다.</p>\n<p><code>의존성이란?</code> A클래스에서 B클래스의 기능을 사용할 때 클래스A는 클래스B에 의존적이다 라고 하며<br>\nA --&gt; B 라고 표현한다 (UML에서는 클래스 간의 Dependency를 점선으로 표현한다.)<br>\n즉, B클래스의 기능이 변하게 되면 A클래스에도 영향이 생긴다는 말로 직역할 수 있다.</p>\n<p>이해를 돕기위해 급식을 받는 학생에 대한 예제를 들어보겠다.<br>\n(이 학교는 아침/점심/저녁을 다 주는 좋은 학교이다)</p>\n<h2>클래스 -&gt; 클래스 호출 관계</h2>\n<p><img src=\"./image-20180921143924788.png\" alt=\"image-20180921143924788\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eatBreakfast();</span><br><span class=\"line\">        restaurant.eatLunch();</span><br><span class=\"line\">        restaurant.eatDinner();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatBreakfast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Breakfast breakfast = <span class=\"keyword\">new</span> Breakfast();</span><br><span class=\"line\">        System.out.println(breakfast.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatLunch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Lunch lunch = <span class=\"keyword\">new</span> Lunch();</span><br><span class=\"line\">        System.out.println(lunch.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eatDinner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Dinner dinner = <span class=\"keyword\">new</span> Dinner();</span><br><span class=\"line\">        System.out.println(dinner.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Student 클래스는 밥을 먹기위해 Restaurant클래스를 new로 생성하였다.<br>\nRestaurant클래스 내에서는 아침/점심/저녁을 먹을 수 있도록 각각 Breakfast, Lunch, Dinner클래스를 new로 생성하였다.<br>\n위의 의존성에 대해 위 예제를 풀어보면 Student는 Restaurant에 대해 의존적이다. (Student —&gt; Restaurant)<br>\nStudent클래스에서 Restaurant클래스를 생성하여 밥을 먹기 때문이다. 만약에 Restaurant 클래스에서 밥을 못먹게 하면<br>\nStudent클래스는 정상적으로 밥을 먹는 기능을 수행할 수 없다.<br>\nRestaurant클래스는 Breakfast/Lunch/Dinner에 대해 의존적이다.<br>\n각각의 메소드에서 Breakfast/Lunch/Dinner클래스를 생성하여 밥을 먹는 행위를 하도록 하고있다.</p>\n<p>가만히 보게 되면 의존성에 대한 공통점을 발견할 수 있다.<br>\n그것은 바로 <code>new</code>이다. <code>클래스 내에서의 new는 곧 의존성을 의미</code>하게 된다. new로 생성한 클래스가 문제가 생기면 사용을 하는 클래스의 기능에도 문제가 생기기 떄문이다.</p>\n<p>따라서 <strong>프로그래밍의 의존성은 new이다</strong> 로 간단하게 정의를 내릴 수 있겠다.</p>\n<h2>클래스 -&gt; 인터페이스(interface) -&gt; 클래스 구조</h2>\n<p>클래스 내에서 클래스를 생성하여 호출 하는 경우에는 변경에 많은 비용이 발생하게 된다.<br>\n만약에 학교에서 야식까지 먹어가며 밤을 새는 경우에는 야식이라는 의존성을 또 추가하게 된다.<br>\n뿐만 아니라 Breakfast/Lunch/Dinner 클래스에 변경이 생기는 경우에도 Restaurant 클래스는 영향을 받게 된다.</p>\n<p>이와 같은 문제를 쪼금 더 편하게 해결 할 수 있게 Java에서는 interface라는게 있다.<br>\n(개인적으로 Service나 Repository 같은 클래스들을 생성 할 때 웬만하면 interface를 선언하는 편이다.)</p>\n<p>차후에 Mock객체 생성하기도 좋고, 요구사항이 변경 되었을 때 유연하게 대응 할 수 있어 개인적으로는 Interface를 자주 사용하는 편이다.</p>\n<p>Breakfast/Lunch/Dinner클래스를 자세히 보면… getInfo() 메소드가 공통적으로 쓰이고 있다.<br>\n(getInfo메소드는 식단에 대한 정보이다.)<br>\n따라서 하나의 interface로 Breakfast/Lunch/Dinner클래스를 추상화 할 수 있다.<br>\n그렇게 되면 eat이라는 메소드 하나만으로도 아침~저녁을 먹을 수 있는 기능을 구현할 수 있다.<br>\n위에서 말로 한 얘기를 코드로 풀어보면…</p>\n<p><img src=\"./image-20180921145310488.png\" alt=\"image-20180921145310488\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Breakfast());</span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Lunch());</span><br><span class=\"line\">        restaurant.eat(<span class=\"keyword\">new</span> Dinner());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 클래스 -&gt; 클래스 간의 Dependency 구조보다는 interface를 사용하므로써 많이 결합도가 완화된 모습이다.<br>\n이전에는 Restaurant 클래스가 Break/Lunch/Dinner에 대해 모두 Dependency를 가지고 가는 구조여서 결합도가 강한 형태였는데, interface를 사용하여 결합도를 많이 약화 시켰다.</p>\n<p>자세히 보면 <code>Student클래스에서 Break/Lunch/Dinner를 생성하여 Restaurant에 주입</code>해 주었다.<br>\n이러한 모습이 향후 DI의 개념과 비슷한 개념으로 발전하게 된다.<br>\nRestaurant입장에서는 개발자가 생성한 객체가 아닌 <code>외부로 부터 주입받은 형태</code>로 Break/Lunch/Dinner에 대해 사용을 하기 때문이다.<br>\n이 부분을 잘 이해하면 차후 IoC와 DI를 이해하는데 크게 도움이 된다.</p>\n<h2>클래스 -&gt; 팩토리(factory) 패턴</h2>\n<p>디자인 패턴 중에는 팩토리(Factory) 패턴이라는 구현 방식이 있다.<br>\n팩토리 패턴에 대해 간단하게 설명하자면, 객체의 상태(State) 또는 구분자(Type)을 통해 필요한 객체를 Return 해주는 패턴이다. 위에서 설명한 클래스 -&gt; 인터페이스 방식을 차용하여 한 단계 더 Wrapping한 개념이라고 생각하면 편하다.<br>\n팩토리 패턴을 이용하면 아예 <code>개발자에게 객체 생성에 대한 권한을 주지 않겠다!</code>를 구현 할 수 있게 된다.<br>\n<strong>개발자가 객체 생성을 직접 하지 않고도 시스템에 요청하여 원하는 객체를 얻어낼 수 있다.</strong> &lt;-- 이 내용은 DL(Dependency Lookup)과 비슷한 개념으로 통할 수 있을 것 같다.</p>\n<p>팩토리 패턴으로 만든 코드를 만들게 된다면, 아래와 같이 만들 수 있을 것이다.</p>\n<p><img src=\"./image-20180921153027741.png\" alt=\"image-20180921153027741\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        Restaurant restaurant = <span class=\"keyword\">new</span> Restaurant();</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.BREAKFAST));</span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.LUNCH));</span><br><span class=\"line\">        restaurant.eat(EatFactory.get(Meal.DINNER));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Meal &#123;</span><br><span class=\"line\">   BREAKFAST, LUNCH, DINNER;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">EatFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Eatable <span class=\"title\">get</span><span class=\"params\">(Meal meal)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(meal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BREAKFAST : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Breakfast();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LUNCH : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Lunch();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> DINNER : <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Dinner();</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Not using Meal Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 개발자가 개발하는 코드에서 Breakfast/Lunch/Dinner에 대한 Dependency는 완전히 제거 되었다.<br>\n야식이라는 식사 메뉴가 추가되어도 Meal enum에 야식 항목을 추가하고, EatFactory에 야식에 대한 case만 추가 해 주면<br>\nStudent 클래스는 유연하게 추가된 기능에 대해 대처가 가능하다.</p>\n<h2>IoC 패턴</h2>\n<p>IoC패턴을 알기 전에 IoC에 대해 간단히 설명하자면…<br>\n기능을 담당하는 POJO class를 프로그램 시작 시, IoC 컨테이너에 Bean이라는 이름으로 객체를 생성해 둔다.<br>\n이렇게 싱글톤으로 생성된 객체들을 필요한 시점에 IoC 컨테이너에서 의존성을 가지는 객체에 직접 주입을 해주는 패턴을 IoC패턴이라 한다.</p>\n<p>쉽게 말하면 객체의 멤버에 대한 상태가 없고(stateless) 기능의 역할을 담은 클래스들을 1개씩 IoC컨테이너라는 상자에 담아두고, 의존성 객체가 필요한 경우 IoC컨테이너에서 필요한 객체를 주입해준다. 라고 생각하면 편할 것 같다.<br>\n객체에 대해 new 생성자를 통해 객체를 생성할 필요가 없으니, 메모리적인 낭비가 없다는 장점이 있을 뿐 더러 개발자에게 객체 관리에 대한 미시적인 역할을 맡기지 않아도 되는 장점이 있다. 자세한 내용은 다음 장에 기술하도록 하겠다.</p>\n<p>위의 내용을 Spring을 사용한 개발이라고 한다면… 아래와 같이 코드를 짤 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span>(scanBasePackages = <span class=\"string\">\"com.example.ioc\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Restaurant restaurant;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EatFactory eatFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\tSpringApplication.run(SpringStudyApplication.class, args);</span><br><span class=\"line\">        <span class=\"comment\">//식사 시작</span></span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.BREAKFAST));</span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.LUNCH));</span><br><span class=\"line\">        restaurant.eat(eatFactory.get(Meal.DINNER));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Meal &#123;</span><br><span class=\"line\">   BREAKFAST, LUNCH, DINNER;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">EatFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"breakfast\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable breakfast;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"lunch\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable lunch;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"dinner\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Eatable dinner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Eatable <span class=\"title\">get</span><span class=\"params\">(Meal meal)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(meal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BREAKFAST : breakfast;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LUNCH : lunch;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> DINNER : dinner;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Not using Meal Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">Eatable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Restaurant</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">(Eatable eatable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(eatable.getInfo() + <span class=\"string\">\"을 먹었습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Spring에서는 component-scan이라는 기능을 통해 @Component 어노테이션이 붙은 클래스는 IoC 컨테이너에 Bean으로써 자동 등록 해준다. 이러한 Bean은 @Autowired / @Inject 와 같은 어노테이션을 통해 클래스에 주입을 해줄 수 있다.<br>\n이렇게 되면 개발자가 new를 통해 의존성을 강제화 하지 않고 프레임워크가 이 역할을 대신 수행해 준다.</p>\n<p>개발자가 객체 생성과 의존성 주입에 대한 역할을 대신 해준다<br>\nInversion of Control (객체 관리과 의존성 관리를 시스템에서 해준다 : 제어의 역전) 이라고 불리게 되었다.</p>\n<h1>참조</h1>\n<p><a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring프레임워크소개와IoC및SpringIoC의개념-2.1IoC란무엇인가%3F</a><br>\n<a href=\"http://wiki.javajigi.net/pages/viewpage.action?pageId=281\" target=\"_blank\" rel=\"noopener\">http://wiki.javajigi.net/pages/viewpage.action?pageId=281</a><br>\n<a href=\"https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/</a><br>\n<a href=\"https://okky.kr/article/415474\" target=\"_blank\" rel=\"noopener\">https://okky.kr/article/415474</a><br>\n<a href=\"http://www.javajigi.net/pages/viewpage.action?pageId=68\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/pages/viewpage.action?pageId=68</a><br>\n<a href=\"http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1\" target=\"_blank\" rel=\"noopener\">http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1</a><br>\n<a href=\"http://isstory83.tistory.com/91\" target=\"_blank\" rel=\"noopener\">http://isstory83.tistory.com/91</a><br>\n토비의 스프링 VOL.2 Spring IoC</p>\n"},{"layout":"posts","title":"SpEL Expression(1)","catalog":true,"Categories":["Spring"],"date":"2018-11-21T05:11:42.000Z","typora-root-url":"2018-11-21-spel-expression","typora-copy-images-to":"2018-11-21-spel-expression","_content":"\n# 들어가며\n\nSpring Cache Abstraction 기능을 사용하게 되면서, key modeling 시, 필요한 SpEL에 대해 알아보게 되었다.\n기본적인 설명과 예제는 Spring Docs를 기반으로 번역\n\n# SpEL (<u>Sp</u>ring <u>E</u>xpression <u>L</u>anguage)이란?\n\nSpring Expression Language (줄여서 SpEL)은 런타임에 쿼리를 지원하고 객체를 조작할 수 있는 강력한 표현식 언어이다. 언어 구문은 Unified EL과 유사하지만, 여러가지 추가 기능을 제공한다.\n\n다른 Java에서 사용가능한 표현식 언어가 있지만, SpEL은 Spring 커뮤니티에 표현식 언어를 제공하기 위해 만들어졌다.\nSpring 포트폴리오 내에서 표현식 평가 (Expression evaluation)의 기반으로 SpEL을 제공하지만, SpEL은 Spring과 직접 연계되지 않고 독립적으로 사용 할 수 있다.\n독립적으로 사용하기 위해서는 Parser 같은 Bootstraping 기반 클래스에 대한 설정을 몇가지 할 필요가 있다.\n하지만 웬만한 개발자들은 이런 기반 클래스에 대한 설정 없이 SpEL 표현식만 잘 작성하면 된다.\n\n# SpEL에서 지원하는 기능\n\n* 리터럴 표현식 (Literal Expression)\n* Boolean과 관계형 Operator (Boolean and Relational Operator)\n* 정규 표현식 (Regular Expression)\n* 클래스 표현식 (Class Expression)\n* 프로퍼티, 배열, 리스트, 맵에 대한 접근 지원 (Accessing properties, arrays, lists, maps)\n* 메서드 호출 (Method Invocation)\n* 관계형 Operator (Relational Operator)\n* 할당 (Assignment)\n* 생성자 호출 (Calling Constructors)\n* Bean 참조 (Bean References)\n* 배열 생성 (Array Contruction)\n* 인라인 리스트/맵 (Inline List/Map)\n* 삼항 연산자 (Ternary Operator)\n* 변수 (Variables)\n* 사용자 정의 함수 (User defined functions)\n* 컬렉션 투영 (Collections Projection)\n* 컬렉션 선택 (Collections Selection)\n* Template 표현식 (Templated expression)\n\n# Expression 인터페이스를 이용한 표현식 파싱\n\n``` java\npublic class ExpressionTest {\n\n    public static void main(String[] args) {\n\n        String message = parseExpression(\"\\\"Hello World\\\"\", String.class);\n        System.out.println(message); //\"Hello World\"\n\n        String message2 = parseExpression(\"\\\"Hello World\\\".concat('!')\", String.class);\n        System.out.println(message2); //\"Hello World!\"\n    }\n\n    public static <T> T parseExpression(String expression, Class<T> clazz) {\n        ExpressionParser parser = new SpelExpressionParser();\n        Expression exp = parser.parseExpression(expression);\n        return exp.getValue(clazz);\n    }\n}\n```\n\n* 위의 코드는 SpEL표현식 문자열에 대한 파싱(Parsing) 하는 프로그램의 예제 코드이다.\n* ExpressionParser Interface를 구현하는 SpelExpressionParser로 SpEL 표현식의 내용을 파싱(Parsing) 할 수 있다.\n* exp.getValue() 메서드를 이용해 파싱된 결과값을 Object 타입으로 얻거나, Class정보를 파라미터로 추가해 자동으로 타입 캐스팅이 가능하다.\n\n# EvaluationContext 인터페이스를 이용한 표현식 파싱\n\n* Property, Method, Field에 대한 파싱을 처리\n* 타입변환을 수행하는 표현식을 평가 할 때 EvaluationContext 인터페이스를 사용\n* EvaluationContext의 구현체인 StandardEvaluationContext는 객체를 조작하기 위해 java reflection의 기능을 사용\n* 성능을 향상 시키기 위해 java.lang.reflect의 Method, Field, Constructor를 캐싱한다.\n\nSpEL의 더 일반적인 사용법은 특정 객체 인스턴스(root객체)에 대해 평가되는 표현식 문자열을 제공하는 것이다.\nroot객체를 제공하는 방식은 2가지 방식이 있다.\n\n## root 객체를 똑같이 제공하는 경우\n\n``` java\n// Create and set a calendar\nGregorianCalendar c = new GregorianCalendar();\nc.set(1856, 7, 9);\n\n// name, birthday, nationality를 파라미터로 갖는 생성자이다.\nInventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");\n\nExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"name\"); //tesla객체의 name 프로퍼티가 파싱\n\n//Context에 tesla객체를 넣어준다.\nEvaluationContext context = new StandardEvaluationContext(tesla);\nString name = (String) exp.getValue(context); //name = \"Nikola Tesla\"\n```\n\n* StandardEvaluationContext는 `name` 프로퍼티가 평가 될 객체를 지정하는 클래스이다.\n  (위의 예제는 root객체, 즉 tesla 객체를 고정하여 사용하는 예제)\n* 위의 SpelExpressionParser가 표현식을 평가 할 때, 표현식의 대한 기준을 Tesla 객체로 지정하는 부분이다.\n* `parser.parseExpression(\"name\");` 가 실행되면, tesla 객체의 name 프로퍼티가 파싱된다.\n* name변수에는 `Nikola Tesla` 문자열이 리턴된다.\n* 타입 캐스팅 실패 시에는, `EvaluationException`이 throw된다.\n\n## root 객체가 계속 변경되는 경우\n\n``` java\n// Create and set a calendar\nGregorianCalendar c = new GregorianCalendar();\nc.set(1856, 7, 9);\n\n// name, birthday, nationality를 파라미터로 갖는 생성자이다.\nInventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");\n\nExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"name\"); //tesla객체의 name 프로퍼티가 파싱\n\nString name = (String) exp.getValue(tesla);\n```\n\ngetValue 메서드 호출 시에, StandardEvaluationContext를 사용하지 않고 root 객체를 직접 지정해 준다.\n\n## 두 가지 방식의 차이\n\n* StandardEvaluationContext를 사용하는 경우 생성 비용이 상대적으로 많이 든다.\n* 반복적으로 사용하는 동안 `Field에 대해 캐싱되고 있기 때문에 표현식 파싱이 더 빠르다`는 장점이 있다.\n* 설정 파일에서 SpEL을 사용하는 경우에는, root 객체를 고정하고 SpEL 표현식만 개발자에게 설정 하도록 하는 것이 좋다.\n\n\n# Bean을 정의하는 표현식\n* BeanDefinition을 정의하는 XML이나, Annotation 기반의 설정에는 MetaData와 SpEL표현식을 같이 사용할 수 있다.\n* `#{<expression>}` 문법으로 사용한다.\n\n\n## XML Based\n* 프로퍼티나 생성자 Argument 값을 표현식으로 나타낼 수 있다.\n```xml\n<bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\">\n  <property name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/>\n</bean>\n```\n\nsystemProperties bean을 미리 지정하여 사용할 수 있다. (bean을 사용하였지만 `@` 문자를 안붙인 것을 주의)\n```xml\n<bean id=\"taxCalculator\" class=\"org.spring.samples.TaxCalculator\">\n  <property name=\"defaultLocale\" value=\"#{ systemProperties['user.region'] }\"/>\n</bean>\n```\n\n아래 예제 처럼 다른 bean의 Properties를 사용할 수 있다.\n```xml\n<bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\">\n  <property name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/>\n</bean>\n\n<bean id=\"shapeGuess\" class=\"org.spring.samples.ShapeGuess\">\n  <property name=\"initialShapeSeed\" value=\"#{ numberGuess.randomNumber }\"/>\n</bean>\n```\n\n## Annotation Based\n* 기본값을 지정하기 위해 @Value Annotation을 이용해 Field, Method, Method-Parameter에 붙일 수 있다.\n\n```java\npublic static class FieldValueTestBean\n\n  @Value(\"#{ systemProperties['user.region'] }\")\n  private String defaultLocale;\n\n  public void setDefaultLocale(String defaultLocale)\n  {\n    this.defaultLocale = defaultLocale;\n  }\n\n  public String getDefaultLocale() \n  {\n    return this.defaultLocale;\n  }\n}\n```\n\n```java\npublic static class PropertyValueTestBean\n\n  private String defaultLocale;\n\n  @Value(\"#{ systemProperties['user.region'] }\")\n  public void setDefaultLocale(String defaultLocale)\n  {\n    this.defaultLocale = defaultLocale;\n  }\n}\n```\n\n```java\n  private MovieFinder movieFinder;\n  private String defaultLocale;\n\n  @Autowired\n  public void configure(MovieFinder movieFinder, \n                   @Value(\"#{ systemProperties['user.region'] }\"} String defaultLocale) {\n    this.movieFinder = movieFinder;\n    this.defaultLocale = defaultLocale;\n  }\n```\n\n\n\n\n# 참고\n\n* https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html\n* https://blog.outsider.ne.kr/835\n* https://blog.outsider.ne.kr/837","source":"_posts/2018-11-21-spel-expression.md","raw":"---\nlayout: posts\ntitle: SpEL Expression(1)\ncatalog: true\nCategories:\n- Spring\ntags:\n- Spring\n- SpEL\ndate: 2018-11-21 14:11:42\ntypora-root-url: 2018-11-21-spel-expression\ntypora-copy-images-to: 2018-11-21-spel-expression\n---\n\n# 들어가며\n\nSpring Cache Abstraction 기능을 사용하게 되면서, key modeling 시, 필요한 SpEL에 대해 알아보게 되었다.\n기본적인 설명과 예제는 Spring Docs를 기반으로 번역\n\n# SpEL (<u>Sp</u>ring <u>E</u>xpression <u>L</u>anguage)이란?\n\nSpring Expression Language (줄여서 SpEL)은 런타임에 쿼리를 지원하고 객체를 조작할 수 있는 강력한 표현식 언어이다. 언어 구문은 Unified EL과 유사하지만, 여러가지 추가 기능을 제공한다.\n\n다른 Java에서 사용가능한 표현식 언어가 있지만, SpEL은 Spring 커뮤니티에 표현식 언어를 제공하기 위해 만들어졌다.\nSpring 포트폴리오 내에서 표현식 평가 (Expression evaluation)의 기반으로 SpEL을 제공하지만, SpEL은 Spring과 직접 연계되지 않고 독립적으로 사용 할 수 있다.\n독립적으로 사용하기 위해서는 Parser 같은 Bootstraping 기반 클래스에 대한 설정을 몇가지 할 필요가 있다.\n하지만 웬만한 개발자들은 이런 기반 클래스에 대한 설정 없이 SpEL 표현식만 잘 작성하면 된다.\n\n# SpEL에서 지원하는 기능\n\n* 리터럴 표현식 (Literal Expression)\n* Boolean과 관계형 Operator (Boolean and Relational Operator)\n* 정규 표현식 (Regular Expression)\n* 클래스 표현식 (Class Expression)\n* 프로퍼티, 배열, 리스트, 맵에 대한 접근 지원 (Accessing properties, arrays, lists, maps)\n* 메서드 호출 (Method Invocation)\n* 관계형 Operator (Relational Operator)\n* 할당 (Assignment)\n* 생성자 호출 (Calling Constructors)\n* Bean 참조 (Bean References)\n* 배열 생성 (Array Contruction)\n* 인라인 리스트/맵 (Inline List/Map)\n* 삼항 연산자 (Ternary Operator)\n* 변수 (Variables)\n* 사용자 정의 함수 (User defined functions)\n* 컬렉션 투영 (Collections Projection)\n* 컬렉션 선택 (Collections Selection)\n* Template 표현식 (Templated expression)\n\n# Expression 인터페이스를 이용한 표현식 파싱\n\n``` java\npublic class ExpressionTest {\n\n    public static void main(String[] args) {\n\n        String message = parseExpression(\"\\\"Hello World\\\"\", String.class);\n        System.out.println(message); //\"Hello World\"\n\n        String message2 = parseExpression(\"\\\"Hello World\\\".concat('!')\", String.class);\n        System.out.println(message2); //\"Hello World!\"\n    }\n\n    public static <T> T parseExpression(String expression, Class<T> clazz) {\n        ExpressionParser parser = new SpelExpressionParser();\n        Expression exp = parser.parseExpression(expression);\n        return exp.getValue(clazz);\n    }\n}\n```\n\n* 위의 코드는 SpEL표현식 문자열에 대한 파싱(Parsing) 하는 프로그램의 예제 코드이다.\n* ExpressionParser Interface를 구현하는 SpelExpressionParser로 SpEL 표현식의 내용을 파싱(Parsing) 할 수 있다.\n* exp.getValue() 메서드를 이용해 파싱된 결과값을 Object 타입으로 얻거나, Class정보를 파라미터로 추가해 자동으로 타입 캐스팅이 가능하다.\n\n# EvaluationContext 인터페이스를 이용한 표현식 파싱\n\n* Property, Method, Field에 대한 파싱을 처리\n* 타입변환을 수행하는 표현식을 평가 할 때 EvaluationContext 인터페이스를 사용\n* EvaluationContext의 구현체인 StandardEvaluationContext는 객체를 조작하기 위해 java reflection의 기능을 사용\n* 성능을 향상 시키기 위해 java.lang.reflect의 Method, Field, Constructor를 캐싱한다.\n\nSpEL의 더 일반적인 사용법은 특정 객체 인스턴스(root객체)에 대해 평가되는 표현식 문자열을 제공하는 것이다.\nroot객체를 제공하는 방식은 2가지 방식이 있다.\n\n## root 객체를 똑같이 제공하는 경우\n\n``` java\n// Create and set a calendar\nGregorianCalendar c = new GregorianCalendar();\nc.set(1856, 7, 9);\n\n// name, birthday, nationality를 파라미터로 갖는 생성자이다.\nInventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");\n\nExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"name\"); //tesla객체의 name 프로퍼티가 파싱\n\n//Context에 tesla객체를 넣어준다.\nEvaluationContext context = new StandardEvaluationContext(tesla);\nString name = (String) exp.getValue(context); //name = \"Nikola Tesla\"\n```\n\n* StandardEvaluationContext는 `name` 프로퍼티가 평가 될 객체를 지정하는 클래스이다.\n  (위의 예제는 root객체, 즉 tesla 객체를 고정하여 사용하는 예제)\n* 위의 SpelExpressionParser가 표현식을 평가 할 때, 표현식의 대한 기준을 Tesla 객체로 지정하는 부분이다.\n* `parser.parseExpression(\"name\");` 가 실행되면, tesla 객체의 name 프로퍼티가 파싱된다.\n* name변수에는 `Nikola Tesla` 문자열이 리턴된다.\n* 타입 캐스팅 실패 시에는, `EvaluationException`이 throw된다.\n\n## root 객체가 계속 변경되는 경우\n\n``` java\n// Create and set a calendar\nGregorianCalendar c = new GregorianCalendar();\nc.set(1856, 7, 9);\n\n// name, birthday, nationality를 파라미터로 갖는 생성자이다.\nInventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");\n\nExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"name\"); //tesla객체의 name 프로퍼티가 파싱\n\nString name = (String) exp.getValue(tesla);\n```\n\ngetValue 메서드 호출 시에, StandardEvaluationContext를 사용하지 않고 root 객체를 직접 지정해 준다.\n\n## 두 가지 방식의 차이\n\n* StandardEvaluationContext를 사용하는 경우 생성 비용이 상대적으로 많이 든다.\n* 반복적으로 사용하는 동안 `Field에 대해 캐싱되고 있기 때문에 표현식 파싱이 더 빠르다`는 장점이 있다.\n* 설정 파일에서 SpEL을 사용하는 경우에는, root 객체를 고정하고 SpEL 표현식만 개발자에게 설정 하도록 하는 것이 좋다.\n\n\n# Bean을 정의하는 표현식\n* BeanDefinition을 정의하는 XML이나, Annotation 기반의 설정에는 MetaData와 SpEL표현식을 같이 사용할 수 있다.\n* `#{<expression>}` 문법으로 사용한다.\n\n\n## XML Based\n* 프로퍼티나 생성자 Argument 값을 표현식으로 나타낼 수 있다.\n```xml\n<bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\">\n  <property name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/>\n</bean>\n```\n\nsystemProperties bean을 미리 지정하여 사용할 수 있다. (bean을 사용하였지만 `@` 문자를 안붙인 것을 주의)\n```xml\n<bean id=\"taxCalculator\" class=\"org.spring.samples.TaxCalculator\">\n  <property name=\"defaultLocale\" value=\"#{ systemProperties['user.region'] }\"/>\n</bean>\n```\n\n아래 예제 처럼 다른 bean의 Properties를 사용할 수 있다.\n```xml\n<bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\">\n  <property name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/>\n</bean>\n\n<bean id=\"shapeGuess\" class=\"org.spring.samples.ShapeGuess\">\n  <property name=\"initialShapeSeed\" value=\"#{ numberGuess.randomNumber }\"/>\n</bean>\n```\n\n## Annotation Based\n* 기본값을 지정하기 위해 @Value Annotation을 이용해 Field, Method, Method-Parameter에 붙일 수 있다.\n\n```java\npublic static class FieldValueTestBean\n\n  @Value(\"#{ systemProperties['user.region'] }\")\n  private String defaultLocale;\n\n  public void setDefaultLocale(String defaultLocale)\n  {\n    this.defaultLocale = defaultLocale;\n  }\n\n  public String getDefaultLocale() \n  {\n    return this.defaultLocale;\n  }\n}\n```\n\n```java\npublic static class PropertyValueTestBean\n\n  private String defaultLocale;\n\n  @Value(\"#{ systemProperties['user.region'] }\")\n  public void setDefaultLocale(String defaultLocale)\n  {\n    this.defaultLocale = defaultLocale;\n  }\n}\n```\n\n```java\n  private MovieFinder movieFinder;\n  private String defaultLocale;\n\n  @Autowired\n  public void configure(MovieFinder movieFinder, \n                   @Value(\"#{ systemProperties['user.region'] }\"} String defaultLocale) {\n    this.movieFinder = movieFinder;\n    this.defaultLocale = defaultLocale;\n  }\n```\n\n\n\n\n# 참고\n\n* https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html\n* https://blog.outsider.ne.kr/835\n* https://blog.outsider.ne.kr/837","slug":"2018-11-21-spel-expression","published":1,"updated":"2018-11-27T07:23:32.382Z","comments":1,"photos":[],"link":"","_id":"cjp55h5ig001d4f1tewnzb39h","content":"<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>Spring Cache Abstraction 기능을 사용하게 되면서, key modeling 시, 필요한 SpEL에 대해 알아보게 되었다.<br>\n기본적인 설명과 예제는 Spring Docs를 기반으로 번역</p>\n<h1><span id=\"spel-spring-expression-language이란\">SpEL (<u>Sp</u>ring <u>E</u>xpression <u>L</u>anguage)이란?</span></h1>\n<p>Spring Expression Language (줄여서 SpEL)은 런타임에 쿼리를 지원하고 객체를 조작할 수 있는 강력한 표현식 언어이다. 언어 구문은 Unified EL과 유사하지만, 여러가지 추가 기능을 제공한다.</p>\n<p>다른 Java에서 사용가능한 표현식 언어가 있지만, SpEL은 Spring 커뮤니티에 표현식 언어를 제공하기 위해 만들어졌다.<br>\nSpring 포트폴리오 내에서 표현식 평가 (Expression evaluation)의 기반으로 SpEL을 제공하지만, SpEL은 Spring과 직접 연계되지 않고 독립적으로 사용 할 수 있다.<br>\n독립적으로 사용하기 위해서는 Parser 같은 Bootstraping 기반 클래스에 대한 설정을 몇가지 할 필요가 있다.<br>\n하지만 웬만한 개발자들은 이런 기반 클래스에 대한 설정 없이 SpEL 표현식만 잘 작성하면 된다.</p>\n<h1><span id=\"spel에서-지원하는-기능\">SpEL에서 지원하는 기능</span></h1>\n<ul>\n<li>리터럴 표현식 (Literal Expression)</li>\n<li>Boolean과 관계형 Operator (Boolean and Relational Operator)</li>\n<li>정규 표현식 (Regular Expression)</li>\n<li>클래스 표현식 (Class Expression)</li>\n<li>프로퍼티, 배열, 리스트, 맵에 대한 접근 지원 (Accessing properties, arrays, lists, maps)</li>\n<li>메서드 호출 (Method Invocation)</li>\n<li>관계형 Operator (Relational Operator)</li>\n<li>할당 (Assignment)</li>\n<li>생성자 호출 (Calling Constructors)</li>\n<li>Bean 참조 (Bean References)</li>\n<li>배열 생성 (Array Contruction)</li>\n<li>인라인 리스트/맵 (Inline List/Map)</li>\n<li>삼항 연산자 (Ternary Operator)</li>\n<li>변수 (Variables)</li>\n<li>사용자 정의 함수 (User defined functions)</li>\n<li>컬렉션 투영 (Collections Projection)</li>\n<li>컬렉션 선택 (Collections Selection)</li>\n<li>Template 표현식 (Templated expression)</li>\n</ul>\n<h1><span id=\"expression-인터페이스를-이용한-표현식-파싱\">Expression 인터페이스를 이용한 표현식 파싱</span></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressionTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String message = parseExpression(<span class=\"string\">\"\\\"Hello World\\\"\"</span>, String.class);</span><br><span class=\"line\">        System.out.println(message); <span class=\"comment\">//\"Hello World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String message2 = parseExpression(<span class=\"string\">\"\\\"Hello World\\\".concat('!')\"</span>, String.class);</span><br><span class=\"line\">        System.out.println(message2); <span class=\"comment\">//\"Hello World!\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">parseExpression</span><span class=\"params\">(String expression, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">        ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">        Expression exp = parser.parseExpression(expression);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> exp.getValue(clazz);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>위의 코드는 SpEL표현식 문자열에 대한 파싱(Parsing) 하는 프로그램의 예제 코드이다.</li>\n<li>ExpressionParser Interface를 구현하는 SpelExpressionParser로 SpEL 표현식의 내용을 파싱(Parsing) 할 수 있다.</li>\n<li>exp.getValue() 메서드를 이용해 파싱된 결과값을 Object 타입으로 얻거나, Class정보를 파라미터로 추가해 자동으로 타입 캐스팅이 가능하다.</li>\n</ul>\n<h1><span id=\"evaluationcontext-인터페이스를-이용한-표현식-파싱\">EvaluationContext 인터페이스를 이용한 표현식 파싱</span></h1>\n<ul>\n<li>Property, Method, Field에 대한 파싱을 처리</li>\n<li>타입변환을 수행하는 표현식을 평가 할 때 EvaluationContext 인터페이스를 사용</li>\n<li>EvaluationContext의 구현체인 StandardEvaluationContext는 객체를 조작하기 위해 java reflection의 기능을 사용</li>\n<li>성능을 향상 시키기 위해 java.lang.reflect의 Method, Field, Constructor를 캐싱한다.</li>\n</ul>\n<p>SpEL의 더 일반적인 사용법은 특정 객체 인스턴스(root객체)에 대해 평가되는 표현식 문자열을 제공하는 것이다.<br>\nroot객체를 제공하는 방식은 2가지 방식이 있다.</p>\n<h2><span id=\"root-객체를-똑같이-제공하는-경우\">root 객체를 똑같이 제공하는 경우</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create and set a calendar</span></span><br><span class=\"line\">GregorianCalendar c = <span class=\"keyword\">new</span> GregorianCalendar();</span><br><span class=\"line\">c.set(<span class=\"number\">1856</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// name, birthday, nationality를 파라미터로 갖는 생성자이다.</span></span><br><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, c.getTime(), <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">Expression exp = parser.parseExpression(<span class=\"string\">\"name\"</span>); <span class=\"comment\">//tesla객체의 name 프로퍼티가 파싱</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Context에 tesla객체를 넣어준다.</span></span><br><span class=\"line\">EvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\">String name = (String) exp.getValue(context); <span class=\"comment\">//name = \"Nikola Tesla\"</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>StandardEvaluationContext는 <code>name</code> 프로퍼티가 평가 될 객체를 지정하는 클래스이다.<br>\n(위의 예제는 root객체, 즉 tesla 객체를 고정하여 사용하는 예제)</li>\n<li>위의 SpelExpressionParser가 표현식을 평가 할 때, 표현식의 대한 기준을 Tesla 객체로 지정하는 부분이다.</li>\n<li><code>parser.parseExpression(&quot;name&quot;);</code> 가 실행되면, tesla 객체의 name 프로퍼티가 파싱된다.</li>\n<li>name변수에는 <code>Nikola Tesla</code> 문자열이 리턴된다.</li>\n<li>타입 캐스팅 실패 시에는, <code>EvaluationException</code>이 throw된다.</li>\n</ul>\n<h2><span id=\"root-객체가-계속-변경되는-경우\">root 객체가 계속 변경되는 경우</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create and set a calendar</span></span><br><span class=\"line\">GregorianCalendar c = <span class=\"keyword\">new</span> GregorianCalendar();</span><br><span class=\"line\">c.set(<span class=\"number\">1856</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// name, birthday, nationality를 파라미터로 갖는 생성자이다.</span></span><br><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, c.getTime(), <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">Expression exp = parser.parseExpression(<span class=\"string\">\"name\"</span>); <span class=\"comment\">//tesla객체의 name 프로퍼티가 파싱</span></span><br><span class=\"line\"></span><br><span class=\"line\">String name = (String) exp.getValue(tesla);</span><br></pre></td></tr></table></figure>\n<p>getValue 메서드 호출 시에, StandardEvaluationContext를 사용하지 않고 root 객체를 직접 지정해 준다.</p>\n<h2><span id=\"두-가지-방식의-차이\">두 가지 방식의 차이</span></h2>\n<ul>\n<li>StandardEvaluationContext를 사용하는 경우 생성 비용이 상대적으로 많이 든다.</li>\n<li>반복적으로 사용하는 동안 <code>Field에 대해 캐싱되고 있기 때문에 표현식 파싱이 더 빠르다</code>는 장점이 있다.</li>\n<li>설정 파일에서 SpEL을 사용하는 경우에는, root 객체를 고정하고 SpEL 표현식만 개발자에게 설정 하도록 하는 것이 좋다.</li>\n</ul>\n<h1><span id=\"bean을-정의하는-표현식\">Bean을 정의하는 표현식</span></h1>\n<ul>\n<li>BeanDefinition을 정의하는 XML이나, Annotation 기반의 설정에는 MetaData와 SpEL표현식을 같이 사용할 수 있다.</li>\n<li><code>#{&lt;expression&gt;}</code> 문법으로 사용한다.</li>\n</ul>\n<h2><span id=\"xml-based\">XML Based</span></h2>\n<ul>\n<li>프로퍼티나 생성자 Argument 값을 표현식으로 나타낼 수 있다.</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"numberGuess\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.NumberGuess\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"randomNumber\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>systemProperties bean을 미리 지정하여 사용할 수 있다. (bean을 사용하였지만 <code>@</code> 문자를 안붙인 것을 주의)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"taxCalculator\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.TaxCalculator\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"defaultLocale\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; systemProperties['user.region'] &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>아래 예제 처럼 다른 bean의 Properties를 사용할 수 있다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"numberGuess\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.NumberGuess\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"randomNumber\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"shapeGuess\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.ShapeGuess\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"initialShapeSeed\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; numberGuess.randomNumber &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"annotation-based\">Annotation Based</span></h2>\n<ul>\n<li>기본값을 지정하기 위해 @Value Annotation을 이용해 Field, Method, Method-Parameter에 붙일 수 있다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FieldValueTestBean</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\">  @Value(\"#&#123; systemProperties['user.region'] &#125;\")</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String defaultLocale;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDefaultLocale</span><span class=\"params\">(String defaultLocale)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.defaultLocale = defaultLocale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDefaultLocale</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.defaultLocale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PropertyValueTestBean</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">private</span> <span class=\"title\">String</span> <span class=\"title\">defaultLocale</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Value</span>(<span class=\"string\">\"#&#123; systemProperties['user.region'] &#125;\"</span>)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDefaultLocale</span><span class=\"params\">(String defaultLocale)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.defaultLocale = defaultLocale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> MovieFinder movieFinder;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String defaultLocale;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(MovieFinder movieFinder, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 @Value(<span class=\"string\">\"#&#123; systemProperties['user.region'] &#125;\"</span>&#125; String defaultLocale)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.movieFinder = movieFinder;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.defaultLocale = defaultLocale;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"참고\">참고</span></h1>\n<ul>\n<li><a href=\"https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html</a></li>\n<li><a href=\"https://blog.outsider.ne.kr/835\" target=\"_blank\" rel=\"noopener\">https://blog.outsider.ne.kr/835</a></li>\n<li><a href=\"https://blog.outsider.ne.kr/837\" target=\"_blank\" rel=\"noopener\">https://blog.outsider.ne.kr/837</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>Spring Cache Abstraction 기능을 사용하게 되면서, key modeling 시, 필요한 SpEL에 대해 알아보게 되었다.<br>\n기본적인 설명과 예제는 Spring Docs를 기반으로 번역</p>\n<h1>SpEL (<u>Sp</u>ring <u>E</u>xpression <u>L</u>anguage)이란?</h1>\n<p>Spring Expression Language (줄여서 SpEL)은 런타임에 쿼리를 지원하고 객체를 조작할 수 있는 강력한 표현식 언어이다. 언어 구문은 Unified EL과 유사하지만, 여러가지 추가 기능을 제공한다.</p>\n<p>다른 Java에서 사용가능한 표현식 언어가 있지만, SpEL은 Spring 커뮤니티에 표현식 언어를 제공하기 위해 만들어졌다.<br>\nSpring 포트폴리오 내에서 표현식 평가 (Expression evaluation)의 기반으로 SpEL을 제공하지만, SpEL은 Spring과 직접 연계되지 않고 독립적으로 사용 할 수 있다.<br>\n독립적으로 사용하기 위해서는 Parser 같은 Bootstraping 기반 클래스에 대한 설정을 몇가지 할 필요가 있다.<br>\n하지만 웬만한 개발자들은 이런 기반 클래스에 대한 설정 없이 SpEL 표현식만 잘 작성하면 된다.</p>\n<h1>SpEL에서 지원하는 기능</h1>\n<ul>\n<li>리터럴 표현식 (Literal Expression)</li>\n<li>Boolean과 관계형 Operator (Boolean and Relational Operator)</li>\n<li>정규 표현식 (Regular Expression)</li>\n<li>클래스 표현식 (Class Expression)</li>\n<li>프로퍼티, 배열, 리스트, 맵에 대한 접근 지원 (Accessing properties, arrays, lists, maps)</li>\n<li>메서드 호출 (Method Invocation)</li>\n<li>관계형 Operator (Relational Operator)</li>\n<li>할당 (Assignment)</li>\n<li>생성자 호출 (Calling Constructors)</li>\n<li>Bean 참조 (Bean References)</li>\n<li>배열 생성 (Array Contruction)</li>\n<li>인라인 리스트/맵 (Inline List/Map)</li>\n<li>삼항 연산자 (Ternary Operator)</li>\n<li>변수 (Variables)</li>\n<li>사용자 정의 함수 (User defined functions)</li>\n<li>컬렉션 투영 (Collections Projection)</li>\n<li>컬렉션 선택 (Collections Selection)</li>\n<li>Template 표현식 (Templated expression)</li>\n</ul>\n<h1>Expression 인터페이스를 이용한 표현식 파싱</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressionTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String message = parseExpression(<span class=\"string\">\"\\\"Hello World\\\"\"</span>, String.class);</span><br><span class=\"line\">        System.out.println(message); <span class=\"comment\">//\"Hello World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String message2 = parseExpression(<span class=\"string\">\"\\\"Hello World\\\".concat('!')\"</span>, String.class);</span><br><span class=\"line\">        System.out.println(message2); <span class=\"comment\">//\"Hello World!\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">parseExpression</span><span class=\"params\">(String expression, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">        ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">        Expression exp = parser.parseExpression(expression);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> exp.getValue(clazz);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>위의 코드는 SpEL표현식 문자열에 대한 파싱(Parsing) 하는 프로그램의 예제 코드이다.</li>\n<li>ExpressionParser Interface를 구현하는 SpelExpressionParser로 SpEL 표현식의 내용을 파싱(Parsing) 할 수 있다.</li>\n<li>exp.getValue() 메서드를 이용해 파싱된 결과값을 Object 타입으로 얻거나, Class정보를 파라미터로 추가해 자동으로 타입 캐스팅이 가능하다.</li>\n</ul>\n<h1>EvaluationContext 인터페이스를 이용한 표현식 파싱</h1>\n<ul>\n<li>Property, Method, Field에 대한 파싱을 처리</li>\n<li>타입변환을 수행하는 표현식을 평가 할 때 EvaluationContext 인터페이스를 사용</li>\n<li>EvaluationContext의 구현체인 StandardEvaluationContext는 객체를 조작하기 위해 java reflection의 기능을 사용</li>\n<li>성능을 향상 시키기 위해 java.lang.reflect의 Method, Field, Constructor를 캐싱한다.</li>\n</ul>\n<p>SpEL의 더 일반적인 사용법은 특정 객체 인스턴스(root객체)에 대해 평가되는 표현식 문자열을 제공하는 것이다.<br>\nroot객체를 제공하는 방식은 2가지 방식이 있다.</p>\n<h2>root 객체를 똑같이 제공하는 경우</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create and set a calendar</span></span><br><span class=\"line\">GregorianCalendar c = <span class=\"keyword\">new</span> GregorianCalendar();</span><br><span class=\"line\">c.set(<span class=\"number\">1856</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// name, birthday, nationality를 파라미터로 갖는 생성자이다.</span></span><br><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, c.getTime(), <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">Expression exp = parser.parseExpression(<span class=\"string\">\"name\"</span>); <span class=\"comment\">//tesla객체의 name 프로퍼티가 파싱</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Context에 tesla객체를 넣어준다.</span></span><br><span class=\"line\">EvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\">String name = (String) exp.getValue(context); <span class=\"comment\">//name = \"Nikola Tesla\"</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>StandardEvaluationContext는 <code>name</code> 프로퍼티가 평가 될 객체를 지정하는 클래스이다.<br>\n(위의 예제는 root객체, 즉 tesla 객체를 고정하여 사용하는 예제)</li>\n<li>위의 SpelExpressionParser가 표현식을 평가 할 때, 표현식의 대한 기준을 Tesla 객체로 지정하는 부분이다.</li>\n<li><code>parser.parseExpression(&quot;name&quot;);</code> 가 실행되면, tesla 객체의 name 프로퍼티가 파싱된다.</li>\n<li>name변수에는 <code>Nikola Tesla</code> 문자열이 리턴된다.</li>\n<li>타입 캐스팅 실패 시에는, <code>EvaluationException</code>이 throw된다.</li>\n</ul>\n<h2>root 객체가 계속 변경되는 경우</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create and set a calendar</span></span><br><span class=\"line\">GregorianCalendar c = <span class=\"keyword\">new</span> GregorianCalendar();</span><br><span class=\"line\">c.set(<span class=\"number\">1856</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// name, birthday, nationality를 파라미터로 갖는 생성자이다.</span></span><br><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, c.getTime(), <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">Expression exp = parser.parseExpression(<span class=\"string\">\"name\"</span>); <span class=\"comment\">//tesla객체의 name 프로퍼티가 파싱</span></span><br><span class=\"line\"></span><br><span class=\"line\">String name = (String) exp.getValue(tesla);</span><br></pre></td></tr></table></figure>\n<p>getValue 메서드 호출 시에, StandardEvaluationContext를 사용하지 않고 root 객체를 직접 지정해 준다.</p>\n<h2>두 가지 방식의 차이</h2>\n<ul>\n<li>StandardEvaluationContext를 사용하는 경우 생성 비용이 상대적으로 많이 든다.</li>\n<li>반복적으로 사용하는 동안 <code>Field에 대해 캐싱되고 있기 때문에 표현식 파싱이 더 빠르다</code>는 장점이 있다.</li>\n<li>설정 파일에서 SpEL을 사용하는 경우에는, root 객체를 고정하고 SpEL 표현식만 개발자에게 설정 하도록 하는 것이 좋다.</li>\n</ul>\n<h1>Bean을 정의하는 표현식</h1>\n<ul>\n<li>BeanDefinition을 정의하는 XML이나, Annotation 기반의 설정에는 MetaData와 SpEL표현식을 같이 사용할 수 있다.</li>\n<li><code>#{&lt;expression&gt;}</code> 문법으로 사용한다.</li>\n</ul>\n<h2>XML Based</h2>\n<ul>\n<li>프로퍼티나 생성자 Argument 값을 표현식으로 나타낼 수 있다.</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"numberGuess\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.NumberGuess\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"randomNumber\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>systemProperties bean을 미리 지정하여 사용할 수 있다. (bean을 사용하였지만 <code>@</code> 문자를 안붙인 것을 주의)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"taxCalculator\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.TaxCalculator\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"defaultLocale\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; systemProperties['user.region'] &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>아래 예제 처럼 다른 bean의 Properties를 사용할 수 있다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"numberGuess\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.NumberGuess\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"randomNumber\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"shapeGuess\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.spring.samples.ShapeGuess\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"initialShapeSeed\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123; numberGuess.randomNumber &#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2>Annotation Based</h2>\n<ul>\n<li>기본값을 지정하기 위해 @Value Annotation을 이용해 Field, Method, Method-Parameter에 붙일 수 있다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FieldValueTestBean</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\">  @Value(\"#&#123; systemProperties['user.region'] &#125;\")</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String defaultLocale;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDefaultLocale</span><span class=\"params\">(String defaultLocale)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.defaultLocale = defaultLocale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDefaultLocale</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.defaultLocale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PropertyValueTestBean</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">private</span> <span class=\"title\">String</span> <span class=\"title\">defaultLocale</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Value</span>(<span class=\"string\">\"#&#123; systemProperties['user.region'] &#125;\"</span>)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDefaultLocale</span><span class=\"params\">(String defaultLocale)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.defaultLocale = defaultLocale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> MovieFinder movieFinder;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String defaultLocale;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(MovieFinder movieFinder, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 @Value(<span class=\"string\">\"#&#123; systemProperties['user.region'] &#125;\"</span>&#125; String defaultLocale)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.movieFinder = movieFinder;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.defaultLocale = defaultLocale;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>참고</h1>\n<ul>\n<li><a href=\"https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html</a></li>\n<li><a href=\"https://blog.outsider.ne.kr/835\" target=\"_blank\" rel=\"noopener\">https://blog.outsider.ne.kr/835</a></li>\n<li><a href=\"https://blog.outsider.ne.kr/837\" target=\"_blank\" rel=\"noopener\">https://blog.outsider.ne.kr/837</a></li>\n</ul>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (2)Docker 설치 및 사용방법","date":"2018-11-28T14:50:01.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-11-28-docker-2","typora-copy-images-to":"2018-11-28-docker-2","_content":"\n# 들어가며\n\n지난 장에서는 Docker에 대한 개념, Image와 컨테이너, VM과의 차이점등을 그림으로 설명하였습니다.\n이번 장부터는 Docker를 linux서버에 설치하는 과정을 설명하고자 합니다.\n(Linux서버 설치는 hyper-v를 이용하여 vm으로 설치 하였습니다. <차후에 hyper-v 설정기를 올릴 예정입니다.>)\nWindows, Mac에도 설치 할 수 있지만, Linux에 설치하는게 거의 표준이다 싶히 사용되고 있으며, Windows, Mac에 설치를 하더라도 어차피 가상화 환경에서 Docker가 설치 되기 때문에... linux를 설치하여 Docker를 설치하였습니다.\n(지울 때 편하게 지우고 싶어서 그런건 안비밀)\n\n\n\n# CentOS 7 환경에서 Docker 설치하기\n\nDocker를 설치하는 방법은 다양한 방법이 있겠지만.. 가장 간단한 방법으로 설치해 보도록 하겠습니다.\n\n설치 환경은 아래와 같습니다.\n\n* OS: CentOS 7 (VM 환경(Hyper-v)에서 테스트)\n* user: docker-user (일부러 root가 아닌 사용자를 생성하였습니다... 이유는 아래에)\n* SW: Redis 5\n\n>Docker 다운로드 yum을 이용해서 Docker를 받는 방법도 있지만, `최신버전이 아닙니다. `\n>차후 Docker-compose를 사용하기 위해서는 Docker버전이 1.13 이상이 되야 합니다. \n>따라서 한번에 패키지로 설치해 주는 url로 설치하도록 합니다. \n\n```sh\nsudo curl -fsSL https://get.docker.com/ | sudo sh\nsudo sh sudo service docker start #Docker Daemon Start\n```\n\n\n\n# Docker의 Permission\n\nDocker를 설치하고 확인하기 위해 Docker 명령을 입력하였습니다.\n\n```sh\ndocker version\n```\n\n![docker permission](./docker-permission.png)\n\ndocker명령을 입력했을 시, permission denied 에러가 발생한 것을 볼 수 있습니다.\ndocker는 명령을 실행 할 때 기본적으로 root계정을 필요로 합니다. (docker의 특성상 시스템의 내부적인 부분에 접근하는 게 많다보니... 그렇다고 합니다.)\n그렇기 때문에 sudo명령을 사용하여 docker 명령을 실행 할 수 있습니다.\n\n`하지만 sudo가 너무 귀찮다! 하시는 분들은...` 아래 명령을 실행하여 계정을 `docker 그룹`에 포함 시켜주시면 됩니다.\n\n```sh\nsudo usermod -aG docker $USER\nsudo service docker restart\n \nexit #로그아웃\ndocker-user <password> #다시 로그인\n```\n\n```sh\ndocker version\n```\n![sudo docker](./sudo-docker.png)\n\n이제 sudo 명령 없이도 docker 명령어 실행이 잘 됩니다!\n\n\n\n# 간단한 Docker Container(깡통)를 만들어 봅시다!\n\nDocker Hub([https://hub.docker.com](https://hub.docker.com/)) 사이트에 들어가면 우리가 필요로하는 많은 프로그램들이 이미지로 올라가 있습니다.\n이번 예제에서는 Redis를 가지고 Docker Container를 만들어보도록 하겠습니다.\n\n![docker-hub](./docker-hub.png)\n\ndocker hub 사이트에서 redis를 검색해 보았습니다.\n여러가지 redis 이미지가 보이는데 official이라고 되어있는 것이 공식이미지 입니다.\nbitnami/redis라고 되어있는 것은 docker hub의 사용자들이 올린 이미지입니다.\n\n\n\n![redis-versions](./redis-versions.png)\n\nofficial 이미지의 상세 버전을 보니 4.x~5.0.1까지 있습니다.\n이번 예제에서는 그나마 stable한 버전인 인 5.0-alpine 버전을 사용해 보도록 하겠습니다.\n\n\n\n# Docker 이미지 다운로드 (Docker hub -> Docker Client)\n\npull 명령을 통해 docker hub에 있는 이미지를 다운로드 합니다.\n\n```sh\ndocker pull redis:<tag> # ex) redis:5.0-alpine, redis:4-alpine, redis:latest(가장 마지막 배포 버전입니다.)\ndocker pull redis #tag version을 적지 않은 경우 자동으로 lastest 버전을 다운로드 합니다.\n```\n\n\n\n# Docker 이미지 확인 / 삭제\n\n## Docker 이미지 확인\n\nimages 명령을 이용하여 docker image리스트를 확인합니다.\n\n```sh\ndocker images\n```\n\n* 자주 사용하는 options\n  * -a --all : 숨겨진 임시 이미지를 보여줍니다.\n  * -f --filter : filter를 이용하여 이미지 조회 조건을 변경하여 조회 할 수 있습니다.\n  * -q --quite : image의 image ID만 출력합니다.\n\n\n>docker의 이미지는 1개의 파일이 아닌, 여러 이미지의 레이어(Layer)로 구성되어 있습니다.\n따라서 Redis이미지를 다운받더라고 Redis 이미지 하나가 아닌 여러 이미지의 레이어로 구성되어 있습니다.\n![image layer](./image-layer.png)\n따라서 하나의 이미지라도 여러 이미지가 투영되어 보이는 결과물이라 볼 수 있습니다.\n\n\n\n## Docker 이미지 삭제\n\nrmi 명령을 이용하여 docker의 image를 삭제 할 수 있습니다.\n\n```sh\n# ex) docker rmi redis:5.0-alpine, docker rmi <imageID>\ndocker rmi {이미지명/이미지ID} \n```\n\n* 자주 사용하는 Options\n  - -f --force : 이미지를 강제로 삭제합니다. (해당 이미지로 만들어진 Docker Container가 존재하는 경우 이미지를 삭제 할 수 없는데, 그 때 강제로 삭제 하기위해 사용)\n\n\n\n# Docker Container 생성 / 삭제\n\n## Docker Container 생성\n\nrun 명령으로 Container를 생성합니다.\n\n```sh\n# ex) docker run -it -d redis:5.0-alpine,\n#     docker run -it -d 4760dc956b2d\ndocker run {options} <image명/image ID> \n```\n\n- 자주 사용하는 Options\n\n  - -d --detach : Container 생성 후 Background로 실행 (이 옵션 없을 시, Redis 같은 경우에는 Console에 Redis log가 지속적으로 표시됩니다.)\n  - -h --hostname : Container 명 지정\n  - -i --interactive : 소통형 모드로 실행 (주로 ubuntu와 같은 Container 실행 시 사용)\n  - -p --publish : 해당 Container의 외부 Port 지정 (10000:6379) (외부:내부) 형식으로 지정\n  - -P --publish-all : 여러개의 Port 노출 (1000-1100)\n  - --rm : Container 종료 시, Container 삭제 `(자주 사용되는 옵션입니다)`\n  - -v --volume : 외부 볼륨 연동 /home/user/data:/data (외부 OS 디렉토리:컨테이너 내부 디렉토리) - 상호 데이터가 공유됨\n\n\n\n## Docker Container 목록 조회\n\nps 명령으로 Container 목록을 조회합니다.\n\n```sh\ndocker ps {options}\n```\n*  자주 사용하는 Options\n  * -a : 비활성 상태의 Container까지 조회\n  * -q : Container ID만 조회\n  * -f --filter : Container 조회 시, Filter를 이용하여 조회\n\n\n\n## Docker Container 내부 접속\n\nattach 명령을 이용하여 접속\n```sh\ndocker attach [container명/container ID]\n```\n>attach 명령은 /bin/bash로 실행 되기 때문에, Container에 /bin/bash가 없는 경우에는 접속이 불가능 합니다. \n\n\n\nexec 명령을 이용하여 Container 내부 명령 수행\n```sh\n# ex) docker exec -it redis:5.0-alpine /bin/sh\n# Redis의 경우 Container에 bin/bash가 없어 bin/sh로 실행하면 내부접속이 가능합니다\ndocker exec {options} [container명/container ID] [명령어]  \n```\n\n* 자주 사용하는 options\n  * -d --detach : 명령수행을 Background 모드로 수행\n  * -e --env : 환경변수 (Environment) 설정\n  * -i --interaction : 대화형 모드로 설정\n\n\n\n# Docker Container 삭제\n\nrm 명령으로 Container를 삭제 합니다.\n\n```sh\n# ex) docker rm -f redis:5.0-alpine\ndocker rm {options} [container명/container ID] \n```\n\n- 자주 사용하는 options\n  - -f --force : 활성(active) 상태의 Container 강제삭제\n  - -l --link : Container간 link가 관계인 Container 삭제\n  - -v --volumes : Container 관련 볼륨(외부 디렉토리) 삭제\n\n\n\n# 자주 사용한 명령어 모음\n\n```sh\n#Container 전체 삭제 (-a -q 옵션으로 전체 Container의 ID만 뽑아온다.)\ndocker rm -f $(docker ps -a -q)\n\n#Image 전체 삭제 (-q 옵션으로 images에 대한 Image ID만 뽑아온다.)\ndocker rmi $(docker images -q)\n\n#특정 Container 삭제 (grep 명령으로 Container ID만 뽑아온다.)\ndocker rm -f $(docker ps -a | grep \"redis:5.0-alpine\"| awk '{print $1}')\n\n#특정 이미지 삭제 (grep + awk 명령어로 image ID만 뽑아온다.)\ndocker rmi $(docker images | grep \"^redis\"| awk '{print $3}')  \n\n#Docker 삭제\ncd ~\nyum remove -y docker*\n```\n\n\n\n# 참고\n\n* http://www.sauru.so/blog/docker-installation-and-test-drive/\n* https://hub.docker.com/_/redis/\n* http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03\n* https://docs.docker.com/engine/reference/run/","source":"_posts/2018-11-28-docker-2.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (2)Docker 설치 및 사용방법\ndate: 2018-11-28 23:50:01\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-11-28-docker-2\ntypora-copy-images-to: 2018-11-28-docker-2\n---\n\n# 들어가며\n\n지난 장에서는 Docker에 대한 개념, Image와 컨테이너, VM과의 차이점등을 그림으로 설명하였습니다.\n이번 장부터는 Docker를 linux서버에 설치하는 과정을 설명하고자 합니다.\n(Linux서버 설치는 hyper-v를 이용하여 vm으로 설치 하였습니다. <차후에 hyper-v 설정기를 올릴 예정입니다.>)\nWindows, Mac에도 설치 할 수 있지만, Linux에 설치하는게 거의 표준이다 싶히 사용되고 있으며, Windows, Mac에 설치를 하더라도 어차피 가상화 환경에서 Docker가 설치 되기 때문에... linux를 설치하여 Docker를 설치하였습니다.\n(지울 때 편하게 지우고 싶어서 그런건 안비밀)\n\n\n\n# CentOS 7 환경에서 Docker 설치하기\n\nDocker를 설치하는 방법은 다양한 방법이 있겠지만.. 가장 간단한 방법으로 설치해 보도록 하겠습니다.\n\n설치 환경은 아래와 같습니다.\n\n* OS: CentOS 7 (VM 환경(Hyper-v)에서 테스트)\n* user: docker-user (일부러 root가 아닌 사용자를 생성하였습니다... 이유는 아래에)\n* SW: Redis 5\n\n>Docker 다운로드 yum을 이용해서 Docker를 받는 방법도 있지만, `최신버전이 아닙니다. `\n>차후 Docker-compose를 사용하기 위해서는 Docker버전이 1.13 이상이 되야 합니다. \n>따라서 한번에 패키지로 설치해 주는 url로 설치하도록 합니다. \n\n```sh\nsudo curl -fsSL https://get.docker.com/ | sudo sh\nsudo sh sudo service docker start #Docker Daemon Start\n```\n\n\n\n# Docker의 Permission\n\nDocker를 설치하고 확인하기 위해 Docker 명령을 입력하였습니다.\n\n```sh\ndocker version\n```\n\n![docker permission](./docker-permission.png)\n\ndocker명령을 입력했을 시, permission denied 에러가 발생한 것을 볼 수 있습니다.\ndocker는 명령을 실행 할 때 기본적으로 root계정을 필요로 합니다. (docker의 특성상 시스템의 내부적인 부분에 접근하는 게 많다보니... 그렇다고 합니다.)\n그렇기 때문에 sudo명령을 사용하여 docker 명령을 실행 할 수 있습니다.\n\n`하지만 sudo가 너무 귀찮다! 하시는 분들은...` 아래 명령을 실행하여 계정을 `docker 그룹`에 포함 시켜주시면 됩니다.\n\n```sh\nsudo usermod -aG docker $USER\nsudo service docker restart\n \nexit #로그아웃\ndocker-user <password> #다시 로그인\n```\n\n```sh\ndocker version\n```\n![sudo docker](./sudo-docker.png)\n\n이제 sudo 명령 없이도 docker 명령어 실행이 잘 됩니다!\n\n\n\n# 간단한 Docker Container(깡통)를 만들어 봅시다!\n\nDocker Hub([https://hub.docker.com](https://hub.docker.com/)) 사이트에 들어가면 우리가 필요로하는 많은 프로그램들이 이미지로 올라가 있습니다.\n이번 예제에서는 Redis를 가지고 Docker Container를 만들어보도록 하겠습니다.\n\n![docker-hub](./docker-hub.png)\n\ndocker hub 사이트에서 redis를 검색해 보았습니다.\n여러가지 redis 이미지가 보이는데 official이라고 되어있는 것이 공식이미지 입니다.\nbitnami/redis라고 되어있는 것은 docker hub의 사용자들이 올린 이미지입니다.\n\n\n\n![redis-versions](./redis-versions.png)\n\nofficial 이미지의 상세 버전을 보니 4.x~5.0.1까지 있습니다.\n이번 예제에서는 그나마 stable한 버전인 인 5.0-alpine 버전을 사용해 보도록 하겠습니다.\n\n\n\n# Docker 이미지 다운로드 (Docker hub -> Docker Client)\n\npull 명령을 통해 docker hub에 있는 이미지를 다운로드 합니다.\n\n```sh\ndocker pull redis:<tag> # ex) redis:5.0-alpine, redis:4-alpine, redis:latest(가장 마지막 배포 버전입니다.)\ndocker pull redis #tag version을 적지 않은 경우 자동으로 lastest 버전을 다운로드 합니다.\n```\n\n\n\n# Docker 이미지 확인 / 삭제\n\n## Docker 이미지 확인\n\nimages 명령을 이용하여 docker image리스트를 확인합니다.\n\n```sh\ndocker images\n```\n\n* 자주 사용하는 options\n  * -a --all : 숨겨진 임시 이미지를 보여줍니다.\n  * -f --filter : filter를 이용하여 이미지 조회 조건을 변경하여 조회 할 수 있습니다.\n  * -q --quite : image의 image ID만 출력합니다.\n\n\n>docker의 이미지는 1개의 파일이 아닌, 여러 이미지의 레이어(Layer)로 구성되어 있습니다.\n따라서 Redis이미지를 다운받더라고 Redis 이미지 하나가 아닌 여러 이미지의 레이어로 구성되어 있습니다.\n![image layer](./image-layer.png)\n따라서 하나의 이미지라도 여러 이미지가 투영되어 보이는 결과물이라 볼 수 있습니다.\n\n\n\n## Docker 이미지 삭제\n\nrmi 명령을 이용하여 docker의 image를 삭제 할 수 있습니다.\n\n```sh\n# ex) docker rmi redis:5.0-alpine, docker rmi <imageID>\ndocker rmi {이미지명/이미지ID} \n```\n\n* 자주 사용하는 Options\n  - -f --force : 이미지를 강제로 삭제합니다. (해당 이미지로 만들어진 Docker Container가 존재하는 경우 이미지를 삭제 할 수 없는데, 그 때 강제로 삭제 하기위해 사용)\n\n\n\n# Docker Container 생성 / 삭제\n\n## Docker Container 생성\n\nrun 명령으로 Container를 생성합니다.\n\n```sh\n# ex) docker run -it -d redis:5.0-alpine,\n#     docker run -it -d 4760dc956b2d\ndocker run {options} <image명/image ID> \n```\n\n- 자주 사용하는 Options\n\n  - -d --detach : Container 생성 후 Background로 실행 (이 옵션 없을 시, Redis 같은 경우에는 Console에 Redis log가 지속적으로 표시됩니다.)\n  - -h --hostname : Container 명 지정\n  - -i --interactive : 소통형 모드로 실행 (주로 ubuntu와 같은 Container 실행 시 사용)\n  - -p --publish : 해당 Container의 외부 Port 지정 (10000:6379) (외부:내부) 형식으로 지정\n  - -P --publish-all : 여러개의 Port 노출 (1000-1100)\n  - --rm : Container 종료 시, Container 삭제 `(자주 사용되는 옵션입니다)`\n  - -v --volume : 외부 볼륨 연동 /home/user/data:/data (외부 OS 디렉토리:컨테이너 내부 디렉토리) - 상호 데이터가 공유됨\n\n\n\n## Docker Container 목록 조회\n\nps 명령으로 Container 목록을 조회합니다.\n\n```sh\ndocker ps {options}\n```\n*  자주 사용하는 Options\n  * -a : 비활성 상태의 Container까지 조회\n  * -q : Container ID만 조회\n  * -f --filter : Container 조회 시, Filter를 이용하여 조회\n\n\n\n## Docker Container 내부 접속\n\nattach 명령을 이용하여 접속\n```sh\ndocker attach [container명/container ID]\n```\n>attach 명령은 /bin/bash로 실행 되기 때문에, Container에 /bin/bash가 없는 경우에는 접속이 불가능 합니다. \n\n\n\nexec 명령을 이용하여 Container 내부 명령 수행\n```sh\n# ex) docker exec -it redis:5.0-alpine /bin/sh\n# Redis의 경우 Container에 bin/bash가 없어 bin/sh로 실행하면 내부접속이 가능합니다\ndocker exec {options} [container명/container ID] [명령어]  \n```\n\n* 자주 사용하는 options\n  * -d --detach : 명령수행을 Background 모드로 수행\n  * -e --env : 환경변수 (Environment) 설정\n  * -i --interaction : 대화형 모드로 설정\n\n\n\n# Docker Container 삭제\n\nrm 명령으로 Container를 삭제 합니다.\n\n```sh\n# ex) docker rm -f redis:5.0-alpine\ndocker rm {options} [container명/container ID] \n```\n\n- 자주 사용하는 options\n  - -f --force : 활성(active) 상태의 Container 강제삭제\n  - -l --link : Container간 link가 관계인 Container 삭제\n  - -v --volumes : Container 관련 볼륨(외부 디렉토리) 삭제\n\n\n\n# 자주 사용한 명령어 모음\n\n```sh\n#Container 전체 삭제 (-a -q 옵션으로 전체 Container의 ID만 뽑아온다.)\ndocker rm -f $(docker ps -a -q)\n\n#Image 전체 삭제 (-q 옵션으로 images에 대한 Image ID만 뽑아온다.)\ndocker rmi $(docker images -q)\n\n#특정 Container 삭제 (grep 명령으로 Container ID만 뽑아온다.)\ndocker rm -f $(docker ps -a | grep \"redis:5.0-alpine\"| awk '{print $1}')\n\n#특정 이미지 삭제 (grep + awk 명령어로 image ID만 뽑아온다.)\ndocker rmi $(docker images | grep \"^redis\"| awk '{print $3}')  \n\n#Docker 삭제\ncd ~\nyum remove -y docker*\n```\n\n\n\n# 참고\n\n* http://www.sauru.so/blog/docker-installation-and-test-drive/\n* https://hub.docker.com/_/redis/\n* http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03\n* https://docs.docker.com/engine/reference/run/","slug":"2018-11-28-docker-2","published":1,"updated":"2018-11-28T15:47:30.299Z","comments":1,"photos":[],"link":"","_id":"cjp55h5ik001f4f1tsacb43f1","content":"<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>지난 장에서는 Docker에 대한 개념, Image와 컨테이너, VM과의 차이점등을 그림으로 설명하였습니다.<br>\n이번 장부터는 Docker를 linux서버에 설치하는 과정을 설명하고자 합니다.<br>\n(Linux서버 설치는 hyper-v를 이용하여 vm으로 설치 하였습니다. &lt;차후에 hyper-v 설정기를 올릴 예정입니다.&gt;)<br>\nWindows, Mac에도 설치 할 수 있지만, Linux에 설치하는게 거의 표준이다 싶히 사용되고 있으며, Windows, Mac에 설치를 하더라도 어차피 가상화 환경에서 Docker가 설치 되기 때문에… linux를 설치하여 Docker를 설치하였습니다.<br>\n(지울 때 편하게 지우고 싶어서 그런건 안비밀)</p>\n<h1><span id=\"centos-7-환경에서-docker-설치하기\">CentOS 7 환경에서 Docker 설치하기</span></h1>\n<p>Docker를 설치하는 방법은 다양한 방법이 있겠지만… 가장 간단한 방법으로 설치해 보도록 하겠습니다.</p>\n<p>설치 환경은 아래와 같습니다.</p>\n<ul>\n<li>OS: CentOS 7 (VM 환경(Hyper-v)에서 테스트)</li>\n<li>user: docker-user (일부러 root가 아닌 사용자를 생성하였습니다… 이유는 아래에)</li>\n<li>SW: Redis 5</li>\n</ul>\n<blockquote>\n<p>Docker 다운로드 yum을 이용해서 Docker를 받는 방법도 있지만, <code>최신버전이 아닙니다.</code><br>\n차후 Docker-compose를 사용하기 위해서는 Docker버전이 1.13 이상이 되야 합니다.<br>\n따라서 한번에 패키지로 설치해 주는 url로 설치하도록 합니다.</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo curl -fsSL https://get.docker.com/ | sudo sh</span><br><span class=\"line\">sudo sh sudo service docker start <span class=\"comment\">#Docker Daemon Start</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"docker의-permission\">Docker의 Permission</span></h1>\n<p>Docker를 설치하고 확인하기 위해 Docker 명령을 입력하였습니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure>\n<p><img src=\"./docker-permission.png\" alt=\"docker permission\"></p>\n<p>docker명령을 입력했을 시, permission denied 에러가 발생한 것을 볼 수 있습니다.<br>\ndocker는 명령을 실행 할 때 기본적으로 root계정을 필요로 합니다. (docker의 특성상 시스템의 내부적인 부분에 접근하는 게 많다보니… 그렇다고 합니다.)<br>\n그렇기 때문에 sudo명령을 사용하여 docker 명령을 실행 할 수 있습니다.</p>\n<p><code>하지만 sudo가 너무 귀찮다! 하시는 분들은...</code> 아래 명령을 실행하여 계정을 <code>docker 그룹</code>에 포함 시켜주시면 됩니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG docker <span class=\"variable\">$USER</span></span><br><span class=\"line\">sudo service docker restart</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">exit</span> <span class=\"comment\">#로그아웃</span></span><br><span class=\"line\">docker-user &lt;password&gt; <span class=\"comment\">#다시 로그인</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure>\n<p><img src=\"./sudo-docker.png\" alt=\"sudo docker\"></p>\n<p>이제 sudo 명령 없이도 docker 명령어 실행이 잘 됩니다!</p>\n<h1><span id=\"간단한-docker-container깡통를-만들어-봅시다\">간단한 Docker Container(깡통)를 만들어 봅시다!</span></h1>\n<p>Docker Hub(<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com</a>) 사이트에 들어가면 우리가 필요로하는 많은 프로그램들이 이미지로 올라가 있습니다.<br>\n이번 예제에서는 Redis를 가지고 Docker Container를 만들어보도록 하겠습니다.</p>\n<p><img src=\"./docker-hub.png\" alt=\"docker-hub\"></p>\n<p>docker hub 사이트에서 redis를 검색해 보았습니다.<br>\n여러가지 redis 이미지가 보이는데 official이라고 되어있는 것이 공식이미지 입니다.<br>\nbitnami/redis라고 되어있는 것은 docker hub의 사용자들이 올린 이미지입니다.</p>\n<p><img src=\"./redis-versions.png\" alt=\"redis-versions\"></p>\n<p>official 이미지의 상세 버전을 보니 4.x~5.0.1까지 있습니다.<br>\n이번 예제에서는 그나마 stable한 버전인 인 5.0-alpine 버전을 사용해 보도록 하겠습니다.</p>\n<h1><span id=\"docker-이미지-다운로드-docker-hub-gt-docker-client\">Docker 이미지 다운로드 (Docker hub -&gt; Docker Client)</span></h1>\n<p>pull 명령을 통해 docker hub에 있는 이미지를 다운로드 합니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull redis:&lt;tag&gt; <span class=\"comment\"># ex) redis:5.0-alpine, redis:4-alpine, redis:latest(가장 마지막 배포 버전입니다.)</span></span><br><span class=\"line\">docker pull redis <span class=\"comment\">#tag version을 적지 않은 경우 자동으로 lastest 버전을 다운로드 합니다.</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"docker-이미지-확인-삭제\">Docker 이미지 확인 / 삭제</span></h1>\n<h2><span id=\"docker-이미지-확인\">Docker 이미지 확인</span></h2>\n<p>images 명령을 이용하여 docker image리스트를 확인합니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<ul>\n<li>자주 사용하는 options\n<ul>\n<li>-a --all : 숨겨진 임시 이미지를 보여줍니다.</li>\n<li>-f --filter : filter를 이용하여 이미지 조회 조건을 변경하여 조회 할 수 있습니다.</li>\n<li>-q --quite : image의 image ID만 출력합니다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>docker의 이미지는 1개의 파일이 아닌, 여러 이미지의 레이어(Layer)로 구성되어 있습니다.<br>\n따라서 Redis이미지를 다운받더라고 Redis 이미지 하나가 아닌 여러 이미지의 레이어로 구성되어 있습니다.<br>\n<img src=\"./image-layer.png\" alt=\"image layer\"><br>\n따라서 하나의 이미지라도 여러 이미지가 투영되어 보이는 결과물이라 볼 수 있습니다.</p>\n</blockquote>\n<h2><span id=\"docker-이미지-삭제\">Docker 이미지 삭제</span></h2>\n<p>rmi 명령을 이용하여 docker의 image를 삭제 할 수 있습니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker rmi redis:5.0-alpine, docker rmi &lt;imageID&gt;</span></span><br><span class=\"line\">docker rmi &#123;이미지명/이미지ID&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>자주 사용하는 Options\n<ul>\n<li>-f --force : 이미지를 강제로 삭제합니다. (해당 이미지로 만들어진 Docker Container가 존재하는 경우 이미지를 삭제 할 수 없는데, 그 때 강제로 삭제 하기위해 사용)</li>\n</ul>\n</li>\n</ul>\n<h1><span id=\"docker-container-생성-삭제\">Docker Container 생성 / 삭제</span></h1>\n<h2><span id=\"docker-container-생성\">Docker Container 생성</span></h2>\n<p>run 명령으로 Container를 생성합니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker run -it -d redis:5.0-alpine,</span></span><br><span class=\"line\"><span class=\"comment\">#     docker run -it -d 4760dc956b2d</span></span><br><span class=\"line\">docker run &#123;options&#125; &lt;image명/image ID&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>자주 사용하는 Options</p>\n<ul>\n<li>-d --detach : Container 생성 후 Background로 실행 (이 옵션 없을 시, Redis 같은 경우에는 Console에 Redis log가 지속적으로 표시됩니다.)</li>\n<li>-h --hostname : Container 명 지정</li>\n<li>-i --interactive : 소통형 모드로 실행 (주로 ubuntu와 같은 Container 실행 시 사용)</li>\n<li>-p --publish : 해당 Container의 외부 Port 지정 (10000:6379) (외부:내부) 형식으로 지정</li>\n<li>-P --publish-all : 여러개의 Port 노출 (1000-1100)</li>\n<li>–rm : Container 종료 시, Container 삭제 <code>(자주 사용되는 옵션입니다)</code></li>\n<li>-v --volume : 외부 볼륨 연동 /home/user/data:/data (외부 OS 디렉토리:컨테이너 내부 디렉토리) - 상호 데이터가 공유됨</li>\n</ul>\n</li>\n</ul>\n<h2><span id=\"docker-container-목록-조회\">Docker Container 목록 조회</span></h2>\n<p>ps 명령으로 Container 목록을 조회합니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps &#123;options&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>자주 사용하는 Options</li>\n<li>-a : 비활성 상태의 Container까지 조회</li>\n<li>-q : Container ID만 조회</li>\n<li>-f --filter : Container 조회 시, Filter를 이용하여 조회</li>\n</ul>\n<h2><span id=\"docker-container-내부-접속\">Docker Container 내부 접속</span></h2>\n<p>attach 명령을 이용하여 접속</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker attach [container명/container ID]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>attach 명령은 /bin/bash로 실행 되기 때문에, Container에 /bin/bash가 없는 경우에는 접속이 불가능 합니다.</p>\n</blockquote>\n<p>exec 명령을 이용하여 Container 내부 명령 수행</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker exec -it redis:5.0-alpine /bin/sh</span></span><br><span class=\"line\"><span class=\"comment\"># Redis의 경우 Container에 bin/bash가 없어 bin/sh로 실행하면 내부접속이 가능합니다</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> &#123;options&#125; [container명/container ID] [명령어]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>자주 사용하는 options\n<ul>\n<li>-d --detach : 명령수행을 Background 모드로 수행</li>\n<li>-e --env : 환경변수 (Environment) 설정</li>\n<li>-i --interaction : 대화형 모드로 설정</li>\n</ul>\n</li>\n</ul>\n<h1><span id=\"docker-container-삭제\">Docker Container 삭제</span></h1>\n<p>rm 명령으로 Container를 삭제 합니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker rm -f redis:5.0-alpine</span></span><br><span class=\"line\">docker rm &#123;options&#125; [container명/container ID]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>자주 사용하는 options\n<ul>\n<li>-f --force : 활성(active) 상태의 Container 강제삭제</li>\n<li>-l --link : Container간 link가 관계인 Container 삭제</li>\n<li>-v --volumes : Container 관련 볼륨(외부 디렉토리) 삭제</li>\n</ul>\n</li>\n</ul>\n<h1><span id=\"자주-사용한-명령어-모음\">자주 사용한 명령어 모음</span></h1>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Container 전체 삭제 (-a -q 옵션으로 전체 Container의 ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rm -f $(docker ps -a -q)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Image 전체 삭제 (-q 옵션으로 images에 대한 Image ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rmi $(docker images -q)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#특정 Container 삭제 (grep 명령으로 Container ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rm -f $(docker ps -a | grep <span class=\"string\">\"redis:5.0-alpine\"</span>| awk <span class=\"string\">'&#123;print $1&#125;'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#특정 이미지 삭제 (grep + awk 명령어로 image ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rmi $(docker images | grep <span class=\"string\">\"^redis\"</span>| awk <span class=\"string\">'&#123;print $3&#125;'</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Docker 삭제</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">yum remove -y docker*</span><br></pre></td></tr></table></figure>\n<h1><span id=\"참고\">참고</span></h1>\n<ul>\n<li><a href=\"http://www.sauru.so/blog/docker-installation-and-test-drive/\" target=\"_blank\" rel=\"noopener\">http://www.sauru.so/blog/docker-installation-and-test-drive/</a></li>\n<li><a href=\"https://hub.docker.com/_/redis/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/redis/</a></li>\n<li><a href=\"http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03\" target=\"_blank\" rel=\"noopener\">http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03</a></li>\n<li><a href=\"https://docs.docker.com/engine/reference/run/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/reference/run/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>지난 장에서는 Docker에 대한 개념, Image와 컨테이너, VM과의 차이점등을 그림으로 설명하였습니다.<br>\n이번 장부터는 Docker를 linux서버에 설치하는 과정을 설명하고자 합니다.<br>\n(Linux서버 설치는 hyper-v를 이용하여 vm으로 설치 하였습니다. &lt;차후에 hyper-v 설정기를 올릴 예정입니다.&gt;)<br>\nWindows, Mac에도 설치 할 수 있지만, Linux에 설치하는게 거의 표준이다 싶히 사용되고 있으며, Windows, Mac에 설치를 하더라도 어차피 가상화 환경에서 Docker가 설치 되기 때문에… linux를 설치하여 Docker를 설치하였습니다.<br>\n(지울 때 편하게 지우고 싶어서 그런건 안비밀)</p>\n<h1>CentOS 7 환경에서 Docker 설치하기</h1>\n<p>Docker를 설치하는 방법은 다양한 방법이 있겠지만… 가장 간단한 방법으로 설치해 보도록 하겠습니다.</p>\n<p>설치 환경은 아래와 같습니다.</p>\n<ul>\n<li>OS: CentOS 7 (VM 환경(Hyper-v)에서 테스트)</li>\n<li>user: docker-user (일부러 root가 아닌 사용자를 생성하였습니다… 이유는 아래에)</li>\n<li>SW: Redis 5</li>\n</ul>\n<blockquote>\n<p>Docker 다운로드 yum을 이용해서 Docker를 받는 방법도 있지만, <code>최신버전이 아닙니다.</code><br>\n차후 Docker-compose를 사용하기 위해서는 Docker버전이 1.13 이상이 되야 합니다.<br>\n따라서 한번에 패키지로 설치해 주는 url로 설치하도록 합니다.</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo curl -fsSL https://get.docker.com/ | sudo sh</span><br><span class=\"line\">sudo sh sudo service docker start <span class=\"comment\">#Docker Daemon Start</span></span><br></pre></td></tr></table></figure>\n<h1>Docker의 Permission</h1>\n<p>Docker를 설치하고 확인하기 위해 Docker 명령을 입력하였습니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure>\n<p><img src=\"./docker-permission.png\" alt=\"docker permission\"></p>\n<p>docker명령을 입력했을 시, permission denied 에러가 발생한 것을 볼 수 있습니다.<br>\ndocker는 명령을 실행 할 때 기본적으로 root계정을 필요로 합니다. (docker의 특성상 시스템의 내부적인 부분에 접근하는 게 많다보니… 그렇다고 합니다.)<br>\n그렇기 때문에 sudo명령을 사용하여 docker 명령을 실행 할 수 있습니다.</p>\n<p><code>하지만 sudo가 너무 귀찮다! 하시는 분들은...</code> 아래 명령을 실행하여 계정을 <code>docker 그룹</code>에 포함 시켜주시면 됩니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG docker <span class=\"variable\">$USER</span></span><br><span class=\"line\">sudo service docker restart</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">exit</span> <span class=\"comment\">#로그아웃</span></span><br><span class=\"line\">docker-user &lt;password&gt; <span class=\"comment\">#다시 로그인</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure>\n<p><img src=\"./sudo-docker.png\" alt=\"sudo docker\"></p>\n<p>이제 sudo 명령 없이도 docker 명령어 실행이 잘 됩니다!</p>\n<h1>간단한 Docker Container(깡통)를 만들어 봅시다!</h1>\n<p>Docker Hub(<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com</a>) 사이트에 들어가면 우리가 필요로하는 많은 프로그램들이 이미지로 올라가 있습니다.<br>\n이번 예제에서는 Redis를 가지고 Docker Container를 만들어보도록 하겠습니다.</p>\n<p><img src=\"./docker-hub.png\" alt=\"docker-hub\"></p>\n<p>docker hub 사이트에서 redis를 검색해 보았습니다.<br>\n여러가지 redis 이미지가 보이는데 official이라고 되어있는 것이 공식이미지 입니다.<br>\nbitnami/redis라고 되어있는 것은 docker hub의 사용자들이 올린 이미지입니다.</p>\n<p><img src=\"./redis-versions.png\" alt=\"redis-versions\"></p>\n<p>official 이미지의 상세 버전을 보니 4.x~5.0.1까지 있습니다.<br>\n이번 예제에서는 그나마 stable한 버전인 인 5.0-alpine 버전을 사용해 보도록 하겠습니다.</p>\n<h1>Docker 이미지 다운로드 (Docker hub -&gt; Docker Client)</h1>\n<p>pull 명령을 통해 docker hub에 있는 이미지를 다운로드 합니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull redis:&lt;tag&gt; <span class=\"comment\"># ex) redis:5.0-alpine, redis:4-alpine, redis:latest(가장 마지막 배포 버전입니다.)</span></span><br><span class=\"line\">docker pull redis <span class=\"comment\">#tag version을 적지 않은 경우 자동으로 lastest 버전을 다운로드 합니다.</span></span><br></pre></td></tr></table></figure>\n<h1>Docker 이미지 확인 / 삭제</h1>\n<h2>Docker 이미지 확인</h2>\n<p>images 명령을 이용하여 docker image리스트를 확인합니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<ul>\n<li>자주 사용하는 options\n<ul>\n<li>-a --all : 숨겨진 임시 이미지를 보여줍니다.</li>\n<li>-f --filter : filter를 이용하여 이미지 조회 조건을 변경하여 조회 할 수 있습니다.</li>\n<li>-q --quite : image의 image ID만 출력합니다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>docker의 이미지는 1개의 파일이 아닌, 여러 이미지의 레이어(Layer)로 구성되어 있습니다.<br>\n따라서 Redis이미지를 다운받더라고 Redis 이미지 하나가 아닌 여러 이미지의 레이어로 구성되어 있습니다.<br>\n<img src=\"./image-layer.png\" alt=\"image layer\"><br>\n따라서 하나의 이미지라도 여러 이미지가 투영되어 보이는 결과물이라 볼 수 있습니다.</p>\n</blockquote>\n<h2>Docker 이미지 삭제</h2>\n<p>rmi 명령을 이용하여 docker의 image를 삭제 할 수 있습니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker rmi redis:5.0-alpine, docker rmi &lt;imageID&gt;</span></span><br><span class=\"line\">docker rmi &#123;이미지명/이미지ID&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>자주 사용하는 Options\n<ul>\n<li>-f --force : 이미지를 강제로 삭제합니다. (해당 이미지로 만들어진 Docker Container가 존재하는 경우 이미지를 삭제 할 수 없는데, 그 때 강제로 삭제 하기위해 사용)</li>\n</ul>\n</li>\n</ul>\n<h1>Docker Container 생성 / 삭제</h1>\n<h2>Docker Container 생성</h2>\n<p>run 명령으로 Container를 생성합니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker run -it -d redis:5.0-alpine,</span></span><br><span class=\"line\"><span class=\"comment\">#     docker run -it -d 4760dc956b2d</span></span><br><span class=\"line\">docker run &#123;options&#125; &lt;image명/image ID&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>자주 사용하는 Options</p>\n<ul>\n<li>-d --detach : Container 생성 후 Background로 실행 (이 옵션 없을 시, Redis 같은 경우에는 Console에 Redis log가 지속적으로 표시됩니다.)</li>\n<li>-h --hostname : Container 명 지정</li>\n<li>-i --interactive : 소통형 모드로 실행 (주로 ubuntu와 같은 Container 실행 시 사용)</li>\n<li>-p --publish : 해당 Container의 외부 Port 지정 (10000:6379) (외부:내부) 형식으로 지정</li>\n<li>-P --publish-all : 여러개의 Port 노출 (1000-1100)</li>\n<li>–rm : Container 종료 시, Container 삭제 <code>(자주 사용되는 옵션입니다)</code></li>\n<li>-v --volume : 외부 볼륨 연동 /home/user/data:/data (외부 OS 디렉토리:컨테이너 내부 디렉토리) - 상호 데이터가 공유됨</li>\n</ul>\n</li>\n</ul>\n<h2>Docker Container 목록 조회</h2>\n<p>ps 명령으로 Container 목록을 조회합니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps &#123;options&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>자주 사용하는 Options</li>\n<li>-a : 비활성 상태의 Container까지 조회</li>\n<li>-q : Container ID만 조회</li>\n<li>-f --filter : Container 조회 시, Filter를 이용하여 조회</li>\n</ul>\n<h2>Docker Container 내부 접속</h2>\n<p>attach 명령을 이용하여 접속</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker attach [container명/container ID]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>attach 명령은 /bin/bash로 실행 되기 때문에, Container에 /bin/bash가 없는 경우에는 접속이 불가능 합니다.</p>\n</blockquote>\n<p>exec 명령을 이용하여 Container 내부 명령 수행</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker exec -it redis:5.0-alpine /bin/sh</span></span><br><span class=\"line\"><span class=\"comment\"># Redis의 경우 Container에 bin/bash가 없어 bin/sh로 실행하면 내부접속이 가능합니다</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> &#123;options&#125; [container명/container ID] [명령어]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>자주 사용하는 options\n<ul>\n<li>-d --detach : 명령수행을 Background 모드로 수행</li>\n<li>-e --env : 환경변수 (Environment) 설정</li>\n<li>-i --interaction : 대화형 모드로 설정</li>\n</ul>\n</li>\n</ul>\n<h1>Docker Container 삭제</h1>\n<p>rm 명령으로 Container를 삭제 합니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex) docker rm -f redis:5.0-alpine</span></span><br><span class=\"line\">docker rm &#123;options&#125; [container명/container ID]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>자주 사용하는 options\n<ul>\n<li>-f --force : 활성(active) 상태의 Container 강제삭제</li>\n<li>-l --link : Container간 link가 관계인 Container 삭제</li>\n<li>-v --volumes : Container 관련 볼륨(외부 디렉토리) 삭제</li>\n</ul>\n</li>\n</ul>\n<h1>자주 사용한 명령어 모음</h1>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Container 전체 삭제 (-a -q 옵션으로 전체 Container의 ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rm -f $(docker ps -a -q)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Image 전체 삭제 (-q 옵션으로 images에 대한 Image ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rmi $(docker images -q)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#특정 Container 삭제 (grep 명령으로 Container ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rm -f $(docker ps -a | grep <span class=\"string\">\"redis:5.0-alpine\"</span>| awk <span class=\"string\">'&#123;print $1&#125;'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#특정 이미지 삭제 (grep + awk 명령어로 image ID만 뽑아온다.)</span></span><br><span class=\"line\">docker rmi $(docker images | grep <span class=\"string\">\"^redis\"</span>| awk <span class=\"string\">'&#123;print $3&#125;'</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Docker 삭제</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">yum remove -y docker*</span><br></pre></td></tr></table></figure>\n<h1>참고</h1>\n<ul>\n<li><a href=\"http://www.sauru.so/blog/docker-installation-and-test-drive/\" target=\"_blank\" rel=\"noopener\">http://www.sauru.so/blog/docker-installation-and-test-drive/</a></li>\n<li><a href=\"https://hub.docker.com/_/redis/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/redis/</a></li>\n<li><a href=\"http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03\" target=\"_blank\" rel=\"noopener\">http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03</a></li>\n<li><a href=\"https://docs.docker.com/engine/reference/run/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/reference/run/</a></li>\n</ul>\n"},{"layout":"posts","title":"Docker기반 Redis 구축하기 - (3)Dockerfile","date":"2018-12-01T06:44:03.000Z","catalog":true,"Categories":["Docker"],"typora-root-url":"2018-12-01-docker-3","typora-copy-images-to":"2018-12-01-docker-3","_content":"\n# Dockerfile 이란?\n\n이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소프트웨어에 대한 공식이미지도 있지만, Docker Hub 사용자들이 공식이미지를 바탕으로 커스터마이징하여 배포한 이미지도 등록되어 있습니다.\n\n어떻게 이미지를 빌드하고 배포 할 수 있었을까요? **Dockerfile을 이용한 이미지 빌드를 이용하면 가능합니다.**\n\nDockerfile은 이미지를 바탕으로 몇가지 명령을 실행 할 수 있는 로직을 담은 파일입니다.\nDockerfile을 통해 더 유연하게 이미지에 대한 설정을 변경할 수 있고, 그 설정을 이미지에 담아 배포 할 수 있습니다.\n\n물론 Docker run 구문에서 options을 사용하여 같은 기능을 하도록 구현 할 수 있지만, Dockerfile로 작성하게 되면 향후 유지보수가 쉬워지고 run 구문에 대한 options을 전부 기억하지 않아도 되는 장점이 있습니다.\n\n이번 장에서는 Dockerfile을 작성하는 명령어를 위주로 알아보겠으며, 간단한 예제 Dockerfile을 보도록 하겠습니다.\n\n\n\n# Dockerfile 사용방법\n\nDockerfile을 이용한 docker build\n\n```sh\n#dockerfile이 위치한 directory의 dockerfile을 가지고 build합니다.\ndocker build -f /path/to/dockerfile \n```\n\n\n\n# Dockerfile을 구성하는 핵심 명령어\n\n## From - Dockerfile의 시작\n\nFrom 명령어는 어떤 이미지를 바탕으로 container를 빌드 할 것인지 명시합니다.\n\n```sh\n# redis:5.0-alpine 이미지를 바탕으로 빌드\nFrom redis:5.0-alpine\n```\n\n\n\n## CMD - Dockerfile의 끝\n\n\n* CMD명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.\n* 보통은 해당 프로그램을 실행시키는 명령을 사용합니다. ( ex> startup.sh)\n* CMD 명령은 Dockerfile에서 `단 한번만 사용`할 수 있습니다.\n\n\n\n명령어 예제\n\n```sh\n# 일반적인 실행 방법\nCMD [\"execute.sh\", \"param1\", \"param2\"] \n\n# Entrypoint 실행을 위한 Default Parameter - Entrypoint를 위한 파라미터를 제공\nCMD [\"param1\", \"param2\"] \n\n# shell form\nCMD execute.sh param1 param2\n```\n\n\n\n> CMD 구문 사용 시, 주의사항!\n>\n> ```sh\n> docker build -f ./dockerfile test\n> # Container 생성 시, docker run [이미지] [실행파일 또는 명령] 입니다.\n> docker run test echo \"test!\" \n> ```\n>\n> 위 예시 처럼 run 명령 시, 이미지 명 뒤에 `실행파일이나 명령어`가 오게되면 CMD에 설정된 명령은 `무시`되고 docker run 구문에서 사용된 명령이 **CMD 대신 실행**됩니다.\n\n\n\n## ENTRYPOINT\n\n* ENTRYPOINT명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.\n* 보통 스크립트를 실행하거나, 실행명령을 수행하게 됩니다.\n* ENTRYPOINT명령은 Dockerfile에서 `단 한번만 사용가능` 합니다.\n* 기본적으로 FROM에서 설정한 이미지의 /bin/sh 파일을 기반으로 실행되며, 이미지에 /bin/sh 파일이 없는 경우 실행이 불가능 합니다.\n\nENTRYPOINT 사용 예시\n```sh\nENTRYPOINT [\"docker-entrypoint.sh\"]\nENTRYPOINT [\"docker-entrypoint.sh\", \"--param1=true\", \"--param2=1\"]\n```\n\n```sh\n#run 명령의 options으로 구현한 방식\n#이러한 방식으로도 사용할 수 있지만, 추천하지 않는 안티패턴입니다.\ndocker run --entrypoint=\"docker-entrypoint.sh\" test\n```\n\n\n\n# Dockerfile에서 자주 사용하는 명령어\n\n## ADD - 파일을 Container에 추가\n\n* Container 내부에 Host OS의 파일을 추가하려고 할 때 사용합니다.\n* ADD <Host OS의 파일 경로> <Container의 파일 경로> 로 작성합니다.\n* <Container의 파일경로>란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.\n* <Host OS의 파일경로>는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가\n* <Container의 파일경로>는 `반드시 절대경로`로 사용합니다.\n* 와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.\n* Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀어서 Container에 추가됩니다.\n  (Container에 압축 해제 된 파일들이 추가됨)\n* 인터넷에 있는 파일 URL은 압축만 해제된 뒤, tar파일만 추가됩니다.\n* Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.\n* ADD로 추가되는 파일은 root root 기존 권한을 따릅니다 (단, URL로 추가된 파일의 경우 600)\n\n```sh\nADD ../file.sh /home/file.sh (x) #상위 디렉터리 사용x\nADD /home/user/file.sh /home/file.sh(x) #절대경로 사용x\nADD file.sh ../../file.sh (x) #<Container 파일경로>는 상대경로 사용x\n \nADD file.sh /home/file.sh (O) #가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.\nADD *.sh /home (O) # 와일드카드를 이용하여 복사 가능\nADD compress.tar.gz / # Container / 경로에 compress.tar파일의 풀어진 형태로 파일 추가\nADD http://file.co.kr/file/1234.tar.gz / # Container 내부의 / 경로에 1234.tar.gz 파일 추가\n```\n\n\n\n## COPY - 파일을 Container로 복사\n\n* ADD의 기능과 거의 유사합니다.\n* COPY <Host OS의 파일 경로> <Container의 파일 경로> 로 작성합니다.\n* <Container의 파일경로>란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.\n* <Host OS의 파일경로>는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가\n* <Container의 파일경로>는 `반드시 절대경로`로 사용합니다.\n* 와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.\n* Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀지않고 그대로 복사됩니다. **(ADD와 차이점)**\n* 인터넷에 있는 파일 URL은 사용 불가. **(ADD와 차이점)**\n* Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.\n* COPY로 추가되는 파일은 root root 기존 권한을 따릅니다\n\n```sh\nCOPY ../file.sh /home/file.sh (x) #상위 디렉터리 사용x\nCOPY /home/user/file.sh /home/file.sh(x) #절대경로 사용x\nCOPY file.sh ../../file.sh (x) #<Container 파일경로>는 상대경로 사용x\n \nCOPY file.sh /home/file.sh (O) #가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.\nCOPY *.sh /home (O) # 와일드카드를 이용하여 복사 가능\nCOPY compress.tar.gz / (O)# Container / 경로에 compress.tar파일이 복사\nCOPY http://file.co.kr/file/1234.tar.gz / (X) # COPY는 인터넷 파일URL 사용 불가\n```\n\n\n\n## RUN - Container 내부에서 명령 실행\n\n* 기본적으로 /bin/sh 파일로 실행됩니다.\n* Window의 경우 cmd 기반 명령을 수행합니다.\n\nDockerfile 내 RUN 명령어 사용법\n```sh\n# software 설치 명령 실행 (예시의 경우 yum이 Container내부에 설치되어야 합니다.)\nRUN yum -y install software  \n# /usr/local/redis directory 생성\nRUN mkdir -p /usr/local/redis \n# execute.sh 파일 실행 \nRUN [\"execute.sh\", \"param1\", \"param2\"] \n```\n\n\n\n명령어의 길이가 긴 경우 \\ 문자를 사용하여 append 가능합니다\n\n```sh\nRUN yum -y install software \\\n         echo \"install software\" \\\n         mkdir -p /usr/local/redis\n```\n\n\n\n## ENV - Container 내부에서 사용할 환경 변수 추가\n\nContainer는 Host OS와 독립된 공간이기 때문에 Container 내부에서 사용 할 환경변수를 추가할 수 있습니다.\n\n```sh\nENV LOCAL_PORT 80\nENV REDIS_HOME /usr/local/bin/redis\n```\n\n\n\n## EXPOSE - Container의 Port 설정\n\n* Host OS - Container와 통신할 포트를 설정\n* EXPOSE는 Host OS와 연결만 할 뿐 외부에 노출 되지는 않습니다.\n* 포트를 노출 하기 위해서는 docker run -p 또는 -P 옵션 사용해야 합니다.\n\n```sh\nEXPOSE 80   #Container 내의 Web Server Port 노출\nEXPOSE 6379 #Container 내의 Redis Server Port 노출\n \nEXPOSE 80 6379 #포트 여러개 노출\n```\n\n\n\n## VOLUME - 외부 볼륨 설정\n\n* Container 내부의 Directory와 Host OS의 Directory를 동기화 시키는 설정\n* log파일이나 설정파일은 보통 Container 내부에만 있는데 이를 Host OS에 동기화 하여 파일에 대한 접근이 가능하게 한다.\n\n```sh\n# Dockerfile volume 설정\nVOLUME [\"/data\", \"/var/log\"]\n\n# docker run 사용 시, volumn 설정\n# -v 옵션을 사용하여 설정 -v <host 디렉터리>:<컨테이너 디렉터리>\ndocker run -v /host/os/data:/container/data app \n```\n\n\n\n## WORKDIR - Container의 Work Directory 설정\n\n* RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉터리\n* 중간에 Directory가 변경되는 경우 바꿀수 있다.\n* 리눅스의 cd 명령어와 비슷하다.\n\n```sh\nWORKDIR /usr/local/bin\nADD redis.conf /usr/local/bin/redis.conf\n \nWORKDIR /usr/local\nADD redis.log /usr/local/redis.log\n\nWORKDIR var\nWORKDIR lib\nRUN touch file.sh # /var/lib/file.sh 생성\n```\n\n# 참고\n* http://pyrasis.com/book/DockerForTheReallyImpatient\n* https://docs.docker.com/engine/reference/builder\n","source":"_posts/2018-12-01-docker-3.md","raw":"---\nlayout: posts\ntitle: Docker기반 Redis 구축하기 - (3)Dockerfile\ndate: 2018-12-01 15:44:03\ncatalog: true\nCategories:\n- Docker\ntags:\n- Docker\ntypora-root-url: 2018-12-01-docker-3\ntypora-copy-images-to: 2018-12-01-docker-3\n---\n\n# Dockerfile 이란?\n\n이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소프트웨어에 대한 공식이미지도 있지만, Docker Hub 사용자들이 공식이미지를 바탕으로 커스터마이징하여 배포한 이미지도 등록되어 있습니다.\n\n어떻게 이미지를 빌드하고 배포 할 수 있었을까요? **Dockerfile을 이용한 이미지 빌드를 이용하면 가능합니다.**\n\nDockerfile은 이미지를 바탕으로 몇가지 명령을 실행 할 수 있는 로직을 담은 파일입니다.\nDockerfile을 통해 더 유연하게 이미지에 대한 설정을 변경할 수 있고, 그 설정을 이미지에 담아 배포 할 수 있습니다.\n\n물론 Docker run 구문에서 options을 사용하여 같은 기능을 하도록 구현 할 수 있지만, Dockerfile로 작성하게 되면 향후 유지보수가 쉬워지고 run 구문에 대한 options을 전부 기억하지 않아도 되는 장점이 있습니다.\n\n이번 장에서는 Dockerfile을 작성하는 명령어를 위주로 알아보겠으며, 간단한 예제 Dockerfile을 보도록 하겠습니다.\n\n\n\n# Dockerfile 사용방법\n\nDockerfile을 이용한 docker build\n\n```sh\n#dockerfile이 위치한 directory의 dockerfile을 가지고 build합니다.\ndocker build -f /path/to/dockerfile \n```\n\n\n\n# Dockerfile을 구성하는 핵심 명령어\n\n## From - Dockerfile의 시작\n\nFrom 명령어는 어떤 이미지를 바탕으로 container를 빌드 할 것인지 명시합니다.\n\n```sh\n# redis:5.0-alpine 이미지를 바탕으로 빌드\nFrom redis:5.0-alpine\n```\n\n\n\n## CMD - Dockerfile의 끝\n\n\n* CMD명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.\n* 보통은 해당 프로그램을 실행시키는 명령을 사용합니다. ( ex> startup.sh)\n* CMD 명령은 Dockerfile에서 `단 한번만 사용`할 수 있습니다.\n\n\n\n명령어 예제\n\n```sh\n# 일반적인 실행 방법\nCMD [\"execute.sh\", \"param1\", \"param2\"] \n\n# Entrypoint 실행을 위한 Default Parameter - Entrypoint를 위한 파라미터를 제공\nCMD [\"param1\", \"param2\"] \n\n# shell form\nCMD execute.sh param1 param2\n```\n\n\n\n> CMD 구문 사용 시, 주의사항!\n>\n> ```sh\n> docker build -f ./dockerfile test\n> # Container 생성 시, docker run [이미지] [실행파일 또는 명령] 입니다.\n> docker run test echo \"test!\" \n> ```\n>\n> 위 예시 처럼 run 명령 시, 이미지 명 뒤에 `실행파일이나 명령어`가 오게되면 CMD에 설정된 명령은 `무시`되고 docker run 구문에서 사용된 명령이 **CMD 대신 실행**됩니다.\n\n\n\n## ENTRYPOINT\n\n* ENTRYPOINT명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.\n* 보통 스크립트를 실행하거나, 실행명령을 수행하게 됩니다.\n* ENTRYPOINT명령은 Dockerfile에서 `단 한번만 사용가능` 합니다.\n* 기본적으로 FROM에서 설정한 이미지의 /bin/sh 파일을 기반으로 실행되며, 이미지에 /bin/sh 파일이 없는 경우 실행이 불가능 합니다.\n\nENTRYPOINT 사용 예시\n```sh\nENTRYPOINT [\"docker-entrypoint.sh\"]\nENTRYPOINT [\"docker-entrypoint.sh\", \"--param1=true\", \"--param2=1\"]\n```\n\n```sh\n#run 명령의 options으로 구현한 방식\n#이러한 방식으로도 사용할 수 있지만, 추천하지 않는 안티패턴입니다.\ndocker run --entrypoint=\"docker-entrypoint.sh\" test\n```\n\n\n\n# Dockerfile에서 자주 사용하는 명령어\n\n## ADD - 파일을 Container에 추가\n\n* Container 내부에 Host OS의 파일을 추가하려고 할 때 사용합니다.\n* ADD <Host OS의 파일 경로> <Container의 파일 경로> 로 작성합니다.\n* <Container의 파일경로>란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.\n* <Host OS의 파일경로>는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가\n* <Container의 파일경로>는 `반드시 절대경로`로 사용합니다.\n* 와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.\n* Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀어서 Container에 추가됩니다.\n  (Container에 압축 해제 된 파일들이 추가됨)\n* 인터넷에 있는 파일 URL은 압축만 해제된 뒤, tar파일만 추가됩니다.\n* Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.\n* ADD로 추가되는 파일은 root root 기존 권한을 따릅니다 (단, URL로 추가된 파일의 경우 600)\n\n```sh\nADD ../file.sh /home/file.sh (x) #상위 디렉터리 사용x\nADD /home/user/file.sh /home/file.sh(x) #절대경로 사용x\nADD file.sh ../../file.sh (x) #<Container 파일경로>는 상대경로 사용x\n \nADD file.sh /home/file.sh (O) #가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.\nADD *.sh /home (O) # 와일드카드를 이용하여 복사 가능\nADD compress.tar.gz / # Container / 경로에 compress.tar파일의 풀어진 형태로 파일 추가\nADD http://file.co.kr/file/1234.tar.gz / # Container 내부의 / 경로에 1234.tar.gz 파일 추가\n```\n\n\n\n## COPY - 파일을 Container로 복사\n\n* ADD의 기능과 거의 유사합니다.\n* COPY <Host OS의 파일 경로> <Container의 파일 경로> 로 작성합니다.\n* <Container의 파일경로>란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.\n* <Host OS의 파일경로>는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가\n* <Container의 파일경로>는 `반드시 절대경로`로 사용합니다.\n* 와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.\n* Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀지않고 그대로 복사됩니다. **(ADD와 차이점)**\n* 인터넷에 있는 파일 URL은 사용 불가. **(ADD와 차이점)**\n* Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.\n* COPY로 추가되는 파일은 root root 기존 권한을 따릅니다\n\n```sh\nCOPY ../file.sh /home/file.sh (x) #상위 디렉터리 사용x\nCOPY /home/user/file.sh /home/file.sh(x) #절대경로 사용x\nCOPY file.sh ../../file.sh (x) #<Container 파일경로>는 상대경로 사용x\n \nCOPY file.sh /home/file.sh (O) #가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.\nCOPY *.sh /home (O) # 와일드카드를 이용하여 복사 가능\nCOPY compress.tar.gz / (O)# Container / 경로에 compress.tar파일이 복사\nCOPY http://file.co.kr/file/1234.tar.gz / (X) # COPY는 인터넷 파일URL 사용 불가\n```\n\n\n\n## RUN - Container 내부에서 명령 실행\n\n* 기본적으로 /bin/sh 파일로 실행됩니다.\n* Window의 경우 cmd 기반 명령을 수행합니다.\n\nDockerfile 내 RUN 명령어 사용법\n```sh\n# software 설치 명령 실행 (예시의 경우 yum이 Container내부에 설치되어야 합니다.)\nRUN yum -y install software  \n# /usr/local/redis directory 생성\nRUN mkdir -p /usr/local/redis \n# execute.sh 파일 실행 \nRUN [\"execute.sh\", \"param1\", \"param2\"] \n```\n\n\n\n명령어의 길이가 긴 경우 \\ 문자를 사용하여 append 가능합니다\n\n```sh\nRUN yum -y install software \\\n         echo \"install software\" \\\n         mkdir -p /usr/local/redis\n```\n\n\n\n## ENV - Container 내부에서 사용할 환경 변수 추가\n\nContainer는 Host OS와 독립된 공간이기 때문에 Container 내부에서 사용 할 환경변수를 추가할 수 있습니다.\n\n```sh\nENV LOCAL_PORT 80\nENV REDIS_HOME /usr/local/bin/redis\n```\n\n\n\n## EXPOSE - Container의 Port 설정\n\n* Host OS - Container와 통신할 포트를 설정\n* EXPOSE는 Host OS와 연결만 할 뿐 외부에 노출 되지는 않습니다.\n* 포트를 노출 하기 위해서는 docker run -p 또는 -P 옵션 사용해야 합니다.\n\n```sh\nEXPOSE 80   #Container 내의 Web Server Port 노출\nEXPOSE 6379 #Container 내의 Redis Server Port 노출\n \nEXPOSE 80 6379 #포트 여러개 노출\n```\n\n\n\n## VOLUME - 외부 볼륨 설정\n\n* Container 내부의 Directory와 Host OS의 Directory를 동기화 시키는 설정\n* log파일이나 설정파일은 보통 Container 내부에만 있는데 이를 Host OS에 동기화 하여 파일에 대한 접근이 가능하게 한다.\n\n```sh\n# Dockerfile volume 설정\nVOLUME [\"/data\", \"/var/log\"]\n\n# docker run 사용 시, volumn 설정\n# -v 옵션을 사용하여 설정 -v <host 디렉터리>:<컨테이너 디렉터리>\ndocker run -v /host/os/data:/container/data app \n```\n\n\n\n## WORKDIR - Container의 Work Directory 설정\n\n* RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉터리\n* 중간에 Directory가 변경되는 경우 바꿀수 있다.\n* 리눅스의 cd 명령어와 비슷하다.\n\n```sh\nWORKDIR /usr/local/bin\nADD redis.conf /usr/local/bin/redis.conf\n \nWORKDIR /usr/local\nADD redis.log /usr/local/redis.log\n\nWORKDIR var\nWORKDIR lib\nRUN touch file.sh # /var/lib/file.sh 생성\n```\n\n# 참고\n* http://pyrasis.com/book/DockerForTheReallyImpatient\n* https://docs.docker.com/engine/reference/builder\n","slug":"2018-12-01-docker-3","published":1,"updated":"2018-12-01T07:43:13.616Z","comments":1,"photos":[],"link":"","_id":"cjp55h5iq001i4f1tygqs9cn7","content":"<h1><span id=\"dockerfile-이란\">Dockerfile 이란?</span></h1>\n<p>이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소프트웨어에 대한 공식이미지도 있지만, Docker Hub 사용자들이 공식이미지를 바탕으로 커스터마이징하여 배포한 이미지도 등록되어 있습니다.</p>\n<p>어떻게 이미지를 빌드하고 배포 할 수 있었을까요? <strong>Dockerfile을 이용한 이미지 빌드를 이용하면 가능합니다.</strong></p>\n<p>Dockerfile은 이미지를 바탕으로 몇가지 명령을 실행 할 수 있는 로직을 담은 파일입니다.<br>\nDockerfile을 통해 더 유연하게 이미지에 대한 설정을 변경할 수 있고, 그 설정을 이미지에 담아 배포 할 수 있습니다.</p>\n<p>물론 Docker run 구문에서 options을 사용하여 같은 기능을 하도록 구현 할 수 있지만, Dockerfile로 작성하게 되면 향후 유지보수가 쉬워지고 run 구문에 대한 options을 전부 기억하지 않아도 되는 장점이 있습니다.</p>\n<p>이번 장에서는 Dockerfile을 작성하는 명령어를 위주로 알아보겠으며, 간단한 예제 Dockerfile을 보도록 하겠습니다.</p>\n<h1><span id=\"dockerfile-사용방법\">Dockerfile 사용방법</span></h1>\n<p>Dockerfile을 이용한 docker build</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dockerfile이 위치한 directory의 dockerfile을 가지고 build합니다.</span></span><br><span class=\"line\">docker build -f /path/to/dockerfile</span><br></pre></td></tr></table></figure>\n<h1><span id=\"dockerfile을-구성하는-핵심-명령어\">Dockerfile을 구성하는 핵심 명령어</span></h1>\n<h2><span id=\"from-dockerfile의-시작\">From - Dockerfile의 시작</span></h2>\n<p>From 명령어는 어떤 이미지를 바탕으로 container를 빌드 할 것인지 명시합니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis:5.0-alpine 이미지를 바탕으로 빌드</span></span><br><span class=\"line\">From redis:5.0-alpine</span><br></pre></td></tr></table></figure>\n<h2><span id=\"cmd-dockerfile의-끝\">CMD - Dockerfile의 끝</span></h2>\n<ul>\n<li>CMD명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li>\n<li>보통은 해당 프로그램을 실행시키는 명령을 사용합니다. ( ex&gt; <a href=\"http://startup.sh\" target=\"_blank\" rel=\"noopener\">startup.sh</a>)</li>\n<li>CMD 명령은 Dockerfile에서 <code>단 한번만 사용</code>할 수 있습니다.</li>\n</ul>\n<p>명령어 예제</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 일반적인 실행 방법</span></span><br><span class=\"line\">CMD [<span class=\"string\">\"execute.sh\"</span>, <span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Entrypoint 실행을 위한 Default Parameter - Entrypoint를 위한 파라미터를 제공</span></span><br><span class=\"line\">CMD [<span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># shell form</span></span><br><span class=\"line\">CMD execute.sh param1 param2</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>CMD 구문 사용 시, 주의사항!</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; docker build -f ./dockerfile <span class=\"built_in\">test</span></span><br><span class=\"line\">&gt; <span class=\"comment\"># Container 생성 시, docker run [이미지] [실행파일 또는 명령] 입니다.</span></span><br><span class=\"line\">&gt; docker run <span class=\"built_in\">test</span> <span class=\"built_in\">echo</span> <span class=\"string\">\"test!\"</span> </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>위 예시 처럼 run 명령 시, 이미지 명 뒤에 <code>실행파일이나 명령어</code>가 오게되면 CMD에 설정된 명령은 <code>무시</code>되고 docker run 구문에서 사용된 명령이 <strong>CMD 대신 실행</strong>됩니다.</p>\n</blockquote>\n<h2><span id=\"entrypoint\">ENTRYPOINT</span></h2>\n<ul>\n<li>ENTRYPOINT명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li>\n<li>보통 스크립트를 실행하거나, 실행명령을 수행하게 됩니다.</li>\n<li>ENTRYPOINT명령은 Dockerfile에서 <code>단 한번만 사용가능</code> 합니다.</li>\n<li>기본적으로 FROM에서 설정한 이미지의 /bin/sh 파일을 기반으로 실행되며, 이미지에 /bin/sh 파일이 없는 경우 실행이 불가능 합니다.</li>\n</ul>\n<p>ENTRYPOINT 사용 예시</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"docker-entrypoint.sh\"</span>]</span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"docker-entrypoint.sh\"</span>, <span class=\"string\">\"--param1=true\"</span>, <span class=\"string\">\"--param2=1\"</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#run 명령의 options으로 구현한 방식</span></span><br><span class=\"line\"><span class=\"comment\">#이러한 방식으로도 사용할 수 있지만, 추천하지 않는 안티패턴입니다.</span></span><br><span class=\"line\">docker run --entrypoint=<span class=\"string\">\"docker-entrypoint.sh\"</span> <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"dockerfile에서-자주-사용하는-명령어\">Dockerfile에서 자주 사용하는 명령어</span></h1>\n<h2><span id=\"add-파일을-container에-추가\">ADD - 파일을 Container에 추가</span></h2>\n<ul>\n<li>Container 내부에 Host OS의 파일을 추가하려고 할 때 사용합니다.</li>\n<li>ADD &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li>\n<li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li>\n<li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li>\n<li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li>\n<li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li>\n<li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀어서 Container에 추가됩니다.<br>\n(Container에 압축 해제 된 파일들이 추가됨)</li>\n<li>인터넷에 있는 파일 URL은 압축만 해제된 뒤, tar파일만 추가됩니다.</li>\n<li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li>\n<li>ADD로 추가되는 파일은 root root 기존 권한을 따릅니다 (단, URL로 추가된 파일의 경우 600)</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADD ../file.sh /home/file.sh (x) <span class=\"comment\">#상위 디렉터리 사용x</span></span><br><span class=\"line\">ADD /home/user/file.sh /home/file.sh(x) <span class=\"comment\">#절대경로 사용x</span></span><br><span class=\"line\">ADD file.sh ../../file.sh (x) <span class=\"comment\">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class=\"line\"> </span><br><span class=\"line\">ADD file.sh /home/file.sh (O) <span class=\"comment\">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class=\"line\">ADD *.sh /home (O) <span class=\"comment\"># 와일드카드를 이용하여 복사 가능</span></span><br><span class=\"line\">ADD compress.tar.gz / <span class=\"comment\"># Container / 경로에 compress.tar파일의 풀어진 형태로 파일 추가</span></span><br><span class=\"line\">ADD http://file.co.kr/file/1234.tar.gz / <span class=\"comment\"># Container 내부의 / 경로에 1234.tar.gz 파일 추가</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"copy-파일을-container로-복사\">COPY - 파일을 Container로 복사</span></h2>\n<ul>\n<li>ADD의 기능과 거의 유사합니다.</li>\n<li>COPY &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li>\n<li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li>\n<li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li>\n<li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li>\n<li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li>\n<li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀지않고 그대로 복사됩니다. <strong>(ADD와 차이점)</strong></li>\n<li>인터넷에 있는 파일 URL은 사용 불가. <strong>(ADD와 차이점)</strong></li>\n<li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li>\n<li>COPY로 추가되는 파일은 root root 기존 권한을 따릅니다</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY ../file.sh /home/file.sh (x) <span class=\"comment\">#상위 디렉터리 사용x</span></span><br><span class=\"line\">COPY /home/user/file.sh /home/file.sh(x) <span class=\"comment\">#절대경로 사용x</span></span><br><span class=\"line\">COPY file.sh ../../file.sh (x) <span class=\"comment\">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class=\"line\"> </span><br><span class=\"line\">COPY file.sh /home/file.sh (O) <span class=\"comment\">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class=\"line\">COPY *.sh /home (O) <span class=\"comment\"># 와일드카드를 이용하여 복사 가능</span></span><br><span class=\"line\">COPY compress.tar.gz / (O)<span class=\"comment\"># Container / 경로에 compress.tar파일이 복사</span></span><br><span class=\"line\">COPY http://file.co.kr/file/1234.tar.gz / (X) <span class=\"comment\"># COPY는 인터넷 파일URL 사용 불가</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"run-container-내부에서-명령-실행\">RUN - Container 내부에서 명령 실행</span></h2>\n<ul>\n<li>기본적으로 /bin/sh 파일로 실행됩니다.</li>\n<li>Window의 경우 cmd 기반 명령을 수행합니다.</li>\n</ul>\n<p>Dockerfile 내 RUN 명령어 사용법</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># software 설치 명령 실행 (예시의 경우 yum이 Container내부에 설치되어야 합니다.)</span></span><br><span class=\"line\">RUN yum -y install software  </span><br><span class=\"line\"><span class=\"comment\"># /usr/local/redis directory 생성</span></span><br><span class=\"line\">RUN mkdir -p /usr/<span class=\"built_in\">local</span>/redis </span><br><span class=\"line\"><span class=\"comment\"># execute.sh 파일 실행 </span></span><br><span class=\"line\">RUN [<span class=\"string\">\"execute.sh\"</span>, <span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>]</span><br></pre></td></tr></table></figure>\n<p>명령어의 길이가 긴 경우 \\ 문자를 사용하여 append 가능합니다</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN yum -y install software \\</span><br><span class=\"line\">         <span class=\"built_in\">echo</span> <span class=\"string\">\"install software\"</span> \\</span><br><span class=\"line\">         mkdir -p /usr/<span class=\"built_in\">local</span>/redis</span><br></pre></td></tr></table></figure>\n<h2><span id=\"env-container-내부에서-사용할-환경-변수-추가\">ENV - Container 내부에서 사용할 환경 변수 추가</span></h2>\n<p>Container는 Host OS와 독립된 공간이기 때문에 Container 내부에서 사용 할 환경변수를 추가할 수 있습니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV LOCAL_PORT 80</span><br><span class=\"line\">ENV REDIS_HOME /usr/<span class=\"built_in\">local</span>/bin/redis</span><br></pre></td></tr></table></figure>\n<h2><span id=\"expose-container의-port-설정\">EXPOSE - Container의 Port 설정</span></h2>\n<ul>\n<li>Host OS - Container와 통신할 포트를 설정</li>\n<li>EXPOSE는 Host OS와 연결만 할 뿐 외부에 노출 되지는 않습니다.</li>\n<li>포트를 노출 하기 위해서는 docker run -p 또는 -P 옵션 사용해야 합니다.</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPOSE 80   <span class=\"comment\">#Container 내의 Web Server Port 노출</span></span><br><span class=\"line\">EXPOSE 6379 <span class=\"comment\">#Container 내의 Redis Server Port 노출</span></span><br><span class=\"line\"> </span><br><span class=\"line\">EXPOSE 80 6379 <span class=\"comment\">#포트 여러개 노출</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"volume-외부-볼륨-설정\">VOLUME - 외부 볼륨 설정</span></h2>\n<ul>\n<li>Container 내부의 Directory와 Host OS의 Directory를 동기화 시키는 설정</li>\n<li>log파일이나 설정파일은 보통 Container 내부에만 있는데 이를 Host OS에 동기화 하여 파일에 대한 접근이 가능하게 한다.</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Dockerfile volume 설정</span></span><br><span class=\"line\">VOLUME [<span class=\"string\">\"/data\"</span>, <span class=\"string\">\"/var/log\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># docker run 사용 시, volumn 설정</span></span><br><span class=\"line\"><span class=\"comment\"># -v 옵션을 사용하여 설정 -v &lt;host 디렉터리&gt;:&lt;컨테이너 디렉터리&gt;</span></span><br><span class=\"line\">docker run -v /host/os/data:/container/data app</span><br></pre></td></tr></table></figure>\n<h2><span id=\"workdir-container의-work-directory-설정\">WORKDIR - Container의 Work Directory 설정</span></h2>\n<ul>\n<li>RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉터리</li>\n<li>중간에 Directory가 변경되는 경우 바꿀수 있다.</li>\n<li>리눅스의 cd 명령어와 비슷하다.</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR /usr/<span class=\"built_in\">local</span>/bin</span><br><span class=\"line\">ADD redis.conf /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\"> </span><br><span class=\"line\">WORKDIR /usr/<span class=\"built_in\">local</span></span><br><span class=\"line\">ADD redis.log /usr/<span class=\"built_in\">local</span>/redis.log</span><br><span class=\"line\"></span><br><span class=\"line\">WORKDIR var</span><br><span class=\"line\">WORKDIR lib</span><br><span class=\"line\">RUN touch file.sh <span class=\"comment\"># /var/lib/file.sh 생성</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"참고\">참고</span></h1>\n<ul>\n<li><a href=\"http://pyrasis.com/book/DockerForTheReallyImpatient\" target=\"_blank\" rel=\"noopener\">http://pyrasis.com/book/DockerForTheReallyImpatient</a></li>\n<li><a href=\"https://docs.docker.com/engine/reference/builder\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/reference/builder</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>Dockerfile 이란?</h1>\n<p>이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소프트웨어에 대한 공식이미지도 있지만, Docker Hub 사용자들이 공식이미지를 바탕으로 커스터마이징하여 배포한 이미지도 등록되어 있습니다.</p>\n<p>어떻게 이미지를 빌드하고 배포 할 수 있었을까요? <strong>Dockerfile을 이용한 이미지 빌드를 이용하면 가능합니다.</strong></p>\n<p>Dockerfile은 이미지를 바탕으로 몇가지 명령을 실행 할 수 있는 로직을 담은 파일입니다.<br>\nDockerfile을 통해 더 유연하게 이미지에 대한 설정을 변경할 수 있고, 그 설정을 이미지에 담아 배포 할 수 있습니다.</p>\n<p>물론 Docker run 구문에서 options을 사용하여 같은 기능을 하도록 구현 할 수 있지만, Dockerfile로 작성하게 되면 향후 유지보수가 쉬워지고 run 구문에 대한 options을 전부 기억하지 않아도 되는 장점이 있습니다.</p>\n<p>이번 장에서는 Dockerfile을 작성하는 명령어를 위주로 알아보겠으며, 간단한 예제 Dockerfile을 보도록 하겠습니다.</p>\n<h1>Dockerfile 사용방법</h1>\n<p>Dockerfile을 이용한 docker build</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dockerfile이 위치한 directory의 dockerfile을 가지고 build합니다.</span></span><br><span class=\"line\">docker build -f /path/to/dockerfile</span><br></pre></td></tr></table></figure>\n<h1>Dockerfile을 구성하는 핵심 명령어</h1>\n<h2>From - Dockerfile의 시작</h2>\n<p>From 명령어는 어떤 이미지를 바탕으로 container를 빌드 할 것인지 명시합니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis:5.0-alpine 이미지를 바탕으로 빌드</span></span><br><span class=\"line\">From redis:5.0-alpine</span><br></pre></td></tr></table></figure>\n<h2>CMD - Dockerfile의 끝</h2>\n<ul>\n<li>CMD명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li>\n<li>보통은 해당 프로그램을 실행시키는 명령을 사용합니다. ( ex&gt; <a href=\"http://startup.sh\" target=\"_blank\" rel=\"noopener\">startup.sh</a>)</li>\n<li>CMD 명령은 Dockerfile에서 <code>단 한번만 사용</code>할 수 있습니다.</li>\n</ul>\n<p>명령어 예제</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 일반적인 실행 방법</span></span><br><span class=\"line\">CMD [<span class=\"string\">\"execute.sh\"</span>, <span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Entrypoint 실행을 위한 Default Parameter - Entrypoint를 위한 파라미터를 제공</span></span><br><span class=\"line\">CMD [<span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># shell form</span></span><br><span class=\"line\">CMD execute.sh param1 param2</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>CMD 구문 사용 시, 주의사항!</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; docker build -f ./dockerfile <span class=\"built_in\">test</span></span><br><span class=\"line\">&gt; <span class=\"comment\"># Container 생성 시, docker run [이미지] [실행파일 또는 명령] 입니다.</span></span><br><span class=\"line\">&gt; docker run <span class=\"built_in\">test</span> <span class=\"built_in\">echo</span> <span class=\"string\">\"test!\"</span> </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>위 예시 처럼 run 명령 시, 이미지 명 뒤에 <code>실행파일이나 명령어</code>가 오게되면 CMD에 설정된 명령은 <code>무시</code>되고 docker run 구문에서 사용된 명령이 <strong>CMD 대신 실행</strong>됩니다.</p>\n</blockquote>\n<h2>ENTRYPOINT</h2>\n<ul>\n<li>ENTRYPOINT명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li>\n<li>보통 스크립트를 실행하거나, 실행명령을 수행하게 됩니다.</li>\n<li>ENTRYPOINT명령은 Dockerfile에서 <code>단 한번만 사용가능</code> 합니다.</li>\n<li>기본적으로 FROM에서 설정한 이미지의 /bin/sh 파일을 기반으로 실행되며, 이미지에 /bin/sh 파일이 없는 경우 실행이 불가능 합니다.</li>\n</ul>\n<p>ENTRYPOINT 사용 예시</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"docker-entrypoint.sh\"</span>]</span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"docker-entrypoint.sh\"</span>, <span class=\"string\">\"--param1=true\"</span>, <span class=\"string\">\"--param2=1\"</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#run 명령의 options으로 구현한 방식</span></span><br><span class=\"line\"><span class=\"comment\">#이러한 방식으로도 사용할 수 있지만, 추천하지 않는 안티패턴입니다.</span></span><br><span class=\"line\">docker run --entrypoint=<span class=\"string\">\"docker-entrypoint.sh\"</span> <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<h1>Dockerfile에서 자주 사용하는 명령어</h1>\n<h2>ADD - 파일을 Container에 추가</h2>\n<ul>\n<li>Container 내부에 Host OS의 파일을 추가하려고 할 때 사용합니다.</li>\n<li>ADD &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li>\n<li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li>\n<li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li>\n<li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li>\n<li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li>\n<li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀어서 Container에 추가됩니다.<br>\n(Container에 압축 해제 된 파일들이 추가됨)</li>\n<li>인터넷에 있는 파일 URL은 압축만 해제된 뒤, tar파일만 추가됩니다.</li>\n<li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li>\n<li>ADD로 추가되는 파일은 root root 기존 권한을 따릅니다 (단, URL로 추가된 파일의 경우 600)</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADD ../file.sh /home/file.sh (x) <span class=\"comment\">#상위 디렉터리 사용x</span></span><br><span class=\"line\">ADD /home/user/file.sh /home/file.sh(x) <span class=\"comment\">#절대경로 사용x</span></span><br><span class=\"line\">ADD file.sh ../../file.sh (x) <span class=\"comment\">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class=\"line\"> </span><br><span class=\"line\">ADD file.sh /home/file.sh (O) <span class=\"comment\">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class=\"line\">ADD *.sh /home (O) <span class=\"comment\"># 와일드카드를 이용하여 복사 가능</span></span><br><span class=\"line\">ADD compress.tar.gz / <span class=\"comment\"># Container / 경로에 compress.tar파일의 풀어진 형태로 파일 추가</span></span><br><span class=\"line\">ADD http://file.co.kr/file/1234.tar.gz / <span class=\"comment\"># Container 내부의 / 경로에 1234.tar.gz 파일 추가</span></span><br></pre></td></tr></table></figure>\n<h2>COPY - 파일을 Container로 복사</h2>\n<ul>\n<li>ADD의 기능과 거의 유사합니다.</li>\n<li>COPY &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li>\n<li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li>\n<li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li>\n<li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li>\n<li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li>\n<li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀지않고 그대로 복사됩니다. <strong>(ADD와 차이점)</strong></li>\n<li>인터넷에 있는 파일 URL은 사용 불가. <strong>(ADD와 차이점)</strong></li>\n<li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li>\n<li>COPY로 추가되는 파일은 root root 기존 권한을 따릅니다</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY ../file.sh /home/file.sh (x) <span class=\"comment\">#상위 디렉터리 사용x</span></span><br><span class=\"line\">COPY /home/user/file.sh /home/file.sh(x) <span class=\"comment\">#절대경로 사용x</span></span><br><span class=\"line\">COPY file.sh ../../file.sh (x) <span class=\"comment\">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class=\"line\"> </span><br><span class=\"line\">COPY file.sh /home/file.sh (O) <span class=\"comment\">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class=\"line\">COPY *.sh /home (O) <span class=\"comment\"># 와일드카드를 이용하여 복사 가능</span></span><br><span class=\"line\">COPY compress.tar.gz / (O)<span class=\"comment\"># Container / 경로에 compress.tar파일이 복사</span></span><br><span class=\"line\">COPY http://file.co.kr/file/1234.tar.gz / (X) <span class=\"comment\"># COPY는 인터넷 파일URL 사용 불가</span></span><br></pre></td></tr></table></figure>\n<h2>RUN - Container 내부에서 명령 실행</h2>\n<ul>\n<li>기본적으로 /bin/sh 파일로 실행됩니다.</li>\n<li>Window의 경우 cmd 기반 명령을 수행합니다.</li>\n</ul>\n<p>Dockerfile 내 RUN 명령어 사용법</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># software 설치 명령 실행 (예시의 경우 yum이 Container내부에 설치되어야 합니다.)</span></span><br><span class=\"line\">RUN yum -y install software  </span><br><span class=\"line\"><span class=\"comment\"># /usr/local/redis directory 생성</span></span><br><span class=\"line\">RUN mkdir -p /usr/<span class=\"built_in\">local</span>/redis </span><br><span class=\"line\"><span class=\"comment\"># execute.sh 파일 실행 </span></span><br><span class=\"line\">RUN [<span class=\"string\">\"execute.sh\"</span>, <span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>]</span><br></pre></td></tr></table></figure>\n<p>명령어의 길이가 긴 경우 \\ 문자를 사용하여 append 가능합니다</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN yum -y install software \\</span><br><span class=\"line\">         <span class=\"built_in\">echo</span> <span class=\"string\">\"install software\"</span> \\</span><br><span class=\"line\">         mkdir -p /usr/<span class=\"built_in\">local</span>/redis</span><br></pre></td></tr></table></figure>\n<h2>ENV - Container 내부에서 사용할 환경 변수 추가</h2>\n<p>Container는 Host OS와 독립된 공간이기 때문에 Container 내부에서 사용 할 환경변수를 추가할 수 있습니다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV LOCAL_PORT 80</span><br><span class=\"line\">ENV REDIS_HOME /usr/<span class=\"built_in\">local</span>/bin/redis</span><br></pre></td></tr></table></figure>\n<h2>EXPOSE - Container의 Port 설정</h2>\n<ul>\n<li>Host OS - Container와 통신할 포트를 설정</li>\n<li>EXPOSE는 Host OS와 연결만 할 뿐 외부에 노출 되지는 않습니다.</li>\n<li>포트를 노출 하기 위해서는 docker run -p 또는 -P 옵션 사용해야 합니다.</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPOSE 80   <span class=\"comment\">#Container 내의 Web Server Port 노출</span></span><br><span class=\"line\">EXPOSE 6379 <span class=\"comment\">#Container 내의 Redis Server Port 노출</span></span><br><span class=\"line\"> </span><br><span class=\"line\">EXPOSE 80 6379 <span class=\"comment\">#포트 여러개 노출</span></span><br></pre></td></tr></table></figure>\n<h2>VOLUME - 외부 볼륨 설정</h2>\n<ul>\n<li>Container 내부의 Directory와 Host OS의 Directory를 동기화 시키는 설정</li>\n<li>log파일이나 설정파일은 보통 Container 내부에만 있는데 이를 Host OS에 동기화 하여 파일에 대한 접근이 가능하게 한다.</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Dockerfile volume 설정</span></span><br><span class=\"line\">VOLUME [<span class=\"string\">\"/data\"</span>, <span class=\"string\">\"/var/log\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># docker run 사용 시, volumn 설정</span></span><br><span class=\"line\"><span class=\"comment\"># -v 옵션을 사용하여 설정 -v &lt;host 디렉터리&gt;:&lt;컨테이너 디렉터리&gt;</span></span><br><span class=\"line\">docker run -v /host/os/data:/container/data app</span><br></pre></td></tr></table></figure>\n<h2>WORKDIR - Container의 Work Directory 설정</h2>\n<ul>\n<li>RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉터리</li>\n<li>중간에 Directory가 변경되는 경우 바꿀수 있다.</li>\n<li>리눅스의 cd 명령어와 비슷하다.</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR /usr/<span class=\"built_in\">local</span>/bin</span><br><span class=\"line\">ADD redis.conf /usr/<span class=\"built_in\">local</span>/bin/redis.conf</span><br><span class=\"line\"> </span><br><span class=\"line\">WORKDIR /usr/<span class=\"built_in\">local</span></span><br><span class=\"line\">ADD redis.log /usr/<span class=\"built_in\">local</span>/redis.log</span><br><span class=\"line\"></span><br><span class=\"line\">WORKDIR var</span><br><span class=\"line\">WORKDIR lib</span><br><span class=\"line\">RUN touch file.sh <span class=\"comment\"># /var/lib/file.sh 생성</span></span><br></pre></td></tr></table></figure>\n<h1>참고</h1>\n<ul>\n<li><a href=\"http://pyrasis.com/book/DockerForTheReallyImpatient\" target=\"_blank\" rel=\"noopener\">http://pyrasis.com/book/DockerForTheReallyImpatient</a></li>\n<li><a href=\"https://docs.docker.com/engine/reference/builder\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/reference/builder</a></li>\n</ul>\n"},{"title":"Cache에 대하여.. (Spring+EHCache)","subtitle":null,"catalog":true,"Categories":["Spring"],"typora-root-url":"./2018-10-03-spring-ehcache","typora-copy-images-to":"./2018-10-03-spring-ehcache","date":"2018-11-07T14:33:38.000Z","header-img":null,"_content":"\n\n\n# 들어가며..\n\n엔터프라이즈 급 Application에서는 DBMS의 부하를 줄이고, 성능을 높이기 위해 캐시(Cache)를 사용한다. 우리 회사에서도 EHCache, Redis를 사용하지만, EHCache쪽은 공부한 적이 없어서 이번 기회에 정리하면서 공부해 보게 되었다.\n대부분 `docs.spring.io`의 문서를 번역한 내용을 위주로 정리 하였다.\n\n\n\n# Cache란?\n\nCache의 사전적인 의미를 알아보기 위해 위키백과를 검색해 보았다.\n\n> **캐시**(cache, [문화어](https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4): 캐쉬, 고속완충기, 고속완충기억기)는 [컴퓨터 과학](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 캐시는 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.\n>\n> 캐시는 시스템의 효율성을 위해 여러 분야에서 두루 쓰인다.\n\n결국 캐시란, 반복적으로 데이터를 불러올 때 지속적으로 DBMS 혹은 서버에 요청하는 것이 아닌 메모리에 데이터를 저장하였다가 데이터를 불러다가 쓰는 것을 의미한다. 따라서 서버나 DBMS에 부담을 덜어주고, 엄청 빠르기 때문에 많은 시스템에서 사용하고 있다. \n대표적으로 Browser Cache, Apacha Cache, DNS Cache등 여러가지 형태로 캐시가 사용되고 있다.\n\nEHCache 사이트에서는 캐시에 대한 용어를 이렇게 정리 하였다.\n\n* **Cache** : 캐시는 `미래에 필요할 것이고 빠르게 검색할 수 있는 데이터를 담은 저장소` 라고 정의 한다. 캐시는 다른 곳에 있는 데이터를 복제하거나, 계산 결과를 임시적으로 저장하는 데이터 저장소이다. 캐시에 있는 데이터는 시간과 자원 면에서 최소한의 비용으로 반복적으로 접근 할 수 있다.\n* **Cache Hit** : 데이터 요소가 캐시에 요청되고 해당 키에 대한 요소가 존재하면 Cache Hit (또는 단순히 'Hit')라고 한다.\n* **Cache Miss**:데이터 요소가 캐시에 요청되고 해당 키에 대해 요소가 존재하지 않으면 Cache Miss (또는 단순히 'Miss')라고 한다.\n* **System-of-record** : 데이터에 대한 신뢰할 수있는 정보원. 이것을 흔히 시스템 레코드(SOR)이라고 한다. 캐시는 시스템 레코드에서 검색되거나 시스템 레코드에 저장된 데이터의 로컬 사본으로 작동된다. Ehcache를 사용하기 위해 SOR은 데이터베이스로 간주된다.\n\n\n# Long Tail 법칙\n\n![Long Tail](./17110B4350CC5EC51D.jpeg)\n\n\n\n20%의 요구가 시스템 리소스의 대부분을 잡아먹는다는 법칙. \n자주 사용되는 `20%의 기능에 캐시를 이용`하면 리소스 사용량을 대폭 줄일 수 있어, `시스템의 성능을 대폭 향상` 시킬 수 있다.\n\n\n\n# Local Cache vs Global Cache\n\n* Local Cache\n  * Local 장비 내에서만 사용 되는 캐시\n  * Local 장비의 Resource를 이용한다 (Memory, Disk)\n  * Local에서 작동 되기 때문에 속도가 빠르다.\n  * Local에서만 작동되기 때문에 다른 서버와 데이터 공유가 어렵다\n\n* Global Cache\n  * 여러 서버에서 Cache Server에 접근하여 사용하는 캐시\n  * 데이터를 분산하여 저장 할 수 있다. \n    * Replication - 데이터를 복제\n    * Sharding - 데이터를 분산하여 저장\n  * Local Cache에 비해 상대적으로 느리다 (네트워크 트래픽)\n  * 별도의 Cache Server를 이용하기 때문에 서버 간 데이터 공유가 쉽다.\n\n\n\n# Spring Cache Abstraction\n\nSpring 3.1버전부터 Spring Application에 캐시를 쉽게 추가할 수 있도록 기능을 제공하게 되었다. 유사 트랜잭션을 지원하고, 사용하고 있는 코드(메소드)에 영향을 최소화 하면서 일관된 방법으로 캐시를 사용 할 수 있게 되었다.\n\nSpring에서 캐시 추상화는 메소드를 통해 기능을 지원하는데, 메소드가 실행되는 시점에 파라미터에 대한 캐시 존재 여부를 판단하여 없으면 캐시를 등록하게 되고, 캐시가 있으면 메소드를 실행 시키지 않고 캐시 데이터를 Return 해주게 된다.\n\nSpring 캐시 추상화를 지원하기 때문에 개발자는 별도의 캐시 로직을 작성하지 않아도 된다. 하지만 캐시를 저장하는 저장소는 직접 설정을 해주어야 한다. Spring에서는 `CacheManager`라는 Interface를 제공하여 캐시를 구현하도록 하고 있다.\n\n<br/>\n\n~~~xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n~~~\n\nSpring Boot에서는 `spring-boot-starter-cache` Artifact를 추가 하여 CacheManager를 구성 할 수 있다. \n기본적으로 별도의 추가적인 서드파티 모듈이 없는 경우에는 Local Memory에 저장이 가능한 ConcurrentMap기반인 `ConcurrentMapCacheManager`가 Bean으로 자동 생성 된다.\n\n이외에도 EHCache, Redis등의 서드파티 모듈을 추가 하게 되면 `EHCacheCacheManager`, `RedisCacheManager`를 Bean으로 등록 하여 사용할 수 있다. 이렇게 되면 별도로 다른 설정 없이도  단순 Memory Cache가 아닌 Cache Server를 대상으로 캐시를 저장 할 수 있도록 지원하고 있다.\n\n\n\n# Spring Cache Annotation\n\nSpring에서는 Cache Annotation을 지원하여 좀 더 쉽게 메서드에 대한 캐시를 제어할 수 있다.\n\n* @EnableCaching\n  * Annotation 기반 캐싱 설정을 사용 (내부적으로 Spring AOP 이용)\n\n| 속성             | 설명                                                         | Default           |\n| ---------------- | ------------------------------------------------------------ | ----------------- |\n| proxyTargetClass | 클래스 기반의 Proxy생성 여부<br />false인 경우 JDK Dynamic Proxy 사용 (Interface 기반)<br />true인 경우 CGLIB Proxy 사용 (Class 기반) | false             |\n| mode             | 위빙 (Weaving) 모드에 대한 설정<br />PROXY : 기존의 Spring AOP 방식을 이용한 RTW방식 사용<br />ASPECTJ : aspectj 라이브러리를 이용한 CTW, LTW 방식 지원 | PROXY             |\n| order            | AOP order 설정                                               | Integer.MAX_VALUE |\n\n* @Cacheable\n  * 캐싱할 수 있는 메서드를 지정하기 위해 사용\n\n| 속성             | 설명                                                         | Default |\n| ---------------- | ------------------------------------------------------------ | ------- |\n| value, cacheName | 캐시 명                                                      | {}      |\n| key              | 같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.) | \"\"      |\n| keyGenerator     | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager     | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver    | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n| condition        | SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 `true`인 경우에만 캐싱 | \"\"      |\n| unless           | 캐싱이 이루어지지 않는 조건을 설정<br />연산 조건이 `true` 이면 경우에는 캐싱되지 않는다<br />예시 : id가 null아 아닌 경우에만 캐싱 (unless = \"#id == null\") | \"\"      |\n| sync             | 캐시 구현체가 Thread safe 하지 않는 경우, 자체적으로 캐시에 동기화를 거는 속성 | false   |\n\n* @CacheEvict\n  * 메서드 실행 시, 해당 캐시를 삭제\n\n| 속성             | 설명                                                         | Default |\n| ---------------- | ------------------------------------------------------------ | ------- |\n| value, cacheName | 캐시 명                                                      | {}      |\n| key              | 같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.) | \"\"      |\n| keyGenerator     | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager     | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver    | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n| condition        | SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 `true`인 경우에만 캐시 삭제 | \"\"      |\n| allEntries       | Cache Key에 대한 전체 데이터 삭제 여부                       | false   |\n| beforeInvocation | true면 메서드 실행 이전에 캐시 삭제, false면 메서드 실행 이후 삭제 | false   |\n\n\n* @CachePut\n  * 메서드 실행에 영향을 주지 않고 캐시를 갱신해야 하는 경우 사용\n  * 보통은 @Cacheable과 @CachePut Annotation을 같이 사용하지 않는다.\n    (둘은 다른 동작을 하기 때문에, 실행순서에 따라 다른 결과가 나올 수 있다.)\n  * @CachePut Annotation은 캐시 생성용으로만 사용한다.\n\n| 속성             | 설명                                                         | Default |\n| ---------------- | ------------------------------------------------------------ | ------- |\n| value, cacheName | 캐시 명                                                      | {}      |\n| key              | 같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.) | \"\"      |\n| keyGenerator     | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager     | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver    | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n| condition        | SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 `true`인 경우에만 캐싱 | \"\"      |\n| unless           | 캐싱이 이루어지지 않는 조건을 설정<br />연산 조건이 `true` 이면 경우에는 캐싱되지 않는다<br />예시 : id가 null아 아닌 경우에만 캐싱 (unless = \"#id == null\") | \"\"      |\n\n* @Caching\n  * @CacheEvict이나 @CachePut을 여러개 지정해야 하는 경우에 사용\n  * 조건식이나 표현식이 다른 경우에 사용한다.\n  * 여러가지의 key에 대한 캐시를 중첩적으로 삭제해야 할 때 사용\n\n| 속성        | 설명                                     | Default |\n| ----------- | ---------------------------------------- | ------- |\n| cacheable[] | @Cacheable 적용할 Annotation을 등록한다. | {}      |\n| put[]       | @CachePut 적용할 Annotation을 등록한다.  | {}      |\n| evict[]     | @CacheEvic 적용할 Annotation을 등록한다. | {}      |\n\n\n* @CacheConfig\n  * 클래스 단위로 캐시설정을 동일하게 하는데 사용\n  * 이 설정은 CacheManager가 여러개인 경우에만 사용\n  * Member조회 클래스에서는 Redis기반 캐시를 사용하고\n    Product 조회 클래스에서는 EHCache 기반 캐시를 사용할 때\n    각 클래스 별로 CacheManager를 지정 가능\n| 속성          | 설명                                                         | Default |\n| ------------- | ------------------------------------------------------------ | ------- |\n| cacheNames    | 캐시 명                                                      | {}      |\n| keyGenerator  | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager  | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n\n\n\n# EHCache\n\n![EHCACHE](./EHCACHE.png)\n\n* EHCache는 오픈 소스 기반의 Local Cache이다. \n* 속도가 빠르며 경량 Cache라는 장점이 있다.\n* Disk, Memory 저장이 가능한 형태\n* 서버 간 분산 캐시를 지원한다 (동기/비동기 복제)\n* JSR107 JCache 표준을 지원한다. \n  따라서 JCache에서 제공하는 Annotation을 통해 이미 작성된 코드에 간단하게 기능 추가가 쉽다.\n>**JSR-107** : (JCACHE – Java Temporary Caching API) 객체 생성, 공유 액세스, 스풀링, 무효화 및 JVM 전반에 걸친 일관성을 포함하여 Java 객체의 메모리 캐싱에서 사용할 API 에 대한 기준으로 볼 수 있다.    해당 Spec 으로 구현된 cache로는 EhCache가 유명하며, Hazelcast, Infinispan, Couchbase, Redis, Caffeine 등도 해당 기준을 따르는 것으로 알려져 있다.\n\n\n\n# EHCache 설정 방법 \n\n내용이 길어 질 것 같아 별도의 포스트로 작성\n\n* [EHCache 설정방법 (Spring Framework)](http://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springframework/)\n* [EHCache 설정방법 (Spring Boot)]( http:/jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springboot/)\n\n\n\n\n# EHCache 예시 코드\n\n테스트 시나리오\n\n1. 가상으로 DBMS에서 데이터를 조회 하는 Repository를 생성\n2. 3초 정도 슬로우쿼리가 실행된다고 가정\n3. 최초 1회는 DB에서 조회, 2회차 부턴 캐시 사용\n4. 캐시를 조회했을 때, 걸리는 시간 확인\n5. 캐시가 만료되었을때, 걸리는 시간 확인\n\n~~~java\n@Slf4j\n@RestController\npublic class EHCacheController {\n\n    @Autowired\n    private EHCacheRepository repository;\n\n    @GetMapping(\"/data/{id}\")\n    public String getData(@PathVariable(\"id\") int id) throws InterruptedException {\n\n        long start = System.currentTimeMillis();\n        String data = repository.getData(id);\n        long end = System.currentTimeMillis();\n\n        log.info(\"쿼리 수행 시간 : {}ms\", end-start);\n        return data;\n    }\n\n    @GetMapping(\"/data/delete/{id}\")\n    public void getExpireCache(@PathVariable(\"id\") int id) {\n        repository.evictCache(id);\n    }\n}\n~~~\n\n```java\n@Slf4j\n@Repository\npublic class EHCacheRepository {\n\n    @Cacheable(cacheNames = \"testData\")\n    public String getData(int id) throws InterruptedException {\n        Thread.sleep(3000);\n        return \"test-data\";\n    }\n\n    @CacheEvict(cacheNames = \"testData\", allEntries = true)\n    public void evictCache(int id) {\n        log.info(\"delete cache all\");\n    }\n}\n```\n\n```java\n@Configuration\n@EnableCaching(proxyTargetClass = true, mode = AdviceMode.PROXY)\npublic class EHCacheConfig {\n    @Bean\n    public EhCacheManagerFactoryBean ehCacheManagerFactoryBean() {\n        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = new EhCacheManagerFactoryBean();\n        ehCacheManagerFactoryBean.setConfigLocation(new ClassPathResource(\"config/ehcache.xml\"));\n        ehCacheManagerFactoryBean.setShared(true);\n        return ehCacheManagerFactoryBean;\n    }\n\n    @Bean\n    public EhCacheCacheManager ehCacheCacheManager(EhCacheManagerFactoryBean ehCacheManagerFactoryBean) {\n        EhCacheCacheManager ehCacheCacheManager = new EhCacheCacheManager();\n        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());\n        return ehCacheCacheManager;\n    }\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         maxBytesLocalHeap=\"300M\"\n         updateCheck=\"false\">\n\n    <diskStore path=\"java.io.tmpdir\" />\n    <sizeOfPolicy maxDepth=\"100000\" maxDepthExceededBehavior=\"continue\"/>\n\n    <defaultCache\n            eternal=\"false\"\n            timeToIdleSeconds=\"0\"\n            timeToLiveSeconds=\"1200\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n\n    <cache name=\"LocalCacheData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n\n    <cache name=\"testData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"100\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n</ehcache>\n```\n\n<br/>\n\n결과\n\n![ehcache-test](./ehcache-test.png)\n\n1. 최초로 `GET localhost:8080/data/1` 요청 시, 3초 이상의 슬로우 쿼리가 실행\n2. 두번째로 동일하게 `GET localhost:8080/data/1` 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)\n3. `GET localhost:8080/data/delete/1` 요청으로 캐시 삭제\n4. `GET localhost:8080/data/1` 요청 시, 3초 이상의 슬로우 쿼리가 실행 (캐시 삭제 후 요청)\n5.  `GET localhost:8080/data/1` 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)\n\n> 주의 할 점! \n>\n> EHCache는 ehcache.xml 또는 Java 코드에서 addCache를 이용하여 반드시 Cache Key를 등록해 줘야 함\n> 이거를 안 등록하고 Cache Key를 막쓰다가.. 계속 Cache Key가 없다는 오류가 발생하여 잠깐 삽질..\n\n# 참고\n\n- http://www.ehcache.org/documentation/2.8/integrations/spring.html#introduction\n- https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache\n- http://blog.breakingthat.com/2018/03/19/springboot-ehcache-%EC%A0%81%EC%9A%A9/\n- https://jojoldu.tistory.com/57\n- http://www.ehcache.org/documentation/2.8/configuration/index.html\n- https://www.slideshare.net/heungrae_kim/spring-31-ehcache\n- https://shortstories.gitbooks.io/studybook/content/cache.html\n","source":"_posts/2018-10-03-spring-ehcache.md","raw":"---\ntitle: Cache에 대하여.. (Spring+EHCache)\nsubtitle:\ncatalog: true\nCategories:\n  - Spring\ntags:\n  - Spring\ntypora-root-url: ./2018-10-03-spring-ehcache\ntypora-copy-images-to: ./2018-10-03-spring-ehcache\ndate: 2018-11-07 23:33:38\nheader-img:\n---\n\n\n\n# 들어가며..\n\n엔터프라이즈 급 Application에서는 DBMS의 부하를 줄이고, 성능을 높이기 위해 캐시(Cache)를 사용한다. 우리 회사에서도 EHCache, Redis를 사용하지만, EHCache쪽은 공부한 적이 없어서 이번 기회에 정리하면서 공부해 보게 되었다.\n대부분 `docs.spring.io`의 문서를 번역한 내용을 위주로 정리 하였다.\n\n\n\n# Cache란?\n\nCache의 사전적인 의미를 알아보기 위해 위키백과를 검색해 보았다.\n\n> **캐시**(cache, [문화어](https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4): 캐쉬, 고속완충기, 고속완충기억기)는 [컴퓨터 과학](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 캐시는 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.\n>\n> 캐시는 시스템의 효율성을 위해 여러 분야에서 두루 쓰인다.\n\n결국 캐시란, 반복적으로 데이터를 불러올 때 지속적으로 DBMS 혹은 서버에 요청하는 것이 아닌 메모리에 데이터를 저장하였다가 데이터를 불러다가 쓰는 것을 의미한다. 따라서 서버나 DBMS에 부담을 덜어주고, 엄청 빠르기 때문에 많은 시스템에서 사용하고 있다. \n대표적으로 Browser Cache, Apacha Cache, DNS Cache등 여러가지 형태로 캐시가 사용되고 있다.\n\nEHCache 사이트에서는 캐시에 대한 용어를 이렇게 정리 하였다.\n\n* **Cache** : 캐시는 `미래에 필요할 것이고 빠르게 검색할 수 있는 데이터를 담은 저장소` 라고 정의 한다. 캐시는 다른 곳에 있는 데이터를 복제하거나, 계산 결과를 임시적으로 저장하는 데이터 저장소이다. 캐시에 있는 데이터는 시간과 자원 면에서 최소한의 비용으로 반복적으로 접근 할 수 있다.\n* **Cache Hit** : 데이터 요소가 캐시에 요청되고 해당 키에 대한 요소가 존재하면 Cache Hit (또는 단순히 'Hit')라고 한다.\n* **Cache Miss**:데이터 요소가 캐시에 요청되고 해당 키에 대해 요소가 존재하지 않으면 Cache Miss (또는 단순히 'Miss')라고 한다.\n* **System-of-record** : 데이터에 대한 신뢰할 수있는 정보원. 이것을 흔히 시스템 레코드(SOR)이라고 한다. 캐시는 시스템 레코드에서 검색되거나 시스템 레코드에 저장된 데이터의 로컬 사본으로 작동된다. Ehcache를 사용하기 위해 SOR은 데이터베이스로 간주된다.\n\n\n# Long Tail 법칙\n\n![Long Tail](./17110B4350CC5EC51D.jpeg)\n\n\n\n20%의 요구가 시스템 리소스의 대부분을 잡아먹는다는 법칙. \n자주 사용되는 `20%의 기능에 캐시를 이용`하면 리소스 사용량을 대폭 줄일 수 있어, `시스템의 성능을 대폭 향상` 시킬 수 있다.\n\n\n\n# Local Cache vs Global Cache\n\n* Local Cache\n  * Local 장비 내에서만 사용 되는 캐시\n  * Local 장비의 Resource를 이용한다 (Memory, Disk)\n  * Local에서 작동 되기 때문에 속도가 빠르다.\n  * Local에서만 작동되기 때문에 다른 서버와 데이터 공유가 어렵다\n\n* Global Cache\n  * 여러 서버에서 Cache Server에 접근하여 사용하는 캐시\n  * 데이터를 분산하여 저장 할 수 있다. \n    * Replication - 데이터를 복제\n    * Sharding - 데이터를 분산하여 저장\n  * Local Cache에 비해 상대적으로 느리다 (네트워크 트래픽)\n  * 별도의 Cache Server를 이용하기 때문에 서버 간 데이터 공유가 쉽다.\n\n\n\n# Spring Cache Abstraction\n\nSpring 3.1버전부터 Spring Application에 캐시를 쉽게 추가할 수 있도록 기능을 제공하게 되었다. 유사 트랜잭션을 지원하고, 사용하고 있는 코드(메소드)에 영향을 최소화 하면서 일관된 방법으로 캐시를 사용 할 수 있게 되었다.\n\nSpring에서 캐시 추상화는 메소드를 통해 기능을 지원하는데, 메소드가 실행되는 시점에 파라미터에 대한 캐시 존재 여부를 판단하여 없으면 캐시를 등록하게 되고, 캐시가 있으면 메소드를 실행 시키지 않고 캐시 데이터를 Return 해주게 된다.\n\nSpring 캐시 추상화를 지원하기 때문에 개발자는 별도의 캐시 로직을 작성하지 않아도 된다. 하지만 캐시를 저장하는 저장소는 직접 설정을 해주어야 한다. Spring에서는 `CacheManager`라는 Interface를 제공하여 캐시를 구현하도록 하고 있다.\n\n<br/>\n\n~~~xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n~~~\n\nSpring Boot에서는 `spring-boot-starter-cache` Artifact를 추가 하여 CacheManager를 구성 할 수 있다. \n기본적으로 별도의 추가적인 서드파티 모듈이 없는 경우에는 Local Memory에 저장이 가능한 ConcurrentMap기반인 `ConcurrentMapCacheManager`가 Bean으로 자동 생성 된다.\n\n이외에도 EHCache, Redis등의 서드파티 모듈을 추가 하게 되면 `EHCacheCacheManager`, `RedisCacheManager`를 Bean으로 등록 하여 사용할 수 있다. 이렇게 되면 별도로 다른 설정 없이도  단순 Memory Cache가 아닌 Cache Server를 대상으로 캐시를 저장 할 수 있도록 지원하고 있다.\n\n\n\n# Spring Cache Annotation\n\nSpring에서는 Cache Annotation을 지원하여 좀 더 쉽게 메서드에 대한 캐시를 제어할 수 있다.\n\n* @EnableCaching\n  * Annotation 기반 캐싱 설정을 사용 (내부적으로 Spring AOP 이용)\n\n| 속성             | 설명                                                         | Default           |\n| ---------------- | ------------------------------------------------------------ | ----------------- |\n| proxyTargetClass | 클래스 기반의 Proxy생성 여부<br />false인 경우 JDK Dynamic Proxy 사용 (Interface 기반)<br />true인 경우 CGLIB Proxy 사용 (Class 기반) | false             |\n| mode             | 위빙 (Weaving) 모드에 대한 설정<br />PROXY : 기존의 Spring AOP 방식을 이용한 RTW방식 사용<br />ASPECTJ : aspectj 라이브러리를 이용한 CTW, LTW 방식 지원 | PROXY             |\n| order            | AOP order 설정                                               | Integer.MAX_VALUE |\n\n* @Cacheable\n  * 캐싱할 수 있는 메서드를 지정하기 위해 사용\n\n| 속성             | 설명                                                         | Default |\n| ---------------- | ------------------------------------------------------------ | ------- |\n| value, cacheName | 캐시 명                                                      | {}      |\n| key              | 같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.) | \"\"      |\n| keyGenerator     | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager     | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver    | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n| condition        | SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 `true`인 경우에만 캐싱 | \"\"      |\n| unless           | 캐싱이 이루어지지 않는 조건을 설정<br />연산 조건이 `true` 이면 경우에는 캐싱되지 않는다<br />예시 : id가 null아 아닌 경우에만 캐싱 (unless = \"#id == null\") | \"\"      |\n| sync             | 캐시 구현체가 Thread safe 하지 않는 경우, 자체적으로 캐시에 동기화를 거는 속성 | false   |\n\n* @CacheEvict\n  * 메서드 실행 시, 해당 캐시를 삭제\n\n| 속성             | 설명                                                         | Default |\n| ---------------- | ------------------------------------------------------------ | ------- |\n| value, cacheName | 캐시 명                                                      | {}      |\n| key              | 같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.) | \"\"      |\n| keyGenerator     | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager     | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver    | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n| condition        | SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 `true`인 경우에만 캐시 삭제 | \"\"      |\n| allEntries       | Cache Key에 대한 전체 데이터 삭제 여부                       | false   |\n| beforeInvocation | true면 메서드 실행 이전에 캐시 삭제, false면 메서드 실행 이후 삭제 | false   |\n\n\n* @CachePut\n  * 메서드 실행에 영향을 주지 않고 캐시를 갱신해야 하는 경우 사용\n  * 보통은 @Cacheable과 @CachePut Annotation을 같이 사용하지 않는다.\n    (둘은 다른 동작을 하기 때문에, 실행순서에 따라 다른 결과가 나올 수 있다.)\n  * @CachePut Annotation은 캐시 생성용으로만 사용한다.\n\n| 속성             | 설명                                                         | Default |\n| ---------------- | ------------------------------------------------------------ | ------- |\n| value, cacheName | 캐시 명                                                      | {}      |\n| key              | 같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.) | \"\"      |\n| keyGenerator     | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager     | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver    | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n| condition        | SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 `true`인 경우에만 캐싱 | \"\"      |\n| unless           | 캐싱이 이루어지지 않는 조건을 설정<br />연산 조건이 `true` 이면 경우에는 캐싱되지 않는다<br />예시 : id가 null아 아닌 경우에만 캐싱 (unless = \"#id == null\") | \"\"      |\n\n* @Caching\n  * @CacheEvict이나 @CachePut을 여러개 지정해야 하는 경우에 사용\n  * 조건식이나 표현식이 다른 경우에 사용한다.\n  * 여러가지의 key에 대한 캐시를 중첩적으로 삭제해야 할 때 사용\n\n| 속성        | 설명                                     | Default |\n| ----------- | ---------------------------------------- | ------- |\n| cacheable[] | @Cacheable 적용할 Annotation을 등록한다. | {}      |\n| put[]       | @CachePut 적용할 Annotation을 등록한다.  | {}      |\n| evict[]     | @CacheEvic 적용할 Annotation을 등록한다. | {}      |\n\n\n* @CacheConfig\n  * 클래스 단위로 캐시설정을 동일하게 하는데 사용\n  * 이 설정은 CacheManager가 여러개인 경우에만 사용\n  * Member조회 클래스에서는 Redis기반 캐시를 사용하고\n    Product 조회 클래스에서는 EHCache 기반 캐시를 사용할 때\n    각 클래스 별로 CacheManager를 지정 가능\n| 속성          | 설명                                                         | Default |\n| ------------- | ------------------------------------------------------------ | ------- |\n| cacheNames    | 캐시 명                                                      | {}      |\n| keyGenerator  | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | \"\"      |\n| cacheManager  | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | \"\"      |\n| cacheResolver | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | \"\"      |\n\n\n\n# EHCache\n\n![EHCACHE](./EHCACHE.png)\n\n* EHCache는 오픈 소스 기반의 Local Cache이다. \n* 속도가 빠르며 경량 Cache라는 장점이 있다.\n* Disk, Memory 저장이 가능한 형태\n* 서버 간 분산 캐시를 지원한다 (동기/비동기 복제)\n* JSR107 JCache 표준을 지원한다. \n  따라서 JCache에서 제공하는 Annotation을 통해 이미 작성된 코드에 간단하게 기능 추가가 쉽다.\n>**JSR-107** : (JCACHE – Java Temporary Caching API) 객체 생성, 공유 액세스, 스풀링, 무효화 및 JVM 전반에 걸친 일관성을 포함하여 Java 객체의 메모리 캐싱에서 사용할 API 에 대한 기준으로 볼 수 있다.    해당 Spec 으로 구현된 cache로는 EhCache가 유명하며, Hazelcast, Infinispan, Couchbase, Redis, Caffeine 등도 해당 기준을 따르는 것으로 알려져 있다.\n\n\n\n# EHCache 설정 방법 \n\n내용이 길어 질 것 같아 별도의 포스트로 작성\n\n* [EHCache 설정방법 (Spring Framework)](http://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springframework/)\n* [EHCache 설정방법 (Spring Boot)]( http:/jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springboot/)\n\n\n\n\n# EHCache 예시 코드\n\n테스트 시나리오\n\n1. 가상으로 DBMS에서 데이터를 조회 하는 Repository를 생성\n2. 3초 정도 슬로우쿼리가 실행된다고 가정\n3. 최초 1회는 DB에서 조회, 2회차 부턴 캐시 사용\n4. 캐시를 조회했을 때, 걸리는 시간 확인\n5. 캐시가 만료되었을때, 걸리는 시간 확인\n\n~~~java\n@Slf4j\n@RestController\npublic class EHCacheController {\n\n    @Autowired\n    private EHCacheRepository repository;\n\n    @GetMapping(\"/data/{id}\")\n    public String getData(@PathVariable(\"id\") int id) throws InterruptedException {\n\n        long start = System.currentTimeMillis();\n        String data = repository.getData(id);\n        long end = System.currentTimeMillis();\n\n        log.info(\"쿼리 수행 시간 : {}ms\", end-start);\n        return data;\n    }\n\n    @GetMapping(\"/data/delete/{id}\")\n    public void getExpireCache(@PathVariable(\"id\") int id) {\n        repository.evictCache(id);\n    }\n}\n~~~\n\n```java\n@Slf4j\n@Repository\npublic class EHCacheRepository {\n\n    @Cacheable(cacheNames = \"testData\")\n    public String getData(int id) throws InterruptedException {\n        Thread.sleep(3000);\n        return \"test-data\";\n    }\n\n    @CacheEvict(cacheNames = \"testData\", allEntries = true)\n    public void evictCache(int id) {\n        log.info(\"delete cache all\");\n    }\n}\n```\n\n```java\n@Configuration\n@EnableCaching(proxyTargetClass = true, mode = AdviceMode.PROXY)\npublic class EHCacheConfig {\n    @Bean\n    public EhCacheManagerFactoryBean ehCacheManagerFactoryBean() {\n        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = new EhCacheManagerFactoryBean();\n        ehCacheManagerFactoryBean.setConfigLocation(new ClassPathResource(\"config/ehcache.xml\"));\n        ehCacheManagerFactoryBean.setShared(true);\n        return ehCacheManagerFactoryBean;\n    }\n\n    @Bean\n    public EhCacheCacheManager ehCacheCacheManager(EhCacheManagerFactoryBean ehCacheManagerFactoryBean) {\n        EhCacheCacheManager ehCacheCacheManager = new EhCacheCacheManager();\n        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());\n        return ehCacheCacheManager;\n    }\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         maxBytesLocalHeap=\"300M\"\n         updateCheck=\"false\">\n\n    <diskStore path=\"java.io.tmpdir\" />\n    <sizeOfPolicy maxDepth=\"100000\" maxDepthExceededBehavior=\"continue\"/>\n\n    <defaultCache\n            eternal=\"false\"\n            timeToIdleSeconds=\"0\"\n            timeToLiveSeconds=\"1200\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n\n    <cache name=\"LocalCacheData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"1200\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           diskExpiryThreadIntervalSeconds=\"120\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n\n    <cache name=\"testData\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"100\"\n           overflowToDisk=\"false\"\n           diskPersistent=\"false\"\n           memoryStoreEvictionPolicy=\"LRU\">\n    </cache>\n</ehcache>\n```\n\n<br/>\n\n결과\n\n![ehcache-test](./ehcache-test.png)\n\n1. 최초로 `GET localhost:8080/data/1` 요청 시, 3초 이상의 슬로우 쿼리가 실행\n2. 두번째로 동일하게 `GET localhost:8080/data/1` 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)\n3. `GET localhost:8080/data/delete/1` 요청으로 캐시 삭제\n4. `GET localhost:8080/data/1` 요청 시, 3초 이상의 슬로우 쿼리가 실행 (캐시 삭제 후 요청)\n5.  `GET localhost:8080/data/1` 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)\n\n> 주의 할 점! \n>\n> EHCache는 ehcache.xml 또는 Java 코드에서 addCache를 이용하여 반드시 Cache Key를 등록해 줘야 함\n> 이거를 안 등록하고 Cache Key를 막쓰다가.. 계속 Cache Key가 없다는 오류가 발생하여 잠깐 삽질..\n\n# 참고\n\n- http://www.ehcache.org/documentation/2.8/integrations/spring.html#introduction\n- https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache\n- http://blog.breakingthat.com/2018/03/19/springboot-ehcache-%EC%A0%81%EC%9A%A9/\n- https://jojoldu.tistory.com/57\n- http://www.ehcache.org/documentation/2.8/configuration/index.html\n- https://www.slideshare.net/heungrae_kim/spring-31-ehcache\n- https://shortstories.gitbooks.io/studybook/content/cache.html\n","slug":"2018-10-03-spring-ehcache","published":1,"updated":"2018-11-27T07:23:32.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp55h5j8001v4f1tjvcawpg5","content":"<h1><span id=\"들어가며\">들어가며…</span></h1>\n<p>엔터프라이즈 급 Application에서는 DBMS의 부하를 줄이고, 성능을 높이기 위해 캐시(Cache)를 사용한다. 우리 회사에서도 EHCache, Redis를 사용하지만, EHCache쪽은 공부한 적이 없어서 이번 기회에 정리하면서 공부해 보게 되었다.<br>\n대부분 <code>docs.spring.io</code>의 문서를 번역한 내용을 위주로 정리 하였다.</p>\n<h1><span id=\"cache란\">Cache란?</span></h1>\n<p>Cache의 사전적인 의미를 알아보기 위해 위키백과를 검색해 보았다.</p>\n<blockquote>\n<p><strong>캐시</strong>(cache, <a href=\"https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4\" target=\"_blank\" rel=\"noopener\">문화어</a>: 캐쉬, 고속완충기, 고속완충기억기)는 <a href=\"https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99\" target=\"_blank\" rel=\"noopener\">컴퓨터 과학</a>에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 캐시는 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.</p>\n<p>캐시는 시스템의 효율성을 위해 여러 분야에서 두루 쓰인다.</p>\n</blockquote>\n<p>결국 캐시란, 반복적으로 데이터를 불러올 때 지속적으로 DBMS 혹은 서버에 요청하는 것이 아닌 메모리에 데이터를 저장하였다가 데이터를 불러다가 쓰는 것을 의미한다. 따라서 서버나 DBMS에 부담을 덜어주고, 엄청 빠르기 때문에 많은 시스템에서 사용하고 있다.<br>\n대표적으로 Browser Cache, Apacha Cache, DNS Cache등 여러가지 형태로 캐시가 사용되고 있다.</p>\n<p>EHCache 사이트에서는 캐시에 대한 용어를 이렇게 정리 하였다.</p>\n<ul>\n<li><strong>Cache</strong> : 캐시는 <code>미래에 필요할 것이고 빠르게 검색할 수 있는 데이터를 담은 저장소</code> 라고 정의 한다. 캐시는 다른 곳에 있는 데이터를 복제하거나, 계산 결과를 임시적으로 저장하는 데이터 저장소이다. 캐시에 있는 데이터는 시간과 자원 면에서 최소한의 비용으로 반복적으로 접근 할 수 있다.</li>\n<li><strong>Cache Hit</strong> : 데이터 요소가 캐시에 요청되고 해당 키에 대한 요소가 존재하면 Cache Hit (또는 단순히 ‘Hit’)라고 한다.</li>\n<li><strong>Cache Miss</strong>:데이터 요소가 캐시에 요청되고 해당 키에 대해 요소가 존재하지 않으면 Cache Miss (또는 단순히 ‘Miss’)라고 한다.</li>\n<li><strong>System-of-record</strong> : 데이터에 대한 신뢰할 수있는 정보원. 이것을 흔히 시스템 레코드(SOR)이라고 한다. 캐시는 시스템 레코드에서 검색되거나 시스템 레코드에 저장된 데이터의 로컬 사본으로 작동된다. Ehcache를 사용하기 위해 SOR은 데이터베이스로 간주된다.</li>\n</ul>\n<h1><span id=\"long-tail-법칙\">Long Tail 법칙</span></h1>\n<p><img src=\"./17110B4350CC5EC51D.jpeg\" alt=\"Long Tail\"></p>\n<p>20%의 요구가 시스템 리소스의 대부분을 잡아먹는다는 법칙.<br>\n자주 사용되는 <code>20%의 기능에 캐시를 이용</code>하면 리소스 사용량을 대폭 줄일 수 있어, <code>시스템의 성능을 대폭 향상</code> 시킬 수 있다.</p>\n<h1><span id=\"local-cache-vs-global-cache\">Local Cache vs Global Cache</span></h1>\n<ul>\n<li>\n<p>Local Cache</p>\n<ul>\n<li>Local 장비 내에서만 사용 되는 캐시</li>\n<li>Local 장비의 Resource를 이용한다 (Memory, Disk)</li>\n<li>Local에서 작동 되기 때문에 속도가 빠르다.</li>\n<li>Local에서만 작동되기 때문에 다른 서버와 데이터 공유가 어렵다</li>\n</ul>\n</li>\n<li>\n<p>Global Cache</p>\n<ul>\n<li>여러 서버에서 Cache Server에 접근하여 사용하는 캐시</li>\n<li>데이터를 분산하여 저장 할 수 있다.\n<ul>\n<li>Replication - 데이터를 복제</li>\n<li>Sharding - 데이터를 분산하여 저장</li>\n</ul>\n</li>\n<li>Local Cache에 비해 상대적으로 느리다 (네트워크 트래픽)</li>\n<li>별도의 Cache Server를 이용하기 때문에 서버 간 데이터 공유가 쉽다.</li>\n</ul>\n</li>\n</ul>\n<h1><span id=\"spring-cache-abstraction\">Spring Cache Abstraction</span></h1>\n<p>Spring 3.1버전부터 Spring Application에 캐시를 쉽게 추가할 수 있도록 기능을 제공하게 되었다. 유사 트랜잭션을 지원하고, 사용하고 있는 코드(메소드)에 영향을 최소화 하면서 일관된 방법으로 캐시를 사용 할 수 있게 되었다.</p>\n<p>Spring에서 캐시 추상화는 메소드를 통해 기능을 지원하는데, 메소드가 실행되는 시점에 파라미터에 대한 캐시 존재 여부를 판단하여 없으면 캐시를 등록하게 되고, 캐시가 있으면 메소드를 실행 시키지 않고 캐시 데이터를 Return 해주게 된다.</p>\n<p>Spring 캐시 추상화를 지원하기 때문에 개발자는 별도의 캐시 로직을 작성하지 않아도 된다. 하지만 캐시를 저장하는 저장소는 직접 설정을 해주어야 한다. Spring에서는 <code>CacheManager</code>라는 Interface를 제공하여 캐시를 구현하도록 하고 있다.</p>\n<br>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Spring Boot에서는 <code>spring-boot-starter-cache</code> Artifact를 추가 하여 CacheManager를 구성 할 수 있다.<br>\n기본적으로 별도의 추가적인 서드파티 모듈이 없는 경우에는 Local Memory에 저장이 가능한 ConcurrentMap기반인 <code>ConcurrentMapCacheManager</code>가 Bean으로 자동 생성 된다.</p>\n<p>이외에도 EHCache, Redis등의 서드파티 모듈을 추가 하게 되면 <code>EHCacheCacheManager</code>, <code>RedisCacheManager</code>를 Bean으로 등록 하여 사용할 수 있다. 이렇게 되면 별도로 다른 설정 없이도  단순 Memory Cache가 아닌 Cache Server를 대상으로 캐시를 저장 할 수 있도록 지원하고 있다.</p>\n<h1><span id=\"spring-cache-annotation\">Spring Cache Annotation</span></h1>\n<p>Spring에서는 Cache Annotation을 지원하여 좀 더 쉽게 메서드에 대한 캐시를 제어할 수 있다.</p>\n<ul>\n<li>@EnableCaching\n<ul>\n<li>Annotation 기반 캐싱 설정을 사용 (내부적으로 Spring AOP 이용)</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>proxyTargetClass</td>\n<td>클래스 기반의 Proxy생성 여부<br>false인 경우 JDK Dynamic Proxy 사용 (Interface 기반)<br>true인 경우 CGLIB Proxy 사용 (Class 기반)</td>\n<td>false</td>\n</tr>\n<tr>\n<td>mode</td>\n<td>위빙 (Weaving) 모드에 대한 설정<br>PROXY : 기존의 Spring AOP 방식을 이용한 RTW방식 사용<br>ASPECTJ : aspectj 라이브러리를 이용한 CTW, LTW 방식 지원</td>\n<td>PROXY</td>\n</tr>\n<tr>\n<td>order</td>\n<td>AOP order 설정</td>\n<td>Integer.MAX_VALUE</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@Cacheable\n<ul>\n<li>캐싱할 수 있는 메서드를 지정하기 위해 사용</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value, cacheName</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br>4.0이후 버전 부터 SimpleKeyGenerator를 사용<br>Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br>CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br>and, or 표현식등을 통해 복수 조건 사용가능<br>연산 조건이 <code>true</code>인 경우에만 캐싱</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>unless</td>\n<td>캐싱이 이루어지지 않는 조건을 설정<br>연산 조건이 <code>true</code> 이면 경우에는 캐싱되지 않는다<br>예시 : id가 null아 아닌 경우에만 캐싱 (unless = “#id == null”)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>캐시 구현체가 Thread safe 하지 않는 경우, 자체적으로 캐시에 동기화를 거는 속성</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@CacheEvict\n<ul>\n<li>메서드 실행 시, 해당 캐시를 삭제</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value, cacheName</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br>4.0이후 버전 부터 SimpleKeyGenerator를 사용<br>Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br>CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br>and, or 표현식등을 통해 복수 조건 사용가능<br>연산 조건이 <code>true</code>인 경우에만 캐시 삭제</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>allEntries</td>\n<td>Cache Key에 대한 전체 데이터 삭제 여부</td>\n<td>false</td>\n</tr>\n<tr>\n<td>beforeInvocation</td>\n<td>true면 메서드 실행 이전에 캐시 삭제, false면 메서드 실행 이후 삭제</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@CachePut\n<ul>\n<li>메서드 실행에 영향을 주지 않고 캐시를 갱신해야 하는 경우 사용</li>\n<li>보통은 @Cacheable과 @CachePut Annotation을 같이 사용하지 않는다.<br>\n(둘은 다른 동작을 하기 때문에, 실행순서에 따라 다른 결과가 나올 수 있다.)</li>\n<li>@CachePut Annotation은 캐시 생성용으로만 사용한다.</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value, cacheName</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br>4.0이후 버전 부터 SimpleKeyGenerator를 사용<br>Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br>CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br>and, or 표현식등을 통해 복수 조건 사용가능<br>연산 조건이 <code>true</code>인 경우에만 캐싱</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>unless</td>\n<td>캐싱이 이루어지지 않는 조건을 설정<br>연산 조건이 <code>true</code> 이면 경우에는 캐싱되지 않는다<br>예시 : id가 null아 아닌 경우에만 캐싱 (unless = “#id == null”)</td>\n<td>“”</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@Caching\n<ul>\n<li>@CacheEvict이나 @CachePut을 여러개 지정해야 하는 경우에 사용</li>\n<li>조건식이나 표현식이 다른 경우에 사용한다.</li>\n<li>여러가지의 key에 대한 캐시를 중첩적으로 삭제해야 할 때 사용</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cacheable[]</td>\n<td>@Cacheable 적용할 Annotation을 등록한다.</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>put[]</td>\n<td>@CachePut 적용할 Annotation을 등록한다.</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>evict[]</td>\n<td>@CacheEvic 적용할 Annotation을 등록한다.</td>\n<td>{}</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@CacheConfig\n<ul>\n<li>클래스 단위로 캐시설정을 동일하게 하는데 사용</li>\n<li>이 설정은 CacheManager가 여러개인 경우에만 사용</li>\n<li>Member조회 클래스에서는 Redis기반 캐시를 사용하고<br>\nProduct 조회 클래스에서는 EHCache 기반 캐시를 사용할 때<br>\n각 클래스 별로 CacheManager를 지정 가능<br>\n| 속성          | 설명                                                         | Default |<br>\n| ------------- | ------------------------------------------------------------ | ------- |<br>\n| cacheNames    | 캐시 명                                                      | {}      |<br>\n| keyGenerator  | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br>4.0이후 버전 부터 SimpleKeyGenerator를 사용<br>Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | “”      |<br>\n| cacheManager  | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | “”      |<br>\n| cacheResolver | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br>CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | “”      |</li>\n</ul>\n</li>\n</ul>\n<h1><span id=\"ehcache\">EHCache</span></h1>\n<p><img src=\"./EHCACHE.png\" alt=\"EHCACHE\"></p>\n<ul>\n<li>EHCache는 오픈 소스 기반의 Local Cache이다.</li>\n<li>속도가 빠르며 경량 Cache라는 장점이 있다.</li>\n<li>Disk, Memory 저장이 가능한 형태</li>\n<li>서버 간 분산 캐시를 지원한다 (동기/비동기 복제)</li>\n<li>JSR107 JCache 표준을 지원한다.<br>\n따라서 JCache에서 제공하는 Annotation을 통해 이미 작성된 코드에 간단하게 기능 추가가 쉽다.</li>\n</ul>\n<blockquote>\n<p><strong>JSR-107</strong> : (JCACHE – Java Temporary Caching API) 객체 생성, 공유 액세스, 스풀링, 무효화 및 JVM 전반에 걸친 일관성을 포함하여 Java 객체의 메모리 캐싱에서 사용할 API 에 대한 기준으로 볼 수 있다.    해당 Spec 으로 구현된 cache로는 EhCache가 유명하며, Hazelcast, Infinispan, Couchbase, Redis, Caffeine 등도 해당 기준을 따르는 것으로 알려져 있다.</p>\n</blockquote>\n<h1><span id=\"ehcache-설정-방법\">EHCache 설정 방법</span></h1>\n<p>내용이 길어 질 것 같아 별도의 포스트로 작성</p>\n<ul>\n<li><a href=\"http://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springframework/\" target=\"_blank\" rel=\"noopener\">EHCache 설정방법 (Spring Framework)</a></li>\n<li><a href=\"http:/jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springboot/\" target=\"_blank\" rel=\"noopener\">EHCache 설정방법 (Spring Boot)</a></li>\n</ul>\n<h1><span id=\"ehcache-예시-코드\">EHCache 예시 코드</span></h1>\n<p>테스트 시나리오</p>\n<ol>\n<li>가상으로 DBMS에서 데이터를 조회 하는 Repository를 생성</li>\n<li>3초 정도 슬로우쿼리가 실행된다고 가정</li>\n<li>최초 1회는 DB에서 조회, 2회차 부턴 캐시 사용</li>\n<li>캐시를 조회했을 때, 걸리는 시간 확인</li>\n<li>캐시가 만료되었을때, 걸리는 시간 확인</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EHCacheRepository repository;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/data/&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getData</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id) <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        String data = repository.getData(id);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">        log.info(<span class=\"string\">\"쿼리 수행 시간 : &#123;&#125;ms\"</span>, end-start);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/data/delete/&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getExpireCache</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id) </span>&#123;</span><br><span class=\"line\">        repository.evictCache(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheRepository</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Cacheable</span>(cacheNames = <span class=\"string\">\"testData\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getData</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"test-data\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CacheEvict</span>(cacheNames = <span class=\"string\">\"testData\"</span>, allEntries = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">evictCache</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"delete cache all\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>, mode = AdviceMode.PROXY)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheManagerFactoryBean <span class=\"title\">ehCacheManagerFactoryBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = <span class=\"keyword\">new</span> EhCacheManagerFactoryBean();</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setConfigLocation(<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">\"config/ehcache.xml\"</span>));</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setShared(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheManagerFactoryBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheCacheManager <span class=\"title\">ehCacheCacheManager</span><span class=\"params\">(EhCacheManagerFactoryBean ehCacheManagerFactoryBean)</span> </span>&#123;</span><br><span class=\"line\">        EhCacheCacheManager ehCacheCacheManager = <span class=\"keyword\">new</span> EhCacheCacheManager();</span><br><span class=\"line\">        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheCacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://ehcache.org/ehcache.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">maxBytesLocalHeap</span>=<span class=\"string\">\"300M\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">updateCheck</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sizeOfPolicy</span> <span class=\"attr\">maxDepth</span>=<span class=\"string\">\"100000\"</span> <span class=\"attr\">maxDepthExceededBehavior</span>=<span class=\"string\">\"continue\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultCache</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">defaultCache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"LocalCacheData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"testData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"100\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<br>\n<p>결과</p>\n<p><img src=\"./ehcache-test.png\" alt=\"ehcache-test\"></p>\n<ol>\n<li>최초로 <code>GET localhost:8080/data/1</code> 요청 시, 3초 이상의 슬로우 쿼리가 실행</li>\n<li>두번째로 동일하게 <code>GET localhost:8080/data/1</code> 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)</li>\n<li><code>GET localhost:8080/data/delete/1</code> 요청으로 캐시 삭제</li>\n<li><code>GET localhost:8080/data/1</code> 요청 시, 3초 이상의 슬로우 쿼리가 실행 (캐시 삭제 후 요청)</li>\n<li><code>GET localhost:8080/data/1</code> 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)</li>\n</ol>\n<blockquote>\n<p>주의 할 점!</p>\n<p>EHCache는 ehcache.xml 또는 Java 코드에서 addCache를 이용하여 반드시 Cache Key를 등록해 줘야 함<br>\n이거를 안 등록하고 Cache Key를 막쓰다가… 계속 Cache Key가 없다는 오류가 발생하여 잠깐 삽질…</p>\n</blockquote>\n<h1><span id=\"참고\">참고</span></h1>\n<ul>\n<li><a href=\"http://www.ehcache.org/documentation/2.8/integrations/spring.html#introduction\" target=\"_blank\" rel=\"noopener\">http://www.ehcache.org/documentation/2.8/integrations/spring.html#introduction</a></li>\n<li><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache</a></li>\n<li><a href=\"http://blog.breakingthat.com/2018/03/19/springboot-ehcache-%EC%A0%81%EC%9A%A9/\" target=\"_blank\" rel=\"noopener\">http://blog.breakingthat.com/2018/03/19/springboot-ehcache-적용/</a></li>\n<li><a href=\"https://jojoldu.tistory.com/57\" target=\"_blank\" rel=\"noopener\">https://jojoldu.tistory.com/57</a></li>\n<li><a href=\"http://www.ehcache.org/documentation/2.8/configuration/index.html\" target=\"_blank\" rel=\"noopener\">http://www.ehcache.org/documentation/2.8/configuration/index.html</a></li>\n<li><a href=\"https://www.slideshare.net/heungrae_kim/spring-31-ehcache\" target=\"_blank\" rel=\"noopener\">https://www.slideshare.net/heungrae_kim/spring-31-ehcache</a></li>\n<li><a href=\"https://shortstories.gitbooks.io/studybook/content/cache.html\" target=\"_blank\" rel=\"noopener\">https://shortstories.gitbooks.io/studybook/content/cache.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며…</h1>\n<p>엔터프라이즈 급 Application에서는 DBMS의 부하를 줄이고, 성능을 높이기 위해 캐시(Cache)를 사용한다. 우리 회사에서도 EHCache, Redis를 사용하지만, EHCache쪽은 공부한 적이 없어서 이번 기회에 정리하면서 공부해 보게 되었다.<br>\n대부분 <code>docs.spring.io</code>의 문서를 번역한 내용을 위주로 정리 하였다.</p>\n<h1>Cache란?</h1>\n<p>Cache의 사전적인 의미를 알아보기 위해 위키백과를 검색해 보았다.</p>\n<blockquote>\n<p><strong>캐시</strong>(cache, <a href=\"https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4\" target=\"_blank\" rel=\"noopener\">문화어</a>: 캐쉬, 고속완충기, 고속완충기억기)는 <a href=\"https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99\" target=\"_blank\" rel=\"noopener\">컴퓨터 과학</a>에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 캐시는 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.</p>\n<p>캐시는 시스템의 효율성을 위해 여러 분야에서 두루 쓰인다.</p>\n</blockquote>\n<p>결국 캐시란, 반복적으로 데이터를 불러올 때 지속적으로 DBMS 혹은 서버에 요청하는 것이 아닌 메모리에 데이터를 저장하였다가 데이터를 불러다가 쓰는 것을 의미한다. 따라서 서버나 DBMS에 부담을 덜어주고, 엄청 빠르기 때문에 많은 시스템에서 사용하고 있다.<br>\n대표적으로 Browser Cache, Apacha Cache, DNS Cache등 여러가지 형태로 캐시가 사용되고 있다.</p>\n<p>EHCache 사이트에서는 캐시에 대한 용어를 이렇게 정리 하였다.</p>\n<ul>\n<li><strong>Cache</strong> : 캐시는 <code>미래에 필요할 것이고 빠르게 검색할 수 있는 데이터를 담은 저장소</code> 라고 정의 한다. 캐시는 다른 곳에 있는 데이터를 복제하거나, 계산 결과를 임시적으로 저장하는 데이터 저장소이다. 캐시에 있는 데이터는 시간과 자원 면에서 최소한의 비용으로 반복적으로 접근 할 수 있다.</li>\n<li><strong>Cache Hit</strong> : 데이터 요소가 캐시에 요청되고 해당 키에 대한 요소가 존재하면 Cache Hit (또는 단순히 ‘Hit’)라고 한다.</li>\n<li><strong>Cache Miss</strong>:데이터 요소가 캐시에 요청되고 해당 키에 대해 요소가 존재하지 않으면 Cache Miss (또는 단순히 ‘Miss’)라고 한다.</li>\n<li><strong>System-of-record</strong> : 데이터에 대한 신뢰할 수있는 정보원. 이것을 흔히 시스템 레코드(SOR)이라고 한다. 캐시는 시스템 레코드에서 검색되거나 시스템 레코드에 저장된 데이터의 로컬 사본으로 작동된다. Ehcache를 사용하기 위해 SOR은 데이터베이스로 간주된다.</li>\n</ul>\n<h1>Long Tail 법칙</h1>\n<p><img src=\"./17110B4350CC5EC51D.jpeg\" alt=\"Long Tail\"></p>\n<p>20%의 요구가 시스템 리소스의 대부분을 잡아먹는다는 법칙.<br>\n자주 사용되는 <code>20%의 기능에 캐시를 이용</code>하면 리소스 사용량을 대폭 줄일 수 있어, <code>시스템의 성능을 대폭 향상</code> 시킬 수 있다.</p>\n<h1>Local Cache vs Global Cache</h1>\n<ul>\n<li>\n<p>Local Cache</p>\n<ul>\n<li>Local 장비 내에서만 사용 되는 캐시</li>\n<li>Local 장비의 Resource를 이용한다 (Memory, Disk)</li>\n<li>Local에서 작동 되기 때문에 속도가 빠르다.</li>\n<li>Local에서만 작동되기 때문에 다른 서버와 데이터 공유가 어렵다</li>\n</ul>\n</li>\n<li>\n<p>Global Cache</p>\n<ul>\n<li>여러 서버에서 Cache Server에 접근하여 사용하는 캐시</li>\n<li>데이터를 분산하여 저장 할 수 있다.\n<ul>\n<li>Replication - 데이터를 복제</li>\n<li>Sharding - 데이터를 분산하여 저장</li>\n</ul>\n</li>\n<li>Local Cache에 비해 상대적으로 느리다 (네트워크 트래픽)</li>\n<li>별도의 Cache Server를 이용하기 때문에 서버 간 데이터 공유가 쉽다.</li>\n</ul>\n</li>\n</ul>\n<h1>Spring Cache Abstraction</h1>\n<p>Spring 3.1버전부터 Spring Application에 캐시를 쉽게 추가할 수 있도록 기능을 제공하게 되었다. 유사 트랜잭션을 지원하고, 사용하고 있는 코드(메소드)에 영향을 최소화 하면서 일관된 방법으로 캐시를 사용 할 수 있게 되었다.</p>\n<p>Spring에서 캐시 추상화는 메소드를 통해 기능을 지원하는데, 메소드가 실행되는 시점에 파라미터에 대한 캐시 존재 여부를 판단하여 없으면 캐시를 등록하게 되고, 캐시가 있으면 메소드를 실행 시키지 않고 캐시 데이터를 Return 해주게 된다.</p>\n<p>Spring 캐시 추상화를 지원하기 때문에 개발자는 별도의 캐시 로직을 작성하지 않아도 된다. 하지만 캐시를 저장하는 저장소는 직접 설정을 해주어야 한다. Spring에서는 <code>CacheManager</code>라는 Interface를 제공하여 캐시를 구현하도록 하고 있다.</p>\n<br>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Spring Boot에서는 <code>spring-boot-starter-cache</code> Artifact를 추가 하여 CacheManager를 구성 할 수 있다.<br>\n기본적으로 별도의 추가적인 서드파티 모듈이 없는 경우에는 Local Memory에 저장이 가능한 ConcurrentMap기반인 <code>ConcurrentMapCacheManager</code>가 Bean으로 자동 생성 된다.</p>\n<p>이외에도 EHCache, Redis등의 서드파티 모듈을 추가 하게 되면 <code>EHCacheCacheManager</code>, <code>RedisCacheManager</code>를 Bean으로 등록 하여 사용할 수 있다. 이렇게 되면 별도로 다른 설정 없이도  단순 Memory Cache가 아닌 Cache Server를 대상으로 캐시를 저장 할 수 있도록 지원하고 있다.</p>\n<h1>Spring Cache Annotation</h1>\n<p>Spring에서는 Cache Annotation을 지원하여 좀 더 쉽게 메서드에 대한 캐시를 제어할 수 있다.</p>\n<ul>\n<li>@EnableCaching\n<ul>\n<li>Annotation 기반 캐싱 설정을 사용 (내부적으로 Spring AOP 이용)</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>proxyTargetClass</td>\n<td>클래스 기반의 Proxy생성 여부<br>false인 경우 JDK Dynamic Proxy 사용 (Interface 기반)<br>true인 경우 CGLIB Proxy 사용 (Class 기반)</td>\n<td>false</td>\n</tr>\n<tr>\n<td>mode</td>\n<td>위빙 (Weaving) 모드에 대한 설정<br>PROXY : 기존의 Spring AOP 방식을 이용한 RTW방식 사용<br>ASPECTJ : aspectj 라이브러리를 이용한 CTW, LTW 방식 지원</td>\n<td>PROXY</td>\n</tr>\n<tr>\n<td>order</td>\n<td>AOP order 설정</td>\n<td>Integer.MAX_VALUE</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@Cacheable\n<ul>\n<li>캐싱할 수 있는 메서드를 지정하기 위해 사용</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value, cacheName</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br>4.0이후 버전 부터 SimpleKeyGenerator를 사용<br>Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br>CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br>and, or 표현식등을 통해 복수 조건 사용가능<br>연산 조건이 <code>true</code>인 경우에만 캐싱</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>unless</td>\n<td>캐싱이 이루어지지 않는 조건을 설정<br>연산 조건이 <code>true</code> 이면 경우에는 캐싱되지 않는다<br>예시 : id가 null아 아닌 경우에만 캐싱 (unless = “#id == null”)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>캐시 구현체가 Thread safe 하지 않는 경우, 자체적으로 캐시에 동기화를 거는 속성</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@CacheEvict\n<ul>\n<li>메서드 실행 시, 해당 캐시를 삭제</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value, cacheName</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br>4.0이후 버전 부터 SimpleKeyGenerator를 사용<br>Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br>CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br>and, or 표현식등을 통해 복수 조건 사용가능<br>연산 조건이 <code>true</code>인 경우에만 캐시 삭제</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>allEntries</td>\n<td>Cache Key에 대한 전체 데이터 삭제 여부</td>\n<td>false</td>\n</tr>\n<tr>\n<td>beforeInvocation</td>\n<td>true면 메서드 실행 이전에 캐시 삭제, false면 메서드 실행 이후 삭제</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@CachePut\n<ul>\n<li>메서드 실행에 영향을 주지 않고 캐시를 갱신해야 하는 경우 사용</li>\n<li>보통은 @Cacheable과 @CachePut Annotation을 같이 사용하지 않는다.<br>\n(둘은 다른 동작을 하기 때문에, 실행순서에 따라 다른 결과가 나올 수 있다.)</li>\n<li>@CachePut Annotation은 캐시 생성용으로만 사용한다.</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value, cacheName</td>\n<td>캐시 명</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br>4.0이후 버전 부터 SimpleKeyGenerator를 사용<br>Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br>CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br>and, or 표현식등을 통해 복수 조건 사용가능<br>연산 조건이 <code>true</code>인 경우에만 캐싱</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>unless</td>\n<td>캐싱이 이루어지지 않는 조건을 설정<br>연산 조건이 <code>true</code> 이면 경우에는 캐싱되지 않는다<br>예시 : id가 null아 아닌 경우에만 캐싱 (unless = “#id == null”)</td>\n<td>“”</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@Caching\n<ul>\n<li>@CacheEvict이나 @CachePut을 여러개 지정해야 하는 경우에 사용</li>\n<li>조건식이나 표현식이 다른 경우에 사용한다.</li>\n<li>여러가지의 key에 대한 캐시를 중첩적으로 삭제해야 할 때 사용</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cacheable[]</td>\n<td>@Cacheable 적용할 Annotation을 등록한다.</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>put[]</td>\n<td>@CachePut 적용할 Annotation을 등록한다.</td>\n<td>{}</td>\n</tr>\n<tr>\n<td>evict[]</td>\n<td>@CacheEvic 적용할 Annotation을 등록한다.</td>\n<td>{}</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@CacheConfig\n<ul>\n<li>클래스 단위로 캐시설정을 동일하게 하는데 사용</li>\n<li>이 설정은 CacheManager가 여러개인 경우에만 사용</li>\n<li>Member조회 클래스에서는 Redis기반 캐시를 사용하고<br>\nProduct 조회 클래스에서는 EHCache 기반 캐시를 사용할 때<br>\n각 클래스 별로 CacheManager를 지정 가능<br>\n| 속성          | 설명                                                         | Default |<br>\n| ------------- | ------------------------------------------------------------ | ------- |<br>\n| cacheNames    | 캐시 명                                                      | {}      |<br>\n| keyGenerator  | 특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br>4.0이후 버전 부터 SimpleKeyGenerator를 사용<br>Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현 | “”      |<br>\n| cacheManager  | 사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등) | “”      |<br>\n| cacheResolver | Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br>CacheResolver를 구현하여 Custom하게 처리 할 수도 있다. | “”      |</li>\n</ul>\n</li>\n</ul>\n<h1>EHCache</h1>\n<p><img src=\"./EHCACHE.png\" alt=\"EHCACHE\"></p>\n<ul>\n<li>EHCache는 오픈 소스 기반의 Local Cache이다.</li>\n<li>속도가 빠르며 경량 Cache라는 장점이 있다.</li>\n<li>Disk, Memory 저장이 가능한 형태</li>\n<li>서버 간 분산 캐시를 지원한다 (동기/비동기 복제)</li>\n<li>JSR107 JCache 표준을 지원한다.<br>\n따라서 JCache에서 제공하는 Annotation을 통해 이미 작성된 코드에 간단하게 기능 추가가 쉽다.</li>\n</ul>\n<blockquote>\n<p><strong>JSR-107</strong> : (JCACHE – Java Temporary Caching API) 객체 생성, 공유 액세스, 스풀링, 무효화 및 JVM 전반에 걸친 일관성을 포함하여 Java 객체의 메모리 캐싱에서 사용할 API 에 대한 기준으로 볼 수 있다.    해당 Spec 으로 구현된 cache로는 EhCache가 유명하며, Hazelcast, Infinispan, Couchbase, Redis, Caffeine 등도 해당 기준을 따르는 것으로 알려져 있다.</p>\n</blockquote>\n<h1>EHCache 설정 방법</h1>\n<p>내용이 길어 질 것 같아 별도의 포스트로 작성</p>\n<ul>\n<li><a href=\"http://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springframework/\" target=\"_blank\" rel=\"noopener\">EHCache 설정방법 (Spring Framework)</a></li>\n<li><a href=\"http:/jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springboot/\" target=\"_blank\" rel=\"noopener\">EHCache 설정방법 (Spring Boot)</a></li>\n</ul>\n<h1>EHCache 예시 코드</h1>\n<p>테스트 시나리오</p>\n<ol>\n<li>가상으로 DBMS에서 데이터를 조회 하는 Repository를 생성</li>\n<li>3초 정도 슬로우쿼리가 실행된다고 가정</li>\n<li>최초 1회는 DB에서 조회, 2회차 부턴 캐시 사용</li>\n<li>캐시를 조회했을 때, 걸리는 시간 확인</li>\n<li>캐시가 만료되었을때, 걸리는 시간 확인</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EHCacheRepository repository;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/data/&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getData</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id) <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        String data = repository.getData(id);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">        log.info(<span class=\"string\">\"쿼리 수행 시간 : &#123;&#125;ms\"</span>, end-start);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/data/delete/&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getExpireCache</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id) </span>&#123;</span><br><span class=\"line\">        repository.evictCache(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheRepository</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Cacheable</span>(cacheNames = <span class=\"string\">\"testData\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getData</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"test-data\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CacheEvict</span>(cacheNames = <span class=\"string\">\"testData\"</span>, allEntries = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">evictCache</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"delete cache all\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>, mode = AdviceMode.PROXY)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EHCacheConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheManagerFactoryBean <span class=\"title\">ehCacheManagerFactoryBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = <span class=\"keyword\">new</span> EhCacheManagerFactoryBean();</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setConfigLocation(<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">\"config/ehcache.xml\"</span>));</span><br><span class=\"line\">        ehCacheManagerFactoryBean.setShared(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheManagerFactoryBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EhCacheCacheManager <span class=\"title\">ehCacheCacheManager</span><span class=\"params\">(EhCacheManagerFactoryBean ehCacheManagerFactoryBean)</span> </span>&#123;</span><br><span class=\"line\">        EhCacheCacheManager ehCacheCacheManager = <span class=\"keyword\">new</span> EhCacheCacheManager();</span><br><span class=\"line\">        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ehCacheCacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://ehcache.org/ehcache.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">maxBytesLocalHeap</span>=<span class=\"string\">\"300M\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">updateCheck</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sizeOfPolicy</span> <span class=\"attr\">maxDepth</span>=<span class=\"string\">\"100000\"</span> <span class=\"attr\">maxDepthExceededBehavior</span>=<span class=\"string\">\"continue\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultCache</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">defaultCache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"LocalCacheData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"1200\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskExpiryThreadIntervalSeconds</span>=<span class=\"string\">\"120\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"testData\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"100\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">diskPersistent</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LRU\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<br>\n<p>결과</p>\n<p><img src=\"./ehcache-test.png\" alt=\"ehcache-test\"></p>\n<ol>\n<li>최초로 <code>GET localhost:8080/data/1</code> 요청 시, 3초 이상의 슬로우 쿼리가 실행</li>\n<li>두번째로 동일하게 <code>GET localhost:8080/data/1</code> 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)</li>\n<li><code>GET localhost:8080/data/delete/1</code> 요청으로 캐시 삭제</li>\n<li><code>GET localhost:8080/data/1</code> 요청 시, 3초 이상의 슬로우 쿼리가 실행 (캐시 삭제 후 요청)</li>\n<li><code>GET localhost:8080/data/1</code> 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)</li>\n</ol>\n<blockquote>\n<p>주의 할 점!</p>\n<p>EHCache는 ehcache.xml 또는 Java 코드에서 addCache를 이용하여 반드시 Cache Key를 등록해 줘야 함<br>\n이거를 안 등록하고 Cache Key를 막쓰다가… 계속 Cache Key가 없다는 오류가 발생하여 잠깐 삽질…</p>\n</blockquote>\n<h1>참고</h1>\n<ul>\n<li><a href=\"http://www.ehcache.org/documentation/2.8/integrations/spring.html#introduction\" target=\"_blank\" rel=\"noopener\">http://www.ehcache.org/documentation/2.8/integrations/spring.html#introduction</a></li>\n<li><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache</a></li>\n<li><a href=\"http://blog.breakingthat.com/2018/03/19/springboot-ehcache-%EC%A0%81%EC%9A%A9/\" target=\"_blank\" rel=\"noopener\">http://blog.breakingthat.com/2018/03/19/springboot-ehcache-적용/</a></li>\n<li><a href=\"https://jojoldu.tistory.com/57\" target=\"_blank\" rel=\"noopener\">https://jojoldu.tistory.com/57</a></li>\n<li><a href=\"http://www.ehcache.org/documentation/2.8/configuration/index.html\" target=\"_blank\" rel=\"noopener\">http://www.ehcache.org/documentation/2.8/configuration/index.html</a></li>\n<li><a href=\"https://www.slideshare.net/heungrae_kim/spring-31-ehcache\" target=\"_blank\" rel=\"noopener\">https://www.slideshare.net/heungrae_kim/spring-31-ehcache</a></li>\n<li><a href=\"https://shortstories.gitbooks.io/studybook/content/cache.html\" target=\"_blank\" rel=\"noopener\">https://shortstories.gitbooks.io/studybook/content/cache.html</a></li>\n</ul>\n"},{"layout":"posts","title":"SpEL Expression(2)","catalog":true,"Categories":["Spring"],"date":"2018-11-25T08:11:42.000Z","typora-root-url":"2018-11-25-spel-expression-2","typora-copy-images-to":"2018-11-25-spel-expression-2","_content":"\n# 리터럴 표현식 (Literal Expression)\n\n리터럴 표현식을 제공하는 타입은 문자열(String), 숫자(int, real, hex), boolean, null이다.\n\n* 문자열 (Strings)는 따옴표(')로 구분된다 `(쌍따옴표가 아님)` \\- 문자열 표현 시\\, `'Hello World'` 처럼 SpEL을 작성\n\n다음은 리터럴 표현식 (Literal Expression)에 대한 간단한 예제이다.\n\n``` java\nExpressionParser parser = new SpelExpressionParser();\n\n//따옴표로 이루어진 'Hello World' => Hello World라는 문자열로 평가 된다.\nString helloWorld = (String) parser.parseExpression(\"'Hello World'\").getValue();\n//Double 타입의 숫자로 평가\ndouble avogadrosNumber = (Double) parser.parseExpression(\"6.0221415E+23\").getValue();\n//2147483647로 평가\nint maxValue = (Integer) parser.parseExpression(\"0x7FFFFFFF\").getValue();\n\nboolean trueValue = (Boolean) parser.parseExpression(\"true\").getValue();\n//null로 평가 된다. -> null String이 아니다. (주의)\nObject nullValue = parser.parseExpression(\"null\").getValue();\n```\n\n* 숫자는 음수기호(-), 지수표시(E), 소수점(.)을 지원한다.\n* 기본적으로 실제 숫자는 Double.parseDouble()로 파싱한다.\n\n# 메서드 호출\n\n``` java\n//String 리터럴 abc에 대한 substring 메서드 호출 -> bc가 리턴된다.\nString c = parser.parseExpression(\"'abc'.substring(2, 3)\").getValue(String.class);\n\n//사용자 정의 메서드 호출 (Return Type : Boolean) -> boolean 타입으로 평가된다.\nboolean isMember = parser.parseExpression(\"isMember('Mihajlo Pupin')\").getValue(\n        societyContext, Boolean.class);\n```\n\n위의 코드는 메서드 호출에 대한 예제 코드이다.\n\n* 메서드는 Java 문법을 사용하여 호출 할 수 있다.\n* Literal에 대한 메서드 호출도 가능하다.\n* Varargs 형식의 파라미터도 지원하고 있다.\n\n# 프로퍼티, 배열, 리스트, 맵에 대한 접근 지원\n\n``` java\nExpressionParser parser = new SpelExpressionParser();\n\n// 발명품 배열\nStandardEvaluationContext teslaContext = new StandardEvaluationContext(tesla);\n\n// \"Induction motor\"로 평가된다.\nString invention = parser.parseExpression(\"inventions[3]\").getValue(teslaContext, String.class); \n\n// 회원 리스트\nStandardEvaluationContext societyContext = new StandardEvaluationContext(ieee);\n\n// \"Nikola Tesla\"로 평가된다.\nString name = parser.parseExpression(\"Members[0].Name\").getValue(societyContext, String.class);\n\n// 리스트와 배열 탐색\n// \"Wireless communication\"로 평가된다.\nString invention = parser.parseExpression(\"Members[0].Inventions[6]\").getValue(societyContext, String.class);\n```\n\n* 프로퍼티의 맨 첫글자는 대소문자를 구별하지 않는다.\n* SpEL은 표준 `dot 표기법`(예: prop1.prop2.prop3)을 사용해서 중첩된 프로퍼티와 프로퍼티의 값 설정도 지원한다.\n* public 필드에 대한 접근을 지원한다.\n\n``` java\n// Officer의 딕션어리\nInventor pupin = parser.parseExpression(\"Officers['president']\").getValue(societyContext, Inventor.class);\n\n// \"Idvor\"로 평가된다\nString city = parser.parseExpression(\"Officers['president'].PlaceOfBirth.City\").getValue(societyContext, String.class);\n\n// 값을 설정한다\nparser.parseExpression(\"Officers['advisors'][0].PlaceOfBirth.Country\").setValue(societyContext, \"Croatia\");\n```\n\n* 대괄호`[]` 를 사용하여 Map의 key를 바탕으로 데이터에 접근한다.\n  (위의 예제에서는 Officers가 `Map`, president가 `key`이다.)\n* SpEL은 표준 'dot' 표기법(예: prop1.prop2.prop3)을 사용해서 Map내의 value 객체의 프로퍼티에도 접근 가능하다.\n* setValue 메서드를 통해 데이터를 수정할 수 있다.\n\n# 인라인 리스트 (Inline list)\n\n리스트는 {} 표기법을 사용하여 리스트로 사용 할 수 있다.\n\n``` java\n// 4개의 숫자를 담고 있는 리스트로 평가된다\nList<Integer> numbers = (List) parser.parseExpression(\"{1,2,3,4}\").getValue(context); \n\n//List의 List의 형태의 List로 평가된다.\n//listOfLists[0] = {'a', 'b'}\n//listOfLists[1] = {'x', 'y'}\nList listOfLists = (List) parser.parseExpression(\"{{'a','b'},{'x','y'}}\").getValue(context);\n```\n\n# 배열 생성\n\n``` java\nint[] numbers1 = (int[]) parser.parseExpression(\"new int[4]\").getValue(context); \n\n// initializer가진 배열\nint[] numbers2 = (int[]) parser.parseExpression(\"new int[]{1,2,3}\").getValue(context); \n\n// 다차원 배열\nint[][] numbers3 = (int[][]) parser.parseExpression(\"new int[4][5]\").getValue(context);\n```\n\n* Java 문법과 같은 표현식을 사용하여 배열을 생성 할 수 있다.\n* {} 표현식을 통해 초기값을 세팅할 수 있다.\n* 2차원 배열이상의 다차원 배열도 선언이 가능하다. (`단, 다차원 배열은 초기값을 설정할 수 없다.`)\n\n# 연산자\n\n## 관계 연산자\n\n표준 관계 연산자를 사용한다. 사용 할 수 있는 관계 연산자는 아래와 같다.\n\n* 같음 (`==`)\n* 같지 않음 (`!=`)\n* 작음 (`<`)\n* 작거나 같음 (`<=`)\n* 큼 (`>`)\n* 크거나 같음 (`>=`)\n\n``` java\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"2 == 2\").getValue(Boolean.class);\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"2 < -5.0\").getValue(Boolean.class);\n\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"'black' < 'block'\").getValue(Boolean.class);\n```\n\n## 심볼릭 연산자\n\nXML과 같이 문서형식에 관계 연산자가 제한을 받는 경우, 사용 가능한 문자 표현식을 제공한다.\n연산자에 대한 대소문자는 구별하지 않는다.\n\n* 같음 (`eq`)\n* 같지 않음 (`ne`)\n* 작음 (`lt`)\n* 작거나 같음 (`le`)\n* 큼 (`gt`)\n* 크거나 같음 (`gt`)\n* div (`/`)\n* mod (`%`)\n* not (`!`)\n\n``` java\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"22 eq 22\").getValue(Boolean.class);\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"'test' eq 'test!'\").getValue(Boolean.class);\n```\n\n## 정규 표현식\n\nmatches를 이용한 정규표현식을 지원한다.\n\n``` java\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"'5.00' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n```\n\n## instanceof\n\nJava에서 super타입에 대한 연산을 위해 instanceof를 표현식으로 사용할 수 있다.\n\n``` java\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"'xyz' instanceof T(int)\").getValue(Boolean.class);\n\n// true로 평가된다.\nboolean trueValue = parser.parseExpression(\"'xyz' instanceof T(String)\").getValue(Boolean.class);\n```\n\n## 논리연산자\n\nAND, OR, NOT에 대한 표현식을 지원한다.\n\n``` java\n// -- AND --\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"true and false\").getValue(Boolean.class);\n\n// true로 평가된다\nString expression =  \"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\";\nboolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n\n// -- OR --\n\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"true or false\").getValue(Boolean.class);\n\n// true로 평가된다\nString expression =  \"isMember('Nikola Tesla') or isMember('Albert Einstien')\";\nboolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n\n// -- NOT --\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"!true\").getValue(Boolean.class);\n\n// -- AND and NOT --\nString expression =  \"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\";\nboolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n```\n\n## 수식 연산자\n\n* 더하기 (+) 연산자를 숫자, 날짜, 문자열에 사용할 수 있다.\n* 빼기(-) 연산자를 숫자, 날짜에 사용할 수 있다.\n* 곱하기(*), 나누기(/), 나머지(%)에 대한 연산은 숫자에만 사용 할 수 있다.\n* 연산자 우선 순위 법칙이 적용된다.\n\n``` java\n// 더하기\nint two = parser.parseExpression(\"1 + 1\").getValue(Integer.class); // 2\nString testString = parser.parseExpression(\"'test' + ' ' + 'string'\").getValue(String.class);  // 'test string'\n\n// 빼기\nint four =  parser.parseExpression(\"1 - -3\").getValue(Integer.class); // 4\ndouble d = parser.parseExpression(\"1000.00 - 1e4\").getValue(Double.class); // -9000\n\n// 곱하기\nint six =  parser.parseExpression(\"-2 * -3\").getValue(Integer.class); // 6\ndouble twentyFour = parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(Double.class); // 24.0\n\n// 나누기\nint minusTwo =  parser.parseExpression(\"6 / -3\").getValue(Integer.class); // -2\ndouble one = parser.parseExpression(\"8.0 / 4e0 / 2\").getValue(Double.class); // 1.0\n\n// 계수(Modulus)\nint three =  parser.parseExpression(\"7 % 4\").getValue(Integer.class); // 3\nint one = parser.parseExpression(\"8 / 5 % 2\").getValue(Integer.class); // 1\n\n// 연산자 우선순위\nint minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(Integer.class); // -21\n```\n\n## 3항 연산자 (If-Then-Else)\n\n표현식에서 3항연산자를 통해 if-then-else 로직을 수행할 수 있다.\n```java\n//falseExp로 평가 된다.\nString falseString = parser.parseExpression(\"false ? 'trueExp' : 'falseExp'\").getValue(String.class);\n```\n\n## Elvis 연산자\n* Elvis 연산자는 3항 연산자 구문을 단축시키고 Groovy 언어로 사용된다.\n* 3항 연산자는 변수를 2번 반복해서 써야하는 단점이 있다.\n\n```java\nString name = \"Elvis Presley\";\nString displayName = name != null ? name : \"Unknown\";\n```\n\n이런 조잡한 표현식 대신에 Elvis 연산자를 사용하면..\n```java\nExpressionParser parser = new SpelExpressionParser();\nString name = parser.parseExpression(\"name?:'Unknown'\").getValue(String.class);  \nSystem.out.println(name); // 'Unknown'\n```\n\n간단하게 변수에 대해 `?` 를 붙여주는 것만으로도 null 체크를 해준다.\n? 모양이 엘비스 프레슬리의 머리모양을 닮아서 Elvis 연산자라고 명명하였다고 한다.\n\n\n\n## 안전한탐색(Navigation) 연산자\n* 안전한 탐색 연산자는 NPE를 피하기 위해 사용, Groovy 언어로 제공\n* java로 코딩을 하다보면 습관적으로 if(variable == null) 과 같은 체크를 하게 된다.\n* 하지만 Safe Navigation 연산자를 사용하면 NPE를 발생시키지 않고, 그냥 null을 리턴해 준다.\n\n```java\nExpressionParser parser = new SpelExpressionParser();\n\nInventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\ntesla.setPlaceOfBirth(new PlaceOfBirth(\"Smiljan\"));\n\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\n\n//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행\nString city = parser.parseExpression(\"PlaceOfBirth?.City\").getValue(context, String.class);\nSystem.out.println(city); // Smiljan\n\ntesla.setPlaceOfBirth(null);\n\n //placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행\ncity = parser.parseExpression(\"PlaceOfBirth?.City\").getValue(context, String.class);\nSystem.out.println(city); // null - null pointer exception이 발생하지 않는다.\n```\n\n\n\n# 할당\n\n* 할당연산자(`=`)를 이용하여 Context내의 프로퍼티에 value를 할당 할 수 있다.\n* 보통은 setValue 메서드를 이용하여 value를 할당\n* getValue 메서드를 이용하여 할당 할 수도 있다.\n\n``` java\nInventor inventor = new Inventor();\nStandardEvaluationContext inventorContext = new StandardEvaluationContext(inventor);\n//inventor.name에 Alexander Seovic2 문자열을 할당\nparser.parseExpression(\"Name\").setValue(inventorContext, \"Alexander Seovic2\");\n\n//할당연산자(`=`)를 이용하여 inventor.name에 Alexander Seovic2 문자열을 할당\nString aleks = parser.parseExpression(\"Name = 'Alexandar Seovic'\").getValue(inventorContext, String.class);\n```\n\n# 클래스 표현식\n\n* `T` 연산자를 통해 클래스의 인스턴스를 지정하는데 사용할 수 있다.\n* `T` 연산자를 통해 클래스의 static method도 사용할 수 있다.\n* 웬만하면 full package를 적어준다.\n* StandardEvaluationContext는 타입을 찾으려고 TypeLocator를 사용\n* StandardTypeLocator는 java.lang 패키지로 만들어진다.\n* 따라서 java.lang.String과 같은 타입은 T(String)으로 간단하게 표현 가능하다.\n\n``` java\nClass dateClass = parser.parseExpression(\"T(java.util.Date)\").getValue(Class.class);\n\nClass stringClass = parser.parseExpression(\"T(String)\").getValue(Class.class);\n\nboolean trueValue = parser.parseExpression(\"T(java.math.RoundingMode).CEILING < T(java.math.RoundingMode).FLOOR\").getValue(Boolean.class);\n```\n\n# 생성자 호출\n\n* 생성자는 새로운 연산자를 사용해서 호출할 수 있다.\n* primitive type(원시 타입 int, double등..)과 String 외에는 모두 정규화된 클래스명을 사용해야 한다.\n\n``` java\nInventor einstein = p.parseExpression(\"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')\").getValue(Inventor.class);\n\n//리스트의 add 메서드내에서 새로운 inventor 인스턴스를 생성한다\np.parseExpression(\"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))\").getValue(societyContext);\n```\n\n# 변수\n\n* `#` 표현식을 통해 표현식 내에 변수를 참조할 수 있다.\n* StandardEvaluationContext에서 setVariable 메서드를 사용해서 변수를 설정한다.\n* 자주 쓰이는 표현식이다. (@Cacheable Annotation에서도 사용)\n\n``` java\nInventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\ncontext.setVariable(\"newName\", \"Mike Tesla\"); //newName변수에 대한 value할당\n\nparser.parseExpression(\"Name = #newName\").getValue(context);\n\nSystem.out.println(tesla.getName()) // \"Mike Tesla\"\n```\n\n## #root\n\n* 변수 #root는 항상 정의되며 루트 컨텍스트 개체의미\n* #root는 항상 루트를 나타낸다.\n* setRootObject 메서드를 통해 root를 정의한다.\n\n``` java\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\n\nSomeCustomObject someObject = new SomeCustomObject();\ncontext.setRootObject(someObject);\n\nString name = \"kocko\";\ncontext.setVariable(\"name\", kocko);\nString statement = \"#root.stringLength(#kocko) == 5\";\nExpression expression = parser.parseExpression(statement);\n\nboolean result = expression.getValue(context, Boolean.class);\n```\n\n* #root는 SomeCustomObject를 의미\n\n## #this\n```java\n// create an array of integers\nList<Integer> primes = new ArrayList<Integer>();\nprimes.addAll(Arrays.asList(2,3,5,7,11,13,17));\n\n// 파서를 생성하고 'primes' 변수를 정수 배열로 설정한다\nExpressionParser parser = new SpelExpressionParser();\nStandardEvaluationContext context = new StandardEvaluationContext();\ncontext.setVariable(\"primes\",primes);\n\n// 리스트에서 10보다 큰 모든 소수(?{...} 선택을 사용)\n// [11, 13, 17]로 평가된다\nList<Integer>\n primesGreaterThanTen = (List<Integer>) \nparser.parseExpression(\"#primes.?[#this>10]\").getValue(context);\n//#primes 변수에 대해 평가하며, #this는 2~17까지 값을 의미한다.\n```\n* #this는 항상 정의되어 있고, 현재 평가되는 객체를 가리킨다.\n* #this는 계속 변경될 수 있다. (위의 예제에서 보면 2,3,5,7등 평가 시점에 따라 달라질수 있다.)\n\n\n\n# 사용자 정의 함수\n* 표현식 문자열 내에서 호출 가능한 사용자 정의 함수를 등록하여 SpEL의 기능을 확장할 수 있다.\n* StandardEvaluationContext에 사용자정의 함수를 등록하여 사용하면 된다.\n\n예시로 문자열을 reverse 하는 메서드를 구현하였다.\n```java\npublic abstract class StringUtils {\n\n    public static String reverseString(String input) {\n        StringBuilder backwards = new StringBuilder();\n        for (int i = 0; i < input.length(); i++)\n            backwards.append(input.charAt(input.length() - 1 - i));\n        }\n        return backwards.toString();\n    }\n}\n```\n\n메서드를 StandardEvaluationContext에 등록\n```java\nExpressionParser parser = new SpelExpressionParser();\nStandardEvaluationContext context = new StandardEvaluationContext();\n\n//StringUtils 클래스에 정의된 reserveString 메서드를 등록한다.\n//파라미터 타입은 String 타입 객체 1개이다.\ncontext.registerFunction(\"reverseString\", StringUtils.class.getDeclaredMethod(\"reverseString\", new Class[] { String.class }));\n\n//hello 문자열을 뒤집은 olleh가 리턴된다.\nString helloWorldReversed = parser.parseExpression(\"#reverseString('hello')\").getValue(context, String.class);\n```\n\n# Bean 참조\n\nevaluation context에 Bean Resolver가 설정된 경우 `@` 표현식으로 bean을 사용할 수 있다.\nSpring Docs에 있는 예제는 잘 이해가 안되어 직접 테스트 해보았다.\n\n\nBean 클래스 생성\n```java\n@Component\npublic class TestBean {\n\n\tpublic String test(){\n\t\treturn \"do Test\";\n\t}\n}\n```\n\n```java\n@Controller\npublic class TestController {\n\n\t@Autowired\n\tprivate ApplicationContext applicationContext;\n\n\t@RequestMapping(\"/test\")\n\t@ResponseBody\n\tpublic String test() {\n\t\tExpressionParser parser = new SpelExpressionParser();\n\t\tStandardEvaluationContext context = new StandardEvaluationContext();\n\n\t\t//실용적인 테스트를 위해 Application Context의 BeanFactory를 설정\n\t\tDefaultListableBeanFactory factory = (DefaultListableBeanFactory) ((ConfigurableApplicationContext) applicationContext).getBeanFactory();\n\t\tcontext.setBeanResolver(new BeanFactoryResolver(factory));\n\n\t\t//Application Context에 등록된 testBean이라는 bean을 불러와 test메서드를 실행하였다.\n\t\tString result = parser.parseExpression(\"@testBean.test()\").getValue(context, String.class);\n\t\treturn result; //do Test가 리턴되었다.\n\t}\n}\n```\n\n\n# Collection 선택 기능\n\n* 컬렉션 (Collection) 선택 기능은 Context내의 Collection 필드에 접근하여 조건(Criteria)를 기반으로 서브 컬렉션을 반환 할 수 있다.\n* `?[selectionExpression]` 표현식을 이용한다.\n* 리스트, 맵에서 모두 사용 가능하다\n* 객체가 context로 들어오는 경우 object.?[필드에 대한 조건]\n* 컬렉션이 context로 들어오는 경우 .?[필드에 대한 조건] (별도의 필드가 없는 경우 #this를 사용)\n\nTwice 클래스를 선언\n```java\n@NoArgsConstructor\npublic static class Twice {\n    @Getter\n    private List<Member> members = new ArrayList<Member>() {\n        {\n            add(new Member(\"지효\", 23));\n            add(new Member(\"나연\", 24));\n            add(new Member(\"모모\", 23));\n            add(new Member(\"사나\", 23));\n            add(new Member(\"다현\", 21));\n            add(new Member(\"미나\", 23));\n            add(new Member(\"채영\", 19));\n            add(new Member(\"쯔위\", 19));\n            add(new Member(\"정연\", 23));\n        }\n    };\n}\n\n@NoArgsConstructor\n@AllArgsConstructor\n@Getter\npublic static class Member{\n    private String name;\n    private int age;\n}\n```\n\n```java\npublic List<Twice> twice() {\n    ExpressionParser parser = new SpelExpressionParser();\n    StandardEvaluationContext context = new StandardEvaluationContext();\n\n    // Twice의 멤버 필드에 접근\n    // 컬렉션의 age 필드에 대해 20 이하인 대상을 반환\n    List<Twice> filterList = (List<Twice>) parser.parseExpression(\"members.?[age < 20]\").getValue(new Twice());\n    return filterList; //[{\"name\":\"채영\",\"age\":19},{\"name\":\"쯔위\",\"age\":19}]\n}\n```\n\n# Collection 투영 기능\n* 투영기능은 컬렉션에 하위표현식을 반영하여 새로운 컬렉션을 리턴한다.\n* `![projectionExpression]` 표현식을 사용한다.\n\n위의 Twice 예제를 바탕으로 설명하겠다.\n```java\npublic List<String> twice2() {\n    ExpressionParser parser = new SpelExpressionParser();\n    StandardEvaluationContext context = new StandardEvaluationContext();\n\n    List<Member> testList = new ArrayList<Member>() {\n        {\n            add(new Member(\"지효\", 23));\n            add(new Member(\"나연\", 24));\n            add(new Member(\"모모\", 23));\n            add(new Member(\"사나\", 23));\n            add(new Member(\"다현\", 21));\n            add(new Member(\"미나\", 23));\n            add(new Member(\"채영\", 19));\n            add(new Member(\"쯔위\", 19));\n            add(new Member(\"정연\", 23));\n        }\n    };\n    // Twice 멤버 배열을 받아, 컬렉션 투영기능을 이용하여 그중 name에 대한 필드만 뽑아온 것이다.\n    List<String> filterList = (List<String>) parser.parseExpression(\"![name]\").getValue(testList);\n    return filterList; //[\"지효\",\"나연\",\"모모\",\"사나\",\"다현\",\"미나\",\"채영\",\"쯔위\",\"정연\"]\n}\n```\n\n\n\n# 표현식 템플릿\n* 표현식 템플릿을 사용하면 평가 블록과 Literal text를 혼합할 수 있다.\n* 평가블록은 prefix와 subfix로 구분\n* 일반적으로 `#{` 와 `}`로 구분한다.\n* parseExpression() 메서드의 두번째 파라미터로 사용자 정의 ParseContext 객체를 넣어준다.\n\n```java\npublic class TemplateParserContext implements ParserContext {\n\n  public String getExpressionPrefix() {\n    return \"#{\";\n  }\n\n  public String getExpressionSuffix() {\n    return \"}\";\n  }\n  \n  public boolean isTemplate() {\n    return true;\n  }\n}\n```\n\n```java\n// \"random number is 0.7038186818312008\"로 평가된다\nString randomPhrase = \n   parser.parseExpression(\"random number is #{T(java.lang.Math).random()}\", new TemplateParserContext()).getValue(String.class);\n\n```","source":"_posts/2018-11-25-spel-expression-2.md","raw":"---\nlayout: posts\ntitle: SpEL Expression(2)\ncatalog: true\nCategories:\n- Spring\ntags:\n- Spring\n- SpEL\ndate: 2018-11-25 17:11:42\ntypora-root-url: 2018-11-25-spel-expression-2\ntypora-copy-images-to: 2018-11-25-spel-expression-2\n---\n\n# 리터럴 표현식 (Literal Expression)\n\n리터럴 표현식을 제공하는 타입은 문자열(String), 숫자(int, real, hex), boolean, null이다.\n\n* 문자열 (Strings)는 따옴표(')로 구분된다 `(쌍따옴표가 아님)` \\- 문자열 표현 시\\, `'Hello World'` 처럼 SpEL을 작성\n\n다음은 리터럴 표현식 (Literal Expression)에 대한 간단한 예제이다.\n\n``` java\nExpressionParser parser = new SpelExpressionParser();\n\n//따옴표로 이루어진 'Hello World' => Hello World라는 문자열로 평가 된다.\nString helloWorld = (String) parser.parseExpression(\"'Hello World'\").getValue();\n//Double 타입의 숫자로 평가\ndouble avogadrosNumber = (Double) parser.parseExpression(\"6.0221415E+23\").getValue();\n//2147483647로 평가\nint maxValue = (Integer) parser.parseExpression(\"0x7FFFFFFF\").getValue();\n\nboolean trueValue = (Boolean) parser.parseExpression(\"true\").getValue();\n//null로 평가 된다. -> null String이 아니다. (주의)\nObject nullValue = parser.parseExpression(\"null\").getValue();\n```\n\n* 숫자는 음수기호(-), 지수표시(E), 소수점(.)을 지원한다.\n* 기본적으로 실제 숫자는 Double.parseDouble()로 파싱한다.\n\n# 메서드 호출\n\n``` java\n//String 리터럴 abc에 대한 substring 메서드 호출 -> bc가 리턴된다.\nString c = parser.parseExpression(\"'abc'.substring(2, 3)\").getValue(String.class);\n\n//사용자 정의 메서드 호출 (Return Type : Boolean) -> boolean 타입으로 평가된다.\nboolean isMember = parser.parseExpression(\"isMember('Mihajlo Pupin')\").getValue(\n        societyContext, Boolean.class);\n```\n\n위의 코드는 메서드 호출에 대한 예제 코드이다.\n\n* 메서드는 Java 문법을 사용하여 호출 할 수 있다.\n* Literal에 대한 메서드 호출도 가능하다.\n* Varargs 형식의 파라미터도 지원하고 있다.\n\n# 프로퍼티, 배열, 리스트, 맵에 대한 접근 지원\n\n``` java\nExpressionParser parser = new SpelExpressionParser();\n\n// 발명품 배열\nStandardEvaluationContext teslaContext = new StandardEvaluationContext(tesla);\n\n// \"Induction motor\"로 평가된다.\nString invention = parser.parseExpression(\"inventions[3]\").getValue(teslaContext, String.class); \n\n// 회원 리스트\nStandardEvaluationContext societyContext = new StandardEvaluationContext(ieee);\n\n// \"Nikola Tesla\"로 평가된다.\nString name = parser.parseExpression(\"Members[0].Name\").getValue(societyContext, String.class);\n\n// 리스트와 배열 탐색\n// \"Wireless communication\"로 평가된다.\nString invention = parser.parseExpression(\"Members[0].Inventions[6]\").getValue(societyContext, String.class);\n```\n\n* 프로퍼티의 맨 첫글자는 대소문자를 구별하지 않는다.\n* SpEL은 표준 `dot 표기법`(예: prop1.prop2.prop3)을 사용해서 중첩된 프로퍼티와 프로퍼티의 값 설정도 지원한다.\n* public 필드에 대한 접근을 지원한다.\n\n``` java\n// Officer의 딕션어리\nInventor pupin = parser.parseExpression(\"Officers['president']\").getValue(societyContext, Inventor.class);\n\n// \"Idvor\"로 평가된다\nString city = parser.parseExpression(\"Officers['president'].PlaceOfBirth.City\").getValue(societyContext, String.class);\n\n// 값을 설정한다\nparser.parseExpression(\"Officers['advisors'][0].PlaceOfBirth.Country\").setValue(societyContext, \"Croatia\");\n```\n\n* 대괄호`[]` 를 사용하여 Map의 key를 바탕으로 데이터에 접근한다.\n  (위의 예제에서는 Officers가 `Map`, president가 `key`이다.)\n* SpEL은 표준 'dot' 표기법(예: prop1.prop2.prop3)을 사용해서 Map내의 value 객체의 프로퍼티에도 접근 가능하다.\n* setValue 메서드를 통해 데이터를 수정할 수 있다.\n\n# 인라인 리스트 (Inline list)\n\n리스트는 {} 표기법을 사용하여 리스트로 사용 할 수 있다.\n\n``` java\n// 4개의 숫자를 담고 있는 리스트로 평가된다\nList<Integer> numbers = (List) parser.parseExpression(\"{1,2,3,4}\").getValue(context); \n\n//List의 List의 형태의 List로 평가된다.\n//listOfLists[0] = {'a', 'b'}\n//listOfLists[1] = {'x', 'y'}\nList listOfLists = (List) parser.parseExpression(\"{{'a','b'},{'x','y'}}\").getValue(context);\n```\n\n# 배열 생성\n\n``` java\nint[] numbers1 = (int[]) parser.parseExpression(\"new int[4]\").getValue(context); \n\n// initializer가진 배열\nint[] numbers2 = (int[]) parser.parseExpression(\"new int[]{1,2,3}\").getValue(context); \n\n// 다차원 배열\nint[][] numbers3 = (int[][]) parser.parseExpression(\"new int[4][5]\").getValue(context);\n```\n\n* Java 문법과 같은 표현식을 사용하여 배열을 생성 할 수 있다.\n* {} 표현식을 통해 초기값을 세팅할 수 있다.\n* 2차원 배열이상의 다차원 배열도 선언이 가능하다. (`단, 다차원 배열은 초기값을 설정할 수 없다.`)\n\n# 연산자\n\n## 관계 연산자\n\n표준 관계 연산자를 사용한다. 사용 할 수 있는 관계 연산자는 아래와 같다.\n\n* 같음 (`==`)\n* 같지 않음 (`!=`)\n* 작음 (`<`)\n* 작거나 같음 (`<=`)\n* 큼 (`>`)\n* 크거나 같음 (`>=`)\n\n``` java\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"2 == 2\").getValue(Boolean.class);\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"2 < -5.0\").getValue(Boolean.class);\n\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"'black' < 'block'\").getValue(Boolean.class);\n```\n\n## 심볼릭 연산자\n\nXML과 같이 문서형식에 관계 연산자가 제한을 받는 경우, 사용 가능한 문자 표현식을 제공한다.\n연산자에 대한 대소문자는 구별하지 않는다.\n\n* 같음 (`eq`)\n* 같지 않음 (`ne`)\n* 작음 (`lt`)\n* 작거나 같음 (`le`)\n* 큼 (`gt`)\n* 크거나 같음 (`gt`)\n* div (`/`)\n* mod (`%`)\n* not (`!`)\n\n``` java\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"22 eq 22\").getValue(Boolean.class);\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"'test' eq 'test!'\").getValue(Boolean.class);\n```\n\n## 정규 표현식\n\nmatches를 이용한 정규표현식을 지원한다.\n\n``` java\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"'5.00' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n```\n\n## instanceof\n\nJava에서 super타입에 대한 연산을 위해 instanceof를 표현식으로 사용할 수 있다.\n\n``` java\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"'xyz' instanceof T(int)\").getValue(Boolean.class);\n\n// true로 평가된다.\nboolean trueValue = parser.parseExpression(\"'xyz' instanceof T(String)\").getValue(Boolean.class);\n```\n\n## 논리연산자\n\nAND, OR, NOT에 대한 표현식을 지원한다.\n\n``` java\n// -- AND --\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"true and false\").getValue(Boolean.class);\n\n// true로 평가된다\nString expression =  \"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\";\nboolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n\n// -- OR --\n\n// true로 평가된다\nboolean trueValue = parser.parseExpression(\"true or false\").getValue(Boolean.class);\n\n// true로 평가된다\nString expression =  \"isMember('Nikola Tesla') or isMember('Albert Einstien')\";\nboolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n\n// -- NOT --\n\n// false로 평가된다\nboolean falseValue = parser.parseExpression(\"!true\").getValue(Boolean.class);\n\n// -- AND and NOT --\nString expression =  \"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\";\nboolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n```\n\n## 수식 연산자\n\n* 더하기 (+) 연산자를 숫자, 날짜, 문자열에 사용할 수 있다.\n* 빼기(-) 연산자를 숫자, 날짜에 사용할 수 있다.\n* 곱하기(*), 나누기(/), 나머지(%)에 대한 연산은 숫자에만 사용 할 수 있다.\n* 연산자 우선 순위 법칙이 적용된다.\n\n``` java\n// 더하기\nint two = parser.parseExpression(\"1 + 1\").getValue(Integer.class); // 2\nString testString = parser.parseExpression(\"'test' + ' ' + 'string'\").getValue(String.class);  // 'test string'\n\n// 빼기\nint four =  parser.parseExpression(\"1 - -3\").getValue(Integer.class); // 4\ndouble d = parser.parseExpression(\"1000.00 - 1e4\").getValue(Double.class); // -9000\n\n// 곱하기\nint six =  parser.parseExpression(\"-2 * -3\").getValue(Integer.class); // 6\ndouble twentyFour = parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(Double.class); // 24.0\n\n// 나누기\nint minusTwo =  parser.parseExpression(\"6 / -3\").getValue(Integer.class); // -2\ndouble one = parser.parseExpression(\"8.0 / 4e0 / 2\").getValue(Double.class); // 1.0\n\n// 계수(Modulus)\nint three =  parser.parseExpression(\"7 % 4\").getValue(Integer.class); // 3\nint one = parser.parseExpression(\"8 / 5 % 2\").getValue(Integer.class); // 1\n\n// 연산자 우선순위\nint minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(Integer.class); // -21\n```\n\n## 3항 연산자 (If-Then-Else)\n\n표현식에서 3항연산자를 통해 if-then-else 로직을 수행할 수 있다.\n```java\n//falseExp로 평가 된다.\nString falseString = parser.parseExpression(\"false ? 'trueExp' : 'falseExp'\").getValue(String.class);\n```\n\n## Elvis 연산자\n* Elvis 연산자는 3항 연산자 구문을 단축시키고 Groovy 언어로 사용된다.\n* 3항 연산자는 변수를 2번 반복해서 써야하는 단점이 있다.\n\n```java\nString name = \"Elvis Presley\";\nString displayName = name != null ? name : \"Unknown\";\n```\n\n이런 조잡한 표현식 대신에 Elvis 연산자를 사용하면..\n```java\nExpressionParser parser = new SpelExpressionParser();\nString name = parser.parseExpression(\"name?:'Unknown'\").getValue(String.class);  \nSystem.out.println(name); // 'Unknown'\n```\n\n간단하게 변수에 대해 `?` 를 붙여주는 것만으로도 null 체크를 해준다.\n? 모양이 엘비스 프레슬리의 머리모양을 닮아서 Elvis 연산자라고 명명하였다고 한다.\n\n\n\n## 안전한탐색(Navigation) 연산자\n* 안전한 탐색 연산자는 NPE를 피하기 위해 사용, Groovy 언어로 제공\n* java로 코딩을 하다보면 습관적으로 if(variable == null) 과 같은 체크를 하게 된다.\n* 하지만 Safe Navigation 연산자를 사용하면 NPE를 발생시키지 않고, 그냥 null을 리턴해 준다.\n\n```java\nExpressionParser parser = new SpelExpressionParser();\n\nInventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\ntesla.setPlaceOfBirth(new PlaceOfBirth(\"Smiljan\"));\n\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\n\n//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행\nString city = parser.parseExpression(\"PlaceOfBirth?.City\").getValue(context, String.class);\nSystem.out.println(city); // Smiljan\n\ntesla.setPlaceOfBirth(null);\n\n //placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행\ncity = parser.parseExpression(\"PlaceOfBirth?.City\").getValue(context, String.class);\nSystem.out.println(city); // null - null pointer exception이 발생하지 않는다.\n```\n\n\n\n# 할당\n\n* 할당연산자(`=`)를 이용하여 Context내의 프로퍼티에 value를 할당 할 수 있다.\n* 보통은 setValue 메서드를 이용하여 value를 할당\n* getValue 메서드를 이용하여 할당 할 수도 있다.\n\n``` java\nInventor inventor = new Inventor();\nStandardEvaluationContext inventorContext = new StandardEvaluationContext(inventor);\n//inventor.name에 Alexander Seovic2 문자열을 할당\nparser.parseExpression(\"Name\").setValue(inventorContext, \"Alexander Seovic2\");\n\n//할당연산자(`=`)를 이용하여 inventor.name에 Alexander Seovic2 문자열을 할당\nString aleks = parser.parseExpression(\"Name = 'Alexandar Seovic'\").getValue(inventorContext, String.class);\n```\n\n# 클래스 표현식\n\n* `T` 연산자를 통해 클래스의 인스턴스를 지정하는데 사용할 수 있다.\n* `T` 연산자를 통해 클래스의 static method도 사용할 수 있다.\n* 웬만하면 full package를 적어준다.\n* StandardEvaluationContext는 타입을 찾으려고 TypeLocator를 사용\n* StandardTypeLocator는 java.lang 패키지로 만들어진다.\n* 따라서 java.lang.String과 같은 타입은 T(String)으로 간단하게 표현 가능하다.\n\n``` java\nClass dateClass = parser.parseExpression(\"T(java.util.Date)\").getValue(Class.class);\n\nClass stringClass = parser.parseExpression(\"T(String)\").getValue(Class.class);\n\nboolean trueValue = parser.parseExpression(\"T(java.math.RoundingMode).CEILING < T(java.math.RoundingMode).FLOOR\").getValue(Boolean.class);\n```\n\n# 생성자 호출\n\n* 생성자는 새로운 연산자를 사용해서 호출할 수 있다.\n* primitive type(원시 타입 int, double등..)과 String 외에는 모두 정규화된 클래스명을 사용해야 한다.\n\n``` java\nInventor einstein = p.parseExpression(\"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')\").getValue(Inventor.class);\n\n//리스트의 add 메서드내에서 새로운 inventor 인스턴스를 생성한다\np.parseExpression(\"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))\").getValue(societyContext);\n```\n\n# 변수\n\n* `#` 표현식을 통해 표현식 내에 변수를 참조할 수 있다.\n* StandardEvaluationContext에서 setVariable 메서드를 사용해서 변수를 설정한다.\n* 자주 쓰이는 표현식이다. (@Cacheable Annotation에서도 사용)\n\n``` java\nInventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\ncontext.setVariable(\"newName\", \"Mike Tesla\"); //newName변수에 대한 value할당\n\nparser.parseExpression(\"Name = #newName\").getValue(context);\n\nSystem.out.println(tesla.getName()) // \"Mike Tesla\"\n```\n\n## #root\n\n* 변수 #root는 항상 정의되며 루트 컨텍스트 개체의미\n* #root는 항상 루트를 나타낸다.\n* setRootObject 메서드를 통해 root를 정의한다.\n\n``` java\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\n\nSomeCustomObject someObject = new SomeCustomObject();\ncontext.setRootObject(someObject);\n\nString name = \"kocko\";\ncontext.setVariable(\"name\", kocko);\nString statement = \"#root.stringLength(#kocko) == 5\";\nExpression expression = parser.parseExpression(statement);\n\nboolean result = expression.getValue(context, Boolean.class);\n```\n\n* #root는 SomeCustomObject를 의미\n\n## #this\n```java\n// create an array of integers\nList<Integer> primes = new ArrayList<Integer>();\nprimes.addAll(Arrays.asList(2,3,5,7,11,13,17));\n\n// 파서를 생성하고 'primes' 변수를 정수 배열로 설정한다\nExpressionParser parser = new SpelExpressionParser();\nStandardEvaluationContext context = new StandardEvaluationContext();\ncontext.setVariable(\"primes\",primes);\n\n// 리스트에서 10보다 큰 모든 소수(?{...} 선택을 사용)\n// [11, 13, 17]로 평가된다\nList<Integer>\n primesGreaterThanTen = (List<Integer>) \nparser.parseExpression(\"#primes.?[#this>10]\").getValue(context);\n//#primes 변수에 대해 평가하며, #this는 2~17까지 값을 의미한다.\n```\n* #this는 항상 정의되어 있고, 현재 평가되는 객체를 가리킨다.\n* #this는 계속 변경될 수 있다. (위의 예제에서 보면 2,3,5,7등 평가 시점에 따라 달라질수 있다.)\n\n\n\n# 사용자 정의 함수\n* 표현식 문자열 내에서 호출 가능한 사용자 정의 함수를 등록하여 SpEL의 기능을 확장할 수 있다.\n* StandardEvaluationContext에 사용자정의 함수를 등록하여 사용하면 된다.\n\n예시로 문자열을 reverse 하는 메서드를 구현하였다.\n```java\npublic abstract class StringUtils {\n\n    public static String reverseString(String input) {\n        StringBuilder backwards = new StringBuilder();\n        for (int i = 0; i < input.length(); i++)\n            backwards.append(input.charAt(input.length() - 1 - i));\n        }\n        return backwards.toString();\n    }\n}\n```\n\n메서드를 StandardEvaluationContext에 등록\n```java\nExpressionParser parser = new SpelExpressionParser();\nStandardEvaluationContext context = new StandardEvaluationContext();\n\n//StringUtils 클래스에 정의된 reserveString 메서드를 등록한다.\n//파라미터 타입은 String 타입 객체 1개이다.\ncontext.registerFunction(\"reverseString\", StringUtils.class.getDeclaredMethod(\"reverseString\", new Class[] { String.class }));\n\n//hello 문자열을 뒤집은 olleh가 리턴된다.\nString helloWorldReversed = parser.parseExpression(\"#reverseString('hello')\").getValue(context, String.class);\n```\n\n# Bean 참조\n\nevaluation context에 Bean Resolver가 설정된 경우 `@` 표현식으로 bean을 사용할 수 있다.\nSpring Docs에 있는 예제는 잘 이해가 안되어 직접 테스트 해보았다.\n\n\nBean 클래스 생성\n```java\n@Component\npublic class TestBean {\n\n\tpublic String test(){\n\t\treturn \"do Test\";\n\t}\n}\n```\n\n```java\n@Controller\npublic class TestController {\n\n\t@Autowired\n\tprivate ApplicationContext applicationContext;\n\n\t@RequestMapping(\"/test\")\n\t@ResponseBody\n\tpublic String test() {\n\t\tExpressionParser parser = new SpelExpressionParser();\n\t\tStandardEvaluationContext context = new StandardEvaluationContext();\n\n\t\t//실용적인 테스트를 위해 Application Context의 BeanFactory를 설정\n\t\tDefaultListableBeanFactory factory = (DefaultListableBeanFactory) ((ConfigurableApplicationContext) applicationContext).getBeanFactory();\n\t\tcontext.setBeanResolver(new BeanFactoryResolver(factory));\n\n\t\t//Application Context에 등록된 testBean이라는 bean을 불러와 test메서드를 실행하였다.\n\t\tString result = parser.parseExpression(\"@testBean.test()\").getValue(context, String.class);\n\t\treturn result; //do Test가 리턴되었다.\n\t}\n}\n```\n\n\n# Collection 선택 기능\n\n* 컬렉션 (Collection) 선택 기능은 Context내의 Collection 필드에 접근하여 조건(Criteria)를 기반으로 서브 컬렉션을 반환 할 수 있다.\n* `?[selectionExpression]` 표현식을 이용한다.\n* 리스트, 맵에서 모두 사용 가능하다\n* 객체가 context로 들어오는 경우 object.?[필드에 대한 조건]\n* 컬렉션이 context로 들어오는 경우 .?[필드에 대한 조건] (별도의 필드가 없는 경우 #this를 사용)\n\nTwice 클래스를 선언\n```java\n@NoArgsConstructor\npublic static class Twice {\n    @Getter\n    private List<Member> members = new ArrayList<Member>() {\n        {\n            add(new Member(\"지효\", 23));\n            add(new Member(\"나연\", 24));\n            add(new Member(\"모모\", 23));\n            add(new Member(\"사나\", 23));\n            add(new Member(\"다현\", 21));\n            add(new Member(\"미나\", 23));\n            add(new Member(\"채영\", 19));\n            add(new Member(\"쯔위\", 19));\n            add(new Member(\"정연\", 23));\n        }\n    };\n}\n\n@NoArgsConstructor\n@AllArgsConstructor\n@Getter\npublic static class Member{\n    private String name;\n    private int age;\n}\n```\n\n```java\npublic List<Twice> twice() {\n    ExpressionParser parser = new SpelExpressionParser();\n    StandardEvaluationContext context = new StandardEvaluationContext();\n\n    // Twice의 멤버 필드에 접근\n    // 컬렉션의 age 필드에 대해 20 이하인 대상을 반환\n    List<Twice> filterList = (List<Twice>) parser.parseExpression(\"members.?[age < 20]\").getValue(new Twice());\n    return filterList; //[{\"name\":\"채영\",\"age\":19},{\"name\":\"쯔위\",\"age\":19}]\n}\n```\n\n# Collection 투영 기능\n* 투영기능은 컬렉션에 하위표현식을 반영하여 새로운 컬렉션을 리턴한다.\n* `![projectionExpression]` 표현식을 사용한다.\n\n위의 Twice 예제를 바탕으로 설명하겠다.\n```java\npublic List<String> twice2() {\n    ExpressionParser parser = new SpelExpressionParser();\n    StandardEvaluationContext context = new StandardEvaluationContext();\n\n    List<Member> testList = new ArrayList<Member>() {\n        {\n            add(new Member(\"지효\", 23));\n            add(new Member(\"나연\", 24));\n            add(new Member(\"모모\", 23));\n            add(new Member(\"사나\", 23));\n            add(new Member(\"다현\", 21));\n            add(new Member(\"미나\", 23));\n            add(new Member(\"채영\", 19));\n            add(new Member(\"쯔위\", 19));\n            add(new Member(\"정연\", 23));\n        }\n    };\n    // Twice 멤버 배열을 받아, 컬렉션 투영기능을 이용하여 그중 name에 대한 필드만 뽑아온 것이다.\n    List<String> filterList = (List<String>) parser.parseExpression(\"![name]\").getValue(testList);\n    return filterList; //[\"지효\",\"나연\",\"모모\",\"사나\",\"다현\",\"미나\",\"채영\",\"쯔위\",\"정연\"]\n}\n```\n\n\n\n# 표현식 템플릿\n* 표현식 템플릿을 사용하면 평가 블록과 Literal text를 혼합할 수 있다.\n* 평가블록은 prefix와 subfix로 구분\n* 일반적으로 `#{` 와 `}`로 구분한다.\n* parseExpression() 메서드의 두번째 파라미터로 사용자 정의 ParseContext 객체를 넣어준다.\n\n```java\npublic class TemplateParserContext implements ParserContext {\n\n  public String getExpressionPrefix() {\n    return \"#{\";\n  }\n\n  public String getExpressionSuffix() {\n    return \"}\";\n  }\n  \n  public boolean isTemplate() {\n    return true;\n  }\n}\n```\n\n```java\n// \"random number is 0.7038186818312008\"로 평가된다\nString randomPhrase = \n   parser.parseExpression(\"random number is #{T(java.lang.Math).random()}\", new TemplateParserContext()).getValue(String.class);\n\n```","slug":"2018-11-25-spel-expression-2","published":1,"updated":"2018-11-27T07:23:32.394Z","comments":1,"photos":[],"link":"","_id":"cjp55h5j9001w4f1td717kvpq","content":"<h1><span id=\"리터럴-표현식-literal-expression\">리터럴 표현식 (Literal Expression)</span></h1>\n<p>리터럴 표현식을 제공하는 타입은 문자열(String), 숫자(int, real, hex), boolean, null이다.</p>\n<ul>\n<li>문자열 (Strings)는 따옴표(’)로 구분된다 <code>(쌍따옴표가 아님)</code> - 문자열 표현 시, <code>'Hello World'</code> 처럼 SpEL을 작성</li>\n</ul>\n<p>다음은 리터럴 표현식 (Literal Expression)에 대한 간단한 예제이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//따옴표로 이루어진 'Hello World' =&gt; Hello World라는 문자열로 평가 된다.</span></span><br><span class=\"line\">String helloWorld = (String) parser.parseExpression(<span class=\"string\">\"'Hello World'\"</span>).getValue();</span><br><span class=\"line\"><span class=\"comment\">//Double 타입의 숫자로 평가</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> avogadrosNumber = (Double) parser.parseExpression(<span class=\"string\">\"6.0221415E+23\"</span>).getValue();</span><br><span class=\"line\"><span class=\"comment\">//2147483647로 평가</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> maxValue = (Integer) parser.parseExpression(<span class=\"string\">\"0x7FFFFFFF\"</span>).getValue();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = (Boolean) parser.parseExpression(<span class=\"string\">\"true\"</span>).getValue();</span><br><span class=\"line\"><span class=\"comment\">//null로 평가 된다. -&gt; null String이 아니다. (주의)</span></span><br><span class=\"line\">Object nullValue = parser.parseExpression(<span class=\"string\">\"null\"</span>).getValue();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>숫자는 음수기호(-), 지수표시(E), 소수점(.)을 지원한다.</li>\n<li>기본적으로 실제 숫자는 Double.parseDouble()로 파싱한다.</li>\n</ul>\n<h1><span id=\"메서드-호출\">메서드 호출</span></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//String 리터럴 abc에 대한 substring 메서드 호출 -&gt; bc가 리턴된다.</span></span><br><span class=\"line\">String c = parser.parseExpression(<span class=\"string\">\"'abc'.substring(2, 3)\"</span>).getValue(String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//사용자 정의 메서드 호출 (Return Type : Boolean) -&gt; boolean 타입으로 평가된다.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isMember = parser.parseExpression(<span class=\"string\">\"isMember('Mihajlo Pupin')\"</span>).getValue(</span><br><span class=\"line\">        societyContext, Boolean.class);</span><br></pre></td></tr></table></figure>\n<p>위의 코드는 메서드 호출에 대한 예제 코드이다.</p>\n<ul>\n<li>메서드는 Java 문법을 사용하여 호출 할 수 있다.</li>\n<li>Literal에 대한 메서드 호출도 가능하다.</li>\n<li>Varargs 형식의 파라미터도 지원하고 있다.</li>\n</ul>\n<h1><span id=\"프로퍼티-배열-리스트-맵에-대한-접근-지원\">프로퍼티, 배열, 리스트, 맵에 대한 접근 지원</span></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 발명품 배열</span></span><br><span class=\"line\">StandardEvaluationContext teslaContext = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Induction motor\"로 평가된다.</span></span><br><span class=\"line\">String invention = parser.parseExpression(<span class=\"string\">\"inventions[3]\"</span>).getValue(teslaContext, String.class); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 회원 리스트</span></span><br><span class=\"line\">StandardEvaluationContext societyContext = <span class=\"keyword\">new</span> StandardEvaluationContext(ieee);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Nikola Tesla\"로 평가된다.</span></span><br><span class=\"line\">String name = parser.parseExpression(<span class=\"string\">\"Members[0].Name\"</span>).getValue(societyContext, String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 리스트와 배열 탐색</span></span><br><span class=\"line\"><span class=\"comment\">// \"Wireless communication\"로 평가된다.</span></span><br><span class=\"line\">String invention = parser.parseExpression(<span class=\"string\">\"Members[0].Inventions[6]\"</span>).getValue(societyContext, String.class);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>프로퍼티의 맨 첫글자는 대소문자를 구별하지 않는다.</li>\n<li>SpEL은 표준 <code>dot 표기법</code>(예: prop1.prop2.prop3)을 사용해서 중첩된 프로퍼티와 프로퍼티의 값 설정도 지원한다.</li>\n<li>public 필드에 대한 접근을 지원한다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Officer의 딕션어리</span></span><br><span class=\"line\">Inventor pupin = parser.parseExpression(<span class=\"string\">\"Officers['president']\"</span>).getValue(societyContext, Inventor.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Idvor\"로 평가된다</span></span><br><span class=\"line\">String city = parser.parseExpression(<span class=\"string\">\"Officers['president'].PlaceOfBirth.City\"</span>).getValue(societyContext, String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 값을 설정한다</span></span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"Officers['advisors'][0].PlaceOfBirth.Country\"</span>).setValue(societyContext, <span class=\"string\">\"Croatia\"</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>대괄호<code>[]</code> 를 사용하여 Map의 key를 바탕으로 데이터에 접근한다.<br>\n(위의 예제에서는 Officers가 <code>Map</code>, president가 <code>key</code>이다.)</li>\n<li>SpEL은 표준 ‘dot’ 표기법(예: prop1.prop2.prop3)을 사용해서 Map내의 value 객체의 프로퍼티에도 접근 가능하다.</li>\n<li>setValue 메서드를 통해 데이터를 수정할 수 있다.</li>\n</ul>\n<h1><span id=\"인라인-리스트-inline-list\">인라인 리스트 (Inline list)</span></h1>\n<p>리스트는 {} 표기법을 사용하여 리스트로 사용 할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 4개의 숫자를 담고 있는 리스트로 평가된다</span></span><br><span class=\"line\">List&lt;Integer&gt; numbers = (List) parser.parseExpression(<span class=\"string\">\"&#123;1,2,3,4&#125;\"</span>).getValue(context); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//List의 List의 형태의 List로 평가된다.</span></span><br><span class=\"line\"><span class=\"comment\">//listOfLists[0] = &#123;'a', 'b'&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//listOfLists[1] = &#123;'x', 'y'&#125;</span></span><br><span class=\"line\">List listOfLists = (List) parser.parseExpression(<span class=\"string\">\"&#123;&#123;'a','b'&#125;,&#123;'x','y'&#125;&#125;\"</span>).getValue(context);</span><br></pre></td></tr></table></figure>\n<h1><span id=\"배열-생성\">배열 생성</span></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] numbers1 = (<span class=\"keyword\">int</span>[]) parser.parseExpression(<span class=\"string\">\"new int[4]\"</span>).getValue(context); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// initializer가진 배열</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] numbers2 = (<span class=\"keyword\">int</span>[]) parser.parseExpression(<span class=\"string\">\"new int[]&#123;1,2,3&#125;\"</span>).getValue(context); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 다차원 배열</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[][] numbers3 = (<span class=\"keyword\">int</span>[][]) parser.parseExpression(<span class=\"string\">\"new int[4][5]\"</span>).getValue(context);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Java 문법과 같은 표현식을 사용하여 배열을 생성 할 수 있다.</li>\n<li>{} 표현식을 통해 초기값을 세팅할 수 있다.</li>\n<li>2차원 배열이상의 다차원 배열도 선언이 가능하다. (<code>단, 다차원 배열은 초기값을 설정할 수 없다.</code>)</li>\n</ul>\n<h1><span id=\"연산자\">연산자</span></h1>\n<h2><span id=\"관계-연산자\">관계 연산자</span></h2>\n<p>표준 관계 연산자를 사용한다. 사용 할 수 있는 관계 연산자는 아래와 같다.</p>\n<ul>\n<li>같음 (<code>==</code>)</li>\n<li>같지 않음 (<code>!=</code>)</li>\n<li>작음 (<code>&lt;</code>)</li>\n<li>작거나 같음 (<code>&lt;=</code>)</li>\n<li>큼 (<code>&gt;</code>)</li>\n<li>크거나 같음 (<code>&gt;=</code>)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"2 == 2\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"2 &lt; -5.0\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"'black' &lt; 'block'\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure>\n<h2><span id=\"심볼릭-연산자\">심볼릭 연산자</span></h2>\n<p>XML과 같이 문서형식에 관계 연산자가 제한을 받는 경우, 사용 가능한 문자 표현식을 제공한다.<br>\n연산자에 대한 대소문자는 구별하지 않는다.</p>\n<ul>\n<li>같음 (<code>eq</code>)</li>\n<li>같지 않음 (<code>ne</code>)</li>\n<li>작음 (<code>lt</code>)</li>\n<li>작거나 같음 (<code>le</code>)</li>\n<li>큼 (<code>gt</code>)</li>\n<li>크거나 같음 (<code>gt</code>)</li>\n<li>div (<code>/</code>)</li>\n<li>mod (<code>%</code>)</li>\n<li>not (<code>!</code>)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"22 eq 22\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"'test' eq 'test!'\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure>\n<h2><span id=\"정규-표현식\">정규 표현식</span></h2>\n<p>matches를 이용한 정규표현식을 지원한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"'5.00' matches '^-?\\\\d+(\\\\.\\\\d&#123;2&#125;)?$'\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d&#123;2&#125;)?$'\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure>\n<h2><span id=\"instanceof\">instanceof</span></h2>\n<p>Java에서 super타입에 대한 연산을 위해 instanceof를 표현식으로 사용할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"'xyz' instanceof T(int)\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"'xyz' instanceof T(String)\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure>\n<h2><span id=\"논리연산자\">논리연산자</span></h2>\n<p>AND, OR, NOT에 대한 표현식을 지원한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- AND --</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"true and false\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\">String expression =  <span class=\"string\">\"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- OR --</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"true or false\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\">String expression =  <span class=\"string\">\"isMember('Nikola Tesla') or isMember('Albert Einstien')\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- NOT --</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"!true\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- AND and NOT --</span></span><br><span class=\"line\">String expression =  <span class=\"string\">\"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br></pre></td></tr></table></figure>\n<h2><span id=\"수식-연산자\">수식 연산자</span></h2>\n<ul>\n<li>더하기 (+) 연산자를 숫자, 날짜, 문자열에 사용할 수 있다.</li>\n<li>빼기(-) 연산자를 숫자, 날짜에 사용할 수 있다.</li>\n<li>곱하기(*), 나누기(/), 나머지(%)에 대한 연산은 숫자에만 사용 할 수 있다.</li>\n<li>연산자 우선 순위 법칙이 적용된다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 더하기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> two = parser.parseExpression(<span class=\"string\">\"1 + 1\"</span>).getValue(Integer.class); <span class=\"comment\">// 2</span></span><br><span class=\"line\">String testString = parser.parseExpression(<span class=\"string\">\"'test' + ' ' + 'string'\"</span>).getValue(String.class);  <span class=\"comment\">// 'test string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 빼기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> four =  parser.parseExpression(<span class=\"string\">\"1 - -3\"</span>).getValue(Integer.class); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> d = parser.parseExpression(<span class=\"string\">\"1000.00 - 1e4\"</span>).getValue(Double.class); <span class=\"comment\">// -9000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 곱하기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> six =  parser.parseExpression(<span class=\"string\">\"-2 * -3\"</span>).getValue(Integer.class); <span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> twentyFour = parser.parseExpression(<span class=\"string\">\"2.0 * 3e0 * 4\"</span>).getValue(Double.class); <span class=\"comment\">// 24.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 나누기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minusTwo =  parser.parseExpression(<span class=\"string\">\"6 / -3\"</span>).getValue(Integer.class); <span class=\"comment\">// -2</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> one = parser.parseExpression(<span class=\"string\">\"8.0 / 4e0 / 2\"</span>).getValue(Double.class); <span class=\"comment\">// 1.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 계수(Modulus)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> three =  parser.parseExpression(<span class=\"string\">\"7 % 4\"</span>).getValue(Integer.class); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> one = parser.parseExpression(<span class=\"string\">\"8 / 5 % 2\"</span>).getValue(Integer.class); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 연산자 우선순위</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minusTwentyOne = parser.parseExpression(<span class=\"string\">\"1+2-3*8\"</span>).getValue(Integer.class); <span class=\"comment\">// -21</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"3항-연산자-if-then-else\">3항 연산자 (If-Then-Else)</span></h2>\n<p>표현식에서 3항연산자를 통해 if-then-else 로직을 수행할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//falseExp로 평가 된다.</span></span><br><span class=\"line\">String falseString = parser.parseExpression(<span class=\"string\">\"false ? 'trueExp' : 'falseExp'\"</span>).getValue(String.class);</span><br></pre></td></tr></table></figure>\n<h2><span id=\"elvis-연산자\">Elvis 연산자</span></h2>\n<ul>\n<li>Elvis 연산자는 3항 연산자 구문을 단축시키고 Groovy 언어로 사용된다.</li>\n<li>3항 연산자는 변수를 2번 반복해서 써야하는 단점이 있다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = <span class=\"string\">\"Elvis Presley\"</span>;</span><br><span class=\"line\">String displayName = name != <span class=\"keyword\">null</span> ? name : <span class=\"string\">\"Unknown\"</span>;</span><br></pre></td></tr></table></figure>\n<p>이런 조잡한 표현식 대신에 Elvis 연산자를 사용하면…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">String name = parser.parseExpression(<span class=\"string\">\"name?:'Unknown'\"</span>).getValue(String.class);  </span><br><span class=\"line\">System.out.println(name); <span class=\"comment\">// 'Unknown'</span></span><br></pre></td></tr></table></figure>\n<p>간단하게 변수에 대해 <code>?</code> 를 붙여주는 것만으로도 null 체크를 해준다.<br>\n? 모양이 엘비스 프레슬리의 머리모양을 닮아서 Elvis 연산자라고 명명하였다고 한다.</p>\n<h2><span id=\"안전한탐색navigation-연산자\">안전한탐색(Navigation) 연산자</span></h2>\n<ul>\n<li>안전한 탐색 연산자는 NPE를 피하기 위해 사용, Groovy 언어로 제공</li>\n<li>java로 코딩을 하다보면 습관적으로 if(variable == null) 과 같은 체크를 하게 된다.</li>\n<li>하지만 Safe Navigation 연산자를 사용하면 NPE를 발생시키지 않고, 그냥 null을 리턴해 준다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\"></span><br><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\">tesla.setPlaceOfBirth(<span class=\"keyword\">new</span> PlaceOfBirth(<span class=\"string\">\"Smiljan\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행</span></span><br><span class=\"line\">String city = parser.parseExpression(<span class=\"string\">\"PlaceOfBirth?.City\"</span>).getValue(context, String.class);</span><br><span class=\"line\">System.out.println(city); <span class=\"comment\">// Smiljan</span></span><br><span class=\"line\"></span><br><span class=\"line\">tesla.setPlaceOfBirth(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행</span></span><br><span class=\"line\">city = parser.parseExpression(<span class=\"string\">\"PlaceOfBirth?.City\"</span>).getValue(context, String.class);</span><br><span class=\"line\">System.out.println(city); <span class=\"comment\">// null - null pointer exception이 발생하지 않는다.</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"할당\">할당</span></h1>\n<ul>\n<li>할당연산자(<code>=</code>)를 이용하여 Context내의 프로퍼티에 value를 할당 할 수 있다.</li>\n<li>보통은 setValue 메서드를 이용하여 value를 할당</li>\n<li>getValue 메서드를 이용하여 할당 할 수도 있다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventor inventor = <span class=\"keyword\">new</span> Inventor();</span><br><span class=\"line\">StandardEvaluationContext inventorContext = <span class=\"keyword\">new</span> StandardEvaluationContext(inventor);</span><br><span class=\"line\"><span class=\"comment\">//inventor.name에 Alexander Seovic2 문자열을 할당</span></span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"Name\"</span>).setValue(inventorContext, <span class=\"string\">\"Alexander Seovic2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//할당연산자(`=`)를 이용하여 inventor.name에 Alexander Seovic2 문자열을 할당</span></span><br><span class=\"line\">String aleks = parser.parseExpression(<span class=\"string\">\"Name = 'Alexandar Seovic'\"</span>).getValue(inventorContext, String.class);</span><br></pre></td></tr></table></figure>\n<h1><span id=\"클래스-표현식\">클래스 표현식</span></h1>\n<ul>\n<li><code>T</code> 연산자를 통해 클래스의 인스턴스를 지정하는데 사용할 수 있다.</li>\n<li><code>T</code> 연산자를 통해 클래스의 static method도 사용할 수 있다.</li>\n<li>웬만하면 full package를 적어준다.</li>\n<li>StandardEvaluationContext는 타입을 찾으려고 TypeLocator를 사용</li>\n<li>StandardTypeLocator는 java.lang 패키지로 만들어진다.</li>\n<li>따라서 java.lang.String과 같은 타입은 T(String)으로 간단하게 표현 가능하다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class dateClass = parser.parseExpression(<span class=\"string\">\"T(java.util.Date)\"</span>).getValue(Class.class);</span><br><span class=\"line\"></span><br><span class=\"line\">Class stringClass = parser.parseExpression(<span class=\"string\">\"T(String)\"</span>).getValue(Class.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure>\n<h1><span id=\"생성자-호출\">생성자 호출</span></h1>\n<ul>\n<li>생성자는 새로운 연산자를 사용해서 호출할 수 있다.</li>\n<li>primitive type(원시 타입 int, double등…)과 String 외에는 모두 정규화된 클래스명을 사용해야 한다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventor einstein = p.parseExpression(<span class=\"string\">\"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')\"</span>).getValue(Inventor.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//리스트의 add 메서드내에서 새로운 inventor 인스턴스를 생성한다</span></span><br><span class=\"line\">p.parseExpression(<span class=\"string\">\"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))\"</span>).getValue(societyContext);</span><br></pre></td></tr></table></figure>\n<h1><span id=\"변수\">변수</span></h1>\n<ul>\n<li><code>#</code> 표현식을 통해 표현식 내에 변수를 참조할 수 있다.</li>\n<li>StandardEvaluationContext에서 setVariable 메서드를 사용해서 변수를 설정한다.</li>\n<li>자주 쓰이는 표현식이다. (@Cacheable Annotation에서도 사용)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\">context.setVariable(<span class=\"string\">\"newName\"</span>, <span class=\"string\">\"Mike Tesla\"</span>); <span class=\"comment\">//newName변수에 대한 value할당</span></span><br><span class=\"line\"></span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"Name = #newName\"</span>).getValue(context);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(tesla.getName()) <span class=\"comment\">// \"Mike Tesla\"</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"root\">#root</span></h2>\n<ul>\n<li>변수 #root는 항상 정의되며 루트 컨텍스트 개체의미</li>\n<li>#root는 항상 루트를 나타낸다.</li>\n<li>setRootObject 메서드를 통해 root를 정의한다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\"></span><br><span class=\"line\">SomeCustomObject someObject = <span class=\"keyword\">new</span> SomeCustomObject();</span><br><span class=\"line\">context.setRootObject(someObject);</span><br><span class=\"line\"></span><br><span class=\"line\">String name = <span class=\"string\">\"kocko\"</span>;</span><br><span class=\"line\">context.setVariable(<span class=\"string\">\"name\"</span>, kocko);</span><br><span class=\"line\">String statement = <span class=\"string\">\"#root.stringLength(#kocko) == 5\"</span>;</span><br><span class=\"line\">Expression expression = parser.parseExpression(statement);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> result = expression.getValue(context, Boolean.class);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>#root는 SomeCustomObject를 의미</li>\n</ul>\n<h2><span id=\"this\">#this</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create an array of integers</span></span><br><span class=\"line\">List&lt;Integer&gt; primes = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">primes.addAll(Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">13</span>,<span class=\"number\">17</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 파서를 생성하고 'primes' 변수를 정수 배열로 설정한다</span></span><br><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\">context.setVariable(<span class=\"string\">\"primes\"</span>,primes);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 리스트에서 10보다 큰 모든 소수(?&#123;...&#125; 선택을 사용)</span></span><br><span class=\"line\"><span class=\"comment\">// [11, 13, 17]로 평가된다</span></span><br><span class=\"line\">List&lt;Integer&gt;</span><br><span class=\"line\"> primesGreaterThanTen = (List&lt;Integer&gt;) </span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"#primes.?[#this&gt;10]\"</span>).getValue(context);</span><br><span class=\"line\"><span class=\"comment\">//#primes 변수에 대해 평가하며, #this는 2~17까지 값을 의미한다.</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>#this는 항상 정의되어 있고, 현재 평가되는 객체를 가리킨다.</li>\n<li>#this는 계속 변경될 수 있다. (위의 예제에서 보면 2,3,5,7등 평가 시점에 따라 달라질수 있다.)</li>\n</ul>\n<h1><span id=\"사용자-정의-함수\">사용자 정의 함수</span></h1>\n<ul>\n<li>표현식 문자열 내에서 호출 가능한 사용자 정의 함수를 등록하여 SpEL의 기능을 확장할 수 있다.</li>\n<li>StandardEvaluationContext에 사용자정의 함수를 등록하여 사용하면 된다.</li>\n</ul>\n<p>예시로 문자열을 reverse 하는 메서드를 구현하였다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringUtils</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">reverseString</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder backwards = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; input.length(); i++)</span><br><span class=\"line\">            backwards.append(input.charAt(input.length() - <span class=\"number\">1</span> - i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> backwards.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>메서드를 StandardEvaluationContext에 등록</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//StringUtils 클래스에 정의된 reserveString 메서드를 등록한다.</span></span><br><span class=\"line\"><span class=\"comment\">//파라미터 타입은 String 타입 객체 1개이다.</span></span><br><span class=\"line\">context.registerFunction(<span class=\"string\">\"reverseString\"</span>, StringUtils.class.getDeclaredMethod(<span class=\"string\">\"reverseString\"</span>, <span class=\"keyword\">new</span> Class[] &#123; String.class &#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//hello 문자열을 뒤집은 olleh가 리턴된다.</span></span><br><span class=\"line\">String helloWorldReversed = parser.parseExpression(<span class=\"string\">\"#reverseString('hello')\"</span>).getValue(context, String.class);</span><br></pre></td></tr></table></figure>\n<h1><span id=\"bean-참조\">Bean 참조</span></h1>\n<p>evaluation context에 Bean Resolver가 설정된 경우 <code>@</code> 표현식으로 bean을 사용할 수 있다.<br>\nSpring Docs에 있는 예제는 잘 이해가 안되어 직접 테스트 해보았다.</p>\n<p>Bean 클래스 생성</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"do Test\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ApplicationContext applicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/test\"</span>)</span><br><span class=\"line\">\t<span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">\t\tStandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//실용적인 테스트를 위해 Application Context의 BeanFactory를 설정</span></span><br><span class=\"line\">\t\tDefaultListableBeanFactory factory = (DefaultListableBeanFactory) ((ConfigurableApplicationContext) applicationContext).getBeanFactory();</span><br><span class=\"line\">\t\tcontext.setBeanResolver(<span class=\"keyword\">new</span> BeanFactoryResolver(factory));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//Application Context에 등록된 testBean이라는 bean을 불러와 test메서드를 실행하였다.</span></span><br><span class=\"line\">\t\tString result = parser.parseExpression(<span class=\"string\">\"@testBean.test()\"</span>).getValue(context, String.class);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result; <span class=\"comment\">//do Test가 리턴되었다.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"collection-선택-기능\">Collection 선택 기능</span></h1>\n<ul>\n<li>컬렉션 (Collection) 선택 기능은 Context내의 Collection 필드에 접근하여 조건(Criteria)를 기반으로 서브 컬렉션을 반환 할 수 있다.</li>\n<li><code>?[selectionExpression]</code> 표현식을 이용한다.</li>\n<li>리스트, 맵에서 모두 사용 가능하다</li>\n<li>객체가 context로 들어오는 경우 object.?[필드에 대한 조건]</li>\n<li>컬렉션이 context로 들어오는 경우 .?[필드에 대한 조건] (별도의 필드가 없는 경우 #this를 사용)</li>\n</ul>\n<p>Twice 클래스를 선언</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Twice</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Getter</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Member&gt; members = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;() &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"지효\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"나연\"</span>, <span class=\"number\">24</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"모모\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"사나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"다현\"</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"미나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"채영\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"쯔위\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"정연\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Twice&gt; <span class=\"title\">twice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">    StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Twice의 멤버 필드에 접근</span></span><br><span class=\"line\">    <span class=\"comment\">// 컬렉션의 age 필드에 대해 20 이하인 대상을 반환</span></span><br><span class=\"line\">    List&lt;Twice&gt; filterList = (List&lt;Twice&gt;) parser.parseExpression(<span class=\"string\">\"members.?[age &lt; 20]\"</span>).getValue(<span class=\"keyword\">new</span> Twice());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> filterList; <span class=\"comment\">//[&#123;\"name\":\"채영\",\"age\":19&#125;,&#123;\"name\":\"쯔위\",\"age\":19&#125;]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"collection-투영-기능\">Collection 투영 기능</span></h1>\n<ul>\n<li>투영기능은 컬렉션에 하위표현식을 반영하여 새로운 컬렉션을 리턴한다.</li>\n<li><code>![projectionExpression]</code> 표현식을 사용한다.</li>\n</ul>\n<p>위의 Twice 예제를 바탕으로 설명하겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">twice2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">    StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Member&gt; testList = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;() &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"지효\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"나연\"</span>, <span class=\"number\">24</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"모모\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"사나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"다현\"</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"미나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"채영\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"쯔위\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"정연\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Twice 멤버 배열을 받아, 컬렉션 투영기능을 이용하여 그중 name에 대한 필드만 뽑아온 것이다.</span></span><br><span class=\"line\">    List&lt;String&gt; filterList = (List&lt;String&gt;) parser.parseExpression(<span class=\"string\">\"![name]\"</span>).getValue(testList);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> filterList; <span class=\"comment\">//[\"지효\",\"나연\",\"모모\",\"사나\",\"다현\",\"미나\",\"채영\",\"쯔위\",\"정연\"]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"표현식-템플릿\">표현식 템플릿</span></h1>\n<ul>\n<li>표현식 템플릿을 사용하면 평가 블록과 Literal text를 혼합할 수 있다.</li>\n<li>평가블록은 prefix와 subfix로 구분</li>\n<li>일반적으로 <code>#{</code> 와 <code>}</code>로 구분한다.</li>\n<li>parseExpression() 메서드의 두번째 파라미터로 사용자 정의 ParseContext 객체를 넣어준다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TemplateParserContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">ParserContext</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getExpressionPrefix</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"#&#123;\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getExpressionSuffix</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"&#125;\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// \"random number is 0.7038186818312008\"로 평가된다</span></span><br><span class=\"line\">String randomPhrase = </span><br><span class=\"line\">   parser.parseExpression(<span class=\"string\">\"random number is #&#123;T(java.lang.Math).random()&#125;\"</span>, <span class=\"keyword\">new</span> TemplateParserContext()).getValue(String.class);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1>리터럴 표현식 (Literal Expression)</h1>\n<p>리터럴 표현식을 제공하는 타입은 문자열(String), 숫자(int, real, hex), boolean, null이다.</p>\n<ul>\n<li>문자열 (Strings)는 따옴표(’)로 구분된다 <code>(쌍따옴표가 아님)</code> - 문자열 표현 시, <code>'Hello World'</code> 처럼 SpEL을 작성</li>\n</ul>\n<p>다음은 리터럴 표현식 (Literal Expression)에 대한 간단한 예제이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//따옴표로 이루어진 'Hello World' =&gt; Hello World라는 문자열로 평가 된다.</span></span><br><span class=\"line\">String helloWorld = (String) parser.parseExpression(<span class=\"string\">\"'Hello World'\"</span>).getValue();</span><br><span class=\"line\"><span class=\"comment\">//Double 타입의 숫자로 평가</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> avogadrosNumber = (Double) parser.parseExpression(<span class=\"string\">\"6.0221415E+23\"</span>).getValue();</span><br><span class=\"line\"><span class=\"comment\">//2147483647로 평가</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> maxValue = (Integer) parser.parseExpression(<span class=\"string\">\"0x7FFFFFFF\"</span>).getValue();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = (Boolean) parser.parseExpression(<span class=\"string\">\"true\"</span>).getValue();</span><br><span class=\"line\"><span class=\"comment\">//null로 평가 된다. -&gt; null String이 아니다. (주의)</span></span><br><span class=\"line\">Object nullValue = parser.parseExpression(<span class=\"string\">\"null\"</span>).getValue();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>숫자는 음수기호(-), 지수표시(E), 소수점(.)을 지원한다.</li>\n<li>기본적으로 실제 숫자는 Double.parseDouble()로 파싱한다.</li>\n</ul>\n<h1>메서드 호출</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//String 리터럴 abc에 대한 substring 메서드 호출 -&gt; bc가 리턴된다.</span></span><br><span class=\"line\">String c = parser.parseExpression(<span class=\"string\">\"'abc'.substring(2, 3)\"</span>).getValue(String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//사용자 정의 메서드 호출 (Return Type : Boolean) -&gt; boolean 타입으로 평가된다.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isMember = parser.parseExpression(<span class=\"string\">\"isMember('Mihajlo Pupin')\"</span>).getValue(</span><br><span class=\"line\">        societyContext, Boolean.class);</span><br></pre></td></tr></table></figure>\n<p>위의 코드는 메서드 호출에 대한 예제 코드이다.</p>\n<ul>\n<li>메서드는 Java 문법을 사용하여 호출 할 수 있다.</li>\n<li>Literal에 대한 메서드 호출도 가능하다.</li>\n<li>Varargs 형식의 파라미터도 지원하고 있다.</li>\n</ul>\n<h1>프로퍼티, 배열, 리스트, 맵에 대한 접근 지원</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 발명품 배열</span></span><br><span class=\"line\">StandardEvaluationContext teslaContext = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Induction motor\"로 평가된다.</span></span><br><span class=\"line\">String invention = parser.parseExpression(<span class=\"string\">\"inventions[3]\"</span>).getValue(teslaContext, String.class); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 회원 리스트</span></span><br><span class=\"line\">StandardEvaluationContext societyContext = <span class=\"keyword\">new</span> StandardEvaluationContext(ieee);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Nikola Tesla\"로 평가된다.</span></span><br><span class=\"line\">String name = parser.parseExpression(<span class=\"string\">\"Members[0].Name\"</span>).getValue(societyContext, String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 리스트와 배열 탐색</span></span><br><span class=\"line\"><span class=\"comment\">// \"Wireless communication\"로 평가된다.</span></span><br><span class=\"line\">String invention = parser.parseExpression(<span class=\"string\">\"Members[0].Inventions[6]\"</span>).getValue(societyContext, String.class);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>프로퍼티의 맨 첫글자는 대소문자를 구별하지 않는다.</li>\n<li>SpEL은 표준 <code>dot 표기법</code>(예: prop1.prop2.prop3)을 사용해서 중첩된 프로퍼티와 프로퍼티의 값 설정도 지원한다.</li>\n<li>public 필드에 대한 접근을 지원한다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Officer의 딕션어리</span></span><br><span class=\"line\">Inventor pupin = parser.parseExpression(<span class=\"string\">\"Officers['president']\"</span>).getValue(societyContext, Inventor.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Idvor\"로 평가된다</span></span><br><span class=\"line\">String city = parser.parseExpression(<span class=\"string\">\"Officers['president'].PlaceOfBirth.City\"</span>).getValue(societyContext, String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 값을 설정한다</span></span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"Officers['advisors'][0].PlaceOfBirth.Country\"</span>).setValue(societyContext, <span class=\"string\">\"Croatia\"</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>대괄호<code>[]</code> 를 사용하여 Map의 key를 바탕으로 데이터에 접근한다.<br>\n(위의 예제에서는 Officers가 <code>Map</code>, president가 <code>key</code>이다.)</li>\n<li>SpEL은 표준 ‘dot’ 표기법(예: prop1.prop2.prop3)을 사용해서 Map내의 value 객체의 프로퍼티에도 접근 가능하다.</li>\n<li>setValue 메서드를 통해 데이터를 수정할 수 있다.</li>\n</ul>\n<h1>인라인 리스트 (Inline list)</h1>\n<p>리스트는 {} 표기법을 사용하여 리스트로 사용 할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 4개의 숫자를 담고 있는 리스트로 평가된다</span></span><br><span class=\"line\">List&lt;Integer&gt; numbers = (List) parser.parseExpression(<span class=\"string\">\"&#123;1,2,3,4&#125;\"</span>).getValue(context); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//List의 List의 형태의 List로 평가된다.</span></span><br><span class=\"line\"><span class=\"comment\">//listOfLists[0] = &#123;'a', 'b'&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//listOfLists[1] = &#123;'x', 'y'&#125;</span></span><br><span class=\"line\">List listOfLists = (List) parser.parseExpression(<span class=\"string\">\"&#123;&#123;'a','b'&#125;,&#123;'x','y'&#125;&#125;\"</span>).getValue(context);</span><br></pre></td></tr></table></figure>\n<h1>배열 생성</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] numbers1 = (<span class=\"keyword\">int</span>[]) parser.parseExpression(<span class=\"string\">\"new int[4]\"</span>).getValue(context); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// initializer가진 배열</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] numbers2 = (<span class=\"keyword\">int</span>[]) parser.parseExpression(<span class=\"string\">\"new int[]&#123;1,2,3&#125;\"</span>).getValue(context); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 다차원 배열</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[][] numbers3 = (<span class=\"keyword\">int</span>[][]) parser.parseExpression(<span class=\"string\">\"new int[4][5]\"</span>).getValue(context);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Java 문법과 같은 표현식을 사용하여 배열을 생성 할 수 있다.</li>\n<li>{} 표현식을 통해 초기값을 세팅할 수 있다.</li>\n<li>2차원 배열이상의 다차원 배열도 선언이 가능하다. (<code>단, 다차원 배열은 초기값을 설정할 수 없다.</code>)</li>\n</ul>\n<h1>연산자</h1>\n<h2>관계 연산자</h2>\n<p>표준 관계 연산자를 사용한다. 사용 할 수 있는 관계 연산자는 아래와 같다.</p>\n<ul>\n<li>같음 (<code>==</code>)</li>\n<li>같지 않음 (<code>!=</code>)</li>\n<li>작음 (<code>&lt;</code>)</li>\n<li>작거나 같음 (<code>&lt;=</code>)</li>\n<li>큼 (<code>&gt;</code>)</li>\n<li>크거나 같음 (<code>&gt;=</code>)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"2 == 2\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"2 &lt; -5.0\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"'black' &lt; 'block'\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure>\n<h2>심볼릭 연산자</h2>\n<p>XML과 같이 문서형식에 관계 연산자가 제한을 받는 경우, 사용 가능한 문자 표현식을 제공한다.<br>\n연산자에 대한 대소문자는 구별하지 않는다.</p>\n<ul>\n<li>같음 (<code>eq</code>)</li>\n<li>같지 않음 (<code>ne</code>)</li>\n<li>작음 (<code>lt</code>)</li>\n<li>작거나 같음 (<code>le</code>)</li>\n<li>큼 (<code>gt</code>)</li>\n<li>크거나 같음 (<code>gt</code>)</li>\n<li>div (<code>/</code>)</li>\n<li>mod (<code>%</code>)</li>\n<li>not (<code>!</code>)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"22 eq 22\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"'test' eq 'test!'\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure>\n<h2>정규 표현식</h2>\n<p>matches를 이용한 정규표현식을 지원한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"'5.00' matches '^-?\\\\d+(\\\\.\\\\d&#123;2&#125;)?$'\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d&#123;2&#125;)?$'\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure>\n<h2>instanceof</h2>\n<p>Java에서 super타입에 대한 연산을 위해 instanceof를 표현식으로 사용할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"'xyz' instanceof T(int)\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"'xyz' instanceof T(String)\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure>\n<h2>논리연산자</h2>\n<p>AND, OR, NOT에 대한 표현식을 지원한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- AND --</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"true and false\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\">String expression =  <span class=\"string\">\"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- OR --</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"true or false\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true로 평가된다</span></span><br><span class=\"line\">String expression =  <span class=\"string\">\"isMember('Nikola Tesla') or isMember('Albert Einstien')\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- NOT --</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false로 평가된다</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(<span class=\"string\">\"!true\"</span>).getValue(Boolean.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- AND and NOT --</span></span><br><span class=\"line\">String expression =  <span class=\"string\">\"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br></pre></td></tr></table></figure>\n<h2>수식 연산자</h2>\n<ul>\n<li>더하기 (+) 연산자를 숫자, 날짜, 문자열에 사용할 수 있다.</li>\n<li>빼기(-) 연산자를 숫자, 날짜에 사용할 수 있다.</li>\n<li>곱하기(*), 나누기(/), 나머지(%)에 대한 연산은 숫자에만 사용 할 수 있다.</li>\n<li>연산자 우선 순위 법칙이 적용된다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 더하기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> two = parser.parseExpression(<span class=\"string\">\"1 + 1\"</span>).getValue(Integer.class); <span class=\"comment\">// 2</span></span><br><span class=\"line\">String testString = parser.parseExpression(<span class=\"string\">\"'test' + ' ' + 'string'\"</span>).getValue(String.class);  <span class=\"comment\">// 'test string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 빼기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> four =  parser.parseExpression(<span class=\"string\">\"1 - -3\"</span>).getValue(Integer.class); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> d = parser.parseExpression(<span class=\"string\">\"1000.00 - 1e4\"</span>).getValue(Double.class); <span class=\"comment\">// -9000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 곱하기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> six =  parser.parseExpression(<span class=\"string\">\"-2 * -3\"</span>).getValue(Integer.class); <span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> twentyFour = parser.parseExpression(<span class=\"string\">\"2.0 * 3e0 * 4\"</span>).getValue(Double.class); <span class=\"comment\">// 24.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 나누기</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minusTwo =  parser.parseExpression(<span class=\"string\">\"6 / -3\"</span>).getValue(Integer.class); <span class=\"comment\">// -2</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> one = parser.parseExpression(<span class=\"string\">\"8.0 / 4e0 / 2\"</span>).getValue(Double.class); <span class=\"comment\">// 1.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 계수(Modulus)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> three =  parser.parseExpression(<span class=\"string\">\"7 % 4\"</span>).getValue(Integer.class); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> one = parser.parseExpression(<span class=\"string\">\"8 / 5 % 2\"</span>).getValue(Integer.class); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 연산자 우선순위</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minusTwentyOne = parser.parseExpression(<span class=\"string\">\"1+2-3*8\"</span>).getValue(Integer.class); <span class=\"comment\">// -21</span></span><br></pre></td></tr></table></figure>\n<h2>3항 연산자 (If-Then-Else)</h2>\n<p>표현식에서 3항연산자를 통해 if-then-else 로직을 수행할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//falseExp로 평가 된다.</span></span><br><span class=\"line\">String falseString = parser.parseExpression(<span class=\"string\">\"false ? 'trueExp' : 'falseExp'\"</span>).getValue(String.class);</span><br></pre></td></tr></table></figure>\n<h2>Elvis 연산자</h2>\n<ul>\n<li>Elvis 연산자는 3항 연산자 구문을 단축시키고 Groovy 언어로 사용된다.</li>\n<li>3항 연산자는 변수를 2번 반복해서 써야하는 단점이 있다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = <span class=\"string\">\"Elvis Presley\"</span>;</span><br><span class=\"line\">String displayName = name != <span class=\"keyword\">null</span> ? name : <span class=\"string\">\"Unknown\"</span>;</span><br></pre></td></tr></table></figure>\n<p>이런 조잡한 표현식 대신에 Elvis 연산자를 사용하면…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">String name = parser.parseExpression(<span class=\"string\">\"name?:'Unknown'\"</span>).getValue(String.class);  </span><br><span class=\"line\">System.out.println(name); <span class=\"comment\">// 'Unknown'</span></span><br></pre></td></tr></table></figure>\n<p>간단하게 변수에 대해 <code>?</code> 를 붙여주는 것만으로도 null 체크를 해준다.<br>\n? 모양이 엘비스 프레슬리의 머리모양을 닮아서 Elvis 연산자라고 명명하였다고 한다.</p>\n<h2>안전한탐색(Navigation) 연산자</h2>\n<ul>\n<li>안전한 탐색 연산자는 NPE를 피하기 위해 사용, Groovy 언어로 제공</li>\n<li>java로 코딩을 하다보면 습관적으로 if(variable == null) 과 같은 체크를 하게 된다.</li>\n<li>하지만 Safe Navigation 연산자를 사용하면 NPE를 발생시키지 않고, 그냥 null을 리턴해 준다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\"></span><br><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\">tesla.setPlaceOfBirth(<span class=\"keyword\">new</span> PlaceOfBirth(<span class=\"string\">\"Smiljan\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행</span></span><br><span class=\"line\">String city = parser.parseExpression(<span class=\"string\">\"PlaceOfBirth?.City\"</span>).getValue(context, String.class);</span><br><span class=\"line\">System.out.println(city); <span class=\"comment\">// Smiljan</span></span><br><span class=\"line\"></span><br><span class=\"line\">tesla.setPlaceOfBirth(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행</span></span><br><span class=\"line\">city = parser.parseExpression(<span class=\"string\">\"PlaceOfBirth?.City\"</span>).getValue(context, String.class);</span><br><span class=\"line\">System.out.println(city); <span class=\"comment\">// null - null pointer exception이 발생하지 않는다.</span></span><br></pre></td></tr></table></figure>\n<h1>할당</h1>\n<ul>\n<li>할당연산자(<code>=</code>)를 이용하여 Context내의 프로퍼티에 value를 할당 할 수 있다.</li>\n<li>보통은 setValue 메서드를 이용하여 value를 할당</li>\n<li>getValue 메서드를 이용하여 할당 할 수도 있다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventor inventor = <span class=\"keyword\">new</span> Inventor();</span><br><span class=\"line\">StandardEvaluationContext inventorContext = <span class=\"keyword\">new</span> StandardEvaluationContext(inventor);</span><br><span class=\"line\"><span class=\"comment\">//inventor.name에 Alexander Seovic2 문자열을 할당</span></span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"Name\"</span>).setValue(inventorContext, <span class=\"string\">\"Alexander Seovic2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//할당연산자(`=`)를 이용하여 inventor.name에 Alexander Seovic2 문자열을 할당</span></span><br><span class=\"line\">String aleks = parser.parseExpression(<span class=\"string\">\"Name = 'Alexandar Seovic'\"</span>).getValue(inventorContext, String.class);</span><br></pre></td></tr></table></figure>\n<h1>클래스 표현식</h1>\n<ul>\n<li><code>T</code> 연산자를 통해 클래스의 인스턴스를 지정하는데 사용할 수 있다.</li>\n<li><code>T</code> 연산자를 통해 클래스의 static method도 사용할 수 있다.</li>\n<li>웬만하면 full package를 적어준다.</li>\n<li>StandardEvaluationContext는 타입을 찾으려고 TypeLocator를 사용</li>\n<li>StandardTypeLocator는 java.lang 패키지로 만들어진다.</li>\n<li>따라서 java.lang.String과 같은 타입은 T(String)으로 간단하게 표현 가능하다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class dateClass = parser.parseExpression(<span class=\"string\">\"T(java.util.Date)\"</span>).getValue(Class.class);</span><br><span class=\"line\"></span><br><span class=\"line\">Class stringClass = parser.parseExpression(<span class=\"string\">\"T(String)\"</span>).getValue(Class.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> trueValue = parser.parseExpression(<span class=\"string\">\"T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR\"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure>\n<h1>생성자 호출</h1>\n<ul>\n<li>생성자는 새로운 연산자를 사용해서 호출할 수 있다.</li>\n<li>primitive type(원시 타입 int, double등…)과 String 외에는 모두 정규화된 클래스명을 사용해야 한다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventor einstein = p.parseExpression(<span class=\"string\">\"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')\"</span>).getValue(Inventor.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//리스트의 add 메서드내에서 새로운 inventor 인스턴스를 생성한다</span></span><br><span class=\"line\">p.parseExpression(<span class=\"string\">\"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))\"</span>).getValue(societyContext);</span><br></pre></td></tr></table></figure>\n<h1>변수</h1>\n<ul>\n<li><code>#</code> 표현식을 통해 표현식 내에 변수를 참조할 수 있다.</li>\n<li>StandardEvaluationContext에서 setVariable 메서드를 사용해서 변수를 설정한다.</li>\n<li>자주 쓰이는 표현식이다. (@Cacheable Annotation에서도 사용)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventor tesla = <span class=\"keyword\">new</span> Inventor(<span class=\"string\">\"Nikola Tesla\"</span>, <span class=\"string\">\"Serbian\"</span>);</span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\">context.setVariable(<span class=\"string\">\"newName\"</span>, <span class=\"string\">\"Mike Tesla\"</span>); <span class=\"comment\">//newName변수에 대한 value할당</span></span><br><span class=\"line\"></span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"Name = #newName\"</span>).getValue(context);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(tesla.getName()) <span class=\"comment\">// \"Mike Tesla\"</span></span><br></pre></td></tr></table></figure>\n<h2>#root</h2>\n<ul>\n<li>변수 #root는 항상 정의되며 루트 컨텍스트 개체의미</li>\n<li>#root는 항상 루트를 나타낸다.</li>\n<li>setRootObject 메서드를 통해 root를 정의한다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext(tesla);</span><br><span class=\"line\"></span><br><span class=\"line\">SomeCustomObject someObject = <span class=\"keyword\">new</span> SomeCustomObject();</span><br><span class=\"line\">context.setRootObject(someObject);</span><br><span class=\"line\"></span><br><span class=\"line\">String name = <span class=\"string\">\"kocko\"</span>;</span><br><span class=\"line\">context.setVariable(<span class=\"string\">\"name\"</span>, kocko);</span><br><span class=\"line\">String statement = <span class=\"string\">\"#root.stringLength(#kocko) == 5\"</span>;</span><br><span class=\"line\">Expression expression = parser.parseExpression(statement);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> result = expression.getValue(context, Boolean.class);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>#root는 SomeCustomObject를 의미</li>\n</ul>\n<h2>#this</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create an array of integers</span></span><br><span class=\"line\">List&lt;Integer&gt; primes = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">primes.addAll(Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">13</span>,<span class=\"number\">17</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 파서를 생성하고 'primes' 변수를 정수 배열로 설정한다</span></span><br><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\">context.setVariable(<span class=\"string\">\"primes\"</span>,primes);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 리스트에서 10보다 큰 모든 소수(?&#123;...&#125; 선택을 사용)</span></span><br><span class=\"line\"><span class=\"comment\">// [11, 13, 17]로 평가된다</span></span><br><span class=\"line\">List&lt;Integer&gt;</span><br><span class=\"line\"> primesGreaterThanTen = (List&lt;Integer&gt;) </span><br><span class=\"line\">parser.parseExpression(<span class=\"string\">\"#primes.?[#this&gt;10]\"</span>).getValue(context);</span><br><span class=\"line\"><span class=\"comment\">//#primes 변수에 대해 평가하며, #this는 2~17까지 값을 의미한다.</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>#this는 항상 정의되어 있고, 현재 평가되는 객체를 가리킨다.</li>\n<li>#this는 계속 변경될 수 있다. (위의 예제에서 보면 2,3,5,7등 평가 시점에 따라 달라질수 있다.)</li>\n</ul>\n<h1>사용자 정의 함수</h1>\n<ul>\n<li>표현식 문자열 내에서 호출 가능한 사용자 정의 함수를 등록하여 SpEL의 기능을 확장할 수 있다.</li>\n<li>StandardEvaluationContext에 사용자정의 함수를 등록하여 사용하면 된다.</li>\n</ul>\n<p>예시로 문자열을 reverse 하는 메서드를 구현하였다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringUtils</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">reverseString</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder backwards = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; input.length(); i++)</span><br><span class=\"line\">            backwards.append(input.charAt(input.length() - <span class=\"number\">1</span> - i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> backwards.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>메서드를 StandardEvaluationContext에 등록</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//StringUtils 클래스에 정의된 reserveString 메서드를 등록한다.</span></span><br><span class=\"line\"><span class=\"comment\">//파라미터 타입은 String 타입 객체 1개이다.</span></span><br><span class=\"line\">context.registerFunction(<span class=\"string\">\"reverseString\"</span>, StringUtils.class.getDeclaredMethod(<span class=\"string\">\"reverseString\"</span>, <span class=\"keyword\">new</span> Class[] &#123; String.class &#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//hello 문자열을 뒤집은 olleh가 리턴된다.</span></span><br><span class=\"line\">String helloWorldReversed = parser.parseExpression(<span class=\"string\">\"#reverseString('hello')\"</span>).getValue(context, String.class);</span><br></pre></td></tr></table></figure>\n<h1>Bean 참조</h1>\n<p>evaluation context에 Bean Resolver가 설정된 경우 <code>@</code> 표현식으로 bean을 사용할 수 있다.<br>\nSpring Docs에 있는 예제는 잘 이해가 안되어 직접 테스트 해보았다.</p>\n<p>Bean 클래스 생성</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"do Test\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ApplicationContext applicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/test\"</span>)</span><br><span class=\"line\">\t<span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">\t\tStandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//실용적인 테스트를 위해 Application Context의 BeanFactory를 설정</span></span><br><span class=\"line\">\t\tDefaultListableBeanFactory factory = (DefaultListableBeanFactory) ((ConfigurableApplicationContext) applicationContext).getBeanFactory();</span><br><span class=\"line\">\t\tcontext.setBeanResolver(<span class=\"keyword\">new</span> BeanFactoryResolver(factory));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//Application Context에 등록된 testBean이라는 bean을 불러와 test메서드를 실행하였다.</span></span><br><span class=\"line\">\t\tString result = parser.parseExpression(<span class=\"string\">\"@testBean.test()\"</span>).getValue(context, String.class);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result; <span class=\"comment\">//do Test가 리턴되었다.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>Collection 선택 기능</h1>\n<ul>\n<li>컬렉션 (Collection) 선택 기능은 Context내의 Collection 필드에 접근하여 조건(Criteria)를 기반으로 서브 컬렉션을 반환 할 수 있다.</li>\n<li><code>?[selectionExpression]</code> 표현식을 이용한다.</li>\n<li>리스트, 맵에서 모두 사용 가능하다</li>\n<li>객체가 context로 들어오는 경우 object.?[필드에 대한 조건]</li>\n<li>컬렉션이 context로 들어오는 경우 .?[필드에 대한 조건] (별도의 필드가 없는 경우 #this를 사용)</li>\n</ul>\n<p>Twice 클래스를 선언</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Twice</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Getter</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Member&gt; members = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;() &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"지효\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"나연\"</span>, <span class=\"number\">24</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"모모\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"사나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"다현\"</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"미나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"채영\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"쯔위\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"정연\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Twice&gt; <span class=\"title\">twice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">    StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Twice의 멤버 필드에 접근</span></span><br><span class=\"line\">    <span class=\"comment\">// 컬렉션의 age 필드에 대해 20 이하인 대상을 반환</span></span><br><span class=\"line\">    List&lt;Twice&gt; filterList = (List&lt;Twice&gt;) parser.parseExpression(<span class=\"string\">\"members.?[age &lt; 20]\"</span>).getValue(<span class=\"keyword\">new</span> Twice());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> filterList; <span class=\"comment\">//[&#123;\"name\":\"채영\",\"age\":19&#125;,&#123;\"name\":\"쯔위\",\"age\":19&#125;]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>Collection 투영 기능</h1>\n<ul>\n<li>투영기능은 컬렉션에 하위표현식을 반영하여 새로운 컬렉션을 리턴한다.</li>\n<li><code>![projectionExpression]</code> 표현식을 사용한다.</li>\n</ul>\n<p>위의 Twice 예제를 바탕으로 설명하겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">twice2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ExpressionParser parser = <span class=\"keyword\">new</span> SpelExpressionParser();</span><br><span class=\"line\">    StandardEvaluationContext context = <span class=\"keyword\">new</span> StandardEvaluationContext();</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Member&gt; testList = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;() &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"지효\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"나연\"</span>, <span class=\"number\">24</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"모모\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"사나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"다현\"</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"미나\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"채영\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"쯔위\"</span>, <span class=\"number\">19</span>));</span><br><span class=\"line\">            add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"정연\"</span>, <span class=\"number\">23</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Twice 멤버 배열을 받아, 컬렉션 투영기능을 이용하여 그중 name에 대한 필드만 뽑아온 것이다.</span></span><br><span class=\"line\">    List&lt;String&gt; filterList = (List&lt;String&gt;) parser.parseExpression(<span class=\"string\">\"![name]\"</span>).getValue(testList);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> filterList; <span class=\"comment\">//[\"지효\",\"나연\",\"모모\",\"사나\",\"다현\",\"미나\",\"채영\",\"쯔위\",\"정연\"]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>표현식 템플릿</h1>\n<ul>\n<li>표현식 템플릿을 사용하면 평가 블록과 Literal text를 혼합할 수 있다.</li>\n<li>평가블록은 prefix와 subfix로 구분</li>\n<li>일반적으로 <code>#{</code> 와 <code>}</code>로 구분한다.</li>\n<li>parseExpression() 메서드의 두번째 파라미터로 사용자 정의 ParseContext 객체를 넣어준다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TemplateParserContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">ParserContext</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getExpressionPrefix</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"#&#123;\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getExpressionSuffix</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"&#125;\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// \"random number is 0.7038186818312008\"로 평가된다</span></span><br><span class=\"line\">String randomPhrase = </span><br><span class=\"line\">   parser.parseExpression(<span class=\"string\">\"random number is #&#123;T(java.lang.Math).random()&#125;\"</span>, <span class=\"keyword\">new</span> TemplateParserContext()).getValue(String.class);</span><br></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide setting.png","slug":"ide setting.png","post":"cjp55h5gb00034f1tthlp6kqb","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide설정.png","slug":"ide설정.png","post":"cjp55h5gb00034f1tthlp6kqb","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ide-setting.png","slug":"ide-setting.png","post":"cjp55h5gb00034f1tthlp6kqb","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/image-20180831235454808.png","slug":"image-20180831235454808.png","post":"cjp55h5i300114f1t7vavujt0","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-28-docker-2/redis-versions.png","slug":"redis-versions.png","post":"cjp55h5ik001f4f1tsacb43f1","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-28-docker-2/docker-hub.png","slug":"docker-hub.png","post":"cjp55h5ik001f4f1tsacb43f1","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-21-spring-context/99A34C3359FEAA8410.png","slug":"99A34C3359FEAA8410.png","post":"cjp55h5gi00074f1tccd6t0va","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-25-docker-1/docker-image.png","slug":"docker-image.png","post":"cjp55h5gj00084f1t03dqnd9c","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-25-docker-1/docker-logo.png","slug":"docker-logo.png","post":"cjp55h5gj00084f1t03dqnd9c","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-25-docker-1/docking-image.png","slug":"docking-image.png","post":"cjp55h5gj00084f1t03dqnd9c","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-25-docker-1/vm-vs-docker.png","slug":"vm-vs-docker.png","post":"cjp55h5gj00084f1t03dqnd9c","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ipv4.png","slug":"ipv4.png","post":"cjp55h5gb00034f1tthlp6kqb","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-httprequest-client-ip/ipv6.png","slug":"ipv6.png","post":"cjp55h5gb00034f1tthlp6kqb","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/image-20180831234615081.png","slug":"image-20180831234615081.png","post":"cjp55h5i300114f1t7vavujt0","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-03-spring-ehcache/test-result.png","slug":"test-result.png","post":"cjp55h5j8001v4f1tjvcawpg5","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-29-java-exception/Exception-Class.png","slug":"Exception-Class.png","post":"cjp55h5i600154f1tye4tk7bg","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-21-spring-ioc-2/containers.jpg","slug":"containers.jpg","post":"cjp55h5i700184f1t8sz99tfn","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor/filter-chain.gif","slug":"filter-chain.gif","post":"cjp55h5i2000z4f1tuku4je3q","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-18-spring-filter-interceptor/spring-request-lifecycle.jpg","slug":"spring-request-lifecycle.jpg","post":"cjp55h5i2000z4f1tuku4je3q","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet/Front-controller-pattern.png","slug":"Front-controller-pattern.png","post":"cjp55h5i400134f1tolzozlhw","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-11-spring-dispatcher-servlet/dispatcher-servlet-lifecycle.jpg","slug":"dispatcher-servlet-lifecycle.jpg","post":"cjp55h5i400134f1tolzozlhw","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/Dispatch-Seq.jpg","slug":"Dispatch-Seq.jpg","post":"cjp55h5i1000x4f1tosf4itxh","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/RequestMappingHandlerAdapter.png","slug":"RequestMappingHandlerAdapter.png","post":"cjp55h5i1000x4f1tosf4itxh","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/argument-resolver-result.png","slug":"argument-resolver-result.png","post":"cjp55h5i1000x4f1tosf4itxh","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-01-servlet/Servlet-life-cycle.png","slug":"Servlet-life-cycle.png","post":"cjp55h5i500144f1t39gbwrl9","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-01-servlet/jspToServlet.jpeg","slug":"jspToServlet.jpeg","post":"cjp55h5i500144f1t39gbwrl9","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-01-servlet/servlet.png","slug":"servlet.png","post":"cjp55h5i500144f1t39gbwrl9","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/Exception-Class.png","slug":"Exception-Class.png","post":"cjp55h5i300114f1t7vavujt0","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-25-spring-mvc-handle-exception/spring-mvc-request.jpg","slug":"spring-mvc-request.jpg","post":"cjp55h5i300114f1t7vavujt0","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921142925583.png","slug":"image-20180921142925583.png","post":"cjp55h5ib001a4f1to44qqx0c","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921142928480.png","slug":"image-20180921142928480.png","post":"cjp55h5ib001a4f1to44qqx0c","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921143924788.png","slug":"image-20180921143924788.png","post":"cjp55h5ib001a4f1to44qqx0c","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921145310488.png","slug":"image-20180921145310488.png","post":"cjp55h5ib001a4f1to44qqx0c","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-12-spring-ioc/image-20180921153027741.png","slug":"image-20180921153027741.png","post":"cjp55h5ib001a4f1to44qqx0c","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-28-docker-2/docker-permission.png","slug":"docker-permission.png","post":"cjp55h5ik001f4f1tsacb43f1","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-28-docker-2/image-layer.png","slug":"image-layer.png","post":"cjp55h5ik001f4f1tsacb43f1","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-28-docker-2/sudo-docker.png","slug":"sudo-docker.png","post":"cjp55h5ik001f4f1tsacb43f1","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-03-spring-ehcache/17110B4350CC5EC51D-20181011233534455.jpeg","slug":"17110B4350CC5EC51D-20181011233534455.jpeg","post":"cjp55h5j8001v4f1tjvcawpg5","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-03-spring-ehcache/17110B4350CC5EC51D.jpeg","slug":"17110B4350CC5EC51D.jpeg","post":"cjp55h5j8001v4f1tjvcawpg5","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-03-spring-ehcache/EHCACHE.png","slug":"EHCACHE.png","post":"cjp55h5j8001v4f1tjvcawpg5","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-03-spring-ehcache/ehcache-test.png","slug":"ehcache-test.png","post":"cjp55h5j8001v4f1tjvcawpg5","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjp55h5gb00034f1tthlp6kqb","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5gn000a4f1tprzx0wp9"},{"post_id":"cjp55h5gg00064f1ta0x2popv","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5gs000f4f1ts3atxvwg"},{"post_id":"cjp55h5gg00064f1ta0x2popv","tag_id":"cjp55h5gr000d4f1ti4x65ktt","_id":"cjp55h5gt000g4f1tgk0cn8hr"},{"post_id":"cjp55h5gi00074f1tccd6t0va","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5gu000i4f1tqrjsth3b"},{"post_id":"cjp55h5gi00074f1tccd6t0va","tag_id":"cjp55h5gs000e4f1tx3y9uusu","_id":"cjp55h5gu000j4f1tvg7dvx5c"},{"post_id":"cjp55h5gj00084f1t03dqnd9c","tag_id":"cjp55h5gt000h4f1tic90jht5","_id":"cjp55h5gu000l4f1tuj28h9tx"},{"post_id":"cjp55h5go000b4f1t5o6yhtiy","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5gw000o4f1te7a40d1l"},{"post_id":"cjp55h5go000b4f1t5o6yhtiy","tag_id":"cjp55h5gu000k4f1tswh3a4xu","_id":"cjp55h5gx000p4f1t1i2apref"},{"post_id":"cjp55h5go000b4f1t5o6yhtiy","tag_id":"cjp55h5gv000m4f1tmmn7zy42","_id":"cjp55h5gx000q4f1tbwcbe94i"},{"post_id":"cjp55h5gq000c4f1tdvel1fve","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5gy000r4f1t17lykh7z"},{"post_id":"cjp55h5gq000c4f1tdvel1fve","tag_id":"cjp55h5gv000m4f1tmmn7zy42","_id":"cjp55h5gy000s4f1t5fvpo0fb"},{"post_id":"cjp55h5i1000x4f1tosf4itxh","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5i300104f1tthyh121p"},{"post_id":"cjp55h5i2000z4f1tuku4je3q","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5i700174f1tzhulte9z"},{"post_id":"cjp55h5i2000z4f1tuku4je3q","tag_id":"cjp55h5i400124f1thrf1a49t","_id":"cjp55h5ib00194f1tcdz1ae69"},{"post_id":"cjp55h5i700184f1t8sz99tfn","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5if001c4f1tqdt7s7jx"},{"post_id":"cjp55h5i300114f1t7vavujt0","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5ik001e4f1tq2nkcmz4"},{"post_id":"cjp55h5i300114f1t7vavujt0","tag_id":"cjp55h5i400124f1thrf1a49t","_id":"cjp55h5ip001h4f1tc2e86ok1"},{"post_id":"cjp55h5ib001a4f1to44qqx0c","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5it001j4f1t5gsmazwk"},{"post_id":"cjp55h5i400134f1tolzozlhw","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5iu001l4f1tzim098gq"},{"post_id":"cjp55h5i400134f1tolzozlhw","tag_id":"cjp55h5ic001b4f1tjk9awsf2","_id":"cjp55h5iv001m4f1tv2o31v4c"},{"post_id":"cjp55h5ik001f4f1tsacb43f1","tag_id":"cjp55h5gt000h4f1tic90jht5","_id":"cjp55h5iv001o4f1t74w1qdl9"},{"post_id":"cjp55h5iq001i4f1tygqs9cn7","tag_id":"cjp55h5gt000h4f1tic90jht5","_id":"cjp55h5iv001p4f1t8p90i04b"},{"post_id":"cjp55h5i500144f1t39gbwrl9","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5iv001q4f1tv74p476u"},{"post_id":"cjp55h5i500144f1t39gbwrl9","tag_id":"cjp55h5il001g4f1td6xxm0v7","_id":"cjp55h5iv001r4f1t3qg3j1lz"},{"post_id":"cjp55h5i600154f1tye4tk7bg","tag_id":"cjp55h5iu001k4f1t2r6lzj78","_id":"cjp55h5iv001s4f1tn3gr0785"},{"post_id":"cjp55h5ig001d4f1tewnzb39h","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5iv001t4f1tine9c07u"},{"post_id":"cjp55h5ig001d4f1tewnzb39h","tag_id":"cjp55h5iv001n4f1thz0drkpc","_id":"cjp55h5iw001u4f1tqalyzxwy"},{"post_id":"cjp55h5j8001v4f1tjvcawpg5","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5ja001x4f1t3wq5trg7"},{"post_id":"cjp55h5j9001w4f1td717kvpq","tag_id":"cjp55h5gd00054f1tu5db0rjw","_id":"cjp55h5ja001y4f1turqcaba9"},{"post_id":"cjp55h5j9001w4f1td717kvpq","tag_id":"cjp55h5iv001n4f1thz0drkpc","_id":"cjp55h5ja001z4f1t39oyw5nh"}],"Tag":[{"name":"Spring","_id":"cjp55h5gd00054f1tu5db0rjw"},{"name":"Java-Config","_id":"cjp55h5gr000d4f1ti4x65ktt"},{"name":"WAS","_id":"cjp55h5gs000e4f1tx3y9uusu"},{"name":"Docker","_id":"cjp55h5gt000h4f1tic90jht5"},{"name":"Spring Boot","_id":"cjp55h5gu000k4f1tswh3a4xu"},{"name":"EHCache","_id":"cjp55h5gv000m4f1tmmn7zy42"},{"name":"Spring Core","_id":"cjp55h5i400124f1thrf1a49t"},{"name":"core","_id":"cjp55h5ic001b4f1tjk9awsf2"},{"name":"J2EE","_id":"cjp55h5il001g4f1td6xxm0v7"},{"name":"Java","_id":"cjp55h5iu001k4f1t2r6lzj78"},{"name":"SpEL","_id":"cjp55h5iv001n4f1thz0drkpc"}]}}