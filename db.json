{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":0,"renderable":0},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1533735880029},{"_id":"source/.DS_Store","hash":"a3e78aac200cfc88a372c26dd2a50f769bad1952","modified":1533831516647},{"_id":"source/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1533735880029},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1533735880082},{"_id":"themes/beantech/_config.yml","hash":"6afd65c055d9b1c70ae67323cc869f1b4aa60348","modified":1533735880082},{"_id":"source/about/index.md","hash":"ebca34cfe8d13ec641d17fcfec0127a966338f8e","modified":1533735880039},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1533836461523},{"_id":"source/_posts/2018-07-15-spring-aop.md","hash":"b2416e01e18a07908eb9983f2792c1a47ca173e2","modified":1533735880030},{"_id":"source/_posts/2018-07-20-spring-aop2.md","hash":"47fed6344f090ef86329a1114640afd668d328ee","modified":1533735880030},{"_id":"source/_posts/2018-07-21-spring-aop3.md","hash":"f9ee48b62b7e238213e643ca4b1f98c3c9c557fa","modified":1533735880030},{"_id":"source/_posts/2018-07-22-spring-aop4.md","hash":"a04545bdb9b27330fc63adf73bcca59129396fb8","modified":1533735880030},{"_id":"source/_posts/2018-07-24-spring-aop5.md","hash":"244f3300ca2f2610da52abedc1b29dc82b0fcfd5","modified":1533735880031},{"_id":"source/_posts/2018-08-10-spring-argument-resolver.md","hash":"7978f20938f8995b928ee6d57a784635bd886e6d","modified":1533837520288},{"_id":"source/archive/index.md","hash":"279ff19668395f5c6b26417da99d2c1f3ecd5886","modified":1533735880040},{"_id":"source/image/.DS_Store","hash":"7adc86aa88c77beca52b3b56f09db71ae4106ee3","modified":1533833482514},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1533834946520},{"_id":"source/tags/index.md","hash":"9d558ce28d0d44c3463517088689bbca44bbb364","modified":1533735880081},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1533735880083},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1533735880083},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1533735880083},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1533735880084},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1533735880084},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1533735880084},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1533735880084},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1533735880084},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1533735880085},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1533735880085},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1533735880089},{"_id":"themes/beantech/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1533735880090},{"_id":"themes/beantech/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1533735880090},{"_id":"themes/beantech/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1533735880090},{"_id":"themes/beantech/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1533735880090},{"_id":"themes/beantech/layout/page.ejs","hash":"c90797e4394c5cb63c2515109480e766d04e486e","modified":1533735880091},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1533735880092},{"_id":"themes/beantech/layout/post.ejs","hash":"2d55684fc539dc281f9e2ec0409f09ea6ca43949","modified":1533735880091},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/Dispatch순서-3836317.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1533743829232},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/argument-resolver실행결과.png","hash":"cd37d456fa0edc6c814db3e9a2cdfe77ebf11fa9","modified":1533828018071},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/Dispatch순서.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1533743829232},{"_id":"source/image/2018-08-08/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1533831555686},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1533834946481},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1533735880092},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1533735880092},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1533735880093},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1533735880095},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1533735880096},{"_id":"themes/beantech/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1533735880097},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1533735880097},{"_id":"themes/beantech/source/css/toc.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1533735880097},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1533735880098},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1533735880098},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1533735880101},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1533735880101},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1533735880101},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1533735880103},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1533735880103},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1533735880103},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1533735880107},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1533735880107},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1533735880107},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1533735880108},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"c31863b1fa66fd915bc4913440be6c610d12af80","modified":1533735880086},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"3542d15bdf73aa59f05f566b7ecd2255e83ee370","modified":1533735880086},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"aafb744601042f0270d2e6595129ac8a73ad2608","modified":1533735880086},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1533735880086},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1533735880087},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1533735880087},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1533735880087},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1533735880087},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1533735880088},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1533735880088},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1533735880088},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"3b10bd768f6ef30a42b1703fbc9a88627f9bfdf1","modified":1533735880089},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1533735880089},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1533834946489},{"_id":"source/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1533834946522},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1533735880095},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1533735880100},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1533735880102},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1533735880106},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1533735880038},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1533834946488},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1533834946526},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1533735880094},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1533735880096},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1533735880096},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1533735880039},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1533834946520},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1533834946524},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1533735880105},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/RequestMappingHandlerAdapter.png","hash":"71751889b49d402fe29355c7ea9bb172ead4b95c","modified":1533742581464},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1533834946486},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1533834946518},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1533735880036},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1533834946514},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1533834946507},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1533834946500},{"_id":"public/post-sitemap.xml","hash":"fa6c6a067a0de9029f78a1f10963b78e849765fe","modified":1533837585608},{"_id":"public/page-sitemap.xml","hash":"f78fbed1bd2a93e1af71055ad959b35d82678857","modified":1533836562297},{"_id":"public/tag-sitemap.xml","hash":"8a53c85bd4e566aa8fea100e745f9255470867b6","modified":1533837585708},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1533836562335},{"_id":"public/sitemap.xml","hash":"96ccd32acf8317d8a31fa3cf7590611c18487567","modified":1533837585743},{"_id":"public/404.html","hash":"080d41b8632bd183794fe0e1e28d2b29aeb8ee8e","modified":1533836562354},{"_id":"public/tags/index.html","hash":"591aa8a4e5ca2280b62aad615775f2dda2babdca","modified":1533836562354},{"_id":"public/about/index.html","hash":"b595fa451f8fcdb49a64a7f925d5ed25b1d8136e","modified":1533836562354},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/index.html","hash":"030d05686aac8c6b0f3375943c26ff77d51e4ab3","modified":1533837585748},{"_id":"public/2018/07/24/2018-07-24-spring-aop5/index.html","hash":"97ed380768582eea528f822e278a2b21da3babb7","modified":1533836562354},{"_id":"public/2018/07/22/2018-07-22-spring-aop4/index.html","hash":"e519076d6d141e1813a1321c0016dd409a0b1040","modified":1533836562354},{"_id":"public/2018/07/21/2018-07-21-spring-aop3/index.html","hash":"ba671f4d7c5998fbd75fb063c95ebf276d8c5030","modified":1533836562354},{"_id":"public/2018/07/20/2018-07-20-spring-aop2/index.html","hash":"cc8b1ff8d03605ac9c74f926ad403d8d74aa5c62","modified":1533836562354},{"_id":"public/2018/07/15/2018-07-15-spring-aop/index.html","hash":"26309260ad1c0e14cf746e287e654f2b9a4de237","modified":1533836562354},{"_id":"public/archive/index.html","hash":"61f83f0439a29929c90ba38f4ef8c76b35c8bb98","modified":1533836562354},{"_id":"public/archives/index.html","hash":"c982b9db7c5dfdfd85b1f131cb63670b1506699b","modified":1533836562354},{"_id":"public/archives/2018/index.html","hash":"d61638e573b2b8273bde0531329bf3782b542d9b","modified":1533836562354},{"_id":"public/archives/2018/07/index.html","hash":"7040a76c957d25004fa6b4aa0914979306186efa","modified":1533836562354},{"_id":"public/archives/2018/08/index.html","hash":"8a4d21dab6bacbae46269782c211d0f3cb2497e3","modified":1533836562354},{"_id":"public/index.html","hash":"19d22065622f2bed3fd4a93a57c5e6681b6e1ebe","modified":1533836562354},{"_id":"public/tags/Spring/index.html","hash":"dc272b7ce2b22f694c3aa2dc54d772f02f55fd9e","modified":1533836562354},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1533836562365},{"_id":"public/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1533836562365},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1533836562365},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1533836562365},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1533836562365},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1533836562365},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1533836562365},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1533836562365},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/Dispatch순서-3836317.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1533836562365},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/Dispatch순서.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1533836562365},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/argument-resolver실행결과.png","hash":"cd37d456fa0edc6c814db3e9a2cdfe77ebf11fa9","modified":1533836562365},{"_id":"public/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1533836562590},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1533836562592},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1533836562600},{"_id":"public/css/highlight.css","hash":"03d1f0a648e9bdf7b1f57d217313cbac5d0c7eb1","modified":1533836562600},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1533836562601},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1533836562601},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1533836562601},{"_id":"public/css/toc.css","hash":"2062bf4e5b219654e0d4bf470f5eef1be213da95","modified":1533836562601},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1533836562601},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1533836562601},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1533836562601},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1533836562601},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1533836562601},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1533836562601},{"_id":"public/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1533836562601},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1533836562601},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1533836562601},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1533836562601},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1533836562601},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1533836562601},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1533836562601},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1533836562601},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1533836562601},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1533836562601},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1533836562601},{"_id":"public/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1533836562607},{"_id":"public/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1533836562607},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1533836562607},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1533836562610},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/RequestMappingHandlerAdapter.png","hash":"71751889b49d402fe29355c7ea9bb172ead4b95c","modified":1533836562620},{"_id":"public/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1533836562642},{"_id":"public/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1533836562644},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1533836562650},{"_id":"public/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1533836562652},{"_id":"public/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1533836562655},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/Dispatch순서-3836317.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1533836666636},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/Dispatch순서.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1533836666637},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/argument-resolver실행결과.png","hash":"cd37d456fa0edc6c814db3e9a2cdfe77ebf11fa9","modified":1533836666640},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/Dispatch순서-3836317.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1533836945094},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/Dispatch순서.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1533836945094},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/argument-resolver실행결과.png","hash":"cd37d456fa0edc6c814db3e9a2cdfe77ebf11fa9","modified":1533836945096},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/Dispatch-Seq.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1533836666637},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/argument-resolver-result.png","hash":"cd37d456fa0edc6c814db3e9a2cdfe77ebf11fa9","modified":1533836666640},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1533837188612},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/Dispatch-Seq.jpg","hash":"5c32f24004e859c85ace0853f97b053113511584","modified":1533837406277},{"_id":"public/2018/08/10/2018-08-10-spring-argument-resolver/argument-resolver-result.png","hash":"cd37d456fa0edc6c814db3e9a2cdfe77ebf11fa9","modified":1533837406277}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2018-08-08T13:44:40.029Z","updated":"2018-08-08T13:44:40.029Z","path":"404.html","title":"","comments":1,"_id":"cjkmuopfx0000edyahh33wy3b","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T19:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","updated":"2018-08-08T13:44:40.039Z","path":"about/index.html","_id":"cjkmuopgr0001edya2qls27w0","content":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n"},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T11:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2018-08-08T13:44:40.040Z","path":"archive/index.html","_id":"cjkmuopgw0003edyacnzvyta7","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2018-08-08T13:44:40.081Z","updated":"2018-08-08T13:44:40.081Z","path":"tags/index.html","comments":1,"_id":"cjkmuoph30005edya4enji762","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"Spring AOP (1)","subtitle":"1. AOP를 사용해야 하는 이유","date":"2018-07-15T13:28:13.000Z","background":"/img/posts/06.jpg","_content":"\n\n\n개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다. \nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.\n\n\n\n# 들어가면서..\n\n\n\n정리하고자 하는 내용\n\n1. AOP를 사용해야하는 이유\n2. AOP에서 사용되는 용어 정리\n3. \u0010Spring AOP\n4. AspectJ\n5. Custom Annotation\n\n\n\n내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.\n\n\n\n# 1. AOP를 사용 해야 하는 이유\n\n## AOP란?\n\n AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.\n\n예를 들어 결제를 담당하는 소스가 있다고 할 때\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n~~~\n\n\n\n위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.\n\n여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.\n\n이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.\n\n그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이 \n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.\n\n\n\nAOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    return response;\n}\n~~~\n\n\n\n~~~java\n@Aspect\n@Component\npublic class PaymentLogAdvisor {\n    \n    @Autowired\n    private PaymentLogRepository paymentLogRepository;\n    \n    @AfterReturning(\"execution(* com.example.payment.doPayment*(..))\", returning=\"paymentResponse\")\n    public void afterPayment(JoinPoint jp, PaymentResponse paymentResponse) {\n        Object[] args = jp.getArgs();\n        if(args.length == 0) {\n            throw new illegalArgumentException(\"argument is none\");\n        }\n        \n        if(!(args[0] instanceof PaymentRequest)) {\n            throw new Exception(\"argument is not PaymentRequest Type\");\n        }\n        \n        PaymentRequest paymentRequest = (PaymentRequest) args[0];\n        \n        //결제 로그 삽입\n        paymentLogRepository.insert(paymentRequest, paymentResponse);\n    }\n}\n~~~\n\n","source":"_posts/2018-07-15-spring-aop.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (1)\"\nsubtitle: \"1. AOP를 사용해야 하는 이유\"\ndate:   2018-07-15 22:28:13 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n\n\n개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다. \nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.\n\n\n\n# 들어가면서..\n\n\n\n정리하고자 하는 내용\n\n1. AOP를 사용해야하는 이유\n2. AOP에서 사용되는 용어 정리\n3. \u0010Spring AOP\n4. AspectJ\n5. Custom Annotation\n\n\n\n내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.\n\n\n\n# 1. AOP를 사용 해야 하는 이유\n\n## AOP란?\n\n AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.\n\n예를 들어 결제를 담당하는 소스가 있다고 할 때\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    \n    //결제 요청에 대한 로그 데이터 DB Insert\n    paymentLogRepository.insert(paymentRequest, response);\n    \n    return response;\n}\n~~~\n\n\n\n위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.\n\n여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.\n\n이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.\n\n그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이 \n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.\n\n\n\nAOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.\n\n~~~java\npublic PaymentResponse doPaymentByCash(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 현금 결제처리\n    PaymentResponse response = paymentModule.paymentCash(paymentRequest);\n    return response;\n}\n\npublic PaymentResponse doPaymentByCreditCard(PaymentRequest paymentRequest) {\n    \n    //결제 요청에 대한 카드 결제 처리\n    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);\n    return response;\n}\n~~~\n\n\n\n~~~java\n@Aspect\n@Component\npublic class PaymentLogAdvisor {\n    \n    @Autowired\n    private PaymentLogRepository paymentLogRepository;\n    \n    @AfterReturning(\"execution(* com.example.payment.doPayment*(..))\", returning=\"paymentResponse\")\n    public void afterPayment(JoinPoint jp, PaymentResponse paymentResponse) {\n        Object[] args = jp.getArgs();\n        if(args.length == 0) {\n            throw new illegalArgumentException(\"argument is none\");\n        }\n        \n        if(!(args[0] instanceof PaymentRequest)) {\n            throw new Exception(\"argument is not PaymentRequest Type\");\n        }\n        \n        PaymentRequest paymentRequest = (PaymentRequest) args[0];\n        \n        //결제 로그 삽입\n        paymentLogRepository.insert(paymentRequest, paymentResponse);\n    }\n}\n~~~\n\n","slug":"2018-07-15-spring-aop","published":1,"updated":"2018-08-08T13:44:40.030Z","comments":1,"photos":[],"link":"","_id":"cjkmuopgs0002edyaxl8gwbpb","content":"<p>개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다.<br>\nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.</p>\n<h1><span id=\"들어가면서\">들어가면서…</span></h1>\n<p>정리하고자 하는 내용</p>\n<ol>\n<li>AOP를 사용해야하는 이유</li>\n<li>AOP에서 사용되는 용어 정리</li>\n<li>\u0010Spring AOP</li>\n<li>AspectJ</li>\n<li>Custom Annotation</li>\n</ol>\n<p>내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.</p>\n<h1><span id=\"1-aop를-사용-해야-하는-이유\">1. AOP를 사용 해야 하는 이유</span></h1>\n<h2><span id=\"aop란\">AOP란?</span></h2>\n<p>AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.<br>\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.<br>\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.</p>\n<p>예를 들어 결제를 담당하는 소스가 있다고 할 때</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.<br>\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.<br>\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.</p>\n<p>여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.<br>\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.</p>\n<p>이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.</p>\n<p>그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이<br>\n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.</p>\n<p>AOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PaymentLogAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PaymentLogRepository paymentLogRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning</span>(<span class=\"string\">\"execution(* com.example.payment.doPayment*(..))\"</span>, returning=<span class=\"string\">\"paymentResponse\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPayment</span><span class=\"params\">(JoinPoint jp, PaymentResponse paymentResponse)</span> </span>&#123;</span><br><span class=\"line\">        Object[] args = jp.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> illegalArgumentException(<span class=\"string\">\"argument is none\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(args[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> PaymentRequest)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"argument is not PaymentRequest Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        PaymentRequest paymentRequest = (PaymentRequest) args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//결제 로그 삽입</span></span><br><span class=\"line\">        paymentLogRepository.insert(paymentRequest, paymentResponse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다.<br>\nCustom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.</p>\n<h1>들어가면서…</h1>\n<p>정리하고자 하는 내용</p>\n<ol>\n<li>AOP를 사용해야하는 이유</li>\n<li>AOP에서 사용되는 용어 정리</li>\n<li>\u0010Spring AOP</li>\n<li>AspectJ</li>\n<li>Custom Annotation</li>\n</ol>\n<p>내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.</p>\n<h1>1. AOP를 사용 해야 하는 이유</h1>\n<h2>AOP란?</h2>\n<p>AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.<br>\n객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.<br>\n하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.</p>\n<p>예를 들어 결제를 담당하는 소스가 있다고 할 때</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class=\"line\">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 doPayment\u0010ByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.<br>\n결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.<br>\n굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.</p>\n<p>여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.<br>\n뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.</p>\n<p>이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.</p>\n<p>그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이<br>\n컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.</p>\n<p>AOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCash</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 현금 결제처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCash(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PaymentResponse <span class=\"title\">doPaymentByCreditCard</span><span class=\"params\">(PaymentRequest paymentRequest)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//결제 요청에 대한 카드 결제 처리</span></span><br><span class=\"line\">    PaymentResponse response = paymentModule.paymentCreditCard(paymentRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PaymentLogAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PaymentLogRepository paymentLogRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning</span>(<span class=\"string\">\"execution(* com.example.payment.doPayment*(..))\"</span>, returning=<span class=\"string\">\"paymentResponse\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPayment</span><span class=\"params\">(JoinPoint jp, PaymentResponse paymentResponse)</span> </span>&#123;</span><br><span class=\"line\">        Object[] args = jp.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> illegalArgumentException(<span class=\"string\">\"argument is none\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(args[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> PaymentRequest)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"argument is not PaymentRequest Type\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        PaymentRequest paymentRequest = (PaymentRequest) args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//결제 로그 삽입</span></span><br><span class=\"line\">        paymentLogRepository.insert(paymentRequest, paymentResponse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"Spring AOP (2)","subtitle":"2. AOP에서 사용되는 용어 정리","date":"2018-07-20T14:06:13.000Z","background":"/img/posts/06.jpg","_content":"\n앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.\n\n여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.\n\n\n\n# AOP(Aspect Oriented Programming) 란?\n\n## AOP의 등장배경\n\n AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.  \n\n 수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.\n\n 하지만 객체지향 프로그래밍 방식에도 헛점은 있었다. \n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. `횡단 관심사 (CrossCutting Concerns)`이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.\n\n\n\n## AOP의 개념\n\n 실제 핵심 로직(Core Concern)을 수행하면서 발생하는 `횡단 관심사 (CrossCutting Concerns)` 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.\n\n![횡단관심사와 핵심로직](https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png)\n\nAOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.\n\nAOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다. \nAspect를 정의 하자면, \n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다. \n\n이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.\n\n\n\n# AOP 에서 사용되는 용어들\n\n## Join Point\n\n말그대로 Join + Point이다. `횡단관심사(Cross Cutting Concern)` 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.\n\n## Advice\n\n`횡단관심사(Cross Cutting Concern)` 으로 분리 된 로직에 대한 코드\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어\n\n## Point Cut\n\n말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어\n\n## Weaving\n\nAdvice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.\n방법에 따라 \n* 런타임 시, Proxy로 생성하며 코드를 합치는 방법\n* 컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법\n이 있다.\n\n## Aspect\n\n여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.\n보안, 트랜잭션, 로깅등이 대표적인 예이다.\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.\n\n## Target\n\n핵심 로직을 구현하는 클래스 또는 객체\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.\n\n## Advisor\n\nAdvice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.\n\n\n\n------\n\n참고\n\nhttps://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttp://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106","source":"_posts/2018-07-20-spring-aop2.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (2)\"\nsubtitle: \"2. AOP에서 사용되는 용어 정리\"\ndate:   2018-07-20 23:06:13 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.\n\n여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.\n\n\n\n# AOP(Aspect Oriented Programming) 란?\n\n## AOP의 등장배경\n\n AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.  \n\n 수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.\n\n 하지만 객체지향 프로그래밍 방식에도 헛점은 있었다. \n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. `횡단 관심사 (CrossCutting Concerns)`이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.\n\n\n\n## AOP의 개념\n\n 실제 핵심 로직(Core Concern)을 수행하면서 발생하는 `횡단 관심사 (CrossCutting Concerns)` 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.\n\n![횡단관심사와 핵심로직](https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png)\n\nAOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.\n\nAOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다. \nAspect를 정의 하자면, \n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다. \n\n이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.\n\n\n\n# AOP 에서 사용되는 용어들\n\n## Join Point\n\n말그대로 Join + Point이다. `횡단관심사(Cross Cutting Concern)` 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.\n\n## Advice\n\n`횡단관심사(Cross Cutting Concern)` 으로 분리 된 로직에 대한 코드\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어\n\n## Point Cut\n\n말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어\n\n## Weaving\n\nAdvice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.\n방법에 따라 \n* 런타임 시, Proxy로 생성하며 코드를 합치는 방법\n* 컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법\n이 있다.\n\n## Aspect\n\n여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.\n보안, 트랜잭션, 로깅등이 대표적인 예이다.\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.\n\n## Target\n\n핵심 로직을 구현하는 클래스 또는 객체\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.\n\n## Advisor\n\nAdvice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.\n\n\n\n------\n\n참고\n\nhttps://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttp://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106","slug":"2018-07-20-spring-aop2","published":1,"updated":"2018-08-08T13:44:40.030Z","comments":1,"photos":[],"link":"","_id":"cjkmuopgy0004edyai4w2n38d","content":"<p>앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.</p>\n<p>여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.</p>\n<h1><span id=\"aopaspect-oriented-programming-란\">AOP(Aspect Oriented Programming) 란?</span></h1>\n<h2><span id=\"aop의-등장배경\">AOP의 등장배경</span></h2>\n<p>AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.</p>\n<p>수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.</p>\n<p>하지만 객체지향 프로그래밍 방식에도 헛점은 있었다.<br>\n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. <code>횡단 관심사 (CrossCutting Concerns)</code>이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.</p>\n<h2><span id=\"aop의-개념\">AOP의 개념</span></h2>\n<p>실제 핵심 로직(Core Concern)을 수행하면서 발생하는 <code>횡단 관심사 (CrossCutting Concerns)</code> 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.</p>\n<p><img src=\"https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png\" alt=\"횡단관심사와 핵심로직\"></p>\n<p>AOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.</p>\n<p>AOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다.<br>\nAspect를 정의 하자면,<br>\n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다.</p>\n<p>이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.<br>\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.</p>\n<h1><span id=\"aop-에서-사용되는-용어들\">AOP 에서 사용되는 용어들</span></h1>\n<h2><span id=\"join-point\">Join Point</span></h2>\n<p>말그대로 Join + Point이다. <code>횡단관심사(Cross Cutting Concern)</code> 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.</p>\n<h2><span id=\"advice\">Advice</span></h2>\n<p><code>횡단관심사(Cross Cutting Concern)</code> 으로 분리 된 로직에 대한 코드<br>\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어</p>\n<h2><span id=\"point-cut\">Point Cut</span></h2>\n<p>말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,<br>\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어</p>\n<h2><span id=\"weaving\">Weaving</span></h2>\n<p>Advice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.<br>\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.<br>\n방법에 따라</p>\n<ul>\n<li>런타임 시, Proxy로 생성하며 코드를 합치는 방법</li>\n<li>컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법<br>\n이 있다.</li>\n</ul>\n<h2><span id=\"aspect\">Aspect</span></h2>\n<p>여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.<br>\n보안, 트랜잭션, 로깅등이 대표적인 예이다.<br>\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.</p>\n<h2><span id=\"target\">Target</span></h2>\n<p>핵심 로직을 구현하는 클래스 또는 객체<br>\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.</p>\n<h2><span id=\"advisor\">Advisor</span></h2>\n<p>Advice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.<br>\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.</p>\n<hr>\n<p>참고</p>\n<p><a href=\"https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop의-등장-배경</a></p>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p>\n<p><a href=\"http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106\" target=\"_blank\" rel=\"noopener\">http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.</p>\n<p>여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.</p>\n<h1>AOP(Aspect Oriented Programming) 란?</h1>\n<h2>AOP의 등장배경</h2>\n<p>AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.</p>\n<p>수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.</p>\n<p>하지만 객체지향 프로그래밍 방식에도 헛점은 있었다.<br>\n실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. <code>횡단 관심사 (CrossCutting Concerns)</code>이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.</p>\n<h2>AOP의 개념</h2>\n<p>실제 핵심 로직(Core Concern)을 수행하면서 발생하는 <code>횡단 관심사 (CrossCutting Concerns)</code> 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.</p>\n<p><img src=\"https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png\" alt=\"횡단관심사와 핵심로직\"></p>\n<p>AOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.</p>\n<p>AOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다.<br>\nAspect를 정의 하자면,<br>\n실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다.</p>\n<p>이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.<br>\nAOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.</p>\n<h1>AOP 에서 사용되는 용어들</h1>\n<h2>Join Point</h2>\n<p>말그대로 Join + Point이다. <code>횡단관심사(Cross Cutting Concern)</code> 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.</p>\n<h2>Advice</h2>\n<p><code>횡단관심사(Cross Cutting Concern)</code> 으로 분리 된 로직에 대한 코드<br>\nAspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어</p>\n<h2>Point Cut</h2>\n<p>말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,<br>\nPoint cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어</p>\n<h2>Weaving</h2>\n<p>Advice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.<br>\n즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.<br>\n방법에 따라</p>\n<ul>\n<li>런타임 시, Proxy로 생성하며 코드를 합치는 방법</li>\n<li>컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법<br>\n이 있다.</li>\n</ul>\n<h2>Aspect</h2>\n<p>여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.<br>\n보안, 트랜잭션, 로깅등이 대표적인 예이다.<br>\nAspect는 AOP의 핵심 단위 이며 Advice + Point cut = Aspect 이다.</p>\n<h2>Target</h2>\n<p>핵심 로직을 구현하는 클래스 또는 객체<br>\nAOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.</p>\n<h2>Advisor</h2>\n<p>Advice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.<br>\n공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.</p>\n<hr>\n<p>참고</p>\n<p><a href=\"https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\" target=\"_blank\" rel=\"noopener\">https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop의-등장-배경</a></p>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p>\n<p><a href=\"http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106\" target=\"_blank\" rel=\"noopener\">http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106</a></p>\n"},{"layout":"post","title":"Spring AOP (3)","subtitle":"3. Spring AOP","date":"2018-07-21T03:52:33.000Z","background":"/img/posts/06.jpg","_content":"\n앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.\n\n이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.\n\n\n\n# Spring AOP\n\nAOP란 `횡단 관심사 (Cross Cutting Concern)` 을 한데 모아 로직을 설계한다음\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다. \n\n이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.\n\n\n\n# Proxy란?\n\n![Proxy구성도](https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336)\n\n\n\n> Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.\n>\n> 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.\n>\n> 토비의 스프링 vol.1 (p. 430)\n\n\n\n토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다. \n\nSpring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.\n\n\n\n> OCP (Open-Close Principal : 개방 폐쇄의 원칙)\n>\n> **개방-폐쇄 원칙**(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.  \n\n실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.\n\n\n\n# Proxy vs Proxy Pattern\n\n일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.\n비슷한 개념이지만, 내용이 조금 다르다.\n\n일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.\n\nProxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.\n\n\n\n# JDK Dynamic Proxy\n\n![JDK Dynamic Proxy](https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif)\n\n\n\nJDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다. \n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다. \n\n내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.\n\n~~~java\npublic class ExamDynamicHandler implements InvocationHandler {\n    private ExamInterface target; // 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용\n     \n    public ExamDynamicHandler(ExamInterface target) {\n        this.target = target;\n    }\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args)\n            throws Throwable {\n        // TODO Auto-generated method stub\n        // 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용\n        String ret = (String)method.invoke(target, args); //타입 Safe하지 않는 단점이 있다.\n        return ret.toUpperCase(); //메소드 기능에 대한 확장\n    }\n}\n~~~\n\n\n\n# CGLIB Proxy\n\nCGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다. \n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.\n\n하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다. \n\nCGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.\n\n![CGLIB Proxy](http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png)\n\n\n\n* CGLIB Proxy 설정법\n\n* ~~~yaml\n  spring.aop.proxy-target-class=false\n  ~~~\n\n  ~~~xml\n  <aop:config proxy-target-class=\"true\">\n  </aop:config>\n  <aop:aspectj-autoproxy proxy-target-class=\"true\"/> <!-- AspectJ를 사용하는 경우 -->\n  ~~~\n\n  ~~~java\n  //AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다\n  @EnableAsync(proxyTargetClass = true)\n  @EnableCaching(proxyTargetClass = true) \n  ~~~\n\n\n\n# Spring Bean에 대한 Proxy는?\n\nSpring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데.. 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?\n\n![00.png](https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png)\n\n\n\nSpring에서는 `자동 프록시 생성기` 라는 것이 있다.\n\n빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  `DefaultAdvisorAutoProxyCreator` 라는 클래스를 사용한다. \n이 클래스는 어드바이저를 이용한 `자동 프록시 생성기` 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.\n\nDefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.\n\n1. 후처리기는 `빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해` 전달받은 빈이 프록시 적용 대상인지 확인한다.\n2. 프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 `프록시를 생성하고 어드바이저를 연결한다.`\n3. 프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.\n4. 컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.\n\n이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.\n\n \n\n# 요약..\n\n* Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.\n* Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n  * JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)\n  * CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)\n    따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)\n* Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.\n  (그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)\n\n\n\n# 참고\n\n토비의 스프링 vol.1\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttps://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99","source":"_posts/2018-07-21-spring-aop3.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (3)\"\nsubtitle: \"3. Spring AOP\"\ndate:   2018-07-21 12:52:33 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.\n\n이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.\n\n\n\n# Spring AOP\n\nAOP란 `횡단 관심사 (Cross Cutting Concern)` 을 한데 모아 로직을 설계한다음\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다. \n\n이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.\n\n\n\n# Proxy란?\n\n![Proxy구성도](https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336)\n\n\n\n> Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.\n>\n> 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.\n>\n> 토비의 스프링 vol.1 (p. 430)\n\n\n\n토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다. \n\nSpring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.\n\n\n\n> OCP (Open-Close Principal : 개방 폐쇄의 원칙)\n>\n> **개방-폐쇄 원칙**(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.  \n\n실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.\n\n\n\n# Proxy vs Proxy Pattern\n\n일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.\n비슷한 개념이지만, 내용이 조금 다르다.\n\n일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.\n\nProxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.\n\n\n\n# JDK Dynamic Proxy\n\n![JDK Dynamic Proxy](https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif)\n\n\n\nJDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다. \n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다. \n\n내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.\n\n~~~java\npublic class ExamDynamicHandler implements InvocationHandler {\n    private ExamInterface target; // 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용\n     \n    public ExamDynamicHandler(ExamInterface target) {\n        this.target = target;\n    }\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args)\n            throws Throwable {\n        // TODO Auto-generated method stub\n        // 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용\n        String ret = (String)method.invoke(target, args); //타입 Safe하지 않는 단점이 있다.\n        return ret.toUpperCase(); //메소드 기능에 대한 확장\n    }\n}\n~~~\n\n\n\n# CGLIB Proxy\n\nCGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다. \n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.\n\n하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다. \n\nCGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.\n\n![CGLIB Proxy](http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png)\n\n\n\n* CGLIB Proxy 설정법\n\n* ~~~yaml\n  spring.aop.proxy-target-class=false\n  ~~~\n\n  ~~~xml\n  <aop:config proxy-target-class=\"true\">\n  </aop:config>\n  <aop:aspectj-autoproxy proxy-target-class=\"true\"/> <!-- AspectJ를 사용하는 경우 -->\n  ~~~\n\n  ~~~java\n  //AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다\n  @EnableAsync(proxyTargetClass = true)\n  @EnableCaching(proxyTargetClass = true) \n  ~~~\n\n\n\n# Spring Bean에 대한 Proxy는?\n\nSpring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데.. 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?\n\n![00.png](https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png)\n\n\n\nSpring에서는 `자동 프록시 생성기` 라는 것이 있다.\n\n빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  `DefaultAdvisorAutoProxyCreator` 라는 클래스를 사용한다. \n이 클래스는 어드바이저를 이용한 `자동 프록시 생성기` 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.\n\nDefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.\n\n1. 후처리기는 `빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해` 전달받은 빈이 프록시 적용 대상인지 확인한다.\n2. 프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 `프록시를 생성하고 어드바이저를 연결한다.`\n3. 프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.\n4. 컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.\n\n이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.\n\n \n\n# 요약..\n\n* Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.\n* Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n  * JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)\n  * CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)\n    따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)\n* Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.\n  (그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)\n\n\n\n# 참고\n\n토비의 스프링 vol.1\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220556587811\n\nhttps://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99","slug":"2018-07-21-spring-aop3","published":1,"updated":"2018-08-08T13:44:40.030Z","comments":1,"photos":[],"link":"","_id":"cjkmuoph40006edya55enfoue","content":"<p>앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.</p>\n<p>이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.</p>\n<h1><span id=\"spring-aop\">Spring AOP</span></h1>\n<p>AOP란 <code>횡단 관심사 (Cross Cutting Concern)</code> 을 한데 모아 로직을 설계한다음<br>\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다.</p>\n<p>이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.<br>\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.<br>\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.</p>\n<h1><span id=\"proxy란\">Proxy란?</span></h1>\n<p><img src=\"https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336\" alt=\"Proxy구성도\"></p>\n<blockquote>\n<p>Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.</p>\n<p>그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.</p>\n<p>토비의 스프링 vol.1 (p. 430)</p>\n</blockquote>\n<p>토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다.</p>\n<p>Spring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.</p>\n<blockquote>\n<p>OCP (Open-Close Principal : 개방 폐쇄의 원칙)</p>\n<p><strong>개방-폐쇄 원칙</strong>(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.</p>\n</blockquote>\n<p>실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.</p>\n<h1><span id=\"proxy-vs-proxy-pattern\">Proxy vs Proxy Pattern</span></h1>\n<p>일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.<br>\n비슷한 개념이지만, 내용이 조금 다르다.</p>\n<p>일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.</p>\n<p>Proxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.</p>\n<h1><span id=\"jdk-dynamic-proxy\">JDK Dynamic Proxy</span></h1>\n<p><img src=\"https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif\" alt=\"JDK Dynamic Proxy\"></p>\n<p>JDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.<br>\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다.<br>\n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.<br>\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다.</p>\n<p>내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExamDynamicHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExamInterface target; <span class=\"comment\">// 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExamDynamicHandler</span><span class=\"params\">(ExamInterface target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        <span class=\"comment\">// 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용</span></span><br><span class=\"line\">        String ret = (String)method.invoke(target, args); <span class=\"comment\">//타입 Safe하지 않는 단점이 있다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret.toUpperCase(); <span class=\"comment\">//메소드 기능에 대한 확장</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"cglib-proxy\">CGLIB Proxy</span></h1>\n<p>CGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다.<br>\n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.</p>\n<p>하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다.</p>\n<p>CGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.</p>\n<p><img src=\"http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png\" alt=\"CGLIB Proxy\"></p>\n<ul>\n<li>\n<p>CGLIB Proxy 설정법</p>\n</li>\n<li>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.aop.proxy-target-class=false</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>/&gt;</span> <span class=\"comment\">&lt;!-- AspectJ를 사용하는 경우 --&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAsync</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1><span id=\"spring-bean에-대한-proxy는\">Spring Bean에 대한 Proxy는?</span></h1>\n<p>Spring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.<br>\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데… 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?</p>\n<p><img src=\"https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png\" alt=\"00.png\"></p>\n<p>Spring에서는 <code>자동 프록시 생성기</code> 라는 것이 있다.</p>\n<p>빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  <code>DefaultAdvisorAutoProxyCreator</code> 라는 클래스를 사용한다.<br>\n이 클래스는 어드바이저를 이용한 <code>자동 프록시 생성기</code> 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.</p>\n<p>DefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.</p>\n<ol>\n<li>후처리기는 <code>빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해</code> 전달받은 빈이 프록시 적용 대상인지 확인한다.</li>\n<li>프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 <code>프록시를 생성하고 어드바이저를 연결한다.</code></li>\n<li>프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.</li>\n<li>컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.</li>\n</ol>\n<p>이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.</p>\n<h1><span id=\"요약\">요약…</span></h1>\n<ul>\n<li>Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.</li>\n<li>Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n<ul>\n<li>JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)</li>\n<li>CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)<br>\n따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)</li>\n</ul>\n</li>\n<li>Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.<br>\n(그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)</li>\n</ul>\n<h1><span id=\"참고\">참고</span></h1>\n<p>토비의 스프링 vol.1</p>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99\" target=\"_blank\" rel=\"noopener\">https://ko.wikipedia.org/wiki/개방-폐쇄_원칙</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.</p>\n<p>이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.</p>\n<h1>Spring AOP</h1>\n<p>AOP란 <code>횡단 관심사 (Cross Cutting Concern)</code> 을 한데 모아 로직을 설계한다음<br>\n런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다.</p>\n<p>이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.<br>\n한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.<br>\n또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.</p>\n<h1>Proxy란?</h1>\n<p><img src=\"https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336\" alt=\"Proxy구성도\"></p>\n<blockquote>\n<p>Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.</p>\n<p>그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.</p>\n<p>토비의 스프링 vol.1 (p. 430)</p>\n</blockquote>\n<p>토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다.</p>\n<p>Spring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.</p>\n<blockquote>\n<p>OCP (Open-Close Principal : 개방 폐쇄의 원칙)</p>\n<p><strong>개방-폐쇄 원칙</strong>(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙이다.</p>\n</blockquote>\n<p>실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.</p>\n<h1>Proxy vs Proxy Pattern</h1>\n<p>일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.<br>\n비슷한 개념이지만, 내용이 조금 다르다.</p>\n<p>일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.</p>\n<p>Proxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.</p>\n<h1>JDK Dynamic Proxy</h1>\n<p><img src=\"https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif\" alt=\"JDK Dynamic Proxy\"></p>\n<p>JDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.<br>\nJDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다.<br>\n따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.<br>\n이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다.</p>\n<p>내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExamDynamicHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExamInterface target; <span class=\"comment\">// 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExamDynamicHandler</span><span class=\"params\">(ExamInterface target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        <span class=\"comment\">// 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용</span></span><br><span class=\"line\">        String ret = (String)method.invoke(target, args); <span class=\"comment\">//타입 Safe하지 않는 단점이 있다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret.toUpperCase(); <span class=\"comment\">//메소드 기능에 대한 확장</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>CGLIB Proxy</h1>\n<p>CGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다.<br>\n실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.</p>\n<p>하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다.</p>\n<p>CGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.</p>\n<p><img src=\"http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png\" alt=\"CGLIB Proxy\"></p>\n<ul>\n<li>\n<p>CGLIB Proxy 설정법</p>\n</li>\n<li>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.aop.proxy-target-class=false</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>/&gt;</span> <span class=\"comment\">&lt;!-- AspectJ를 사용하는 경우 --&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAsync</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span>(proxyTargetClass = <span class=\"keyword\">true</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1>Spring Bean에 대한 Proxy는?</h1>\n<p>Spring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.<br>\n하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데… 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?</p>\n<p><img src=\"https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png\" alt=\"00.png\"></p>\n<p>Spring에서는 <code>자동 프록시 생성기</code> 라는 것이 있다.</p>\n<p>빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  <code>DefaultAdvisorAutoProxyCreator</code> 라는 클래스를 사용한다.<br>\n이 클래스는 어드바이저를 이용한 <code>자동 프록시 생성기</code> 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.</p>\n<p>DefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.</p>\n<ol>\n<li>후처리기는 <code>빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해</code> 전달받은 빈이 프록시 적용 대상인지 확인한다.</li>\n<li>프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 <code>프록시를 생성하고 어드바이저를 연결한다.</code></li>\n<li>프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.</li>\n<li>컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.</li>\n</ol>\n<p>이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.</p>\n<h1>요약…</h1>\n<ul>\n<li>Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.</li>\n<li>Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.\n<ul>\n<li>JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)</li>\n<li>CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)<br>\n따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)</li>\n</ul>\n</li>\n<li>Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.<br>\n(그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)</li>\n</ul>\n<h1>참고</h1>\n<p>토비의 스프링 vol.1</p>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99\" target=\"_blank\" rel=\"noopener\">https://ko.wikipedia.org/wiki/개방-폐쇄_원칙</a></p>\n"},{"layout":"post","title":"Spring AOP (4)","subtitle":"4. AspectJ","date":"2018-07-22T03:52:33.000Z","background":"/img/posts/06.jpg","_content":"\n# AspectJ란?\n\n> AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.\n\nAspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, `CTW, LTW`과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.\n\n\n\n> Aspect란?\n>\n> Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.\n> 그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.\n> 구조적으로 보자면 Aspect = PointCut + Advisor이다.\n\n \n\n# 위빙 Weaving\n\n위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.\n\n\n\n##런타임 시, 위빙 (RTW: Runtime Weaving)\n\nSpring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.\n\n![Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw)\n\n\n\n\n\n\n\n## 컴파일 시, 위빙 (CTW: Compile time Weaving)\n\nAspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)\n\n\n\n### CTW를 사용하기 위한 메이븐 설정\n\n**라이브러리 추가:** (pom.xml)\n\n```xml\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjrt</artifactId>\n    <version>1.8.6</version>\n    <scope>runtime</scope>\n</dependency>\n \n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjtools</artifactId>\n    <version>1.8.6</version>\n</dependency> \n```\n\n**플러그인 설정:** (pom.xml)\n\n```xml\n<plugin>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>aspectj-maven-plugin</artifactId>\n    <version>1.7</version>\n    <configuration>\n        <showWeaveInfo>true</showWeaveInfo>\n            <source>${aspectj-compiler.version}</source>\n            <target>${aspectj-compiler.version}</target>\n            <verbose>true</verbose>\n            <complianceLevel>${aspectj-compiler.version}</complianceLevel>\n            <outxml>true</outxml>\n    </configuration>\n    <executions>\n        <execution>\n            <goals>\n                <goal>compile</goal>\n                <goal>test-compile</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n*(\\*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)*\n\n위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용 \n\nAspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용\n\n\n\n## 클래스 로드 시, 위빙 (LTW: Load time Weaving)\n\n ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.\n\n그리고 설정이 가장 복잡하지 않은가 싶다..\n\n아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.\n\n~~~xml\n<context:load-time-weaver/> <!-- 스프링 설정 파일에 추가 servlet.xml -->\n~~~\n\n~~~java\n@EnableLoadTimeWeaving //Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.\n~~~\n\n~~~vm\n//IDE에서 개발 시, 해당 설정을 추가\n-javaagent:/fullpath/aspectjweaver-1.8.1.jar \n-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar \n~~~\n\n~~~\n//톰캣 시작 시, jvmargs 옵션에 추가\n-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar\n~~~\n\n\n\n# Annotations\n\n## JoinPoint 관련 Annotations\n\n공통적으로 pointcut에 대한 표현식을 인자로 받는다.\n\n* @Before\n  * 메소드 실행 이전 부분에 대한 Joinpoint 설정\n* @Around\n  * ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.\n  * 메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.\n* @After\n  * 메소드 실행 이후 부분의 대한 Joinpoint 설정\n* @AfterReturning\n  * 메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정\n* @AfterThrowable\n  * 메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정\n\n\n\n## Pointcut 관련 Annotation\n\n* @Pointcut\n  * Pointcut에 대한 표현식을 값으로 가짐\n  * @Pointcut이 적용된 메소드는 무조건 리턴타입이 void\n\n\n\n\n\n# Point Cut\n\n포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.\n\n![pointcut 개념](https://t1.daumcdn.net/cfile/tistory/223B623D548C415631)\n\n\n\n## 포인트 컷 표현식\n\nExpression을 이용한 pointcut 표현식\n\n![pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg)\n\n\n\n1. 접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)\n   * \\* 인 경우 모든 접근제어자에 대해 설정 가능\n   * 생략 시, \\* 과 같은 효과\n\n2. 리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)\n   * 필수 적으로 기재해야 한다.\n   * \\* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.\n3. Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)\n   * 단, 패키지 명도 기재해야 함 \n   * com.springframework.aop.. 처럼 ..으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리\n   * 필수 적으로 기재해야 한다.\n4. 메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * 모든 메소드에 적용 하려면 \\* 을 사용\n5. 파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * ,로 구분하여 순서대로 파라미터를 기재한다.\n   * 타입과 갯수에 상관없다면 .. 또는 \\* 를 기재한다.\n6. 예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)\n\n\n\n## 예시\n\n- **execution(int minus(int, int))**: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(int, int))**: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(..))**: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드\n\n- **execution(\\* *(..))**: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드\n\n- **execution(\\* *())**: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드\n\n- **execution(\\* springbook.aop.Target.*(..))**: springbook.aop.Target 클래스의 모든 메소드\n\n- **execution(\\* springbook.aop.*.*(..))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.\n\n- **execution(\\* springbook.aop..*.*(..))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함\n\n- **execution(\\* *..Target.*(..))**: 패키지에는 상관없이 Target 클래스의 모든 메소드\n\n- **execution(* *(..) throws Exception) **: Exception을 throw하는 모든 메소드\n\n- **within(com.springbook.aop.service.***) : service 패키지 내의 모든 Joinpoint\n\n- **within(com.springbook.aop.service..***) : service 패키지의 하위패키지 내의 모든 Joinpoint\n\n- **this(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint\n\n- **target(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint\n\n- **args(java.utils.List)** : 파라미터가 1개이고 List타입인 모든 Joinpoint\n\n- **@target(org.springframework.transaction.annotation.Transactional)** :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@within(org.springframework.transaction.annotation.Transactional)** : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@annotation(org.springframework.transaction.annotation.Transactional)** : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점\n\n* **@args(com.xyz.security.Classified)** : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점\n\n* **bean(UserRepository)** : “UserRepository” 빈\n\n* **!bean(UserRepository)** :  “UserRepository” 빈을 제외한 모든 빈\n\n* **bean(*)** : 모든 빈\n\n* **bean(user*)** : 이름이 'user'로 시작되는 모든 빈\n\n* **bean(*Repository)** : 이름이 “Repository”로 끝나는 모든 빈\n\n* **bean(user/*)** : 이름이 “user/“로 시작하는 모든 빈\n\n* **bean(*dataSource) || bean(*DataSource)** : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈\n\n \n\n# 예시코드\n\n## Aspect 파일 사용\n\n~~~java\npublic aspect TestAdvisor {\n    pointcut advicePoint() : execution(* com.example.advice..*(..));\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n    \n    //order는 어떻게 주는건지 모르겠다.\n}\n~~~\n\n\n\n## @Aspect 어노테이션 사용\n\n~~~java\n@Aspect\npublic class TestAdvisor {\n    \n    /**\n    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut\n    */\n    @Pointcut(\"execution(* com.example.advice..*(..))\")\n    public void pointcut(){\n        \n    }\n    \n    @order(2) //order가 높은 순으로 먼저 실행\n    @After(pointcut=\"pointcut()\")\n    public void afterAdvice(Joinpoint joinpoint) {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    @order(1)\n    @After(pointcut=\"pointcut()\")\n    public void showLog(Joinpoint joinpoint) {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n}\n~~~\n\n\n\n\n\n# 참고\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220564638014\n\nhttp://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\n\nhttps://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5","source":"_posts/2018-07-22-spring-aop4.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (4)\"\nsubtitle: \"4. AspectJ\"\ndate:   2018-07-22 12:52:33 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n# AspectJ란?\n\n> AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.\n\nAspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, `CTW, LTW`과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.\n\n\n\n> Aspect란?\n>\n> Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.\n> 그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.\n> 구조적으로 보자면 Aspect = PointCut + Advisor이다.\n\n \n\n# 위빙 Weaving\n\n위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.\n\n\n\n##런타임 시, 위빙 (RTW: Runtime Weaving)\n\nSpring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.\n\n![Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw)\n\n\n\n\n\n\n\n## 컴파일 시, 위빙 (CTW: Compile time Weaving)\n\nAspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)\n\n\n\n### CTW를 사용하기 위한 메이븐 설정\n\n**라이브러리 추가:** (pom.xml)\n\n```xml\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjrt</artifactId>\n    <version>1.8.6</version>\n    <scope>runtime</scope>\n</dependency>\n \n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjtools</artifactId>\n    <version>1.8.6</version>\n</dependency> \n```\n\n**플러그인 설정:** (pom.xml)\n\n```xml\n<plugin>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>aspectj-maven-plugin</artifactId>\n    <version>1.7</version>\n    <configuration>\n        <showWeaveInfo>true</showWeaveInfo>\n            <source>${aspectj-compiler.version}</source>\n            <target>${aspectj-compiler.version}</target>\n            <verbose>true</verbose>\n            <complianceLevel>${aspectj-compiler.version}</complianceLevel>\n            <outxml>true</outxml>\n    </configuration>\n    <executions>\n        <execution>\n            <goals>\n                <goal>compile</goal>\n                <goal>test-compile</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n*(\\*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)*\n\n위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용 \n\nAspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용\n\n\n\n## 클래스 로드 시, 위빙 (LTW: Load time Weaving)\n\n ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.\n\n그리고 설정이 가장 복잡하지 않은가 싶다..\n\n아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.\n\n~~~xml\n<context:load-time-weaver/> <!-- 스프링 설정 파일에 추가 servlet.xml -->\n~~~\n\n~~~java\n@EnableLoadTimeWeaving //Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.\n~~~\n\n~~~vm\n//IDE에서 개발 시, 해당 설정을 추가\n-javaagent:/fullpath/aspectjweaver-1.8.1.jar \n-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar \n~~~\n\n~~~\n//톰캣 시작 시, jvmargs 옵션에 추가\n-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar\n~~~\n\n\n\n# Annotations\n\n## JoinPoint 관련 Annotations\n\n공통적으로 pointcut에 대한 표현식을 인자로 받는다.\n\n* @Before\n  * 메소드 실행 이전 부분에 대한 Joinpoint 설정\n* @Around\n  * ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.\n  * 메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.\n* @After\n  * 메소드 실행 이후 부분의 대한 Joinpoint 설정\n* @AfterReturning\n  * 메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정\n* @AfterThrowable\n  * 메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정\n\n\n\n## Pointcut 관련 Annotation\n\n* @Pointcut\n  * Pointcut에 대한 표현식을 값으로 가짐\n  * @Pointcut이 적용된 메소드는 무조건 리턴타입이 void\n\n\n\n\n\n# Point Cut\n\n포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.\n\n![pointcut 개념](https://t1.daumcdn.net/cfile/tistory/223B623D548C415631)\n\n\n\n## 포인트 컷 표현식\n\nExpression을 이용한 pointcut 표현식\n\n![pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg)\n\n\n\n1. 접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)\n   * \\* 인 경우 모든 접근제어자에 대해 설정 가능\n   * 생략 시, \\* 과 같은 효과\n\n2. 리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)\n   * 필수 적으로 기재해야 한다.\n   * \\* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.\n3. Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)\n   * 단, 패키지 명도 기재해야 함 \n   * com.springframework.aop.. 처럼 ..으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리\n   * 필수 적으로 기재해야 한다.\n4. 메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * 모든 메소드에 적용 하려면 \\* 을 사용\n5. 파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정\n   * 필수 적으로 기재해야 한다.\n   * ,로 구분하여 순서대로 파라미터를 기재한다.\n   * 타입과 갯수에 상관없다면 .. 또는 \\* 를 기재한다.\n6. 예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)\n\n\n\n## 예시\n\n- **execution(int minus(int, int))**: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(int, int))**: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드\n\n- **execution(\\* minus(..))**: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드\n\n- **execution(\\* *(..))**: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드\n\n- **execution(\\* *())**: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드\n\n- **execution(\\* springbook.aop.Target.*(..))**: springbook.aop.Target 클래스의 모든 메소드\n\n- **execution(\\* springbook.aop.*.*(..))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.\n\n- **execution(\\* springbook.aop..*.*(..))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함\n\n- **execution(\\* *..Target.*(..))**: 패키지에는 상관없이 Target 클래스의 모든 메소드\n\n- **execution(* *(..) throws Exception) **: Exception을 throw하는 모든 메소드\n\n- **within(com.springbook.aop.service.***) : service 패키지 내의 모든 Joinpoint\n\n- **within(com.springbook.aop.service..***) : service 패키지의 하위패키지 내의 모든 Joinpoint\n\n- **this(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint\n\n- **target(com.springbook.aop.service.UserService)** : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint\n\n- **args(java.utils.List)** : 파라미터가 1개이고 List타입인 모든 Joinpoint\n\n- **@target(org.springframework.transaction.annotation.Transactional)** :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@within(org.springframework.transaction.annotation.Transactional)** : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점\n\n- **@annotation(org.springframework.transaction.annotation.Transactional)** : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점\n\n* **@args(com.xyz.security.Classified)** : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점\n\n* **bean(UserRepository)** : “UserRepository” 빈\n\n* **!bean(UserRepository)** :  “UserRepository” 빈을 제외한 모든 빈\n\n* **bean(*)** : 모든 빈\n\n* **bean(user*)** : 이름이 'user'로 시작되는 모든 빈\n\n* **bean(*Repository)** : 이름이 “Repository”로 끝나는 모든 빈\n\n* **bean(user/*)** : 이름이 “user/“로 시작하는 모든 빈\n\n* **bean(*dataSource) || bean(*DataSource)** : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈\n\n \n\n# 예시코드\n\n## Aspect 파일 사용\n\n~~~java\npublic aspect TestAdvisor {\n    pointcut advicePoint() : execution(* com.example.advice..*(..));\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    after(Joinpoint joinpoint) : advicePoint() {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n    \n    //order는 어떻게 주는건지 모르겠다.\n}\n~~~\n\n\n\n## @Aspect 어노테이션 사용\n\n~~~java\n@Aspect\npublic class TestAdvisor {\n    \n    /**\n    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut\n    */\n    @Pointcut(\"execution(* com.example.advice..*(..))\")\n    public void pointcut(){\n        \n    }\n    \n    @order(2) //order가 높은 순으로 먼저 실행\n    @After(pointcut=\"pointcut()\")\n    public void afterAdvice(Joinpoint joinpoint) {\n        System.out.println(\"처음으로 실행되는 로그\");\n    }\n    \n    @order(1)\n    @After(pointcut=\"pointcut()\")\n    public void showLog(Joinpoint joinpoint) {\n        System.out.println(\"두번째로 실행되는 로그\");\n    }\n}\n~~~\n\n\n\n\n\n# 참고\n\nhttp://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220564638014\n\nhttp://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\n\nhttps://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5","slug":"2018-07-22-spring-aop4","published":1,"updated":"2018-08-08T13:44:40.030Z","comments":1,"photos":[],"link":"","_id":"cjkmuoph50007edyad1txkbko","content":"<h1><span id=\"aspectj란\">AspectJ란?</span></h1>\n<blockquote>\n<p>AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.</p>\n</blockquote>\n<p>AspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, <code>CTW, LTW</code>과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.<br>\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.<br>\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.</p>\n<blockquote>\n<p>Aspect란?</p>\n<p>Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.<br>\n그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.<br>\n구조적으로 보자면 Aspect = PointCut + Advisor이다.</p>\n</blockquote>\n<h1><span id=\"위빙-weaving\">위빙 Weaving</span></h1>\n<p>위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.<br>\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.</p>\n<p>##런타임 시, 위빙 (RTW: Runtime Weaving)</p>\n<p>Spring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.<br>\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.<br>\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.</p>\n<p><img src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw\" alt=\"Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<h2><span id=\"컴파일-시-위빙-ctw-compile-time-weaving\">컴파일 시, 위빙 (CTW: Compile time Weaving)</span></h2>\n<p>AspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.<br>\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.<br>\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)</p>\n<h3><span id=\"ctw를-사용하기-위한-메이븐-설정\">CTW를 사용하기 위한 메이븐 설정</span></h3>\n<p><strong>라이브러리 추가:</strong> (pom.xml)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>플러그인 설정:</strong> (pom.xml)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectj-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">showWeaveInfo</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">showWeaveInfo</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">verbose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">verbose</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">complianceLevel</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">complianceLevel</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outxml</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">outxml</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>test-compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><em>(*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)</em></p>\n<p>위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용</p>\n<p>AspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용</p>\n<h2><span id=\"클래스-로드-시-위빙-ltw-load-time-weaving\">클래스 로드 시, 위빙 (LTW: Load time Weaving)</span></h2>\n<p>ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식<br>\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.<br>\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.</p>\n<p>그리고 설정이 가장 복잡하지 않은가 싶다…</p>\n<p>아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:load-time-weaver</span>/&gt;</span> <span class=\"comment\">&lt;!-- 스프링 설정 파일에 추가 servlet.xml --&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableLoadTimeWeaving</span> <span class=\"comment\">//Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//IDE에서 개발 시, 해당 설정을 추가</span><br><span class=\"line\">-javaagent:/fullpath/aspectjweaver-1.8.1.jar </span><br><span class=\"line\">-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//톰캣 시작 시, jvmargs 옵션에 추가</span><br><span class=\"line\">-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure>\n<h1><span id=\"annotations\">Annotations</span></h1>\n<h2><span id=\"joinpoint-관련-annotations\">JoinPoint 관련 Annotations</span></h2>\n<p>공통적으로 pointcut에 대한 표현식을 인자로 받는다.</p>\n<ul>\n<li>@Before\n<ul>\n<li>메소드 실행 이전 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@Around\n<ul>\n<li>ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.</li>\n<li>메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.</li>\n</ul>\n</li>\n<li>@After\n<ul>\n<li>메소드 실행 이후 부분의 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterReturning\n<ul>\n<li>메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterThrowable\n<ul>\n<li>메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n</ul>\n<h2><span id=\"pointcut-관련-annotation\">Pointcut 관련 Annotation</span></h2>\n<ul>\n<li>@Pointcut\n<ul>\n<li>Pointcut에 대한 표현식을 값으로 가짐</li>\n<li>@Pointcut이 적용된 메소드는 무조건 리턴타입이 void</li>\n</ul>\n</li>\n</ul>\n<h1><span id=\"point-cut\">Point Cut</span></h1>\n<p>포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.<br>\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/223B623D548C415631\" alt=\"pointcut 개념\"></p>\n<h2><span id=\"포인트-컷-표현식\">포인트 컷 표현식</span></h2>\n<p>Expression을 이용한 pointcut 표현식</p>\n<p><img src=\"http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg\" alt=\"pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<ol>\n<li>\n<p>접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)</p>\n<ul>\n<li>* 인 경우 모든 접근제어자에 대해 설정 가능</li>\n<li>생략 시, * 과 같은 효과</li>\n</ul>\n</li>\n<li>\n<p>리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)</p>\n<ul>\n<li>단, 패키지 명도 기재해야 함</li>\n<li>com.springframework.aop… 처럼 …으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리</li>\n<li>필수 적으로 기재해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>모든 메소드에 적용 하려면 * 을 사용</li>\n</ul>\n</li>\n<li>\n<p>파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>,로 구분하여 순서대로 파라미터를 기재한다.</li>\n<li>타입과 갯수에 상관없다면 … 또는 * 를 기재한다.</li>\n</ul>\n</li>\n<li>\n<p>예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)</p>\n</li>\n</ol>\n<h2><span id=\"예시\">예시</span></h2>\n<ul>\n<li>\n<p><strong>execution(int minus(int, int))</strong>: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(int, int))</strong>: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(…))</strong>: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>(…))</em></em>: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>())</em></em>: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.Target.</em>(…))</em>*: springbook.aop.Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.</em>.</em>(…))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop…</em>.</em>(…))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함</p>\n</li>\n<li>\n<p><strong>execution(* <em>…Target.</em>(…))</strong>: 패키지에는 상관없이 Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(</em> *(…) throws Exception) **: Exception을 throw하는 모든 메소드</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service.</strong>*) : service 패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service…</strong>*) : service 패키지의 하위패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>this(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>target(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>args(java.utils.List)</strong> : 파라미터가 1개이고 List타입인 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>@target(org.springframework.transaction.annotation.Transactional)</strong> :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@within(org.springframework.transaction.annotation.Transactional)</strong> : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@annotation(org.springframework.transaction.annotation.Transactional)</strong> : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n</ul>\n<ul>\n<li>\n<p><strong>@args(com.xyz.security.Classified)</strong> : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>bean(UserRepository)</strong> : “UserRepository” 빈</p>\n</li>\n<li>\n<p><strong>!bean(UserRepository)</strong> :  “UserRepository” 빈을 제외한 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(</em>)</em>* : 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user</em>)</em>* : 이름이 'user’로 시작되는 모든 빈</p>\n</li>\n<li>\n<p>*<em>bean(<em>Repository)</em></em> : 이름이 “Repository”로 끝나는 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user/</em>)</em>* : 이름이 “user/“로 시작하는 모든 빈</p>\n</li>\n<li>\n<p>**bean(<em>dataSource) || bean(<em>DataSource)</em></em> : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈</p>\n</li>\n</ul>\n<h1><span id=\"예시코드\">예시코드</span></h1>\n<h2><span id=\"aspect-파일-사용\">Aspect 파일 사용</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> aspect TestAdvisor &#123;</span><br><span class=\"line\">    <span class=\"function\">pointcut <span class=\"title\">advicePoint</span><span class=\"params\">()</span> : <span class=\"title\">execution</span><span class=\"params\">(* com.example.advice..*(..)</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//order는 어떻게 주는건지 모르겠다.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"aspect-어노테이션-사용\">@Aspect 어노테이션 사용</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.example.advice..*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pointcut</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">2</span>) <span class=\"comment\">//order가 높은 순으로 먼저 실행</span></span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterAdvice</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showLog</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"참고\">참고</span></h1>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014</a></p>\n<p><a href=\"http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\" target=\"_blank\" rel=\"noopener\">http://netframework.tistory.com/entry/LTW-CTW를-이용한-Transactional의-사용</a></p>\n<p><a href=\"https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5\" target=\"_blank\" rel=\"noopener\">https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>AspectJ란?</h1>\n<blockquote>\n<p>AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.</p>\n</blockquote>\n<p>AspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, <code>CTW, LTW</code>과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.<br>\n또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.<br>\n현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.</p>\n<blockquote>\n<p>Aspect란?</p>\n<p>Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.<br>\n그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.<br>\n구조적으로 보자면 Aspect = PointCut + Advisor이다.</p>\n</blockquote>\n<h1>위빙 Weaving</h1>\n<p>위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.<br>\n위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.</p>\n<p>##런타임 시, 위빙 (RTW: Runtime Weaving)</p>\n<p>Spring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.<br>\n실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.<br>\n소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.</p>\n<p><img src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw\" alt=\"Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<h2>컴파일 시, 위빙 (CTW: Compile time Weaving)</h2>\n<p>AspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.<br>\nAJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.<br>\n장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)</p>\n<h3>CTW를 사용하기 위한 메이븐 설정</h3>\n<p><strong>라이브러리 추가:</strong> (pom.xml)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>플러그인 설정:</strong> (pom.xml)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectj-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">showWeaveInfo</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">showWeaveInfo</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">verbose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">verbose</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">complianceLevel</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">complianceLevel</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outxml</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">outxml</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>test-compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><em>(*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)</em></p>\n<p>위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용</p>\n<p>AspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용</p>\n<h2>클래스 로드 시, 위빙 (LTW: Load time Weaving)</h2>\n<p>ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식<br>\nRTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.<br>\nApplication Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.</p>\n<p>그리고 설정이 가장 복잡하지 않은가 싶다…</p>\n<p>아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:load-time-weaver</span>/&gt;</span> <span class=\"comment\">&lt;!-- 스프링 설정 파일에 추가 servlet.xml --&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableLoadTimeWeaving</span> <span class=\"comment\">//Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//IDE에서 개발 시, 해당 설정을 추가</span><br><span class=\"line\">-javaagent:/fullpath/aspectjweaver-1.8.1.jar </span><br><span class=\"line\">-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//톰캣 시작 시, jvmargs 옵션에 추가</span><br><span class=\"line\">-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure>\n<h1>Annotations</h1>\n<h2>JoinPoint 관련 Annotations</h2>\n<p>공통적으로 pointcut에 대한 표현식을 인자로 받는다.</p>\n<ul>\n<li>@Before\n<ul>\n<li>메소드 실행 이전 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@Around\n<ul>\n<li>ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.</li>\n<li>메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.</li>\n</ul>\n</li>\n<li>@After\n<ul>\n<li>메소드 실행 이후 부분의 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterReturning\n<ul>\n<li>메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n<li>@AfterThrowable\n<ul>\n<li>메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정</li>\n</ul>\n</li>\n</ul>\n<h2>Pointcut 관련 Annotation</h2>\n<ul>\n<li>@Pointcut\n<ul>\n<li>Pointcut에 대한 표현식을 값으로 가짐</li>\n<li>@Pointcut이 적용된 메소드는 무조건 리턴타입이 void</li>\n</ul>\n</li>\n</ul>\n<h1>Point Cut</h1>\n<p>포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.<br>\n여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/223B623D548C415631\" alt=\"pointcut 개념\"></p>\n<h2>포인트 컷 표현식</h2>\n<p>Expression을 이용한 pointcut 표현식</p>\n<p><img src=\"http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg\" alt=\"pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼\"></p>\n<ol>\n<li>\n<p>접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)</p>\n<ul>\n<li>* 인 경우 모든 접근제어자에 대해 설정 가능</li>\n<li>생략 시, * 과 같은 효과</li>\n</ul>\n</li>\n<li>\n<p>리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)</p>\n<ul>\n<li>단, 패키지 명도 기재해야 함</li>\n<li>com.springframework.aop… 처럼 …으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리</li>\n<li>필수 적으로 기재해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>모든 메소드에 적용 하려면 * 을 사용</li>\n</ul>\n</li>\n<li>\n<p>파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정</p>\n<ul>\n<li>필수 적으로 기재해야 한다.</li>\n<li>,로 구분하여 순서대로 파라미터를 기재한다.</li>\n<li>타입과 갯수에 상관없다면 … 또는 * 를 기재한다.</li>\n</ul>\n</li>\n<li>\n<p>예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)</p>\n</li>\n</ol>\n<h2>예시</h2>\n<ul>\n<li>\n<p><strong>execution(int minus(int, int))</strong>: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(int, int))</strong>: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>\n</li>\n<li>\n<p><strong>execution(* minus(…))</strong>: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>(…))</em></em>: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(* <em>())</em></em>: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.Target.</em>(…))</em>*: springbook.aop.Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop.</em>.</em>(…))**: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.</p>\n</li>\n<li>\n<p><em><em>execution(* springbook.aop…</em>.</em>(…))**: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함</p>\n</li>\n<li>\n<p><strong>execution(* <em>…Target.</em>(…))</strong>: 패키지에는 상관없이 Target 클래스의 모든 메소드</p>\n</li>\n<li>\n<p>*<em>execution(</em> *(…) throws Exception) **: Exception을 throw하는 모든 메소드</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service.</strong>*) : service 패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>within(com.springbook.aop.service…</strong>*) : service 패키지의 하위패키지 내의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>this(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>target(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>args(java.utils.List)</strong> : 파라미터가 1개이고 List타입인 모든 Joinpoint</p>\n</li>\n<li>\n<p><strong>@target(org.springframework.transaction.annotation.Transactional)</strong> :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@within(org.springframework.transaction.annotation.Transactional)</strong> : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>@annotation(org.springframework.transaction.annotation.Transactional)</strong> : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점</p>\n</li>\n</ul>\n<ul>\n<li>\n<p><strong>@args(com.xyz.security.Classified)</strong> : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점</p>\n</li>\n<li>\n<p><strong>bean(UserRepository)</strong> : “UserRepository” 빈</p>\n</li>\n<li>\n<p><strong>!bean(UserRepository)</strong> :  “UserRepository” 빈을 제외한 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(</em>)</em>* : 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user</em>)</em>* : 이름이 'user’로 시작되는 모든 빈</p>\n</li>\n<li>\n<p>*<em>bean(<em>Repository)</em></em> : 이름이 “Repository”로 끝나는 모든 빈</p>\n</li>\n<li>\n<p><em><em>bean(user/</em>)</em>* : 이름이 “user/“로 시작하는 모든 빈</p>\n</li>\n<li>\n<p>**bean(<em>dataSource) || bean(<em>DataSource)</em></em> : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈</p>\n</li>\n</ul>\n<h1>예시코드</h1>\n<h2>Aspect 파일 사용</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> aspect TestAdvisor &#123;</span><br><span class=\"line\">    <span class=\"function\">pointcut <span class=\"title\">advicePoint</span><span class=\"params\">()</span> : <span class=\"title\">execution</span><span class=\"params\">(* com.example.advice..*(..)</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//order는 어떻게 주는건지 모르겠다.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>@Aspect 어노테이션 사용</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdvisor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.example.advice..*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pointcut</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">2</span>) <span class=\"comment\">//order가 높은 순으로 먼저 실행</span></span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterAdvice</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"처음으로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"meta\">@After</span>(pointcut=<span class=\"string\">\"pointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showLog</span><span class=\"params\">(Joinpoint joinpoint)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"두번째로 실행되는 로그\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>참고</h1>\n<p><a href=\"http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014\" target=\"_blank\" rel=\"noopener\">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014</a></p>\n<p><a href=\"http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\" target=\"_blank\" rel=\"noopener\">http://netframework.tistory.com/entry/LTW-CTW를-이용한-Transactional의-사용</a></p>\n<p><a href=\"https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5\" target=\"_blank\" rel=\"noopener\">https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5</a></p>\n"},{"layout":"post","title":"Spring AOP (5)","subtitle":"5. Custom Annotation Pointcut","date":"2018-07-24T14:14:33.000Z","background":"/img/posts/06.jpg","_content":"\n\n\nAOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.\n아래의 리뷰와 같다.\n\n![AOP코드리뷰](/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP코드리뷰.png)\n\n메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.\n\n이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.\n\n\n\n# Custom Annotation\n\nAPI에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.\n\n\n\n## Annotation 생성하기\n\n~~~java\nimport java.lang.annotation.*;\n\n@Inherited  //Annotation의 상속이 가능함 \n@Documented //JavaDoc 문서 추가 가능\n@Retention(RetentionPolicy.RUNTIME) // 컴파일 이후에도 JVM에 의해서 참조가 가능\n//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효\n//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)\n@Target({\n        ElementType.PACKAGE,         // 패키지 선언시\n        ElementType.TYPE,            // 타입 선언시\n        ElementType.CONSTRUCTOR,     // 생성자 선언시\n        ElementType.FIELD,           // 멤버 변수 선언시\n        ElementType.METHOD,          // 메소드 선언시\n        ElementType.ANNOTATION_TYPE, // 어노테이션 타입 선언시\n        ElementType.LOCAL_VARIABLE,  // 지역 변수 선언시\n        ElementType.PARAMETER,       // 매개 변수 선언시\n        ElementType.TYPE_PARAMETER,  // 매개 변수 타입 선언시\n        ElementType.TYPE_USE         // 타입 사용시\n})\npublic @interface CustomAnnotation {  //interface에 @를 붙여주면 Annotation으로 등록\n    /* enum 타입을 선언할 수 있습니다. */\n    public enum Quality {BAD, GOOD, VERYGOOD}\n    /* String은 기본 자료형은 아니지만 사용 가능합니다. */\n    String value();\n    /* 배열 형태로도 사용할 수 있습니다. */\n    int[] values();\n    /* enum 형태를 사용하는 방법입니다. */\n    Quality quality() default Quality.GOOD;\n}\n~~~\n\n\n\n## Annotation Pointcut 지정하기\n\n예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.\n\n~~~java\npackage com.example.aopexam;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.ComponentScan;\n\n@SpringBootApplication\n//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능\n@ComponentScan(value={\"com.example.aopexam\", \"com.example.custom.annotation\"})\npublic class AopExamApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AopExamApplication.class, args);\n    }\n}\n\n~~~\n\n~~~java\npackage com.example.aopexam;\n\nimport com.example.custom.annotation.CustomLog;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api/aop-test\")\npublic class ApiController {\n\n    @Autowired\n    private ApiService apiService;\n\n    @GetMapping\n    @CustomLog //get 메소드에 @CustomLog추가\n    public void getTest() {\n        apiService.method(ApiType.GET);\n    }\n\n    @PostMapping\n    public void postTest() {\n        apiService.method(ApiType.POST);\n    }\n\n    @PutMapping\n    public void putTest() {\n        apiService.method(ApiType.PUT);\n    }\n\n    @DeleteMapping\n    public void deleteTest() {\n        apiService.method(ApiType.DELETE);\n    }\n\n}\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD) //메소드 어노테이션 적용\npublic @interface CustomLog {\n}\n\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@EnableAspectJAutoProxy(proxyTargetClass = true) //cglib 사용 -> class기반 proxy생성\n@Component\npublic class CustomLogAdvisor {\n\n    //Annotation을 기준으로 pointcut설정\n    @Pointcut(\"@annotation(com.example.custom.annotation.CustomLog)\")\n    public void customLogPointcut() {\n    }\n\n    @Before(value=\"customLogPointcut()\")\n    public void pringLog() {\n        System.out.println(\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\");\n    }\n}\n~~~\n\n~~~log\nhttp://localhost:8080/api/aop-test\n\n메소드 실행 전 무조건 이 로그를 보게 될 것이야...\n[ApiService.method] apiType : GET\n~~~\n\n","source":"_posts/2018-07-24-spring-aop5.md","raw":"---\nlayout: post\ntitle:  \"Spring AOP (5)\"\nsubtitle: \"5. Custom Annotation Pointcut\"\ndate:   2018-07-24 23:14:33 +0900\nbackground: '/img/posts/06.jpg'\n---\n\n\n\nAOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.\n아래의 리뷰와 같다.\n\n![AOP코드리뷰](/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP코드리뷰.png)\n\n메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.\n\n이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.\n\n\n\n# Custom Annotation\n\nAPI에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.\n\n\n\n## Annotation 생성하기\n\n~~~java\nimport java.lang.annotation.*;\n\n@Inherited  //Annotation의 상속이 가능함 \n@Documented //JavaDoc 문서 추가 가능\n@Retention(RetentionPolicy.RUNTIME) // 컴파일 이후에도 JVM에 의해서 참조가 가능\n//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효\n//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)\n@Target({\n        ElementType.PACKAGE,         // 패키지 선언시\n        ElementType.TYPE,            // 타입 선언시\n        ElementType.CONSTRUCTOR,     // 생성자 선언시\n        ElementType.FIELD,           // 멤버 변수 선언시\n        ElementType.METHOD,          // 메소드 선언시\n        ElementType.ANNOTATION_TYPE, // 어노테이션 타입 선언시\n        ElementType.LOCAL_VARIABLE,  // 지역 변수 선언시\n        ElementType.PARAMETER,       // 매개 변수 선언시\n        ElementType.TYPE_PARAMETER,  // 매개 변수 타입 선언시\n        ElementType.TYPE_USE         // 타입 사용시\n})\npublic @interface CustomAnnotation {  //interface에 @를 붙여주면 Annotation으로 등록\n    /* enum 타입을 선언할 수 있습니다. */\n    public enum Quality {BAD, GOOD, VERYGOOD}\n    /* String은 기본 자료형은 아니지만 사용 가능합니다. */\n    String value();\n    /* 배열 형태로도 사용할 수 있습니다. */\n    int[] values();\n    /* enum 형태를 사용하는 방법입니다. */\n    Quality quality() default Quality.GOOD;\n}\n~~~\n\n\n\n## Annotation Pointcut 지정하기\n\n예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.\n\n~~~java\npackage com.example.aopexam;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.ComponentScan;\n\n@SpringBootApplication\n//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능\n@ComponentScan(value={\"com.example.aopexam\", \"com.example.custom.annotation\"})\npublic class AopExamApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AopExamApplication.class, args);\n    }\n}\n\n~~~\n\n~~~java\npackage com.example.aopexam;\n\nimport com.example.custom.annotation.CustomLog;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api/aop-test\")\npublic class ApiController {\n\n    @Autowired\n    private ApiService apiService;\n\n    @GetMapping\n    @CustomLog //get 메소드에 @CustomLog추가\n    public void getTest() {\n        apiService.method(ApiType.GET);\n    }\n\n    @PostMapping\n    public void postTest() {\n        apiService.method(ApiType.POST);\n    }\n\n    @PutMapping\n    public void putTest() {\n        apiService.method(ApiType.PUT);\n    }\n\n    @DeleteMapping\n    public void deleteTest() {\n        apiService.method(ApiType.DELETE);\n    }\n\n}\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD) //메소드 어노테이션 적용\npublic @interface CustomLog {\n}\n\n~~~\n\n~~~java\npackage com.example.custom.annotation;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@EnableAspectJAutoProxy(proxyTargetClass = true) //cglib 사용 -> class기반 proxy생성\n@Component\npublic class CustomLogAdvisor {\n\n    //Annotation을 기준으로 pointcut설정\n    @Pointcut(\"@annotation(com.example.custom.annotation.CustomLog)\")\n    public void customLogPointcut() {\n    }\n\n    @Before(value=\"customLogPointcut()\")\n    public void pringLog() {\n        System.out.println(\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\");\n    }\n}\n~~~\n\n~~~log\nhttp://localhost:8080/api/aop-test\n\n메소드 실행 전 무조건 이 로그를 보게 될 것이야...\n[ApiService.method] apiType : GET\n~~~\n\n","slug":"2018-07-24-spring-aop5","published":1,"updated":"2018-08-08T13:44:40.031Z","comments":1,"photos":[],"link":"","_id":"cjkmuoph70008edyanlhzjie1","content":"<p>AOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.<br>\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.<br>\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.<br>\n아래의 리뷰와 같다.</p>\n<p><img src=\"/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2.png\" alt=\"AOP코드리뷰\"></p>\n<p>메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.</p>\n<p>이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.</p>\n<h1><span id=\"custom-annotation\">Custom Annotation</span></h1>\n<p>API에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.</p>\n<h2><span id=\"annotation-생성하기\">Annotation 생성하기</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span>  <span class=\"comment\">//Annotation의 상속이 가능함 </span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span> <span class=\"comment\">//JavaDoc 문서 추가 가능</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME) <span class=\"comment\">// 컴파일 이후에도 JVM에 의해서 참조가 가능</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;</span><br><span class=\"line\">        ElementType.PACKAGE,         <span class=\"comment\">// 패키지 선언시</span></span><br><span class=\"line\">        ElementType.TYPE,            <span class=\"comment\">// 타입 선언시</span></span><br><span class=\"line\">        ElementType.CONSTRUCTOR,     <span class=\"comment\">// 생성자 선언시</span></span><br><span class=\"line\">        ElementType.FIELD,           <span class=\"comment\">// 멤버 변수 선언시</span></span><br><span class=\"line\">        ElementType.METHOD,          <span class=\"comment\">// 메소드 선언시</span></span><br><span class=\"line\">        ElementType.ANNOTATION_TYPE, <span class=\"comment\">// 어노테이션 타입 선언시</span></span><br><span class=\"line\">        ElementType.LOCAL_VARIABLE,  <span class=\"comment\">// 지역 변수 선언시</span></span><br><span class=\"line\">        ElementType.PARAMETER,       <span class=\"comment\">// 매개 변수 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_PARAMETER,  <span class=\"comment\">// 매개 변수 타입 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_USE         <span class=\"comment\">// 타입 사용시</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomAnnotation &#123;  <span class=\"comment\">//interface에 @를 붙여주면 Annotation으로 등록</span></span><br><span class=\"line\">    <span class=\"comment\">/* enum 타입을 선언할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Quality &#123;BAD, GOOD, VERYGOOD&#125;</span><br><span class=\"line\">    <span class=\"comment\">/* String은 기본 자료형은 아니지만 사용 가능합니다. */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 배열 형태로도 사용할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] values();</span><br><span class=\"line\">    <span class=\"comment\">/* enum 형태를 사용하는 방법입니다. */</span></span><br><span class=\"line\">    <span class=\"function\">Quality <span class=\"title\">quality</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Quality.GOOD</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"annotation-pointcut-지정하기\">Annotation Pointcut 지정하기</span></h2>\n<p>예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(value=&#123;<span class=\"string\">\"com.example.aopexam\"</span>, <span class=\"string\">\"com.example.custom.annotation\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AopExamApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(AopExamApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.custom.annotation.CustomLog;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/api/aop-test\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiService apiService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@CustomLog</span> <span class=\"comment\">//get 메소드에 @CustomLog추가</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.GET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.POST);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.PUT);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.DELETE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.ElementType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD) <span class=\"comment\">//메소드 어노테이션 적용</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomLog &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class=\"keyword\">true</span>) <span class=\"comment\">//cglib 사용 -&gt; class기반 proxy생성</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomLogAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Annotation을 기준으로 pointcut설정</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@annotation(com.example.custom.annotation.CustomLog)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">customLogPointcut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(value=<span class=\"string\">\"customLogPointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pringLog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/api/aop-test</span><br><span class=\"line\"></span><br><span class=\"line\">메소드 실행 전 무조건 이 로그를 보게 될 것이야...</span><br><span class=\"line\">[ApiService.method] apiType : GET</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>AOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.<br>\n결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.<br>\nAOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.<br>\n아래의 리뷰와 같다.</p>\n<p><img src=\"/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2.png\" alt=\"AOP코드리뷰\"></p>\n<p>메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.</p>\n<p>이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.</p>\n<h1>Custom Annotation</h1>\n<p>API에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.</p>\n<h2>Annotation 생성하기</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span>  <span class=\"comment\">//Annotation의 상속이 가능함 </span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span> <span class=\"comment\">//JavaDoc 문서 추가 가능</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME) <span class=\"comment\">// 컴파일 이후에도 JVM에 의해서 참조가 가능</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효</span></span><br><span class=\"line\"><span class=\"comment\">//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;</span><br><span class=\"line\">        ElementType.PACKAGE,         <span class=\"comment\">// 패키지 선언시</span></span><br><span class=\"line\">        ElementType.TYPE,            <span class=\"comment\">// 타입 선언시</span></span><br><span class=\"line\">        ElementType.CONSTRUCTOR,     <span class=\"comment\">// 생성자 선언시</span></span><br><span class=\"line\">        ElementType.FIELD,           <span class=\"comment\">// 멤버 변수 선언시</span></span><br><span class=\"line\">        ElementType.METHOD,          <span class=\"comment\">// 메소드 선언시</span></span><br><span class=\"line\">        ElementType.ANNOTATION_TYPE, <span class=\"comment\">// 어노테이션 타입 선언시</span></span><br><span class=\"line\">        ElementType.LOCAL_VARIABLE,  <span class=\"comment\">// 지역 변수 선언시</span></span><br><span class=\"line\">        ElementType.PARAMETER,       <span class=\"comment\">// 매개 변수 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_PARAMETER,  <span class=\"comment\">// 매개 변수 타입 선언시</span></span><br><span class=\"line\">        ElementType.TYPE_USE         <span class=\"comment\">// 타입 사용시</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomAnnotation &#123;  <span class=\"comment\">//interface에 @를 붙여주면 Annotation으로 등록</span></span><br><span class=\"line\">    <span class=\"comment\">/* enum 타입을 선언할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Quality &#123;BAD, GOOD, VERYGOOD&#125;</span><br><span class=\"line\">    <span class=\"comment\">/* String은 기본 자료형은 아니지만 사용 가능합니다. */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 배열 형태로도 사용할 수 있습니다. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] values();</span><br><span class=\"line\">    <span class=\"comment\">/* enum 형태를 사용하는 방법입니다. */</span></span><br><span class=\"line\">    <span class=\"function\">Quality <span class=\"title\">quality</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Quality.GOOD</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Annotation Pointcut 지정하기</h2>\n<p>예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(value=&#123;<span class=\"string\">\"com.example.aopexam\"</span>, <span class=\"string\">\"com.example.custom.annotation\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AopExamApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(AopExamApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.aopexam;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.custom.annotation.CustomLog;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/api/aop-test\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiService apiService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@CustomLog</span> <span class=\"comment\">//get 메소드에 @CustomLog추가</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.GET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.POST);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.PUT);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        apiService.method(ApiType.DELETE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.ElementType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD) <span class=\"comment\">//메소드 어노테이션 적용</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CustomLog &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.custom.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class=\"keyword\">true</span>) <span class=\"comment\">//cglib 사용 -&gt; class기반 proxy생성</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomLogAdvisor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Annotation을 기준으로 pointcut설정</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@annotation(com.example.custom.annotation.CustomLog)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">customLogPointcut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(value=<span class=\"string\">\"customLogPointcut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pringLog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"메소드 실행 전 무조건 이 로그를 보게 될 것이야...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/api/aop-test</span><br><span class=\"line\"></span><br><span class=\"line\">메소드 실행 전 무조건 이 로그를 보게 될 것이야...</span><br><span class=\"line\">[ApiService.method] apiType : GET</span><br></pre></td></tr></table></figure>\n"},{"title":"Spring Argument Resovler","catalog":true,"date":"2018-08-09T16:53:17.000Z","subtitle":"Controller를 깔끔하게 해주는 Argument Resolver","header-img":null,"typora-root-url":"./2018-08-10-spring-argument-resolver","typora-copy-images-to":"./2018-08-10-spring-argument-resolver","_content":"\n\n\n회사 업무 중에 이미 개발 된 API의 Controller에서 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다.\n처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나.. 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 굳이 script로 찾기가 번거로웠다.\n\n그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다.\n아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.\n\n하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체에서 Client IP를 조회하는 소스를 중복해서 넣기는 번거럽고 꾀나 길었다.. (한 10줄 정도는 된다.)\n\n그래서 중간에 Filter나 Interceptor로 해볼까..? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다.\n그에 대한 기록을 위해 해당 포스팅을 작성한다.\n\n\n\n# Spring Argument Resolver\n\nSpring Argument Resolver는 `Controller에 들어오는 파라미터를 가공`해야 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. 각기 Controller에서 해당로직을 수행할 수 있기 때문이다. 하지만, 이는 중복 코드를 양산하고 유지보수 용이성이 떨어지는 코딩 방법이다.\nArgument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.\nSpring에서는 `HandlerMethodArgumentResolver`라는 인터페이스를 제공하여 개발자에게 기능을 확장 할 수 있도록 기능을 제공한다. \n\n\n\n# Argument Resolver 동작 방식\n\n![Dispatch-Seq](/Dispatch-Seq.jpg)\n\n\n\n(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)\n\n1. Client Request 요청\n2. Dispatcher Servlet에서 해당 요청을 처리\n3. Client Request에 대한 Handler Mapping \n   1. RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)\n   2. Interceptor처리\n   3. `Argument Resolver 처리` <-- 바로 여기서 우리가 지정한 Argument Resolver 실행\n   4. Message Converter 처리\n4. Controller Method invoke\n\n\n\n![RequestMappingHandlerAdapter](/RequestMappingHandlerAdapter.png)\n\n\n\nRequestHandlerMappingAdapter.java > getDefaultArgumentResolvers\n\n위에서 지정 된 순서대로 Argument Resolver를 실행 한다.\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.\n\n\n\n# Custom Argument Resolver 만들기\n\n내가 업무 중에 처한 상황을 기반으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에..)\n\n기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.\nCustom Argument Resolver를 만들기 위해서는 HandlerMethodArgumentResolver` 인터페이스를 구현하여 만든다.\n\n\n\n```java\npackage com.example.springstudy.resolver;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.support.WebDataBinderFactory;\nimport org.springframework.web.context.request.NativeWebRequest;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.method.support.ModelAndViewContainer;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class ClientIpArgumentResolver implements HandlerMethodArgumentResolver {\n\n    /**\n     * resolveArgument를 실행 할 수 있는 method인지 판별\n     * @param methodParameter\n     * @return\n     */\n    @Override\n    public boolean supportsParameter(MethodParameter methodParameter) {\n        //@ClientIP 어노테이션이 붙은 파라미터에 대해 적용\n        return methodParameter.hasParameterAnnotation(ClientIP.class);\n    }\n\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n}\n\n```\n\n\n\nHandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.\n\n- supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n  - 물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.\n- resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.\n\n\n\n# Custom Argument Resolver 등록하기\n\n개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.\n\n전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.\n\n\n\n1. ServletContext.xml 에 등록하는 방법\n\n```xml\n<mvc:annotation-driven>\n    <mvc:argument-resolvers>\n        <bean class=\"com.example.springstudy.resolver.ClientIpArgumentResolver\"></bean>      \n    </mvc:argument-resolvers>\n</mvc:annotation-driven>\n```\n\n\n\n1. Java Config를 이용하는 방법\n\n```java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\nimport java.util.List;\n\n//WebMvcConfigurationSupport를 상속 \n//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n    \n    //우리가 만든 ArgumentResolver를 추가한다.\n    @Override\n    protected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        super.addArgumentResolvers(argumentResolvers);\n        argumentResolvers.add(new ClientIpArgumentResolver());\n    }\n}\n```\n\n\n\n# Controller에 적용\n\n```java\npackage com.example.springstudy.controller;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class ClientController {\n\n    /**\n     * 요청을 보낸 Client Ip를 return\n     * @param clientIp\n     * @return\n     */\n    @GetMapping(\"/client\")\n    public String getClientIp(@ClientIP String clientIp) {\n\n        return String.format(\"Request Client Ip = %s\", clientIp);\n    }\n}\n```\n\n\n\nController 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.\n\n\n\n실행 결과\n\n![argument-resolver-result](/argument-resolver-result.png)\n\n\n\n\n\n# 참조\n\n토비의 스프링 vol.2\n\nhttp://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\n\nhttp://zgundam.tistory.com/38\n\nhttp://rstoyanchev.github.io/spring-mvc-31-update/#13","source":"_posts/2018-08-10-spring-argument-resolver.md","raw":"---\ntitle: Spring Argument Resovler\ncatalog: true\ndate: 2018-08-10 01:53:17\nsubtitle: Controller를 깔끔하게 해주는 Argument Resolver\nheader-img:\ntags: Spring\ntypora-root-url: ./2018-08-10-spring-argument-resolver\ntypora-copy-images-to: ./2018-08-10-spring-argument-resolver\n---\n\n\n\n회사 업무 중에 이미 개발 된 API의 Controller에서 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다.\n처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나.. 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 굳이 script로 찾기가 번거로웠다.\n\n그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다.\n아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.\n\n하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체에서 Client IP를 조회하는 소스를 중복해서 넣기는 번거럽고 꾀나 길었다.. (한 10줄 정도는 된다.)\n\n그래서 중간에 Filter나 Interceptor로 해볼까..? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다.\n그에 대한 기록을 위해 해당 포스팅을 작성한다.\n\n\n\n# Spring Argument Resolver\n\nSpring Argument Resolver는 `Controller에 들어오는 파라미터를 가공`해야 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. 각기 Controller에서 해당로직을 수행할 수 있기 때문이다. 하지만, 이는 중복 코드를 양산하고 유지보수 용이성이 떨어지는 코딩 방법이다.\nArgument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.\nSpring에서는 `HandlerMethodArgumentResolver`라는 인터페이스를 제공하여 개발자에게 기능을 확장 할 수 있도록 기능을 제공한다. \n\n\n\n# Argument Resolver 동작 방식\n\n![Dispatch-Seq](/Dispatch-Seq.jpg)\n\n\n\n(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)\n\n1. Client Request 요청\n2. Dispatcher Servlet에서 해당 요청을 처리\n3. Client Request에 대한 Handler Mapping \n   1. RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)\n   2. Interceptor처리\n   3. `Argument Resolver 처리` <-- 바로 여기서 우리가 지정한 Argument Resolver 실행\n   4. Message Converter 처리\n4. Controller Method invoke\n\n\n\n![RequestMappingHandlerAdapter](/RequestMappingHandlerAdapter.png)\n\n\n\nRequestHandlerMappingAdapter.java > getDefaultArgumentResolvers\n\n위에서 지정 된 순서대로 Argument Resolver를 실행 한다.\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.\n\n\n\n# Custom Argument Resolver 만들기\n\n내가 업무 중에 처한 상황을 기반으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에..)\n\n기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.\nCustom Argument Resolver를 만들기 위해서는 HandlerMethodArgumentResolver` 인터페이스를 구현하여 만든다.\n\n\n\n```java\npackage com.example.springstudy.resolver;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.support.WebDataBinderFactory;\nimport org.springframework.web.context.request.NativeWebRequest;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.method.support.ModelAndViewContainer;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class ClientIpArgumentResolver implements HandlerMethodArgumentResolver {\n\n    /**\n     * resolveArgument를 실행 할 수 있는 method인지 판별\n     * @param methodParameter\n     * @return\n     */\n    @Override\n    public boolean supportsParameter(MethodParameter methodParameter) {\n        //@ClientIP 어노테이션이 붙은 파라미터에 대해 적용\n        return methodParameter.hasParameterAnnotation(ClientIP.class);\n    }\n\n    /**\n     * Method parameter에 대한 Argument Resovler로직 처리\n     * @param methodParameter\n     * @param modelAndViewContainer\n     * @param nativeWebRequest\n     * @param webDataBinderFactory\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();\n\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (StringUtils.isEmpty(clientIp)|| \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (StringUtils.isEmpty(clientIp) || \"unknown\".equalsIgnoreCase(clientIp)) {\n            clientIp = request.getRemoteAddr();\n        }\n\n        return clientIp;\n    }\n}\n\n```\n\n\n\nHandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.\n\n- supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n  - 물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.\n- resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.\n\n\n\n# Custom Argument Resolver 등록하기\n\n개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.\n\n전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.\n\n\n\n1. ServletContext.xml 에 등록하는 방법\n\n```xml\n<mvc:annotation-driven>\n    <mvc:argument-resolvers>\n        <bean class=\"com.example.springstudy.resolver.ClientIpArgumentResolver\"></bean>      \n    </mvc:argument-resolvers>\n</mvc:annotation-driven>\n```\n\n\n\n1. Java Config를 이용하는 방법\n\n```java\npackage com.example.springstudy.config;\n\nimport com.example.springstudy.resolver.ClientIpArgumentResolver;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\nimport java.util.List;\n\n//WebMvcConfigurationSupport를 상속 \n//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport {\n    \n    //우리가 만든 ArgumentResolver를 추가한다.\n    @Override\n    protected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        super.addArgumentResolvers(argumentResolvers);\n        argumentResolvers.add(new ClientIpArgumentResolver());\n    }\n}\n```\n\n\n\n# Controller에 적용\n\n```java\npackage com.example.springstudy.controller;\n\nimport com.example.springstudy.annotation.ClientIP;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class ClientController {\n\n    /**\n     * 요청을 보낸 Client Ip를 return\n     * @param clientIp\n     * @return\n     */\n    @GetMapping(\"/client\")\n    public String getClientIp(@ClientIP String clientIp) {\n\n        return String.format(\"Request Client Ip = %s\", clientIp);\n    }\n}\n```\n\n\n\nController 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.\n\n\n\n실행 결과\n\n![argument-resolver-result](/argument-resolver-result.png)\n\n\n\n\n\n# 참조\n\n토비의 스프링 vol.2\n\nhttp://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\n\nhttp://zgundam.tistory.com/38\n\nhttp://rstoyanchev.github.io/spring-mvc-31-update/#13","slug":"2018-08-10-spring-argument-resolver","published":1,"updated":"2018-08-09T17:58:40.288Z","_id":"cjkmuoph90009edyaif7o6ues","comments":1,"layout":"post","photos":[],"link":"","content":"<p>회사 업무 중에 이미 개발 된 API의 Controller에서 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다.<br>\n처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나… 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 굳이 script로 찾기가 번거로웠다.</p>\n<p>그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다.<br>\n아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.</p>\n<p>하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체에서 Client IP를 조회하는 소스를 중복해서 넣기는 번거럽고 꾀나 길었다… (한 10줄 정도는 된다.)</p>\n<p>그래서 중간에 Filter나 Interceptor로 해볼까…? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다.<br>\n그에 대한 기록을 위해 해당 포스팅을 작성한다.</p>\n<h1><span id=\"spring-argument-resolver\">Spring Argument Resolver</span></h1>\n<p>Spring Argument Resolver는 <code>Controller에 들어오는 파라미터를 가공</code>해야 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. 각기 Controller에서 해당로직을 수행할 수 있기 때문이다. 하지만, 이는 중복 코드를 양산하고 유지보수 용이성이 떨어지는 코딩 방법이다.<br>\nArgument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.<br>\nSpring에서는 <code>HandlerMethodArgumentResolver</code>라는 인터페이스를 제공하여 개발자에게 기능을 확장 할 수 있도록 기능을 제공한다.</p>\n<h1><span id=\"argument-resolver-동작-방식\">Argument Resolver 동작 방식</span></h1>\n<p><img src=\"/Dispatch-Seq.jpg\" alt=\"Dispatch-Seq\"></p>\n<p>(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)</p>\n<ol>\n<li>Client Request 요청</li>\n<li>Dispatcher Servlet에서 해당 요청을 처리</li>\n<li>Client Request에 대한 Handler Mapping\n<ol>\n<li>RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)</li>\n<li>Interceptor처리</li>\n<li><code>Argument Resolver 처리</code> &lt;-- 바로 여기서 우리가 지정한 Argument Resolver 실행</li>\n<li>Message Converter 처리</li>\n</ol>\n</li>\n<li>Controller Method invoke</li>\n</ol>\n<p><img src=\"/RequestMappingHandlerAdapter.png\" alt=\"RequestMappingHandlerAdapter\"></p>\n<p>RequestHandlerMappingAdapter.java &gt; getDefaultArgumentResolvers</p>\n<p>위에서 지정 된 순서대로 Argument Resolver를 실행 한다.<br>\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.<br>\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.</p>\n<h1><span id=\"custom-argument-resolver-만들기\">Custom Argument Resolver 만들기</span></h1>\n<p>내가 업무 중에 처한 상황을 기반으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에…)</p>\n<p>기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.<br>\nCustom Argument Resolver를 만들기 위해서는 HandlerMethodArgumentResolver` 인터페이스를 구현하여 만든다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.resolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.MethodParameter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.util.StringUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientIpArgumentResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * resolveArgument를 실행 할 수 있는 method인지 판별</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supportsParameter</span><span class=\"params\">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//@ClientIP 어노테이션이 붙은 파라미터에 대해 적용</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> methodParameter.hasParameterAnnotation(ClientIP.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">        String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getRemoteAddr();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.</p>\n<ul>\n<li>supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n<ul>\n<li>물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.</li>\n</ul>\n</li>\n<li>resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.</li>\n</ul>\n<h1><span id=\"custom-argument-resolver-등록하기\">Custom Argument Resolver 등록하기</span></h1>\n<p>개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.</p>\n<p>전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.</p>\n<ol>\n<li>ServletContext.xml 에 등록하는 방법</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.resolver.ClientIpArgumentResolver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span>      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>Java Config를 이용하는 방법</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//WebMvcConfigurationSupport를 상속 </span></span><br><span class=\"line\"><span class=\"comment\">//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//우리가 만든 ArgumentResolver를 추가한다.</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addArgumentResolvers</span><span class=\"params\">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addArgumentResolvers(argumentResolvers);</span><br><span class=\"line\">        argumentResolvers.add(<span class=\"keyword\">new</span> ClientIpArgumentResolver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"controller에-적용\">Controller에 적용</span></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 요청을 보낸 Client Ip를 return</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> clientIp</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/client\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getClientIp</span><span class=\"params\">(@ClientIP String clientIp)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.format(<span class=\"string\">\"Request Client Ip = %s\"</span>, clientIp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Controller 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.</p>\n<p>실행 결과</p>\n<p><img src=\"/argument-resolver-result.png\" alt=\"argument-resolver-result\"></p>\n<h1><span id=\"참조\">참조</span></h1>\n<p>토비의 스프링 vol.2</p>\n<p><a href=\"http://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"noopener\">http://jekalmin.tistory.com/entry/커스텀-ArgumentResolver-등록하기</a></p>\n<p><a href=\"http://zgundam.tistory.com/38\" target=\"_blank\" rel=\"noopener\">http://zgundam.tistory.com/38</a></p>\n<p><a href=\"http://rstoyanchev.github.io/spring-mvc-31-update/#13\" target=\"_blank\" rel=\"noopener\">http://rstoyanchev.github.io/spring-mvc-31-update/#13</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>회사 업무 중에 이미 개발 된 API의 Controller에서 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다.<br>\n처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나… 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 굳이 script로 찾기가 번거로웠다.</p>\n<p>그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다.<br>\n아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.</p>\n<p>하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체에서 Client IP를 조회하는 소스를 중복해서 넣기는 번거럽고 꾀나 길었다… (한 10줄 정도는 된다.)</p>\n<p>그래서 중간에 Filter나 Interceptor로 해볼까…? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다.<br>\n그에 대한 기록을 위해 해당 포스팅을 작성한다.</p>\n<h1>Spring Argument Resolver</h1>\n<p>Spring Argument Resolver는 <code>Controller에 들어오는 파라미터를 가공</code>해야 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. 각기 Controller에서 해당로직을 수행할 수 있기 때문이다. 하지만, 이는 중복 코드를 양산하고 유지보수 용이성이 떨어지는 코딩 방법이다.<br>\nArgument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.<br>\nSpring에서는 <code>HandlerMethodArgumentResolver</code>라는 인터페이스를 제공하여 개발자에게 기능을 확장 할 수 있도록 기능을 제공한다.</p>\n<h1>Argument Resolver 동작 방식</h1>\n<p><img src=\"/Dispatch-Seq.jpg\" alt=\"Dispatch-Seq\"></p>\n<p>(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)</p>\n<ol>\n<li>Client Request 요청</li>\n<li>Dispatcher Servlet에서 해당 요청을 처리</li>\n<li>Client Request에 대한 Handler Mapping\n<ol>\n<li>RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)</li>\n<li>Interceptor처리</li>\n<li><code>Argument Resolver 처리</code> &lt;-- 바로 여기서 우리가 지정한 Argument Resolver 실행</li>\n<li>Message Converter 처리</li>\n</ol>\n</li>\n<li>Controller Method invoke</li>\n</ol>\n<p><img src=\"/RequestMappingHandlerAdapter.png\" alt=\"RequestMappingHandlerAdapter\"></p>\n<p>RequestHandlerMappingAdapter.java &gt; getDefaultArgumentResolvers</p>\n<p>위에서 지정 된 순서대로 Argument Resolver를 실행 한다.<br>\n메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.<br>\n아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.</p>\n<h1>Custom Argument Resolver 만들기</h1>\n<p>내가 업무 중에 처한 상황을 기반으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에…)</p>\n<p>기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.<br>\nCustom Argument Resolver를 만들기 위해서는 HandlerMethodArgumentResolver` 인터페이스를 구현하여 만든다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.resolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.MethodParameter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.util.StringUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientIpArgumentResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * resolveArgument를 실행 할 수 있는 method인지 판별</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supportsParameter</span><span class=\"params\">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//@ClientIP 어노테이션이 붙은 파라미터에 대해 적용</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> methodParameter.hasParameterAnnotation(ClientIP.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodParameter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> modelAndViewContainer</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nativeWebRequest</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> webDataBinderFactory</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">        String clientIp = request.getHeader(<span class=\"string\">\"X-Forwarded-For\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp)|| <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"WL-Proxy-Client-IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_CLIENT_IP\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getHeader(<span class=\"string\">\"HTTP_X_FORWARDED_FOR\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(clientIp) || <span class=\"string\">\"unknown\"</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class=\"line\">            clientIp = request.getRemoteAddr();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> clientIp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.</p>\n<ul>\n<li>supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)\n<ul>\n<li>물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.</li>\n</ul>\n</li>\n<li>resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.</li>\n</ul>\n<h1>Custom Argument Resolver 등록하기</h1>\n<p>개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.</p>\n<p>전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.</p>\n<ol>\n<li>ServletContext.xml 에 등록하는 방법</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.example.springstudy.resolver.ClientIpArgumentResolver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span>      </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>Java Config를 이용하는 방법</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//WebMvcConfigurationSupport를 상속 </span></span><br><span class=\"line\"><span class=\"comment\">//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//우리가 만든 ArgumentResolver를 추가한다.</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addArgumentResolvers</span><span class=\"params\">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.addArgumentResolvers(argumentResolvers);</span><br><span class=\"line\">        argumentResolvers.add(<span class=\"keyword\">new</span> ClientIpArgumentResolver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>Controller에 적용</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springstudy.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 요청을 보낸 Client Ip를 return</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> clientIp</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/client\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getClientIp</span><span class=\"params\">(@ClientIP String clientIp)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.format(<span class=\"string\">\"Request Client Ip = %s\"</span>, clientIp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Controller 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.</p>\n<p>실행 결과</p>\n<p><img src=\"/argument-resolver-result.png\" alt=\"argument-resolver-result\"></p>\n<h1>참조</h1>\n<p>토비의 스프링 vol.2</p>\n<p><a href=\"http://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"noopener\">http://jekalmin.tistory.com/entry/커스텀-ArgumentResolver-등록하기</a></p>\n<p><a href=\"http://zgundam.tistory.com/38\" target=\"_blank\" rel=\"noopener\">http://zgundam.tistory.com/38</a></p>\n<p><a href=\"http://rstoyanchev.github.io/spring-mvc-31-update/#13\" target=\"_blank\" rel=\"noopener\">http://rstoyanchev.github.io/spring-mvc-31-update/#13</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/2018-08-10-spring-argument-resolver/RequestMappingHandlerAdapter.png","slug":"RequestMappingHandlerAdapter.png","post":"cjkmuoph90009edyaif7o6ues","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/Dispatch-Seq.jpg","slug":"Dispatch-Seq.jpg","post":"cjkmuoph90009edyaif7o6ues","modified":0,"renderable":0},{"_id":"source/_posts/2018-08-10-spring-argument-resolver/argument-resolver-result.png","slug":"argument-resolver-result.png","post":"cjkmuoph90009edyaif7o6ues","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjkmuoph90009edyaif7o6ues","tag_id":"cjkmuophi000aedyaf2lizg5m","_id":"cjkmuopho000bedyaod6vdn28"}],"Tag":[{"name":"Spring","_id":"cjkmuophi000aedyaf2lizg5m"}]}}