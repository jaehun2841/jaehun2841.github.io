<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Carrey`s 기술블로그</title>
    <link>https://jaehun2841.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 04 Feb 2019 11:43:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Item 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item41/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item41/</guid>
      <pubDate>Mon, 04 Feb 2019 11:22:34 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시 해주는 인터페이스를 마커 인터페이스라고 한다.&lt;br&gt;
Serializeable 인터페이스가 가장 좋은 예이다.&lt;/p&gt;
&lt;p
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시 해주는 인터페이스를 마커 인터페이스라고 한다.<br>Serializeable 인터페이스가 가장 좋은 예이다.</p><p><img src="./serializable.png" alt="serializable"></p><p>아무런 메서드도 없다.<br>단지 타입 정보만 알려주는 인터페이스이다.</p><h1 id="마커-인터페이스의-장점">마커 인터페이스의 장점</h1><ul><li>마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 사용가능하다.<br>(마커 애너테이션은 그렇지 않다.)</li><li>마커 인터페이스는 컴파일타임에 오류를 발견할 수 있다.(마커 애너테이션은 런타임에 발견된다.)</li><li>ObjectOutputStream.writeObject 메서드는 파라미터에 Serializeable 인터페이스를 구현한 파라미터가 와야한다.<ul><li>Serializeable를 구현한 파라미터가 와도 컴파일 에러는 나지 않는다.</li><li>하지만 런타임에 Serializeable 타입이 아니라는 에러를 발생 시킨다.</li></ul></li><li>적용 대상을 더 정밀하게 지정할 수 있다.<ul><li>적용 대상을 @Target(ElementType.TYPE)으로 선언한 애너테이션은 모든 타입(클래스, 인터페이스, 열거타입, 애너테이션)에 달 수 있다.</li><li>부착 할 수 있는 타입을 더 세밀하게 제한하지 못한다.</li><li>마커 인터페이스의 경우 그냥 마킹하고 싶은 클래스에만 그 인터페이스를 구현하면 된다.<br>그러면 마킹된 타입은 자동으로 그 인터페이스의 하위타입이 보장된다.</li></ul></li><li>마커 인터페이스는 객체의 특정 부분을 불변식으로 규정하거나,<br>그 타입의 인스턴스는 다른 클래스의 특정 메서드가 처리 할 수 있다는 사실을 명시하는 용도로 사용 할 수 있다.<br>(Serializeable 인터페이스가 ObjectOutputStream이 처리할 수 있는 인스턴스이듯이)</li></ul><h1 id="마커-애너테이션의-장점">마커 애너테이션의 장점</h1><ul><li>거대한 애너테이션 시스템의 지원을 받는다.<ul><li>애너테이션 기반의 프레임워크에서는 마커 애너테이션을 쓰는 쪽이 더 나을 수 있다. (일관적이어서)</li></ul></li><li>클래스, 인터페이스 외의 프로그램 요소 (모듈, 패키지, 필드, 지역변수)에 마킹해햐 할 때는  마커 인터페이스를 쓸 수 없으니<br>마커 애너테이션을 사용할 수밖에 없다.</li></ul><h1 id="요약">요약</h1><ul><li>마커 인터페이스와 마커 애너테이션은 각자의 쓰임이 있다.</li><li>새로 추가하는 메서드 없이 단지 타입 정의가 목적이라면 마커 인터페이스를 선택하자</li><li>마커 애너테이션을 사용할 때 @Target(ElementType.TYPE)인 마커 애너테이션을 작성하고 있다면,<br>마커 애너테이션을 정말 사용해야 하는지? 마커 인터페이스를 사용할 수 있는지 생각해보고<br>웬만하면 마커 인터페이스를 사용하도록 하자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item41/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 40. @Override 애너테이션을 일관되게 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item40/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item40/</guid>
      <pubDate>Mon, 04 Feb 2019 10:51:36 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바가 기본으로 제공하는 애너테이션 중 보통의 프로그래머에게 가장 중요한 것은 @Override일 것이다.&lt;br&gt;
@Override는 메서드 선언에만 달 수 있으며, 이 애너테이션의 의미는 상위 클래스의 메서드
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바가 기본으로 제공하는 애너테이션 중 보통의 프로그래머에게 가장 중요한 것은 @Override일 것이다.<br>@Override는 메서드 선언에만 달 수 있으며, 이 애너테이션의 의미는 상위 클래스의 메서드를 재정의 했음을 의미한다.</p><h1 id="override를-선언하지-않은-메서드">@Override를 선언하지 않은 메서드</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bigram</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bigram</span><span class="params">(<span class="keyword">char</span> first, <span class="keyword">char</span> second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Bigram bigram)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bigram.first == <span class="keyword">this</span>.first &amp;&amp;</span><br><span class="line">                bigram.second == <span class="keyword">this</span>.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * first + second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Bigram&gt; s = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">                s.add(<span class="keyword">new</span> Bigram(ch, ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(s.size()); <span class="comment">//260</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Bigram이라는 문자 2개를 갖는 클래스에 a~z까지 26개의 문자를 넣고, 10개씩 만든다음에 HashSet에 삽입했다.<br>생각해보면 26개가 나올 것 같지만, 실제로는 260개가 발생한다.</p><p>왜 그럴까?</p><p>HashSet은 내부적으로 equals 메서드를 기반으로 객체의 논리적 동치적(equals) 검사를 실시한다.<br>하지만 자세히 보면 equals메서드의 파라미터 타입이 Bigram이다. equals 메서드를 재정의 한게 아니라 Overloading 한 꼴이다.</p><p>equals를 재정의 하려면 파라미터 타입이 Object이어야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Bigram bigram)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bigram.first == <span class="keyword">this</span>.first &amp;&amp;</span><br><span class="line">        bigram.second == <span class="keyword">this</span>.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 변경하고 컴파일 해보면,</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(15, 5) java: method does not override or implement a method from a supertype</span><br></pre></td></tr></table></figure></p><p>이러한 컴파일 에러가 발생한다.</p><p>잘못된 부분을 명확히 알려주므로 곧장 수정할 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object bigram)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Bigram)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Bigram b = (Bigram) bigram;</span><br><span class="line">    <span class="keyword">return</span> b.first == <span class="keyword">this</span>.first &amp;&amp;</span><br><span class="line">        b.second == <span class="keyword">this</span>.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="요약">요약</h1><ul><li>상위 클래스의 메서드를 재정의 하는 모든 메서드에 @Override 애너테이션을 달자</li><li>굳이 @Override를 달지 않아도 동작은 한다. 하지만 일괄적으로 붙여주는게 좋다.</li><li>인터페이스를 상속한 구체 클래스인데 아직 구현하지 않은 추상 메서드가 남아있다면,<br>컴파일러가 바로 사실을 알려준다.</li><li>Java 8 부터 Default 메서드의 사용이 가능해 지면서, 인터페이스의 메서드를 재정의 할 때도 사용할 수 있다.</li><li>구현하려는 인터페이스에 Default 메서드가 없음을 안다면 @Override를 생략해 코드를 조금 깔끔히 유지해도 좋다.</li><li>웬만하면 추상클래스나 인터페이스에서는 상위 클래스나 상위 인터페이스를 재정의하는 모든 메서드에 @Override를 다는것이 좋다.<br>(실수 했을 때 컴파일러가 알려준다.)</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 40. @Override 애너테이션을 일관되게 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item40/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 39. 명명 패턴보다 애너테이션을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item39/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item39/</guid>
      <pubDate>Mon, 04 Feb 2019 10:49:36 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;전통적으로 도구나 프레임워크가 특별히 다뤄야 할 프로그램 요소에는 딱 구분되는 명명 패턴을 적용해 왔다.&lt;br&gt;
예컨데 테스트 프레임워크인 JUnit3에서는 테스트 메서드 이름을 &lt;strong&gt;test&lt;/str
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>전통적으로 도구나 프레임워크가 특별히 다뤄야 할 프로그램 요소에는 딱 구분되는 명명 패턴을 적용해 왔다.<br>예컨데 테스트 프레임워크인 JUnit3에서는 테스트 메서드 이름을 <strong>test</strong>로 시작하게 지어야 했다.</p><p>단점은 아래와 같다.</p><ol><li><p>오타가 나면 안된다.<br>실수로 이름을 tset~라고 지으면 그 테스트 메서드는 무시하고 지나가기 때문에 테스트 메서드가 제대로 실행됐는지 어쨌는지 모른다.</p></li><li><p>올바른 프로그램 요소에서만 사용되리라 보증 할 방법이 없다.<br>예컨데 TestSafetyMechanisms으로 JUnit에 던져줬다고 해보자. 개발자는 이 클래스에 정의된 테스트 메서드들을 수행해 주길 기대하겠지만, JUnit은 클래스 이름에는 관심이 없다. 이번에도 경고조차 출력하지 않고 개발자가 의도한 대로 테스트는 진행되지 않는다.</p></li><li><p>프로그램 요소를 매개변수로 전달할 마땅한 방법이 없다는 것이다.<br>특정 예외를 던져야만 성공하는 테스트가 있을 때, 기대하는 예외의 타입을 매개변수로 전달해야 하는 상황이다.<br>예외의 이름을 테스트 메서드 이름에 덧붙이는 방법도 있지만, 보기에도 나쁘고 깨지기도 쉽다.</p></li></ol><p>이런 문제를 해결해 주는 개념으로 JUnit4 부터는 애너테이션을 도입하였다.</p><h1 id="마커-애너테이션-타입선언">마커 애너테이션 타입선언</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 테스트 메서드임을 선언하는 애너테이션이다.</span></span><br><span class="line"><span class="comment">* 매개변수 없는 정적메서드 전용이다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//성공</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//실행되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//실패</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"실패"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//실행되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//잘못 사용한 예</span></span><br><span class="line">        <span class="comment">//static method가 아니다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//실행되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//실패</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"실패"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//실행되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@Test와 같은 애너테이션을 <strong>아무 매개변수 없이 단순히 대상에 마킹(Marking)한다</strong>는 뜻에서 마커 애너테이션 (Marker Annotation)이라고 한다.<br>이 애너테이션을 사용하면 @Test 애너테이션에 오타를 내면 컴파일 오류를 내준다.</p><p>아래 프로그램을 실행하면총 8개의 메서드 중 4개의 테스트 메서드가 실행되고</p><ul><li>성공 1개</li><li>실패 2개</li><li>1개는 잘못 사용한 예이다.</li></ul><p>애너테이션은 Sample클래스의 의미에 직접적으로 영향을 주지는 않는다.<br>그저 애너테이션에 관심있는 프로그램에게 추가 정보를 제공할 뿐이다.<br>다시 말하면, 프로그램 코드에의 의미는 그대로 둔 채 애너테이션에 관심있는 도구에서 특별히 처리하도록 하는 것이다.</p><h2 id="메타-애너테이션-meta-annotation">메타 애너테이션 (Meta Annotation)</h2><p>애너테이션 타입에 다는 애너테이션을 메타 애너테이션 (Meta Annotation)이라 한다.<br>메타 애너테이션의 종류로는</p><ul><li><p><strong>@Documented</strong>: 문서에도 애너테이션 정보가 표현되게 함</p></li><li><p><strong>@Inherited</strong>: 자식클래스가 애너테이션을 상속받을 수 있게 함</p></li><li><p><strong>@Repeatable</strong>: 애너테이션을 반복적으로 사용할 수 있게 함</p></li><li><p><strong>@Retention(RetentionPolicy)</strong>: 애너테이션의 범위를 지정 (어느 시점까지 유효한지?)</p><ul><li><strong>RetentionPolicy.RUNTIME</strong>: 컴파일 이후에도 JVM에 의해 참조가 가능 - 보통 이거로 설정</li><li><strong>RetentionPolicy.CLASS</strong>: 컴파일러가 클래스를 참조할 때 까지 유효</li><li><strong>RetentionPolicy.SOURCE</strong>: 애너테이션 정보가 컴파일 이후 사라짐</li></ul></li><li><p><strong>@Target(ElementType[])</strong>: 애너테이션이 적용될 위치를 선언</p><ul><li><strong>ElementType.PACKAGE</strong>:  패키지 선언시</li><li><strong>ElementType.TYPE</strong>: 타입 선언시</li><li><strong>ElementType.CONSTRUCTOR</strong>: 생성자 선언시</li><li><strong>ElementType.FIELD</strong>: 멤버 변수 선언시</li><li><strong>ElementType.METHOD</strong>:  메소드 선언시</li><li><strong>ElementType.ANNOTATION_TYPE</strong>: 어노테이션 타입 선언시</li><li><strong>ElementType.LOCAL_VARIABLE</strong>: 지역 변수 선언시</li><li><strong>ElementType.PARAMETER</strong>: 매개 변수 선언시</li><li><strong>ElementType.TYPE_PARAMETER</strong>: 매개 변수 타입 선언시</li><li><strong>ElementType.TYPE_USE</strong>: 타입 사용시</li></ul></li></ul><h2 id="마커-애너테이션-processor">마커 애너테이션 processor</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tests = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> passed = <span class="number">0</span>;</span><br><span class="line">        Class&lt;?&gt; testClass = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Method m : testClass.getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.isAnnotationPresent(Test.class)) &#123;</span><br><span class="line">                test++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    m.invoke(<span class="keyword">null</span>);</span><br><span class="line">                    passed++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException wrappedExc) &#123;</span><br><span class="line">                    Throwable exc = wrappedExc.getCause();</span><br><span class="line">                    System.out.println(m + <span class="string">" 실패: "</span> + exc);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"잘못 사용한 @Test: "</span> + m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.printf(<span class="string">"성공: %d, 실패: %d%n"</span>, passed, tests-passed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>m.isAnnotationPresent(Test.class)</strong>: @Test 애너테이션이 적용된 메서드인지 판별</li><li><strong>m.invoke()</strong>: @Test 메서드 실행</li><li><strong>InvocationTargetException</strong>: 테스트 메서드가 예외를 던지면 리플렉션 메커니즘이 InvocationTargetException으로 감싸서 다시 던진다.<br>그래서 이 프로그램은 InvocationTargetException에 대해 catch절을 구성해 원래 예외에 담긴 정보를 출력한다.</li><li><strong>두번째 catch</strong>: 두번째 catch블럭은 잘못 사용해서 발생한 예외를 처리</li></ul><h1 id="매개변수-하나짜리-애너테이션-타입선언">매개변수 하나짜리 애너테이션 타입선언</h1><p>특정 예외를 던져야만 성공하는 테스트도 있을 것이다.<br>특정 예외가 발생했을 때 성공하는 테스트를 지원하도록 해보자.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 명시한 예외를 던져야만, 성공하는 테스트케이스 애너테이션</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTest&#123;</span><br><span class="line">    <span class="comment">//한정적 와일드카드를 통해 Throwable을 상속한 모든 타입을 지정</span></span><br><span class="line">    Class&lt;? extends Throwable&gt; values(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="예제-프로그램">예제 프로그램</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionTest</span>(ArithmeticException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        i = i / i; <span class="comment">//divide by zero. ArithmeticException 예외를 발생시킴 -&gt; 성공</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ExceptionTest</span>(ArithmeticException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> i = a[<span class="number">1</span>]; <span class="comment">//IndexOutOfBoundsException 발생 -&gt; ArithmeticException가 아니므로 실패</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ExceptionTest</span>(ArithmeticException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 아무 Exception도 발생하지 않음 -&gt; 실패</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="매개변수-하나짜리-애너테이션-processor">매개변수 하나짜리 애너테이션 processor</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(m.isAnnotaionPresent(ExceptionTest.class)) &#123;</span><br><span class="line">    test++;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m.invoke(<span class="keyword">null</span>);</span><br><span class="line">        System.out.printf(<span class="string">"테스트 %s 실패: 예외를 던지지 않음%n"</span>, m);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException wrappedExc) &#123;</span><br><span class="line">        Throwable exc = wrappedExc.getCause();</span><br><span class="line">        Class&lt;? extends Throwable&gt; excType = m.getAnnotation(ExceptionTest.class).value();</span><br><span class="line">        <span class="keyword">if</span>(excType.isInstance(exc)) &#123;</span><br><span class="line">            passed++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"테스트 %s 실패: 기대한 예외 %s, 발생한 예외 %s%n"</span>, m, excType.getName(), exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"잘못 사용한 @ExceptionTest: "</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 @Test와의 차이는 애너테이션의 매개변수를 추출하여 테스트 메서드가 올바른 메서드를 던졌는지 확인하는데 사용한다.<br>m.getAnnotation(ExceptionTest.class).value()를 실행할 때 ArithmeticException.class가 리턴된다.</p><h1 id="배열-매개변수를-받는-애너테이션-타입선언">배열 매개변수를 받는 애너테이션 타입선언</h1><p>Exception이 발생하는 종류를 묶어서 처리하고 싶을 때도 있다.<br>@ExceptionTest에서 배열형태로 Exception클래스를 받을 수 있도록 배열로 선언하였다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 명시한 예외를 던져야만, 성공하는 테스트케이스 애너테이션</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTest&#123;</span><br><span class="line">    <span class="comment">//한정적 와일드카드를 통해 Throwable을 상속한 모든 타입을 지정</span></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] values(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="예제-프로그램">예제 프로그램</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionTest</span>(&#123;IndexOutOfBoundsException.class,</span><br><span class="line">                    NullPointerException.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//자바 명세에 따르면, 다음 메서드는 IndexOutOfBoundsException이나,</span></span><br><span class="line">        <span class="comment">//NullPointerException을 던질 수 있다.</span></span><br><span class="line">        <span class="comment">//예외 발생 시 성공</span></span><br><span class="line">        list.addAll(<span class="number">5</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="배열-매개변수를-받는-애너테이션-processor">배열 매개변수를 받는 애너테이션 processor</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(m.isAnnotaionPresent(ExceptionTest.class)) &#123;</span><br><span class="line">    test++;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m.invoke(<span class="keyword">null</span>);</span><br><span class="line">        System.out.printf(<span class="string">"테스트 %s 실패: 예외를 던지지 않음%n"</span>, m);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException wrappedExc) &#123;</span><br><span class="line">        Throwable exc = wrappedExc.getCause();</span><br><span class="line">        Class&lt;? extends Throwable&gt;[] excTypes = m.getAnnotation(ExceptionTest.class).value();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> oldPassed = passed;</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;? extends Throwable&gt; excType : excTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span>(excType.isInstance(exc)) &#123;</span><br><span class="line">            passed++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(passed == oldPassed) &#123;</span><br><span class="line">            System.out.println(<span class="string">"테스트 %s 실패: %s %n"</span>, m, exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"잘못 사용한 @ExceptionTest: "</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드 중 변경되는 부분은  Class&lt;? extends Throwable&gt;[] excTypes을 배열형태로 받아,<br>이미 지정한 Exception 클래스 중에 맞는 클래스가 있는지 확인하는 코드가 변경되었다.</p><h1 id="반복-가능-애너테이션-repeatable">반복 가능 애너테이션 @Repeatable</h1><p>자바8에서는 여러개의 값을 받는 애너테이션을 다른 방식으로도 만들 수 있다.<br>배열 방식의 매개변수를 사용하는 대신 애너테이션에 @Repeatable 메타애너테이션을 다는 방식이다.<br>@Repeatable 애너테이션은 하나의 메서드에 여러개의 애너테이션을 지정할 수 있다.</p><ol><li>@Repeatable을 단 애너테이션을 반환하는 <strong>컨테이너 애너테이션</strong>을 하나 더 정의한다.</li><li>@Repeatable에 이 컨터이너 애너테이션의 class 객체를 매개변수로 전달해야 한다.</li><li>컨테이너 애너테이션은 내부 애너테이션 타입의 배열을 반환하는 value 메서드를 정의한다.</li><li>컨터이너 애너테이션에는 @Retention과 @Target을 적절히 명시한다.<br>(그렇지 않으면 컴파일되지 않는다.)</li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Repeatable</span>(ExceptionTestContainer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTest &#123;</span><br><span class="line">    Class&lt;? extends Throwable&gt; value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTestContainer &#123;</span><br><span class="line">    ExceptionTest[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="예제-프로그램-반복-가능-애너테이션을-적용한-예">예제 프로그램 - 반복 가능 애너테이션을 적용한 예</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionTest</span>(IndexOutOfBoundsException.class)</span><br><span class="line"><span class="meta">@ExceptionTest</span>(NullPointerException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>반복 가능 애너테이션은 처리할 때 주의를 요한다.반복 가능 애너테이션을 여러개 달면, 하나만 달았을 때와 구분하기 위해 해당 <strong>컨테이너</strong> 애너테이션 타입이 적용 된다.</p><ul><li>getAnnotationByType 메서드는 이 둘을 구분하지 않아 @ExceptionTest와 @ExceptionTestContainer를 모두 가져온다.</li><li>isAnnotationPresent는 둘을 구분한다.<ul><li>만약 @ExceptionTest를 여러번 단 다음, isAnnotationPresent로 ExceptionTest를 검사하면 false가 나온다.<br>(@ExceptionTestContainer로 인식하기 때문)</li><li>반대로 @ExceptionTest를 한번 만 단 다음, isAnnotationPresent로 ExceptionTestContainer를 검사하면 false가 나온다.(@ExceptionTest가 적용되었기 때문)</li></ul></li></ul><h2 id="반복-가능-애너테이션-processor">반복 가능 애너테이션 processor</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        m.invoke(<span class="keyword">null</span>);</span><br><span class="line">        System.out.printf(<span class="string">"테스트 %s 실패: 예외를 던지지 않음%n"</span>, m);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException wrappedExc) &#123;</span><br><span class="line">        Throwable exc = wrappedExc.getCause();</span><br><span class="line">        <span class="keyword">int</span> oldPassed = passed;</span><br><span class="line">    </span><br><span class="line">        ExceptionTest[] excTests = m.getAnnotationByType(ExceptionTest.class);</span><br><span class="line">        <span class="keyword">for</span>(ExceptionTest excType : excTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span>(excType.isInstance(exc)) &#123;</span><br><span class="line">            passed++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(passed == oldPassed) &#123;</span><br><span class="line">            System.out.println(<span class="string">"테스트 %s 실패: %s %n"</span>, m, exc);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>반복 가능 애너테이션을 사용한 경우 getAnnotationByType를 사용해 애너테이션 정보를 가져오는 것이 좋다.</p><h1 id="요약">요약</h1><ul><li><p>애너테이션이 명명패턴을 이용할 때 보다 확실히 낫다.</p></li><li><p>애너테이션으로 할 수 있는 일을 명명 패턴으로 처리할 이유는 없다.</p></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 39. 명명 패턴보다 애너테이션을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item39/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item38/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item38/</guid>
      <pubDate>Mon, 04 Feb 2019 09:54:37 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;타입 안전 열거 패턴은 확장이 가능하나, 열거 타입은 확장을 할 수 없다&lt;br&gt;
다시 말해 타입 안전 열거 패턴은 값을 그대로 가져온 다음 값을 더 추가하여 다른 목적으로 쓸 수 있지만,&lt;br&gt;
열거 타입은 그
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>타입 안전 열거 패턴은 확장이 가능하나, 열거 타입은 확장을 할 수 없다<br>다시 말해 타입 안전 열거 패턴은 값을 그대로 가져온 다음 값을 더 추가하여 다른 목적으로 쓸 수 있지만,<br>열거 타입은 그럴 수 없다.</p><p>하지만 열거타입도 확장할 수 있는 방법이 한 가지 존재한다.<br>기본적인 아이디어는 열거 타입이 인터페이스를 구현할 수 있다는 사실을 이용하는 것이다.</p><h1 id="인터페이스를-이용한-확장-가능-열거-타입">인터페이스를 이용한 확장 가능 열거 타입</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> BasicOperation implements Operation &#123;</span><br><span class="line"></span><br><span class="line">    PLUS(<span class="string">"+"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(<span class="string">"-"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(<span class="string">"*"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x * y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(<span class="string">"/"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x / y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line"></span><br><span class="line">    BasicOperation(String symbol) &#123;</span><br><span class="line">        <span class="keyword">this</span>.symbol = symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>열거 타입인 BasicOperation은 확장할 수 없지만 인터페이스인 Operation은 확장할 수 있고, 이 인터페이스를 연산의 타입으로 사용하면 된다.</p><h2 id="다른-열거-타입-추가">다른 열거 타입 추가</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExtendedOperation implements Operation &#123;</span><br><span class="line"></span><br><span class="line">    EXP(<span class="string">"^"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.pow(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    REMAINDER(<span class="string">"%"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x % y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line"></span><br><span class="line">    ExtendedOperation(String symbol) &#123;</span><br><span class="line">        <span class="keyword">this</span>.symbol = symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Operation 인터페이스를 구현하면 다른 열거 타입에서도 인터페이스를 구현하여 기능을 확장할 수 있다.</p><h1 id="열거-타입-확인">열거 타입 확인</h1><h2 id="enum타입을-넘겨-순회하기">Enum타입을 넘겨 순회하기</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">double</span> y = <span class="number">2</span>;</span><br><span class="line">        test(ExtendedOperation.class, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt; &amp; Operation&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Class&lt;T&gt; opEnumType, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Operation op : opEnumType.getEnumConstants()) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%f %s %f = %f%n"</span>, x, op, y, op.apply(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>&lt;T extends Enum&lt;T&gt; &amp; Operation&gt; : 타입이 Enum타입이면서, Operation을 구현하는 클래스</li></ul><h2 id="collectionlt-extends-operationgt-넘겨-순회하기">Collection&lt;? extends Operation&gt; 넘겨 순회하기</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">double</span> y = <span class="number">2</span>;</span><br><span class="line">        test2(Arrays.asList(ExtendedOperation.values()), x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Collection&lt;? extends Operation&gt; opSet, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Operation op : opSet) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%f %s %f = %f%n"</span>, x, op, y, op.apply(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>열거 타입의 리스트를 넘겨 &lt;? extends Operation&gt;인 한정적 와일드 카드 타입으로 지정</li></ul><h1 id="요약">요약</h1><ul><li>확장할 수 있는 열거 타입이 필요한 경우 인터페이스를 정의하여 구현하자</li><li>열거 타입끼리는 상속이 되지 않는다.</li><li>여러 열거 타입 간 공유하는 기능이 있으면, 클래스나 도우미 메서드로 분리하자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item38/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 37. Ordinal 인덱싱 대신 EnumMap을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item37/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item37/</guid>
      <pubDate>Mon, 04 Feb 2019 08:33:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;ordinal을-배열-인덱스로-사용해선-안된다&quot;&gt;ordinal()을 배열 인덱스로 사용해선 안된다.&lt;/h1&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="ordinal을-배열-인덱스로-사용해선-안된다">ordinal()을 배열 인덱스로 사용해선 안된다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Lifecycle &#123; ANNUAL, PERENNIAL, BIENNIAL &#125;</span><br><span class="line">    <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">final</span> Lifecycle lifeCycle;</span><br><span class="line">    </span><br><span class="line">    Plant(String name, Lifecycle lifeCycle) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.lifeCycle = lifeCycle;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Plant&gt;[] plantsByLifeCycle = (Set&lt;Plant&gt;[]) <span class="keyword">new</span> Set[Plant.LifeCycle.values().length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; plantsByLifeCycle.length ; i++) &#123;</span><br><span class="line">    plantsByLifeCycle[i] = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Plant p : garden) &#123;</span><br><span class="line">    plantsByLifeCycle[p.lifeCycle.ordinal()].add(p); <span class="comment">//이런 코드는 제발 쓰지 말자</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과 출력</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plantsByLifeCycle.length; i++) &#123;</span><br><span class="line">    System.out.printf(<span class="string">"%s: %s%n"</span>, Plant.LifeCycle.values()[i], plantsByLifeCycle[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>문제점</strong></p><ul><li><code>Set&lt;Plant&gt;[] plantsByLifeCycle = (Set&lt;Plant&gt;[]) new Set[Plant.LifeCycle.values().length]</code><br>배열은 제네릭과 호환되지 않는다. (비검사 형변환이 수행, 컴파일이 안된다.)</li><li>ordinal()은 상수 선언 순서에 따라 변한다.</li><li>잘못된 값을 사용하면 이상한 동작을 유발한다.</li></ul><h1 id="enummap을-사용해-매핑">EnumMap을 사용해 매핑</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Plant.LifeCycle, Set&lt;Plant&gt;&gt; plantsByLifeCycle = <span class="keyword">new</span> EnumMap&lt;&gt;(Plant.LifeCycle.class);</span><br><span class="line"><span class="keyword">for</span> (Plant.LifeCycle lc : Plant.LifeCycle.values()) &#123;</span><br><span class="line">    plantsByLifeCycle.put(lc, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Plant p : garden) &#123;</span><br><span class="line">    plantsByLifeCycle.get(p.lifeCycle).add(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>더 간단명료하게 로직이 변환되었다.</li><li>맵의 키인 열거 타입이 그 자체로 출력용 문자열을 제공하니 출력결과에 별도의 formatting이 필요없다.</li><li>EnumMap의 성능이 ordinal을 쓴 배열과 같은 이유는 EnumMap 내부에서 ordinal을 사용한 배열을 사용하기 때문이다.</li><li>개발자가 직접 제어하지 않고 Map을 사용하여, 타입안정성을 얻을 뿐더러 성능상의 이점까지 그대로 가져간다.</li></ul><h1 id="stream을-이용한-코드">Stream을 이용한 코드</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap을 이용한 데이터와 열거타입 매핑</span></span><br><span class="line">Arrays.stream(garden)</span><br><span class="line">      .collect(groupingBy(p -&gt; p.lifeCycle))</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EnumMap을 이용해 데이터와 열거타입 매핑</span></span><br><span class="line">Arrays.stream(garden)</span><br><span class="line">      .collect(groupingBy(p -&gt; p.lifeCycle, () -&gt; <span class="keyword">new</span> EnumMap&lt;&gt;(LifeCycle.class),</span><br><span class="line">                         toSet()));</span><br></pre></td></tr></table></figure></p><ul><li>두 방식의 차이<ul><li>HashMap을 이용한 방식에는 garden에 있는 키만 만든다.</li><li>EnumMap을 이용한 방식에는 garden에 데이터가 없어도 모든 키가 다 만들어 진다.</li></ul></li></ul><h1 id="추가-예제">추가 예제</h1><h2 id="ordinal을-배열의-인덱스로-사용한-예">ordinal()을 배열의 인덱스로 사용한 예</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Phase &#123;</span><br><span class="line">    SOLID, LIQUID, GAS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Transition &#123;</span><br><span class="line">        MELT, FREEZE, BOIL, CONDENSE, SUBLIME, DEPOSIT;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 행은 from의 ordinal을, 열은 to의 ordinal을 인덱스로 사용</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Transition[][] TRANSITIONS = &#123;</span><br><span class="line">            &#123; <span class="keyword">null</span>, MELT, SUBLIME &#125;,</span><br><span class="line">            &#123; FREEZE, <span class="keyword">null</span>, BOIL &#125;,</span><br><span class="line">            &#123; DEPOSIT, CONDENSE, <span class="keyword">null</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 한 상태에서 다른 상태로의 전이를 반환한다.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transition <span class="title">from</span><span class="params">(Phase from, Phase to)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> TRANSITIONS[from.ordinal()][to.ordinal()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 예제는 결국 SOLID, LIQUID, GAS의 상태 변화(from~to)에 대한 배열로 맵을 만든 것이다.<br>이렇게 되면 Phase가 추가 될 때마다 배열을 수정해 줘야 하는 불상사가 발생한다.</p><h2 id="enummap을-이용">EnumMap을 이용</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Phase &#123;</span><br><span class="line"></span><br><span class="line">    SOLID, LIQUID, GAS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Transition &#123;</span><br><span class="line">        MELT(SOLID, LIQUID),</span><br><span class="line">        FREEZE(LIQUID, SOLID),</span><br><span class="line">        BOIL(LIQUID, GAS),</span><br><span class="line">        CONDENSE(GAS, SOLID),</span><br><span class="line">        SUBLIME(SOLID, GAS),</span><br><span class="line">        DEPOSIT(GAS, SOLID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phase from;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phase to;</span><br><span class="line"></span><br><span class="line">        Transition(Phase from, Phase to) &#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt; m = Stream.of(values())</span><br><span class="line">                .collect(groupingBy(t -&gt; t.from, () -&gt; <span class="keyword">new</span> EnumMap&lt;&gt;(Phase.class),</span><br><span class="line">                        toMap(t -&gt; t.to, <span class="comment">//key-mapper</span></span><br><span class="line">                                t -&gt; t,  <span class="comment">//value-mapper</span></span><br><span class="line">                                (x, y) -&gt; y, <span class="comment">//merge-function</span></span><br><span class="line">                                () -&gt; <span class="keyword">new</span> EnumMap&lt;&gt;(Phase.class))));</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transition <span class="title">from</span> <span class="params">(Phase from, Phase to)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.get(from).get(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>EnumMap을 사용하여 간단하게 바꾼 모습이다.<br>Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt;을 초기화하는 부분이 복잡하다.</p><ol><li>일단 from으로 grouping 하여 EnumMap을 하나 생성</li><li>toMap으로 하위 Map을 생성</li><li>첫 번째 인자는 Map의 key를 설정하는 Function이다. - Phase to로 선언</li><li>두 번째 인자는 Map의 value를 설정하는 Function이다. - 자기 자신을 참조</li><li>세 번째 인자는 merge-function이다. - 얘는 별 의미없다.</li><li>네 번째 인자는 EnumMap으로 내부 Map을 선언한다.</li></ol><p>따라서 from 메서드에서 Phase별 from~to에 대해 Map -&gt; Map에 접근하여 Transition을 리턴 할 수 있다.</p><h2 id="새로운-phase가-추가되는-경우">새로운 Phase가 추가되는 경우</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Phase &#123;</span><br><span class="line"></span><br><span class="line">    SOLID, LIQUID, GAS, PLASMA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Transition &#123;</span><br><span class="line">        MELT(SOLID, LIQUID),</span><br><span class="line">        FREEZE(LIQUID, SOLID),</span><br><span class="line">        BOIL(LIQUID, GAS),</span><br><span class="line">        CONDENSE(GAS, SOLID),</span><br><span class="line">        SUBLIME(SOLID, GAS),</span><br><span class="line">        DEPOSIT(GAS, SOLID),</span><br><span class="line">        IONIZE(GAS, PLASMA),</span><br><span class="line">        DEIONIZE(PLASMA, GAS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phase from;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phase to;</span><br></pre></td></tr></table></figure></p><p>PLASMA라는 Phase가 추가되어도 Transition에 IONIZE, DEIONIZE를 간단히 추가하여 유연하게 대응이 가능하다.</p><h1 id="요약">요약</h1><ul><li>배열의 인덱스를 얻기 위해 ordinal을 쓰는 것은 일반적으로 좋지 않으니, 대신 EnumMap을 사용하라.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 37. ordinal 인덱싱 대신 EnumMap을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item37/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 36. 비트 필드 대신 EnumSet을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item36/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item36/</guid>
      <pubDate>Mon, 04 Feb 2019 07:27:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;열거한 값들이 주로 단독이 아닌 집합으로 사용 될 경우, 예전에는 각 상수에 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴을 사용해왔다.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>열거한 값들이 주로 단독이 아닌 집합으로 사용 될 경우, 예전에는 각 상수에 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴을 사용해왔다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_BOLD =          <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_ITALIC =        <span class="number">1</span> &lt;&lt; <span class="number">1</span>; <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_UNDERLINE =     <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_STRIKETHROUGH = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">//8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//매개 변수 styles는 0개 이상의 STYLE_ 상수를 비트별 OR 한 값이다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyle</span><span class="params">(<span class="keyword">int</span> styles)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>다음과 같은 식으로 비트별 OR을 사용해 여러 상수를 하나의 집합으로 모을 수 있으며,<br>이렇게 만들어진 집합을 비트 필드(bit field)라고 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.applyStyles(STYLE_BOLD | STYLE_ITALIC); <span class="comment">// 1 | 2 =&gt; 3</span></span><br></pre></td></tr></table></figure></p><p>하지만 비트 필드는 열거 상수의 단점을 그대로 지닌다.</p><ul><li>컴파일 되면 값이 새겨진다 (무슨 의미인지 모름)</li><li>비트 필드 값이 그대로 출력되면 단순한 정수 열거 상수보다 해석하기 어렵다.<br>(어떤 값이 OR연산되서 나온값인지 알기 어렵다.)</li><li>최대 몇 비트가 필요한지 API작성 시 미리 예측이 필요하다.</li></ul><h1 id="비트-필드-대신-enumset을-사용하라">비트 필드 대신 EnumSet을 사용하라</h1><ul><li>java.util 패키지의 EnumSet 클래스는 열거 타입 상수의 값으로 구성된 집합을 효과적으로 표현해준다.</li><li>Set 인터페이스를 완벽히 구현하며, 타입 안전하고 다른 Set 구현체와도 함께 사용할 수 있다.</li><li>EnumSet의 내부는 비트 벡터로 구현되었다.</li><li>원소가 64개 이하인 경우에는 EnumSet 전체를 long 변수 하나로 표현하여 비트 필드에 비견되는 성능을 보여준다.</li><li>removeAll과 retailAll과 같은 대량 작업은 비트를 효율적으로 처리 할 수 있는 산술 연산을 사용하였다.<br>(RegularEnumSet과 JumboEnumSet 클래스를 보면 비트연산을 많이 한다.)</li></ul><h1 id="비트필드를-대체하는-enumset-예제">비트필드를 대체하는 EnumSet 예제</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Style &#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 어떤 Set을 넘겨도 되나 EnumSet이 가장 좋다.</span></span><br><span class="line">    <span class="comment">// 이왕이면 Set Interface로 받는게 좋은 습관이다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(Set&lt;Style&gt; styles)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));</span><br></pre></td></tr></table></figure></p><h1 id="요약">요약</h1><ul><li>열거할 수 있는 타입을 한데 모아 집합 형태로 사용한다고 해도, 비트 필드를 사용할 이유는 없다.</li><li>EnumSet 클래스가 비트 필드 수준의 명료함과 성능을 제공한다.</li><li>EnumSet의 유일한 단점은 불변 객체를 생성할 수 없는 점이다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 36. 비트 필드 대신 EnumSet을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item36/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 35. Ordinal 메서드 대신 인스턴스 필드를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item35/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item35/</guid>
      <pubDate>Mon, 04 Feb 2019 07:06:55 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;대부분의 열거 타입 상수는 자연스럽게 하나의 정숫값에 대응된다.&lt;br&gt;
모든 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal이라는 메서드를 제공한다.&lt;/p&gt;
&lt;h1 id=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>대부분의 열거 타입 상수는 자연스럽게 하나의 정숫값에 대응된다.<br>모든 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal이라는 메서드를 제공한다.</p><h1 id="ordinal을-잘못-사용한-예">ordinal을 잘못 사용한 예</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</span><br><span class="line">    SOLO, DUET, TRIO, QUARTET, QUINTET,</span><br><span class="line">    SEXTET, SEPET, OCTET, NONET, DECTET;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ordinal() + <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>상수 선언 순서를 바꾸는 순간 numberOfMusicians 메서드의 기능을 상실하게 된다.<br>상수 순서를 바꾸는 순간 ordinal 값이 바뀌기 때문에 상수의 의미와 실제 뮤지션 숫자와 일치하지 않는다.</p><p>가령, 똑같이 8명인 복4중주(double quartet)은 OCTET이 있기 때문에 추가할 수 도 없다.</p><h1 id="인스턴스-필드를-사용하라">인스턴스 필드를 사용하라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</span><br><span class="line">    SOLO(<span class="number">1</span>), DUET(<span class="number">2</span>), TRIO(<span class="number">3</span>), QUARTET(<span class="number">4</span>), QUINTET(<span class="number">5</span>),</span><br><span class="line">    SEXTET(<span class="number">6</span>), SEPET(<span class="number">7</span>), OCTET(<span class="number">8</span>), DOUBLE_QUARTET(<span class="number">8</span>),</span><br><span class="line">    NONET(<span class="number">9</span>), DECTET(<span class="number">10</span>), TRIPLE_QUARTET(<span class="number">12</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numberOfMusicians;</span><br><span class="line">    Ensemble(<span class="keyword">int</span> numberOfMusicians) &#123;</span><br><span class="line">        <span class="keyword">this</span>.numberOfMusicians = numberOfMusicians;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.numberOfMusicians; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이처럼 인스턴스 필드를 두어 값을 초기화 하여 사용하는 방법으로 사용하는 것이 좋다.</p><h1 id="ordinal은-언제-사용하나">ordinal은 언제 사용하나?</h1><blockquote><p>The ordinal of this enumeration constant<br>(its position in the enum declaration, where the initial constant is assigned an ordinal of zero).<br>Most programmers will have no use for this field.<br>It is designed for use by sophisticated enum-based data structures,<br>such as {@link java.util.EnumSet} and {@link java.util.EnumMap}.</p></blockquote><p>ordinal은 enum타입의 상수 값이다. (상수의 위치값)<br>대부분의 프로그래머는 이 값이 필요는 없다.<br>이 값은 EnumSet이나 EnumMap 같은 열거 타입 기반의 범용 자료구조에 사용 될 목적으로 만들어졌다.<br><strong>결론: 사용하지 말자</strong></p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 35. ordinal 메서드 대신 인스턴스 필드를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item35/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 34. Int 상수 대신 열거 타입을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/03/effective-java-item34/</link>
      <guid>https://jaehun2841.github.io/2019/02/03/effective-java-item34/</guid>
      <pubDate>Sun, 03 Feb 2019 08:25:27 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바에서는 상수(Costants)라는 개념이 있다.&lt;br&gt;
변하지 않는 값을 공통적으로 선언하고 한 군데에서 관리하고자 사용한다.&lt;br&gt;
Java 1.5 버전부터 enum (enumeration) 타입을 제공하
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바에서는 상수(Costants)라는 개념이 있다.<br>변하지 않는 값을 공통적으로 선언하고 한 군데에서 관리하고자 사용한다.<br>Java 1.5 버전부터 enum (enumeration) 타입을 제공하였고, C/C++에서 처럼 단순한 정수값을 제공하는 수준을 넘어<br>완전한 형태의 클래스의 역할을 수행 하는 강력한 기능을 제공한다.</p><h1 id="정수-열거-패턴int-enum-pattern의-단점">정수 열거 패턴(int enum pattern)의 단점</h1><h2 id="타입-safe하지-않다">타입 safe하지 않다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_FUJI = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_PIPPIN = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_GRANNY_SMITH = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORANGE_NAVEL = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORANGE_TEMPLE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORANGE_BLOOD = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>정수 열거 패턴은 위와 같이 선언하고 사용된다.<br>자바는 정수 열거 패턴을 위한 별도의 namespace를 지원하지 않기 때문에 어쩔수 없이 접두어를 사용해서 이름 충돌을 방지한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPLE_FUJI == ORANGE_NAVEL;</span><br></pre></td></tr></table></figure></p><p>위에 대한 결과는 true가 되기 때문에 type safe 하지 않으며, 표현력도 좋지 않다.</p><h2 id="정수-열거-패턴을-사용한-프로그램은-깨지기-쉽다">정수 열거 패턴을 사용한 프로그램은 깨지기 쉽다.</h2><p>평범한 상수를 나열한 것뿐이라, 컴파일 하면 그 값이 클라이언트 파일에 그대로 새겨진다.<br>따라서 상수의 값이 바뀌면 클라리언트도 반드시 다시 컴파일 해야 한다.<br><code>다시 컴파일 하지 않은 클라이언트는 실행이 되더라도 엉뚱하게 동작할 수 있다.</code></p><p><img src="./constants-code.png" alt="constants-code"></p><p><img src="./compiled-constants-code.png" alt="compiled-constants-code"></p><p>compile 이후에는 상수에 대한 namespace정보가 없기 때문에 단순히 상수 값만 찍히게 된다.</p><h2 id="정수-상수는-문자열로-출력하기-까다롭다">정수 상수는 문자열로 출력하기 까다롭다.</h2><p>그 값을 출력하거나 디버거로 살펴보면 (의미가 아닌) 단지 숫자로만 보여서 썩 도움이 되지 않는다.<br>(APPLE_FUJI나, ORANGE_NAVEL 같은 의미를 출력하기 어렵다는 의미)<br>같은 정수 열거 그룹에 속한 모든 상수를 한 바퀴 순회하는 방법도 마땅치 않다.<br>(enum은 values()메서드를 통해 상수를 배열 형태로 제공한다.)</p><h2 id="문자열-열거-패턴은-더-나쁘다">문자열 열거 패턴은 더 나쁘다.</h2><p>상수의 의미를 출력할 수 있다는 점은 좋지만, 문자열 상수의 이름 대신 문자열 값을 그대로 하드코딩하게 만들기 때문이다.<br>하드코딩한 문자열에 오타가 있어도 컴파일러는 확인할 길이 없으니, 자연스럽게 런타임 버그가 생긴다.<br>문자열 비교에 따른 성능 저하 역시 당연한 결과다.</p><h1 id="java의-열거-타입">Java의 열거 타입</h1><p>자바의 열거(enum) 타입은 완전한 형태의 <code>클래스(class)</code> 이다.<br>Java에서는 Enum.java라는 abstract클래스를 Java 1.5 부터 제공하고 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the common base class of all Java language enumeration types.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * More information about enums, including descriptions of the</span></span><br><span class="line"><span class="comment"> * implicitly declared methods synthesized by the compiler, can be</span></span><br><span class="line"><span class="comment"> * found in section 8.9 of</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Note that when using an enumeration type as the type of a set</span></span><br><span class="line"><span class="comment"> * or as the type of the keys in a map, specialized and efficient</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> java.util.EnumSet set&#125; and &#123;<span class="doctag">@linkplain</span></span></span><br><span class="line"><span class="comment"> * java.util.EnumMap map&#125; implementations are available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; The enum type subclass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Josh Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Neal Gafter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Class#getEnumConstants()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.util.EnumSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.util.EnumMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>) <span class="comment">// No serialVersionUID needed due to</span></span><br><span class="line">                            <span class="comment">// special-casing of enum types.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure></p><p>C/C++와 같이 다른 언어에서처럼 단순히 정수값만 지원하는 것이 아니라, 하나의 클래스로써의 역할을 수행해 강력한 기능을 제공한다.</p><h2 id="열거enum-타입의-특징">열거(enum) 타입의 특징</h2><ul><li>열거 타입 자체는 클래스(class)이다.</li><li>상수 하나당 자신의 인스턴스를 하나씩 만들어(Singleton) public static final 필드로 공개한다.</li><li>열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로, 사실상 final이다.<br>(따라서 열거 타입 내 필드도 final이다.)</li></ul><h2 id="타입-safe하다">타입 safe하다.</h2><p>열거 타입은 타입 안전성을 제공한다.위의 APPLE과 ORANGE의 상수 형태를 enum으로 변경한 뒤 다시 테스트 해보자<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Apple &#123;FUJI, PIPPIN, GRANNY_SMITH&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Orange &#123;NAVEL, TEMPLE, BLOOD&#125;</span><br></pre></td></tr></table></figure></p><p><img src="./enum-test.png" alt="enum-test"></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(24, 33) java: incomparable types: com.study.effectivejavatest.item34.Apple and com.study.effectivejavatest.item34.Orange</span><br></pre></td></tr></table></figure></p><p>컴파일 시, 위와 같은 에러가 발생한다.<br>Apple.FUJI와 Orange.NAVEL은 비교를 할 수 없는 타입이라는 내용이다.<br>다른 열거 타입의 값끼리 == 연산자로 비교하려는 꼴이기 때문이다.</p><h2 id="각자의-namespace가-있다">각자의 namespace가 있다.</h2><p>열거타입은 각자의 namespace가 있어서 이름이 같은 상수도 평화롭게 공존한다.<br>열거 타입에 새로운 상수를 추가하거나, 순서를 바꿔도 다시 컴파일 하지 않아도 된다.<br>공개 되는 것이 오직 필드의 이름 뿐이라, 컴파일 시, 클라이언트의 코드에 정수 값이 각인되지 않기 때문이다.</p><p><img src="./compiled-constants-code2.png" alt="compiled-constants-code2"></p><h1 id="데이터와-메서드를-갖는-열거-타입">데이터와 메서드를 갖는 열거 타입</h1><p>열거 타입은 메서드와 필드를 추가 할 수 있다.<br>각 상수 별로 데이터를 가질 수 있고, enum에서 공통적으로 사용하는 메서드를 선언하거나 상수 별로 메서드를 재정의 할 수 있다.<br>단순하게는 상수 모음이지만, 실제로는 클래스이기 때문에 고차원의 추상 개념 하나를 완벽히 표현해낼 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Planet &#123;</span><br><span class="line">    MERCURY(<span class="number">3.302e+23</span>, <span class="number">2.439e6</span>),</span><br><span class="line">    VENUS(<span class="number">4.869e+24</span>, <span class="number">6.052e6</span>),</span><br><span class="line">    EARTH(<span class="number">5.975e+24</span>, <span class="number">6.378e6</span>),</span><br><span class="line">    MARS(<span class="number">6.419e+23</span>, <span class="number">3.393e6</span>),</span><br><span class="line">    JUPITER(<span class="number">1.899e+27</span>, <span class="number">7.149e7</span>),</span><br><span class="line">    SATURN(<span class="number">5.685e+26</span>, <span class="number">6.027e7</span>),</span><br><span class="line">    URANUS(<span class="number">8.683e+25</span>, <span class="number">2.556e7</span>),</span><br><span class="line">    NEPTUNE(<span class="number">1.024e+26</span>, <span class="number">2.447e7</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> mass;            <span class="comment">// 질량(단위: 킬로그램)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> radius;          <span class="comment">// 반지름(단위: 미터)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> surfaceGravity;  <span class="comment">// 표면중력(단위: m / s^2)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 중력상수 (단위: m^3 / kg s^2)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> G = <span class="number">6.67300E-11</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생성자</span></span><br><span class="line">    Planet(<span class="keyword">double</span> mass, <span class="keyword">double</span> radius) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mass = mass;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        <span class="keyword">this</span>.surfaceGravity = G * mass / (radius * radius);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">surfaceWeight</span><span class="params">(<span class="keyword">double</span> mass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mass * surfaceGravity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 Planet의 예시를 보면, 행성별 상수는 각각 질량과 반지름을 필드로 가지고 있다.<br>그리고 표면중력에 대한 값을 계산해 주는 surfaceWeight라는 메서드를 공통으로 사용하고 있다.</p><ul><li>열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.</li><li>열거 타입은 외부로의 생성자를 제공하지 않기 때문에 불변 객체이다.</li><li>모든 필드는 final이다.</li><li>필드를 public으로 선언해도 되지만, private로 선언 후 접근자 메서드를 제공하는 것이 좋다.</li></ul><h1 id="상수별-메서드-구현">상수별 메서드 구현</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">    PLUS, MINUS, TIMES, DIVIDE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같은 사칙 연산 열거타입이 있을 때, 사칙연산에 대한 로직을 열거 타입 내에 작성하고 싶을 때가 있다.<br>여러가지 방법을 통해 구현해 보도록 하겠다.</p><h2 id="switch-case을-이용한-구현">switch-case을 이용한 구현</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> PLUS: <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">case</span> MINUS: <span class="keyword">return</span> x - y;</span><br><span class="line">        <span class="keyword">case</span> TIMES: <span class="keyword">return</span> x * y;</span><br><span class="line">        <span class="keyword">case</span> DIVIDE: <span class="keyword">return</span> x / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"알 수 없는 연산: "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이런 경우에는 메서드 하나에 연산을 모아 볼 수 있는 장점은 있다.<br>하지만 상수가 추가 되는 경우, 실수로 case를 추가 하지 않으면, <code>알 수 없는 연산</code>이라는 예외가 발생하게 된다.</p><h2 id="abstract-method를-이용한-구현">abstract method를 이용한 구현</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">    PLUS&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    MINUS&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    TIMES&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x * y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    DIVIDE&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x / y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 선언하면 상수가 추가 될 때마다 apply 메서드를 재정의 해줘야 한다.</p><h2 id="funtional-interface를-이용한-구현">Funtional Interface를 이용한 구현</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">    PLUS((x, y) -&gt; x + y),</span><br><span class="line">    MINUS((x, y) -&gt; x - y),</span><br><span class="line">    TIMES((x, y) -&gt; x * y),</span><br><span class="line">    DIVIDE((x, y) -&gt; x / y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> BiFunction&lt;Double, Double, Double&gt; operationFuntion;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java 8에서 제공하는 BiFuntion 을 이용해 람다식을 이용하여 로직을 구현 할 수 있다.</p><h2 id="편한-계산식-출력">편한 계산식 출력</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = Double.parseDouble(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">double</span> y = Double.parseDouble(args[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Operation op : Operation.values()) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"%f %s %f = %f%n"</span>, x, op, y, op.apply(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.000000 + 4.000000 = 6.000000</span><br><span class="line">2.000000 - 4.000000 = -2.000000</span><br><span class="line">2.000000 * 4.000000 = 8.000000</span><br><span class="line">2.000000 / 4.000000 = 0.500000</span><br></pre></td></tr></table></figure></p><h1 id="전략적-열거-타입-패턴">전략적 열거 타입 패턴</h1><p>상수별 메서드 구현에는 열거 타입 상수끼리 코드를 공유하기 어렵다는 단점이 있다.<br>아래 예시는 요일별로 일당을 계산해 주는 열거타입 메서드이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> PayrollDay &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINS_PER_SHIFT = <span class="number">8</span> * <span class="number">60</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> basePay = minutesWorked * payRate;</span><br><span class="line">        <span class="keyword">int</span> overtimePay;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> SATURDAY:</span><br><span class="line">            <span class="keyword">case</span> SUNDAY:</span><br><span class="line">                overtimePay = basePay / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                overtimePay = minutesWorked &lt;= MINS_PER_SHIFT ? <span class="number">0</span> : </span><br><span class="line">                (minutesWorked - MINS_PER_SHIFT) * payRate / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> basePay + overtimePay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>간결하지만, 관리 관점에서는 위험한 코드이다.<br>공휴일과 같은 새로운 값을 열거타입에 추가하려면 그 값을 처리하는 case문을 잊지말고 추가해 줘야 한다.<br>상수별 메서드 구현으로 급여를 정확히 계산하는 방법은 두 가지다.</p><ol><li>잔업수당을 계산하는 코드를 모든 상수에 중복해서 넣는다.</li><li>평일용/주말용으로 나눠 각각 도우미 메서드를 생성한다음 각 상수가 자신에게 필요한 메서드를 적절히 호출한다.</li></ol><p>1번으로 로직을 구성할 경우 case 구문을 사용할 때와 동일한 문제가 발생한다.<br>가장 깔끔한 방법은 새로운 상수를 추가할 때, 잔업 수당에 대한 <code>전략</code>을 선택하게 하는 방법이다.</p><h2 id="잔업-수당-전략-선택하기">잔업 수당 전략 선택하기</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> PayrollDay &#123;</span><br><span class="line">    MONDAY(WEEKDAY),</span><br><span class="line">    TUESDAY(WEEKDAY),</span><br><span class="line">    WEDNESDAY(WEEKDAY),</span><br><span class="line">    THURSDAY(WEEKDAY),</span><br><span class="line">    FRIDAY(WEEKDAY),</span><br><span class="line">    SATURDAY(WEEKEND),</span><br><span class="line">    SUNDAY(WEEKEND);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayType payType;</span><br><span class="line">    </span><br><span class="line">    PayrollDay(PayType payType) &#123;</span><br><span class="line">        <span class="keyword">this</span>.payType = payType;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> payType.pay(minutesWorked, payRate);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> PayType &#123;</span><br><span class="line">        WEEKDAY &#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> minutesWorked &lt;= MINS_PER_SHIFT ? <span class="number">0</span> : (minutesWorked - MINS_PER_SHIFT) * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        WEEKEND &#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> minutesWorked * payRate / <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span></span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINS_PER_SHIFT = <span class="number">8</span> * <span class="number">60</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> basePay = minutesWorked &amp; payRate;</span><br><span class="line">            <span class="keyword">return</span> basePay + overtimePay(minutesWorked, payRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 코드를 변경하니 깔끔하게 되었다.switch문은 열거 타입의 상수별 동작을 구현하는데 적합하지 않다.<br>하지만 기존의 열거 타입의 상수별 동작을 혼합해 넣을 때에는 switch문이 좋은 선택이 될 수 있다.<br>(최소한으로 코드를 변경하기 때문)</p><h1 id="요약">요약</h1><ul><li><p>필요한 원소를 컴파일타입에 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자</p></li><li><p>int 상수 대신 열거 타입으로 정의하라</p></li><li><p>각 상수와 특정 데이터를 연결 짓거나, 상수마다 다른 action이 필요한 경우 열거 타입이 효과적이다.</p></li><li><p>switch문으로 분기하여 로직을 구성하기 보다는 전략 열거타입 패턴을 사용하여 로직을 구현하라.</p></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 34. int 상수 대신 열거 타입을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/03/effective-java-item34/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라</title>
      <link>https://jaehun2841.github.io/2019/01/28/effective-java-item32/</link>
      <guid>https://jaehun2841.github.io/2019/01/28/effective-java-item32/</guid>
      <pubDate>Mon, 28 Jan 2019 10:27:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;가변인수(varargs) 메서드와 제네릭은 Java 5버전에 함께 추가되었다.&lt;br&gt;
서로 잘 어우러지리라 생각하겠지만, 그렇지 않다. 가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>가변인수(varargs) 메서드와 제네릭은 Java 5버전에 함께 추가되었다.<br>서로 잘 어우러지리라 생각하겠지만, 그렇지 않다. 가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는데, 구현방식에 헛점이 있다.<br>가변인수 메서드를 호출하면, 가변인수를 담기 위한 배열이 자동으로 하나 만들어진다.<br>그 결과 varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생한다.</p><p>실제화 불가 타입은 런타임에는 컴파일타임보다 타입관련 정보를 적게 담고 있다<code>(소거)</code></p><h1 id="제네릭과-varargs를-혼용하면-타입-안정성이-깨진다">제네릭과 varargs를 혼용하면 타입 안정성이 깨진다.</h1><p>매개변수화 타입(Parameterize Type (예 List&lt;String&gt;))의 변수가 타입이 다른 객체를 참조하면 <strong>힙 오염</strong>이 발생한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dangerous</span><span class="params">(List&lt;String&gt;... stringLists)</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; intList = List.of(<span class="number">42</span>);</span><br><span class="line">  <span class="comment">//varargs는 내부적으로 배열이고</span></span><br><span class="line">  <span class="comment">//배열은 공변이기 때문에 List&lt;String&gt;타입은 Object의 하위클래스로 인식되어</span></span><br><span class="line">  <span class="comment">//Object[]에 참조 될 수 있다.</span></span><br><span class="line">  Object[] objects = stringLists;</span><br><span class="line">  Object[<span class="number">0</span>] = intList; <span class="comment">//힙 오염 발생</span></span><br><span class="line">  String s = stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// ClassCastException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드를 한줄한줄 분석해보자</p><ol><li>List&lt;String&gt; varargs형태의 파라미터를 받는 메서드이다.</li><li>List&lt;Integer&gt; 제네릭타입 객체를 생성하여 42라는 값을 추가하였다.</li><li>varargs는 내부적으로 배열이고, 배열은 공변이기 때문에 List&lt;String&gt;[] -&gt; Object[]에 참조될 수 있다.</li><li>Object[0] = intList 초기화<br>(내부적으로는 List&lt;String&gt; 타입이지만, 런타임에는 제네릭 타입이 소거되므로 같은 List로만 인식되어 할당이 가능하다. <strong>힙 오염 발생</strong>)</li><li>stringList[0]을 하면 List가 나오고 List의 0번째 인덱스 위치의 객체를 호출해 눈에 보이지 않는 String으로 형변환한다.<br>-&gt; 여기서 ClassCastException이 발생</li></ol><p>이처럼 타입안정성이 깨지기 때문에 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다.<br>(실제로 실무에서는 저런 경우는 거의 없다. 웬만하면 varargs 형태로 받아와서 그대로 사용하기 때문)</p><h1 id="safevarargs">@SafeVarargs</h1><p>자바 7 전에는 제네릭 가변인수 메서드의 작성자가 호출자 쪽에서 발생하는 경고에 대해서 해줄 수 있는 일이 없었다.<br>사용자는 이 경고를 그냥 무시하거나, 사용하는 메서드에서 @SupprssWarning(&quot;unchecked&quot;) annotation을 달아 경고를 숨겨야 했다.<br>자바 7부터 @SafeVarargs annotation이 추가되어 제네릭 가변인수 메서드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있게 되었다.</p><p>단, @SafeVarargs annotation은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치이므로<br>반드시 메서드가 타입 안전한 경우에만 이 annotation을 붙이는 것이 좋다.</p><h2 id="어떤게-타입-안전할까">어떤게 타입 안전할까?</h2><ul><li>가변인수 메서드를 호출하면 varargs 매개변수를 담는 제네릭 배열이 만들어 진다.</li><li>메서드 내에서 이 배열에 아무것도 저장하지 않고, 배열의 참조가 밖으로 노출되지 않는다면 타입 안전하다.</li><li>순수하게 메서드의 생산자 역할만 충실히 하면 메서드는 안전하다.</li></ul><h2 id="자신의-제네릭-매개변수-배열의-참조를-노출하는-것은-위험하다">자신의 제네릭 매개변수 배열의 참조를 노출하는 것은 위험하다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T[] toArray(T... args) &#123;</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T[] pickTwo(T a, T b, T c) &#123;</span><br><span class="line">  <span class="keyword">switch</span>(ThreadLocalRandom.current().nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> toArray(a, b);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> toArray(b, c);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> toArray(c, a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> AssertiionError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  String[] attributes = pickTwo(<span class="string">"좋은"</span>, <span class="string">"빠른"</span>, <span class="string">"저렴한"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>아무 문제가 없는 메서드이니 별다른 문제없이 컴파일 된다.<br>하지만 실행하면 ClassCastException을 던진다.<br>어디서 발생하는 에러일까?</p><p>정답은 바로 String[] attributes = pickTwo(); 메서드에서 보이지 않는 형변환 시 발생한다.</p><p>실제로는 아래와 같다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] attributes = (String[]) pickTwo(<span class="string">"좋은"</span>, <span class="string">"빠른"</span>, <span class="string">"저렴한"</span>);</span><br></pre></td></tr></table></figure></p><p>Object[]는 String[]의 <code>하위타입</code>이 아니므로 형변환할 수 없다. (다운캐스팅 불가)<br>이 예시는 <strong>제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다.</strong> 를 다시금 알려주는 예제이다.</p><p>단 예외가 두 가지 있다.</p><ul><li>@SafeVarargs로 선언된 타입 안전성이 보장된 또 다른 varargs 메서드에 넘기는 것은 안전하다.</li><li>배열 내용의 일부 함수를 호출만 하는 (varargs를 받지않는) 일반 메서드에 넘기는 것도 안전하다.</li></ul><h1 id="제네릭-varargs-매개변수를-안전하게-사용하는-메서드">제네릭 varargs 매개변수를 안전하게 사용하는 메서드</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">flatten</span><span class="params">(List&lt;? extends T&gt;... lists)</span> </span>&#123;</span><br><span class="line">  List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span>(List&lt;? extends T&gt; list : lists) &#123;</span><br><span class="line">    result.addAll(list);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 메서드는 안전하다.<br>varargs 배열을 직접 노출 시키지 않고, T타입의 제네릭 타입을 사용하였기 때문에 ClassCastException 또한 발생할 일이 없다.<br>안전한 varargs 메서드에는 @SafeVarargs annotation을 달아서 컴파일러 경고를 없애는 것이 좋다.</p><h1 id="제네릭-varargs-매개변수를-list로-대체하라">제네릭 varargs 매개변수를 List로 대체하라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">flatten</span><span class="params">(List&lt;List&lt;? extends T&gt;&gt; lists)</span> </span>&#123;</span><br><span class="line">  List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (List&lt;? extends T&gt; list : lists) &#123;</span><br><span class="line">    result.addAll(list);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 방식의 장점은 이 메서드의 타입 안전성을 검증할 수 있다는 점이다.<br>@SafeVarargs를 달지 않아도 되며 실수로 안전하다고 판단할 걱정도 없다.<br>단점은 클라이언트 코드가 살짝 지저분해지고, 속도가 약간 느려질 수 있다는 점이다.</p><h1 id="정리">정리</h1><ul><li>varargs 매개변수는 단순히 파라미터를 받아와 메서드의 생산자(T 타입의 객체를 제공하는 용도)로만 사용하자</li><li>varargs는 read-only라고 생각하고, 아무런 데이터를 저장하지 말자</li><li>varargs 배열을 외부에 리턴하거나 노출하지 말자.<br>웬만하면 다시 컬렉션(List)에 담아 리턴하는 안전한 방식을 취하자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/28/effective-java-item32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 31. 한정적 와일드 카드(Bounded Wildcard Type)를 사용해 API 유연성을 높여라</title>
      <link>https://jaehun2841.github.io/2019/01/26/effective-java-item31/</link>
      <guid>https://jaehun2841.github.io/2019/01/26/effective-java-item31/</guid>
      <pubDate>Sat, 26 Jan 2019 12:16:50 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Generic에서 매개변수화 타입(Parameterize Type - List&amp;lt;String&amp;gt;)는 불공변이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;공변 vs 불공변
Java에서 배열은 공변(varian
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Generic에서 매개변수화 타입(Parameterize Type - List&lt;String&gt;)는 불공변이다.</p><blockquote><p>공변 vs 불공변Java에서 배열은 공변(variant), Generic은 불공변(invariant)이라 한다.<br>배열의 경우 Object[]과 String[] 간에는 부모-자식 클래스 관계가 성립한다. 이를 공변이라한다.<br>하지만 Generic에서는 List&lt;Object&gt;와 List&lt;String&gt;은 부모-자식 관계가 성립하지 않는다 이를 불공변이라한다.</p></blockquote><p>즉, List&lt;String&gt;은 String타입의 문자열만 넣을 수 있지만, List&lt;Object&gt;는 문자열이건, 숫자건 다 넣을 수 있으므로, 부모클래스에서 가능한 일은 자식클래스에서도 가능해야 한다는 <strong>리스코프 치환원칙</strong>에 위배된다.</p><p>하지만 때로는 불공변 방식보다 유연한 무언가가 필요하다.</p><h1 id="생산자producer-와일드카드-적용">생산자(producer) 와일드카드 적용</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; integers = List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">numberStack.pushAll(integers);</span><br></pre></td></tr></table></figure></p><p>Integer는 Number의 하위타입이기 때문에 잘 동작할 것 같지만, 실제로는 컴파일 시에 오류가 발생한다.</p><p>Parameterize Type이 불공변이기 때문에 Iterator&lt;Number&gt;와 Iterator&lt;Integer&gt;는 부모-자식 관계가 아니다.<br>그렇기 때문에 addAll 메서드의 파라미터로 사용할 수 없는 것이다.</p><p>이런 경우 생산자(producer) 파라미터에 와일드카드 타입을 적용하여 유연하게 만들 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterator&lt;? extends E&gt; iterator)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (E e : iterator) &#123;</span><br><span class="line">    push(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>생산자(producer) 파라미터란, 파라미터로 제공되어 메서드 내에서 사용 될 객체를 공급해 주는 파라미터이다.</p><p><code>&lt;? extends E&gt;</code> 형태로 사용하는 경우 E 타입의 하위타입만 파라미터로 올 수 있게 제약을 거는 것이다.<br><code>모든 타입은 자기 자신의 하위타입이다!</code> 라는 규칙이 있으므로 자기 자신에 대한 타입도 들어올 수 있다.</p><h1 id="소비자consumer-와일드카드-적용">소비자(consumer) 와일드카드 적용</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;E&gt; dst)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!isEmpty()) &#123;</span><br><span class="line">    dst.add(pop());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Collection&lt;Object&gt; objects = List.of(<span class="number">1</span>, <span class="string">"String"</span>);</span><br><span class="line">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure></p><p>컴파일 하게되면 Collection&lt;Object&gt;는 Collection&lt;Number&gt;의 하위타입이 아니다라는 오류가 나온다.<br>이를 해결하기 위해서는 super를 이용해 와일드카드를 작성해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; dst)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!isEmpty()) &#123;</span><br><span class="line">    dst.add(pop());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>소비자(consumer) 파라미터란, 메서드에 제공되어 메서드 내에서 제공되는 객체를 자기 자신이 사용하는 파라미터를 의미한다.</p><h1 id="pecsproducer-extends-consumer-super">PECS(Producer-Extends, Consumer-Super)</h1><p>다음 공식을 외워 어떤 와일드 카드 타입을 쓸지 기억하자</p><ul><li>생산자(producer) - Generic 클래스 내에 타입 파라미터를 이용해 객체를 제공하는 것<ul><li>&lt;? extends E&gt;를 사용하여 유연성을 높일 수 있다.</li></ul></li><li>소비자(consumer) - Generic 클래스 내의 자원을 사용하는 객체를 파라미터로 전달하는 것<ul><li>&lt;? super E&gt;를 사용하여 유연성을 높일 수 있다.</li><li>Comparable, Comparator는 소비자로 사용된다.</li></ul></li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; integers = Set.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Set&lt;Double&gt; doubles = Set.of(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line">Set&lt;Number&gt; numbers = union(integers, doubles);</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</span><br><span class="line">  Set&lt;E&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  set.addAll(integers);</span><br><span class="line">  set.addAll(doubles);</span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 메서드가 만들어지면 타입이 맞지 않는다고 컴파일 오류가 나게 된다.<br>Set&lt;E&gt;은 불공변이기 때문에 Set&lt;Integer&gt;와 Set&lt;Double&gt;은 Set&lt;Number&gt;의 하위타입이 아니기 떄문이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2)</span> </span>&#123;</span><br><span class="line">  Set&lt;E&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  set.addAll(integers);</span><br><span class="line">  set.addAll(doubles);</span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 변경하면 컴파일 오류도 해결되고 잘 실행 된다.이렇게 공통 API를 작성할 때는 와일드 카드를 적절하게 쓰도록 하자.<br>클래스 사용자가 와일드카드 타입을 신경써야 한다면, 그 API에 문제가 있을 가능성이 크다.</p><h2 id="java7에서는">Java7에서는...</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);</span><br></pre></td></tr></table></figure></p><p>위와 같은 형태로 명시적으로 타입인수를 사용해야 한다.<br>타입추론능력이 부족하기 때문이다.</p><h1 id="심화-comparable">심화 - Comparable</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">E <span class="title">max</span><span class="params">(List&lt;E&gt; list)</span></span></span><br></pre></td></tr></table></figure></p><p>와일드카드를 통해 좀 더 다듬은 모습이다.<br><strong>주의: Comparable을 구현한 클래스만 파라미터로 올 수 있다</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function">E <span class="title">ma</span><span class="params">(List&lt;? extends E&gt; list)</span> </span>&#123;</span><br><span class="line">           list.sort(Comparator.reverseOrder());</span><br><span class="line">           <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><ul><li>일반적으로는 Comparable&lt;E&gt;보단 Comparable&lt;? super E&gt;를 사용하는게 낫다. (대부분 소비자로 사용)</li></ul><h1 id="심화2-와일드카드를-적절히-사용하라">심화2 - 와일드카드를 적절히 사용하라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure></p><p>리스트 내의 특정 인자들의 위치를 뒤바꿔주는 메서드이다.<br>어느 메서드가 더 좋을까?</p><p>기본적으로는 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하는 것이 좋다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드는 list.get하는 부분에서 컴파일 오류가 난다.비한정적 와일드카드를 사용하고 있기 때문에 list.set을 하는 경우에는 null밖에 넣을 수가 없다.<br>이런 경우 도우미 메서드를 따로 이용한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 경우에는 List&lt;E&gt;의 리턴타입이 항상 E인 것을 알기 때문에<br>런타임 시, 타입안정성을 보장 할 수 있고 set하는 경우에도 E 타입을 set할 것을 알기 때문에 컴파일 오류 없이 작동 한다.</p><h1 id="정리">정리</h1><p>조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다.<br>그러나 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해야 한다.<br>PECS 공식을 기억하여 생산자에는 extends, 소비자에는 super를 사용하자.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 31. 한정적 와일드 카드(bounded wildcard type)를 사용해 API 유연성을 높여라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/26/effective-java-item31/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 17. 변경 가능성을 최소화하라</title>
      <link>https://jaehun2841.github.io/2019/01/20/effective-java-item17/</link>
      <guid>https://jaehun2841.github.io/2019/01/20/effective-java-item17/</guid>
      <pubDate>Sun, 20 Jan 2019 08:53:58 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;불변-클래스immutable-class란&quot;&gt;불변 클래스(immutable class)란?&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다.&lt;/li&gt;
&lt;li&gt;불변 클래스의 인스턴스는 객체가 생성되는 시점에 초
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="불변-클래스immutable-class란">불변 클래스(immutable class)란?</h1><ul><li>인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다.</li><li>불변 클래스의 인스턴스는 객체가 생성되는 시점에 초기화되고 소멸이 될 때까지 값이 변경되지 않는다.</li><li>불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉽다.</li><li>값이 변경되지 않으니 오류가 발생할 일도 적고 안전하다.</li></ul><h1 id="불변-클래스를-만들기-위한-5가지-조건">불변 클래스를 만들기 위한 5가지 조건</h1><h2 id="객체의-상태를-변경하는-메서드변경자를-제공하지-않는다">객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.</h2><ul><li>쉽게 말해 setter나, 필드 정보를 변경하는 메서드를 제공하지 않는다.</li></ul><h2 id="클래스를-확장-할-수-없도록-한다">클래스를 확장 할 수 없도록 한다.</h2><ul><li>클래스를 final로 선언한다.</li><li>모든 생성자는 private으로 만들고 생성자 정적 팩터리 메서드를 제공한다.</li><li>정적 팩터리 메서드는 유연성을 제공한다.</li><li>다음 릴리즈에서 Boolean처럼 <code>캐싱</code>을 이용해 성능을 끌어올릴 수도 있다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class="line"><span class="meta">@AllArgsConstructor</span>(access = AccessLevel.PRIVATE, staticName=<span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="모든-필드를-final로-선언한다">모든 필드를 final로 선언한다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span>(access = AccessLevel.PRIVATE, staticName=<span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>필드에 대해 수정을 막겠다는 설계자의 의도를 보여준다. - final클래스는 생성자에서 딱 <code>1회 초기화</code> 할 수 있기 때문이다.</li><li>인스턴스에 대한 동기화(syncronized)처리 없이도 다른 스레드에서 문제없이 처리 된다.</li></ul><h2 id="모든-필드를-private로-선언한다">모든 필드를 private로 선언한다.</h2><ul><li>필드가 참조하는 가변 객체를 클라이언트에서 직접 접근하여 수정하는 일을 막는다.</li><li>public final로만 처리해도 되지만, 그 안의 내용을 바꿀 수 있고 다 릴리즈에서 내부 표현을 변경하지 못하므로 사용하지 않는게 좋다.</li></ul><h2 id="자신객체-이외에는-내부의-가변-컴포넌트에-접근-할-수-없도록-한다">자신(객체) 이외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.</h2><ul><li>클라이언트에서 인스턴스 내에 가변 객체의 참조를 얻을 수 없게 해야한다. - Collection에 대한 getter를 제공하면 안된다!</li><li>생성자, 접근자(getter), readObject 메서드에서 모두 <code>방어적 복사</code>를 수행해야 한다.</li></ul><h1 id="함수형-프로그래밍">함수형 프로그래밍</h1><ul><li>피연산자에 함수를 적용해 결과를 반환하는 프로그래밍 기법</li><li>피연산자에 대해 연산하지만 피연산자는 값이 변하지 않음(캡처 - 피연산자는 사실상 final)</li><li>코드의 불변이 영역이 되는 비율이 높아져 안전하다.</li></ul><h1 id="불변-객체의-장점">불변 객체의 장점</h1><ul><li>불변 객체는 생성 시점부터 소멸될 때 까지 변하지 않는다. - 서비스 로직에 더 안전하다.</li><li>불변 객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요가 없다. - 스레드에 따라 값이 변하지 않기 때문이다.</li><li>불변 객체는 안심하고 공유 할 수 있다. - 불변 클래스라면 최대한 재사용 하라 (캐싱)</li><li>불변 객체는 방어적 복사본이 필요없다 - 바뀌지 않으므로 방어할 일이 없다.</li><li>불변 객체는 clone메서드를 제공하지 않는게 좋다. - 의미가 없다.</li><li>불변 객체를 key로 하면 이점이 많다.<ul><li>Map의 key</li><li>Set의 원소</li></ul></li><li>불변 객체는 그 자체로 실패 원자성을 제공한다.<ul><li>메서드에서 예외가 발생하더라도 객체의 변경내용이 없다.</li></ul></li><li>불변 객체끼리는 자유롭게 내부 데이터를 공유 할 수 있다.<ul><li>BigInteger 클래스에서 mag는 크기를 나타내는 배열</li><li>signum은 부호를 나타내는 int 필드</li><li>mag는 배열이지만 불변이므로 방어적 복사본을 만들지 않고 원래 객체의 mag를 써도 된다.</li></ul></li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a BigInteger whose value is &#123;<span class="doctag">@code</span> (-this)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> -this&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(<span class="keyword">this</span>.mag, -<span class="keyword">this</span>.signum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>불변 객체는 값이 다르면 반드시 독립된 객체로 만들어야 한다.</li></ul><h1 id="요약">요약</h1><ul><li>접근자(getter)를 제공한다고 습관처럼 수정자(setter)를 만들지 말자<ul><li>꼭 필요한 경우가 아니라면 클래스는 불변이어야 한다.</li><li>장점이 훨씬많고, 단점이라면 잠재적 성능저하 뿐이다.</li></ul></li><li>불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한 줄이자<ul><li>객체가 가질 수 있는 상태를 제한하면, 예외를 예측하기 쉽고, 오류가 생길 가능성이 줄어든다.</li><li>꼭 변경할 필드가 아닌 필드는 final로 선언하자 - 웬만하면 final로 해야한다.</li></ul></li><li>생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.<ul><li>확실한 이유가 없다면, 생성자와 정적팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안된다.</li><li>특히! 객체를 재활용할 목적으로 상태를 다시 초기화 하는 메서드도 안된다.</li><li>복잡성만 커지고 성능 이점은 거의 없다.</li></ul></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 17. 변경 가능성을 최소화하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/20/effective-java-item17/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/01/20/effective-java-item16/</link>
      <guid>https://jaehun2841.github.io/2019/01/20/effective-java-item16/</guid>
      <pubDate>Sun, 20 Jan 2019 08:53:54 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;퇴보한-클래스&quot;&gt;퇴보한 클래스&lt;/h1&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="퇴보한-클래스">퇴보한 클래스</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> x;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이런 클래스는 데이터 필드에 직접 접근하여 수정이 가능하다. 따라서 캡슐화의 이점을 제공하지 못한다.</p><ul><li>API를 수정하지 않고는 내부 표현을 바꿀 수 없다.</li><li>불변식을 보장할 수 없다.</li><li>외부에서 필드에 접근할 때 부수 작업을 수행 할 수도 없다.(예를들면, x값 조회 시, Comma case로 리턴하는 식의?)</li></ul><h1 id="흔하게-만드는-캡슐레이션">흔하게 만드는 캡슐레이션</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">this</span>.x = x; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">this</span>.y = y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>public 클래스라면 반드시 이정도의 접근자와 수정자를 만드는 정도는 해야된다.</li><li>클래스 내부 표현 방식을 언제든지 바꿀 수 있는 유연성을 제공해야 한다.</li><li>package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다해도 문제가 없다.<ul><li>같은 패키지안에서 특정이유 때문에 사용하던가, 톱레벨 클래스에서만 접근 할 것이기 때문이다.</li></ul></li></ul><h1 id="요약">요약</h1><ul><li>public 클래스는 절대 가변 필드를 노출해선 안된다.</li><li>불변 필드라면 노출해도 덜위험 하지만 그래도 하지 말아라.</li><li>package-private 클래스, 톱 레벨 클래스에서는 노출하는 편이 나을 수도 있다. (글쎄..?)</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/20/effective-java-item16/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 15. 클래스와 멤버의 접근 권한을 최소화하라</title>
      <link>https://jaehun2841.github.io/2019/01/19/effective-java-item15/</link>
      <guid>https://jaehun2841.github.io/2019/01/19/effective-java-item15/</guid>
      <pubDate>Sat, 19 Jan 2019 12:54:32 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;잘 설계된 컴포넌트는 클래스는 모든 내부구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리 해놨다.&lt;br&gt;
오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.&lt;br&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>잘 설계된 컴포넌트는 클래스는 모든 내부구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리 해놨다.<br>오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.<br>정보은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.</p><h1 id="정보-은닉의-장점">정보 은닉의 장점</h1><h2 id="시스템-개발-속도를-높인다">시스템 개발 속도를 높인다.</h2><p>여러가지 컴포넌트를 병렬로 개발할 수 있기 때문이다.예를 들어, 회원탈퇴 기능을 개발한다고 해보자</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithdrawalService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">withdrawalMember</span><span class="params">(Member member)</span></span>;</span><br><span class="line">  <span class="function">List&lt;Member&gt; <span class="title">getMembers</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">WithdrawalProcessType <span class="title">getProcessType</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="title">startProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Member&gt; members = getMembers();</span><br><span class="line">    members.stream().foreach(<span class="keyword">this</span>::withdrawalMember);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이러한 회원탈퇴 로직에 대한 인터페이스를 제공하고,일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴등의 로직이 상이하여 Service를 별도로 구현한다고하는 경우 Interface 스펙에 맞추어 여러 개발자가 개발할 수 있기 때문이다.</p><h2 id="시스템-관리-비용을-낮춘다">시스템 관리 비용을 낮춘다.</h2><p>각 컴포넌트를 빨리 파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.<br>위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 로직에 변경이 생긴 경우<br><code>WithdrawalService</code> interface를 구현한 비회원 탈퇴 서비스를 만들면 되기 때문이다.</p><h2 id="성능-최적화에-도움을-준다">성능 최적화에 도움을 준다.</h2><p>완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있다.<br>위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 중 비회원 탈퇴에 대해 처리대상이 많아 startProcess 메서드를 확장하여 내부적으로 withdrawalMember 메서드를 사용하지 않고 회원 리스트에 대해 쿼리를 이용해 Insert~ Select로 한방에 처리 할 수도 있다.</p><h2 id="소프트웨어-재사용성을-높인다">소프트웨어 재사용성을 높인다.</h2><p>외부에 의존하지 않고, 독자적으로 동작할 수 있는 컴포넌트라면, 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크다.<br>예를들면 알림톡 서버 API를 호출 할 수 있는 인터페이스가 있는 경우 그 인터페이스를 그대로 사용할 수 있다.</p><h2 id="큰-시스템을-제작하는-난이도를-낮춰준다">큰 시스템을 제작하는 난이도를 낮춰준다.</h2><p>시스템 전체가 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있다.<br>쉬운 예로 Mockito를 이용한 TestCase 작성이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(MockitoJUnitRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithdrawalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWithdrawalService</span> <span class="keyword">implements</span> <span class="title">WithdrawalService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">withdrawalMember</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">getMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> TestWithdrawalService testWithdrawalService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMocks</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 회원탈퇴_테스트() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        doReturn(Arrays.asList(<span class="keyword">new</span> Member(<span class="string">"Carrey"</span>))).when(testWithdrawalService).getMembers();</span><br><span class="line">        doCallRealMethod().when(testWithdrawalService).startProcess();</span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        String result = testWithdrawalService.startProcess();</span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        assertThat(result, is(<span class="string">"FINISHED"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="java의-접근제한자">Java의 접근제한자</h1><ul><li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li><li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 할 수 있다.</li><li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li><li>public: 모든 곳에서 접근 할 수 있다.</li></ul><h1 id="모든-클래스와-멤버의-접근성을-가능한-좁혀야-한다">모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.</h1><p>소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다.</p><h2 id="클래스-레벨-접근제한자">클래스 레벨 접근제한자</h2><p>톱레벨 수준(파일명 = 클래스명)이 같은 수준에서의 접근제한자는 public과 package-private만 사용 할 수 있다.</p><ul><li>public으로 선언하는 경우 공개 API로 사용 - 하위호환을 평생 신경써야 한다.</li><li>package-private로 사용하는 경우 해당 패키지 안에서만 사용 가능 - 다음 릴리즈에 내부로직을 변경해도 괜찮다.</li></ul><h2 id="이너클래스-사용하기">이너클래스 사용하기</h2><ul><li>한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 사용하는 클래스 안에 private static으로 중첩해보자</li><li>public일 필요가 없는 클래스의 접근 수준을 package-private로 해보자 - 다른 패키지에서 사용하지 못하게 막아야 한다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Shop&gt; shops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Shop&gt; shops;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String owner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="private과-package-private은-해당-클래스의-구현에-해당하므로-공개-api에-영향을-주지-않는다">private과 package-private은 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다.</h2><ul><li>일단 처음에는 모든 멤버는 private으로 만들어야 한다.</li><li>같은 패키지에서 접근해야 하는 멤버가 있는 경우 package-private로 변경</li><li>단, Serialize를 구현한 클래스의 경우 공개 API에 의도치 않게 공개 될 수도 있다.</li><li>필드의 접근 권한을 package-private에서 protected로 바꾸는 순간 필드에 접근 할 수 있는 대상 범위가 늘어나니 주의해야 한다.</li></ul><h2 id="메서드를-재정의-할-경우에는-접근-수준을-상위-클래스에서보다-좁게-설정-할-수-없다">메서드를 재정의 할 경우에는 접근 수준을 상위 클래스에서보다 좁게 설정 할 수 없다.</h2><ul><li>상위 클래스에서 접근제한자가 protected인데 하위클래스에서 갑자기 package-private이나 private로 변경할 수 없다.</li><li>상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환원칙)을 위반하기 때문이다.</li><li>단 인터페이스를 구현하는 경우에는 클래스의 메서드는 모두 public으로 해야 한다.</li></ul><h2 id="코드를-테스트-하려는-목적으로-클래스-인터페이스를-접근-범위를-넓히는-것을-주의하라">코드를 테스트 하려는 목적으로 클래스, 인터페이스를 접근 범위를 넓히는 것을 주의하라</h2><p>public 클래스의 private -&gt; package-private으로 바꾸는거는 괜찮다. 하지만 그이상의 경우 공개 API에 문제가 될 수 있다.</p><h1 id="public-클래스의-인스턴스-필드는-되도록-public이-아니어야-한다">public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.</h1><p>필드가 가변객체를 참조하거나(Collections이나 배열), final이 아닌 인스턴스 필드를 public으로 선언하면 <strong>불변식을 보장할 수 없다.</strong><br>public 가변 필드를 갖는 클래스는 일반적으로 thread safe 하지않다.<br>내부 구현을 바꾸고 싶어도 public 필드를 없애는 방식으로는 리팩터링이 불가하다.</p><p>하지만 상수라면 관례대로 public static final 필드로 공개해도 좋다.<br>필드 명 네이밍은 관례 상 <code>대문자 + _(언더바)</code>로 구성한다.그리고 반드시 불변 객체를 참조하도록 한다.<br>불변성이 깨지는 순간 어마무시한 일이 일어난다.</p><h1 id="클래스에서-public-static-final-배열-필드를-두지말아라">클래스에서 public static final 배열 필드를 두지말아라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123;...&#125;;</span><br></pre></td></tr></table></figure></p><p>이런 경우 VALUES에 대한 참조를 변경할 수는 없지만, 배열내의 내용을 변경하는 것은 가능하다.</p><h2 id="해결책1-thing-배열을-private로-만들고-public-불변-리스트를-추가한다">해결책1. Thing 배열을 private로 만들고 public 불변 리스트를 추가한다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 해결책2. Thing 배열을 private로 만들고 public 메서드를 추가한다.</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">  <span class="keyword">return</span> PRIVATE_VALUES.clone(); <span class="comment">//방어적 복사본</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="java-9에-추가된-modules-project-jigsaw">Java 9에 추가된 Modules (Project Jigsaw)</h1><p>Java9 부터는 Module시스템이라는 개념이 도입 되었다.</p><p>패키지는 클래스의 묶음인 것 처럼, 모듈(Modules)은 패키지의 묶음이다.모듈은 관례 상, 자신이 속하는 패키지 중 공개(export) 할 것을 선언한다.<br>관례상 <strong>module-info.java</strong> 에 선언한다.모듈을 정의하기 위해 3가지 정보를 작성해야 한다.</p><ol><li>module 명 - module 명칭</li><li>공개할 package (export)</li></ol><ul><li>공개한 package의 public type에 접근제한자만 외부에서 접근할 수 있다.</li><li>만약 export에 적지 않은 패키지의 클래스 중 public 접근제한자가 있어도 접근을 할 수 없다.</li></ul><ol start="3"><li>module내 package의 클래스를 사용하기 위해 종속되는 package (require)</li></ol><ul><li>다른 모듈의 대한 require를 작성하면 다른 모듈에서 export하는 클래스의 public type에 접근이 가능하다</li></ul><h2 id="java-8에서-접근-제한자">Java 8에서 접근 제한자</h2><ul><li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li><li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li><li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li><li>public: 모든 곳에서 접근할 수 있다.</li></ul><h2 id="java-9부터의-접근-제한자">Java 9부터의 접근 제한자</h2><ul><li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li><li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li><li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li><li>모듈 내부의 public: 모듈 내부의 모든 곳에서 접근할 수 있다.</li><li>required의 public: 모듈에 종속하는 모듈의 모든 패키지 내의 클래스에 접근할 수 있다.</li><li>export public: module-info.java에서 제공하는 모든 public에 접근할 수 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 15. 클래스와 멤버의 접근 권한을 최소화하라</li><li>https://infoscis.github.io/2017/03/24/First-steps-with-java9-and-jigsaw-part-1/</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/19/effective-java-item15/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 14. Comparable을 구현할지 고려하라</title>
      <link>https://jaehun2841.github.io/2019/01/13/effective-java-item14/</link>
      <guid>https://jaehun2841.github.io/2019/01/13/effective-java-item14/</guid>
      <pubDate>Sun, 13 Jan 2019 10:26:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Comparable을 구현하는 이유는 클래스의 인스턴스들간의 Ordering을 목적으로 구현하는 클래스이다.&lt;br&gt;
따라서 Comparable을 구현한 클래스에 대한 배열은 다음처럼 손쉽게 정렬 할 수 있다.&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Comparable을 구현하는 이유는 클래스의 인스턴스들간의 Ordering을 목적으로 구현하는 클래스이다.<br>따라서 Comparable을 구현한 클래스에 대한 배열은 다음처럼 손쉽게 정렬 할 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(arr);</span><br></pre></td></tr></table></figure></p><p>사실상 자바 플랫폼 라이브러리의 모든 값 클래스와 열거타입은 Compareable을 구현했다.<br>알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면, 반드시 Comparable 인터페이스를 구현하자</p><h1 id="compareto-메서드-규약">compareTo 메서드 규약</h1><p>이 객체와 주어진 객체의 순서를 비교한다.<br>이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 리턴한다.<br>이 객체와 비교할 수 없는 타입이 주어지면 ClassCaseException을 던진다.</p><h2 id="대칭성">대칭성</h2><ul><li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == (y.compareTo(x)) * (-1)을 만족해야 한다.</li><li>따라서 x.compareTo(y)가 예외를 던지는 경우, y.compareTo(x)도 예외를 던져야 한다.</li></ul><h2 id="추이성">추이성</h2><ul><li>Comparable을 구현한 클래스는 모든 x, y, z에 대해 x.compareTo(y) &gt; 0 이고 y.compareTo(z)이면, x.compareTo(z)를 만족해야 한다.</li></ul><h2 id="반사성">반사성</h2><ul><li>Comparable을 구현한 클래스 z는 x.compareTo(y) == 0 이면, sgn(x.compareTo(z)) == sgn(y.compareTo(z))를 만족해야 한다.</li></ul><h2 id="equals">equals</h2><ul><li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == 0 이면, x.equals(y)를 만족하는 것이 좋다. (권고사항은 아니다.)<br>이 권고를 지키지 않으려면, <code>주의: 이 클래스의 순서는 equals 메서드와 일관되지 않다.</code>라고 명시해 주자.</li></ul><h1 id="equals와-compareto-차이점">equals와 compareTo 차이점</h1><p>compareTo 규약 4번째의 예시로 BigDecimal 클래스가 있다.<br>new Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)이 있다고 할 때 두 객체를 HashSet&lt;Decimal&gt;에 담게 되면 size는 2개가 된다.<br>하지만 TreeSet&lt;Decimal&gt;에 담게 되면 size는 1개가 된다.</p><p>왜 이런 결과가 나올까?<br>HashSet에서는 equals를 기반으로 비교하기 때문에 new Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)은 서로 다른 객체이다. 그렇기 때문에 size가 2개가 된다.<br>하지만 TreeSet에서는 객체에 대한 동치성 비교를 compareTo로 하기 때문에 new Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)의 compareTo는 0을 리턴한다.<br>따라서 같은 객체로 인식하여 size가 1개가 된다.</p><h1 id="compareto-안티패턴">compareTo 안티패턴</h1><p>compareTo 메서드에서 관계연산자 (<code>&lt;</code> 와 <code>&gt;</code>)를 사용하지 말아야 한다.<br>대신 Type.compare(T t1, T t2)를 사용하여 비교하는 것이 좋다.</p><p>안티 패턴 코드<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; y ? <span class="number">1</span> : (x == y) ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>hashcode의 차를 이용한 비교는 안된다. (추이성에 위배된다.)</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">  (Object o1, Object o2) -&gt; o1.hashCode() - o2.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드 처럼 실행하면, 정수 overflow를 일으키거나 IEEE754 부동소수점 계산방식에 따른 오류를 발생 시킬 수 있다.<br>따라서 아래 코드로 고쳐서 사용하는 것이 좋다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">  (Object o1, Object o2) -&gt; Integer.compare(o1.hashCode(), o2.hashCode())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());</span><br></pre></td></tr></table></figure></p><h1 id="사용-예제">사용 예제</h1><h2 id="기본-타입-필드가-여러-개-일때-비교자">기본 타입 필드가 여러 개 일때 비교자</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PhoneNumber pn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = Short.compare(<span class="keyword">this</span>.areaCode, pn.areaCode);</span><br><span class="line">  <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">    result = Short.compare(<span class="keyword">this</span>.prefix, pn.prefix);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">      result = Short.compare(<span class="keyword">this</span>.line</span><br><span class="line">      Num, pn.lineNum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>필드의 정렬 우선순위를 정해 같은 값이 있을 때 마다 조건을 추가한다.</p><h2 id="비교자-생성-메서드를-이용한-비교자">비교자 생성 메서드를 이용한 비교자</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR </span><br><span class="line">                        = comparingInt((PhoneNumber pn) -&gt; pn.areaCode)  </span><br><span class="line">                                      .thenComparingInt(pn -&gt; pn.prefix)  </span><br><span class="line">                                      .thenComparingInt(pn -&gt; pn.lineNum)</span><br></pre></td></tr></table></figure></p><p>comparingInt라는 static 메서드를 import하여 사용하고, 2번째 조건 부터 thenComparingInt를 사용하여 비교자를 추가 할 수 있다.<br>최초 사용 시, PhoneNumber pn을 사용하여 람다식에서 타입을 추론 할 수 있도록 코드를 추가 하였다.<br>thenComparingInt부터는 자바 컴파일러가 충분히 타입을 추론 할 수 있으므로 명시적으로 지정하지 않았다.<br>Long타입과 Double타입에 대해서는 각각 comparingLong, thenComparingLong과 comparingDouble, thenComparingDouble이 별도로 있다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 14. Comparable을 구현할지 고려하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/13/effective-java-item14/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Shallow Copy와 Deep Copy</title>
      <link>https://jaehun2841.github.io/2019/01/13/java-object-copy/</link>
      <guid>https://jaehun2841.github.io/2019/01/13/java-object-copy/</guid>
      <pubDate>Sun, 13 Jan 2019 09:59:09 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;객체의-복사copy&quot;&gt;객체의 복사(Copy)&lt;/h1&gt;
&lt;p&gt;객체 지향 프로그래밍에서 객체를 복사하는 방법은 크게 두가지로 나뉜다.&lt;br&gt;
얇은 복사(Shallow Copy)와 깊은 복사(Deep Copy)가 있다.&lt;br&gt;
두가지 개념 모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="객체의-복사copy">객체의 복사(Copy)</h1><p>객체 지향 프로그래밍에서 객체를 복사하는 방법은 크게 두가지로 나뉜다.<br>얇은 복사(Shallow Copy)와 깊은 복사(Deep Copy)가 있다.<br>두가지 개념 모두 원본 객체를 바탕으로 새로운 객체를 만들어 낸다는 점에서는 같지만 미묘한 차이가 있다.</p><p>설명을 진행하기 전에 아래와 같은 Interface를 구현한 객체에 대해 copy가 진행된다고 가정하겠다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Copyable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function">T <span class="title">shallowCopy</span><span class="params">(T t)</span></span>;</span><br><span class="line">   <span class="function">T <span class="title">deepCopy</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="./clone.jpg" alt="clone"></p><h1 id="shallow-copy">Shallow Copy</h1><p>Shallow copy란 원본 객체를 바탕으로 새로운 객체를 생성한 뒤, 내부 필드의 참조에 대해서는 원본 객체와 같은 필드의 참조를 바라보는 형태이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">implements</span> <span class="title">Copyable</span>&lt;<span class="title">Menu</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> Recipe recipe;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Menu <span class="title">shallowCopy</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    Menu copyMenu = <span class="keyword">new</span> Menu(menu.getName(), menu.getPrice(), menu.getRecipe());</span><br><span class="line">    <span class="keyword">return</span> copyMenu;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>불변 객체에 대해서는 같은 객체를 공유한다는 점에서 메모리에 대한 비용을 아낄 수 있다는 장점이 있고, deep copy보다는 빠르다.</p><p>하지만, 가변 객체에 대해서는 원본 객체의 Recipe 객체가 변경되는 경우 의도치 않게 복사한 Recipe도 변경되는 경우가 발생한다.<br>이런 경우에는 Deep Copy를 통해 완전히 분리를 시켜줘야 한다.</p><h1 id="deep-copy">Deep Copy</h1><p>Deep Copy 원본 객체의 타입을 바탕으로 새로운 객체를 생성한 뒤, 내부 필드가 참조하는 객체에 대해서도 새로운 객체를 만들어 주는 방식이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">implements</span> <span class="title">Copyable</span>&lt;<span class="title">Menu</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> Recipe recipe;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Menu <span class="title">deepCopy</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    Menu copyMenu = <span class="keyword">new</span> Menu();</span><br><span class="line">    copyMenu.setName(<span class="keyword">new</span> String(menu.getName));</span><br><span class="line">    copyMenu.setPrice(menu.getPrice());</span><br><span class="line">    copyMenu.setRecipe(Recipe.deepCopy(menu.getRecipe));</span><br><span class="line">    <span class="keyword">return</span> copyMenu;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 필드에 대해 원본객체와 같은 reference를 사용하는 것이 아닌 필드의 reference에 대해서도 새로운 객체를 생성하여 복사하는 방식이다.</p><p>이런 경우 가변객체에 대한 변경에는 안전하다는 장점이 있다.<br>서로 다른 객체를 다루기 떄문에 안전하다.</p><p>하지만 객체 생성 비용이 shallow copy보다 비싸고 상대적으로 느리며,copy하는 객체 수가 많을 수록 메모리를 많이 점유하게 된다는 단점이 있다.</p>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/13/java-object-copy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 13. Clone 재정의는 주의해서 진행하라</title>
      <link>https://jaehun2841.github.io/2019/01/13/effective-java-item13/</link>
      <guid>https://jaehun2841.github.io/2019/01/13/effective-java-item13/</guid>
      <pubDate>Sun, 13 Jan 2019 07:31:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Cloneable은 복제해도 되는 인터페이스 임을 명시하는 용도의 믹스인 인터페이스이다.&lt;br&gt;
하지만 아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone메서드가 선언된 곳이 Cloneab
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Cloneable은 복제해도 되는 인터페이스 임을 명시하는 용도의 믹스인 인터페이스이다.<br>하지만 아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라는데 있다. 그래서 Cloneable을 구현하는 것만으로는 외부에서 clone 메서드를 호출 할 수 없다.</p><h1 id="cloneable-인터페이스는-무슨일을-할까">Cloneable 인터페이스는 무슨일을 할까?</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to</span></span><br><span class="line"><span class="comment"> * indicate to the &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; method that it</span></span><br><span class="line"><span class="comment"> * is legal for that method to make a</span></span><br><span class="line"><span class="comment"> * field-for-field copy of instances of that class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Invoking Object's clone method on an instance that does not implement the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, classes that implement this interface should override</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Object.clone&#125; (which is protected) with a public method.</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; for details on overriding this</span></span><br><span class="line"><span class="comment"> * method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &#123;<span class="doctag">@code</span> clone&#125; method.</span></span><br><span class="line"><span class="comment"> * Therefore, it is not possible to clone an object merely by virtue of the</span></span><br><span class="line"><span class="comment"> * fact that it implements this interface.  Even if the clone method is invoked</span></span><br><span class="line"><span class="comment"> * reflectively, there is no guarantee that it will succeed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#clone()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>자바의 Cloneable 인터페이스를 보면 아무런 메서드도 없다.<br>아무것도 없지만, 사실은 Object의 clone메서드의 동작방식을 결정한다.<br>Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면, 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면, <code>ClassNotSupportedException</code>을 던진다.</p><h1 id="object-클래스의-clone-규약">Object 클래스의 clone 규약</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns a copy of this object.  The precise meaning</span></span><br><span class="line"><span class="comment"> * of "copy" may depend on the class of the object. The general</span></span><br><span class="line"><span class="comment"> * intent is that, for any object &#123;<span class="doctag">@code</span> x&#125;, the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be true, and that the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, but these are not absolute requirements.</span></span><br><span class="line"><span class="comment"> * While it is typically the case that:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the returned object should be obtained by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> super.clone&#125;.  If a class and all of its superclasses (except</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Object&#125;) obey this convention, it will be the case that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> x.clone().getClass() == x.getClass()&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment"> * of this object (which is being cloned).  To achieve this independence,</span></span><br><span class="line"><span class="comment"> * it may be necessary to modify one or more fields of the object returned</span></span><br><span class="line"><span class="comment"> * by &#123;<span class="doctag">@code</span> super.clone&#125; before returning it.  Typically, this means</span></span><br><span class="line"><span class="comment"> * copying any mutable objects that comprise the internal "deep structure"</span></span><br><span class="line"><span class="comment"> * of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment"> * objects with references to the copies.  If a class contains only</span></span><br><span class="line"><span class="comment"> * primitive fields or references to immutable objects, then it is usually</span></span><br><span class="line"><span class="comment"> * the case that no fields in the object returned by &#123;<span class="doctag">@code</span> super.clone&#125;</span></span><br><span class="line"><span class="comment"> * need to be modified.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The method &#123;<span class="doctag">@code</span> clone&#125; for class &#123;<span class="doctag">@code</span> Object&#125; performs a</span></span><br><span class="line"><span class="comment"> * specific cloning operation. First, if the class of this object does</span></span><br><span class="line"><span class="comment"> * not implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125;, then a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> CloneNotSupportedException&#125; is thrown. Note that all arrays</span></span><br><span class="line"><span class="comment"> * are considered to implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125; and that</span></span><br><span class="line"><span class="comment"> * the return type of the &#123;<span class="doctag">@code</span> clone&#125; method of an array type &#123;<span class="doctag">@code</span> T[]&#125;</span></span><br><span class="line"><span class="comment"> * is &#123;<span class="doctag">@code</span> T[]&#125; where T is any reference or primitive type.</span></span><br><span class="line"><span class="comment"> * Otherwise, this method creates a new instance of the class of this</span></span><br><span class="line"><span class="comment"> * object and initializes all its fields with exactly the contents of</span></span><br><span class="line"><span class="comment"> * the corresponding fields of this object, as if by assignment; the</span></span><br><span class="line"><span class="comment"> * contents of the fields are not themselves cloned. Thus, this method</span></span><br><span class="line"><span class="comment"> * performs a "shallow copy" of this object, not a "deep copy" operation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The class &#123;<span class="doctag">@code</span> Object&#125; does not itself implement the interface</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Cloneable&#125;, so calling the &#123;<span class="doctag">@code</span> clone&#125; method on an object</span></span><br><span class="line"><span class="comment"> * whose class is &#123;<span class="doctag">@code</span> Object&#125; will result in throwing an</span></span><br><span class="line"><span class="comment"> * exception at run time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>     a clone of this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  CloneNotSupportedException  if the object's class does not</span></span><br><span class="line"><span class="comment"> *               support the &#123;<span class="doctag">@code</span> Cloneable&#125; interface. Subclasses</span></span><br><span class="line"><span class="comment"> *               that override the &#123;<span class="doctag">@code</span> clone&#125; method can also</span></span><br><span class="line"><span class="comment"> *               throw this exception to indicate that an instance cannot</span></span><br><span class="line"><span class="comment"> *               be cloned.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Cloneable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p><p>Object에 명시된 clone 규약이 주석으로 쓰여져 있다.</p><ul><li>x.clone() != x은 참이다.<br>복사한 객체와 원본 객체는 서로 다른 객체이다.</li><li>x.clone() .getClass() == x.getClass()은 일반적으로 참이다.하지만 반드시 만족해야 하는 것은 아니다.</li><li>x.clone.equals(x) 은 참이다.<br>복사한 객체와 원본객체는 논리적 동치성이 같다.</li><li>x.clone().getClass() == x.getClass()은 참이다.<br>관례상, 이 방법으로 반환된 객체는 독립성이 있어야 한다.<br>이를 만족하려면 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.</li><li>Cloneable을 구현하지 않은 클래스의 경우, CloneNotSupportedException이 throw된다.</li><li>모든 Array는 Cloneable을 구현하도록 고려되었다. clone 메서드는 T[]를 리턴하도록 설계</li><li>T는 기본타입 또는 참조타입으로 설계</li><li>기본적으로 Object.clone은 clone대상 클래스에 대해 새로운 객체를 new로 생성</li><li>모든 필드들에 대해 초기화를 진행</li><li>하지만 필드에 대한 객체를 다시 생성하지 않는 Shallow copy 방식으로 수행한다 (deep copy아님)</li><li>클래스에 대한 복제본을 원하지 않는 경우 clone메서드를 재정의하여 CloneNotSupportedException을 throw하도록 함</li></ul><h1 id="clone-메서드-재정의-시-주의할-점">clone 메서드 재정의 시, 주의할 점</h1><h2 id="기본적인-clone메서드-재정의">기본적인 clone메서드 재정의</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PhoneNumber <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (PhoneNumber) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ClassNotSupportedException e) &#123;</span><br><span class="line">      <span class="comment">//아무처리를 하지 않거나, RuntimeException으로 감싸는 것이 사용하기 편하다.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>super.clone()을 실행하면 PhoneNumber에 대한 완벽한 복제가 이루어진다.</li><li>super.clone()의 리턴 타입은 Object이지만, 자바의 공변 반환타이핑 기능을 통해 PhoneNumber 타입으로 캐스팅하여 리턴하는 것이 가능하다.<br>(추천하는 기능)</li><li>try-catch 부분으로 감싼것은 super.clone() 메서드에서 ClassNotSupportedException이라는 checked exception을 리턴하기 떄문에 처리 해주었다.<ul><li>하지만 PhoneNumber가 Cloneable을 구현하기 떄문에 절대 실패하지 않는다.<br>따라서 이부분은 RuntimeException으로 처리하거나, 아무것도 설정하지 않아야 한다.</li></ul></li></ul><h2 id="가변-상태를-갖는-필드에-대한-복제">가변 상태를 갖는 필드에 대한 복제</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object[] elements;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Stack <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Stack result = (Stack) <span class="keyword">super</span>.clone();</span><br><span class="line">      result.elements = </span><br><span class="line">    &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 클래스가 단순히 clone메서드를 이용해 super.clone()만 실행하게 된다면,<br>new Stack()을 통해 새로운 객체가 생성되고 필드모두 원본 객체와 동일하게 초기화가 될 것이다.<br>하지만, 위에서 얘기한 Object의 clone 기본규약에는 Deep copy가 아닌 Shallow Copy를 이용해 초기화를 진행한다고 적혀있다.<br>따라서 배열과 같은 가변필드는 원본 필드와 객체를 공유하게 된다.</p><p>Clone메서드는 사실상 생성자와 같은 효과를 낸다.<br>즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.<br>그렇기 때문에 제대로 복제하기 위해서는, elements라는 배열을 똑같이 복사해서 만들어줘야 한다.</p><h2 id="배열-복사">배열 복사</h2><p>배열을 복제하는 방법 중 가장 권장하는 방법은array.clone()을 이용해 복사하는 방법이다.<br>사실, 배열은 clone기능을 가장 제대로 사용하는 유일한 예이다.</p><p>하지만, array 필드가 final이 적용되어 있다면 array.clone()을 통한 초기화는 할 수 없다. (final이기 떄문에 객체 생성 이후 초기화 불가)<br><strong>Cloneable 아키텍처는 가변객체를 참조하는 필드는 final로 선언하라 라는 일반 용법과 충돌한다.</strong><br>그래서 복제 할 수 있는 클래스를 만들기 위해 일부 필드에서 final 한정자를 제거해야 할 수도 있다.</p><h2 id="stack-overflow-문제">Stack overflow 문제</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Entry[] buckets = ...;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object key;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry next;</span><br><span class="line"></span><br><span class="line">    Entry(Object key, Object value, Entry next) &#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HashTable <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      HashTable result = (HashTable) <span class="keyword">super</span>.clone();</span><br><span class="line">      result.buckets = buckets.clone();</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Assertion();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>복제본은 자신만의 버킷 배열은 갖지만, 배열내의 Entry는 원본과 같은 연결리스트를 참조하여, 불변성이 꺠지게 된다.</p><p>그래서 HashTable.Entry 클래스는 내부적으로 deep copy를 지원하도록 보강되었다. 연결리스트에 대한 next를 복제할 때 재귀적으로 clone을 호출하도록 되어있는데, 재귀 호출 떄문에 연결리스트의 size만큼 스택프레임을 소비하여, 리스트가 길면 stackoverflow에러를 발생시킬 위험이 있다.<br>이 문제를 해결하기 위해서는 재귀 호출을 통한 deepcopy대신 반복자를 써서 순회하는 방법으로 수정해야 한다.</p><h2 id="안전하지만-느린-copy">안전하지만 느린 copy</h2><p>HashTable을 예로 들면, buckets필드를 새로운 배열로 초기화 한다음 원본테이블의 있는 버킷의 내용을 put(key, value) 메서드를 호출해<br>새로 버킷을 만드는 방법이 있다.<br>이 방법은 안전하긴 하지만, low level에서 작동하는 copy보다는 느리다.</p><h2 id="생성자-내에서는-재정의-될-수-있는-메서드를-호출-하지-말자">생성자 내에서는 재정의 될 수 있는 메서드를 호출 하지 말자</h2><p>만약 clone이 하위 클래스에서 재정의한 메서드를 호출하면, 하위 클래스는 복사과정에서 자신의 상태를 교정할 기회를 잃게되어<br>원본과 복제본의 상태가 달라질 수 있다.</p><h2 id="classnotsupportedexception">ClassNotSupportedException</h2><p>Object의 clone메서드는 CloneNotSupportedException을 던진다고 선언했지만 재정의한 메서드는 그렇지 않다.<br>public인 clone 메서드에서는 throws절을 없애던가, RuntimeException으로 throws 해야한다.<br>그렇지 않으면 clone 메서드를 호출 할 떄마다, 예외처리를 해야 해서 사용하기가 불편하다.</p><p>하위 클래스에서 Clone을 방지하기 위해 동작하지 않게 만들수도 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="스레드-안전성을-고려한다면-적절히-동기화해야-한다">스레드 안전성을 고려한다면 적절히 동기화해야 한다.</h2><p>스레드 안정성을 고려한다면 clone 메서드에 대해 적절히 동기화 처리 해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object result = <span class="keyword">super</span>.clone();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="복사-생성자와-복사-팩터리-메서드">복사 생성자와 복사 팩터리 메서드</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Yum</span><span class="params">(Yum yum)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Yum <span class="title">newInstance</span><span class="params">(Yum yum)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>복사 생성자와 복사 팩터리 메서드는 Cloneable/clone 방식보다 나은 면이 많다.</p><ul><li>언어 모순적이고 위험한 객체 생성 메커니즘을 사용하지 않는다. (super.clone())</li><li>clone 규약에 기대지 않는다.</li><li>정상적인 final필드 용법과도 충돌하지 않는다.</li><li>불필요한 check exception 처리가 필요없다.</li><li>형변환도 필요없다.</li><li>복사 생성자와 복사 팩터리는 인터페이스 타입의 인스턴스를 인수로 받을 수 있다.</li></ul><h1 id="deep-copy-vs-shallow-copy">Deep copy vs Shallow copy</h1><p><a href="http://localhost:4000/2019/01/13/java-object-copy" target="_blank" rel="noopener">Shallow Copy와 Deep Copy</a> - 이 포스팅을 참고하자</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 13. clone 재정의는 주의해서 진행하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/13/effective-java-item13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 12. toString을 항상 재정의하라</title>
      <link>https://jaehun2841.github.io/2019/01/13/effective-java-item12/</link>
      <guid>https://jaehun2841.github.io/2019/01/13/effective-java-item12/</guid>
      <pubDate>Sun, 13 Jan 2019 05:59:25 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Object의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.&lt;br&gt;
이 메서드는 &lt;code&gt;PhoneNumber@adbbd&lt;/code&gt;처럼 단순히 &lt;stron
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Object의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.<br>이 메서드는 <code>PhoneNumber@adbbd</code>처럼 단순히 <strong>클래스이름@16진수로_표현한_해시코드</strong>를 반환할 뿐이다.<br>toString의 일반 규약에 따르면, <code>간결하면서 사람이 읽기 쉬운 형태의 유익한 정보</code>를 반환해야 한다.<br>toString의 규악은 <code>모든 하위클래스에서 이 메서드를 재정의하라</code>라고 하고 있다.</p><h1 id="tostring을-재정의-해야하는-이유">toString을 재정의 해야하는 이유</h1><ul><li>toString을 잘 구현한 클래스는 사용하기 편하고, 그 클래스에 대해 디버깅 하기 쉽다.<ul><li>map객체를 출력하는 경우 <code>{Jenny=PhoneNumber@addbb}</code> 보다는 <code>{Jenney=707-867-5308}</code>이라는 메세지가 가독서이 좋다.</li></ul></li><li>실전에서는 toString메서드를 재작성 할 때, 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.</li><li>toString을 구현할 때면 반환값의 포맷을 문서화 할 지 정해야 한다.<ul><li>포맷을 명시하면, 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다.</li><li>포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</li><li>단, 포맷을 한번 명시하면, 평생 그 포맷에 얽매이게 된다.</li><li>포맷을 명시하지 않는다면 다음 릴리즈에 포맷을 변경할 수 있는 유연성을 더 가져갈 수 있다.</li></ul></li><li>포맷을 명시하든 아니든, 개발자의 의도는 명확히 밝혀야 한다.</li><li>toString이 반환한 값에 대해 포함된 정보를 얻어올 수 있는 API를 제공하자<ul><li>toString에 있는 getter를 제공하지 않는다면, 클라이언트에서 toString을 파싱하여 사용할 지도 모른다.</li></ul></li></ul><h2 id="포맷을-명시하기로-했으면-명시한-포맷에-맞는-문자열과-객체를-상호전환-할-수-있는-정적-팩터리나-생성자를-함께-제공하면-좋다">포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> toString테스트() &#123;</span><br><span class="line">        String phoneNumber = <span class="string">"707-908-9999"</span>;</span><br><span class="line">        assertEquals(PhoneNumber.parse(phoneNumber), <span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">908</span>, <span class="number">9999</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>(expected = UnknownFormatConversionException.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 파싱문자열_오류_테스트() &#123;</span><br><span class="line">        String phoneNumber = <span class="string">"707-908"</span>;</span><br><span class="line">        assertEquals(PhoneNumber.parse(phoneNumber), <span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">908</span>, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer areaCode;</span><br><span class="line">        <span class="keyword">private</span> Integer prefix;</span><br><span class="line">        <span class="keyword">private</span> Integer lineNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern phoneNumberPattern = Pattern.compile(<span class="string">"^\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;4&#125;$"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PhoneNumber pn = (PhoneNumber) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.areaCode.equals(pn.areaCode)</span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.prefix.equals(pn.prefix)</span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.lineNum.equals(pn.lineNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result = Integer.hashCode(areaCode);</span><br><span class="line">            result = <span class="number">31</span> * result + Integer.hashCode(prefix);</span><br><span class="line">            result = <span class="number">31</span> * result + Integer.hashCode(lineNum);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">"%03d-%03d-%04d"</span>, areaCode, prefix, lineNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PhoneNumber <span class="title">parse</span><span class="params">(String phoneNumber)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!phoneNumberPattern.matcher(phoneNumber).find()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnknownFormatConversionException(phoneNumber + <span class="string">" cannot be parsed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] numbers = phoneNumber.split(<span class="string">"-"</span>);</span><br><span class="line">            <span class="keyword">return</span> PhoneNumber.builder()</span><br><span class="line">                    .areaCode(Integer.parseInt(numbers[<span class="number">0</span>]))</span><br><span class="line">                    .prefix(Integer.parseInt(numbers[<span class="number">1</span>]))</span><br><span class="line">                    .lineNum(Integer.parseInt(numbers[<span class="number">2</span>]))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="tostring을-따로-재정의-안해도-되는-경우">toString을 따로 재정의 안해도 되는 경우</h1><ul><li>정적 Utils 클래스는 따로 재정의 하지 않아도 된다.(객체의 상태(state)를 가지는 클래스가 아니기 떄문)</li><li>enum 타입 또한 이미 완벽한 toString을 제공한다.</li><li>대다수의 컬렉션 구현체는 추상 컬렉션 클래스(AbstractMap, AbstractSet등)의 toString 메서드를 상속하여 쓴다.</li><li>라이브러리를 통해 자동생성하자<ul><li>구글의 @Autovalue</li><li>Lombok의 @ToString</li><li>위의 라이브러리들을 이용해 자동생성하는 편이 더 간편하다.</li></ul></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 12. toString을 항상 재정의하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/13/effective-java-item12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 11. Equals를 재정의하려거든 Hashcode도 재정의하라</title>
      <link>https://jaehun2841.github.io/2019/01/12/effective-java-item11/</link>
      <guid>https://jaehun2841.github.io/2019/01/12/effective-java-item11/</guid>
      <pubDate>Sat, 12 Jan 2019 13:22:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;equals를 재정의한 클래스에서는 hashcode도 재정의 해야한다.&lt;/code&gt;&lt;br&gt;
그렇지 않으면 hash를 사용하는 HashMap, HashSet과 같은 컬렉션의 원소로 사용될 때 문제가 발
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p><code>equals를 재정의한 클래스에서는 hashcode도 재정의 해야한다.</code><br>그렇지 않으면 hash를 사용하는 HashMap, HashSet과 같은 컬렉션의 원소로 사용될 때 문제가 발생할 것이다.</p><p>이번 글을 읽기 전에 아래 글을 먼저 읽어 해시, 해시테이블에 대한 용어를 먼저 익히는 것이 도움이 될 것 같다.</p><ul><li><a href="http://bcho.tistory.com/1072" target="_blank" rel="noopener">해쉬 테이블의 이해와 구현 (Hashtable) - 조대협의 블로그</a></li><li><a href="https://d2.naver.com/helloworld/831311" target="_blank" rel="noopener">Java HashMap은 어떻게 동작하는가? - Naver D2</a></li></ul><h1 id="hashcode의-규약">hashcode의 규약</h1><ul><li>equals비교에 사용되는 정보가 변경되지 않았다면, 객체의 hashcode 메서드는 몇번을 호출해도 항상 일관된 값을 반환해야 한다.<br>(단, Application을 다시 실행한다면 값이 달라져도 상관없다. (메모리 소가 달라지기 때문))</li><li>equals메서드 통해 두 개의 객체가 같다고 판단했다면, 두 객체는 똑같은 hashcode 값을 반환해야 한다.</li><li>equals메서드가 두 개의 객체를 다르다고 판단했다 하더라도, 두 객체의 hashcode가 서로 다른 값을 가질 필요는 없다. (Hash Collision)<br>단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.</li></ul><h1 id="equals-메서드는-재정의했지만-hashcode를-재정의하지-않은-경우">equals 메서드는 재정의했지만, hashcode를 재정의하지 않은 경우</h1><p>hashcode의 규약 2번째 조건을 위반하는 행위이다.<br>Effective Java 11장에서 설명하는 PhoneNumber 클래스를 생성해 테스트 해 보았다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashCodeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hashcode_재정의() &#123;</span><br><span class="line">        HashMap&lt;ExtendedPhoneNumber, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>), <span class="string">"제니"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Instance 1 hashcode : "</span> + <span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        System.out.println(<span class="string">"Instance 2 hashcode : "</span> + <span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        Assert.assertEquals(map.get(<span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>)), <span class="string">"제니"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hashcode_재정의안함() &#123;</span><br><span class="line">        HashMap&lt;PhoneNumber, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>), <span class="string">"제니"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Instance 1 hashcode : "</span> + <span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        System.out.println(<span class="string">"Instance 2 hashcode : "</span> + <span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        Assert.assertNotEquals(map.get(<span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>)), <span class="string">"제니"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> firstNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> secondNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> thirdNumber;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PhoneNumber p = (PhoneNumber) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.firstNumber == p.firstNumber &amp;&amp;</span><br><span class="line">                    <span class="keyword">this</span>.secondNumber == p.secondNumber &amp;&amp;</span><br><span class="line">                    <span class="keyword">this</span>.thirdNumber == p.thirdNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedPhoneNumber</span> <span class="keyword">extends</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExtendedPhoneNumber</span><span class="params">(<span class="keyword">int</span> firstNumber, <span class="keyword">int</span> secondNumber, <span class="keyword">int</span> thirdNumber)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(firstNumber, secondNumber, thirdNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">int</span> hashcode = Integer.hashCode(firstNumber);</span><br><span class="line">            hashcode = c * hashcode + Integer.hashCode(secondNumber);</span><br><span class="line">            hashcode = c * hashcode + Integer.hashCode(thirdNumber);</span><br><span class="line">            <span class="keyword">return</span> hashcode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="test1-hashcode를-재정의-하지-않은-경우">Test.1 hashcode를 재정의 하지 않은 경우</h2><p>PhoneNumber 클래스에서는 객체 동치성 체크를 위해 equals메서드를 재정의했다. <strong>하지만 hashcode 메서드는 재정의 하지 않았다.</strong>new를 통해 새로운 객체를 만들 때마다 늘 다른 hashcode를 리턴하여, 실제 HashMap에 key로 PhoneNumber클래스를 삽입하더라도<br>hashcode가 다르기 때문에 다른 버킷에가서 데이터를 조회 하려고해서 결과적으로 null이 나와 기댓값인 <code>&quot;제니&quot;</code>를 만족하지 못했다.</p><p>실제 로그를 찍어보니<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instance 1 hashcode : 1686369710</span><br><span class="line">Instance 2 hashcode : 194706439</span><br></pre></td></tr></table></figure></p><p>두 개의 다른 객체에 대해 다른 hashcode를 리턴하고 있었다.</p><h2 id="test2-hashcode를-재정의-한-경우">Test.2 hashcode를 재정의 한 경우</h2><p>ExtendPhoneNumber 클래스에서는 PhoneNumber를 상속 받은 뒤, hashCode 메서드를 재정의하였다.<br>(equals메서드는 PhoneNumber의 equals를 그대로 사용하였다.)</p><p>실제 로그를 찍어보니<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instance 1 hashcode : 711611</span><br><span class="line">Instance 2 hashcode : 711611</span><br></pre></td></tr></table></figure></p><p>두 개의 ExtendPhoneNumber 객체에 대해 같은 hashcode를 리턴하고 있었다.<br>그렇기 때문에 HashMap에 삽입한 ExtendPhoneNumber 객체에 대해 new ExtendPhoneNumber()로 조회를 하니 같은 hashCode의 버킷을 조회하여<br><code>&quot;제니&quot;</code>라는 데이터를 얻어올 수 있었다.</p><h1 id="최악의-hashcode-구현">최악의 hashcode 구현</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하니 적법한 해시코드 처럼 보인다.<br>하지만, 모든 객체에 대해 똑같은 해시코드를 반환하니 모든 객체가 같은 해시테이블 버킷에 담겨 연결리스트(Linked List)처럼 동작하게 된다.<br>평균 수행시간이 O(1)에서 O(n)으로 느려져서, 성능이 매우 낮아질 뿐더러 버킷에 대한 overflow가 발생하는 경우 데이터가 누락될 수도 있다.</p><h2 id="hashcode가-같으면-hashmap에서-어떻게-동작할까">hashcode가 같으면 HashMap에서 어떻게 동작할까?</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashCodeTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hashcode_재정의() &#123;</span><br><span class="line">        HashMap&lt;ExtendedPhoneNumber, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>), <span class="string">"제니"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Instance 1 hashcode : "</span> + <span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        System.out.println(<span class="string">"Instance 2 hashcode : "</span> + <span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5301</span>).hashCode());</span><br><span class="line">        <span class="comment">//다른 객체를 넣어 데이터를 조회해 보았다.</span></span><br><span class="line">        Assert.assertEquals(map.get(<span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5301</span>)), <span class="string">"제니"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> firstNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> secondNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> thirdNumber;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PhoneNumber p = (PhoneNumber) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.firstNumber == p.firstNumber &amp;&amp;</span><br><span class="line">                    <span class="keyword">this</span>.secondNumber == p.secondNumber &amp;&amp;</span><br><span class="line">                    <span class="keyword">this</span>.thirdNumber == p.thirdNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedPhoneNumber</span> <span class="keyword">extends</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExtendedPhoneNumber</span><span class="params">(<span class="keyword">int</span> firstNumber, <span class="keyword">int</span> secondNumber, <span class="keyword">int</span> thirdNumber)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(firstNumber, secondNumber, thirdNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Instance 1 hashcode : 42</span><br><span class="line">Instance 2 hashcode : 42</span><br><span class="line"></span><br><span class="line">java.lang.AssertionError: </span><br><span class="line">Expected :null</span><br><span class="line">Actual   :제니</span><br><span class="line"> &lt;Click to see difference&gt;</span><br></pre></td></tr></table></figure></p><p>이 결과로 보아하니, hashcode가 같으면 같은 버킷에 LinkedList로 저장되면서 객체에 대해 equals 체크를 통해 데이터를 조회하는 것으로 판단 된다.</p><blockquote><p>설사 두 인스턴스가 같은 버킷에 담았더라도, hashmap.get메서드는 null을 반환한다.<br>만약 hashcode가 다른경우에는 동치성비교를 실행하지 않도록 최적화 되어있기 때문이다.<br>hashcode가 같더라도 동치성비교(equals)를 실행하여 객체에 대한 값(value)를 조회한다.</p></blockquote><h1 id="좋은-해시-함수-만들기">좋은 해시 함수 만들기</h1><p>좋은 해시 함수는 서로 다른 인스턴스에 대해 다른 해시코드를 반환한다.<br>이게 바로 hashcode의 세번째 규약이 요구하는 속성이다.<br>이상적인 해시 함수는 주어진 (서로 다른) 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">31</span>;</span><br><span class="line">    <span class="comment">//1. int변수 result를 선언한 후 첫번째 핵심 필드에 대한 hashcode로 초기화 한다.</span></span><br><span class="line">    <span class="keyword">int</span> result = Integer.hashCode(firstNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 기본타입 필드라면 Type.hashCode()를 실행한다</span></span><br><span class="line">    <span class="comment">//Type은 기본타입의 Boxing 클래스이다.</span></span><br><span class="line">    result = c * result + Integer.hashCode(secondNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 참조타입이라면 참조타입에 대한 hashcode 함수를 호출 한다.</span></span><br><span class="line">    <span class="comment">//4. 값이 null이면 0을 더해 준다.</span></span><br><span class="line">    result = c * result + address == <span class="keyword">null</span> ? <span class="number">0</span> : address.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 필드가 배열이라면 핵심 원소를 각각 필드처럼 다룬다.</span></span><br><span class="line">    <span class="keyword">for</span> (String elem : arr) &#123;</span><br><span class="line">      result = c * result + elem == <span class="keyword">null</span> ? <span class="number">0</span> : elem.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 배열의 모든 원소가 핵심필드이면 Arrays.hashCode를 이용한다.</span></span><br><span class="line">    result = c * result + Arrays.hashCode(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. result = 31 * result + c 형태로 초기화 하여 </span></span><br><span class="line">    <span class="comment">//result를 리턴한다.</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>hashcode를 다 구현했다면, 이 메서드가 동치인 인스턴스에 대해 똑같은 해시코드를 반환할지 TestCase를 작성해보자</li><li>파생필드는 hashcode 계산에서 제외해도 된다.</li><li>equals 비교에 사용되지 않는 필드는 반드시 제외한다.</li><li>31 * result를 곱하는 순서에 따라 result 값이 달라진다.</li><li>곱할 숫자를 31로 지정하는 이유는 31이 홀수 이면서 소수(prime)이기 때문이다. 2를 곱하는 것은 shift연산과 같은 결과를 내기 떄문에 추천하지 않는다.</li><li>31을 이용하면 (i &lt;&lt; 5) - i와 같이 최적화 할 수 있다.</li></ul><h1 id="hashcode를-편하게-만들어-주는-모듈">hashcode를 편하게 만들어 주는 모듈</h1><ul><li>Objects.hash()<ul><li>내부적으로 AutoBoxing이 일어나 성능이 떨어진다.</li></ul></li><li>Lombok의 @EqualsAndHashCode</li><li>Google의 @AutoValue</li></ul><h1 id="hashcode를-재정의-할-때-주의-할-점">hashcode를 재정의 할 때 주의 할 점!</h1><ul><li>불변 객체에 대해서는 hashcode 생성비용이 많이 든다면, hashcode를 캐싱하는 것도 고려하자<ul><li>스레드 안전성까지 고려해야 한다.</li></ul></li><li>성능을 높인답시고 hashcode를 계산할 떄 핵심필드를 생략해서는 안된다.<ul><li>속도는 빨라지겠지만, hash품질이 나빠져 해시테이블 성능을 떨어뜨릴 수 있다 (Hashing Collision)</li></ul></li><li>hashcode 생성규칙을 API사용자에게 공표하지 말자<ul><li>그래야 클라이언트가 hashcode값에 의지한 코드를 짜지 않는다.</li><li>다음 릴리즈 시, 성능을 개선할 여지가 있다.</li></ul></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 11. equals를 재정의하려거든 hashcode도 재정의하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/12/effective-java-item11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 10. Equals는 일반 규약을 지켜 재정의하라</title>
      <link>https://jaehun2841.github.io/2019/01/10/effective-java-item10/</link>
      <guid>https://jaehun2841.github.io/2019/01/10/effective-java-item10/</guid>
      <pubDate>Thu, 10 Jan 2019 12:14:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;equals 메서드는 Object 클래스에 구현된 메서드로 객체 내의 정보들에 대한 동등성(equality) 비교를 목적으로 하는 메서드이다.&lt;br&gt;
equals 메서드를 잘못 작성하게 되면 의도하지 않는 결과
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>equals 메서드는 Object 클래스에 구현된 메서드로 객체 내의 정보들에 대한 동등성(equality) 비교를 목적으로 하는 메서드이다.<br>equals 메서드를 잘못 작성하게 되면 의도하지 않는 결과들이 초래되므로 웬만하면 변경하지 않는 것이 좋다.</p><h1 id="equals를-재정의-하지-않아도-되는-경우">equals를 재정의 하지 않아도 되는 경우</h1><ul><li>각 인스턴스가 본질적으로 고유 한 경우 - 값이 아닌 동작을 표현하는 클래스의 경우 (Thread가 좋은 예이다.)</li><li>인스턴스의 논리적 동치성 (Logical Equality)를 검사할 일이 없는 경우 - <code>java.utils.regex.Pattern</code>의 equals는 내부의 정규표현식이 같은지를 검사하는 메서드이다.</li><li>상위 클래스에서 재정의한 equals가 하위 클래스에서도 적용 되는 경우 - Set, Map, List의 경우 Abstract(Type)의 equals를 쓴다.</li><li>클래스가 private이거나, package-private여서 equals를 호출할 일이 없는 경우</li><li>싱글턴을 보장하는 클래스(인스턴스 통제 클래스, Enum (열거타입)) 인 경우 - 객체 간 동등성, 동일성이 보장된다.</li></ul><h1 id="equals를-재정의-하는-경우-지켜야-할-규약">equals를 재정의 하는 경우 지켜야 할 규약</h1><p>equals를 재정의 해야 하는 경우는 객체 동일성(식별성(Object Identity))를 확인해야 하는 경우가 아니라<br>논리적 동치성(동등성(Logical equality))를 비교 하도록 재정의 되지 않았을 경우이다.</p><h2 id="반사성reflexivity">반사성(reflexivity)</h2><p><strong>null이 아닌 모든 참조 값 x에 대해 x.equals(x)를 만족해야한다.</strong><br>단순히 말하면 객체는 자기 자신과 비교했을 때 같아야 한다는 뜻이다.<br>이 조건을 만족하지 않는 예를 찾기가 더 어렵다.<br>만약 x.equals(x)가 성립하지 않는 객체라면, 컬렉션에서 contain 메서드를 사용하는 경우 방금 넣은 객체도 찾을 수 없을 것이다.</p><h2 id="대칭성-symmetry">대칭성 (symmetry)</h2><p><strong>null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true이면, y.equals(x)가 true를 만족해야 한다.</strong></p><p>예시 코드를 보면<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveString</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String s;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CaseInsensitiveString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s = Objects.requireNonNull(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> CaseInsensitiveString) &#123;</span><br><span class="line">      <span class="keyword">return</span> s.equalsIgnoreCase(((CaseInsensitiveString) o).s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> String) &#123; <span class="comment">//한 방향으로만 작동!!</span></span><br><span class="line">      <span class="keyword">return</span> s.equalsIgnoreCase((String) o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 클래스를 기반으로<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CaseInsensitiveString caseInsensitiveString = <span class="keyword">new</span> CaseInsensitiveString(<span class="string">"Test"</span>);</span><br><span class="line">String test = <span class="string">"test"</span>;</span><br><span class="line">System.out.println(caseInsensitiveString.equals(test)); <span class="comment">//true</span></span><br><span class="line">System.out.println(test.equals(caseInsensitiveString)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p><p>위의 코드를 실행하게 되면, x.equals(y)가 true일 때, y.equals(x)가 false이므로 <code>대칭성</code>이 깨지는 코드가 된다.<br>String 클래스에서는 CaseInsensitiveString의 존재를 모르기 때문에 false가 날 수 밖에 없는 상황이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CaseInsensitiveString&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> CaseInsensitiveString(<span class="string">"Test"</span>));</span><br><span class="line">System.out.println(list.contain(<span class="string">"test"</span>)); <span class="comment">//false or true</span></span><br></pre></td></tr></table></figure></p><p>위의 예제의 경우는 JDK버전에 따라 다를 수 있다. x.equals(y)로 비교할 수 도 있고, y.equals(x)로 비교될 수 있기 때문이다.</p><p>위의 내용을 수정한다면, String과의 비교는 포기해야 한다.<br>같은 CaseInsensitiveString 타입인 경우에만 비교하도록 한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o <span class="keyword">instanceof</span> CaseInsensitiveString &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="추이성-transitivity">추이성 (transitivity)</h2><p><strong>null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y)가 true이고, y.equals(z)가 true이면 x.equals(z)도 true가 되야 한다는 조건이다.</strong></p><p>Point클래스와 ColorPoint 클래스를 가지고 예시를 들어보겠다.<br>(ColorPoint는 Point클래스를 확장(extends)한 클래스이다.)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint a = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line">Point b = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">ColorPoint c = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</span><br></pre></td></tr></table></figure></p><p>위와 같은 인스턴스 a, b, c가 있다.이 때, a.equals(b)와 b.equals(c) 일 때, a.equals(c)가 되는 과정을 살펴 보자</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Point p = (Point) o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x == p.x &amp;&amp; <span class="keyword">this</span>.y == p.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="대칭성이-위배되는-case">대칭성이 위배되는 case</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; <span class="keyword">this</span>.color == ((ColorPoint) o).color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 처럼 ColorPoint 클래스의 equals 메서드를 재정의 했다면...<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint a = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line">Point b = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//false</span></span><br><span class="line">System.out.println(b.equals(a)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><ol><li><p><code>a.equals(b)</code>를 보면 a는 ColorPoint이기 떄문에 ColorPoint 클래스에서 재정의 된 equals 메서드를 타게 된다.<br>이렇게 되면 첫번째 if 조건에서 걸리게 된다. b는 Point이지만 ColorPoint는 아니기 떄문이다.<br>따라서 <code>a.equals(b)</code>는 <code>false</code>가 된다.</p></li><li><p><code>b.equals(a)</code>를 보면 b는 Point클래스이기 떄문에 Point클래스의 equals메서드를 타게 된다.<br>이렇게 되면 ColorPoint는 Point클래스를 상속하고 있기 때문에 첫번째 if조건을 통과하게 되고,<br>int x, int y값을 기준으로만 비교하기 떄문에 값이 참이 된다.<br>따라서 <code>b.equals(a)</code>는 <code>true</code>가 된다.</p></li></ol><p>위의 예시는 equals 정의 규약 중 하나인 대칭성을 위반하고 있으므로 다시 작성해야 한다.</p><h3 id="추이성이-위반되는-case">추이성이 위반되는 case</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.</span></span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> o.equals(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//o가 ColorPoint이면 색상까지 비교한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; <span class="keyword">this</span>.color == ((ColorPoint) o).color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 처럼 ColorPoint 클래스의 equals메서드를 다시 재정의 했다면..<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint a = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line">Point b = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">ColorPoint c = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</span><br><span class="line"></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//true</span></span><br><span class="line">System.out.println(b.equals(c)); <span class="comment">//true</span></span><br><span class="line">System.out.println(a.equals(c)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p><ol><li><code>a.equals(b)</code>를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.<br>b가 Point인 경우이기 때문에 2번쨰 if 절을 타게 되어 Point의 x, y정보만 비교하게 되므로 결과는 <code>true</code>이다.</li><li><code>b.equals(c)</code>를 보면 b는 Point클래스의 인스턴스이므로 Point클래스의 equals 메서드를 실행하게 된다.<br>Point의 x, y정보만 비교하게 되므로 결과는 <code>true</code>이다.</li><li><code>a.equals(c)</code>를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.<br>하지만, c가 ColorPoint클래스의 인스턴스이므로 x, y값 뿐만아니라 color까지 비교하게되어 결과는 <code>false</code>이다.</li></ol><p>이렇게 a.equals(b)는 <code>true</code>를 만족하고 b.equals(c)는 <code>true</code>를 만족하지만 a.equals(c)는 <code>false</code>가 되므로<br>위의 코드는 equals 정의 규약 중 <code>추이성</code>을 위반하는 코드가 된다.</p><h3 id="무한-재귀-infinite-recursion이-발생하는-case">무한 재귀 (Infinite Recursion)이 발생하는 case</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmellPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Smell smell;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.</span></span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> SmellPoint)) <span class="keyword">return</span> o.equals(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//o가 ColorPoint이면 색상까지 비교한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; <span class="keyword">this</span>.smell == ((SmellPoint) o).smell;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 처럼 Point를 상속받는 SmellPoint라는 클래스도 추가되었다고 가정해보자</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point cp = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line">Point sp = <span class="keyword">new</span> SmellPoint(<span class="number">1</span>, <span class="number">2</span>, Smell.SWEET);</span><br><span class="line"></span><br><span class="line">System.out.println(cp.equals(sp));  <span class="comment">//?</span></span><br></pre></td></tr></table></figure></p><p>위와 같이 ColorPoint와 SmellPoint에 대해 equals비교를 한다고 하면 어떻게 될까??<br>이렇게 되면 두번째 if절에서 무한재귀(Infinite Recursion)이 발생하게 된다.</p><p>무슨 의미인지 자세히 설명하면, cp는 ColorPoint 클래스의 인스턴스이기 때문에<br><code>cp.equals(sp)</code> 코드는 ColorPoint 클래스의 재정의 된 equals 메서드를 타게 된다.<br>이렇게 되면 두번째 if에서 걸리게 된다. 왜냐하면 o는 <strong>SmellPoint</strong> 타입이기 때문에 <code>!(o instanceof ColorPoint)</code> 이 조건식이 true가 된다.<br>그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 o는 SmellPoint 클래스의 인스턴스이기 때문에<br>SmellPoint 클래스의 재정의된 equals메서드를 타게 된다.</p><p>다시 SmellPoint클래스의 입장에서 보게되면 두번째 if에서 걸리게 된다.<br>여기서 o는 ColorPoint타입이기 때문에 <code>!(o instanceof ColorPoint)</code> 이 조건식이 true가 된다.<br>그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 다시 ColorPoint 클래스의 재정의된 equals메서드를 타게 된다.</p><p>이런 작업이 계속 재귀적으로 호출 되면서, 결국은 StackOverflowError를 내며 프로그램이 죽는 참사를 맞이 하게 될 것이다.</p><h3 id="리스코프-치환-원칙-solid">리스코프 치환 원칙 (SOLID)</h3><p>SOLID원칙 중 3번째인 리스코프 치횐 원칙이란?</p><blockquote><p>자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.</p></blockquote><p>쉽게 말해서, 자식클래스에서 부모클래스의 기능을 수행하지 못하는 건 리스코프 치환원칙에 위배된다고 볼 수 있다.</p><p>위에서 equals 재정의에 실패해서 다시 또 변경하였다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Point&gt; unitCircle = Set.of(<span class="keyword">new</span> Point(<span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">   <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">   <span class="keyword">new</span> Point(-<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">   <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onUnitCircle</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unitCircle.contains(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o == <span class="keyword">null</span> || o.getClass() != <span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point p = (Point) o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x == p.x &amp;&amp; <span class="keyword">this</span>.y = p.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이번에는 주어진 점이 반지름이 1인 원안에 포함되는지에 대한 여부를 판단하는 로직이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint cp = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">0</span>, Color.RED);</span><br><span class="line">System.out.println(Point.onUnitCircle(cp)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p><p>ColorPoint는 Point를 상속한 클래스이다.<br>실제 oint.onUnitCircle 메서드의 contains 메서드에서 Set내의 element들에 대한 equals 비교가 일어나게 된다.<br>하지만 equals 메서드 첫번째 if문에서 걸리게 된다.<br>ColorPoint 객체가 파라미터로 전달되어 null은 아니지만,<br>두번째 조건식인 o.getClass()에서 <code>ColorPoint.class</code>가 도출되고 this.getClass()에서는 <code>Point.class</code>가 도출되게 된다.</p><p>위 조건식 때문에 ColorPoint 클래스는 Point클래스로서 equals메서드 내에서 활용되지 못했기 때문에<br>위 코드는 리스코프 치환원칙에 위배되는 코드로 전락해 버렸다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(o == <span class="keyword">null</span> || !(o <span class="keyword">instanceof</span> Point)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Point p = (Point) o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x == p.x &amp;&amp; <span class="keyword">this</span>.y = p.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>차라리 이런식으로 instanceof를 사용했다면 좋았을 것이다.</p><h2 id="상속-대신-컴포지션composition을-사용하라">상속 대신 컴포지션(Composition)을 사용하라</h2><p>구체클래스의 하위클래스에서 값을 추가할 방법은 없지만, 우회방법이 있다.<br>상속 대신에 Point 변수를 갖도록 Composition(구성)을 이용하는 방법이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ColorPoint &#123;</span><br><span class="line">  <span class="keyword">private</span> Point point;</span><br><span class="line">  <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.point = <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    <span class="keyword">this</span>.color = Objects.requireNonNull(color);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Point <span class="title">asPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.point;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ColorPoint cp = (ColorPoint) o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.point.equals(cp) &amp;&amp; <span class="keyword">this</span>.color.equals(cp.color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이와 같이 컴포지션을 이용하면 상속에 때문에 발생하는 대칭성, 추이성, 리스코프 치환원칙에 위배되지 않는 코드를 작성할 수 있다.</p><h2 id="일관성-consistency">일관성 (consistency)</h2><p><strong>null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.</strong><br>두 객체가 같다면 수정되지 않는 한 영원히 같아야 함을 의미한다.<br>가변객체는 비교시점에 따라 서로 달라질 수 있지만 불변객체라면 한번 다르면 끝까지 달라야 한다. (그래서 불변객체로 만드는 것이 나을때가 많다)</p><p>하지만, 클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들어서는 안된다.<br><code>java.net.URL</code> 클래스는 URL과 매핑된 host의 IP주소를 이용해 비교한다.<br>당장 우리회사 서버만 봐도 L4스위치가 적용되있기 때문에 로드밸런싱이 되어 같은 도메인주소라도 그떄그떄 나오는 IP정보가 다르다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL url1 = <span class="keyword">new</span> URL(<span class="string">"www.site-name.co.kr"</span>);</span><br><span class="line">URL url2 = <span class="keyword">new</span> URL(<span class="string">"www.site-name.co.kr"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(url1.equals(url2)); <span class="comment">//?</span></span><br></pre></td></tr></table></figure></p><p>실제 url1이 10.0.0.1 이라는 IP가 나왔다면<br>url2의 경우 10.0.0.1이 나올수도 있고, 같은 대역에 있는 10.0.0.2가 나올 수도 있다.<br>그렇기 떄문에 equals의 결과가 가변적이기 떄문에 다른 자원의 개입으로 인해 equals의 일관성이 깨지게 된다.</p><p>그렇게 때문에 항상 equals를 사용할 때는 메모리에 존재하는 객체만을 사용한 결정적(deterministic) 계산만 수행해야 한다.</p><h2 id="not-null">not null</h2><p><strong>null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다</strong>기본적으로 x.equals(null)이 true가 되는 일은 생각하기 어렵다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//불필요</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x == o.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하지만 equals를 재정의 할 때 이러한 코드를 작성하기 쉽다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> MyClass)) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//묵시적 null검사</span></span><br><span class="line">  MyClass clazz = (MyClass) o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x == clazz.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이런식으로 instanceof 키워드를 통해 묵시적 null 체크를 하는 방법이 좋다.</p><h1 id="요약-정리">요약 정리</h1><h2 id="equals-구현-절차">equals 구현 절차</h2><ul><li><code>==</code> 연산자를 사용해 입력된 파라미터와 자기자신이 같은 객체인지 검사한다. (동일성 검사 - Object Identity)<ul><li>성능 향상을 위한 코드</li><li>equals가 복잡할 때 같은 참조를 가진 객체에 대한 비교를 안하기 위함</li></ul></li><li><code>instanceof</code> 연산자로 파라미터의 타입이 올바른지 체크<ul><li>묵시적 null체크 용도로도 사용</li><li>equals중에서는 같은 interface를 구현한 클래스끼리도 비교하는 경우가 있다.</li></ul></li><li>입력을 올바른 타입으로 형변환한다.<ul><li>Object타입의 파라미터를 비교하고자 하는 타입으로 형변환한다.</li><li>앞서 <code>instanceof</code> 연산을 수행했기 때문에 100% 성공한다.</li></ul></li><li>파라미터 Object 객체와 자기자신의 대응되는 핵심필드들이 모두 일치하는지 확인한다.<ul><li>하나라도 다르면 false를 리턴</li><li>만약 interface기반의 비교가 필요하다면 필드정보를 가져오는 메서드가 interface에 정의되어있어야하고,<br>구현체 클래스에서는 메서드를 재정의 해야한다.</li></ul></li><li>float, double을 제외한 기본타입은 <code>==</code>을 통해 비교</li><li>참조(reference) 타입은 equals를 통해 비교</li><li>float, double은 Float.compare(float, float)와 Double.compare(double, double)로 비교한다.<ul><li>Float.Nan, -0.0f등을 비교하기 위함이다.</li><li>이 메서드들은 float -&gt; Float, double -&gt; Double로 변환하는 오토박싱 기능이 수반되므로 성능상 좋지 못하다.</li></ul></li><li>배열의 모든 원소가 핵심 필드라면 Arrays.equals를 사용하자</li><li>null이 의심되는 필드는 Objects.equals(obj, obj)를 이용해 NullPointerException을 예방하자</li><li>성능을 올리고자 한다면<ul><li>다를 확률이 높은 필드부터 비교한다.</li><li>비교하는 비용(시간복잡도)이 적은 비교를 먼저 수행</li></ul></li></ul><h1 id="주의사항">주의사항</h1><ul><li>equals를 재정의 했다면, 대칭성, 추이성, 일관성에 대한 체크를 꼭 하자 (테스트 케이스 작성 요망)</li><li>equals를 작성할 때는 hashcode도 반드시 재정의하자 (Item.11)</li><li>너무 복잡하게 해결하려 들지 말자</li><li>equals의 파라미터는 Object이외의 타입으로 선언하지 말자 (컴파일 에러 발생)</li><li>구글에서 만든 @AutoValue을 이용해서 equals와 hashcode를 자동으로 재정의해보자 (Lombok의 @EqualsAndHashCode도 있다.)</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 10. equals는 일반 규약을 지켜 재정의하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/10/effective-java-item10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 9. Try-Finally 보다는 Try-With-Resources를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/01/08/effective-java-item9/</link>
      <guid>https://jaehun2841.github.io/2019/01/08/effective-java-item9/</guid>
      <pubDate>Tue, 08 Jan 2019 07:30:31 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Java 라이브러리 중에는 close메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, Connection등이 있다.&lt;br&gt;
자원 닫기는 클라이언트가 놓치기 쉽기 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Java 라이브러리 중에는 close메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, Connection등이 있다.<br>자원 닫기는 클라이언트가 놓치기 쉽기 때문에 예측할 수 없는 성능 문제로 이어지기도 한다.</p><p>나의 경우에도 신입 때 JDBC로 개발을 해야 했던 적이 있었는데,<br>DB의 max-connection이 10이어서 11번째 호출 시 부터는 JDBCException이 발생하는 오류를 겪은 적이 있다.<br>알고 보니 하나의 메서드에서 Connection 객체에 대한 참조를 해제 하지 않아 계속 Connection을 물고 있는 상황이었다.<br>Spring을 사용하면서는 Mybatis나 JPA같은 프레임웍 내에서 자원에 대한 관리를 해주기 때문에 이런 일을 만날 일은 없게 되었다.</p><p>하지만 예전처럼 JDBC를 사용하거나, IO관련 작업을 할 때는 반드시 close를 통해 자원에 대한 해제가 필요하다.<br>이전에는 finallizer를 통해 했다고는 아는데 이전 장에서 봤듯이 안 쓰는것이 좋다.<br>그리고 try-catch-finally 구문을 통해 Exception이 발생하더라도, finally 절에서 close를 호출 하도록 했는데, 코드가 복잡해 지고, finally 절 내에서 Exception이 발생하는 경우도 있기 때문에 이를 방지하기 위해 더 더러운 코드를 생산하는 일이 적지 않았다.</p><p>옛날에 자주 사용해 본 아주아주 슬픈 코드이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCExam</span> </span>&#123;</span><br><span class="line">  Connection connection;</span><br><span class="line">  Statement statement;</span><br><span class="line">  ResultSet resultSet;</span><br><span class="line"></span><br><span class="line">  String driverName = <span class="string">"oracle.jdbc.driver.OracleDriver"</span>;</span><br><span class="line">  String url = <span class="string">"oracle:thin:localhost:1521:ORCL"</span>;</span><br><span class="line">  String user = <span class="string">"scott"</span>;</span><br><span class="line">  String password = <span class="string">"tiger"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JDBCExam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Class.forName(driverName);</span><br><span class="line">          connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">"[로드 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">"[연결 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  connection.close();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  statement.close();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  resultSet.close();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">              System.out.println(<span class="string">"[닫기 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="autocloseable">AutoCloseable</h1><p>JDK 1.7 부터 try-with-resources 구문이 추가 되었고, <code>AutoCloseable</code> 인터페이스가 추가되었다. 이 인터페이스가 나오고 부터 Java의 close를 지원하는 클래스에서 AutoCloseable을 구현하도록 변경되었다.</p><h1 id="try-with-resources">try-with-resources</h1><p>try 절에 AutoCloseable을 구현한 클래스에 대한 인스턴스를 선언하게 되면 try절이 종료되는 시점에 AutoCloseable 인터페이스의 close() 메서드를 자동으로 호출 한다. 그렇기 때문에 이전처럼 finally 구문에서 별도로 자원에 대한 해제를 하지 않아도 된다.</p><p>위의 예시코드를 try-with-resources 구문으로 바꿔보았다.<br>위의 코드보다는 한층 깔끔해 짐을 볼 수 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String driverName = <span class="string">"oracle.jdbc.driver.OracleDriver"</span>;</span><br><span class="line">    String url = <span class="string">"oracle:thin:localhost:1521:ORCL"</span>;</span><br><span class="line">    String user = <span class="string">"scott"</span>;</span><br><span class="line">    String password = <span class="string">"tiger"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDBCExam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">             Statement statement = connection.prepareStatement(<span class="string">"select * from member"</span>);</span><br><span class="line">             ResultSet resultSet = statement.getResultSet();</span><br><span class="line">             )&#123;</span><br><span class="line">            Class.forName(driverName);</span><br><span class="line">            String name = resultSet.getString(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"회원명 : "</span> + name);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"[로드 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"[연결 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 9. try-finally 보다는 try-with-resources를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/08/effective-java-item9/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
