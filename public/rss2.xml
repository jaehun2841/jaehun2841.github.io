<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Carrey`s 기술블로그</title>
    <link>https://jaehun2841.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 22 Dec 2019 10:48:46 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Custom @Enable Annotation 만들어보기</title>
      <link>https://jaehun2841.github.io/2019/12/22/2019-12-22-spring-import/</link>
      <guid>https://jaehun2841.github.io/2019/12/22/2019-12-22-spring-import/</guid>
      <pubDate>Sun, 22 Dec 2019 07:04:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;multi-모듈-프로젝트에서-발생하는-일&quot;&gt;Multi 모듈 프로젝트에서 발생하는 일&lt;/h1&gt;
&lt;p&gt;Maven, Gradle을 이용해서 멀티 모듈을 구성하다 보면 각 모듈 별로 중복된 Bean을 계속 생성 코드를 만드는 경우가 있습니다.&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="multi-모듈-프로젝트에서-발생하는-일">Multi 모듈 프로젝트에서 발생하는 일</h1><p>Maven, Gradle을 이용해서 멀티 모듈을 구성하다 보면 각 모듈 별로 중복된 Bean을 계속 생성 코드를 만드는 경우가 있습니다.<br>(ex: Datasource, TransactionManager 등등)</p><blockquote><p>예시 : Custom Module에서만 사용하는 JPA 환경 구성입니다.<br>일반적으로 하나의 DataSource를 사용하신다면, Spring AutoConfiguration을 이용하면 편리하게 구성하실 수 있습니다.<br>하지만 실무에서는 DataSource를 2개 이상 구성해서 쓰는 경우도 있기에, 직접 경험한 예시를 사용하게 되었습니다.</p></blockquote><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EntityScan</span>(basePackages = &#123;<span class="string">"com.your.packages.module1"</span>&#125;)</span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>(basePackages = &#123;<span class="string">"com.your.packages.module1"</span>&#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module_1_Configuration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.custom-module.datasource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> HikariConfig <span class="title">hikariConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariConfig();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@FlywayDatasource</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    EntityManagerFactoryBuilder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">    DataSource dataSource</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="string">"com.your.packages.module1"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EntityScan</span>(basePackages = &#123;<span class="string">"com.your.packages.module2"</span>&#125;)</span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>(basePackages = &#123;<span class="string">"com.your.packages.module2"</span>&#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module_2_Configuration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.custom-module.datasource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> HikariConfig <span class="title">hikariConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariConfig();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    EntityManagerFactoryBuilder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">    DataSource dataSource</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="string">"com.your.packages.module2"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 두 Configuation 코드는 99% 같은 코드입니다.<br>하지만 왜 같은 코드 두개를 짰을까요?</p><p>첫 번째는 packages 설정이 달랐습니다.</p><ul><li>packages(&quot;com.your.packages.module1&quot;)</li><li>packages(&quot;com.your.packages.module2&quot;)</li></ul><p>두 번째는 EntityScan, EnableJpaRepositories의 basePackages 설정이 달랐습니다.</p><ul><li>basePackages = {&quot;com.your.packages.module1&quot;}</li><li>basePackages = {&quot;com.your.packages.module2&quot;}</li></ul><p>세 번째는</p><ul><li>module1에서는 DataSource Bean에 <code>@FlywayDataSource</code> annotation이 있고</li><li>module2에서는 DataSource Bean에 <code>@FlywayDataSource</code> annotation이 없습니다.</li></ul><p>코드가 거의 같더라도, 약간의 설정이 다르다는 이유로 거의 같은 두 개의 Configuration을 사용했습니다.</p><h1 id="리팩토링1-enablecustomdatasource">리팩토링1 - @EnableCustomDataSource</h1><p>Spring을 사용하다 보면 @Enable~ 하는 Annotation을 자주 보았을 것이고, 실제로도 많이 사용해 보셨을 겁니다.</p><ul><li>EnableCaching</li><li>EnableTransactionManagement</li><li>EnableJpaRepositories</li><li>EnableConfigurationProperties</li><li>EnableAsync</li></ul><p>이 처럼 많은 Enable Annotation들을 Spring에서 사용하고 있고, 실제로 개발자가 해야할 귀찮은<br>Configuration이나 BeanPostProcessing 같은 처리들을 손쉽게 하도록 도와줍니다.</p><p>그렇기 때문에 이번 리팩토링도 Spring의 이런 부분을 벤치마킹하여 <code>@EnableCustomDataSource</code> 를 한번 만들어 보겠습니다.</p><p>최종적인 모습은 아래와 같은 코드로 깔끔하게 리팩토링을 하는 그림이면 좋겠네요</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCustomDataSource</span>(basePackage = &#123;<span class="string">"com.your.packages.module1"</span>&#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module1Configuration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="리팩토링2-다른-enable~-annotation-내부는-어떻게-생겼을까">리팩토링2 - 다른 @Enable~ Annotation 내부는 어떻게 생겼을까?</h1><p><img src="./EnableAsync.png" alt="EnableAsync"></p><p><img src="./EnableConfigurationProperties.png" alt="EnableConfigurationProperties"></p><p><img src="./EnableJpaRepositories.png" alt="EnableJpaRepositories"></p><p>혹시 3개의 Annotation의 공통점이 보이시나요?<br>모두 <code>@Import</code> Annotation을 통해 어떤 class를 import하고 있습니다.<br>대부분의 Enable의 Annotation은 위와 같이 Configuration 클래스를 Import하는 형식으로 많이 작성되고 있습니다.<br>(이외에는 SpringAutoConfiguration으로 작동하는 것들도 있는 것 같습니다.)</p><h1 id="리팩토링3-enablecustomdatasource-생성">리팩토링3 - @EnableCustomDataSource 생성</h1><p>위 에서 많은 개발자들이 만든 @Enable Annotation 생성 방식을 모방하여 만들어 보겠습니다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.Type)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(??.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>일단 @EnableCustomDataSource를 만들었습니다.<br>근데 @Import Annotation에 지정할 Configuration Class가 없어서.. 어떻게 해야 할지 잘 모르겠네요.<br>위에는 2개의 Configuration이 있는데 말이죠</p><h1 id="리팩토링-4-importselector를-이용한-선택적-configuration-사용">리팩토링 4 - ImportSelector를 이용한 선택적 Configuration 사용</h1><p>spring-context 라이브러리에서는 @Import Annotation processing에 대한 3가지 Interface를 지원합니다.</p><ul><li>ImportSelector</li><li>ImportBeanDefinitionRegistrar</li><li>ImportAware</li></ul><p>먼저 ImportSelector를 사용하여 선택적으로 Configuration을 사용해 보겠습니다.ImportSelector는 Annotation Attribute의 값에 따라 Import할 Configuration을 지정할 수 있습니다.</p><p>그렇기 때문에 @EnableCustomDataSource의 Attribute를 수정해보았습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.Type)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(CustomDataSourceConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">  <span class="function">Module <span class="title">module</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Module &#123; ONE, TWO &#125;</span><br></pre></td></tr></table></figure></p><p>ImportSelector를 구현한 CustomDataSourceConfigurationSelector 코드를 구성하였습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceConfigurationSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//find annotation attribute (module)</span></span><br><span class="line">    Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">    AnnotationAttributes attributes = AnnotationAttributes.fromMap(metaData);</span><br><span class="line">    Module <span class="keyword">module</span> = attributes.getEnum(<span class="string">"module"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//determine configuration class</span></span><br><span class="line">    String configurationClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">module</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> ONE:</span><br><span class="line">          configurationClass = Module_1_Configuration.class.getName();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TWO:</span><br><span class="line">          configurationClass = Module_2_Configuration.class.getName();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;configurationClass&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Module1의 CustomDataSourceConfiguration에서 Module.ONE이라고 설정을 정의해주면<br>Module_1_Configuration에 대한 설정을 Import할 수 있습니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCustomDataSource</span>(<span class="keyword">module</span> = Module.ONE)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="리팩토링-5-importbeandefinitionregistrar를-이용한-직접-bean-생성하기">리팩토링 5 - ImportBeanDefinitionRegistrar를 이용한 직접 Bean 생성하기</h1><p>ImportBeanDefinitionRegistrar를 이용하면 직접 beanRegistry에 Bean을 등록할 수 있습니다.</p><blockquote><p>하지만 추천하는 방식은 아닙니다.<br>실제로 Bean이 등록되는 순서를 제어하기 어렵기 때문에 원하는대로 실행이 되지 않을 수 있습니다.<br>토비의 스프링 ver2에서도 가급적이면 사용을 하지 않을 것을 권장하고 있습니다.</p></blockquote><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">"customDataSourceConfiguration"</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">      Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">      AnnotationAttributes attributes = AnnotationAttributes.fromMap(metaData);</span><br><span class="line">      EnableCustomDataSource.Module <span class="keyword">module</span> = attributes.getEnum(<span class="string">"module"</span>);</span><br><span class="line"></span><br><span class="line">      AbstractBeanDefinition beanDefinition = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">module</span>) &#123;</span><br><span class="line">          <span class="keyword">case</span> ONE:</span><br><span class="line">              beanDefinition = BeanDefinitionBuilder</span><br><span class="line">                      .rootBeanDefinition(Module_1_Configuration.class)</span><br><span class="line">                      .getBeanDefinition();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> TWO:</span><br><span class="line">              beanDefinition = BeanDefinitionBuilder</span><br><span class="line">                      .rootBeanDefinition(Module_2_Configuration.class)</span><br><span class="line">                      .getBeanDefinition();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      registry.registerBeanDefinition(BEAN_NAME, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.Type)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(CustomDataSourceBeanDefinitionRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">  <span class="function">Module <span class="title">module</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="리팩토링-6-importaware를-이용한-annoataion-attribute-주입">리팩토링 6 - ImportAware를 이용한 Annoataion attribute 주입</h1><p>마지막으로 ImportAware입니다.</p><p>ImportAware interface는 @Import하는 Configuration class에 @Import 메타 annoatation을 사용하는 annoatation의 attribute를 사용할 수 있도록 해줍니다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.Type)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(CustomDataSourceConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.custom-module.datasource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> HikariConfig <span class="title">hikariConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariConfig();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    EntityManagerFactoryBuilder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">    DataSource dataSource</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="string">"com.your.packages.module2"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(annoatationMetadata: AnnotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//use @EnableCustomDataSource annotation attribute</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 @EnableCustomDataSource annotation의 attribute를 사용할 수 있는 메서드를 제공합니다.</p><p>그렇게 되면, 애초에 2개의 파일로 분리되었던</p><ul><li>Module_1_Configuration</li><li>Module_2_Configuration</li></ul><p>이 두가지 파일을 하나로 합칠 수 있을 것 같습니다.</p><p>두개의 파일을 하나로 합쳐서 CustomDataSourceConfiguration이라는 class를 만들고<br>@EnableCustomDataSource annotation에서 @Import 해보겠습니다.</p><h2 id="basepackages-attribute-추가">basePackages attribute 추가</h2><p>@EnableCustomDataSource annotation의 attribute를 조금 변경해 보겠습니다.<br>여태까지 사용한 module attribute는 이제 의미가 없을 것 같습니다.<br>파일을 하나로 합치기로 했기 때문이죠</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.Type)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(CustomDataSourceConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">  String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Module1Configuration class에 드디어 우리가 원하던 대로 @EnableCustomDataSource를 사용해보게 되었습니다.<br>이게 껍데기는 완성되었고 내부 로직만 잘 구성하면 될듯 합니다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCustomDataSource</span>(basePackages = &#123;<span class="string">"com.your.package.module1"</span>&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module1Configuration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="importaware-메서드-코드-구성">ImportAware 메서드 코드 구성</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String[] basePackages;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.custom-module.datasource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> HikariConfig <span class="title">hikariConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariConfig();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    EntityManagerFactoryBuilder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">    DataSource dataSource</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="keyword">this</span>.basePackages)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(annoatationMetadata: AnnotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//use @EnableCustomDataSource annotation attribute</span></span><br><span class="line">    Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">    AnnotationAttributes attributes = AnnotationAttributes.fromMap(metaData);</span><br><span class="line">    </span><br><span class="line">    String[] basePackages = attributes.get(<span class="string">"basePackages"</span>);</span><br><span class="line">    <span class="keyword">this</span>.basePackages = basePackages; <span class="comment">// initialize member variable basePackages</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CustomDataSourceConfiguration을 @Import를 통해 Import하게 되면 @Bean 메서드 보다 setImportMetadata가 먼저 실행됩니다.<br>(이유는 ImportAwareBeanPostProcessor에 의해 @Configuration Bean 초기화 이전에 setImportMetadata 메서드가 실행되기 때문입니다.)</p><blockquote><p>주의: ImportAware를 구현한 Configuration class에는 반드시 @Configuration Annotation을 붙여야 합니다.그래야 Spring 내부적으로 ConfigurationClassPargser가 작동할 때 scan 되어 나중에 ImportAwareBeanPostProcessor에 의해 Post Processing이 될 수 있습니다.</p></blockquote><h1 id="리팩토링-7-아직-끝나지-않았다">리팩토링 7 - 아직 끝나지 않았다.</h1><p>아직 끝나지 않았습니다.</p><p>Configuration class를 두 개로 나눈 두번째 이유 @EntityScan, @EnableJpaRepositories의 basePackages에 대한 설정이 다르기 때문입니다.<br>이 문제를 해결하기 위해서는 Spring에서 제공하는 @AliasFor annoataion을 사용해 보았습니다.</p><p><img src="./AliasFor.png" alt="AliasFor"></p><p>@AliasFor Annotation은 Spring 4.2에서 추가된 Annotation입니다.</p><ul><li>AliasFor을 이용해 Attribute의 다른 속성에 값을 바인딩 할 수 있습니다.<br>위의 예시처럼 value로 들어온 값을 attribute의 값에 바인딩</li><li>Annotation의 메타 Annotation의 attribute에 값을 바인딩 할 수 있습니다.<strong>(우리는 이 기능을 사용해 보도록 할 것입니다.)</strong></li></ul><blockquote><p>주의: Spring framework 5.2 하위버전에서 AliasFor이 Array에 대해서는 잘 적용이 안되는 이슈가 있었습니다.<br>이 이슈는 Spring framework 5.2, Springboot 2.2.0 이후에는 잘 적용이 됩니다.<br>혹시나 적용이 안되시는 분은 Spring version up을 권장드립니다.</p></blockquote><h2 id="enablecustomdatasource-수정">@EnableCustomDataSource 수정</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.Type)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@EntityScan</span> <span class="comment">// meta annotation으로 추가</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span> <span class="comment">// meta annotation으로 추가</span></span><br><span class="line"><span class="meta">@Import</span>(CustomDataSourceConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">  <span class="meta">@AliasFor</span>(annotation = EntityScan.class, attribute = <span class="string">"basePackages"</span>)</span><br><span class="line">  String[] jpaEntityBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">  <span class="meta">@AliasFor</span>(annotation = EnableJpaRepositories.class, attribute = <span class="string">"basePackages"</span>)</span><br><span class="line">  String[] jpaRepositoriesBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@AliasFor annotation은 @Repeatable meta annotation이 없기 때문에 하나의 메서드에 중첩해서 사용할 수 없습니다.<br>그렇기 때문에 @EntityScan에 대한 basePackages를 설정할 수 있는 메서드와<br>@EnableJpaRepositories에 대한 basePacakges를 설정할 수 있는 메서드로 분리 하였습니다.</p><p>위와 같이 설정해 주면<br>jpaEntityBasePackages -&gt; <code>EntityScan.basePackages</code>로 바인딩 됩니다.<br>jpaRepositoriesBasePackages -&gt; <code>EnableJpaRepositories.basePackages</code>로 바인딩 됩니다.<br>물론 EnableCustomDataSource의 attribute로도 사용할 수 있습니다.</p><h2 id="customdatasourceconfiguration-수정">CustomDataSourceConfiguration 수정</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String[] basePackages;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(annoatationMetadata: AnnotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//use @EnableCustomDataSource annotation attribute</span></span><br><span class="line">    Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">    AnnotationAttributes attributes = AnnotationAttributes.fromMap(metaData);</span><br><span class="line">    </span><br><span class="line">    String[] basePackages = attributes.get(<span class="string">"jpaEntityBasePackages"</span>);</span><br><span class="line">    <span class="keyword">this</span>.basePackages = basePackages; <span class="comment">// initialize member variable basePackages</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>attribute가 변경되어 attribute명을 변경하였습니다.</p><h1 id="리팩토링-8-flywaydatasource는-어째요">리팩토링 8 - FlywayDataSource는 어째요?</h1><p>Flyway는 Database 자동 구성에 도움을 주는 라이브러리입니다.<br>(저장된 sql을 versioning하고 내부적으로 version관리를 하여 자동으로 Database를 초기화 하도록 해줍니다.)</p><p>이런 FlywayDatasource는 보통 하나의 모듈에서만 초기화 하게됩니다.<br>보통 하나의 DataSource만 사용하는 상황에서는 Flyway를 적용하는 대상도 하나이기 때문에 문제가 안되지만<br>지금과 같은 다중 DataSource를 사용하는 상황에서는 제약이 생길 수 있습니다.</p><p>그래서 @FlywayDataSource annotation을 지정하여 이 DataSource에 Flyway를 적용할 지 말지 결정할 수 있습니다.<br>여기서는 Springboot에서 제공하는 @ConditionalOnProperty를 이용하여 Bean 생성을 해보도록 하겠습니다.</p><p><img src="./ConditionalOnProperty.png" alt="ConditionalOnProperty"></p><ul><li><strong>prefix</strong>: 사용하고자 하는 property의 prefix입니다.</li><li><strong>name</strong>: Condition에 유효한 property인지 테스트할 property명</li><li><strong>havingValue</strong>: prefix + name property의 값이 어떤 value일 경우 조건식이 참이 될지 결정하는 값입니다.</li><li><strong>matchIfMissing</strong>: property를 찾을 수 없는 경우 조건식의 default 값을 정의합니다.</li></ul><h2 id="property-추가">property 추가</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.custom.datasource.flyway.enable = true</span><br></pre></td></tr></table></figure></p><p>이와 같이 custom property를 추가해보겠습니다. (custom datasource에 대한 flyway를 쓸지 말지에 대한 설정입니다.)</p><h2 id="customdatasourceconfiguration-수정">CustomDataSourceConfiguration 수정</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.custom-module.datasource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> HikariConfig <span class="title">hikariConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariConfig();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ConditionalOnProperty</span>(</span><br><span class="line">    prefix = <span class="string">"spring.custom.datasource.flyway"</span>, </span><br><span class="line">    name = [<span class="string">"enable"</span>],</span><br><span class="line">    havingValue = <span class="string">"true"</span>, </span><br><span class="line">    matchIfMissing = <span class="keyword">false</span></span><br><span class="line">  )</span><br><span class="line">  <span class="meta">@FlywayDataSource</span></span><br><span class="line">  <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceUsingFlyway</span><span class="params">(HikariConfig hikariConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ConditionalOnProperty</span>(</span><br><span class="line">    prefix = <span class="string">"spring.custom.datasource.flyway"</span>, </span><br><span class="line">    name = [<span class="string">"enable"</span>],</span><br><span class="line">    havingValue = <span class="string">"false"</span>, </span><br><span class="line">    matchIfMissing = <span class="keyword">true</span></span><br><span class="line">  )</span><br><span class="line">  <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  EntityManagerFactoryBuilder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">    DataSource dataSource</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="string">"com.your.packages.module2"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(annoatationMetadata: AnnotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//use @EnableCustomDataSource annotation attribute</span></span><br><span class="line">    Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">    AnnotationAttributes attributes = AnnotationAttributes.fromMap(metaData);</span><br><span class="line">    </span><br><span class="line">    String[] basePackages = attributes.get(<span class="string">"jpaEntityBasePackages"</span>);</span><br><span class="line">    <span class="keyword">this</span>.basePackages = basePackages; <span class="comment">// initialize member variable basePackages</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이와 같이 CustomDataSourceConfiguration에서 DataSource Bean을 생성하는 코드를 두개로 하고<br><code>spring.custom.datasource.flyway.enable</code> 값에 따라 자동으로 Bean을 생성하도록 코드를 구성하였습니다.</p><p>FlywayDataSource를 사용하는 module에만 <code>spring.custom.datasource.flyway.enable</code> 를 추가하여 Bean이 생성되도록 하였습니다.<br>FlywayDataSource를 사용하지 않는 module에는 <code>spring.custom.datasource.flyway.enable</code> 를 설정하지 않고 사용하여<br>일반적인 DataSource만 사용하도록 구성하였습니다.</p><h1 id="참고">참고</h1><ul><li>토비의 스프링 Ver.2</li><li><a href="https://medium.com/@circlee7/spring-conditional-annotation-e288ccf6b536" target="_blank" rel="noopener">Spring Conditional annotation</a></li><li><a href="https://docs.spring.io/spring/docs/4.2.0.RC2_to_4.2.0.RC3/Spring%20Framework%204.2.0.RC3/org/springframework/core/annotation/AliasFor.html" target="_blank" rel="noopener">Spring AliasFor</a></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/12/22/2019-12-22-spring-import/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Rest Docs를 이용한 API 문서 만들기</title>
      <link>https://jaehun2841.github.io/2019/08/04/2019-08-04-spring-rest-docs/</link>
      <guid>https://jaehun2841.github.io/2019/08/04/2019-08-04-spring-rest-docs/</guid>
      <pubDate>Sun, 04 Aug 2019 06:02:21 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Spring Rest API 문서를 자동으로 생성하고자  할 때, 보통 Swagger로 많이 사용하지만
이번에는 Spring Rest Docs를 사용하여 API 문서를 자동으로 작성 할 수 있도록 해봤습니다.&lt;/p&gt;
&lt;p&gt;포스팅에 작성된 코드는 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Spring Rest API 문서를 자동으로 생성하고자  할 때, 보통 Swagger로 많이 사용하지만이번에는 Spring Rest Docs를 사용하여 API 문서를 자동으로 작성 할 수 있도록 해봤습니다.</p><p>포스팅에 작성된 코드는 <a href="https://github.com/jaehun2841/spring-rest-docs-example" target="_blank" rel="noopener">https://github.com/jaehun2841/spring-rest-docs-example</a> 에서 참고하시길 바랍니다.</p><h1 id="spring-rest-docs란">Spring Rest Docs란</h1><p>Spring Rest Docs는 테스트 코드를 기반으로 자동으로 API문서를 작성할 수 있게 해주는 프레임워크입니다.<br>그렇기 때문에 반드시 <code>Test가 통과되어야 문서가 작성</code> 된다는 장점이 있습니다.<br>(그렇기 때문에 API Spec이 변경되거나 추가/삭제 되는 부분에 대해 항상 테스트 코드를 수정하여야 하며, API 문서가 최신화 될 수 있도록 해줍니다.)<br>기본적으로 asciidoc을 사용하여 문서를 작성합니다 . (asciidoc은 마크다운과 비슷하게 html문서를 작성할 수 있는 언어입니다.)<br>원하는 경우에는 mark down을 사용할 수도 있지만, 이번 포스트에서는 asciidoc을 이용하여 API 문서를 작성해 보도록 하겠습니다.</p><h1 id="spring-rest-docs-architecture">Spring Rest Docs Architecture</h1><p><img src="./asciidoctor.png" alt="asciidoctor-task"></p><ul><li>Test Case를 수행하면 산출물이 &lt;document-name&gt;.adoc 파일로 /build/generate-snippets 디렉토리에 생성됩니다. (default path)</li><li>/src/docs/asciidoc 디렉토리에 /build/generate-snippets에 있는 adoc 파일을 include하여 문서를 생성할 수 있습니다.<ul><li>/build/generate-snippets/*.adoc 파일들은 API Request, Response에 대한 명세들만 있는 파일이고</li><li>/src/docs/asciidoc/*.adoc 파일들이 실제 사용자에게 html파일로 변환되어 제공되는 API 문서 파일입니다.</li><li>따라서 /src/docs/asciidoc/*.adoc 에 API 문서를 작성하고,<br>필요한 API Request, Response Spec은 자동 생성된 /build/generate-snippets/*.adoc 파일들을 이용해 표현해줍니다.</li><li>이렇게 하면 향후 API Spec이 변경되더라도, 문서를 수정하지 않아도 되는 장점이 있습니다.</li></ul></li><li>이렇게 생성된 asciidoc 문서는 AsciidoctorTask를 통해 html 문서로 processing 되어 /build/asciidoc/html5 하위에 html문서로 생성됩니다.<ul><li>html 문서가 생성되는 기준은 /src/docs/asciidoc/*.adoc 파일을 기준으로 생성됩니다.</li></ul></li></ul><h2 id="예시">예시</h2><h3 id="srcdocsasciidoc-디렉토리-내에-html로-제공될-문서를-asciidoc으로-작성">/src/docs/asciidoc 디렉토리 내에 html로 제공될 문서를 asciidoc으로 작성</h3><p><img src="./src-template.png" alt="docuement-templates"></p><h3 id="test-case의-산출물">Test Case의 산출물</h3><ul><li>/build/generated-snippets 디렉토리 하위에 생성</li><li>Request, Response Spec에 대한 정보를 생성</li><li>/src/docs/asciidoc/*.adoc 파일에서 include해서 사용<img src="./snippets.png" alt="snippets"></li></ul><h3 id="srcdocsasciidoc-디렉토리-adoc파일을-기반으로-생성된-html-파일">/src/docs/asciidoc 디렉토리 adoc파일을 기반으로 생성된 html 파일</h3><p><img src="./processed-html.png" alt="processed-html"></p><p>자세한 부분은 아래 예시를 따라하면서 보시면 좋을 것 같습니다.</p><h1 id="spring-rest-docs-시작하기">Spring Rest Docs 시작하기</h1><h2 id="개발-스펙">개발 스펙</h2><ul><li>Spring Boot 2.1.6.RELEASE</li><li>Junit 5</li><li>Kotlin 1.3.41 (저희 팀에서 코틀린만 써서 코틀린이 편하네요)</li><li>Gradle 5.4.1</li><li>Asciidoctor 1.5.9.2</li></ul><h2 id="test-library">Test Library</h2><p>Spring Rest Docs는 3가지 테스트 라이브러리를 지원합니다.</p><ul><li>MockMvc (@WebMvcTest)</li><li>WebTestClient (Mono / Flux, @WebTestClient)</li><li>Rest Assured (IntegrationTest, @SpringBootTest)</li></ul><p>API 문서를 작성할 때 Spring Mvc를 사용하는 환경이라면 가장 가볍게 돌릴 수 있는게 MockMvc를 사용하는 것이라 생각합니다.<br>그래서 이번 포스팅에서는 MockMvc를 사용한 예제로만 진행하도록 하겠습니다.</p><h2 id="gradle-설정">Gradle 설정</h2><h3 id="asciidoctor-plugin-설정">asciidoctor plugin 설정</h3><p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        kotlinVersion = <span class="string">'1.3.41'</span></span><br><span class="line">        springBootVersion = <span class="string">"2.1.6.RELEASE"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$springBootVersion"</span></span><br><span class="line">        classpath <span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'org.asciidoctor.convert'</span> version <span class="string">'1.5.9.2'</span></span><br><span class="line">    id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.1.6.RELEASE'</span></span><br><span class="line">    id <span class="string">"io.spring.dependency-management"</span> version <span class="string">"1.0.5.RELEASE"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"groovy"</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"org.springframework.boot"</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"io.spring.dependency-management"</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin-kapt"</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'com.example'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="string">'1.8'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    set(<span class="string">'snippetsDir'</span>, file(<span class="string">"build/generated-snippets"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line">    testImplementation(<span class="string">"org.springframework.boot:spring-boot-starter-test"</span>) &#123;</span><br><span class="line">        exclude <span class="string">group:</span> <span class="string">"junit"</span>, <span class="string">module:</span> <span class="string">"junit"</span></span><br><span class="line">    &#125;</span><br><span class="line">    testImplementation <span class="string">"org.junit.jupiter:junit-jupiter-api"</span></span><br><span class="line">    testImplementation <span class="string">"org.junit.jupiter:junit-jupiter-params"</span></span><br><span class="line">    testRuntimeOnly <span class="string">"org.junit.jupiter:junit-jupiter-engine"</span></span><br><span class="line">    testImplementation <span class="string">'org.springframework.restdocs:spring-restdocs-mockmvc'</span></span><br><span class="line">    testImplementation <span class="string">"com.nhaarman:mockito-kotlin:1.6.0"</span></span><br><span class="line">    implementation <span class="string">"org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlinVersion"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kapt &#123;</span><br><span class="line">    useBuildCache = <span class="literal">true</span></span><br><span class="line">    correctErrorTypes = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">    outputs.dir snippetsDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asciidoctor &#123;</span><br><span class="line">    inputs.dir snippetsDir</span><br><span class="line">    dependsOn test <span class="comment">//test Task 이후에 실행될 수 있도록 Dependency를 설정</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asciidoctor.doFirst &#123;</span><br><span class="line">    println <span class="string">"=====start asciidoctor"</span></span><br><span class="line">    <span class="comment">//asciidoctor 실행전 기존에 생성된 API 문서 삭제</span></span><br><span class="line">    delete file(<span class="string">'src/main/resources/static/docs'</span>)</span><br><span class="line">&#125;</span><br><span class="line">asciidoctor.doLast &#123;</span><br><span class="line">    println <span class="string">"=====finish asciidoctor"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task copyDocument(<span class="string">type:</span> Copy) &#123;</span><br><span class="line">    dependsOn asciidoctor</span><br><span class="line">    from file(<span class="string">"build/asciidoc/html5"</span>)</span><br><span class="line">    <span class="comment">// resources/static/docs 로 복사하여 서버가 돌아가고 있을때 /docs/index.html 로 접속하면 볼수 있음</span></span><br><span class="line">    into file(<span class="string">"src/main/resources/static/docs"</span>)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build &#123;</span><br><span class="line">    dependsOn copyDocument</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bootJar &#123;</span><br><span class="line">    archiveName = <span class="string">'app.jar'</span></span><br><span class="line">    dependsOn asciidoctor</span><br><span class="line">    <span class="comment">//실제 배포 시, BOOT-INF/classes가 classpath가 됩니다.</span></span><br><span class="line">    from (<span class="string">"$&#123;asciidoctor.outputDir&#125;/html5"</span>) &#123;</span><br><span class="line">        into <span class="string">"BOOT-INF/classes/static/docs"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileKotlin &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        freeCompilerArgs = [<span class="string">"-Xjsr305=strict"</span>]</span><br><span class="line">        jvmTarget = <span class="string">"1.8"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileTestKotlin &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        freeCompilerArgs = [<span class="string">"-Xjsr305=strict"</span>]</span><br><span class="line">        jvmTarget = <span class="string">"1.8"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar.enabled = <span class="literal">false</span></span><br><span class="line">bootJar.enabled = <span class="literal">true</span></span><br><span class="line">bootJar.mainClassName = <span class="string">'com.example.restdocs.RestdocsApplication'</span></span><br></pre></td></tr></table></figure></p><ul><li><code>testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc'</code> : mockMvc 테스트를 통해 API adoc 파일을 생성해주도록 하는 라이브러리 입니다.</li><li><code>id 'org.asciidoctor.convert' version '1.5.9.2'</code> : asciidoc 파일을 html 파일로 processing 해주는 플러그인 입니다.</li><li><code>asciidoctor</code> :  asciidoc 파일을 html 파일로 processing 해주는 Gradle Task를 정의합니다.</li></ul><h2 id="user-api-코드-작성">User API 코드 작성</h2><h2 id="usercontrollerkt">UserController.kt</h2><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Suppress(<span class="meta-string">"SpringJavaInjectionPointsAutowiringInspection"</span>)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/user"</span>)</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>(</span><br><span class="line">        <span class="keyword">val</span> userService: UserService</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/&#123;userId&#125;"</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable(value = <span class="meta-string">"userId"</span>)</span> userId: <span class="type">Long</span>)</span></span>: Response&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> searchUser = userService.search(userId)</span><br><span class="line">    <span class="keyword">return</span> Response.success(searchUser)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(<span class="meta">@RequestBody</span> userDto: <span class="type">UserDto</span>)</span></span>: Response&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> createUser = userService.create(User(name = userDto.name, address = userDto.address, age = userDto.age))</span><br><span class="line">    <span class="keyword">return</span> Response.success(createUser)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@PutMapping(<span class="meta-string">"/&#123;userId&#125;"</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">updateUser</span><span class="params">(<span class="meta">@PathVariable(<span class="meta-string">"userId"</span>)</span> userId: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="meta">@RequestBody</span> userDto: <span class="type">UserDto</span>)</span></span>: Response&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> updateUser = userService.update(User(id = userId, name = userDto.name, address = userDto.address, age = userDto.age))</span><br><span class="line">    <span class="keyword">return</span> Response.success(updateUser)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@DeleteMapping(<span class="meta-string">"/&#123;userId&#125;"</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable(value = <span class="meta-string">"userId"</span>)</span> userId: <span class="type">Long</span>)</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    userService.delete(userId)</span><br><span class="line">    <span class="keyword">return</span> Response.success()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping(<span class="meta-string">"/&#123;userId&#125;/role/&#123;roleId&#125;"</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">grantRole</span><span class="params">(<span class="meta">@PathVariable(value = <span class="meta-string">"userId"</span>)</span> userId: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="meta">@PathVariable(value = <span class="meta-string">"roleId"</span>)</span> roleId: <span class="type">Long</span>)</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">     userService.grantRole(userId = userId, roleId = roleId)</span><br><span class="line">    <span class="keyword">return</span> Response.success()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="userservicekt">UserService.kt</h2><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">search</span><span class="params">(userId: <span class="type">Long</span>)</span></span>: User?</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(user: <span class="type">User</span>)</span></span>: User?</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(user: <span class="type">User</span>)</span></span>: User?</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(userId: <span class="type">Long</span>)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">grantRole</span><span class="params">(userId: <span class="type">Long</span>, roleId: <span class="type">Long</span>)</span></span>: User?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="responsekt">Response.kt</h2><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">val</span> code: <span class="built_in">Int</span>,</span><br><span class="line">        <span class="keyword">val</span> message: String,</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span>: T?,</span><br><span class="line">        <span class="keyword">val</span> error: T?</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">success</span><span class="params">()</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; = success(<span class="literal">null</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">success</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>?)</span></span>: Response&lt;T&gt; = Response(<span class="number">200</span>, <span class="string">"OK"</span>, <span class="keyword">data</span>, <span class="literal">null</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">error</span><span class="params">(error: <span class="type">T</span>?)</span></span>: Response&lt;T&gt; = Response(<span class="number">500</span>, <span class="string">"Server Error"</span>, <span class="literal">null</span>, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="userkt">User.kt</h2><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">        <span class="keyword">val</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">val</span> name: String,</span><br><span class="line">        <span class="keyword">val</span> age: <span class="built_in">Int</span>,</span><br><span class="line">        <span class="keyword">val</span> address: String,</span><br><span class="line">        <span class="keyword">var</span> roles: MutableList&lt;Role&gt; = mutableListOf()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="test-코드-작성">Test 코드 작성</h2><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(RestDocumentationExtension::class, SpringExtension::class)</span> <span class="comment">// (1)</span></span><br><span class="line"><span class="meta">@WebMvcTest(UserController::class, secure = false)</span> <span class="comment">// (2)</span></span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span> <span class="comment">// (3)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> mockMvc: MockMvc <span class="comment">// (4)</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@MockBean</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> userService: UserService <span class="comment">// (5)</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> `user search api docs`<span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    given(userService.search((eq(<span class="number">1</span>L))))</span><br><span class="line">            .willReturn(User(<span class="number">1</span>, <span class="string">"배달이"</span>, <span class="number">10</span>, <span class="string">"서울특별시 송파구 올림픽로 295"</span>)) <span class="comment">// (6)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    <span class="keyword">val</span> resultActions = mockMvc.perform(</span><br><span class="line">            RestDocumentationRequestBuilders.<span class="keyword">get</span>(<span class="string">"/user/&#123;userId&#125;"</span>, <span class="number">1</span>)</span><br><span class="line">                    .header(<span class="string">"x-api-key"</span>, <span class="string">"API-KEY"</span>)</span><br><span class="line">                    .accept(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">    ).andDo(MockMvcResultHandlers.print()) <span class="comment">// (7)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//then</span></span><br><span class="line">    resultActions</span><br><span class="line">            .andExpect(status().isOk) <span class="comment">// (8)</span></span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-search"</span>, <span class="comment">// (9)</span></span><br><span class="line">                            getDocumentRequest(), <span class="comment">// (10)</span></span><br><span class="line">                            getDocumentResponse(), <span class="comment">// (11)</span></span><br><span class="line">                            requestHeaders(*header()),  <span class="comment">// (12)</span></span><br><span class="line">                          pathParameters(userIdPathParameter()),  <span class="comment">// (13)</span></span><br><span class="line">                            responseFields(*common())  <span class="comment">// (14)</span></span><br><span class="line">                                    .andWithPrefix(<span class="string">"data."</span>, *user()) </span><br><span class="line">                                    .andWithPrefix(<span class="string">"data.roles[]."</span>, *role())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;...&#125; <span class="comment">//중략..</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserDto</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"""</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        "name": "배달이",</span></span><br><span class="line"><span class="string">        "age": 10,</span></span><br><span class="line"><span class="string">        "address": "서울특별시 송파구 올림픽로 295"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    """</span>.trimIndent()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">header</span><span class="params">()</span></span>: Array&lt;HeaderDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arrayOf(headerWithName(<span class="string">"x-api-key"</span>).description(<span class="string">"Api Key"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">userIdPathParameter</span><span class="params">()</span></span>: ParameterDescriptor &#123;</span><br><span class="line">    <span class="keyword">return</span> parameterWithName(<span class="string">"userId"</span>).description(<span class="string">"USER ID"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">roleIdPathParameter</span><span class="params">()</span></span>: ParameterDescriptor &#123;</span><br><span class="line">    <span class="keyword">return</span> parameterWithName(<span class="string">"roleId"</span>).description(<span class="string">"ROLE ID"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">common</span><span class="params">()</span></span>: Array&lt;FieldDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arrayOf(</span><br><span class="line">            fieldWithPath(<span class="string">"code"</span>).type(JsonFieldType.NUMBER).description(<span class="string">"응답 코드"</span>),</span><br><span class="line">            fieldWithPath(<span class="string">"message"</span>).type(JsonFieldType.STRING).description(<span class="string">"응답 메세지"</span>),</span><br><span class="line">            subsectionWithPath(<span class="string">"error"</span>).type(JsonFieldType.OBJECT).description(<span class="string">"에러 Data"</span>).optional(),</span><br><span class="line">            subsectionWithPath(<span class="string">"data"</span>).type(JsonFieldType.OBJECT).description(<span class="string">"응답 Data"</span>).optional()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">user</span><span class="params">()</span></span>: Array&lt;FieldDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arrayOf(</span><br><span class="line">            fieldWithPath(<span class="string">"id"</span>).type(JsonFieldType.NUMBER).description(<span class="string">"User ID"</span>),</span><br><span class="line">            fieldWithPath(<span class="string">"name"</span>).type(JsonFieldType.STRING).description(<span class="string">"이름"</span>),</span><br><span class="line">            fieldWithPath(<span class="string">"age"</span>).type(JsonFieldType.NUMBER).description(<span class="string">"나이"</span>),</span><br><span class="line">            fieldWithPath(<span class="string">"address"</span>).type(JsonFieldType.STRING).description(<span class="string">"주소"</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">role</span><span class="params">()</span></span>: Array&lt;FieldDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arrayOf(</span><br><span class="line">            fieldWithPath(<span class="string">"id"</span>).type(JsonFieldType.NUMBER).description(<span class="string">"Role ID"</span>).optional(),</span><br><span class="line">            fieldWithPath(<span class="string">"name"</span>).type(JsonFieldType.STRING).description(<span class="string">"Role명"</span>).optional()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> RestApiDocumentUtils &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getDocumentRequest</span><span class="params">()</span></span>: OperationRequestPreprocessor &#123; <span class="comment">// (10)</span></span><br><span class="line">    <span class="keyword">return</span> Preprocessors.preprocessRequest(</span><br><span class="line">            modifyUris()</span><br><span class="line">              .scheme(<span class="string">"http"</span>)</span><br><span class="line">              .host(<span class="string">"user.api.com"</span>)</span><br><span class="line">              .removePort(),</span><br><span class="line">            Preprocessors.prettyPrint()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getDocumentResponse</span><span class="params">()</span></span>: OperationResponsePreprocessor &#123; <span class="comment">// (11)</span></span><br><span class="line">    <span class="keyword">return</span> Preprocessors.preprocessResponse(Preprocessors.prettyPrint())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="코드-설명">코드 설명</h3><ol><li>Junit5에서 Spring Rest Docs를 사용할 때, RestDocumentationExtension::class, SpringExtension::class Extension 두개를 사용합니다.<br>ExtendWith는 Junit 4 에서 RunWith와 같은 기능입니다.</li><li>@WebMvcTest annotation을 사용하여, mockMvc를 사용할 수 있는 환경을 설정합니다.</li><li>이 예제에서는 UserController에 대한 테스트와 API문서를 작성하므로, controller를 UserController로 지정합니다.</li><li>spring security를 사용하는 경우, <code>secure=false</code> 옵션을 통해 Spring Security 사용 안함으로 설정할 수 있습니다.</li><li>Spring Rest Docs에 대한 Auto Configuration을 설정합니다.</li><li>mockMvc를 사용하기 위해 MockMvc bean을 Autowiring 해줍니다.</li><li>UserService에 대한 Mocking을 위해 @MockBean annotation을 통해 Test Context에 bean으로 등록해줍니다.</li><li>UserService.search() function에 대한 stubbing을 해줍니다. (호출 시, return 되는 값 지정)</li><li>mockMvc를 이용하여, <code>GET /user/1</code> API를 호출 합니다.</li><li>API 호출 결과에 대해 간단한 status체크 정도로 테스트 항목을 추가했습니다.</li><li>andDo function으로 Asciidoc을 생성하도록 설정합니다.<br><code>user-search</code>는 테스트가 수행 된 후, adoc 파일이 생성될 디렉토리 이름입니다.<br><code>/build/generate-snippets/user-search/*.adoc</code> path에 adoc 파일이 생성됩니다.</li><li>DocumentRequest에 대한 설정을 추가합니다.</li><li>modifyUris()를 통해 adoc 파일에 어떤 도메인으로 API를 호출 할 지, 정의할 수 있습니다.(Default는 <code>http://localhost:8080</code> 입니다.)</li><li>Request Json을 이쁘장하게 출력하도록 해줍니다</li><li>DocumentResponse에 대한 설정을 추가합니다.</li><li>Response Json을 이쁘장하게 출력하도록 해줍니다</li><li>requestHeader 정보를 추가합니다.</li><li>path parameter 정보를 추가합니다.</li><li>responseFields 정보를 추가합니다.</li></ol><h2 id="document-생성하기">Document 생성하기</h2><p>asciidoctor를 이용하면 6개의 snippet 파일을 기본적으로 생성해줍니다.</p><h3 id="예시">예시</h3><ul><li><p><code>&lt;output-directory&gt;/&lt;document-name&gt;/curl-request.adoc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[source,bash]</span><br><span class="line">----</span><br><span class="line">$ curl &apos;http://user.api.com/user/1&apos; -i -X GET \</span><br><span class="line">    -H &apos;Accept: application/json;charset=UTF-8&apos; \</span><br><span class="line">    -H &apos;x-api-key: API-KEY&apos;</span><br><span class="line">----</span><br></pre></td></tr></table></figure></p></li><li><p><code>&lt;output-directory&gt;/&lt;document-name&gt;/http-request.adoc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[source,http,options=&quot;nowrap&quot;]</span><br><span class="line">----</span><br><span class="line">GET /user/1 HTTP/1.1</span><br><span class="line">Accept: application/json;charset=UTF-8</span><br><span class="line">Host: user.api.com</span><br><span class="line">x-api-key: API-KEY</span><br><span class="line"></span><br><span class="line">----</span><br></pre></td></tr></table></figure></p></li><li><p><code>&lt;output-directory&gt;/&lt;document-name&gt;/http-response.adoc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[source,http,options=&quot;nowrap&quot;]</span><br><span class="line">----</span><br><span class="line">GET /user/1 HTTP/1.1</span><br><span class="line">Accept: application/json;charset=UTF-8</span><br><span class="line">Host: user.api.com</span><br><span class="line">x-api-key: API-KEY</span><br><span class="line"></span><br><span class="line">----</span><br></pre></td></tr></table></figure></p></li><li><p><code>&lt;output-directory&gt;/&lt;document-name&gt;/httpie-request.adoc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[source,bash]</span><br><span class="line">----</span><br><span class="line">$ http GET &apos;http://user.api.com/user/1&apos; \</span><br><span class="line">    &apos;Accept:application/json;charset=UTF-8&apos; \</span><br><span class="line">    &apos;x-api-key:API-KEY&apos;</span><br><span class="line">----</span><br></pre></td></tr></table></figure></p></li><li><p><code>&lt;output-directory&gt;/&lt;document-name&gt;/request-body.adoc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[source,http,options=&quot;nowrap&quot;]</span><br><span class="line">----</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;홍길동&quot;</span><br><span class="line">&#125;</span><br><span class="line">----</span><br></pre></td></tr></table></figure></p></li><li><p><code>&lt;output-directory&gt;/&lt;document-name&gt;/response-body.adoc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[source,options=&quot;nowrap&quot;]</span><br><span class="line">----</span><br><span class="line">&#123;</span><br><span class="line">  &quot;code&quot; : 200,</span><br><span class="line">  &quot;message&quot; : &quot;OK&quot;,</span><br><span class="line">  &quot;data&quot; : &#123;</span><br><span class="line">    &quot;id&quot; : 1,</span><br><span class="line">    &quot;name&quot; : &quot;배달이&quot;,</span><br><span class="line">    &quot;age&quot; : 10,</span><br><span class="line">    &quot;address&quot; : &quot;서울특별시 송파구 올림픽로 295&quot;,</span><br><span class="line">    &quot;roles&quot; : [ ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;error&quot; : null</span><br><span class="line">&#125;</span><br><span class="line">----</span><br></pre></td></tr></table></figure></p></li></ul><p>Optional하게 생성되는 snippet도 존재합니다.</p><ul><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/path-parameters.adoc.adoc</code> : Path Parameters에 대한 정보를 표로 나타냅니다.</li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/request-headers.adoc.adoc</code> : request header에 대한 정보를 표로 나타냅니다.</li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/request-fieldadoc</code> : request fields에 대한 정보를 표로 나타냅니다.</li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/response-fields.adoc</code> : response fields에 대한 정보를 표로 나타냅니다.</li></ul><h3 id="api-document-생성하기">API Document 생성하기</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ifndef::snippets[]</span><br><span class="line">:snippets: ../../../build/generated-snippets</span><br><span class="line">endif::[]</span><br><span class="line">:doctype: book</span><br><span class="line">:icons: font</span><br><span class="line">:source-highlighter: highlightjs</span><br><span class="line">:toc: left</span><br><span class="line">:toclevels: 4</span><br><span class="line">:sectlinks:</span><br><span class="line">:site-url: /build/asciidoc/html5/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">== Request</span><br><span class="line"></span><br><span class="line">=== [Request URL]</span><br><span class="line">....</span><br><span class="line">GET /user/&#123;userId&#125;</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">=== [Request Headers]</span><br><span class="line">include::&#123;snippets&#125;/user-search/request-headers.adoc[]</span><br><span class="line"></span><br><span class="line">=== [Request Path Parameters]</span><br><span class="line"></span><br><span class="line">include::&#123;snippets&#125;/user-search/path-parameters.adoc[]</span><br><span class="line"></span><br><span class="line">=== [Request HTTP Example]</span><br><span class="line"></span><br><span class="line">include::&#123;snippets&#125;/user-search/http-request.adoc[]</span><br><span class="line"></span><br><span class="line">== Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=== [Response Fields]</span><br><span class="line"></span><br><span class="line">include::&#123;snippets&#125;/user-search/response-fields.adoc[]</span><br><span class="line"></span><br><span class="line">=== [Response HTTP Example]</span><br><span class="line"></span><br><span class="line">include::&#123;snippets&#125;/user-search/http-response.adoc[]</span><br></pre></td></tr></table></figure></p><ul><li>/src/docs/asciidoc 디렉토리를 생성하고 user-search.adoc 파일을 생성합니다.</li><li>이 파일은 html로 변환될 adoc 파일입니다.</li><li>snippet에 대한 path를 지정하고 <code>include::</code> 를 통해 adoc 파일을 include하여 processing 할 수 있습니다.</li><li>include 된 파일은 include한 부분에 html 태그로 직접 삽입됩니다.</li><li>processing 된 html 파일은 <code>/build/docs/html5</code> 디렉토리에 생성됩니다 (default)</li><li>부가적으로 API 문서에 대한 내용을 작성하여 API 문서를 만들 수 있습니다. (ex: API 설명, 담당자, 주의사항)</li></ul><h1 id="html-문서-serving-해보기">HTML 문서 Serving 해보기</h1><p>Spring Rest Docs로 만들어진 API 문서의 최종 형태는 HTML 파일로 제공됩니다.<br>그렇기 때문에 Spring Static Resource Handler를 이용하여 간단하게 html 파일을 Serving하여 웹 브라우져를 통해 사용자에게 API문서를 제공 할 수 있습니다.</p><p>SpringBoot의 WebMvcConfigure를 상속하여 Configuration을 추가합니다.</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.restdocs.configuration</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Configuration</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.<span class="keyword">annotation</span>.ResourceHandlerRegistry</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.<span class="keyword">annotation</span>.WebMvcConfigurer</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span>: <span class="type">WebMvcConfigurer &#123;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addResourceHandlers</span><span class="params">(registry: <span class="type">ResourceHandlerRegistry</span>)</span></span> &#123;</span><br><span class="line">    registry.addResourceHandler(<span class="string">"/docs/**"</span>).addResourceLocations(<span class="string">"classpath:/static/docs/"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 설정을 추가하게 되면<br><code>localhost:8080/docs/index.html</code>  과 같이 <code>/docs/**</code> 패턴으로 유입되는 url에 대해<br>classpath 하위의 /static/docs/ 디렉토리 아래의 파일을 찾아 반환하도록 해줍니다.</p><p><img src="./static-resource-path.png" alt=""></p><h1 id="여러가지-function-사용해보기">여러가지 Function 사용해보기</h1><h2 id="pathparameters">PathParameters</h2><ul><li>API의 Path Parameter에 대한 Snippet을 생성합니다.</li><li>/build/generated-snippets/&lt;document-name&gt;/path-parameters.adoc 인 파일명으로 생성됩니다.</li><li>pathParameter(parameterWithName(&quot;key 명칭&quot;).description(&quot;key가 의미 하는 내용&quot;)) 으로 코드를 작성합니다.</li></ul><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-update"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(parameterWithName(<span class="string">"userId"</span>).description(<span class="string">"유저 ID"</span>)),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .andWithPrefix(<span class="string">"data."</span>, *user())</span><br><span class="line">                                    .andWithPrefix(<span class="string">"data.roles[]."</span>, *role())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><h2 id="requestheader">requestHeader</h2><ul><li>API의 Request Header에 대한 Snippet을 생성합니다.</li><li>/build/generated-snippets/&lt;document-name&gt;/request-headers.adoc 인 파일명으로 생성됩니다.</li><li>requestHeader(headerWithName(&quot;header-key명&quot;).description(&quot;header-key가 의미하는 내용&quot;))</li></ul><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">          .andExpect(status().isOk)</span><br><span class="line">          .andDo(</span><br><span class="line">                  document(</span><br><span class="line">                          <span class="string">"user-grant-role"</span>,</span><br><span class="line">                          getDocumentRequest(),</span><br><span class="line">                          getDocumentResponse(),</span><br><span class="line">                          requestHeaders(headerWithName(<span class="string">"api-auth-key"</span>).description(<span class="string">"API 인증 키"</span>)),</span><br><span class="line">                      pathParameters(userIdPathParameter(), roleIdPathParameter()),</span><br><span class="line">                          responseFields(*common())</span><br><span class="line">                                  .andWithPrefix(<span class="string">"data."</span>, *user())</span><br><span class="line">                                  .andWithPrefix(<span class="string">"data.roles[]."</span>, *role())</span><br><span class="line">                  )</span><br><span class="line">          )</span><br></pre></td></tr></table></figure></p><h2 id="fieldwithpath">fieldWithPath</h2><ul><li>API의 Request, Response Snippet을 구성하는 요소를 정의하는 가장 기본적인 function입니다.</li><li>fieldWithPath(&quot;key&quot;) 형태로 API Request, Response 내의 요소를 정의 할 수 있습니다.</li><li>Attributes<ul><li>description(&quot;내용&quot;) : Request, Response 내의 요소의 내용을 정의합니다.</li><li>type(JsonFieldType.TYPE) : Request, Response 내의 요소의 타입을 정의합니다.</li><li>optional() : Request, Response 내의 요소의 필수값 여부를 정의합니다. (optional()를 선언하면 필수값 아님)</li></ul></li></ul><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-grant-role"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter(), roleIdPathParameter()),</span><br><span class="line">                            responseFields(</span><br><span class="line">                            fieldWithPath(<span class="string">"code"</span>).type(JsonFieldType.NUMBER).description(<span class="string">"응답 코드"</span>),</span><br><span class="line">                fieldWithPath(<span class="string">"message"</span>).type(JsonFieldType.STRING).description(<span class="string">"응답 메세지"</span>),</span><br><span class="line">                subsectionWithPath(<span class="string">"error"</span>).type(JsonFieldType.OBJECT).description(<span class="string">"에러 Data"</span>).optional(),</span><br><span class="line">                subsectionWithPath(<span class="string">"data"</span>).type(JsonFieldType.OBJECT).description(<span class="string">"응답 Data"</span>).optional()</span><br><span class="line">      )</span><br><span class="line">                      .andWithPrefix(<span class="string">"data."</span>, *user())</span><br><span class="line">                      .andWithPrefix(<span class="string">"data.roles[]."</span>, *role())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><h2 id="subsectionwithpath">subSectionWithPath</h2><ul><li>API Request, Response Snippet을 구성하는 요소를 정의하는 function입니다.</li><li>요소의 하위를 선언하고 싶지 않거나, 가변적인 Request, Response가 오는 경우 사용하기 좋습니다.</li><li>subSectionWithPath는 root key가 존재하는 지만 체크하고 하위 key에 대한 체크는 하지 않습니다.</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"Parameter validation error"</span>,</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">4000</span>,</span><br><span class="line">  <span class="attr">"errors"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"field"</span>: <span class="string">"receivers[0].phone"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"010469090"</span>,</span><br><span class="line">      <span class="attr">"errorMessage"</span>: <span class="string">"유효하지 않은 수신자 번호입니다."</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같은 응답이 오는 경우</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-grant-role"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter(), roleIdPathParameter()),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .and(fieldWithPath(<span class="string">"errors"</span>).type(JsonFieldType.ARRAY).description(<span class="string">"에러 Data"</span>)) <span class="comment">//에러 발생!!</span></span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><p>아래와 같은 에러가 발생하게 됩니다.<br>에러 내용을 요약하자면, payload에 있는 정보를 문서화 하지 않았다는 에러입니다.<br>즉, errors 하위에 field, value, errorMessage 정보를 문서화 하지 않았기 때문에 발생하는 에러입니다.</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.restdocs.snippet.SnippetException: The following parts of the payload were not documented:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errors"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"field"</span>: <span class="string">"receivers[0].phone"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"010469090"</span>,</span><br><span class="line">      <span class="attr">"errorMessage"</span>: <span class="string">"유효하지 않은 수신자 번호입니다."</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하지만 subSectionWithPath를 사용하게 되면 errors 하위에 대한 정보는 문서화 하지 않겠다!를 의미하므로<br>에러가 발생하지 않고, errors 까지만 문서화 됩니다.</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-grant-role"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter(), roleIdPathParameter()),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .and(subSectionWithPath(<span class="string">"errors"</span>).type(JsonFieldType.ARRAY).description(<span class="string">"에러 Data"</span>)) </span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><h2 id="responsefieldand">responseField().and()</h2><ul><li>response에 대한 Field정보가 많은 경우 가독성을 해칠 수 있고, Field Snippet에 대한 재사용성이 떨어질 수 있습니다.</li><li>이럴때 and를 사용하면 좋습니다.</li><li>requestField(), responseField() 함수 뒤에 and() 함수를 사용하여 FieldDescriptor에 대한 Concatenation이 가능합니다.</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"OK"</span>,</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"배달이"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"address"</span>: <span class="string">"서울특별시 송파구 올림픽로 295"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 모든 요소가 1레벨인 Json이 Response로 오는 경우<br>code, message 는 모든 API Response에 대한 공통 요소 입니다.<br>id, name, age, address는 User API Response에만 응답오는 요소라고 할 떄,<br>두 요소에 대한 관리를 별도로 하여 재사용성을 높일 수 있습니다.</p><p>아래와 같이 and를 사용하여 Response에 대한 FieldDesciptor를 concatenation 하여 구성할 수 있습니다.</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-update"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter()),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .and(*user())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><h2 id="responsefieldandwithprefix">responseField().andWithPrefix()</h2><ul><li>and()의 사용예제와 동일합니다.</li><li>하지만, andWithPrefix는 key 앞에 prefix를 붙여 depth를 표현할 수 있도록 해줍니다.</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"OK"</span>,</span><br><span class="line">  <span class="attr">"data"</span> : &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"배달이"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"address"</span>: <span class="string">"서울특별시 송파구 올림픽로 295"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 data에 대한 키가 2레벨인 Json이 Response로 오는 경우<br>아래와 같이 and를 사용하여 Response에 대한 FieldDesciptor를 concatination 하여 구성할 수 있습니다.</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-update"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter()),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .andWithPrefix(<span class="string">"data."</span>, *user())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><h2 id="beneathpath">beneathPath</h2><ul><li>API를 사용하다 보면 특정 Field의 명세만 별도로 추출하여 문서화 하는 needs가 있을 수 있습니다.</li><li>beneathPath(&quot;data-path&quot;) function을 사용하면 특정 data-path에 대한 field를 별도의 snippet으로 생성해 줍니다.</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"OK"</span>,</span><br><span class="line">  <span class="attr">"data"</span> : &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"배달이"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"address"</span>: <span class="string">"서울특별시 송파구 올림픽로 295"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-search"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter()),</span><br><span class="line">                            responseFields(</span><br><span class="line">                                    beneathPath(<span class="string">"data"</span>).withSubsectionId(<span class="string">"user"</span>),</span><br><span class="line">                                    *user(),</span><br><span class="line">                                    subsectionWithPath(<span class="string">"roles"</span>).description(<span class="string">"User Role"</span>)</span><br><span class="line">                    )</span><br></pre></td></tr></table></figure></p><ul><li>data 필드 하위의 내용을 문서화 해줍니다.</li><li>beneathPath(&quot;data&quot;) : data 필드 하위의 내용이라는 Path 지정</li><li>.withSubsectionId(&quot;user&quot;) : response-fields-user.adoc이라고 SubSectionId로 response-fields.adoc 파일이 별도로 만들어 집니다.</li></ul><h1 id="spring-rest-docs-추가-기능">Spring Rest Docs 추가 기능</h1><h2 id="custom-필드-삽입하기">Custom 필드 삽입하기</h2><ul><li>Spring Rest Docs에서 기본적으로 제공하는 path, description, optional, type 이외에 다른 메타정보를 추가하고 싶을 때 Custom 필드를 만들어 사용할 수 있습니다.</li><li>AbstractDescriptor에서 제공하는 attributes라는 Map을 이용합니다.</li><li>저는 비고, 최대길이라는 필드를 표현하기 위해 Kotlin Extension Function을 이용하여 기능을 추가해보았습니다.</li><li>기본적으로 AbstractDescriptor의 attributes라는 Map에 key, value라는 내용을 넣어주면 됩니다.<br>(Java에서는 이 방식을 사용하세요)</li></ul><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : AbstractDescriptor&lt;T&gt;</span>&gt; AbstractDescriptor<span class="type">&lt;T&gt;</span>.<span class="title">remarks</span><span class="params">(remarks: <span class="type">String</span>)</span></span>: T &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.attributes(key(<span class="string">"remarks"</span>).value(remarks))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : AbstractDescriptor&lt;T&gt;</span>&gt; AbstractDescriptor<span class="type">&lt;T&gt;</span>.<span class="title">maxLength</span><span class="params">(length: <span class="type">Int</span>)</span></span>: T &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.attributes(key(<span class="string">"maxLength"</span>).value(length))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-update"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter()</span><br><span class="line">                              .maxLength(<span class="number">10</span>)</span><br><span class="line">                              .remarks(<span class="string">"User ID가 없는 경우는 먼저 생성하세요"</span>)),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .andWithPrefix(<span class="string">"data."</span>, *user())</span><br><span class="line">                                    .andWithPrefix(<span class="string">"data.roles[]."</span>, *role())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><p>위의 예제에서는 일단 ParameterDescriptor에 maxLength와 remark 속성을 추가 했습니다.<br>ParameterDescriptor 뿐만 아니라, AbstractDescriptor를 구현하는 모든 Descriptor에 적용이 가능합니다.<br>(FieldDescriptor, SubsectionDescriptor, HeaderDescriptor등...)</p><p>이렇게 추가한 속성을 snippet에 출력해보도록 하겠습니다.<br>위의 예시는 path parameter에 추가한 속성이므로, path-parameters snippet을 override하여 출력해 줄 수 있습니다.</p><h3 id="path-parameters-snippet-override">path-parameters snippet override</h3><ul><li>/test/org/springframework/restdocs/templates 하위에 path-parameters.snippet 파일을 새로 등록합니다.</li><li>snippet 파일은 mustache 문법을 사용합니다.</li><li>여기에 제가 추가한 최대길이, 비고 컬럼을 추가하였습니다.</li><li>mustache 문법 중 <code>#maxLength</code> 문법은 maxLength 속성이 존재하는가? 라는 if문과 비슷한 문법입니다.</li><li>반대되는 문법으로 <code>^maxLength</code> 문법은 maxLength 속성이 존재하지 않는가? 라는 문법입니다.</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.+&#123;&#123;path&#125;&#125;+</span><br><span class="line">|===</span><br><span class="line">|Parameter|Description|최대길이|비고</span><br><span class="line">&#123;&#123;#parameters&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;`+&#123;&#123;name&#125;&#125;+`&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;&#123;&#123;description&#125;&#125;&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;&#123;&#123;#maxLength&#125;&#125;&#123;&#123;maxLength&#125;&#125;&#123;&#123;/maxLength&#125;&#125;&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;&#123;&#123;#remarks&#125;&#125;&#123;&#123;remarks&#125;&#125;&#123;&#123;/remarks&#125;&#125;&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">&#123;&#123;/parameters&#125;&#125;</span><br><span class="line">|===</span><br></pre></td></tr></table></figure></p><h3 id="결과">결과</h3><p><img src="./add-path-parameter-custom-fields.png" alt="add-path-parameter-custom-fields"></p><h2 id="custom-snippet-생성하기">Custom Snippet 생성하기</h2><p>API 문서를 작성하다 보면, 특정 API와 관계없는 응답코드나, Status 값에 대한 명세를 정의하고 문서화 해야 할 요구사항이 있을 수 있습니다.<br>그런 경우 Custom Snippet을 생성하여 문서화하면, 별도로 응답코드나 Status가 추가되거나 변경되어도 항상 문서를 최신화 할 수 있습니다.</p><p>생성해야 할 것은 4가지 입니다.</p><ol><li>Test 용 Controller</li><li>Custom Snippet Template 파일</li><li>ResponseCodeSnippet 클래스 (AbstractFieldsSnippet 상속)</li><li>Test Code</li></ol><h3 id="test용-controller">Test용 Controller</h3><p>MockMvc 기반에서 생성되는 문서이다 보니 사용하지 않더라도, Test용 Controller가 하나 필요합니다.<br>실제 코드에 영향이 없도록 <code>/test</code> 디렉토리 하위에 Controller를 만들었습니다.</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponseCodeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/response-code"</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getResponseCode</span><span class="params">()</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Response.success()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="custom-snippet-template-파일">Custom Snippet Template 파일</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;title&#125;&#125;</span><br><span class="line">|===</span><br><span class="line">|Code|Message</span><br><span class="line">&#123;&#123;#fields&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;`+&#123;&#123;path&#125;&#125;+`&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;&#123;&#123;description&#125;&#125;&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">&#123;&#123;/fields&#125;&#125;</span><br><span class="line">|===</span><br></pre></td></tr></table></figure></p><ul><li>title을 변수로 받아서 출력할 예정입니다.</li><li>표에 출력할 필드는 code값과 description입니다.</li></ul><h3 id="responsecodesnippet-클래스">ResponseCodeSnippet 클래스</h3><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponseCodeSnippet</span></span>(</span><br><span class="line">        name: String, </span><br><span class="line">        descriptors: MutableList&lt;FieldDescriptor&gt;,</span><br><span class="line">        attributes: Map&lt;String, Any&gt;,</span><br><span class="line">        ignoreUndocumentedFields: <span class="built_in">Boolean</span></span><br><span class="line">) : AbstractFieldsSnippet(name, descriptors, attributes, ignoreUndocumentedFields) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getContentType</span><span class="params">(operation: <span class="type">Operation</span>)</span></span>: MediaType? &#123;</span><br><span class="line">    <span class="keyword">return</span> operation.response.headers.contentType</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getContent</span><span class="params">(operation: <span class="type">Operation</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">return</span> operation.response.content</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>name: 생성할 snippet 템플릿의 prefix입니다. (실제 파일은 {name}-fields.snippet 파일로 생성됩니다.)</li></ul><p><img src="./AbstractFieldSnippet-Constructor.png" alt="AbstractFieldSnippet-Constructor"></p><ul><li>descriptors : snippet에 출력될 field 정보들입니다. (예제에서는 ResponseCode 하나하나가 Row가 됩니다.)</li><li>attributes: snippet에 출력할 추가적인 속성입니다.</li></ul><h3 id="test-code">Test Code</h3><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(RestDocumentationExtension::class, SpringExtension::class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(ResponseCodeController::class, secure = false)</span></span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponseCodeDocs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> mockMvc: MockMvc</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> `build response code snippet`<span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    mockMvc.perform(<span class="keyword">get</span>(<span class="string">"/response-code"</span>)</span><br><span class="line">            .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">    ).andDo(MockMvcResultHandlers.print())</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"common"</span>,</span><br><span class="line">                            responseCodeFields(</span><br><span class="line">                                    <span class="string">"response-code"</span>, <span class="comment">//&#123;name&#125;-fields.snippet 이라는 파일명으로 생성</span></span><br><span class="line">                                    Attributes.attributes(Attributes.key(<span class="string">"title"</span>).value(<span class="string">"공통 응답 코드"</span>)),</span><br><span class="line">                                    *convertResponseCodeToFieldDescriptor(ResponseCode.values())</span><br><span class="line">                            )</span><br><span class="line">                    )</span><br><span class="line">            )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">responseCodeFields</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">          attributes: <span class="type">Map</span>&lt;<span class="type">String</span>, Any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">vararg</span> descriptors: <span class="type">FieldDescriptor</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>: ResponseCodeSnippet &#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseCodeSnippet(name, mutableListOf(*descriptors), attributes, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">convertResponseCodeToFieldDescriptor</span><span class="params">(enumTypes: <span class="type">Array</span>&lt;<span class="type">ResponseCode</span>&gt;)</span></span>: Array&lt;FieldDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(enumTypes)</span><br><span class="line">            .map &#123;</span><br><span class="line">              fieldWithPath(it.code.toString()).type(JsonFieldType.NUMBER).description(it.message).optional()</span><br><span class="line">            &#125;</span><br><span class="line">            .collect(Collectors.toList())</span><br><span class="line">            .toTypedArray()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="결과">결과</h3><p><img src="./custom-snippet.png" alt="custom-snippet"></p><h3 id="추가">추가</h3><p>위의 예시에서는 Custom Field Snippet으로 예시를 들었지만</p><ul><li>AbstractParametersSnippet</li><li>AbstractBodySnippet</li><li>AbstractHeadersSnippet</li></ul><p>위의 AbstractSnippet이 더 있는 걸로 보아 다른 Custom Snippet도 생성할 수 있는 것 같습니다.<br>필요할 때마다 한번씩 써보면 좋겠죠?</p><h1 id="reference">Reference</h1><ul><li>https://docs.spring.io/spring-restdocs/docs/current/reference/html5/#introduction</li><li>https://asciidoctor.org/docs/asciidoctor-gradle-plugin/</li><li>https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/</li><li>http://woowabros.github.io/experience/2018/12/28/spring-rest-docs.html</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/08/04/2019-08-04-spring-rest-docs/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Event-Driven-Architecture란?</title>
      <link>https://jaehun2841.github.io/2019/06/23/2019-06-23-event-driven-architecture/</link>
      <guid>https://jaehun2841.github.io/2019/06/23/2019-06-23-event-driven-architecture/</guid>
      <pubDate>Sun, 23 Jun 2019 08:54:28 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;event-driven-란&quot;&gt;Event Driven 란?&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;./EDA.png&quot; alt=&quot;EDA&quot;&gt;&lt;/p&gt;
&lt;p&gt;Event Driven은 IT 영역에서 오래 사용된 키워드이며, 현재도 그 영향력이 대단하여 2
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="event-driven-란">Event Driven 란?</h1><p><img src="./EDA.png" alt="EDA"></p><p>Event Driven은 IT 영역에서 오래 사용된 키워드이며, 현재도 그 영향력이 대단하여 2018년 Gartner에서 선정한 유망한 기술 트렌드 중 하나로 뽑히기도 했다.<br>(Top 10 Strategic Technology Trends for 2018: Event-Driven Model)</p><p>Event Driven이라는 용어는 programming, architecture와 연결되어 다양한 정의로 표현된다.</p><blockquote><p><strong>EDA (Event-driven architecture)</strong><br>분산된 시스템 간에 이벤트를 생성, 발행 (publishing)하고 발행된 이벤트를 필요로하는 수신자에게 전송된다.<br>이벤트를 수신한 수신자가 이벤트를 처리하는 형태의 시스템 아키텍쳐</p></blockquote><ul><li>Event Driven Pattern - 특정 행동이 자동으로/순서에 따라 발생하는 것이 아닌 어떤 일에 대한 반응으로 동작하는 디자인 패턴</li><li>IO Event - 컴퓨터 회로를 구동시키기 위해 발생하는 일  ( ex)  마우스 클릭, 키보드 타이핑, 모바일 터치 등)</li><li>IOT 기기 등의 센서로부터 유입되는 데이터 스트리밍 기반의 동작</li><li>시스템의 내,외부에서 발생한 <strong>주목할 만한 상태의 변화(a significant change in state)</strong></li></ul><p>주로 Event Driven 시스템은 Message Broker(Kafka, Rabbit MQ, Redis)와 결합하여, Message Driven 시스템으로 구성된다.</p><h2 id="eda-event-driven-architecture의-구성요소">EDA (Event-driven architecture)의 구성요소</h2><p>EDA는 크게 3개의 구성요소로 나누어 볼 수 있다.</p><ul><li>Event generator : 시스템 내,외부의 상태 변화를 감지하여 표준화된 형식의 이벤트를 생성</li><li>Event channel : 이벤트를 필요로 하는 시스템까지 발송</li><li>Event processing engine : 수신한 이벤트를 식별, 적절한 처리를 함. 때에 따라 이벤트 처리의 결과로 또 다른 이벤트를 발생시킬 수 있다.</li></ul><h2 id="event-processing-style">Event Processing Style</h2><p>수신한 이벤트를 처리하는 방법에는 세가지 종류가 있다.</p><h3 id="simple-event-processing">Simple event processing</h3><p>각각의 이벤트가 직접적으로 수행해야할 action과 매핑되어 처리 된다.<br>실시간으로 작업의 흐름을 처리할 때 사용되며, 이벤트 처리 시간과 비용의 손실이 적다.</p><h3 id="event-stream-processing">Event Stream Processing</h3><p>이벤트를 중요도에 따라  필터링하여 걸러진 이벤트만을 수신자에게 전송.<br>실시간으로 정보의 흐름을 처리할 때 사용되며, 기업에 적용될 경우 신속한 의사 결정을 가능케한다.(BAM)</p><h3 id="complex-event-processing">Complex event processing</h3><p>일상적인 이벤트의 패턴을 감지하여 더 복잡한 이벤트의 발생을 추론하는 것.<br>예를 들어 '주식의 등락'이라는 일상적인 이벤트의 패턴을 감지하여 '투자 적기'라는 상위의 이벤트를 추론해 낼 수 있다.</p><h2 id="event-driven-architecture의-장단점">Event Driven Architecture의 장단점</h2><h3 id="장점">장점</h3><ul><li>Decoupling - 시스템 간의 느슨한 결합이 가능 하므로 분산 시스템, Microservice 환경에서 시스템 간 의존성을 배제 할 수 있다<br>(시스템은 Event Channel인 Message Broker에 대한 의존성만 가진다.)</li><li>다른 시스템의 정보를 알 필요가 없다 - 약속된 Event message를 가지고 상호 정보를 교환한다.</li><li>micro service 단위로 시스템을 분리하기 쉽기 때문에 확장성, 탄력성을 고려하기 쉽다.</li></ul><h3 id="단점">단점</h3><ul><li>Broker Dependency - Event를 전송하기 위한 Message Broker에 대한 의존성이 커지기 때문에<br>Message Broker 장애 상황 시, 전체 장애로 이어질 수 있다.</li><li>Transaction 단위가 격리되기 때문에 서비스 장애 발생시 retry/rollback을 고려해야 한다.</li><li>시스템 전체 Flow를 파악하기 어렵다. - 명확한 Flow를 보기 위해서는 시스템을 모니터링하여야 한다.</li><li>디버깅이 어렵다.</li></ul><h1 id="microservice에서의-event">Microservice에서의 Event</h1><p><img src="./EDM.png" alt="EDM"></p><blockquote><p><strong>EDM(Event Driven Microservice)</strong>MSA가 적용된 시스템에서 이벤트 발생시 해당 이벤트 로그를 보관하고 이를 기반으로 동작하며,<br>비동기 통신을 통해 시스템 내 통합(integration)을 수행하는 Architecture</p></blockquote><h2 id="event">Event</h2><p>IT 영역에서의 이벤트는 다양한 정의를 포함하지만, MSA에서 의미하는 이벤트는<br>시스템의 내,외부에서 발생한 <strong>주목할 만한 상태의 변화(a significant change in state)</strong><br>데이터의 생성, 변경, 삭제를 통해 발생하는 서비스의 의미 있는 변화를 의미</p><h2 id="이벤트-로그를-보관">이벤트 로그를 보관</h2><ul><li>github를 예시들어 이해하면 이해가 편할 것 같습니다.</li></ul><h3 id="현재의-데이터는-상태-변경의-누적이다">현재의 데이터는 상태 변경의 누적이다.</h3><ul><li>github의 commit 한 스냅샷의 연속으로 현재의 소스가 변경</li></ul><h3 id="상태-변경은-이벤트를-의미하고-이를-누적하는-행위는-이벤트-로그를-보관하는-것">상태 변경은 이벤트를 의미하고 이를 누적하는 행위는 이벤트 로그를 보관하는 것</h3><ul><li>github에 commit = Eventcommit 로그는 이벤트를 보관하는 행위</li></ul><h3 id="보관된-이벤트는-데이터의-현재-상태를-구성하는-근간">보관된 이벤트는 데이터의 현재 상태를 구성하는 근간</h3><ul><li>github는 commit이라는 이벤트를 보관하는 store의 역할을 해주며commit의 누적으로 인해 현재의 소스를 구성할 수 있다.</li></ul><h3 id="보관된-이벤트를-바탕으로-장애-발생-또는-특정-요구사항에-따라-지정된-시점으로-복원을-수행">보관된 이벤트를 바탕으로 장애 발생 또는 특정 요구사항에 따라 지정된 시점으로 복원을 수행</h3><ul><li>github는 특정시점으로 롤백 및 revert가 가능</li></ul><h2 id="비동기-통신">비동기 통신</h2><p>amqp, mqtt, jms 등 메세징 프로토콜을 통한 메세지 큐 방식이 자주 사용됩니다.<br>서비스에서 데이터의 생성,변경,삭제(CUD)를 통해 이벤트가 발생하면 발행 서비스는 <strong>메세지의 형태로 이벤트를 발행</strong>하고, 해당 이벤트에 관심이 있는 서비스에서 구독을 수행합니다.<br>메세지 큐를 사용함으로 requeue/dlq(dead letter queue) 등의 기능을 활용할 수 있습니다.</p><h2 id="시스템-내-통합integration">시스템 내 통합(integration)</h2><p>이상적으로 구현된 MSA는 서비스 간 데이터 참조를 위한 내부 통신이 필요없지만, 현실적으로 서비스 간 내부 통신이 전혀 없는 시스템을 구현하기란 불가능에 가깝습니다. 다양한 사유로 여러 서비스 간 통신을 통해 연동이 발생합니다.</p><h2 id="트랜잭션-관리">트랜잭션 관리</h2><p>microservice 단위로 분리된 환경이기 때문에 각자 데이터베이스를 적용한 시스템에 대해 데이터 무결성을 보장할 수는 없지만<br>Event를 통해 최종적인 일관성을 유지 할 수는 있습니다.<br><strong>all commit or rollback → eventually consistency</strong> (언젠가는 맞는다.)</p><h1 id="참고">참고</h1><ul><li>https://bigstory.tistory.com/entry/Event-Driven-Architecture</li><li>https://en.wikipedia.org/wiki/Event-driven_architecture</li><li>https://medium.com/dtevangelist/event-driven-microservice-%EB%9E%80-54b4eaf7cc4a</li><li>https://www.confluent.io/blog/event-streaming-platform-1</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/06/23/2019-06-23-event-driven-architecture/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 88. readObject 메서드는 방어적으로 작성하라</title>
      <link>https://jaehun2841.github.io/2019/03/17/effective-java-item88/</link>
      <guid>https://jaehun2841.github.io/2019/03/17/effective-java-item88/</guid>
      <pubDate>Sun, 17 Mar 2019 08:11:59 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Item 50에서는 불변인 날짜 범위 클래스를 만드는데 가변인 Date 필드를 이용했다.&lt;br&gt;
그래서 불변식을 지키고 불변을 유지하기 위해 생성자와 접근자에서 Date객체를 방어적으로 복사하느라 코드가 상당히
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Item 50에서는 불변인 날짜 범위 클래스를 만드는데 가변인 Date 필드를 이용했다.<br>그래서 불변식을 지키고 불변을 유지하기 위해 생성자와 접근자에서 Date객체를 방어적으로 복사하느라 코드가 상당히 길어졌다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Period</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 시작 시각</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 종료 시각; 시작 시각보다 뒤여야 한다.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException start나 end가 null이면 발행한다.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.start.compareTo(<span class="keyword">this</span>.end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(start + <span class="string">"가 "</span> + end + <span class="string">"보다 늦다."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Date(start.getTime()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Date(end.getTime()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start + <span class="string">"-"</span> + end; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 클래스는 물리적 표현과 논리적 표현이 부합하므로 기본 직렬화를 사용해도 좋다.<br>하지만 이렇게 해서는 주요한 Date의 불변식을 보장하지 못한다.</p><h1 id="필요하다면-매개변수를-방어적으로-복사하라">필요하다면 매개변수를 방어적으로 복사하라</h1><ul><li>readObject 메서드는 실질적으로는 또 다른 public 생성자이기 때문에 생성자와 똑같은 수준으로 주의를 기울여야한다.</li><li>readObject 메서드에서 <strong>인수가 유효한지 검사해야하고 필요하다면 방어적으로 복사하라</strong></li><li>readObject에서 이 작업을 제대로 하지 못하면 공격자는 쉽게 클래스의 불변식을 깨뜨릴 수 있다.</li></ul><h2 id="불변식을-깨뜨릴-용도로-스트림을-조작하면-문제가-생긴다">불변식을 깨뜨릴 용도로 스트림을 조작하면 문제가 생긴다</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BogusPeriod</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] serializedForm = &#123;</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xac</span>, (<span class="keyword">byte</span>)<span class="number">0xed</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x73</span>, <span class="number">0x72</span>, <span class="number">0x00</span>, <span class="number">0x06</span>....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Period p = (Period) deserialize(serializedForm);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] sf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(sf)).readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 코드의 serializedForm에서 상위 비트가 1인 바이트 값들은 byte로 형변환했는데,<br>이는 자바가 바이트 리터럴을 지원하지 않고 byte 타입은 부호가 있는 (signed) 타입이기 때문이다.</li><li>위의 프로그램을 실행하면<br><code>Fri Jan 01 12:00:00 PST 1999 - Sun Jan 01 12:00:00 PST 1984</code>를 출력한다.</li><li>Period를 직렬화할 수 있도록 선언한 것 만으로도 불변식을 깨뜨리는 객체를 만들 수 있다.</li></ul><h1 id="역직렬화-시-불변식을-만족하는-유효성-검사를-해야한다">역직렬화 시, 불변식을 만족하는 유효성 검사를 해야한다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 불변식을 만족하는지 검사한다.</span></span><br><span class="line">    <span class="keyword">if</span>(start.compareTo(end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(start + <span class="string">"가 "</span> + end + <span class="string">"보다 늦다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위의 if문 추가로 허용되지 않는 Period 인스턴스가 생성되는 일을 막을 수 있지만, 아직도 미묘한 문제가 숨어있다.</li><li>정상 Period 인스턴스에서 시작된 바이트 스트림 끝에 private Date 필드로의 참조를 추가하면 가변 Period 인스턴스를 만들 수 있다.</li></ul><h1 id="가변-공격을-막기위해서는-방어적-복사본을-만들어야-한다">가변 공격을 막기위해서는 방어적 복사본을 만들어야 한다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePeriod</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Period 인스턴스</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Period period;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//시작 시각 필드 - 외부에서 접근할 수 없어야 한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Date start;</span><br><span class="line">    <span class="comment">//종료 시각 필드 - 외부에서 접근할 수 없어야 한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Date end;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePeriod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectArrayOutputStream out = <span class="keyword">new</span> ObjectArrayOutputStream(bos);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//유효한 Period 인스턴스를 직렬화한다.</span></span><br><span class="line">            out.writeObject(<span class="keyword">new</span> Period(<span class="keyword">new</span> Date(), <span class="keyword">new</span> Date()));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 악의적인 '이전 객체 참조', 즉 내부 Date 필드로의 참조를 추가한다.</span></span><br><span class="line"><span class="comment">             * 상세 내용은 자바 객체 직렬화 명세의 6.4절을 참고</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">byte</span>[] ref = &#123;<span class="number">0x71</span>, <span class="number">0</span>, <span class="number">0x7e</span>, <span class="number">0</span>, <span class="number">5</span>&#125;; <span class="comment">// 참조 #5</span></span><br><span class="line">            bos.write(ref); <span class="comment">// 시작 start 필드 참조 추가</span></span><br><span class="line">            ref[<span class="number">4</span>] = <span class="number">4</span>; <span class="comment">//참조 #4</span></span><br><span class="line">            bos.write(ref); <span class="comment">// 종료(end) 필드 참조 추가</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Period 역직렬화 후 Date 참조를 훔친다.</span></span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray()));</span><br><span class="line">            period = (Period) in.readObject();</span><br><span class="line">            start = (Date) in.readObject();</span><br><span class="line">            end = (Date) in.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>다음 공격 코드를 실행하면 이 공격이 실제로 이뤄지는 모습을 확인할 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MutablePeriod mp = <span class="keyword">new</span> MutablePeriod();</span><br><span class="line">    Period p = mp.period;</span><br><span class="line">    Date pEnd = mp.end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//시간 되돌리기</span></span><br><span class="line">    pEnd.setYear(<span class="number">78</span>);</span><br><span class="line">    System.out.println(p); <span class="comment">// Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1978</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//60년대로 회귀</span></span><br><span class="line">    pEnd.setYear(<span class="number">60</span>);</span><br><span class="line">    System.out.println(p); <span class="comment">// Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1969</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 예시에서 Period 인스턴스는 불변식을 유지한 채 생성됐지만 의도적으로 내부의 값을 수정할 수 있었다.<br>이처럼 변경할 수 있는 Period 인스턴스를 획득한 공격자는 인스턴스가 불변이라고 가정하는 클래스에 넘겨 엄청난 보안 문제를 일으킬 수 있다.</p><p>이 문제의 근원은 <strong>Period의 readObject메서드가 방어적 복사를 충분히 하지 않은 데 있다.</strong><br>객체를 직렬화할 때는 클라이언트가 소유해서는 안 되는 객체 참조를 갖는 필드를 모두 방어적으로 복사해야 한다.<br>따라서 <code>readObject에서는 불변 클래스 안의 모든 private 가변 요소를 방어적으로 복사 해야한다.</code></p><h1 id="readobject-메서드에서는-private-가변요소를-방어-복사하라">readObject 메서드에서는 private 가변요소를 방어 복사하라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 가변 요소들을 방어적으로 복사한다.</span></span><br><span class="line">    start = <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">    end = <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 불변식을 만족하는지 검사한다.</span></span><br><span class="line">    <span class="keyword">if</span>(start.compareTo(end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(start + <span class="string">"가 "</span> + end + <span class="string">"보다 늦다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>방어적 복사를 유효성 검사보다 앞서 수행하며, Date의 clone 메서드는 사용하지 않았음에 주목하자.</li><li>두 조치 모두 Period를 공격으로 부터 보호하는데 필요하다.</li><li>또한 final 필드는 방어적 복사가 불가능 하니 주의하자</li><li>그래서 이 readObject를 사용하려면 start와 end필드에서 final 한정자를 제거해야 한다.</li></ul><h1 id="기본-readobject를-사용해도-되는지에-대한-체크리스트">기본 readObject를 사용해도 되는지에 대한 체크리스트</h1><ul><li>transient 필드를 제외한 모든 필드의 값을 매개변수로 받아 유효성 검사 없이 필드에 대입하는 public 생성자를 추가해도 괜찮은가?<ul><li>아니오 -&gt; 커스텀 readObject 메서드를 만들어 유효성 검사와 방어적 복사를 수행</li><li>예 -&gt; 기본 readObject 메서드 사용</li></ul></li><li>직렬화 프록시 패턴을 사용해도 된다 .<ul><li>역직렬화를 안전하게 만드는 데 필요한 노력을 경감해 준다. (권장)</li></ul></li></ul><h1 id="정리">정리</h1><ul><li>readObject 메서드를 작성할 때는 언제나 public 생성자를 만든다고 생각하고 만들어야 한다.</li><li>private 이어야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사하라 (불변 클래스 내의 가변 요소)</li><li>모든 불변식을 검사하여 어긋나는 게 발견되면 InvalidObjectException을 던진다.<br>방어적 복사 다음에는 반드시 불변식 검사가 뒤따라야 한다.</li><li>역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면 ObjectInputValidation 인터페이스를 사용하라</li><li>직접적이든 간접적이든 readObject메서드에서 재정의 가능한 메서드를 호출해서는 안된다.</li><li>재정의 가능한 메서드가 재정의되면 하위 클래스의 상태가 완전히 역직렬화 되기전에 하위 클래스에서 재정의된 메서드가 실행되므로<br>프로그램 오작동을 일으킬 수 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 88. readObject 메서드는 방어적으로 작성하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/17/effective-java-item88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 87. 커스텀 직렬화 형태를 고려해보라</title>
      <link>https://jaehun2841.github.io/2019/03/17/effective-java-item87/</link>
      <guid>https://jaehun2841.github.io/2019/03/17/effective-java-item87/</guid>
      <pubDate>Sun, 17 Mar 2019 06:21:53 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;개발 일정에 쫓기는 상황에서는 API 설계에 노력을 집중하는 편이 낫다.&lt;br&gt;
다음 릴리스에서 세부적인 기능을 제대로 구현하고 이번 릴리즈는 대충 동작만하게 하면 된다는 뜻이다.&lt;br&gt;
하지만 클래스가 Ser
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>개발 일정에 쫓기는 상황에서는 API 설계에 노력을 집중하는 편이 낫다.<br>다음 릴리스에서 세부적인 기능을 제대로 구현하고 이번 릴리즈는 대충 동작만하게 하면 된다는 뜻이다.<br>하지만 클래스가 Serializable을 구현하고 기본 직렬화 형태를 사용한다면 다음 릴리즈때 버리려 한 현재의 구현에 영원히 발이 묶이게 된다.<br>(현재의 기본 직렬화 형태를 버릴 수 없게 되기 때문이다.)</p><h1 id="먼저-고민해보고-괜찮다고-판단될-때만-기본-직렬화-형태를-사용하라">먼저 고민해보고 괜찮다고 판단될 때만 기본 직렬화 형태를 사용하라</h1><ul><li>기본 직렬화 형태는 유연성,  성능, 정확성, 측면에서 신중히 고민한 후 합당할 때만 사용해야 한다.</li><li>직접 설계하더라도 기본 직렬화 형태와 거의 같은 결과가 나올 경우에만 기본 형태를 써야 한다.</li><li>기본 직렬화 형태는 그 객체를 루트로 하는 객체 그래프의 물리적 모습을 나름 효율적으로 인코딩한다.</li><li>객체가 포함한 데이터들과 그 객체에서부터 시작해 접근할 수 있는 모든 객체를 담아내며 객체들이 연결된 위상(topology)까지 기술한다.</li><li>하지만 이상적인 직렬화 형태는 <strong>물리적인 모습과 독립된 논리적인 모습만을 표현해야 한다.</strong></li></ul><h1 id="객체의-물리적-표현과-논리적-내용이-같다면-기본-직렬화-형태라도-무방하다">객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 성. null이 아니어야함</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lastName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 이름. null이 아니어야 함.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String firstName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 중간이름. 중간이름이 없다면 null.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String middleName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>기본 직렬화 형태가 적합하다고 결정했더라고 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다.</li><li>Name의 3개의 필드는 private임에도 불구하고 문서화 주석이 달려있다.</li><li>이 필드들은 결국 클래스의 직렬화 형태에 포함되는 공개 API에 속하며 공개 API는 모두 문서화 해야 하기 때문이다.</li><li>private 필드의 설명을 API 문서에 포함하라고 자바독에 알려주는 역할은 @serial태그가 한다.</li><li>@serial 태그로 기술한 내용은 API 문서에서 직렬화 형태를 설명하는 특별한 페이지에 기록된다.</li></ul><h1 id="기본-직렬화-형태에-적합하지-않은-클래스">기본 직렬화 형태에 적합하지 않은 클래스</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Entry head = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        String data;</span><br><span class="line">        Entry next;</span><br><span class="line">        Entry previous;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>논리적으로는 이클래스는 일련의 문자열을 표현한다.<br>물리적으로는 문자열을 이중 연결 리스트로 연결했다. 이 클래스에 기본 직렬화 형태를 사용하면 각 노드의 양방향 연결 정보를 포함해 모든 엔트리(Entry)를 철두철미하게 기록한다.</p><h1 id="객체의-물리적-표현과-논리적-표현의-차이가-클-때-기본-직렬화-형태를-사용하는-경우-생기는-문제">객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하는 경우 생기는 문제</h1><h2 id="공개-api가-현재의-내부-표현-방식에-영구히-묶인다">공개 API가 현재의 내부 표현 방식에 영구히 묶인다.</h2><ul><li>앞의 예에서 private 클래스인 StringList.Entry가 공개 API가 되어버린다.</li><li>다음 릴리스에서 내부 표현 방식을 바꾸더라도 StringList 클래스는 여전히 연결 리스트로 표현된 입력도 처리할 수 있어야 한다.</li><li>즉 연결 리스트를 더 이상 사용하지 않더라도 관련 코드를 제거할 수 없다.</li></ul><h2 id="너무-많은-공간을-차지할-수-있다">너무 많은 공간을 차지할 수 있다.</h2><ul><li>앞 예의 직렬화 형태는 연결 리스트의 모든 엔트리와 연결 정보까지 기록했지만, 엔트리와 연결 정보는 내부 구현에 해당하니 직렬화 형태에 포함할 가치가 없다.</li><li>이처럼 직렬화 형태가 너무 커져서 디스크에 저장하거나 네트워크로 전송하는 속도가 느려진다.</li></ul><h2 id="시간이-너무-많이-걸릴-수-있다">시간이 너무 많이 걸릴 수 있다.</h2><ul><li>직렬화 로직은 객체 그래프의 위상에 관한 정보가 없으니 그래프를 직접 순회해볼 수밖에 없다.</li><li>앞의 예제는 간단히 다음 참조를 따라가 보는 정도로 충분하다.</li></ul><h2 id="스택-오버플로를-일으킬-수-있다">스택 오버플로를 일으킬 수 있다.</h2><ul><li>기본 직렬화 과정은 객체 그래프를 재귀 순회하는데 중간정도 크기의 객체 그래프에서도 스택 오버플로 에러가 날 수 있다.</li><li>그때그때 다른 시점에서 스택 오버플로가 날 수 있고, 어떤 플랫폼에서는 에러가 나지 않을 수도 있다.</li></ul><h1 id="합리적인-커스텀-직렬화-형태를-갖춘-stringlist">합리적인 커스텀 직렬화 형태를 갖춘 StringList</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry head = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 이제는 직렬화되지 않는다.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">        String data;</span><br><span class="line">        Entry next;</span><br><span class="line">        Entry previous;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 지정한 문자열을 이 리스트에 추가한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 이 &#123;<span class="doctag">@code</span> StringList&#125; 인스턴스를 직렬화한다.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> 이 리스트의 크기(포함된 문자열의 개수)를 기록한 후</span></span><br><span class="line"><span class="comment">     * (&#123;<span class="doctag">@code</span> int&#125;), 이어서 모든 원소를(각각은 &#123;<span class="doctag">@code</span> String&#125;)</span></span><br><span class="line"><span class="comment">     * 순서대로 기록한다.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//기본 직렬화를 수행한다.</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        s.writeInt(size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 커스텀 역직렬화를 수행한다.</span></span><br><span class="line">        <span class="comment">// 모든 원소를 올바른 순서로 기록한다.</span></span><br><span class="line">        <span class="keyword">for</span> (Entry e = head; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">            s.writeObject(e.data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//기본 역직렬화를 수행한다.</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        <span class="keyword">int</span> numElements = s.readInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 커스텀 역직렬화 부분</span></span><br><span class="line">        <span class="comment">// 모든 원소를 읽어 이 리스트에 삽입한다.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i++) &#123;</span><br><span class="line">            add((String) s.readObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>StringList의 필드 모두가 transient더라도 writeObject와 readObject는 각각 먼저 defaultWriteObject와 defaultReadObject를 호출한다.</p></li><li><p>클래스의 인스턴스가 모두 transient더라도 defaultWriteObject와 defaultReadObject를 호출해줘야 한다.<br>(향후 릴리즈에서 transient가 아닌 필드가 추가되더라도 상호 호환되기 때문이다)</p></li><li><p>신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화하면 새로 추가된 필드들은 무시될 것이다.</p></li><li><p>구버전 readObject 메서드에서 defaultReadObject를 호출하지 않는다면 역직렬화할 때 StreamCorruptedException이 발생할 것이다.</p></li><li><p>writeObject는 private 메서드임에도 문서화 주석이 달려 있다.<br>이 private 메서드는 직렬화 형태에 포함되는 공개 API에 속하며 공개 API는 모두 문서화 해야한다.</p></li><li><p>메서드에 달린 @serialData 태그는 자바독 유틸리티에게 이 내용을 직렬화 형태 페이지에 추가하도록 요청한다.</p></li><li><p>개선한 StringList는 원래버전의 절반정도의 공간을 차지하며 수행속도 또한 두 배 이상 빠르다.</p></li><li><p>개선한 StringList는 스택 오버플로 에러가 발생하지 않는다. (크기의 제한이 사라짐)</p></li><li><p>객체를 직렬화한 후 역직렬화하면 원래 객체를 그 불변식까지 포함해 제대로 복원해낸다는 점에서 정확하다 할 수 있다.</p></li><li><p>하지만 불변식이 세부 구현에 따라 달라지는 객체에서는 이 정확성마저 깨질 수 있다.</p></li></ul><h1 id="객체의-불변식이-깨지는-경우에는-직렬화를-주의해야한다">객체의 불변식이 깨지는 경우에는 직렬화를 주의해야한다.</h1><p>해시 테이블을 예로 생각해보면 이해할 수 있다.  해시 테이블은 물리적으로는 key-value 엔트리를 담은 해시 버킷을 차례로 나열한 형태다.<br>어떤 엔트리를 어떤 버킷에 담을지는 key에서 구한 hashcode가 결정하는데 <strong>그 계산 방식은 구현에 따라 달라질 수 있다.</strong><br>혹은 계산할 때마다 달라지기도 한다.<br>따라서 해시테이블을 직렬화한 후 역직렬화하면 불변식이 심각하게 훼손된 객체들이 생겨날 수 있는 것이다.</p><h1 id="객체의-논리적-상태와-무관한-필드라고-확신하면-transient-한정자를-생략하라">객체의 논리적 상태와 무관한 필드라고 확신하면 transient 한정자를 생략하라</h1><ul><li>기본 직렬화를 수용하든 하지 않든 defaultWriteObject 메서드를 호출하면 transient로 선언하지 않은 모든 인스턴스 필드가 직렬화된다.</li><li>따라서 transient로 선언해되 되는 인스턴스 필드에는 모두 transient를 붙여야 한다.</li><li>JVM을 실행할 때마다 값이 달라지는 필드도 transient를 붙여야 한다.</li><li>커스텀 직렬화 형태를 사용한다면 앞서의 StringList 처럼 대부분의(혹은 모든) 인스턴스 필드를 transient로 선언해야 한다.</li></ul><h1 id="동기화-메커니즘을-직렬화에도-적용해야-한다">동기화 메커니즘을 직렬화에도 적용해야 한다.</h1><p>모든 메서드를 synchronized로 선언하여 스레드 안전하게 만든 객체에서 기본 직렬화를 사용하려면<br>writeObject도 다음 코드 처럼 synchronized로 선언해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>writeObject 메서드 안에서 동기화 하고 싶다면 클래스의 다른 부분에서 사용하는 락 순서를 똑같이 따라야 한다.<br>그렇지 않으면 교착상태 (resource-ordering deadlock)에 빠질 수 있다.</p><h1 id="직렬-버전-uid를-명시적으로-부여하자">직렬 버전 UID를 명시적으로 부여하자</h1><p>어떤 직렬화 형태를 사용하든 직렬 가능 클래스에 모두 직렬 버전 UID를 명시적으로 부여하자.<br>이렇게 하면 직렬 버전 UID가 일으키는 잠재적인 호환성 문제가 사라진다.<br>성능도 조금 빨라지는데 직렬 버전 UID를 명시하지 않으면 런타임에 이 값을 생성하느라 복잡한 연산을 수행하기 때문이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">232923283928929</span>;</span><br></pre></td></tr></table></figure></p><p>위와 같은 형태로 사용하면 된다.<br>Intellij 에서는 alt+insert 단축키를 누르면 serialVersionUID를 자동으로 생성해 주는 메뉴가 있다.<br>기존 클래스를 구버전으로 직렬화된 인스턴스와 호환성을 유지한 채 사용하고 싶다면<br>기존 클래스를 구버전에서 사용한 자동 생성된 값을 그대로 사용해야 한다.</p><h2 id="주의할-점">주의할 점</h2><p><strong>직렬버전 UID는 클래스의 명세가 변경되면 자동 생성된 값이 바뀌기 때문에 이부분도 주의해야 한다.</strong><br>구버전과 호환이 되지 않아 역직렬화가 되지 않는다.<br>기존 버전의 직렬화된 인스턴스를 역직렬화할 때 InvalidClassException이 던져질 것이다.<br>구버전으로 직렬화된 인스턴스들과 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID를 절대 수정하면 안된다.</p><h1 id="정리">정리</h1><ul><li>클래스를 직렬화하기로 했다면 어떤 직렬화 형태를 사용할지 심사숙고 해야한다.</li><li>자바의 기본 직렬화 형태는 객체를 직렬화한 결과가 해당 객체의 논리적 표현에 부합할 때만 사용하고 그렇지 않으면 객체를 적절히 설명하는 커스텀 직렬화 형태를 고안해야 한다.</li><li>직렬화 형태도 공개 메서드를 설계할 때에 준하는 시간을 들여 설계 해야 한다.</li><li>한번 공개된 메서드는 향후 릴리즈에서 제거할 수 없듯이 직렬화 형태에 포함된 필드도 마음대로 제거할 수 없다.</li><li>직렬화 호환성을 유지하기 위해 영원히 지원해야 한다.</li><li>잘못된 직렬화 형태를 선택하면 해당 클래스의 복잡성과 성능에 영구히 부정적인 영향을 남긴다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 87. 커스텀 직렬화 형태를 고려해보라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/17/effective-java-item87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 79. 과도한 동기화는 피하라</title>
      <link>https://jaehun2841.github.io/2019/03/12/effective-java-item79/</link>
      <guid>https://jaehun2841.github.io/2019/03/12/effective-java-item79/</guid>
      <pubDate>Mon, 11 Mar 2019 15:28:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.&lt;br&gt;
&lt;strong&gt;응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.<br><strong>응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.</strong></p><ul><li>동기화(synchronized) 된 코드 블럭 안에서는 재정의 가능한 메서드를 호출해선 안된다.</li><li>클라이언트가 넘겨준 함수객체를 호출해서도 안된다.</li><li>이런 메서드는 동기화도니 클래스 관점에서 외계인 메서드(alien method)라고 칭한다.<br>(무슨일을 할지 모르니, 이 메서드가 예외를 발생시키거나, 교착상태를 만들거나, 데이터를 훼손시킬 수 있다.)</li></ul><h1 id="외계인-메서드">외계인 메서드</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ForwardingSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableSet</span><span class="params">(Set&lt;E&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserver&lt;E&gt;&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            observers.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">return</span> observers.remove(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">for</span>(SetObserver&lt;E&gt; observer : observers) &#123;</span><br><span class="line">                observer.added(<span class="keyword">this</span>, element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> added = <span class="keyword">super</span>.add(element);</span><br><span class="line">        <span class="keyword">if</span>(added) &#123;</span><br><span class="line">            notifyElementAdded(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> added;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : c) &#123;</span><br><span class="line">            result |= add(element); <span class="comment">//notifyElementAdded를 호출</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>관찰자들은 addObserver와 removeObserver 메서드를 호출해 구독을 신청하거나 해지한다.</li><li>두 경우 다음 콜백 인터페이스의 인스턴스를 메서드에 전달</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SetObserver</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//ObservableSet에 원소가 더해지면 호출된다.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet&lt;E&gt; set, E element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 인터페이스는 구조적으로 BiConsumer&lt;ObservableSet&lt;E&gt;,  E&gt;와 똑같다.</li><li>커스텀 함수형 인터페이스를 정의한 이유는 이름이 더 직관적이고 다중 콜백을 지원하도록 확장할 수 있기 때문이다.</li></ul><h1 id="외계인-메서드-예제1">외계인 메서드 - 예제1</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ObservableSet&lt;Integer&gt; set = <span class="keyword">new</span> ObservableSet&lt;&gt;(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    set.addObserver(<span class="keyword">new</span> SetObserver&lt;&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet&lt;Integer&gt; s, Integer e)</span> </span>&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            <span class="keyword">if</span>(e == <span class="number">23</span>) &#123;</span><br><span class="line">                s.removeObserver(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        set.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>s.removeObserver에 this를 넘겨야하는데 람다에서는 방법이 없으므로 익명클래스의 형태로 사용</li><li>이 프로그램은 0~23까지 출력한 후 Observer 자신을 구독해제 한 후 아무런 로그도 뜨지 않고 종료할 것 같다.</li><li>하지만 그렇지 않다. 프로그램은 0~23까지 출력한 후 <code>ConcurrentModificationException</code> 을 던진다.</li><li>왜냐하면 Observer의 added 메서드 호출이 일어난 시점이 notifyElementAdded가 Observer들의 리스트를 순회하는 도중이기 때문이다.</li><li>added 메서드 -&gt; ObservableSet.removeObserver를 호출 -&gt; observers.remove 호출</li><li>리스트에서 원소를 제거하려는데 마침 지금은 이 원소를 순회하는 중 <strong>(허용되지 않은 동작)</strong></li><li>notifyElementAdded 메서드에서 수행하는 순회는 동기화 블록 안에 있으므로 동시 수정이 일어나지 않지만<br>정작 자신이 콜백을 거쳐 되돌아와 수정하는 것을 막진 못한다.</li></ul><h1 id="외계인-메서드-예제-2">외계인 메서드 - 예제 2</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set.addObserver(<span class="keyword">new</span> SetObserver&lt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet&lt;Integer&gt; s, Integer e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">if</span>(e == <span class="number">23</span>) &#123;</span><br><span class="line">            ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                exec.submit(() -&gt; s.removeObserver(<span class="keyword">this</span>)).get(); <span class="comment">//여기서 lock이 걸려서 못들어감</span></span><br><span class="line">                <span class="comment">//하지만 메인 스레드는 너의 작업을 기다리고 있어</span></span><br><span class="line">            &#125; <span class="keyword">catch</span>(ExecutionException | InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(ex);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ul><li>이 프로그램을 실행하면 에러는 나진 않지만 교착상태(Dead-lock)에 빠진다.</li><li>백그라운드 스레드가 s.removeObserver를 호출하면 Observer를 잠그려 시도하지만 락을 얻을 수 없다.<br>(메인스레드가 이미 락을 쥐고 있기 때문 - removeObserver는 synchronized 키워드가 달려있어서 실행 시 락이 걸린다.)</li><li>그와 동시에 메인 스레드는 백그라운드 스레드가 Observer를 제거하기만을 기다리는 중이다.</li></ul><h1 id="교착상태-해결방법">교착상태 해결방법</h1><p>자바 언어의 락은 재진입(reentrant)을 허용하므로 교착상태에 빠지지는 않는다.<br>재진입 가능 락은 객체 지향 멀티스레드 프로그램을 쉽게 구현 할 수 있도록 해준다.<br>하지만 응답 불가(교착상태)가 될 상황을 안전 실패(데이터 훼손)으로 변모시킬 수도 있다.</p><p>이런 경우 외계인 메서드 호출을 동기화 블록 바깥으로 옮기면 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    List&lt;SetObserver&lt;E&gt;&gt; snapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(observers) &#123;</span><br><span class="line">        snapshot = <span class="keyword">new</span> ArrayList&lt;&gt;(observers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SetObserver&lt;E&gt; observer : snapshot) &#123;</span><br><span class="line">        observer.added(<span class="keyword">this</span>, element); <span class="comment">//외계인 메서드를 동기화 블록 바깥으로 옮겼다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="copyonwritearraylist">CopyOnWriteArrayList</h1><p>외계인 메서드 호출을 동기화 블록 바깥으로 옮기는 것 보다 더 나은 방법은 java.util.concurrent 패키지의 CopyOnWriteArrayList를 사용하는 것이 좋다.<br>내부를 변경하는 작업은 항상 깨끗한 복사본을 만들어 수행한다.<br>내부의 배열은 절대 수정되지 않아 락이 없어 빠르다.<br>다른 용도로 쓰인다면 매번 복사해서 느리겠지만, 수정할 일은 드물고 순회만 빈번히 일어나는 Observer 리스트 용으로는 딱이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserser&lt;E&gt;&gt; observers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observers.remove(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (SetObserver&lt;E&gt; observer : observers) &#123;</span><br><span class="line">         observers.added(<span class="keyword">this</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="동기화의-성능">동기화의 성능</h1><p>자바의 동기화 비용은 빠르게 낮아져 왔지만, 과도한 동기화를 피하는일은 오히려 과거 어느 때보다 중요하다.<br>멀티코어가 일반화된 오늘날 과도한 동기화가 초래하는 진짜 비용은 락을 얻는데 드는 CPU 시간이 아니다.<br>서로 스레드끼리 경쟁하는 Race Condition에 낭비가 발생한다.</p><ul><li>병렬로 실행할 기회를 잃는다.</li><li>모든 코어가 메모리를 일관되게 보기위한 지연시간이 진짜 비용</li><li>가상머신의 코드최적화를 제한하는 점도 숨은 비용</li></ul><h2 id="가변-클래스를-작성하는-경우-동기화에-대해-고려할-점">가변 클래스를 작성하는 경우 동기화에 대해 고려할 점</h2><ol><li>동기화를 전혀 하지 말고 가변 클래스를 동시에 사용해야하는 클래스가 외부에서 동기화하자</li><li>동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.<br>(단 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 두번째 방법을 쓴다)</li></ol><h1 id="정리">정리</h1><ul><li>기본 규칙은 동기화 영역에서 가능한 한 일을 적게하는 것이다.<br>(락을 얻고 공유 데이터를 검사하고, 필요하면 수정하고, 락을 놓는다.)</li><li>오래 걸리는 작업이라면 동기화 영역 밖으로 옮기는 방법을 찾아보자.</li><li>여러 스레드가 호출할 가능성이 있는 메서드가 정적 필드를 수정한다면 그 필드를 사용하기 전에 반드시 동기화 해야 한다.</li><li>교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자</li><li>동기화 영역 안에서 작업은 최소한으로 줄이자</li><li>가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자</li><li>지금은 과도한 동기화를 피하는게 제일 중요하다</li><li>합당한 이유가 있을때만 내부에서 동기화하고 동기화 여부를 문서에 남기자.<br>(웬만하면 외부에서 동기화를 하자)</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 79. 과도한 동기화는 피하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/12/effective-java-item79/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 78. 공유 중인 가변 데이터는 동기화해 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/11/effective-java-item78/</link>
      <guid>https://jaehun2841.github.io/2019/03/11/effective-java-item78/</guid>
      <pubDate>Mon, 11 Mar 2019 07:02:45 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;싱글 스레드 기반의 프로그램에서는 하나의 스레드가 하나의 객체를 사용하면 되기 때문에 동기화에 대한 걱정을 하지 않아도 되지만,&lt;br&gt;
멀티 스레드 기반의 환경에서는 여러개의 스레드가 하나의 객체를 공유해서 사
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>싱글 스레드 기반의 프로그램에서는 하나의 스레드가 하나의 객체를 사용하면 되기 때문에 동기화에 대한 걱정을 하지 않아도 되지만,<br>멀티 스레드 기반의 환경에서는 여러개의 스레드가 하나의 객체를 공유해서 사용하는 경우가 있다.<br>하나의 객체를 공유하며 사용하는 경우 불변 객체에 대해서는 동기화를 걱정할 필요가 없지만,<br>스레드가 메서드를 실행하면서 변수의 데이터를 변경하는 경우 다른 스레드에서 동기화되지 않은 데이터를 읽을 수 있다.<br>이런 경우에는 프로그래머가 기대한 결과와는 다른 결과를 초래할 수 있기 때문에 주의해야 한다.</p><h1 id="동기화란">동기화란?</h1><p>동기화(Syncronized)란 멀티스레드 환경에서 하나의 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장하는 것을 의미한다.</p><h2 id="동기화의-특징">동기화의 특징</h2><ul><li>한 객체가 일관된 상태를 가지고 생성되었을 때, 이 객체에 접근하는 메서드는 그 객체에 Lock을 건다.<br>(다른 스레드가 메서드를 실행할 때 실행되지 못하도록 Lock을 건다)</li><li>Lock을 건 메서드는 객체의 상태를 확인하거나 필요하면 수정한다.</li><li>즉 일관된 하나의 상태 -&gt; 다른 일관된 하나의 상태로 변화한다.</li><li>메서드 실행이 끝나면 Lock을 해제한다.</li><li>동기화를 제대로 사용하면 어떤 메서드도 이 객체의 상태가 일관되지 않은 순간을 볼 수 없다.</li><li><strong>동기화 없이는</strong> 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.<br>(동기화가 없다면, 너도나도 접근하는데 시점에 따라 일관된 상태가 아닐 수도 있기 때문)</li><li>언어 명세상 long과 double 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이다.<br>(여러 스레드가 하나의 변수에 동기화 없이 접근해도 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장)</li><li>성능을 높이려면 원자적 데이터를 읽고 쓸 때는 동기화 하지 말아야겠다 <strong>(위험한 발상)</strong><br>(필드를 읽을 때 항상 <strong>수정이 완전히 반영된 값</strong> 을 얻지만, <strong>한 스레드가 저장한 값이 다른 스레드에도 보이는가?</strong> 는 보장하지 않음)</li></ul><h1 id="java에서의-가변-데이터-동기화-방법">Java에서의 가변 데이터 동기화 방법</h1><p>Java에서는 <strong>synchronized</strong> 키워드를 통해 동기화 처리를 할 수 있다.</p><ul><li>가변데이터를 수정하거나 읽는 메서드를 동기화</li><li>가변 객체에 대한 동기화</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">countup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(list) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="한-스레드가-저장한-값이-다른-스레드에도-보이는가">한 스레드가 저장한 값이 다른 스레드에도 보이는가?</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread backgroundThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위의 코드는 대충 보면 1초뒤에 <code>stopRequested</code> 필드가 false로 바뀌면서 스레드 내의 while문이 종료될 것 처럼 보인다.</li><li>하지만 무한루프!!!</li><li>원인은 동기화에 있다.</li><li>동기화하지 않으면 메인 스레드에서 수정한 <code>stopRequested</code> 필드가 언제 false로 보일지 모른다.<br>(맨 마지막에 stopRequested가 false가 되면서 실제 원잣값은 false가 된다)</li><li>위의 문제를 해결하기 위해서는 <code>stopRequested</code> 필드에 대한 동기화 처리가 필요하다</li></ul><h2 id="동기화가-빠지는-경우-jvm에서-최적화를-수행할-수도-있다">동기화가 빠지는 경우 JVM에서 최적화를 수행할 수도 있다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//원래 코드</span></span><br><span class="line"><span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 최적화한 코드</span></span><br><span class="line"><span class="keyword">if</span>(!stopRequested) &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>JVM의 호이스팅 기법을 통해 최적화 할 수 있다.</li><li>이 결과 프로그램은 응답 불가 상태가 되어 더 이상 진전이 없다.</li></ul><h1 id="위의-코드를-동기화-해보자">위의 코드를 동기화 해보자</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">requestStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stopRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">stopRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stopRequested;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread backgroundThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested()) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위와 같이 <strong>stopRequested</strong> 필드의 읽기/쓰기에 대한 동기화처리를 하면 위의 프로그램이 1초뒤에 종료된다.</li><li>읽기/쓰기 메서드 모두 동기화 처리를 하였음에 주목하자</li><li>쓰기 메서드만 동기화처리를 하고 읽기 메서드에는 동기화처리를 하지 않으면 동작을 보장할 수 없다.</li></ul><h1 id="volatile-키워드">volatile 키워드</h1><p>volatile 키워드의 의미는 <code>volatile 변수를 읽어 들일 때 CPU 캐시가 아니라 컴퓨터의 메인 메모리로 부터 읽어들인다.</code><br>즉 read 할 때도 CPU 캐시가 아닌 메인메모리에서 read하고, write할 때도 메인 메모리에 write를 수행</p><p><img src="./java-volatile.png" alt="java-volatile"></p><p>long, double을 제외한 기본타입은 <strong>volitile</strong> 키워드를 사용하면 동기화를 생략해도 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread backgroundThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>volitile 예약어는 배타적 수행(한 블록을 한 스레드가 실행) 하는것과는 관계없다</li><li>volatile 변수는 CPU캐시에서 값을 읽는게 아닌 메인 메모리에서 읽기 때문에 항상 최근에 기록된 값을 읽는다.<br>(그렇기 때문에 위의 프로그램이 1초 뒤에 종료됨)</li></ul><h1 id="volatile-사용-시-주의할-점">volatile 사용 시 주의할 점</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> nextSerialNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">generateSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 메서드는 호출 될 때 마다 1씩 증가하여 스레드에서 고유한 값을 반환할 의도로 만들어 졌다.</li><li>겉보기에는 int이기 때문에 원자적으로 접근할 수 있을 것 같다</li><li>Volatile 키워드가 쓰여져있기 때문에 최신 값을 읽을 수 있을 것 같지만 제대로 된 고유한 값이 나오지 않는다.</li></ul><h2 id="원인은-nextserialnumber">원인은 nextSerialNumber++</h2><p>원인은 nextSerialNumber++에 있었다.<br>실제 이 코드는 1줄이지만 풀어쓰면 nextSerialNumber = nextSerialNumber + 1; 와 같은 형태이다.<br>결국 nextSerialNumber 값을 한번 읽어와 +1 한다음에 다시 nextSerialNumber 변수에 저장하는 형태이다.<br>만약 두번째 스레드가 nextSerialNumber + 1 연산이 이루어지는 시점을 비집고 들어온다면 1이 두번 리턴되는 형국이다.<br>이런 오류를 <strong>안전 실패(safety failure)</strong> 이라고 한다.</p><h2 id="문제-해결은-synchronized">문제 해결은 synchronized</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> nextSerialNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">generateSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 generateSerialNumber 메서드에 synchronized만 붙여주면 문제는 해결된다.<br>동시에 호출해도 배타적으로 실행 (한번에 한 스레드만 실행) 되기 때문이다.<br>만약 위 처럼 generateSerialNumber 메서드에 synchronized를 붙였다면 nextSerialNumber 변수에는 volatile을 제거해야 한다.<br>만약 메서드를 더 견고하게 하려면 int 대신 long을 사용하는게 더 많은 수를 사용할 수 있다.</p><h1 id="long-double을-사용할-때는-더욱-더-주의하자">long, double을 사용할 때는 더욱 더 주의하자</h1><ul><li>Java.util.concurrent.atomic 패키지의 AtomicLong, AtomicDouble을 사용하는 것이 좋다.</li><li>이 패키지는 락 없이도(lock-free) 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨 있다.</li><li>volatile은 동기화 속성 중 통신에 대해서만 보장</li><li>Java.util.concurrent.atomic 패키지는 원자성(배타적 실행) 까지 지원한다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextSerialNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">generateSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNum.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="정리">정리</h1><ul><li>동기화에 대한 문제를 피하는 가장 좋은 방법은 가변 데이터를 공유하지 않는 것이다.</li><li>가변데이터는 단일 스레드에서만 사용하는 것이 좋다</li><li>가변데이터를 단일 스레드에서만 사용한다면 문서에 남겨 유지보수 정책에서도 지켜지는것이 중요하다</li><li>멀티 스레드 환경에서 한 스레드가 데이터를 수정한 후에 다른 스레드에 공유할 때는 해당 객체에서 공유하는 부분만 동기화해도 된다.</li><li>클래스 초기화 과정에서 객체를 정적필드, volatile필드, final 필드, 혹은 보통의 락을 통해 접근하는 필드에 저장해도 된다.</li><li>여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 메서드 모두에 반드시 synchronized 키워드를 붙인다.</li><li>배타적 실행 (한번에 한스레드) 동작이 필요없고, 스레드 간 최신데이터만 읽는 거로도 충분하면 가변 변수에 volatile 키워드만으로도 동기화가 가능하다</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 78. 공유 중인 가변 데이터는 동기화해 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/11/effective-java-item78/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 74. 메서드가 던지는 모든 예외를 문서화하라</title>
      <link>https://jaehun2841.github.io/2019/03/10/effective-java-item74/</link>
      <guid>https://jaehun2841.github.io/2019/03/10/effective-java-item74/</guid>
      <pubDate>Sun, 10 Mar 2019 11:07:57 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;메서드가 던지는 예외는 그 메서드를 올바로 사용하는 데 아주 중요한 정보다.&lt;br&gt;
따라서 각 메서드가 던지는 예외 하나하나를 문서화하는 데 충분한 시간을 쏟아야 한다.&lt;/p&gt;
&lt;h1 id=&quot;검사-예외는-thr
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>메서드가 던지는 예외는 그 메서드를 올바로 사용하는 데 아주 중요한 정보다.<br>따라서 각 메서드가 던지는 예외 하나하나를 문서화하는 데 충분한 시간을 쏟아야 한다.</p><h1 id="검사-예외는-throws-태그로-문서화하라">검사 예외는 @throws 태그로 문서화하라</h1><p>검사 예외(Checked Exception)는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자.<br>공통 상위 예외 클래스 하나로 뭉뚱그려 선언하는 일은 삼가야 한다.<br>극단적인 예로 Exception이나 Throwable을 던진다고 선언해서는 안된다.<br>메서드 사용자에게 각 예외에 대처할 수 있는 힌트를 주지 못할뿐더러 같은 맥락에서 발생할 여지가 있는 다른 예외들 까지 삼켜버릴 수 있기 때문에 API 사용성을 크게 떨어뜨린다.</p><h2 id="잘못된-방법">잘못된 방법</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>같은 맥락에서 발생할 수 있는 다른 예외들까지 삼켜버려 API 사용성이 떨어진다.</li><li>main메서드는 JVM만이 호출하므로 Exception을 던지도록 선언해도 괜찮다.</li></ul><h2 id="권장하는-방법">권장하는 방법</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NumberFormatException - params가 숫자형 데이터가 아닌경우 throw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String params)</span> <span class="keyword">throws</span> IllegalStateException, SQLException, NumberFormatException </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="비검사-예외runtime-exception도-문서로-남기면-좋다">비검사 예외(Runtime Exception)도 문서로 남기면 좋다.</h1><p>자바 언어에서 요구하는 것은 아니지만 비검사 예외(Runtime Exception)도 검사 예외(Checked Exception) 처럼 정성껏 문서화 해두면 좋다.<br>비검사 예외(Runtime Exception)는 일반적으로 프로그래밍 오류를 뜻하는데 자신이 일으킬 수 있는 오류들이 무엇인지 알려주면<br>프로그래머는 자연스럽게 해당 오류가 나지 않도록 코딩하게 된다.<br>잘 정비된 비검사 예외 문서는 그 메서드를 성공적으로 수행하기 위한 전제조건이 된다.</p><p>public 메서드라면 필요한 전제조건을 문서화해야 하며, 그 수단으로 가장 좋은 것이 비검사 예외들을 문서화 하는것이다.<br><strong>특히 인터페이스에서 중요하다.</strong><br>이 조건이 인터페이스의 일반 규약에 속하게 되어 인터페이스를 구현한 모든 구현체가 일관되게 동작하도록 해주기 때문이다.</p><h1 id="비검사-예외runtime-exception은-메서드-시그니처에-추가하지-말자">비검사 예외(Runtime Exception)은 메서드 시그니처에 추가하지 말자</h1><p>메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.<br>검사냐 비검사냐에 따라 사용자가 해야할 일이 달라지므로 이 둘을 확실히 구분하는게 좋다.<br>자바독은 메서드 시그니처에 throws 절에 등장하고 메서드 주석의 @throws 태그에도 명시한 예외와 @throws 태그에만 명시한 예외를 시각적으로 구분해준다.<br>그래서 프로그래머는 어떤 것이 비검사 예외인지 바로 알 수 있다.</p><h1 id="거의-모든-메서드에서-같은-예외를-던진다면-class-설명에-추가하라">거의 모든 메서드에서 같은 예외를 던진다면 Class 설명에 추가하라</h1><p>한 클래스에 정의된 웬만한 메서드에서 같은 이유로 같은 예외를 던진다면 그 예외를 각각의 메서드가 아니라 클래스 설명에 추가하는 방법도 있다.<br>NullPointerException이 가장 흔한 사례다.<br>이럴 때는 클래스의 문서화 주석에 <strong>이 클래스의 모든 메서드는 인수로 null이 넘어오면 NullPointerException을 던진다.</strong> 라고 적어도 좋다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 74. 메서드가 던지는 모든 예외를 문서화하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/10/effective-java-item74/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 73. 추상화 수준에 맞는 예외를 던지라</title>
      <link>https://jaehun2841.github.io/2019/03/10/effective-java-item73/</link>
      <guid>https://jaehun2841.github.io/2019/03/10/effective-java-item73/</guid>
      <pubDate>Sun, 10 Mar 2019 10:31:02 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;수행하려는 일과 관련 없어 보이는 예외가 튀어나오면 당황스럽다.&lt;br&gt;
메서드가 저수준 예외를 처리하지 않고 바깥으로 throw 해버릴 때 상위 메서드에서 종종 발생하는 일이다.&lt;br&gt;
내부 구현방식을 상위에 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>수행하려는 일과 관련 없어 보이는 예외가 튀어나오면 당황스럽다.<br>메서드가 저수준 예외를 처리하지 않고 바깥으로 throw 해버릴 때 상위 메서드에서 종종 발생하는 일이다.<br>내부 구현방식을 상위에 드러내어 윗 레벨 API를 오염 시킬 수 있고, 다음 릴리스에서 구현방식이 변경되면 다른 예외가 튀어나와<br>기존 클라이언트 프로그램을 깨지게 할 수도 있다.</p><h1 id="상위-메서드에서-저수준-예외를-번역해야-한다">상위 메서드에서 저수준 예외를 번역해야 한다.</h1><p>상위 메서드에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다.<br>이를 예외 번역(Exception Translation)이라 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">..<span class="comment">// 저수준 추상화를 이용</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (LowerLevelException e) &#123;</span><br><span class="line">  <span class="comment">// 추상화 수준에 맞게 번역</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> HigherLevelException(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="저수준-예외의-내용이-필요하다면-예외-연쇄를-사용하라">저수준 예외의 내용이 필요하다면 예외 연쇄를 사용하라</h1><p>예외 연쇄(Exception chaining)이란 문제의 근본 원인(cause)인 저수준 예외를 고수준 예외에 실어 보내는 방식이다.<br>별도의 접근자 메서드(Throwable의 getCause메서드)를 통해 필요하면 언제든 저수준 예외를 꺼내 볼 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 저수준 추상화를 이용한다.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (LowerLevelException cause) &#123;</span><br><span class="line">  <span class="comment">// 저수준 예외를 고수준 예외에 실어 보낸다.</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> HigherLevelException(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HigherLevelException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">  HigherLevelException(Throwable cause) &#123;</span><br><span class="line">    <span class="keyword">super</span>(cause);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있다.<br>그렇지 않은 예외라도 Throwable의 initCause 메서드를 이용해 <code>원인</code> 을 직접 못박을 수 있다.<br>예외 연쇄는 문제의 원인을 프로그램에서 접근할 수 있게 해주며 원인과 고수준 예외의 Stack trace를 잘 통합해준다.</p><h1 id="예외-번역을-남용하지-말자">예외 번역을 남용하지 말자</h1><p>가능하다면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.<br>때로는 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 Validator를 이용하여 미리 검사하는 것이 좋다.</p><p>아래 계층에서의 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리하여 문제를 API 호출자에 전파하지 않는 방법이 있다.<br>이 경우 발생한 예외는 log를 활용하여 개발자가 디버깅을 할 수 있는 정도면 충분하다</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  lowerLevelMethod();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="comment">//Exception을 먹어버리고 상위로 전파되지 않도록 한다.</span></span><br><span class="line">  log.error(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="정리">정리</h1><ul><li>아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라</li><li>예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에  좋다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 73. 추상화 수준에 맞는 예외를 던지라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/10/effective-java-item73/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 72. 표준 예외를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/10/effective-java-item72/</link>
      <guid>https://jaehun2841.github.io/2019/03/10/effective-java-item72/</guid>
      <pubDate>Sun, 10 Mar 2019 09:58:11 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;숙련된 프로그래머는 그렇지 못한 프로그래머보다 더 많은 코드를 재사용한다.&lt;br&gt;
예외도 마찬가지로 재사용하는 것이 좋으며, 자바 라이브러리는 대부분 API에서 쓰기에 충분한 수의 예외를 제공한다.&lt;/p&gt;
&lt;h
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>숙련된 프로그래머는 그렇지 못한 프로그래머보다 더 많은 코드를 재사용한다.<br>예외도 마찬가지로 재사용하는 것이 좋으며, 자바 라이브러리는 대부분 API에서 쓰기에 충분한 수의 예외를 제공한다.</p><h1 id="표준-예외를-재사용하라">표준 예외를 재사용하라</h1><ul><li>표준 예외를 사용하면 다른사람이 API를 익히고 사용하기 쉬워진다 (많은 개발자들이 이미 익숙하게 사용하기 때문)</li><li>표준 예외를 사용한 API는 다른 개발자가 API를 사용하더라도 낯선 예외를 사용하지 않아 코드의 가독성이 높아진다.</li><li>예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스를 로딩하는 시간도 적게 걸린다.<br>(무분별하게 커스텀 예외 클래스를 만들면 빌드하는 시간도 오래 걸리고 클래스 로딩 시간도 더 걸린다는 소리)</li></ul><h1 id="가장-많이-사용되는-예외">가장 많이 사용되는 예외</h1><h2 id="illegalargumentexception">IllegalArgumentException</h2><ul><li>호출자가 인수로 부적절한 값을 넘길 때 던지는 예외</li><li>반복 횟수 (loop count)를 지정하는 매개변수에 음수를 건넬 때 쓸 수 있다.</li><li>메서드의 파라미터로 <code>null 값</code>이 들어오면 관례상 IllegalArgumentException보다는 <code>NullPointerException</code>을 던진다.</li><li>시퀀스의 허용 범위를 넘는 값을 건넬 때도 IllegalArgumentException보다는 <code>IndexOutOfBoundsException</code>을 던진다.</li></ul><h2 id="illegalstateexception">IllegalStateException</h2><ul><li>대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때 주로 던진다.</li><li>예를 들면, 초기화되지 않은 객체를 사용하려 할 때 던질 수 있다.</li></ul><h2 id="concurrentmodificationexception">ConcurrentModificationException</h2><ul><li>단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때 던진다.<br>(외부 동기화 방식으로 사용하려고 설계한 객체도 마찬가지다.)</li><li>동시 수정을 확실히 검출할 수 있는 안정된 방법은 없으나, 문제가 생길 가능성 정도만 알려주는 역할도 쓰인다.</li></ul><h2 id="unsupportedoperationexception">UnsupportedOperationException</h2><ul><li>예외는 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 던진다.</li><li>보통 구현하려는 인터페이스의 메서드 일부를 구현할 수 없는 경우에 사용</li></ul><h2 id="arithmeticexception-numberformatexception">ArithmeticException, NumberFormatException</h2><ul><li>복소수나 유리수를 다루는 객체를 사용할 때 사용</li><li>10 / 0 과 같은 연산을 할 때 ArithmeticException이 발생한다.</li><li>숫자형 파라미터가 와야 하는 부분에 String이라든지 다른 형식의 데이터가 들어오는 경우 NumberFormatException이 발생</li></ul><h1 id="예외-사용-시-주의할-점">예외 사용 시 주의할 점</h1><ul><li>Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자.<br>(다른 예외들의 상위 클래스이기 때문에 안정적으로 테스트 할 수 없다.)</li><li>예외에서 더 많은 정보를 제공하길 원한다면 표준 예외를 확장해도 좋다.<br>(단 예외는 직렬화할 수 있기 때문에 주의해야 한다.)</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 72. 표준 예외를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/10/effective-java-item72/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 68. 일반적으로 통용되는 명명 규칙을 따르라</title>
      <link>https://jaehun2841.github.io/2019/03/03/effective-java-item68/</link>
      <guid>https://jaehun2841.github.io/2019/03/03/effective-java-item68/</guid>
      <pubDate>Sun, 03 Mar 2019 10:12:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바 플랫폼은 명명 규칙이 잘 정립되어 있으며, 그중 많은 것이 자바 언어 명세에 기술되어 있다.&lt;br&gt;
자바의 명명 규칙은 철자와 문법 두 범주로 나뉜다.&lt;br&gt;
철자 규칙은 패키지, 클래스, 인터페이스, 메
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바 플랫폼은 명명 규칙이 잘 정립되어 있으며, 그중 많은 것이 자바 언어 명세에 기술되어 있다.<br>자바의 명명 규칙은 철자와 문법 두 범주로 나뉜다.<br>철자 규칙은 패키지, 클래스, 인터페이스, 메서드, 필드, 타입 변수의 이름을 다룬다.<br>이 규칙들은 특별한 이유가 없는 한 반드시 따르는게 좋고 이를 어기면 다른 프로그래머들이 그 코드를 읽기 번거로울 뿐 아니라 다른뜻으로 오해할 수도 있고 그로 인해 장애로 발전할 수 있다.</p><h1 id="명명-규칙">명명 규칙</h1><h2 id="패키지-package">패키지 (Package)</h2><ul><li>패키지 (Package)와 모듈 이름은 각 요소를 **점(.)**으로 구분하여 계층적으로 짓는다.</li><li>요소들은 모두 소문자 알파벳 혹은 숫자로 이뤄진다.</li><li>com.google, kr.co.edu와 같은 식이다.</li><li>패키지를 설명하는 하나이상의 요소로 이루어져 있다.</li><li>일반적으로 8자 이하의 짧은 단어로 한다.</li><li>utilities보다는 util처럼 의미가 통하는 약어가 좋다.</li><li>요소의 이름은 보통 한 단어 혹은 약어로 이루어진다.</li><li>많은 기능을 제공하는 애플리케이션의 경우에는 계층을 더 많은 요소로 나누는 것이 좋다.</li></ul><h2 id="클래스-인터페이스-열거타입">클래스, 인터페이스, 열거타입</h2><ul><li>클래스 명은 하나이상의 단어로 구성되며, 첫글자는 대문자로 작성한다.</li><li>여러 단어의 첫글자만 딴 약자나 널리 통용되는 줄임말을 제외하고는 줄임말을 쓰지 않도록 한다.</li><li>조합한 단어를 구분할 수 있게 <strong>camel case</strong>로 작성한다.</li></ul><h2 id="메서드-필드명">메서드, 필드명</h2><ul><li>첫 글자를 소문자로 작성하고 클래스 명과 같게 단어 별로 <strong>camel case</strong>로 작성한다.</li><li>첫 단어가 약자라면 단어 전체가 소문자여야 한다.</li><li>상수 필드는 예외다. 상수 필드를 구성하는 단어는 모두 대문자로 쓰며 단어 사이는 언더바(_)로 구분한다.<br>(VALUES, NEGATIVE_INFINITY등..)</li><li>상수 필드는 static final인 타입을 의미한다.</li><li>가르키는 객체가 불변이라면, 그 타입은 가변이어도 상수이다.</li><li>지역번수에도 동일한 규칙이 적용된다. 단, 문맥에서 의미를 쉽게 유추할 수 있는 경우에는 <strong>약어를 사용해도 좋다.</strong><br>(i, denom, houseNum등..)</li><li>타입 매개변수의 이름은 한 글자로 표현한다.<ul><li>T: 임의의 타입 (Type)</li><li>E: 컬렉션의 원소 (Element)</li><li>K: 맵의 키 (Key)</li><li>V: 맵의 값 (Value)</li><li>X: 예외 (eXception)</li><li>R: 메서드의 반환타입 (Return)</li><li>그 이외의 타입에는 T, U, V 혹은 T1, T2, T3의 식으로 사용</li></ul></li></ul><h1 id="명명-규칙2">명명 규칙2</h1><ul><li>객체를 생성하는 클래스나 열거타입 인터페이스는 <strong>단수 명사나 명사구를 사용한다.</strong><ul><li>Thread, PriorityQueue, ChessPiece 등..</li></ul></li><li>객체를 생성할 수 없는 클래스 (Utils 클래스)에는 보통 <strong>복수형 명사로 짓는다.</strong><ul><li>Collectors, Collections 등..</li></ul></li><li>인터페이스 이름은 클래스명과 동일하게 짓거나, <strong>ible, able로 끝나는 형용사로 짓는다.</strong><ul><li>Runnable, Iterable, Accessible 등...</li></ul></li><li>애너테이션은 워낙 다양하게 활용되어 지배적인 규칙이 없이 명사, 형용사, 동사, 전치사가 두루 쓰인다.<ul><li>@Binding, @Inject, @ImplementsBy, @Singleton 등..</li></ul></li><li>메서드의 이름은 동사나 목적어를 포함한 <strong>동사구로 짓는다.</strong><ul><li>append, drawImage</li></ul></li><li>boolean 값을 반환하는 메서드라면 <strong>is~, has~로 짓는다.</strong><ul><li>isDigit, isEmpty, hasSiblings 등..</li></ul></li><li>반환타입이 boolean이 아닌경우 보통 명사, 명사구, get~로 짓는다.<ul><li>size, hashcode, getTime 등...</li><li>get으로 시작하는 형태는 주로 자바빈즈(JavaBeans) 명세에 뿌리를 두고 있다.</li><li>보통 getter/setter의 한 묶음 형태로 만드는 경우가 많다.</li></ul></li><li>반환타입을 또다른 타입을 반환하는 경우에는<strong>toType</strong> 의 형태로 짓는다.<ul><li>toString, toArray 등..</li></ul></li><li>객체의 내용을 다른 뷰로 보여주는 메서드는 <strong>asType</strong> 의 형태로 짓는다.<ul><li>asList, asMap 등..</li></ul></li><li>객체의 값을 기본 타입(primitive type)으로 반환하는 경우에는 <strong>typeValue</strong> 의 형태로 짓는다.<ul><li>intValue, longValue 등...</li></ul></li><li>정적 팩터리의 이름은 다양하다<ul><li>from, valueOf, getInstance, newInstance 등..</li></ul></li></ul><h1 id="정리">정리</h1><ul><li>표준 명명 규칙을 체득하여 자연스럽게 사용하도록 연습하자</li><li>철자 규칙은 직관적이라 모호한 부분이 적지만, 문법 규칙은 더 복잡하고 느슨하다</li><li>오랫동안 따라온 규칙과 충돌한다면 그 규칙을 맹종해서는 안된다. 상식대로 가자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 68. 일반적으로 통용되는 명명 규칙을 따르라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/03/effective-java-item68/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 67. 최적화는 신중히 하라</title>
      <link>https://jaehun2841.github.io/2019/03/03/effective-java-item67/</link>
      <guid>https://jaehun2841.github.io/2019/03/03/effective-java-item67/</guid>
      <pubDate>Sun, 03 Mar 2019 09:49:08 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;최적화에-대한-명언&quot;&gt;최적화에 대한 명언&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;맹목적인 어리석음을 포함해 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다 (심지어 효율을 높이지도 못하면서)&lt;/p&gt;
&lt;p&gt;- 윌리엄 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="최적화에-대한-명언">최적화에 대한 명언</h1><blockquote><p>맹목적인 어리석음을 포함해 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다 (심지어 효율을 높이지도 못하면서)</p><p>- 윌리엄 울프(Wulf72)</p></blockquote><blockquote><p>(전체의 97% 정도인) 자그마한 효율성은 모두 잊자. 섣부른 최적화가 만약의 근원이다. - 도널드 크누스(Knuth74)</p></blockquote><blockquote><p>최적화를 할 때는 다음 두 규칙을 따르라.</p><p>첫 번째, 하지마라.<br>두 번째, (전문가 한정) 아직 하지 마라. 다시 말해, 완전히 명백하고 최적화되지 않은 해법을 찾을 때까지는 하지 마라.<br>- M.A 잭슨 (Jackson75)</p></blockquote><p>위의 명언들을 풀어보면,<br>최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고 섣불리 진행하면 특히 더 그렇다.<br>빠르지도 않고 제대로 동작하지도 않으면서 수정하기는 어려운 소프트웨어를 탄생시키는 것이다.</p><h1 id="프로그램을-설계할-때-생각해야-할-점">프로그램을 설계할 때 생각해야 할 점</h1><h2 id="빠른-프로그램보다는-좋은-프로그램을-작성하자">빠른 프로그램보다는 좋은 프로그램을 작성하자</h2><ul><li>좋은 프로그램이지만 원하는 성능이 나오지 않는다면 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것이다.</li><li>좋은 프로그램은 정보 은닉(캡슐화) 원칙을 따르므로 개별 구성요소 내부를 독립적으로 설계할 수 있다.</li><li>따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다.</li><li>구현상의 문제는 나중에 최적화 할 수 있지만, 아키텍처의 결함이 성능을 제한한다면 시스템을 다시 작성해야 하기 때문이다.</li><li>따라서 설계 단계에서 성능을 반드시 염두하자</li></ul><h2 id="성능을-제한하는-설계를-피하라">성능을 제한하는 설계를 피하라</h2><ul><li>완성 후 변경하기가 가장 어려운 설계 요소는 컴포넌트끼리 또는 외부 시스템과의 소통 방식이다.</li><li>API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등이 있다.</li><li>완성후에는 변경하기 어렵거나 불가능 하고, 동시에 시스템 성능을 제한할 수 있다.</li></ul><h2 id="api를-설계할-때-성능에-주는-영향을-고려하라">API를 설계할 때 성능에 주는 영향을 고려하라</h2><ul><li>가변 객체를 사용하여 내부데이터를 변경할 수 있게 만들면 불필요한 방어적 복사를 유발할 수 있다.</li><li>컴포지션으로 해결할 수 있는 경우에도 상속을 이용하면 상위클래스에 영원히 종속되고, 성능 제약까지 물려받는다</li><li>인터페이스도 있는데 굳이 클래스 타입으로 사용하면, 차후 개선된 구현체를 사용하기 어려워진다.</li></ul><h2 id="성능을-위해-api를-왜곡하지-말자">성능을 위해 API를 왜곡하지 말자</h2><ul><li>API를 왜곡하도록 만든 성능 문제는 해당 플랫폼이나 아랫단 소프트웨어의 다음 버전에서 사라질 수 있다.</li><li>왜곡된 API를 지원하는 데 따르는 고통은 영원하다</li></ul><h2 id="프로파일링-도구를-적극-활용하자">프로파일링 도구를 적극 활용하자</h2><ul><li>프로파일링 도구는 최적화 노력을 어디에 집중해야 할지 찾는 데 도움을 준다.</li><li>개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 제공하여 개발자의 수고를 덜어준다.</li><li>JMH도 알아야 하는 도구이다.  프로파일러는 아니지만 자바 코드의 상세한 성능을 알기 쉽게 보여주는 마이크로 벤치마킹 프레임워크다.</li></ul><h1 id="정리">정리</h1><ul><li>빠른프로그램을 작성하려 하지 말고 좋은 프로그램을 작성하려 노력하자. 성능은 따라오기 마련이다.</li><li>시스템을 설계할 때 API, 네트워크 프로토코르 영구 저장용 데이터 포맷을 설계할 때는 성능을 염두하자</li><li>시스템 구현을 완료했으면 측정해보고 충분히 빠르면 최적화를 하지 마라</li><li>성능 측정 시에는 프로파일링 도구를 이용해 문제의 원인이 되는 지점을 찾아 최적화하자</li><li>알고리즘을 잘못 골랐다면, 저수준 최적화는 의미가 없다.</li><li>만족할 만한 성능이 나올 때까지 위의 과정을 반복하고, 변경 후에는 성능 측정을 꼭하자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 67. 최적화는 신중히 하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/03/effective-java-item67/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 66. 네이티브 메서드는 신중히 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/03/effective-java-item66/</link>
      <guid>https://jaehun2841.github.io/2019/03/03/effective-java-item66/</guid>
      <pubDate>Sun, 03 Mar 2019 09:09:15 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바 네이티브 인터페이스(Java Native Interface, JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;네이티브 메서드란?&lt;/p&gt;
&lt;p&gt;C나 C++
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바 네이티브 인터페이스(Java Native Interface, JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다.</p><blockquote><p>네이티브 메서드란?</p><p>C나 C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다.</p></blockquote><h1 id="네이티브-메서드의-주요-쓰임">네이티브 메서드의 주요 쓰임</h1><ul><li>Registry 같은 플랫폼 특화기능을 사용한다.<ul><li>하지만 자바가 진화해가면서 하부 플랫폼의 기능을 흡수하고 있다.</li><li>네이티브 메서드를 사용해야하는 일이 줄어들고 있다.</li><li>자바9 부터는 process API를 추가해 OS에 접근하는 길을 열어주었다.</li></ul></li><li>네이티브 코드로 작성된 기존 라이브러리를 사용해야 하는 경우<ul><li>레거시 데이터를 사용하는 레거시 라이브러리</li><li>Java로 된 라이브러리가 없는 경우 네이티브 라이브러리를 사용한다.</li></ul></li><li>성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.</li></ul><h1 id="네이티브-메서드를-성능개선의-목적으로-사용하지-말라">네이티브 메서드를 성능개선의 목적으로 사용하지 말라</h1><ul><li>자바 초기 시절 (Java 1.3)이전이라면 다른 얘기지만, 그동안 JVM은 빠른 속도로 발전해 왔다.</li><li>대부분의 작업에서 Java는 다른 플랫폼과 견줄만한 성능을 보인다 (자바가 느리다는 것도 옛말)</li><li>네이티브 라이브러리 쪽은 GNU 다중 정밀 연산 라이브러리(GMP)를 필두로 개선 작업이 계속돼왔다.<br>고성능의 다중 정밀 연산이 필요한 경우에는 네이티브 메서드를 통해 GMP를 사용하는것을 고려해보자</li></ul><h1 id="네이티브-메서드의-단점">네이티브 메서드의 단점</h1><ul><li>네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로 부터 안전하지 않다.</li><li>네이티브 언어는 플랫폼 종속성이 있으므로 이식성이 좋지 못하다</li><li>디버깅도 어렵다</li><li>오히려 속도가 더 느릴 수 있다.</li><li>JVM의 가비지 컬렉터는 네이티브 메모리는 자동 회수 하지 못하고 추적도 할 수 없다.</li><li>자바 코드와 네이티브 코드의 경계를 넘나 들때마다 비용이 발생한다.</li><li>자바 코드와 네이티브 코드간의 접착 코드(glue code)를 작성해야 하는데 이 부분도 귀찮고 가독성도 떨어진다.</li></ul><h1 id="정리">정리</h1><ul><li><p>네이티브 메서드를 사용하는 경우는 한번 더 생각하라</p></li><li><p>네이티브 메서드가 그렇게 성능 향상에 도움을 주지는 않는다.</p></li><li><p>네이티브 메서드를 사용해야 하는 경우에는 최소한으로 사용하고 철저한 테스트를 해야한다.</p></li><li><p>숨은 버그하나가 애플리케이션 전체에 영향을 줄 수도 있다.</p></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 66. 네이티브 메서드는 신중히 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/03/effective-java-item66/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 65. 리플렉션보다는 인터페이스를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/03/effective-java-item65/</link>
      <guid>https://jaehun2841.github.io/2019/03/03/effective-java-item65/</guid>
      <pubDate>Sun, 03 Mar 2019 07:57:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;리플렉션 기능(java.lang.reflect)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.&lt;br&gt;
Class 객체가 주어지면 클래스 정보를 통해 아래와 같은 인스턴스를 가져올 수 있다.&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>리플렉션 기능(java.lang.reflect)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.<br>Class 객체가 주어지면 클래스 정보를 통해 아래와 같은 인스턴스를 가져올 수 있다.</p><ul><li>Constructor<ul><li>생성자 시그니처를 가져올 수 있다.</li><li>생성자 인스턴스를 통해 객체를 생성할 수 있다.</li></ul></li><li>Method<ul><li>Method 시그니처를 가져올 수 있다.</li><li>Method 인스턴스를 통해 Method를 실행시킬 수 있다. (Method.invoke)</li></ul></li><li>Field<ul><li>필드타입, 멤버필드 이름등을 가져올 수 있다.</li></ul></li></ul><h1 id="리플렉션의-단점">리플렉션의 단점</h1><p>리플렉션을 이용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있다.<br>(예를들면.. 외부 라이브러리의 클래스를 리플렉션으로 인스턴스를 생성한다든지…)</p><h2 id="컴파일타임-타입-검사가-주는-이점을-누릴-수-없다">컴파일타임 타입 검사가 주는 이점을 누릴 수 없다.</h2><ul><li>예외 검사, 컴파일 타임 에러를 잡아낼 수 없다.</li><li>프로그램이 리플렉션 기능을 써서 존재하지 않는 혹은 접근 불가능한 (private 메서드)를 호출하려 하면 런타임 오류가 발생한다.</li></ul><h2 id="리플렉션을-이용하면-코드가-지저분하고-장황해진다">리플렉션을 이용하면 코드가 지저분하고 장황해진다.</h2><ul><li>지루한 일이고 읽기도 어렵다.</li></ul><h2 id="성능이-떨어진다">성능이 떨어진다.</h2><ul><li>리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느리다.</li><li>고려해야 하는 요소가 많아 정확한 차이는 이야기하기 어렵다</li><li>하지만 분명 느리다.</li></ul><h2 id="리플렉션은-아주-제한된-형태로만-사용해야-그-단점을-피할-수-있다">리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피할 수 있다</h2><ul><li>컴파일타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램은 비록 컴파일타임이라도 적절한 인터페이스나 상위 클래스를 이용할 수는 있을것이다.</li><li>리플렉션은 인스턴스 생성에만 쓰고 이렇게 만든 인터페이스나 상위 클래스로 참조해 사용하자</li></ul><h1 id="리플렉션의-취약한-예">리플렉션의 취약한 예</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 클래스 이름을 Class 객체로 변환</span></span><br><span class="line">    Class&lt;? extends Set&lt;String&gt;&gt; cl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = (Class&lt;? extends Set&lt;String&gt;&gt;) Class.forName(args[<span class="number">0</span>]); <span class="comment">//비검사 형변환</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"클래스를 찾을 수 없습니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생성자를 얻는다.</span></span><br><span class="line">    Constructor&lt;? extends Set&lt;String&gt;&gt; cons = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cons = cl.getDeclaredConstructor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"매개변수 없는 생성자를 찾을 수 없습니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//집합의 인스턴스를 만든다.</span></span><br><span class="line">    Set&lt;String&gt; s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        s = cons.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"생성자에 접근할 수 없습니다."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"클래스를 인스턴스화할 수 없습니다."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"생성자가 예외를 던졌습니다: "</span> + e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"Set을 구현하지 않은 클래스입니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//생성한 집합을 사용한다.</span></span><br><span class="line">    s.addAll(Arrays.asList(args).subList(<span class="number">1</span>, args.length));</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fatalError</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.err.println(msg);</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 예시는 리플렉션의 단점을 보여준다.</p><ul><li>런타임에 총 6가지의 예외를 던질 수 있다.</li><li>위에서 발생하는 예외는 모두 컴파일타임에 체크할 수 있는 예외들이다.</li><li>클래스 이름만으로 인스턴스를 생성해내기 위해 무려 25줄이나 되는 코드를 작성했지만, 그게 아닌 경우에는 생성자 1줄이면 끝난다.</li><li>리플렉션 예외를 각각 잡는 대신 상위 클래스인 ReflectiveOperationException을 잡으면 코드량을 줄일 수 있다.<br>(ReflectiveOperationException은 Java 7부터 지원한다.)</li></ul><h1 id="리플렉션은-무조건-쓰지-말아야-한다">리플렉션은 무조건 쓰지 말아야 한다?</h1><ul><li>Spring MVC, Serialize/Deserialize, BeanUtils.copyProperties등 실무에서 사용하는 코드에 리플렉션이 적용된 예는 굉장히 많다.</li><li>단점이 많다고는 하지만 공통적인 기능을 설계하거나, 재사용 가능한 코드를 설계할 경우에는 오히려 리플렉션이 적합할 수 있다.</li><li>그렇기 때문에 Java 1.3 이후부터 리플렉션에 대한 성능향상을 발전시켜왔다고 한다.</li><li>이러한 발전으로 리플렉션은 우려할 만큼 성능이 떨어지지는 않는다고 한다.</li><li>리플렉션을 남발하는 것이 아닌 필요한 상황에 적시적소에 사용한다면 오히려 서비스 개발을 더 단순화 시킬수 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 65. 리플렉션보다는 인터페이스를 사용하라</li><li><a href="https://kmongcom.wordpress.com/2014/03/15/%EC%9E%90%EB%B0%94-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%A4%ED%95%B4%EC%99%80-%EC%A7%84%EC%8B%A4/" target="_blank" rel="noopener">Java 리플렉션의 오해와 진실</a></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/03/effective-java-item65/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 64. 객체는 인터페이스를 사용해 참조하라</title>
      <link>https://jaehun2841.github.io/2019/03/01/effective-java-item64/</link>
      <guid>https://jaehun2841.github.io/2019/03/01/effective-java-item64/</guid>
      <pubDate>Fri, 01 Mar 2019 12:33:55 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Item 51에 제네릭 타입으로 클래스가 아니라 인터페이스를 사용하라고 설명 되어있다.&lt;br&gt;
이 말의 의미는 &lt;strong&gt;객체는 클래스가 아닌 인터페이스로 참조하라&lt;/strong&gt; 라는 의미로 확장할 수 있
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Item 51에 제네릭 타입으로 클래스가 아니라 인터페이스를 사용하라고 설명 되어있다.<br>이 말의 의미는 <strong>객체는 클래스가 아닌 인터페이스로 참조하라</strong> 라는 의미로 확장할 수 있다.<br>적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언해야 한다.</p><h1 id="유연한-프로그램을-생성하는-인터페이스-타입-변수">유연한 프로그램을 생성하는 인터페이스 타입 변수</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//좋은 예</span></span><br><span class="line">Set&lt;Son&gt; sonSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//나쁜 예</span></span><br><span class="line">LinkedHashSet&lt;Son&gt; sonSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br></pre></td></tr></table></figure></p><ul><li>좋은 예는 Set 인터페이스 타입으로 변수를 선언하였다.</li><li>나쁜 예는 LinkedHashSet 타입으로 변수를 선언하였다.</li></ul><p>만약 LinkedHashSet을 TreeSet으로 변환해야 한다면 어떨까?</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//좋은 예</span></span><br><span class="line">Set&lt;Son&gt; sonSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//나쁜 예</span></span><br><span class="line">LinkedHashSet&lt;Son&gt; sonSet = <span class="keyword">new</span> TreeSet&lt;&gt;(); <span class="comment">//컴파일 에러!</span></span><br></pre></td></tr></table></figure></p><ul><li>위의 좋은 예는 Set 인터페이스 타입이기 때문에 컴파일 타임/런타임에 전혀 문제가 되지 않는다.</li><li>나쁜 예는 LinkedHashSet 타입이기 때문에 TreeSet을 LinkedHashSet로 형변환 할 수 없다고 에러가 발생한다.</li></ul><h1 id="인터페이스-타입의-장점">인터페이스 타입의 장점</h1><ul><li>인터페이스 타입을 사용하면 클라이언트 코드를 수정하지 않고도 참조 객체를 변경할 수 있다.</li><li>다른 타입의 객체를 사용하더라도 컴파일에러/런타임에러에 대한 걱정을 하지 않아도 된다.</li></ul><h1 id="인터페이스-타입의-단점">인터페이스 타입의 단점</h1><ul><li>인터페이스 타입에 선언된 메서드를 구현한 메서드만 사용이 가능하다.</li><li>특정 구현체의 내부 메서드를 사용할 수 없다.</li></ul><h1 id="클래스를-참조해야-하는-경우">클래스를 참조해야 하는 경우</h1><h2 id="값-타입에는-클래스를-참조하라">값 타입에는 클래스를 참조하라</h2><ul><li>String, Integer, Long과 같이 값 타입에 대해서는 인터페이스를 사용할 수 없으니 클래스를 참조해야 한다.</li><li>또한 Integer, Long과 같은 타입을 사용할 때는 Number와 같은 상위 타입을 사용하지 말아야 한다.<br><strong>형변환이 발생 할 때 특정 데이터가 절삭되어 다른 결과가 발생 할 수 있기 때문이다.</strong></li><li>이런 경우에는 인터페이스나 상위타입 보다는 본래의 클래스로 참조하는 것이 좋다.</li></ul><h2 id="인터페이스에는-없는-메서드를-사용할-때에는-클래스를-참조해라">인터페이스에는 없는 메서드를 사용할 때에는 클래스를 참조해라</h2><ul><li>PriorityQueue 클래스에는 Queue 인터페이스에는 없는 comparator 메서드를 제공한다.</li><li>클래스 타입을 직접 사용하는 경우에는 추가 메서드를 사용해야 하는 경우로 최소화 하는 것이 좋다.</li></ul><h1 id="정리">정리</h1><ul><li>인터페이스나 추상클래스를 구현하는 클래스를 사용할 때는 참조 변수를 인터페이스나 추상클래스로 사용하자</li><li>인터페이스나 추상클래스 타입으로 참조 변수를 사용하면 참조 객체를 바꿔도 안전하다</li><li>값 타입을 사용하는 경우에는 클래스 타입의 참조변수를 사용해야 한다.</li><li>인터페이스에는 없는 메서드를 사용할 때는 클래스 타입의 참조변수를 사용해야 한다.</li><li>적합한 인터페이스가 없다면 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 상위 타입을 사용해야 한다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 64. 객체는 인터페이스를 사용해 참조하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/01/effective-java-item64/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 63. 문자열 연결은 느리니 주의하라</title>
      <link>https://jaehun2841.github.io/2019/03/01/effective-java-item63/</link>
      <guid>https://jaehun2841.github.io/2019/03/01/effective-java-item63/</guid>
      <pubDate>Fri, 01 Mar 2019 11:45:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;문자열 연결 연산자(+)는 여러 문자열을 하나로 합쳐주는 편리한 수단이다.&lt;br&gt;
그런데 한 줄짜리 출력값(&lt;code&gt;return prefix + str + suffix;&lt;/code&gt; 정도?)  혹은 작고 크기
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>문자열 연결 연산자(+)는 여러 문자열을 하나로 합쳐주는 편리한 수단이다.<br>그런데 한 줄짜리 출력값(<code>return prefix + str + suffix;</code> 정도?)  혹은 작고 크기가 고정된 객체의 문자열 표현을 만들 때라면 괜찮다.<br>하지만 문자열 여러개를 사용하기 시작하면 성능 저하를 피할 수 없다.</p><p><strong>문자열 연결 연산자로 문자열 n개를 연결하는 시간은 n^2에 비례한다.</strong><br>문자열은 불변이기 때문에 두 문자열을 연결하는 경우에는 양쪽의 내용을 복사하여 연결한 다음 새로운 String 객체를 만들어야 하기 때문이다.</p><h1 id="문자열-연결을-잘못-사용한-예-느리다">문자열 연결을 잘못 사용한 예 - 느리다!</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numItems(); i++) &#123;</span><br><span class="line">        result += lineForItem(i); <span class="comment">//문자열 연결</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="stringbuilder를-사용하여-문자열을-연결한-예">StringBuilder를 사용하여 문자열을 연결한 예</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">statement2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(numItems() * LINE_WIDTH);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numItems(); i++) &#123;</span><br><span class="line">       sb.append(lineForItem(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>자바 6이후 문자열 연결 성능을 다방면으로 개선 했지만, 두 메서드의 성능 차이는 여전하다.</p><h1 id="string-stringbuffer-stringbuilder의-비교">String, StringBuffer, StringBuilder의 비교</h1><ul><li>String과 StringBuffer는 Java 1.0의 등장과 함께 같이 등장하였다.</li><li>StringBuilder는 조금 뒤인 Java 1.5부터 등장하였다.</li><li>String의 concat연산은 + 기호를 사용하여 concatination을 수행한다.</li><li>StringBuffer와 StringBuilder는 append 메서드를 통해 concatination을 수행한다.</li><li>정확히 말하면 StringBuffer와 StringBuilder는 AbstractStringBuilder를 상속하고 있으며,<br>결국은 같은 append 메서드를 사용한다.</li><li>StringBuffer와 StringBuilder 차이점은 thread-safe에 있다.<ul><li>StringBuffer의 append 메서드에는 <code>syncronized</code> 예약어가 붙어있어 thread-safe하다</li><li>StringBuilder의 append 메서드는 thread-safe 하지 않다.</li><li>따라서 multi-thread 환경에서 문자열 결합을 할 때는 StringBuffer를 사용하는 것이 안전하다.</li><li>단일 thread라면 StringBuilder를 사용하는 것이 StringBuffer보다 성능이 더 좋다.<br>(아무래도 동기화 체크를 안해도 되니 말이다.)</li></ul></li></ul><h2 id="string-string-연산이-느린-이유">String + String 연산이 느린 이유</h2><ul><li>String은 불변 클래스이기 때문에 String + String을 하기 위해서는</li><li>String내의 char[] 혹은 byte[]를 copy한다.</li><li>2개의 array의 length를 더한 값으로 새로운 array를 생성한다.</li><li>array에 기존의 값을 채워넣는다.</li><li>new String(byte[]) 생성자를 통해 새로운 String 객체를 생성한다.</li><li>이런식으로 하면 String + String 연산이 일어날 때마다 String 객체가 생성된다.</li><li>Heap Memory에 String 객체가 많아지면 GC가 돌면서 String 객체를 제거한다.</li><li>GC는 동작 시 stop the world라는 행위를 한다. <strong>(JVM의 작동이 일시적으로 멈춘다.</strong>)</li><li>위와 같은 행위가 계속되면 당연히 느려 질 수 밖에 없다.</li></ul><h2 id="stringbuilderappend-메서드-파헤치기">StringBuilder.append() 메서드 파헤치기</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified string to this character sequence.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The characters of the &#123;<span class="doctag">@code</span> String&#125; argument are appended, in</span></span><br><span class="line"><span class="comment">     * order, increasing the length of this sequence by the length of the</span></span><br><span class="line"><span class="comment">     * argument. If &#123;<span class="doctag">@code</span> str&#125; is &#123;<span class="doctag">@code</span> null&#125;, then the four</span></span><br><span class="line"><span class="comment">     * characters &#123;<span class="doctag">@code</span> "null"&#125; are appended.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Let &lt;i&gt;n&lt;/i&gt; be the length of this character sequence just prior to</span></span><br><span class="line"><span class="comment">     * execution of the &#123;<span class="doctag">@code</span> append&#125; method. Then the character at</span></span><br><span class="line"><span class="comment">     * index &lt;i&gt;k&lt;/i&gt; in the new character sequence is equal to the character</span></span><br><span class="line"><span class="comment">     * at index &lt;i&gt;k&lt;/i&gt; in the old character sequence, if &lt;i&gt;k&lt;/i&gt; is less</span></span><br><span class="line"><span class="comment">     * than &lt;i&gt;n&lt;/i&gt;; otherwise, it is equal to the character at index</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;k-n&lt;/i&gt; in the argument &#123;<span class="doctag">@code</span> str&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   str   a string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a reference to this object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    putStringAt(count, str);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위의 코드는 AbstractStringBuilder의 append 메서드이다.</li><li>새로운 String의 길이 만큼 AbstractStringBuilder의 내의 byte[]의 사이즈를 늘리고 복사한다.</li><li>그 다음 String에 대한 byte[]를 AbstractStringBuilder의 내의 byte[]에 추가한다.</li><li>String + String 연산과의 차이점은 불필요한 String 객체가 발생하지 않는다는 점이다</li></ul><h1 id="string-concatination의-발전">String Concatination의 발전</h1><ul><li>Java String 연산에 대한 성능최적화를 다방면으로 생각하고 있고, Java 9 부터 String의 내부 배열을<br><strong>char[] -&gt; byte[]로 변경</strong>하여 성능을 더 향상 시켰다.</li><li>Java 1.5 버전부터 String + String연산에 대해 <strong>Compile Time에 StringBuilder를 사용하도록 코드를 변경한다.</strong><br>하지만 JDK가 항상 자동으로 바꿔준다는 보장이 없으니 String + String 보다는 StringBuilder를 사용해야 한다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 63. 문자열 연결은 느리니 주의하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/01/effective-java-item63/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 62. 다른 타입이 적절하다면 문자열 사용을 피하라</title>
      <link>https://jaehun2841.github.io/2019/03/01/effective-java-item62/</link>
      <guid>https://jaehun2841.github.io/2019/03/01/effective-java-item62/</guid>
      <pubDate>Fri, 01 Mar 2019 10:53:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;문자열(String)은 텍스트를 표현하도록 설계되었고, 그 일을 아주 멋지게 해낸다.&lt;br&gt;
그런데 문자열은 워낙 흔하고 자바가 또 잘 지원해주어 원래 의도하지 않는 용도로도 쓰이는 경향이 있다.&lt;/p&gt;
&lt;h1
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>문자열(String)은 텍스트를 표현하도록 설계되었고, 그 일을 아주 멋지게 해낸다.<br>그런데 문자열은 워낙 흔하고 자바가 또 잘 지원해주어 원래 의도하지 않는 용도로도 쓰이는 경향이 있다.</p><h1 id="문자열의-안티패턴">문자열의 안티패턴</h1><h2 id="문자열은-다른-값-타입을-대신하기에-적합하지-않다">문자열은 다른 값 타입을 대신하기에 적합하지 않다.</h2><p>많은 사람들이 파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때 주로 문자열을 이용한다.<br>하지만 <strong>입력받을 데이터가 진짜 문자열인 경우에만 문자열을 사용하는 것이 좋다.</strong><br>데이터가 수치형이면 int, long, double등 수치에 대한 타입으로 사용하는 것이 좋다.<br>질문의 답이 예/아니오라면 boolean을 사용하는것이 좋다.</p><p>일반화 하여 얘기하자면,<br><strong>기본 타입이든 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고 없다면 새로 하나 타입을 만드는 것이 좋다.</strong></p><h2 id="문자열은-열거-타입-대신하기에-적합하지-않다">문자열은 열거 타입 대신하기에 적합하지 않다.</h2><p>상수를 열거할 경우에는 문자열 열거 패턴 클래스 보다는 열거 타입(enum)이 훨씬 낫다.</p><h2 id="문자열은-혼합-타입을-대신하기에-적합하지-않다">문자열은 혼합 타입을 대신하기에 적합하지 않다.</h2><p>여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String compoundKey = className + <span class="string">"#"</span> + i.next();</span><br></pre></td></tr></table></figure></p><p>이 방식은 단점이 많다.<br>예를 들어 문자열에 # 문자열이 있는 경우 혼란스러운 결과가 발생한다.<br>각 요소를 개별적으로 접근하기 위해서는 특정 기준을 통해 문자열을 파싱해야해서 느리고, 귀찮고, 오류 가능성도 크다.</p><p>이럴바에는 <strong>차라리 전용 클래스를 새로 만들어서 각 데이터 별로 멤버 변수를 취하는 것이 좋다.</strong></p><h2 id="문자열은-권한을-표현하기에-적합하지-않다">문자열은 권한을 표현하기에 적합하지 않다.</h2><p>권한(capacity)를 문자열로 표현하는 경우가 종종 있다.</p><h3 id="잘못된-예-문자열을-사용하여-권한을-구분하였다">잘못된 예 - 문자열을 사용하여 권한을 구분하였다.</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//객체 생성 불가</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 현 스레드의 값을 키로 구분해 저장한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (키가 가르키는) 현 스레드의 값을 반환한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 방식의 문제점은 스레드 구분용 문자열 키가 global namespace에서 공유된다는 점이다.<br>이 방식이 의도대로 동작하려면 각 클라이언트가 고유한 키를 제공해야 한다.<br>만약 두 클라이언트가 서로 소통하지 못해 같은 키를 쓰기로 결정한다면, 의도치 않게 같은 변수를 공유하게 된다.<br>따라서 클라이언트는 제대로 작동하지도 않고 보안에도 취약하다.</p><p>이런 경우에는 String으로 권한을 구분하는 것이 아니라 별도의 타입을 만들어 해결해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//객체 생성 불가</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">        key() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//위조 불가능한 고유 키를 생성한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Key();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Key key, Object value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">(Key key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 방법은 앞서의 문자열 기반 API의 문제점을 해결해 주지만 개선할 부분이 있다.<br>set/get 메서드는 이제 static 메서드일 이유가 없다. 따라서 Key의 인스턴스 메서드로 변경하는 것이 좋다.<br>그렇게 하면 Key는 더 이상 스레드 지역변수를 구분하기 위한 키가 아니라 그 자체가 스레드 지역변수가 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 API는 get으로 얻은 Object를 실제 타입으로 타입 캐스팅 해야 해서 타입안전하지 않다.<br>하지만 제네릭을 사용한다면 조금 더 타입 안전하게 만들 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="정리">정리</h1><ul><li>더 적합한 데이터 티입이 있거나 새로 작성할 수 있다면, 문자열을 쓰지 말자</li><li>문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고 오류 가능성도 크다.</li><li>문자열을 잘못 사용하는 흔한 예로는 기본 타입, 열거 타입, 혼합 타입이 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 62. 다른 타입이 적절하다면 문자열 사용을 피하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/01/effective-java-item62/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/01/effective-jave-item61/</link>
      <guid>https://jaehun2841.github.io/2019/03/01/effective-jave-item61/</guid>
      <pubDate>Fri, 01 Mar 2019 09:27:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바의 데이터 타입은 크게 두 가지로 나눌 수 있다.&lt;br&gt;
&lt;strong&gt;기본 타입 (Primitive type) vs 참조 타입 (Reference Type)&lt;/strong&gt; 으로 구분 할 수 있다.&lt;/p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바의 데이터 타입은 크게 두 가지로 나눌 수 있다.<br><strong>기본 타입 (Primitive type) vs 참조 타입 (Reference Type)</strong> 으로 구분 할 수 있다.</p><h2 id="기본-타입-primitive-type">기본 타입 (Primitive Type)</h2><ul><li>int</li><li>long</li><li>short</li><li>double</li><li>char</li><li>boolean</li></ul><h2 id="참조-타입-reference-type">참조 타입 (Reference Type)</h2><ul><li>String</li><li>Integer</li><li>Long</li><li>Double</li><li>Boolean</li></ul><p>기본 타입에 대응되는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다.</p><h1 id="auto-boxing-vs-auto-unboxing">Auto Boxing vs Auto UnBoxing</h1><p>Java 1.5 부터 기본 타입과 래퍼 타입(Wrapper Type, 참조 타입에 대한 클래스를 래퍼 클래스라고 함)을 자동으로 변환해 주는 기능이 추가되었다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> j = i; <span class="comment">// Auto UnBoxing</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">10</span>;</span><br><span class="line">Integer l = k; <span class="comment">//Auto Boxing</span></span><br></pre></td></tr></table></figure></p><p>이 기능 때문에 개발자는 별도로 Boxing과 UnBoxing을 수행해 주지 않아도 되지만, 그렇다고 두 개가 같은 것은 아니다.<br>기본 타입과 래퍼 타입에는 차이가 있으니 어떤 타입을 사용하는지는 상당히 중요하다.</p><h1 id="기본타입-vs-참조타입">기본타입 vs 참조타입</h1><p>기본 타입과 참조 타입의 차이점은 크게 3가지이다.</p><ul><li><p>기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)란 속성을 갖는다.</p><ul><li><p>기본 타입은 흔히 말하는 리터럴(Literal)이다.</p><blockquote><p>리터럴(Literal)이란?</p><p>소스 코드의 고정된 값을 의미하는 용어이다.상수(Constants) 또는 변수(Variable)에 할당 할 수 있는 값 자체를 일컫는 용어이다.</p></blockquote></li><li><p>기본 타입의 값은 JVM내의 Stack 메모리에 저장된다.</p></li><li><p>참조 타입의 값은 객체 내의 상수에 저장된다. 따라서 JVM 내의 Heap 메모리에 저장된다.</p></li><li><p>따라서 박싱된 타입의 객체는 같은 값이라 하더라도 다른 객체일 경우에는 다르다고 식별이 가능하다.</p></li></ul></li><li><p>기본 타입의 값은 언제나 유효한 값을 가지고 있으나 박싱된 기본타입은 유효하지 않을 수 있다.</p><ul><li>기본타입의 값은 Java의 경우 초기화 되지 않으면 0으로 초기화 된다.</li><li>박싱된 기본 타입의 경우에는 초기화 되지 않으면 null이 될 수 있다.</li></ul></li><li><p>기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.</p><ul><li>박싱된 타입은 heap에 객체를 생성하기 때문에 메모리 사용면에서 더 안좋다.</li><li>기본타입은 변수에 값이 있는 반면, 박싱된 기본 타입은 변수의 객체참조 정보를 바탕으로 heap에서 찾으므로<br>시간적인 측면에서 기본타입보다 값에 접근하는 시간이 더 들게 된다.</li></ul></li></ul><h1 id="잘못-구현된-비교자-예제">잘못 구현된 비교자 예제</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; naturalOrder = (i, j) -&gt; (i &lt; j) ? -<span class="number">1</span> : (i == j ? <span class="number">0</span> : <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><ul><li>위의 코드를 기반으로 Integer비교가 실행되면 같은 값을 비교한다고 해도 1이 나올 수 있다.</li><li>첫번째 i &lt; j 에 대한 연산 시, Integer타입인 i와 j는 기본타입 int로 언박싱된다.</li><li>첫번째 연산이 false이면 두번째 연산 i == j에서도 false가 발생하게 된다.</li><li>이유는, (i, j)의 타입이 Integer로 추론되기 때문에 i == j 연산이 이루어질 때 객체의 동일성검사가 이루어져 false가 발생하기 때문이다. (i와 j는 내부 값은 같지만 서로 다른 객체이기 때문이다.)</li></ul><p><strong>이처럼 같은 객체가 아니라면 박싱된 기본타입에 == 연산자를 이용하여 비교하면 예상과는 다른 결과가 나올 수 있다.</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; naturalOrder = (i, j) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> unBoxi = i;</span><br><span class="line">    <span class="keyword">int</span> unBoxj = j;</span><br><span class="line">    <span class="keyword">return</span> (unBoxi &lt; unBoxj) ? -<span class="number">1</span> : (unBoxi == unBoxj ? <span class="number">0</span> : <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 수정하면 정상적인 결과를 얻을 수 있다.</p><h1 id="갑자기-발생하는-nullpointerexception">갑자기 발생하는 NullPointerException</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unbelievable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Integer i;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">42</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"믿을 수 없군"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 프로그램은 &quot;믿을 수 없군&quot;을 출력하지는 않지만, 전혀 예상하지 못한 결과를 보여준다.<br>i == 42를 검사하는 과정에서 NullPointerException을 던진다.<br>원인은 i가 literal 값인 42와 비교하는 과정에서 i는 Auto UnBoxing을 수행한다.<br>하지만  i는 null이기 때문에 Auto UnBoxing을 수행하는 과정에서 NullPointerException을 발생시키게 된다.</p><p><strong>기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.</strong><br>하지만 박싱된 기본타입이 null인 경우에는 NullPointerException이 발생하니 주의 해야 한다.</p><h1 id="의도하지-않은-auto-boxing으로-인한-성능저하">의도하지 않은 Auto Boxing으로 인한 성능저하</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0L</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">        sum += i; <span class="comment">//sum이 UnBoxing되어 i와 연산되고 연산 후에 AutoBoxing되어 Long타입으로 변환된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 코드는 sum을 Long으로 선언하였기 때문에 엄청난 성능상 안좋은 코드이다.<br>sum += i;를 수행하는 과정에서 <strong>sum이 long타입으로 UnBoxing되고</strong> sum + i 연산이 이루어진다음 <strong>Long타입으로 AutoBoxing되기 때문이다.</strong></p><h1 id="박싱된-기본타입은-언제-사용해야-하는가">박싱된 기본타입은 언제 사용해야 하는가?</h1><ul><li>컬렉션의 원소, 키, 값으로 쓴다.<ul><li>컬렉션은 기본타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본타입을 사용해야 한다.</li></ul></li><li>제네릭(Generics) 타입을 이용하는 경우에도 박싱된 기본타입을 사용한다.<ul><li>제네릭 타입에서는 int, double과 같은 기본타입을 지원하지 않기 때문이다.</li></ul></li><li>리플렉션(Reflection)을 통해 메서드를 호출할 때에도 박싱된 기본타입을 사용한다.</li></ul><h1 id="정리">정리</h1><ul><li>기본 타입과 박싱된 기본 타입을 사용해야 한다면,  가능하면 기본 타입을 사용하는 것이 좋다.</li><li>기본타입은 간단하고 빠르다.</li><li>박싱된 기본 타입을 사용한다면 주의를 기울이자</li><li>AutoBoxing이 기본타입을 변경할 때 번거로움을 줄여주지만 그 위험까지 없애주지는 않는다.<ul><li>박싱된 기본 타입을 == 연산자로 비교한다면 객체의 동일성 비교가 이뤄지는데<br>개발자가 의도한 결과가 나오지 않을 가능성이 크다.</li><li>== 연산에서 기본 타입과 박싱된 기본 타입의 연산이 이루어지면, 박싱된 기본 타입이 UnBoxing되는데<br>박싱된 기본 타입이 null인 경우 NullPointerException이 발생한다.</li></ul></li><li>기본 타입을 Boxing하는 것은 필요없는 객체를 생성하는 부작용이 나올 수 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/01/effective-jave-item61/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 60. 정확한 답이 필요하다면 Float와 Double은 피하라</title>
      <link>https://jaehun2841.github.io/2019/02/28/effective-java-item60/</link>
      <guid>https://jaehun2841.github.io/2019/02/28/effective-java-item60/</guid>
      <pubDate>Thu, 28 Feb 2019 10:34:22 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;float와 double 타입은 과학과 공학 계산용으로 설계되었다.&lt;br&gt;
이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 &lt;strong&gt;근사치&lt;/strong&gt; 로 계산하도록 세심하게 설계되었다
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>float와 double 타입은 과학과 공학 계산용으로 설계되었다.<br>이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 <strong>근사치</strong> 로 계산하도록 세심하게 설계되었다.<br>따라서 정확한 결과가 필요할 때에는 사용해선 안된다<br><strong>float와 double 타입은 특히 금융 관련 계산과는 맞지 않는다.</strong><br>0.1 혹은 10의 거듭 제곱 수를 표현할 수 없기 때문이다.</p><h1 id="예시-금융-계산에-부동소수-타입을-사용">예시 - 금융 계산에 부동소수 타입을 사용</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> funds = <span class="number">1.00</span>;</span><br><span class="line">    <span class="keyword">int</span> itemBought = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> price = <span class="number">0.10</span>; funds &gt;= price; price += <span class="number">0.10</span>) &#123;</span><br><span class="line">        funds -= price;</span><br><span class="line">        itemsBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">"개 구입"</span>);</span><br><span class="line">    System.out.println(<span class="string">"잔돈(달러): "</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>프로그램의 실행결과는 사탕 3개를 구입한 후 잔돈은 0.39999999999999달러가 남는다고 나온다.</li><li>잘못된 결과이며, 올바른 결과를 위해서는 <strong>BigDecimal, int, long</strong> 을 사용해야 한다.</li></ul><h2 id="bigdecimal을-사용한-코드-속도가-느리고-쓰기-불편하다">BigDecimal을 사용한 코드 - 속도가 느리고 쓰기 불편하다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BigDecimal TEN_CENTS = <span class="keyword">new</span> BigDecimal(<span class="string">".10"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> itemBought = <span class="number">0</span>;</span><br><span class="line">    BigDecimal funds = <span class="keyword">new</span> BigDecimal(<span class="string">"1.00"</span>);</span><br><span class="line">    <span class="keyword">for</span>(BigDecimal price = TEN_CENT; funds.compareTo(price) &gt;= <span class="number">0</span>; price = price.add(TEN_CENTS)) &#123;</span><br><span class="line">        funds = funds.subtract(price);</span><br><span class="line">        itemsBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">"개 구입"</span>);</span><br><span class="line">    System.out.println(<span class="string">"잔돈(달러): "</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 프로그램의 실행결과는 사탕 4개 구입 후 잔돈이 0달러가 남는다. 올바른 답이다.</li><li>BigDecimal에는 2가지 단점이 있다.<ul><li>기본 타입보다 쓰기가 훨씬 불편하고, 느리다. 단발성 계산이라면 문제는 아니지만 쓰기 불편하다</li><li>BigDecimal의 대안으로 int, long을 사용해도 된다. 하지만 소수점을 직접 관리해야 한다.</li></ul></li></ul><h2 id="int를-사용한-코드-cent로-문제를-해결">int를 사용한 코드 - Cent로 문제를 해결</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> itemBought = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> funds = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> price = <span class="number">10</span>; funds &gt;= price; price += <span class="number">10</span>) &#123;</span><br><span class="line">        funds -= price;</span><br><span class="line">        itemBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">"개 구입"</span>);</span><br><span class="line">    System.out.println(<span class="string">"잔돈(달러): "</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>int로 사용하면 BigDecimal 보다는 깔끔하고 정확한 답을 얻을 수 있다.</li></ul><h1 id="정리">정리</h1><ul><li>정확한 답이 필요한 계산에는 float나 double을 피해야한다.</li><li>소수점 추적은 시스템에 맡기고 코딩시의 불편함이나 성능저하가 중요하지 않다면 BigDecimal을 사용하라</li><li>BigDecimal은 8가지 반올림 모드를 제공하므로 반올림을 거의 완벽하게 제어할 수 있다.</li><li>성능이 중요하고 소수점을 직접 추적할 수 있고 숫자가 너무 크지 않다면 int나 long을 사용하라</li><li>숫자를 9자리 10진수로 표현한다면 int를 사용하라</li><li>숫자를 18자리 10진수로 표현할 수 있다면 long을 사용하라</li><li>숫자가 18자리가 넘어가면 BigDecimal을 사용해야 한다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 60. 정확한 답이 필요하다면 float와 double은 피하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/28/effective-java-item60/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 59. 라이브러리를 익히고 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/28/effective-java-item59/</link>
      <guid>https://jaehun2841.github.io/2019/02/28/effective-java-item59/</guid>
      <pubDate>Thu, 28 Feb 2019 10:18:25 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;무작위-정수-만들기&quot;&gt;무작위 정수 만들기&lt;/h1&gt;
&lt;p&gt;무작위 정수를 하나 생성한다고 해보자&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="무작위-정수-만들기">무작위 정수 만들기</h1><p>무작위 정수를 하나 생성한다고 해보자</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">random</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(rnd.nextInt()) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>괜찮아 보이지만 3가지의 문제를 내포하고 있다.</p><ul><li><p>n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다.</p></li><li><p>n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 자주 반환된다.</p></li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span> * (Integer.MAX_VALUE / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(random(n) &lt; n/<span class="number">2</span>) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(low);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>random 메서드가 이상적으로 동작한다면 약 50만개가 출력되어야 하지만, 실제로는 666,666에 가까운 값을 얻는다.<br>무작위로 생성된 수 중에서 2/3 가량이 중간값보다 낮은 쪽으로 쏠린 것이다.</p><ul><li>지정한 범위 바깥의 수가 종종 튀어나올 수 있다. rnd.nextInt()가 반환한 값을 Math.abs를 이용해 음수가 아닌 정수로 매핑하기 때문이다.</li></ul><h1 id="표준-라이브러리를-사용하면-다른-프로그래머들의-경험을-활용할-수-있다">표준 라이브러리를 사용하면 다른 프로그래머들의 경험을 활용할 수 있다.</h1><ul><li>메서드의 동작 방식은 몰라도 알고리즘에 능통한 개발자나, 여러 분야의 전문가가 설계와 구현에 시간을 들여 개발한 것이다.</li><li>버그가 발생되더라도 다음 릴리스에 수정 보완 개선이 될 수 있다.</li><li>표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.</li><li>핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 되고 어플리케이션 기능 개발에 집중할 수 있다.</li><li>따로 노력하지 않아도 릴리즈가 나올 때 마다 성능이 지속해서 개선된다.</li><li>기능이 점점 많아진다. 개발자 커뮤니티에서 나온 이야기를 바탕으로 논의 후 다음 릴리즈에 기능이 추가되곤 한다.</li><li>라이브러리를 사용하면 많은 사람들에게 낯익은 코드가 된다. 다른 개발자들이 유지보수 하기 쉬워지고 재사용성이 높아진다.</li></ul><h1 id="메이저-버전-릴리즈-마다-수많은-기능이-추가된다">메이저 버전 릴리즈 마다 수많은 기능이 추가된다.</h1><ul><li>자바는 메이저 릴리즈마다 새로운 기능을 설명하는 웹페이지를 공시한다.</li><li>한 번쯤은 읽어볼만 하다</li><li>너무 많아서 읽기 힘든 경우에는 java.lang, java.util, java.io와 하위 패키지들에는 익숙해져야 한다.</li><li>컬렉션 프레임워크나 concurrent 패키지는 알아두면 도움이 도니다.</li></ul><h2 id="예시-transferto-메서드를-이용해-url-내용-가져오기">예시 - transferTo 메서드를 이용해 URL 내용 가져오기</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;InputStream in = <span class="keyword">new</span> URL(args[<span class="number">0</span>]).openStream()) &#123;</span><br><span class="line">        in.transferTo(System.out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>java 9 버전 부터 URL정보를 쉽게 출력해 주는 transferTo 메서드를 제공한다.</li></ul><h1 id="정리">정리</h1><ul><li>라이브러리가 전문적인 기능을 제공해 주지 못할수도 있지만, 라이브러리를 일단 사용해보자</li><li>특별한 기능이 아니라면 누군가 라이브러리로 만들어 두었을 가능성이 높다.<br>일단 라이브러리가 있는지 찾아보자</li><li>일반적으로 라이브러리의 코드는 개발자가 작성한 것보다 품질이 좋고 개선의 여지가 있다.</li><li>라이브러리 코드는 주목을 많이 받고 개발자 커뮤니티에서 문제점이 많이 거론되므로 코드 품질이 점차 좋아진다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 59. 라이브러리를 익히고 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/28/effective-java-item59/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
