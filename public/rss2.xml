<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Carrey`s 기술블로그</title>
    <link>https://jaehun2841.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 17 Feb 2019 13:36:01 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Item 48. 스트림 병렬화는 주의해서 적용하라</title>
      <link>https://jaehun2841.github.io/2019/02/17/effective-java-item48/</link>
      <guid>https://jaehun2841.github.io/2019/02/17/effective-java-item48/</guid>
      <pubDate>Sun, 17 Feb 2019 07:34:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;주류 언어 중, 동시성 프로그래밍 측면에서는 항상 자바는 앞서왔다.&lt;br&gt;
처음 릴리즈된 1996년부터 스레드, 동기화, wait/notify를 지원했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바 5부터는 동시성 컬렉션인 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>주류 언어 중, 동시성 프로그래밍 측면에서는 항상 자바는 앞서왔다.<br>처음 릴리즈된 1996년부터 스레드, 동기화, wait/notify를 지원했다.</p><ul><li>자바 5부터는 동시성 컬렉션인 java.util.concurrent 라이브러리와 실행자(Excutor) 프레임워크를 지원했다.</li><li>자바 7부터는 고성능 병렬 분해(parallel decom-position) 프레임워크인 fork-join 패키지를 추가했다.<br>(Fork-join pool에 대한 설명은 https://okky.kr/article/345720 여기 참고)</li><li>자바 8부터는 parallel 메서드만 한 번 호출하면 파이프라인을 병렬 실행할 수 있는 Stream을 지원했다.</li></ul><p>자바로 동시성 프로그램을 작성하기가 점점 쉬워지고 있지만, 이를 올바르고 빠르게 작성하는 일은 어렵다.<br>동시성 프로그래밍을 할 때는 안전성(safety)과 응답 가능(liveness) 상태를 유지하기 애써야 한다.<br>병렬 스트림 파이프라인 프로그래밍에서도 다를 바 없다.</p><h1 id="파이프라인-병렬화가-불가능-한-경우-성능-개선이-되지-않는다">파이프라인 병렬화가 불가능 한 경우 성능 개선이 되지 않는다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MersenPrimeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        primes().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))</span><br><span class="line">                .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                .limit(<span class="number">20</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"running time : "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        primes().parallel().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))</span><br><span class="line">                .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                .limit(<span class="number">20</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"running time : "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;BigInteger&gt; <span class="title">primes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(TWO, BigInteger::nextProbablePrime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>스트림을 이용한 처음 20개의 메르센 소수를 생성하는 프로그램이다.<br>이 프로그램을 실행 시켜보니 test1은 8.2초 정도의 수행시간을 보여줬다test2는 stream의 성능을 향상시켜보고자 parallel()을 호출했다.<br>하지만 메르센 소수의 값이 프린트 되지 않았고, 강제로 중지 하기 전까지 계속 돌고 있었다.<br>아무것도 안된 원인은 stream 라이브러리가 이 파이프라인을 병렬화 하는 방법을 찾아내지 못했기 때문이다.</p><ul><li>데이터 소스가 Stream.iterate인 경우</li><li>중간 연산으로 limit()를 사용하는 경우위 두 가지 경우에는 파이프라인 병렬화로 성능 향상을 기대하기 어렵다.<br>뿐만 아니라 파이프라인 병렬화는 limit를 다룰 때 <strong>CPU 코어가 남는다면, 원소를 몇 개 더 처리한 후 제한된 개수 이후의 결과를 버려도 아무런 해가 없다고 가정한다.</strong></li></ul><p>따라서 스트림 파이프라인을 마구잡이로 병렬화 해선 안된다. 성능이 오히려 더 나빠질 수 있다.</p><h1 id="언제-병렬화를-사용하나">언제 병렬화를 사용하나?</h1><ul><li><p>ArrayList</p></li><li><p>HashMap</p></li><li><p>HashSet</p></li><li><p>ConcurrentHashMap</p></li><li><p>배열(Array)</p></li><li><p>int/long 범위</p></li></ul><p>스트림의 데이터 소스가 위와 같은 클래스의 인스턴스 일 때 병렬화의 효과가 가장 좋다.<br>위 자료구조들은 모두 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어 다수의 스레드에 분배하기에 좋다.<br>나누는 작업은 <strong>Spliterator</strong>가 담당하며, Spliterator 객체는 Stream, Iterable의 spliterator() 메서드로 얻어올 수 있다.</p><p>또한 위의 자료구조는 <strong>참조 지역성(locality of reference)</strong> 이 높아 성능이 좋다.</p><h1 id="참조-지역성-locality-of-reference">참조 지역성 (Locality of Reference)</h1><p><img src="./locality.PNG" alt="locality"></p><p>만일 캐시(Cache)가 어떤 별도의 알고리즘 없이 중간 매개체로만 사용된다면,<br>CPU가 Cache에서 데이터를 읽고 쓰는 속도나 메인 메모리에서 읽고 쓰는 속도나 마찬가지가 될 것이다.</p><p>캐시 메모리가 제 역할을 하는 것은 데이터의 지역성(locality)를 이용하기 때문.<br>데이터의 지역성은 다음의 세가지로 분류</p><ul><li>공간적 지역성 (partial locality)<ul><li>메인메모리에서 CPU가 요청한 주소지점의 데이터에 인접한 주소들이 앞으로 참조될 확률이 높음을 의미</li><li>이웃한 원소들의 참조가 메모리에 연속적으로 저장되어 있어 다음 참조에 대한 접근 속도가 빠르게 함</li></ul></li><li>시간적 지역성 (temporal locality)<ul><li>한번 참조되었던 데이터는 후에 다시 참조될 가능성이 높음을 의미</li></ul></li><li>순차적 지역성 (sequential locality)<ul><li>따로 분기가 없는 한 데이터가 기억장치에 저장된 순서대로 인출되고 실행될 가능성이 높음을 의미 (FIFO)</li></ul></li></ul><h1 id="스트림-파이프라인의-종단-연산">스트림 파이프라인의 종단 연산</h1><p>스트림 파이프라인의 종단연산의 동작방식 역시 병렬 수행 효율에 영향을 준다.<br>종단 연산 중 병렬화에 가장 적합한 것은 축소(reduction)이다.<br>축소는 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업이다.<br>예를 들면 min, max, sum, count 같이 완성된 형태로 제공되는 메서드가 있다.<br>anyMatch, allMatch, noneMatch처럼 조건에 맞음년 바로 반환되는 메서드도 병렬화에 적합하다.</p><p>반면, 가변 축소(Mutable Reduction)을 수행하는 Stream의 collect 메서드는 병렬화에 적합하지 않다.컬렉션들을 합치는 부담이 크기 때문이다.</p><h1 id="병렬화에-대해-잘모르면-안하는게-낫다">병렬화에 대해 잘모르면 안하는게 낫다</h1><p>스트림을 잘못 병렬화하면 (응답 불가를 포함해) 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.<br>(결과가 잘못되거나 오동작하는 것은 <strong>안전 실패(safety failure)</strong> 이라 한다.)<br>안전 실패는 병렬화한 파이프라인이 사용하는 mappers, filters 혹은 프로그래머가 제공한 다른 함수 객체가 명시한대로 동작하지 않을 때 발생할 수 있다.</p><p>Stream 명세는 이때 사용되는 함수 객체에 관한 엄중한 규약을 정의해놨다.</p><h2 id="stream-명세는-함수-객체에-대한-규약">Stream 명세는 함수 객체에 대한 규약</h2><ol><li>Stream의 reduce 연산에 건네지는 accumulator(누적기)와 combiner(결합기) 함수는 반드시 <strong>결합법칙</strong>을 만족해야 한다.<br>(결합 법칙 : (a op b) op c = a op (b op c))</li><li>간섭받지 않아야 한다 (non-interfering) - 파이프라인이 수행되는 동안 <strong>데이터소스가 변경되지 않아야한다.</strong></li><li>상태를 갖지 않아야 한다 (stateless)위의 요구사항을 지키지 못하더라도 순차적으로 실행하면 올바른 결과를 얻을 수 있다.<br>하지만 병렬로 수행하면 기대한 결과가 나오지 않을 수 있고, 실패할 수 있으니 주의해야 한다.</li></ol><h1 id="스트림-병렬화는-오직-성능-최적화-수단임을-기억하라">스트림 병렬화는 오직 성능 최적화 수단임을 기억하라</h1><p>다른 최적화와 마찬가지로 변경 전후로 반드시 성능테스트를 진행하여 병렬화를 사용할 가치가 있는지 확인해야 한다.<br>이상적으로는 운영 시스템과 같은 환경에서 테스트하는 것이 좋다.<br>보통은 병렬 스트림 파이프라인도 공통의 포크-조인 풀에서 수행되므로 (같은 스레드 풀을 사용)<br>잘못된 파이프라인 하나가 다른 부분의 성능에까지 악영향을 줄 수 있음을 유념하자<br>조건이 잘 갖춰지면 parallel 메서드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 볼 수 있다.</p><h1 id="스트림-파이프라인-병렬화가-효과적인-예">스트림 파이프라인 병렬화가 효과적인 예</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pi</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">2</span>, n)</span><br><span class="line">                     .mapToObj(BigInteger::valueOf)</span><br><span class="line">                     .filter(i -&gt; i.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                     .count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pi</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">2</span>, n)</span><br><span class="line">                     .parallel()</span><br><span class="line">                     .mapToObj(BigInteger::valueOf)</span><br><span class="line">                     .filter(i -&gt; i.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                     .count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>𝛑(n) : n 보다 작거나 같은 소수의 개수를 계산하는 함수</li><li>책에서는 위의 함수를 실행하는데 31초, 아래 parallel()이 추가된 함수를 실행하는데 9.2초가 걸렸다고 한다.</li></ul><h1 id="random한-수의-경우">Random한 수의 경우</h1><p>무작위 수들로 이뤄진 스트림을 병렬화하려거든 ThreadLocalRandom(혹은 Random) 보다는<br>SplittableRandom 인스턴스를 이용하자. SplittableRandom은 정확히 이럴 때 쓰고자 설계된 것이라<br>병렬화 하면 성능이 선형으로 증가한다. 한편 ThreadLocalRandom은 단일 스레드에서 사용하고자 만들어 졌다.<br>병렬로 사용하는 경우에는 SplittableRandom &gt; SplittableRandom 성능을 보인다.</p><p>그냥 Random의 경우에는 모든 연산을 동기화하기 때문에 병렬 처리하면 최악의 성능을 보일 것이다.</p><h1 id="요약">요약</h1><ul><li>계산도 올바로 수행하고 성능도 빨라질거라는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말자</li><li>스트림 병렬화를 잘못하면 프로그램이 오동작하거나 성능이 급격히 떨어질 수 있다.</li><li>병렬화를 할 경우에는 성능테스트를 반드시 진행하고, 결과가 정확한지 확인해야 한다.</li><li>계산도 정확하고 성능도 좋아졌음이 확실할 때, 그럴 때만 병렬화 버전을 운영 코드에 반영하라</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 48. 스트림 병렬화는 주의해서 적용하라</li><li><a href="https://okky.kr/article/345720" target="_blank" rel="noopener">Thread pool과 ForkJoinPool</a></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/17/effective-java-item48/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 47. 반환 타입으로는 스트림보다 컬렉션이 낫다</title>
      <link>https://jaehun2841.github.io/2019/02/16/effective-java-item47/</link>
      <guid>https://jaehun2841.github.io/2019/02/16/effective-java-item47/</guid>
      <pubDate>Sat, 16 Feb 2019 12:20:25 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Array형태의 Linear한 자료구조를 반환하는 메서드는 수없이 많다.&lt;br&gt;
이런 메서드의 반환타입으로 아래와 같은 타입을 사용했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Collection&amp;lt;E&amp;gt;, Set&amp;lt
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Array형태의 Linear한 자료구조를 반환하는 메서드는 수없이 많다.<br>이런 메서드의 반환타입으로 아래와 같은 타입을 사용했다.</p><ul><li>Collection&lt;E&gt;, Set&lt;E&gt;, List&lt;E&gt;와 같은 컬렉션 인터페이스</li><li>E[]와 같은 배열</li><li>Iterable&lt;E&gt; 인터페이스</li></ul><p>기본은 Collection&lt;E&gt; 타입이다.<br>for-each 문에서만 쓰이거나, (contain(Object) 같은) 일부 Collection 메서드를 구현 할 수 없을 때는 Iterable 인터페이스를 사용한다.<br>성능에 민감한 상황이면, E[] 형태의 배열을 주로 사용해 왔다.</p><p>자바 8이 스트림이라는 개념을 들고오면서 선택이 더욱 복잡해지게 되었다.</p><h1 id="stream은-반복loop을-지원하지-않는다">Stream은 반복(loop)을 지원하지 않는다.</h1><p>Stream은 반복을 지원하지 않는다.<br>다라서 Stream과 반복을 알맞게 조합해야 좋은 코드가 나온다.<br>API를 Stream만 사용하도록 하면 for-each를 사용하고자 하는 개발자는 불편을 겪을 것이다.<br>(Stream은 Iterator 인터페이스가 정의한 추상메서드를 포함하고 있다. 하지만, Iterator를 확장하진 않아 for-each로 반복하지 못한다.)</p><h2 id="api에서-stream만-반환하는-경우">API에서 Stream만 반환하는 경우</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a snapshot of all processes visible to the current process.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* &lt;em&gt;Note that processes are created and terminate asynchronously. There</span></span><br><span class="line"><span class="comment">* is no guarantee that a process in the stream is alive or that no other</span></span><br><span class="line"><span class="comment">* processes may have been created since the inception of the snapshot.</span></span><br><span class="line"><span class="comment">* &lt;/em&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> a Stream of ProcessHandles for all processes</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> SecurityException if a security manager has been installed and</span></span><br><span class="line"><span class="comment">*         it denies RuntimePermission("manageProcess")</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> UnsupportedOperationException if the implementation</span></span><br><span class="line"><span class="comment">*         does not support this operation</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Stream&lt;ProcessHandle&gt; <span class="title">allProcesses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ProcessHandleImpl.children(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드는 자바 타입추론의 한계로 컴파일되지 않는다.</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test.java:6 error: method reference not expected here</span><br><span class="line">for (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) &#123;</span><br><span class="line">                        ^</span><br></pre></td></tr></table></figure></p><p>이 오류를 바로 잡으려면 메서드 참조를 매개변수화된 Iterable로 적절히 형변환 해줘야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(ProcessHandle ph : (Iterable&lt;ProcessHandle&gt;) ProcessHandle.allProcesses().iterator()) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>책에서는 이런식으로 억지로 형변환을 하면, 작동은 한다고 한다.<br>(하지만 실제로 코드를 실행해 본 결과 <code>ClassCastException</code>이 발생하였다.)</p><h3 id="streamltegt를-iterableltegt로-중개해주는-어댑터">Stream<code>&lt;</code>E<code>&gt;</code>를 Iterable<code>&lt;</code>E<code>&gt;</code>로 중개해주는 어댑터</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Iterable&lt;E&gt; <span class="title">iterableOf</span><span class="params">(Stream&lt;E&gt; stream)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> stream::iterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ProcessHandle ph : iterableOf(ProcessHandle.allProcesses()) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>iterableOf 메서드를 통해 명시적으로 Iterable으로 반환할 수 있다.</p><h2 id="api에서-iterator만-반환하는-경우">API에서 Iterator만 반환하는 경우</h2><p>API에서 Iterator만 반환하는 경우에도 Stream 코드가 편한 개발자들은 불편을 겪을 수 있다.자바는 Iterator -&gt; Stream을 위한 어댑터를 제공하지 않지만, 손쉽게 구현이 가능하다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Iterator&lt;E&gt;를 Stream&lt;E&gt;로 중개해주는 어댑터</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; Stream&lt;E&gt; <span class="title">streamOf</span><span class="params">(Iterable&lt;E&gt; iterable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(iterable.spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>객체 시퀀스를 반환하는 메서드를 작성할 때, 메서드가 오직 Stream 파이프라인에서만 쓰인다면 마음놓고 Stream을 반환하자.하지만 for-each를 사용하는 개발자와 Stream을 사용하는 개발자를 모두 배려하여 Stream과 Iterable을 동시에 제공할 수 있도록 하는 것이 좋다.<br>따라서 <strong>원소 시퀀스를 반환하는 공개 API의 반환 타입에는 Collection이나 그 하위타입을 쓰는 것이 일반적이다</strong></p><h1 id="컬렉션-내의-시퀀스가-크면-전용-컬렉션을-구현하라">컬렉션 내의 시퀀스가 크면 전용 컬렉션을 구현하라</h1><p>반환하는 시퀀스의 크기가 메모리에 올려도 안전할 만큼 작다면 ArrayList나 HashSet 같은 표준 컬렉션 구현체를 반환하는게 최선일 수 있다.<br>하지만 단지 컬렉션을 반환한다는 이유로 <strong>덩치 큰 시퀀스를 메모리에 올려서는 안된다.</strong></p><h2 id="예시-입력-집합의-멱집합을-전용-컬렉션에-담아-반환한다">예시 - 입력 집합의 멱집합을 전용 컬렉션에 담아 반환한다.</h2><p>멱집합이란, <strong>한 집합의 모든 부분집합을 원소로 하는 집합</strong>이다.<br>예를 들어 (a, b, c)의 멱집합은 ((), (a), (b), (c), (a, b), (a, c), (b, c), (a, b, c))이다.<br>원소의 갯수가 n개일 때, 원소의 갯수는 2^n개가 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;E&gt; Collection&lt;Set&lt;E&gt;&gt; of(Set&lt;E&gt; s) &#123;</span><br><span class="line">       List&lt;E&gt; src = <span class="keyword">new</span> ArrayList&lt;&gt;(s);</span><br><span class="line">       <span class="keyword">if</span>(src.size() &gt; <span class="number">30</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"집합에 원소가 너무 많습니다(최대 30개).: "</span> + s);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> AbstractList&lt;Set&lt;E&gt;&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; src.size();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> o <span class="keyword">instanceof</span> Set &amp;&amp; src.containsAll((Set) o);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Set&lt;E&gt; <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">               Set&lt;E&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; index != <span class="number">0</span>; i++, index &gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span>((index &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                       result.add(src.get(i));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>입력 집합의 원소 수가 30을 넘으면 Power.of가 예외를 던진다.<br>(size() 메서드의 리턴타입은 int이기 때문에 최대길이는 2^31 - 1 또는 Integer.MAX_VALUE로 제한 되기 때문)</li><li>이는 Stream이나, Iterable이 아닌 Collection을 쓸 때의 단점을 보여준다.<br>(Stream이나 Iterable은 size에 대한 고민이 필요없기 때문)</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Query Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of elements in this collection.  If this collection</span></span><br><span class="line"><span class="comment">     * contains more than &#123;<span class="doctag">@code</span> Integer.MAX_VALUE&#125; elements, returns</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Integer.MAX_VALUE&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of elements in this collection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li>Collection 인터페이스에서는 collection의 size가 int 범위를 넘어가는 경우 Integer.MAX_VALUE를 리턴하라고 하지만 만족스러운 해법은 아니다.</li></ul><h1 id="stream이-나을-때도-있다">Stream이 나을 때도 있다.</h1><p>위의 예제처럼 AbstractCollection을 활용해서 Collection 구현체를 리턴 할 때는 Iterator용 메서드 외에 2개만 더 구현하면 된다.<br>바로 <code>contains</code>과 <code>size</code>이다.</p><p>하지만 반복이 시작되기 전에는 (시퀀스의 내용을 확정할 수 없는 등의 사유로) contains와 size를 구현할 수 없는 경우에는 Collection이나 Iterable을 반환하는 편이 낫다.</p><h2 id="예시-입력-리스트의-모든-부분-리스트를-stream으로-반환">예시 - 입력 리스트의 모든 부분 리스트를 Stream으로 반환</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; of(List&lt;E&gt; list) &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.concat(Stream.of(Collections.emptyList()), </span><br><span class="line">                             prefixes(list).flatMap(SubList::suffixes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; prefixes(List&lt;E&gt; list) &#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">1</span>, list.size())</span><br><span class="line">                        .mapToObj(end -&gt; list.subList(<span class="number">0</span>, end));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; suffixes(List&lt;E&gt; list) &#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">0</span>, list.size())</span><br><span class="line">                        .mapToObj(start -&gt; list.subList(start, list.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>(a, b, c)의 prefixes는 (a), (a, b), (a, b, c) 이다</li><li>(a, b, c)의 suffixes는 (c), (b, c), (a, b, c) 이다</li><li>Stream.concat 메서드는 반환되는 Stream에 빈 리스트를 추가하며, flatMap은 모든 Stream을 하나의 Stream으로 만든다.</li></ul><h2 id="위의-내용과-같은-로직-for-loop를-이용한-코드">위의 내용과 같은 로직 - for loop를 이용한 코드</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; src.size(); start++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= src.size(); end++) &#123;</span><br><span class="line">        System.out.println(src.subList(start, end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="위의-로직과-같은-로직-stream-중첩">위의 로직과 같은 로직 - Stream 중첩</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; of(List&lt;E&gt; list) &#123;</span><br><span class="line">    <span class="keyword">return</span> IntStream.range(<span class="number">0</span>, list.size())</span><br><span class="line">        .mapToObj(start -&gt; </span><br><span class="line">                  IntStream.rangeClosed(start + <span class="number">1</span>, list.size())</span><br><span class="line">                           .mapToObj(end -&gt; list.subList(start, end)))</span><br><span class="line">        .flatMap(x -&gt; x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="요약">요약</h1><ul><li>Stream이나 Iterable을 리턴하는 API에는 Stream -&gt; Iterable, Iterable -&gt; Stream으로 변환하기 위한 어댑터 메서드가 필요하다.</li><li>어댑터는 클라이언트 코드를 어수선하게 만들고 더 느리다 (책에서는 2.3배정도 느리다함)</li><li>원소 시퀀스를 반환하는 메서드를 작성할 때는 Stream, Iterator를 모두 지원할 수 있게 작성하자<br>(되도록 Collection으로 하는게 좋다.)</li><li>원소의 갯수가 많다면, 멱집합의 예처럼 전용 컬렉션을 리턴하는 방법도 고민하자</li><li>만약 나중에 Stream 인터페이스가 Iterable을 지원하도록 수정된다면, 그때는 안심하고 Stream을 반환하면 된다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 47. 반환 타입으로는 스트림보다 컬렉션이 낫다</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/16/effective-java-item47/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 45. 스트림은 주의해서 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/16/effective-java-item45/</link>
      <guid>https://jaehun2841.github.io/2019/02/16/effective-java-item45/</guid>
      <pubDate>Sat, 16 Feb 2019 06:25:05 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;스트림 API는 다량의 데이터 처리 작업(순차적이든 병렬적이든)을 돕고자 자바8에 추가되었다.&lt;br&gt;
이 API가 제공하는 추상 개념 중 핵심은 두 가지다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스트림(Stream)은 데이터
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>스트림 API는 다량의 데이터 처리 작업(순차적이든 병렬적이든)을 돕고자 자바8에 추가되었다.<br>이 API가 제공하는 추상 개념 중 핵심은 두 가지다.</p><ul><li>스트림(Stream)은 데이터 원소의 유한 혹은 무한 시퀀스(sequence)를 의미</li><li>스트림 파이프라인(Stream Pipeline)은 이 원소들로 수행하는 연산단계를 표현하는 개념</li></ul><p>스트림의 원소들은 어디서부터든 올 수 있다. 대표적으로</p><ul><li>컬렉션 (Collection)</li><li>배열 (Array)</li><li>파일 (File)</li><li>정규표현식 (Regex Pattern Matcher)</li><li>난수 생성기 (Random Generator)</li><li>다른 스트림 (Other Stream)</li></ul><p>스트림 안의 데이터 원소들은 객체 참조(reference)나 기본 타입(int, long, double)을 지원한다.</p><ul><li><strong>Stream</strong> : 객체 참조타입에 대한 Stream</li><li><strong>IntStream</strong> : int 타입에 대한 Stream</li><li><strong>LongStream</strong> : long 타입에 대한 Stream</li><li><strong>DoubleStream</strong> : double 타입에 대한 Stream</li></ul><p>기본타입의 경우 위의 IntStream, LongStream, DoubleStream과 같은 Stream을 사용하는 것이 성능상 좋다.</p><h1 id="스트림-파이프라인-stream-pipeline">스트림 파이프라인 (Stream Pipeline)</h1><p>스트림 파이프 라인은 소스 스트림에서 시작해 종단 연산(terminal operation)으로 끝나며,<br>그 사이에 하나 이상의 중간 연산(intermediate operation)이 있을 수 있다.</p><h2 id="종단-연산-terminal-operation">종단 연산 (terminal operation)</h2><ul><li><p><strong>forEach(Consumer&lt;? super T&gt; consumer)</strong> : Stream의 요소를 순회</p></li><li><p><strong>count()</strong> : 스트림 내의 요소 수 반환</p></li><li><p><strong>max(Comparator&lt;? super T&gt; comparator)</strong> : 스트림 내의 최대 값 반환</p></li><li><p><strong>min(Comparator&lt;? super T&gt; comparator)</strong> : 스트림 내의 최소 값 반환</p></li><li><p><strong>allMatch(Predicate&lt;? super T&gt; predicate)</strong> : 스트림 내에 모든 요소가 predicate 함수에 만족할 경우 true</p></li><li><p><strong>anyMatch(Predicate&lt;? super T&gt; predicate)</strong> : 스트림 내에 하나의 요소라도 predicate 함수에 만족할 경우 true</p></li><li><p><strong>noneMatch(Predicate&lt;? super T&gt; predicate)</strong> : 스트림 내에 모든 요소가 predicate 함수에 만족하지않는 경우 true</p></li><li><p><strong>sum()</strong> : 스트림 내의 요소의 합 (IntStream, LongStream, DoubleStream)</p></li><li><p><strong>average()</strong> : 스트림 내의 요소의 평균 (IntStream, LongStream, DoubleStream)</p></li></ul><h2 id="중간-연산-intermediate-operation">중간 연산 (intermediate operation)</h2><ul><li><p>f<strong>ilter(Predicate&lt;? super T&gt; predicate)</strong> : predicate 함수에 맞는 요소만 사용하도록 필터</p></li><li><p><strong>map(Function&lt;? Super T, ? extends R&gt; function)</strong> : 요소 각각의 function 적용</p></li><li><p><strong>flatMap(Function&lt;? Super T, ? extends R&gt; function)</strong> : 스트림의 스트림을 하나의 스트림으로 변환</p></li><li><p><strong>distinct()</strong> : 중복 요소 제거</p></li><li><p><strong>sort()</strong> : 기본 정렬</p></li><li><p><strong>sort(Comparator&lt;? super T&gt; comparator)</strong> : comparator 함수를 이용하여 정렬</p></li><li><p><strong>skip(long n)</strong> : n개 만큼의 스트림 요소 건너뜀</p></li><li><p><strong>limit(long maxSize)</strong> : maxSize 갯수만큼만 출력</p></li></ul><h1 id="스트림의-지연-평가lazy-evaluation">스트림의 지연 평가(Lazy evaluation)</h1><p>스트림에 대한 평가는 종단 연산이 호출될 때 이뤄지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다.<br>이러한 지연 평가가 무한 스트림을 다룰 수 있게 해주는 열쇠다.</p><p>쉽게 말해 <strong>종단 연산(terminal operation)이 없는 스트림 파이프라인은 아무 일도 일어나지 않는다.</strong></p><h1 id="stream-예제-아나그램anagram">Stream 예제 - 아나그램(anagram)</h1><h2 id="일반-loop를-이용한-코드">일반 loop를 이용한 코드</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    File dectionary = <span class="keyword">new</span> File(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> minGroupSize = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; groups = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> (Scanner s = <span class="keyword">new</span> Scanner(dectionary)) &#123;</span><br><span class="line">        <span class="keyword">while</span>(s.hasNext()) &#123;</span><br><span class="line">            String word = s.next();</span><br><span class="line">            groups.computeIfAbsent(alphabetize(word), </span><br><span class="line">                                   (unused) -&gt; <span class="keyword">new</span> TreeSet&lt;&gt;()).add(word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Set&lt;String&gt; group : groups.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(group.size() &gt;= minGroupSize) &#123;</span><br><span class="line">            System.out.println(group.size() + <span class="string">": "</span> + group);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">alphabetize</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] a = s.toCharArray();</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>자바 8에서 추가된 computeIfAbsent 메서드를 사용했다</li><li>computeIfAbsent : 맵 안에 키가 있는지 찾은 다음, 있으면 단순히 그 키에 매핑된 값을 반환한다.</li></ul><h2 id="stream을-과도하게-쓴-코드">Stream을 과도하게 쓴 코드</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File dectionary = <span class="keyword">new</span> File(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> minGroupSize = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(Stream&lt;String&gt; words = Files.lines(dectionary.toPath())) &#123;</span><br><span class="line">        words.collect(</span><br><span class="line">            groupingBy(word -&gt; word.chars().sorted()</span><br><span class="line">                       .collect(StringBuilder::<span class="keyword">new</span>,</span><br><span class="line">                                (sb, c) -&gt; sb.append((<span class="keyword">char</span>) c),</span><br><span class="line">                                StringBuilder::append).toString()))</span><br><span class="line">            .values().stream()</span><br><span class="line">            .filter(group -&gt; group.size() &gt;= minGroupSize)</span><br><span class="line">            .map(group -&gt; group.size() + <span class="string">": "</span> + group)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>스트림을 과용하면 프로그램이 읽거나 유지보수 하기 어려워진다.</li></ul><h2 id="stream을-적절히-활용한-코드">Stream을 적절히 활용한 코드</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File dectionary = <span class="keyword">new</span> File(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> minGroupSize = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(Stream&lt;String&gt; words = Files.lines(dectionary.toPath())) &#123;</span><br><span class="line">        words.collect(groupingBy(word -&gt; alphabetize(word)))</span><br><span class="line">            .values().stream()</span><br><span class="line">            .filter(group -&gt; group.size() &gt;= minGroupSize)</span><br><span class="line">            .forEach(group -&gt; System.out.println(group.size() + <span class="string">": "</span> + group));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>스트림을 적절하게 사용하면 명료해진다.</li><li>람다에서는 타입 추론 기능을 사용하기 때문에 주로 타입 이름을 생략한다.<br>따라서 매개변수 이름을 잘 지어야 스트림 파이프라인의 가독성이 유지된다.</li><li>연산에 적절한 이름을 지어 주고 도우미 메서드를 적정히 활용하는 것은 일반 반복코드보다 스트림 파이프라인에서 훨씬 크다</li></ul><h1 id="기존-코드는-필요한-경우에만-스트림으로-리팩터링-하자">기존 코드는 필요한 경우에만 스트림으로 리팩터링 하자</h1><p>스트림을 처음 쓰기 시작하면 모든 반복문을 스트림으로 바꾸고 싶은 유혹이 생긴다.<br>스트림으로 바꾸는 게 가능할 지라도, 가독성과 유지보수 측면에서 볼 때 손해를 볼 수 있기 때문에 무작정 바꾸지는 말자<br>스트림과 반복문을 적절히 활용하는 것이 최선이다.</p><h1 id="코드블럭-vs-람다lambda">코드블럭 vs 람다(lambda)</h1><ul><li>코드블럭에서는 범위 안의 지역변수를 읽고 수정할 수 있다.</li><li>람다에서는 final이거나 사실상 final인 변수만 읽을 수 있다. (캡처)지역 변수를 수정하는 것은 불가능하다.</li><li>코드 블럭에서는 return을 이용해 메서드를 빠져나갈 수 있다.</li><li>코드 블럭에서는 break, continue문을 통해 블럭 바깥의 반복문을 종료 할 수 있다.</li><li>메서드 선언에 명시된 예외(Exception)을 던질 수 있다.</li><li>하지만 람다로는 모든 것이 불가능하다.</li></ul><h1 id="스트림이-적합한-경우">스트림이 적합한 경우</h1><ul><li>원소들의 시퀀스를 일관되게 변환한다.</li><li>원소들의 시퀀스를 필터링한다.</li><li>원소들의 시퀀스를 하나의 연산을 사용해 결합한다. (더하기, 연결하기, 최소값 등..)</li><li>원소들의 시퀀스를 컬렉션에 모은다</li><li>원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.</li></ul><h1 id="스트림이-적합하지-않은-경우">스트림이 적합하지 않은 경우</h1><ul><li>데이터가 파이프라인의 여러 단계(stage)를 통과할 때 이 데이터의 각 단계에서의 값들에 동시에 접근하기 어려운 경우</li><li>스트림 파이프라인은 한 값을 다른 값에 매핑하고 나면 원래의 값을 잃는 구조이기 때문</li></ul><h2 id="예제-메르센-소수-출력하기">예제 - 메르센 소수 출력하기</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Stream&lt;BigInteger&gt; <span class="title">primes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.iterator(TWO, BigInteger::nextProbablePrime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위의 코드는 무한 스트림을 반환하는 메서드이다.</li><li>아직 종단 연산이 없기 때문에 실행되지는 않는 스트림이다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    primes().map(p -&gt; TWO.pow(p.intValueExact().subtract(ONE)))</span><br><span class="line">            .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">            .limit(<span class="number">20</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위의 코드는 메르센 소수를 20개를 출력하는 프로그램이다.</li></ul><h1 id="예제-데카르트-곱">예제 - 데카르트 곱</h1><h2 id="데카르트-곱을-반복을-이용하여-구현">데카르트 곱을 반복을 이용하여 구현</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Card&gt; <span class="title">newDeck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Card&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Suit suit : Suit.values()) </span><br><span class="line">        <span class="keyword">for</span>(Rank rank : Rank.values())</span><br><span class="line">            result.add(<span class="keyword">new</span> Card(suit, rank));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>카드는 숫자(rank)와 무늬(suit)를 묶은 불변 값 클래스이거 숫자와 무늬는 열거타입이다.</li><li>for-each를 통해 스트림을 모르는 개발자라도 쉽게 알아 볼 수 있는 코드이다</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Card&gt; <span class="title">newDeck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(Suit.values())</span><br><span class="line">    .flatMap(suit -&gt; Stream.of(Rank.values())</span><br><span class="line">                      .map(rank -&gt; <span class="keyword">new</span> Card(suit, rank)))</span><br><span class="line">    .collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>Stream을 중첩하여 만든 코드이다.</li><li>개발자에 따라 어떤 코드가 가독성, 유지보수성이 좋은 코드인지 갈리겠지만,<br>내 기준에는 첫번째 코드가 더 가독성과 유지보수성이 좋아보인다.</li></ul><h1 id="요약">요약</h1><ul><li>스트림과 함수형 프로그래밍에 익숙한 프로그래머라면 스트림방식이 좀 더 명확하다</li><li>스트림을 사용할 때가 있고, 반복을 사용할 때가 있다.</li><li>스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 택하는 것이 좋다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 45. 스트림은 주의해서 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/16/effective-java-item45/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item41/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item41/</guid>
      <pubDate>Mon, 04 Feb 2019 11:22:34 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시 해주는 인터페이스를 마커 인터페이스라고 한다.&lt;br&gt;
Serializeable 인터페이스가 가장 좋은 예이다.&lt;/p&gt;
&lt;p
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시 해주는 인터페이스를 마커 인터페이스라고 한다.<br>Serializeable 인터페이스가 가장 좋은 예이다.</p><p><img src="./serializable.png" alt="serializable"></p><p>아무런 메서드도 없다.<br>단지 타입 정보만 알려주는 인터페이스이다.</p><h1 id="마커-인터페이스의-장점">마커 인터페이스의 장점</h1><ul><li>마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 사용가능하다.<br>(마커 애너테이션은 그렇지 않다.)</li><li>마커 인터페이스는 컴파일타임에 오류를 발견할 수 있다.(마커 애너테이션은 런타임에 발견된다.)</li><li>ObjectOutputStream.writeObject 메서드는 파라미터에 Serializeable 인터페이스를 구현한 파라미터가 와야한다.<ul><li>Serializeable를 구현한 파라미터가 와도 컴파일 에러는 나지 않는다.</li><li>하지만 런타임에 Serializeable 타입이 아니라는 에러를 발생 시킨다.</li></ul></li><li>적용 대상을 더 정밀하게 지정할 수 있다.<ul><li>적용 대상을 @Target(ElementType.TYPE)으로 선언한 애너테이션은 모든 타입(클래스, 인터페이스, 열거타입, 애너테이션)에 달 수 있다.</li><li>부착 할 수 있는 타입을 더 세밀하게 제한하지 못한다.</li><li>마커 인터페이스의 경우 그냥 마킹하고 싶은 클래스에만 그 인터페이스를 구현하면 된다.<br>그러면 마킹된 타입은 자동으로 그 인터페이스의 하위타입이 보장된다.</li></ul></li><li>마커 인터페이스는 객체의 특정 부분을 불변식으로 규정하거나,<br>그 타입의 인스턴스는 다른 클래스의 특정 메서드가 처리 할 수 있다는 사실을 명시하는 용도로 사용 할 수 있다.<br>(Serializeable 인터페이스가 ObjectOutputStream이 처리할 수 있는 인스턴스이듯이)</li></ul><h1 id="마커-애너테이션의-장점">마커 애너테이션의 장점</h1><ul><li>거대한 애너테이션 시스템의 지원을 받는다.<ul><li>애너테이션 기반의 프레임워크에서는 마커 애너테이션을 쓰는 쪽이 더 나을 수 있다. (일관적이어서)</li></ul></li><li>클래스, 인터페이스 외의 프로그램 요소 (모듈, 패키지, 필드, 지역변수)에 마킹해햐 할 때는  마커 인터페이스를 쓸 수 없으니<br>마커 애너테이션을 사용할 수밖에 없다.</li></ul><h1 id="요약">요약</h1><ul><li>마커 인터페이스와 마커 애너테이션은 각자의 쓰임이 있다.</li><li>새로 추가하는 메서드 없이 단지 타입 정의가 목적이라면 마커 인터페이스를 선택하자</li><li>마커 애너테이션을 사용할 때 @Target(ElementType.TYPE)인 마커 애너테이션을 작성하고 있다면,<br>마커 애너테이션을 정말 사용해야 하는지? 마커 인터페이스를 사용할 수 있는지 생각해보고<br>웬만하면 마커 인터페이스를 사용하도록 하자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item41/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 40. @Override 애너테이션을 일관되게 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item40/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item40/</guid>
      <pubDate>Mon, 04 Feb 2019 10:51:36 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바가 기본으로 제공하는 애너테이션 중 보통의 프로그래머에게 가장 중요한 것은 @Override일 것이다.&lt;br&gt;
@Override는 메서드 선언에만 달 수 있으며, 이 애너테이션의 의미는 상위 클래스의 메서드
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바가 기본으로 제공하는 애너테이션 중 보통의 프로그래머에게 가장 중요한 것은 @Override일 것이다.<br>@Override는 메서드 선언에만 달 수 있으며, 이 애너테이션의 의미는 상위 클래스의 메서드를 재정의 했음을 의미한다.</p><h1 id="override를-선언하지-않은-메서드">@Override를 선언하지 않은 메서드</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bigram</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bigram</span><span class="params">(<span class="keyword">char</span> first, <span class="keyword">char</span> second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Bigram bigram)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bigram.first == <span class="keyword">this</span>.first &amp;&amp;</span><br><span class="line">                bigram.second == <span class="keyword">this</span>.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * first + second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Bigram&gt; s = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">                s.add(<span class="keyword">new</span> Bigram(ch, ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(s.size()); <span class="comment">//260</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Bigram이라는 문자 2개를 갖는 클래스에 a~z까지 26개의 문자를 넣고, 10개씩 만든다음에 HashSet에 삽입했다.<br>생각해보면 26개가 나올 것 같지만, 실제로는 260개가 발생한다.</p><p>왜 그럴까?</p><p>HashSet은 내부적으로 equals 메서드를 기반으로 객체의 논리적 동치적(equals) 검사를 실시한다.<br>하지만 자세히 보면 equals메서드의 파라미터 타입이 Bigram이다. equals 메서드를 재정의 한게 아니라 Overloading 한 꼴이다.</p><p>equals를 재정의 하려면 파라미터 타입이 Object이어야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Bigram bigram)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bigram.first == <span class="keyword">this</span>.first &amp;&amp;</span><br><span class="line">        bigram.second == <span class="keyword">this</span>.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 변경하고 컴파일 해보면,</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(15, 5) java: method does not override or implement a method from a supertype</span><br></pre></td></tr></table></figure></p><p>이러한 컴파일 에러가 발생한다.</p><p>잘못된 부분을 명확히 알려주므로 곧장 수정할 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object bigram)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Bigram)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Bigram b = (Bigram) bigram;</span><br><span class="line">    <span class="keyword">return</span> b.first == <span class="keyword">this</span>.first &amp;&amp;</span><br><span class="line">        b.second == <span class="keyword">this</span>.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="요약">요약</h1><ul><li>상위 클래스의 메서드를 재정의 하는 모든 메서드에 @Override 애너테이션을 달자</li><li>굳이 @Override를 달지 않아도 동작은 한다. 하지만 일괄적으로 붙여주는게 좋다.</li><li>인터페이스를 상속한 구체 클래스인데 아직 구현하지 않은 추상 메서드가 남아있다면,<br>컴파일러가 바로 사실을 알려준다.</li><li>Java 8 부터 Default 메서드의 사용이 가능해 지면서, 인터페이스의 메서드를 재정의 할 때도 사용할 수 있다.</li><li>구현하려는 인터페이스에 Default 메서드가 없음을 안다면 @Override를 생략해 코드를 조금 깔끔히 유지해도 좋다.</li><li>웬만하면 추상클래스나 인터페이스에서는 상위 클래스나 상위 인터페이스를 재정의하는 모든 메서드에 @Override를 다는것이 좋다.<br>(실수 했을 때 컴파일러가 알려준다.)</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 40. @Override 애너테이션을 일관되게 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item40/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 39. 명명 패턴보다 애너테이션을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item39/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item39/</guid>
      <pubDate>Mon, 04 Feb 2019 10:49:36 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;전통적으로 도구나 프레임워크가 특별히 다뤄야 할 프로그램 요소에는 딱 구분되는 명명 패턴을 적용해 왔다.&lt;br&gt;
예컨데 테스트 프레임워크인 JUnit3에서는 테스트 메서드 이름을 &lt;strong&gt;test&lt;/str
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>전통적으로 도구나 프레임워크가 특별히 다뤄야 할 프로그램 요소에는 딱 구분되는 명명 패턴을 적용해 왔다.<br>예컨데 테스트 프레임워크인 JUnit3에서는 테스트 메서드 이름을 <strong>test</strong>로 시작하게 지어야 했다.</p><p>단점은 아래와 같다.</p><ol><li><p>오타가 나면 안된다.<br>실수로 이름을 tset~라고 지으면 그 테스트 메서드는 무시하고 지나가기 때문에 테스트 메서드가 제대로 실행됐는지 어쨌는지 모른다.</p></li><li><p>올바른 프로그램 요소에서만 사용되리라 보증 할 방법이 없다.<br>예컨데 TestSafetyMechanisms으로 JUnit에 던져줬다고 해보자. 개발자는 이 클래스에 정의된 테스트 메서드들을 수행해 주길 기대하겠지만, JUnit은 클래스 이름에는 관심이 없다. 이번에도 경고조차 출력하지 않고 개발자가 의도한 대로 테스트는 진행되지 않는다.</p></li><li><p>프로그램 요소를 매개변수로 전달할 마땅한 방법이 없다는 것이다.<br>특정 예외를 던져야만 성공하는 테스트가 있을 때, 기대하는 예외의 타입을 매개변수로 전달해야 하는 상황이다.<br>예외의 이름을 테스트 메서드 이름에 덧붙이는 방법도 있지만, 보기에도 나쁘고 깨지기도 쉽다.</p></li></ol><p>이런 문제를 해결해 주는 개념으로 JUnit4 부터는 애너테이션을 도입하였다.</p><h1 id="마커-애너테이션-타입선언">마커 애너테이션 타입선언</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 테스트 메서드임을 선언하는 애너테이션이다.</span></span><br><span class="line"><span class="comment">* 매개변수 없는 정적메서드 전용이다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//성공</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//실행되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//실패</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"실패"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//실행되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//잘못 사용한 예</span></span><br><span class="line">        <span class="comment">//static method가 아니다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//실행되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//실패</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"실패"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//실행되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@Test와 같은 애너테이션을 <strong>아무 매개변수 없이 단순히 대상에 마킹(Marking)한다</strong>는 뜻에서 마커 애너테이션 (Marker Annotation)이라고 한다.<br>이 애너테이션을 사용하면 @Test 애너테이션에 오타를 내면 컴파일 오류를 내준다.</p><p>아래 프로그램을 실행하면총 8개의 메서드 중 4개의 테스트 메서드가 실행되고</p><ul><li>성공 1개</li><li>실패 2개</li><li>1개는 잘못 사용한 예이다.</li></ul><p>애너테이션은 Sample클래스의 의미에 직접적으로 영향을 주지는 않는다.<br>그저 애너테이션에 관심있는 프로그램에게 추가 정보를 제공할 뿐이다.<br>다시 말하면, 프로그램 코드에의 의미는 그대로 둔 채 애너테이션에 관심있는 도구에서 특별히 처리하도록 하는 것이다.</p><h2 id="메타-애너테이션-meta-annotation">메타 애너테이션 (Meta Annotation)</h2><p>애너테이션 타입에 다는 애너테이션을 메타 애너테이션 (Meta Annotation)이라 한다.<br>메타 애너테이션의 종류로는</p><ul><li><p><strong>@Documented</strong>: 문서에도 애너테이션 정보가 표현되게 함</p></li><li><p><strong>@Inherited</strong>: 자식클래스가 애너테이션을 상속받을 수 있게 함</p></li><li><p><strong>@Repeatable</strong>: 애너테이션을 반복적으로 사용할 수 있게 함</p></li><li><p><strong>@Retention(RetentionPolicy)</strong>: 애너테이션의 범위를 지정 (어느 시점까지 유효한지?)</p><ul><li><strong>RetentionPolicy.RUNTIME</strong>: 컴파일 이후에도 JVM에 의해 참조가 가능 - 보통 이거로 설정</li><li><strong>RetentionPolicy.CLASS</strong>: 컴파일러가 클래스를 참조할 때 까지 유효</li><li><strong>RetentionPolicy.SOURCE</strong>: 애너테이션 정보가 컴파일 이후 사라짐</li></ul></li><li><p><strong>@Target(ElementType[])</strong>: 애너테이션이 적용될 위치를 선언</p><ul><li><strong>ElementType.PACKAGE</strong>:  패키지 선언시</li><li><strong>ElementType.TYPE</strong>: 타입 선언시</li><li><strong>ElementType.CONSTRUCTOR</strong>: 생성자 선언시</li><li><strong>ElementType.FIELD</strong>: 멤버 변수 선언시</li><li><strong>ElementType.METHOD</strong>:  메소드 선언시</li><li><strong>ElementType.ANNOTATION_TYPE</strong>: 어노테이션 타입 선언시</li><li><strong>ElementType.LOCAL_VARIABLE</strong>: 지역 변수 선언시</li><li><strong>ElementType.PARAMETER</strong>: 매개 변수 선언시</li><li><strong>ElementType.TYPE_PARAMETER</strong>: 매개 변수 타입 선언시</li><li><strong>ElementType.TYPE_USE</strong>: 타입 사용시</li></ul></li></ul><h2 id="마커-애너테이션-processor">마커 애너테이션 processor</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tests = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> passed = <span class="number">0</span>;</span><br><span class="line">        Class&lt;?&gt; testClass = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Method m : testClass.getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.isAnnotationPresent(Test.class)) &#123;</span><br><span class="line">                test++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    m.invoke(<span class="keyword">null</span>);</span><br><span class="line">                    passed++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException wrappedExc) &#123;</span><br><span class="line">                    Throwable exc = wrappedExc.getCause();</span><br><span class="line">                    System.out.println(m + <span class="string">" 실패: "</span> + exc);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"잘못 사용한 @Test: "</span> + m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.printf(<span class="string">"성공: %d, 실패: %d%n"</span>, passed, tests-passed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>m.isAnnotationPresent(Test.class)</strong>: @Test 애너테이션이 적용된 메서드인지 판별</li><li><strong>m.invoke()</strong>: @Test 메서드 실행</li><li><strong>InvocationTargetException</strong>: 테스트 메서드가 예외를 던지면 리플렉션 메커니즘이 InvocationTargetException으로 감싸서 다시 던진다.<br>그래서 이 프로그램은 InvocationTargetException에 대해 catch절을 구성해 원래 예외에 담긴 정보를 출력한다.</li><li><strong>두번째 catch</strong>: 두번째 catch블럭은 잘못 사용해서 발생한 예외를 처리</li></ul><h1 id="매개변수-하나짜리-애너테이션-타입선언">매개변수 하나짜리 애너테이션 타입선언</h1><p>특정 예외를 던져야만 성공하는 테스트도 있을 것이다.<br>특정 예외가 발생했을 때 성공하는 테스트를 지원하도록 해보자.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 명시한 예외를 던져야만, 성공하는 테스트케이스 애너테이션</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTest&#123;</span><br><span class="line">    <span class="comment">//한정적 와일드카드를 통해 Throwable을 상속한 모든 타입을 지정</span></span><br><span class="line">    Class&lt;? extends Throwable&gt; values(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="예제-프로그램">예제 프로그램</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionTest</span>(ArithmeticException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        i = i / i; <span class="comment">//divide by zero. ArithmeticException 예외를 발생시킴 -&gt; 성공</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ExceptionTest</span>(ArithmeticException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> i = a[<span class="number">1</span>]; <span class="comment">//IndexOutOfBoundsException 발생 -&gt; ArithmeticException가 아니므로 실패</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ExceptionTest</span>(ArithmeticException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 아무 Exception도 발생하지 않음 -&gt; 실패</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="매개변수-하나짜리-애너테이션-processor">매개변수 하나짜리 애너테이션 processor</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(m.isAnnotaionPresent(ExceptionTest.class)) &#123;</span><br><span class="line">    test++;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m.invoke(<span class="keyword">null</span>);</span><br><span class="line">        System.out.printf(<span class="string">"테스트 %s 실패: 예외를 던지지 않음%n"</span>, m);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException wrappedExc) &#123;</span><br><span class="line">        Throwable exc = wrappedExc.getCause();</span><br><span class="line">        Class&lt;? extends Throwable&gt; excType = m.getAnnotation(ExceptionTest.class).value();</span><br><span class="line">        <span class="keyword">if</span>(excType.isInstance(exc)) &#123;</span><br><span class="line">            passed++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"테스트 %s 실패: 기대한 예외 %s, 발생한 예외 %s%n"</span>, m, excType.getName(), exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"잘못 사용한 @ExceptionTest: "</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 @Test와의 차이는 애너테이션의 매개변수를 추출하여 테스트 메서드가 올바른 메서드를 던졌는지 확인하는데 사용한다.<br>m.getAnnotation(ExceptionTest.class).value()를 실행할 때 ArithmeticException.class가 리턴된다.</p><h1 id="배열-매개변수를-받는-애너테이션-타입선언">배열 매개변수를 받는 애너테이션 타입선언</h1><p>Exception이 발생하는 종류를 묶어서 처리하고 싶을 때도 있다.<br>@ExceptionTest에서 배열형태로 Exception클래스를 받을 수 있도록 배열로 선언하였다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 명시한 예외를 던져야만, 성공하는 테스트케이스 애너테이션</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTest&#123;</span><br><span class="line">    <span class="comment">//한정적 와일드카드를 통해 Throwable을 상속한 모든 타입을 지정</span></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] values(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="예제-프로그램">예제 프로그램</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionTest</span>(&#123;IndexOutOfBoundsException.class,</span><br><span class="line">                    NullPointerException.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//자바 명세에 따르면, 다음 메서드는 IndexOutOfBoundsException이나,</span></span><br><span class="line">        <span class="comment">//NullPointerException을 던질 수 있다.</span></span><br><span class="line">        <span class="comment">//예외 발생 시 성공</span></span><br><span class="line">        list.addAll(<span class="number">5</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="배열-매개변수를-받는-애너테이션-processor">배열 매개변수를 받는 애너테이션 processor</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(m.isAnnotaionPresent(ExceptionTest.class)) &#123;</span><br><span class="line">    test++;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m.invoke(<span class="keyword">null</span>);</span><br><span class="line">        System.out.printf(<span class="string">"테스트 %s 실패: 예외를 던지지 않음%n"</span>, m);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException wrappedExc) &#123;</span><br><span class="line">        Throwable exc = wrappedExc.getCause();</span><br><span class="line">        Class&lt;? extends Throwable&gt;[] excTypes = m.getAnnotation(ExceptionTest.class).value();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> oldPassed = passed;</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;? extends Throwable&gt; excType : excTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span>(excType.isInstance(exc)) &#123;</span><br><span class="line">            passed++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(passed == oldPassed) &#123;</span><br><span class="line">            System.out.println(<span class="string">"테스트 %s 실패: %s %n"</span>, m, exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"잘못 사용한 @ExceptionTest: "</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드 중 변경되는 부분은  Class&lt;? extends Throwable&gt;[] excTypes을 배열형태로 받아,<br>이미 지정한 Exception 클래스 중에 맞는 클래스가 있는지 확인하는 코드가 변경되었다.</p><h1 id="반복-가능-애너테이션-repeatable">반복 가능 애너테이션 @Repeatable</h1><p>자바8에서는 여러개의 값을 받는 애너테이션을 다른 방식으로도 만들 수 있다.<br>배열 방식의 매개변수를 사용하는 대신 애너테이션에 @Repeatable 메타애너테이션을 다는 방식이다.<br>@Repeatable 애너테이션은 하나의 메서드에 여러개의 애너테이션을 지정할 수 있다.</p><ol><li>@Repeatable을 단 애너테이션을 반환하는 <strong>컨테이너 애너테이션</strong>을 하나 더 정의한다.</li><li>@Repeatable에 이 컨터이너 애너테이션의 class 객체를 매개변수로 전달해야 한다.</li><li>컨테이너 애너테이션은 내부 애너테이션 타입의 배열을 반환하는 value 메서드를 정의한다.</li><li>컨터이너 애너테이션에는 @Retention과 @Target을 적절히 명시한다.<br>(그렇지 않으면 컴파일되지 않는다.)</li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Repeatable</span>(ExceptionTestContainer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTest &#123;</span><br><span class="line">    Class&lt;? extends Throwable&gt; value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTestContainer &#123;</span><br><span class="line">    ExceptionTest[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="예제-프로그램-반복-가능-애너테이션을-적용한-예">예제 프로그램 - 반복 가능 애너테이션을 적용한 예</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionTest</span>(IndexOutOfBoundsException.class)</span><br><span class="line"><span class="meta">@ExceptionTest</span>(NullPointerException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>반복 가능 애너테이션은 처리할 때 주의를 요한다.반복 가능 애너테이션을 여러개 달면, 하나만 달았을 때와 구분하기 위해 해당 <strong>컨테이너</strong> 애너테이션 타입이 적용 된다.</p><ul><li>getAnnotationByType 메서드는 이 둘을 구분하지 않아 @ExceptionTest와 @ExceptionTestContainer를 모두 가져온다.</li><li>isAnnotationPresent는 둘을 구분한다.<ul><li>만약 @ExceptionTest를 여러번 단 다음, isAnnotationPresent로 ExceptionTest를 검사하면 false가 나온다.<br>(@ExceptionTestContainer로 인식하기 때문)</li><li>반대로 @ExceptionTest를 한번 만 단 다음, isAnnotationPresent로 ExceptionTestContainer를 검사하면 false가 나온다.(@ExceptionTest가 적용되었기 때문)</li></ul></li></ul><h2 id="반복-가능-애너테이션-processor">반복 가능 애너테이션 processor</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        m.invoke(<span class="keyword">null</span>);</span><br><span class="line">        System.out.printf(<span class="string">"테스트 %s 실패: 예외를 던지지 않음%n"</span>, m);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException wrappedExc) &#123;</span><br><span class="line">        Throwable exc = wrappedExc.getCause();</span><br><span class="line">        <span class="keyword">int</span> oldPassed = passed;</span><br><span class="line">    </span><br><span class="line">        ExceptionTest[] excTests = m.getAnnotationByType(ExceptionTest.class);</span><br><span class="line">        <span class="keyword">for</span>(ExceptionTest excType : excTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span>(excType.isInstance(exc)) &#123;</span><br><span class="line">            passed++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(passed == oldPassed) &#123;</span><br><span class="line">            System.out.println(<span class="string">"테스트 %s 실패: %s %n"</span>, m, exc);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>반복 가능 애너테이션을 사용한 경우 getAnnotationByType를 사용해 애너테이션 정보를 가져오는 것이 좋다.</p><h1 id="요약">요약</h1><ul><li><p>애너테이션이 명명패턴을 이용할 때 보다 확실히 낫다.</p></li><li><p>애너테이션으로 할 수 있는 일을 명명 패턴으로 처리할 이유는 없다.</p></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 39. 명명 패턴보다 애너테이션을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item39/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item38/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item38/</guid>
      <pubDate>Mon, 04 Feb 2019 09:54:37 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;타입 안전 열거 패턴은 확장이 가능하나, 열거 타입은 확장을 할 수 없다&lt;br&gt;
다시 말해 타입 안전 열거 패턴은 값을 그대로 가져온 다음 값을 더 추가하여 다른 목적으로 쓸 수 있지만,&lt;br&gt;
열거 타입은 그
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>타입 안전 열거 패턴은 확장이 가능하나, 열거 타입은 확장을 할 수 없다<br>다시 말해 타입 안전 열거 패턴은 값을 그대로 가져온 다음 값을 더 추가하여 다른 목적으로 쓸 수 있지만,<br>열거 타입은 그럴 수 없다.</p><p>하지만 열거타입도 확장할 수 있는 방법이 한 가지 존재한다.<br>기본적인 아이디어는 열거 타입이 인터페이스를 구현할 수 있다는 사실을 이용하는 것이다.</p><h1 id="인터페이스를-이용한-확장-가능-열거-타입">인터페이스를 이용한 확장 가능 열거 타입</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> BasicOperation implements Operation &#123;</span><br><span class="line"></span><br><span class="line">    PLUS(<span class="string">"+"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(<span class="string">"-"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(<span class="string">"*"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x * y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(<span class="string">"/"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x / y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line"></span><br><span class="line">    BasicOperation(String symbol) &#123;</span><br><span class="line">        <span class="keyword">this</span>.symbol = symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>열거 타입인 BasicOperation은 확장할 수 없지만 인터페이스인 Operation은 확장할 수 있고, 이 인터페이스를 연산의 타입으로 사용하면 된다.</p><h2 id="다른-열거-타입-추가">다른 열거 타입 추가</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExtendedOperation implements Operation &#123;</span><br><span class="line"></span><br><span class="line">    EXP(<span class="string">"^"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.pow(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    REMAINDER(<span class="string">"%"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x % y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line"></span><br><span class="line">    ExtendedOperation(String symbol) &#123;</span><br><span class="line">        <span class="keyword">this</span>.symbol = symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Operation 인터페이스를 구현하면 다른 열거 타입에서도 인터페이스를 구현하여 기능을 확장할 수 있다.</p><h1 id="열거-타입-확인">열거 타입 확인</h1><h2 id="enum타입을-넘겨-순회하기">Enum타입을 넘겨 순회하기</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">double</span> y = <span class="number">2</span>;</span><br><span class="line">        test(ExtendedOperation.class, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt; &amp; Operation&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Class&lt;T&gt; opEnumType, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Operation op : opEnumType.getEnumConstants()) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%f %s %f = %f%n"</span>, x, op, y, op.apply(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>&lt;T extends Enum&lt;T&gt; &amp; Operation&gt; : 타입이 Enum타입이면서, Operation을 구현하는 클래스</li></ul><h2 id="collectionlt-extends-operationgt-넘겨-순회하기">Collection&lt;? extends Operation&gt; 넘겨 순회하기</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">double</span> y = <span class="number">2</span>;</span><br><span class="line">        test2(Arrays.asList(ExtendedOperation.values()), x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Collection&lt;? extends Operation&gt; opSet, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Operation op : opSet) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%f %s %f = %f%n"</span>, x, op, y, op.apply(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>열거 타입의 리스트를 넘겨 &lt;? extends Operation&gt;인 한정적 와일드 카드 타입으로 지정</li></ul><h1 id="요약">요약</h1><ul><li>확장할 수 있는 열거 타입이 필요한 경우 인터페이스를 정의하여 구현하자</li><li>열거 타입끼리는 상속이 되지 않는다.</li><li>여러 열거 타입 간 공유하는 기능이 있으면, 클래스나 도우미 메서드로 분리하자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item38/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 37. Ordinal 인덱싱 대신 EnumMap을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item37/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item37/</guid>
      <pubDate>Mon, 04 Feb 2019 08:33:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;ordinal을-배열-인덱스로-사용해선-안된다&quot;&gt;ordinal()을 배열 인덱스로 사용해선 안된다.&lt;/h1&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="ordinal을-배열-인덱스로-사용해선-안된다">ordinal()을 배열 인덱스로 사용해선 안된다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Lifecycle &#123; ANNUAL, PERENNIAL, BIENNIAL &#125;</span><br><span class="line">    <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">final</span> Lifecycle lifeCycle;</span><br><span class="line">    </span><br><span class="line">    Plant(String name, Lifecycle lifeCycle) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.lifeCycle = lifeCycle;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Plant&gt;[] plantsByLifeCycle = (Set&lt;Plant&gt;[]) <span class="keyword">new</span> Set[Plant.LifeCycle.values().length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; plantsByLifeCycle.length ; i++) &#123;</span><br><span class="line">    plantsByLifeCycle[i] = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Plant p : garden) &#123;</span><br><span class="line">    plantsByLifeCycle[p.lifeCycle.ordinal()].add(p); <span class="comment">//이런 코드는 제발 쓰지 말자</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과 출력</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plantsByLifeCycle.length; i++) &#123;</span><br><span class="line">    System.out.printf(<span class="string">"%s: %s%n"</span>, Plant.LifeCycle.values()[i], plantsByLifeCycle[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>문제점</strong></p><ul><li><code>Set&lt;Plant&gt;[] plantsByLifeCycle = (Set&lt;Plant&gt;[]) new Set[Plant.LifeCycle.values().length]</code><br>배열은 제네릭과 호환되지 않는다. (비검사 형변환이 수행, 컴파일이 안된다.)</li><li>ordinal()은 상수 선언 순서에 따라 변한다.</li><li>잘못된 값을 사용하면 이상한 동작을 유발한다.</li></ul><h1 id="enummap을-사용해-매핑">EnumMap을 사용해 매핑</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Plant.LifeCycle, Set&lt;Plant&gt;&gt; plantsByLifeCycle = <span class="keyword">new</span> EnumMap&lt;&gt;(Plant.LifeCycle.class);</span><br><span class="line"><span class="keyword">for</span> (Plant.LifeCycle lc : Plant.LifeCycle.values()) &#123;</span><br><span class="line">    plantsByLifeCycle.put(lc, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Plant p : garden) &#123;</span><br><span class="line">    plantsByLifeCycle.get(p.lifeCycle).add(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>더 간단명료하게 로직이 변환되었다.</li><li>맵의 키인 열거 타입이 그 자체로 출력용 문자열을 제공하니 출력결과에 별도의 formatting이 필요없다.</li><li>EnumMap의 성능이 ordinal을 쓴 배열과 같은 이유는 EnumMap 내부에서 ordinal을 사용한 배열을 사용하기 때문이다.</li><li>개발자가 직접 제어하지 않고 Map을 사용하여, 타입안정성을 얻을 뿐더러 성능상의 이점까지 그대로 가져간다.</li></ul><h1 id="stream을-이용한-코드">Stream을 이용한 코드</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap을 이용한 데이터와 열거타입 매핑</span></span><br><span class="line">Arrays.stream(garden)</span><br><span class="line">      .collect(groupingBy(p -&gt; p.lifeCycle))</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EnumMap을 이용해 데이터와 열거타입 매핑</span></span><br><span class="line">Arrays.stream(garden)</span><br><span class="line">      .collect(groupingBy(p -&gt; p.lifeCycle, () -&gt; <span class="keyword">new</span> EnumMap&lt;&gt;(LifeCycle.class),</span><br><span class="line">                         toSet()));</span><br></pre></td></tr></table></figure></p><ul><li>두 방식의 차이<ul><li>HashMap을 이용한 방식에는 garden에 있는 키만 만든다.</li><li>EnumMap을 이용한 방식에는 garden에 데이터가 없어도 모든 키가 다 만들어 진다.</li></ul></li></ul><h1 id="추가-예제">추가 예제</h1><h2 id="ordinal을-배열의-인덱스로-사용한-예">ordinal()을 배열의 인덱스로 사용한 예</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Phase &#123;</span><br><span class="line">    SOLID, LIQUID, GAS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Transition &#123;</span><br><span class="line">        MELT, FREEZE, BOIL, CONDENSE, SUBLIME, DEPOSIT;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 행은 from의 ordinal을, 열은 to의 ordinal을 인덱스로 사용</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Transition[][] TRANSITIONS = &#123;</span><br><span class="line">            &#123; <span class="keyword">null</span>, MELT, SUBLIME &#125;,</span><br><span class="line">            &#123; FREEZE, <span class="keyword">null</span>, BOIL &#125;,</span><br><span class="line">            &#123; DEPOSIT, CONDENSE, <span class="keyword">null</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 한 상태에서 다른 상태로의 전이를 반환한다.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transition <span class="title">from</span><span class="params">(Phase from, Phase to)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> TRANSITIONS[from.ordinal()][to.ordinal()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 예제는 결국 SOLID, LIQUID, GAS의 상태 변화(from~to)에 대한 배열로 맵을 만든 것이다.<br>이렇게 되면 Phase가 추가 될 때마다 배열을 수정해 줘야 하는 불상사가 발생한다.</p><h2 id="enummap을-이용">EnumMap을 이용</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Phase &#123;</span><br><span class="line"></span><br><span class="line">    SOLID, LIQUID, GAS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Transition &#123;</span><br><span class="line">        MELT(SOLID, LIQUID),</span><br><span class="line">        FREEZE(LIQUID, SOLID),</span><br><span class="line">        BOIL(LIQUID, GAS),</span><br><span class="line">        CONDENSE(GAS, SOLID),</span><br><span class="line">        SUBLIME(SOLID, GAS),</span><br><span class="line">        DEPOSIT(GAS, SOLID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phase from;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phase to;</span><br><span class="line"></span><br><span class="line">        Transition(Phase from, Phase to) &#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt; m = Stream.of(values())</span><br><span class="line">                .collect(groupingBy(t -&gt; t.from, () -&gt; <span class="keyword">new</span> EnumMap&lt;&gt;(Phase.class),</span><br><span class="line">                        toMap(t -&gt; t.to, <span class="comment">//key-mapper</span></span><br><span class="line">                                t -&gt; t,  <span class="comment">//value-mapper</span></span><br><span class="line">                                (x, y) -&gt; y, <span class="comment">//merge-function</span></span><br><span class="line">                                () -&gt; <span class="keyword">new</span> EnumMap&lt;&gt;(Phase.class))));</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transition <span class="title">from</span> <span class="params">(Phase from, Phase to)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.get(from).get(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>EnumMap을 사용하여 간단하게 바꾼 모습이다.<br>Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt;을 초기화하는 부분이 복잡하다.</p><ol><li>일단 from으로 grouping 하여 EnumMap을 하나 생성</li><li>toMap으로 하위 Map을 생성</li><li>첫 번째 인자는 Map의 key를 설정하는 Function이다. - Phase to로 선언</li><li>두 번째 인자는 Map의 value를 설정하는 Function이다. - 자기 자신을 참조</li><li>세 번째 인자는 merge-function이다. - 얘는 별 의미없다.</li><li>네 번째 인자는 EnumMap으로 내부 Map을 선언한다.</li></ol><p>따라서 from 메서드에서 Phase별 from~to에 대해 Map -&gt; Map에 접근하여 Transition을 리턴 할 수 있다.</p><h2 id="새로운-phase가-추가되는-경우">새로운 Phase가 추가되는 경우</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Phase &#123;</span><br><span class="line"></span><br><span class="line">    SOLID, LIQUID, GAS, PLASMA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Transition &#123;</span><br><span class="line">        MELT(SOLID, LIQUID),</span><br><span class="line">        FREEZE(LIQUID, SOLID),</span><br><span class="line">        BOIL(LIQUID, GAS),</span><br><span class="line">        CONDENSE(GAS, SOLID),</span><br><span class="line">        SUBLIME(SOLID, GAS),</span><br><span class="line">        DEPOSIT(GAS, SOLID),</span><br><span class="line">        IONIZE(GAS, PLASMA),</span><br><span class="line">        DEIONIZE(PLASMA, GAS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phase from;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phase to;</span><br></pre></td></tr></table></figure></p><p>PLASMA라는 Phase가 추가되어도 Transition에 IONIZE, DEIONIZE를 간단히 추가하여 유연하게 대응이 가능하다.</p><h1 id="요약">요약</h1><ul><li>배열의 인덱스를 얻기 위해 ordinal을 쓰는 것은 일반적으로 좋지 않으니, 대신 EnumMap을 사용하라.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 37. ordinal 인덱싱 대신 EnumMap을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item37/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 36. 비트 필드 대신 EnumSet을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item36/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item36/</guid>
      <pubDate>Mon, 04 Feb 2019 07:27:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;열거한 값들이 주로 단독이 아닌 집합으로 사용 될 경우, 예전에는 각 상수에 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴을 사용해왔다.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>열거한 값들이 주로 단독이 아닌 집합으로 사용 될 경우, 예전에는 각 상수에 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴을 사용해왔다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_BOLD =          <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_ITALIC =        <span class="number">1</span> &lt;&lt; <span class="number">1</span>; <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_UNDERLINE =     <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_STRIKETHROUGH = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">//8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//매개 변수 styles는 0개 이상의 STYLE_ 상수를 비트별 OR 한 값이다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyle</span><span class="params">(<span class="keyword">int</span> styles)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>다음과 같은 식으로 비트별 OR을 사용해 여러 상수를 하나의 집합으로 모을 수 있으며,<br>이렇게 만들어진 집합을 비트 필드(bit field)라고 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.applyStyles(STYLE_BOLD | STYLE_ITALIC); <span class="comment">// 1 | 2 =&gt; 3</span></span><br></pre></td></tr></table></figure></p><p>하지만 비트 필드는 열거 상수의 단점을 그대로 지닌다.</p><ul><li>컴파일 되면 값이 새겨진다 (무슨 의미인지 모름)</li><li>비트 필드 값이 그대로 출력되면 단순한 정수 열거 상수보다 해석하기 어렵다.<br>(어떤 값이 OR연산되서 나온값인지 알기 어렵다.)</li><li>최대 몇 비트가 필요한지 API작성 시 미리 예측이 필요하다.</li></ul><h1 id="비트-필드-대신-enumset을-사용하라">비트 필드 대신 EnumSet을 사용하라</h1><ul><li>java.util 패키지의 EnumSet 클래스는 열거 타입 상수의 값으로 구성된 집합을 효과적으로 표현해준다.</li><li>Set 인터페이스를 완벽히 구현하며, 타입 안전하고 다른 Set 구현체와도 함께 사용할 수 있다.</li><li>EnumSet의 내부는 비트 벡터로 구현되었다.</li><li>원소가 64개 이하인 경우에는 EnumSet 전체를 long 변수 하나로 표현하여 비트 필드에 비견되는 성능을 보여준다.</li><li>removeAll과 retailAll과 같은 대량 작업은 비트를 효율적으로 처리 할 수 있는 산술 연산을 사용하였다.<br>(RegularEnumSet과 JumboEnumSet 클래스를 보면 비트연산을 많이 한다.)</li></ul><h1 id="비트필드를-대체하는-enumset-예제">비트필드를 대체하는 EnumSet 예제</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Style &#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 어떤 Set을 넘겨도 되나 EnumSet이 가장 좋다.</span></span><br><span class="line">    <span class="comment">// 이왕이면 Set Interface로 받는게 좋은 습관이다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(Set&lt;Style&gt; styles)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));</span><br></pre></td></tr></table></figure></p><h1 id="요약">요약</h1><ul><li>열거할 수 있는 타입을 한데 모아 집합 형태로 사용한다고 해도, 비트 필드를 사용할 이유는 없다.</li><li>EnumSet 클래스가 비트 필드 수준의 명료함과 성능을 제공한다.</li><li>EnumSet의 유일한 단점은 불변 객체를 생성할 수 없는 점이다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 36. 비트 필드 대신 EnumSet을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item36/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 35. Ordinal 메서드 대신 인스턴스 필드를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/04/effective-java-item35/</link>
      <guid>https://jaehun2841.github.io/2019/02/04/effective-java-item35/</guid>
      <pubDate>Mon, 04 Feb 2019 07:06:55 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;대부분의 열거 타입 상수는 자연스럽게 하나의 정숫값에 대응된다.&lt;br&gt;
모든 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal이라는 메서드를 제공한다.&lt;/p&gt;
&lt;h1 id=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>대부분의 열거 타입 상수는 자연스럽게 하나의 정숫값에 대응된다.<br>모든 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal이라는 메서드를 제공한다.</p><h1 id="ordinal을-잘못-사용한-예">ordinal을 잘못 사용한 예</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</span><br><span class="line">    SOLO, DUET, TRIO, QUARTET, QUINTET,</span><br><span class="line">    SEXTET, SEPET, OCTET, NONET, DECTET;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ordinal() + <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>상수 선언 순서를 바꾸는 순간 numberOfMusicians 메서드의 기능을 상실하게 된다.<br>상수 순서를 바꾸는 순간 ordinal 값이 바뀌기 때문에 상수의 의미와 실제 뮤지션 숫자와 일치하지 않는다.</p><p>가령, 똑같이 8명인 복4중주(double quartet)은 OCTET이 있기 때문에 추가할 수 도 없다.</p><h1 id="인스턴스-필드를-사용하라">인스턴스 필드를 사용하라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</span><br><span class="line">    SOLO(<span class="number">1</span>), DUET(<span class="number">2</span>), TRIO(<span class="number">3</span>), QUARTET(<span class="number">4</span>), QUINTET(<span class="number">5</span>),</span><br><span class="line">    SEXTET(<span class="number">6</span>), SEPET(<span class="number">7</span>), OCTET(<span class="number">8</span>), DOUBLE_QUARTET(<span class="number">8</span>),</span><br><span class="line">    NONET(<span class="number">9</span>), DECTET(<span class="number">10</span>), TRIPLE_QUARTET(<span class="number">12</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numberOfMusicians;</span><br><span class="line">    Ensemble(<span class="keyword">int</span> numberOfMusicians) &#123;</span><br><span class="line">        <span class="keyword">this</span>.numberOfMusicians = numberOfMusicians;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.numberOfMusicians; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이처럼 인스턴스 필드를 두어 값을 초기화 하여 사용하는 방법으로 사용하는 것이 좋다.</p><h1 id="ordinal은-언제-사용하나">ordinal은 언제 사용하나?</h1><blockquote><p>The ordinal of this enumeration constant<br>(its position in the enum declaration, where the initial constant is assigned an ordinal of zero).<br>Most programmers will have no use for this field.<br>It is designed for use by sophisticated enum-based data structures,<br>such as {@link java.util.EnumSet} and {@link java.util.EnumMap}.</p></blockquote><p>ordinal은 enum타입의 상수 값이다. (상수의 위치값)<br>대부분의 프로그래머는 이 값이 필요는 없다.<br>이 값은 EnumSet이나 EnumMap 같은 열거 타입 기반의 범용 자료구조에 사용 될 목적으로 만들어졌다.<br><strong>결론: 사용하지 말자</strong></p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 35. ordinal 메서드 대신 인스턴스 필드를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/04/effective-java-item35/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 34. Int 상수 대신 열거 타입을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/03/effective-java-item34/</link>
      <guid>https://jaehun2841.github.io/2019/02/03/effective-java-item34/</guid>
      <pubDate>Sun, 03 Feb 2019 08:25:27 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바에서는 상수(Costants)라는 개념이 있다.&lt;br&gt;
변하지 않는 값을 공통적으로 선언하고 한 군데에서 관리하고자 사용한다.&lt;br&gt;
Java 1.5 버전부터 enum (enumeration) 타입을 제공하
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바에서는 상수(Costants)라는 개념이 있다.<br>변하지 않는 값을 공통적으로 선언하고 한 군데에서 관리하고자 사용한다.<br>Java 1.5 버전부터 enum (enumeration) 타입을 제공하였고, C/C++에서 처럼 단순한 정수값을 제공하는 수준을 넘어<br>완전한 형태의 클래스의 역할을 수행 하는 강력한 기능을 제공한다.</p><h1 id="정수-열거-패턴int-enum-pattern의-단점">정수 열거 패턴(int enum pattern)의 단점</h1><h2 id="타입-safe하지-않다">타입 safe하지 않다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_FUJI = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_PIPPIN = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_GRANNY_SMITH = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORANGE_NAVEL = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORANGE_TEMPLE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORANGE_BLOOD = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>정수 열거 패턴은 위와 같이 선언하고 사용된다.<br>자바는 정수 열거 패턴을 위한 별도의 namespace를 지원하지 않기 때문에 어쩔수 없이 접두어를 사용해서 이름 충돌을 방지한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPLE_FUJI == ORANGE_NAVEL;</span><br></pre></td></tr></table></figure></p><p>위에 대한 결과는 true가 되기 때문에 type safe 하지 않으며, 표현력도 좋지 않다.</p><h2 id="정수-열거-패턴을-사용한-프로그램은-깨지기-쉽다">정수 열거 패턴을 사용한 프로그램은 깨지기 쉽다.</h2><p>평범한 상수를 나열한 것뿐이라, 컴파일 하면 그 값이 클라이언트 파일에 그대로 새겨진다.<br>따라서 상수의 값이 바뀌면 클라리언트도 반드시 다시 컴파일 해야 한다.<br><code>다시 컴파일 하지 않은 클라이언트는 실행이 되더라도 엉뚱하게 동작할 수 있다.</code></p><p><img src="./constants-code.png" alt="constants-code"></p><p><img src="./compiled-constants-code.png" alt="compiled-constants-code"></p><p>compile 이후에는 상수에 대한 namespace정보가 없기 때문에 단순히 상수 값만 찍히게 된다.</p><h2 id="정수-상수는-문자열로-출력하기-까다롭다">정수 상수는 문자열로 출력하기 까다롭다.</h2><p>그 값을 출력하거나 디버거로 살펴보면 (의미가 아닌) 단지 숫자로만 보여서 썩 도움이 되지 않는다.<br>(APPLE_FUJI나, ORANGE_NAVEL 같은 의미를 출력하기 어렵다는 의미)<br>같은 정수 열거 그룹에 속한 모든 상수를 한 바퀴 순회하는 방법도 마땅치 않다.<br>(enum은 values()메서드를 통해 상수를 배열 형태로 제공한다.)</p><h2 id="문자열-열거-패턴은-더-나쁘다">문자열 열거 패턴은 더 나쁘다.</h2><p>상수의 의미를 출력할 수 있다는 점은 좋지만, 문자열 상수의 이름 대신 문자열 값을 그대로 하드코딩하게 만들기 때문이다.<br>하드코딩한 문자열에 오타가 있어도 컴파일러는 확인할 길이 없으니, 자연스럽게 런타임 버그가 생긴다.<br>문자열 비교에 따른 성능 저하 역시 당연한 결과다.</p><h1 id="java의-열거-타입">Java의 열거 타입</h1><p>자바의 열거(enum) 타입은 완전한 형태의 <code>클래스(class)</code> 이다.<br>Java에서는 Enum.java라는 abstract클래스를 Java 1.5 부터 제공하고 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the common base class of all Java language enumeration types.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * More information about enums, including descriptions of the</span></span><br><span class="line"><span class="comment"> * implicitly declared methods synthesized by the compiler, can be</span></span><br><span class="line"><span class="comment"> * found in section 8.9 of</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Note that when using an enumeration type as the type of a set</span></span><br><span class="line"><span class="comment"> * or as the type of the keys in a map, specialized and efficient</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> java.util.EnumSet set&#125; and &#123;<span class="doctag">@linkplain</span></span></span><br><span class="line"><span class="comment"> * java.util.EnumMap map&#125; implementations are available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; The enum type subclass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Josh Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Neal Gafter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Class#getEnumConstants()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.util.EnumSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.util.EnumMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>) <span class="comment">// No serialVersionUID needed due to</span></span><br><span class="line">                            <span class="comment">// special-casing of enum types.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure></p><p>C/C++와 같이 다른 언어에서처럼 단순히 정수값만 지원하는 것이 아니라, 하나의 클래스로써의 역할을 수행해 강력한 기능을 제공한다.</p><h2 id="열거enum-타입의-특징">열거(enum) 타입의 특징</h2><ul><li>열거 타입 자체는 클래스(class)이다.</li><li>상수 하나당 자신의 인스턴스를 하나씩 만들어(Singleton) public static final 필드로 공개한다.</li><li>열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로, 사실상 final이다.<br>(따라서 열거 타입 내 필드도 final이다.)</li></ul><h2 id="타입-safe하다">타입 safe하다.</h2><p>열거 타입은 타입 안전성을 제공한다.위의 APPLE과 ORANGE의 상수 형태를 enum으로 변경한 뒤 다시 테스트 해보자<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Apple &#123;FUJI, PIPPIN, GRANNY_SMITH&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Orange &#123;NAVEL, TEMPLE, BLOOD&#125;</span><br></pre></td></tr></table></figure></p><p><img src="./enum-test.png" alt="enum-test"></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(24, 33) java: incomparable types: com.study.effectivejavatest.item34.Apple and com.study.effectivejavatest.item34.Orange</span><br></pre></td></tr></table></figure></p><p>컴파일 시, 위와 같은 에러가 발생한다.<br>Apple.FUJI와 Orange.NAVEL은 비교를 할 수 없는 타입이라는 내용이다.<br>다른 열거 타입의 값끼리 == 연산자로 비교하려는 꼴이기 때문이다.</p><h2 id="각자의-namespace가-있다">각자의 namespace가 있다.</h2><p>열거타입은 각자의 namespace가 있어서 이름이 같은 상수도 평화롭게 공존한다.<br>열거 타입에 새로운 상수를 추가하거나, 순서를 바꿔도 다시 컴파일 하지 않아도 된다.<br>공개 되는 것이 오직 필드의 이름 뿐이라, 컴파일 시, 클라이언트의 코드에 정수 값이 각인되지 않기 때문이다.</p><p><img src="./compiled-constants-code2.png" alt="compiled-constants-code2"></p><h1 id="데이터와-메서드를-갖는-열거-타입">데이터와 메서드를 갖는 열거 타입</h1><p>열거 타입은 메서드와 필드를 추가 할 수 있다.<br>각 상수 별로 데이터를 가질 수 있고, enum에서 공통적으로 사용하는 메서드를 선언하거나 상수 별로 메서드를 재정의 할 수 있다.<br>단순하게는 상수 모음이지만, 실제로는 클래스이기 때문에 고차원의 추상 개념 하나를 완벽히 표현해낼 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Planet &#123;</span><br><span class="line">    MERCURY(<span class="number">3.302e+23</span>, <span class="number">2.439e6</span>),</span><br><span class="line">    VENUS(<span class="number">4.869e+24</span>, <span class="number">6.052e6</span>),</span><br><span class="line">    EARTH(<span class="number">5.975e+24</span>, <span class="number">6.378e6</span>),</span><br><span class="line">    MARS(<span class="number">6.419e+23</span>, <span class="number">3.393e6</span>),</span><br><span class="line">    JUPITER(<span class="number">1.899e+27</span>, <span class="number">7.149e7</span>),</span><br><span class="line">    SATURN(<span class="number">5.685e+26</span>, <span class="number">6.027e7</span>),</span><br><span class="line">    URANUS(<span class="number">8.683e+25</span>, <span class="number">2.556e7</span>),</span><br><span class="line">    NEPTUNE(<span class="number">1.024e+26</span>, <span class="number">2.447e7</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> mass;            <span class="comment">// 질량(단위: 킬로그램)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> radius;          <span class="comment">// 반지름(단위: 미터)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> surfaceGravity;  <span class="comment">// 표면중력(단위: m / s^2)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 중력상수 (단위: m^3 / kg s^2)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> G = <span class="number">6.67300E-11</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생성자</span></span><br><span class="line">    Planet(<span class="keyword">double</span> mass, <span class="keyword">double</span> radius) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mass = mass;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        <span class="keyword">this</span>.surfaceGravity = G * mass / (radius * radius);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">surfaceWeight</span><span class="params">(<span class="keyword">double</span> mass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mass * surfaceGravity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 Planet의 예시를 보면, 행성별 상수는 각각 질량과 반지름을 필드로 가지고 있다.<br>그리고 표면중력에 대한 값을 계산해 주는 surfaceWeight라는 메서드를 공통으로 사용하고 있다.</p><ul><li>열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.</li><li>열거 타입은 외부로의 생성자를 제공하지 않기 때문에 불변 객체이다.</li><li>모든 필드는 final이다.</li><li>필드를 public으로 선언해도 되지만, private로 선언 후 접근자 메서드를 제공하는 것이 좋다.</li></ul><h1 id="상수별-메서드-구현">상수별 메서드 구현</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">    PLUS, MINUS, TIMES, DIVIDE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같은 사칙 연산 열거타입이 있을 때, 사칙연산에 대한 로직을 열거 타입 내에 작성하고 싶을 때가 있다.<br>여러가지 방법을 통해 구현해 보도록 하겠다.</p><h2 id="switch-case을-이용한-구현">switch-case을 이용한 구현</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> PLUS: <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">case</span> MINUS: <span class="keyword">return</span> x - y;</span><br><span class="line">        <span class="keyword">case</span> TIMES: <span class="keyword">return</span> x * y;</span><br><span class="line">        <span class="keyword">case</span> DIVIDE: <span class="keyword">return</span> x / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"알 수 없는 연산: "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이런 경우에는 메서드 하나에 연산을 모아 볼 수 있는 장점은 있다.<br>하지만 상수가 추가 되는 경우, 실수로 case를 추가 하지 않으면, <code>알 수 없는 연산</code>이라는 예외가 발생하게 된다.</p><h2 id="abstract-method를-이용한-구현">abstract method를 이용한 구현</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">    PLUS&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    MINUS&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    TIMES&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x * y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    DIVIDE&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x / y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 선언하면 상수가 추가 될 때마다 apply 메서드를 재정의 해줘야 한다.</p><h2 id="funtional-interface를-이용한-구현">Funtional Interface를 이용한 구현</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">    PLUS((x, y) -&gt; x + y),</span><br><span class="line">    MINUS((x, y) -&gt; x - y),</span><br><span class="line">    TIMES((x, y) -&gt; x * y),</span><br><span class="line">    DIVIDE((x, y) -&gt; x / y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> BiFunction&lt;Double, Double, Double&gt; operationFuntion;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java 8에서 제공하는 BiFuntion 을 이용해 람다식을 이용하여 로직을 구현 할 수 있다.</p><h2 id="편한-계산식-출력">편한 계산식 출력</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = Double.parseDouble(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">double</span> y = Double.parseDouble(args[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Operation op : Operation.values()) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"%f %s %f = %f%n"</span>, x, op, y, op.apply(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.000000 + 4.000000 = 6.000000</span><br><span class="line">2.000000 - 4.000000 = -2.000000</span><br><span class="line">2.000000 * 4.000000 = 8.000000</span><br><span class="line">2.000000 / 4.000000 = 0.500000</span><br></pre></td></tr></table></figure></p><h1 id="전략적-열거-타입-패턴">전략적 열거 타입 패턴</h1><p>상수별 메서드 구현에는 열거 타입 상수끼리 코드를 공유하기 어렵다는 단점이 있다.<br>아래 예시는 요일별로 일당을 계산해 주는 열거타입 메서드이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> PayrollDay &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINS_PER_SHIFT = <span class="number">8</span> * <span class="number">60</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> basePay = minutesWorked * payRate;</span><br><span class="line">        <span class="keyword">int</span> overtimePay;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> SATURDAY:</span><br><span class="line">            <span class="keyword">case</span> SUNDAY:</span><br><span class="line">                overtimePay = basePay / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                overtimePay = minutesWorked &lt;= MINS_PER_SHIFT ? <span class="number">0</span> : </span><br><span class="line">                (minutesWorked - MINS_PER_SHIFT) * payRate / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> basePay + overtimePay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>간결하지만, 관리 관점에서는 위험한 코드이다.<br>공휴일과 같은 새로운 값을 열거타입에 추가하려면 그 값을 처리하는 case문을 잊지말고 추가해 줘야 한다.<br>상수별 메서드 구현으로 급여를 정확히 계산하는 방법은 두 가지다.</p><ol><li>잔업수당을 계산하는 코드를 모든 상수에 중복해서 넣는다.</li><li>평일용/주말용으로 나눠 각각 도우미 메서드를 생성한다음 각 상수가 자신에게 필요한 메서드를 적절히 호출한다.</li></ol><p>1번으로 로직을 구성할 경우 case 구문을 사용할 때와 동일한 문제가 발생한다.<br>가장 깔끔한 방법은 새로운 상수를 추가할 때, 잔업 수당에 대한 <code>전략</code>을 선택하게 하는 방법이다.</p><h2 id="잔업-수당-전략-선택하기">잔업 수당 전략 선택하기</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> PayrollDay &#123;</span><br><span class="line">    MONDAY(WEEKDAY),</span><br><span class="line">    TUESDAY(WEEKDAY),</span><br><span class="line">    WEDNESDAY(WEEKDAY),</span><br><span class="line">    THURSDAY(WEEKDAY),</span><br><span class="line">    FRIDAY(WEEKDAY),</span><br><span class="line">    SATURDAY(WEEKEND),</span><br><span class="line">    SUNDAY(WEEKEND);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayType payType;</span><br><span class="line">    </span><br><span class="line">    PayrollDay(PayType payType) &#123;</span><br><span class="line">        <span class="keyword">this</span>.payType = payType;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> payType.pay(minutesWorked, payRate);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> PayType &#123;</span><br><span class="line">        WEEKDAY &#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> minutesWorked &lt;= MINS_PER_SHIFT ? <span class="number">0</span> : (minutesWorked - MINS_PER_SHIFT) * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        WEEKEND &#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> minutesWorked * payRate / <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span></span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINS_PER_SHIFT = <span class="number">8</span> * <span class="number">60</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> basePay = minutesWorked &amp; payRate;</span><br><span class="line">            <span class="keyword">return</span> basePay + overtimePay(minutesWorked, payRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 코드를 변경하니 깔끔하게 되었다.switch문은 열거 타입의 상수별 동작을 구현하는데 적합하지 않다.<br>하지만 기존의 열거 타입의 상수별 동작을 혼합해 넣을 때에는 switch문이 좋은 선택이 될 수 있다.<br>(최소한으로 코드를 변경하기 때문)</p><h1 id="요약">요약</h1><ul><li><p>필요한 원소를 컴파일타입에 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자</p></li><li><p>int 상수 대신 열거 타입으로 정의하라</p></li><li><p>각 상수와 특정 데이터를 연결 짓거나, 상수마다 다른 action이 필요한 경우 열거 타입이 효과적이다.</p></li><li><p>switch문으로 분기하여 로직을 구성하기 보다는 전략 열거타입 패턴을 사용하여 로직을 구현하라.</p></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 34. int 상수 대신 열거 타입을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/03/effective-java-item34/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라</title>
      <link>https://jaehun2841.github.io/2019/01/28/effective-java-item32/</link>
      <guid>https://jaehun2841.github.io/2019/01/28/effective-java-item32/</guid>
      <pubDate>Mon, 28 Jan 2019 10:27:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;가변인수(varargs) 메서드와 제네릭은 Java 5버전에 함께 추가되었다.&lt;br&gt;
서로 잘 어우러지리라 생각하겠지만, 그렇지 않다. 가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>가변인수(varargs) 메서드와 제네릭은 Java 5버전에 함께 추가되었다.<br>서로 잘 어우러지리라 생각하겠지만, 그렇지 않다. 가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는데, 구현방식에 헛점이 있다.<br>가변인수 메서드를 호출하면, 가변인수를 담기 위한 배열이 자동으로 하나 만들어진다.<br>그 결과 varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생한다.</p><p>실제화 불가 타입은 런타임에는 컴파일타임보다 타입관련 정보를 적게 담고 있다<code>(소거)</code></p><h1 id="제네릭과-varargs를-혼용하면-타입-안정성이-깨진다">제네릭과 varargs를 혼용하면 타입 안정성이 깨진다.</h1><p>매개변수화 타입(Parameterize Type (예 List&lt;String&gt;))의 변수가 타입이 다른 객체를 참조하면 <strong>힙 오염</strong>이 발생한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dangerous</span><span class="params">(List&lt;String&gt;... stringLists)</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; intList = List.of(<span class="number">42</span>);</span><br><span class="line">  <span class="comment">//varargs는 내부적으로 배열이고</span></span><br><span class="line">  <span class="comment">//배열은 공변이기 때문에 List&lt;String&gt;타입은 Object의 하위클래스로 인식되어</span></span><br><span class="line">  <span class="comment">//Object[]에 참조 될 수 있다.</span></span><br><span class="line">  Object[] objects = stringLists;</span><br><span class="line">  Object[<span class="number">0</span>] = intList; <span class="comment">//힙 오염 발생</span></span><br><span class="line">  String s = stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// ClassCastException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드를 한줄한줄 분석해보자</p><ol><li>List&lt;String&gt; varargs형태의 파라미터를 받는 메서드이다.</li><li>List&lt;Integer&gt; 제네릭타입 객체를 생성하여 42라는 값을 추가하였다.</li><li>varargs는 내부적으로 배열이고, 배열은 공변이기 때문에 List&lt;String&gt;[] -&gt; Object[]에 참조될 수 있다.</li><li>Object[0] = intList 초기화<br>(내부적으로는 List&lt;String&gt; 타입이지만, 런타임에는 제네릭 타입이 소거되므로 같은 List로만 인식되어 할당이 가능하다. <strong>힙 오염 발생</strong>)</li><li>stringList[0]을 하면 List가 나오고 List의 0번째 인덱스 위치의 객체를 호출해 눈에 보이지 않는 String으로 형변환한다.<br>-&gt; 여기서 ClassCastException이 발생</li></ol><p>이처럼 타입안정성이 깨지기 때문에 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다.<br>(실제로 실무에서는 저런 경우는 거의 없다. 웬만하면 varargs 형태로 받아와서 그대로 사용하기 때문)</p><h1 id="safevarargs">@SafeVarargs</h1><p>자바 7 전에는 제네릭 가변인수 메서드의 작성자가 호출자 쪽에서 발생하는 경고에 대해서 해줄 수 있는 일이 없었다.<br>사용자는 이 경고를 그냥 무시하거나, 사용하는 메서드에서 @SupprssWarning(&quot;unchecked&quot;) annotation을 달아 경고를 숨겨야 했다.<br>자바 7부터 @SafeVarargs annotation이 추가되어 제네릭 가변인수 메서드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있게 되었다.</p><p>단, @SafeVarargs annotation은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치이므로<br>반드시 메서드가 타입 안전한 경우에만 이 annotation을 붙이는 것이 좋다.</p><h2 id="어떤게-타입-안전할까">어떤게 타입 안전할까?</h2><ul><li>가변인수 메서드를 호출하면 varargs 매개변수를 담는 제네릭 배열이 만들어 진다.</li><li>메서드 내에서 이 배열에 아무것도 저장하지 않고, 배열의 참조가 밖으로 노출되지 않는다면 타입 안전하다.</li><li>순수하게 메서드의 생산자 역할만 충실히 하면 메서드는 안전하다.</li></ul><h2 id="자신의-제네릭-매개변수-배열의-참조를-노출하는-것은-위험하다">자신의 제네릭 매개변수 배열의 참조를 노출하는 것은 위험하다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T[] toArray(T... args) &#123;</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T[] pickTwo(T a, T b, T c) &#123;</span><br><span class="line">  <span class="keyword">switch</span>(ThreadLocalRandom.current().nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> toArray(a, b);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> toArray(b, c);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> toArray(c, a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> AssertiionError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  String[] attributes = pickTwo(<span class="string">"좋은"</span>, <span class="string">"빠른"</span>, <span class="string">"저렴한"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>아무 문제가 없는 메서드이니 별다른 문제없이 컴파일 된다.<br>하지만 실행하면 ClassCastException을 던진다.<br>어디서 발생하는 에러일까?</p><p>정답은 바로 String[] attributes = pickTwo(); 메서드에서 보이지 않는 형변환 시 발생한다.</p><p>실제로는 아래와 같다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] attributes = (String[]) pickTwo(<span class="string">"좋은"</span>, <span class="string">"빠른"</span>, <span class="string">"저렴한"</span>);</span><br></pre></td></tr></table></figure></p><p>Object[]는 String[]의 <code>하위타입</code>이 아니므로 형변환할 수 없다. (다운캐스팅 불가)<br>이 예시는 <strong>제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다.</strong> 를 다시금 알려주는 예제이다.</p><p>단 예외가 두 가지 있다.</p><ul><li>@SafeVarargs로 선언된 타입 안전성이 보장된 또 다른 varargs 메서드에 넘기는 것은 안전하다.</li><li>배열 내용의 일부 함수를 호출만 하는 (varargs를 받지않는) 일반 메서드에 넘기는 것도 안전하다.</li></ul><h1 id="제네릭-varargs-매개변수를-안전하게-사용하는-메서드">제네릭 varargs 매개변수를 안전하게 사용하는 메서드</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">flatten</span><span class="params">(List&lt;? extends T&gt;... lists)</span> </span>&#123;</span><br><span class="line">  List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span>(List&lt;? extends T&gt; list : lists) &#123;</span><br><span class="line">    result.addAll(list);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 메서드는 안전하다.<br>varargs 배열을 직접 노출 시키지 않고, T타입의 제네릭 타입을 사용하였기 때문에 ClassCastException 또한 발생할 일이 없다.<br>안전한 varargs 메서드에는 @SafeVarargs annotation을 달아서 컴파일러 경고를 없애는 것이 좋다.</p><h1 id="제네릭-varargs-매개변수를-list로-대체하라">제네릭 varargs 매개변수를 List로 대체하라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">flatten</span><span class="params">(List&lt;List&lt;? extends T&gt;&gt; lists)</span> </span>&#123;</span><br><span class="line">  List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (List&lt;? extends T&gt; list : lists) &#123;</span><br><span class="line">    result.addAll(list);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 방식의 장점은 이 메서드의 타입 안전성을 검증할 수 있다는 점이다.<br>@SafeVarargs를 달지 않아도 되며 실수로 안전하다고 판단할 걱정도 없다.<br>단점은 클라이언트 코드가 살짝 지저분해지고, 속도가 약간 느려질 수 있다는 점이다.</p><h1 id="정리">정리</h1><ul><li>varargs 매개변수는 단순히 파라미터를 받아와 메서드의 생산자(T 타입의 객체를 제공하는 용도)로만 사용하자</li><li>varargs는 read-only라고 생각하고, 아무런 데이터를 저장하지 말자</li><li>varargs 배열을 외부에 리턴하거나 노출하지 말자.<br>웬만하면 다시 컬렉션(List)에 담아 리턴하는 안전한 방식을 취하자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/28/effective-java-item32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 31. 한정적 와일드 카드(Bounded Wildcard Type)를 사용해 API 유연성을 높여라</title>
      <link>https://jaehun2841.github.io/2019/01/26/effective-java-item31/</link>
      <guid>https://jaehun2841.github.io/2019/01/26/effective-java-item31/</guid>
      <pubDate>Sat, 26 Jan 2019 12:16:50 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Generic에서 매개변수화 타입(Parameterize Type - List&amp;lt;String&amp;gt;)는 불공변이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;공변 vs 불공변
Java에서 배열은 공변(varian
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Generic에서 매개변수화 타입(Parameterize Type - List&lt;String&gt;)는 불공변이다.</p><blockquote><p>공변 vs 불공변Java에서 배열은 공변(variant), Generic은 불공변(invariant)이라 한다.<br>배열의 경우 Object[]과 String[] 간에는 부모-자식 클래스 관계가 성립한다. 이를 공변이라한다.<br>하지만 Generic에서는 List&lt;Object&gt;와 List&lt;String&gt;은 부모-자식 관계가 성립하지 않는다 이를 불공변이라한다.</p></blockquote><p>즉, List&lt;String&gt;은 String타입의 문자열만 넣을 수 있지만, List&lt;Object&gt;는 문자열이건, 숫자건 다 넣을 수 있으므로, 부모클래스에서 가능한 일은 자식클래스에서도 가능해야 한다는 <strong>리스코프 치환원칙</strong>에 위배된다.</p><p>하지만 때로는 불공변 방식보다 유연한 무언가가 필요하다.</p><h1 id="생산자producer-와일드카드-적용">생산자(producer) 와일드카드 적용</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; integers = List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">numberStack.pushAll(integers);</span><br></pre></td></tr></table></figure></p><p>Integer는 Number의 하위타입이기 때문에 잘 동작할 것 같지만, 실제로는 컴파일 시에 오류가 발생한다.</p><p>Parameterize Type이 불공변이기 때문에 Iterator&lt;Number&gt;와 Iterator&lt;Integer&gt;는 부모-자식 관계가 아니다.<br>그렇기 때문에 addAll 메서드의 파라미터로 사용할 수 없는 것이다.</p><p>이런 경우 생산자(producer) 파라미터에 와일드카드 타입을 적용하여 유연하게 만들 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterator&lt;? extends E&gt; iterator)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (E e : iterator) &#123;</span><br><span class="line">    push(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>생산자(producer) 파라미터란, 파라미터로 제공되어 메서드 내에서 사용 될 객체를 공급해 주는 파라미터이다.</p><p><code>&lt;? extends E&gt;</code> 형태로 사용하는 경우 E 타입의 하위타입만 파라미터로 올 수 있게 제약을 거는 것이다.<br><code>모든 타입은 자기 자신의 하위타입이다!</code> 라는 규칙이 있으므로 자기 자신에 대한 타입도 들어올 수 있다.</p><h1 id="소비자consumer-와일드카드-적용">소비자(consumer) 와일드카드 적용</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;E&gt; dst)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!isEmpty()) &#123;</span><br><span class="line">    dst.add(pop());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Collection&lt;Object&gt; objects = List.of(<span class="number">1</span>, <span class="string">"String"</span>);</span><br><span class="line">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure></p><p>컴파일 하게되면 Collection&lt;Object&gt;는 Collection&lt;Number&gt;의 하위타입이 아니다라는 오류가 나온다.<br>이를 해결하기 위해서는 super를 이용해 와일드카드를 작성해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; dst)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!isEmpty()) &#123;</span><br><span class="line">    dst.add(pop());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>소비자(consumer) 파라미터란, 메서드에 제공되어 메서드 내에서 제공되는 객체를 자기 자신이 사용하는 파라미터를 의미한다.</p><h1 id="pecsproducer-extends-consumer-super">PECS(Producer-Extends, Consumer-Super)</h1><p>다음 공식을 외워 어떤 와일드 카드 타입을 쓸지 기억하자</p><ul><li>생산자(producer) - Generic 클래스 내에 타입 파라미터를 이용해 객체를 제공하는 것<ul><li>&lt;? extends E&gt;를 사용하여 유연성을 높일 수 있다.</li></ul></li><li>소비자(consumer) - Generic 클래스 내의 자원을 사용하는 객체를 파라미터로 전달하는 것<ul><li>&lt;? super E&gt;를 사용하여 유연성을 높일 수 있다.</li><li>Comparable, Comparator는 소비자로 사용된다.</li></ul></li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; integers = Set.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Set&lt;Double&gt; doubles = Set.of(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line">Set&lt;Number&gt; numbers = union(integers, doubles);</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</span><br><span class="line">  Set&lt;E&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  set.addAll(integers);</span><br><span class="line">  set.addAll(doubles);</span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 메서드가 만들어지면 타입이 맞지 않는다고 컴파일 오류가 나게 된다.<br>Set&lt;E&gt;은 불공변이기 때문에 Set&lt;Integer&gt;와 Set&lt;Double&gt;은 Set&lt;Number&gt;의 하위타입이 아니기 떄문이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2)</span> </span>&#123;</span><br><span class="line">  Set&lt;E&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  set.addAll(integers);</span><br><span class="line">  set.addAll(doubles);</span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 변경하면 컴파일 오류도 해결되고 잘 실행 된다.이렇게 공통 API를 작성할 때는 와일드 카드를 적절하게 쓰도록 하자.<br>클래스 사용자가 와일드카드 타입을 신경써야 한다면, 그 API에 문제가 있을 가능성이 크다.</p><h2 id="java7에서는">Java7에서는...</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);</span><br></pre></td></tr></table></figure></p><p>위와 같은 형태로 명시적으로 타입인수를 사용해야 한다.<br>타입추론능력이 부족하기 때문이다.</p><h1 id="심화-comparable">심화 - Comparable</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">E <span class="title">max</span><span class="params">(List&lt;E&gt; list)</span></span></span><br></pre></td></tr></table></figure></p><p>와일드카드를 통해 좀 더 다듬은 모습이다.<br><strong>주의: Comparable을 구현한 클래스만 파라미터로 올 수 있다</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function">E <span class="title">ma</span><span class="params">(List&lt;? extends E&gt; list)</span> </span>&#123;</span><br><span class="line">           list.sort(Comparator.reverseOrder());</span><br><span class="line">           <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><ul><li>일반적으로는 Comparable&lt;E&gt;보단 Comparable&lt;? super E&gt;를 사용하는게 낫다. (대부분 소비자로 사용)</li></ul><h1 id="심화2-와일드카드를-적절히-사용하라">심화2 - 와일드카드를 적절히 사용하라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure></p><p>리스트 내의 특정 인자들의 위치를 뒤바꿔주는 메서드이다.<br>어느 메서드가 더 좋을까?</p><p>기본적으로는 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하는 것이 좋다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드는 list.get하는 부분에서 컴파일 오류가 난다.비한정적 와일드카드를 사용하고 있기 때문에 list.set을 하는 경우에는 null밖에 넣을 수가 없다.<br>이런 경우 도우미 메서드를 따로 이용한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 경우에는 List&lt;E&gt;의 리턴타입이 항상 E인 것을 알기 때문에<br>런타임 시, 타입안정성을 보장 할 수 있고 set하는 경우에도 E 타입을 set할 것을 알기 때문에 컴파일 오류 없이 작동 한다.</p><h1 id="정리">정리</h1><p>조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다.<br>그러나 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해야 한다.<br>PECS 공식을 기억하여 생산자에는 extends, 소비자에는 super를 사용하자.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 31. 한정적 와일드 카드(bounded wildcard type)를 사용해 API 유연성을 높여라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/26/effective-java-item31/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 17. 변경 가능성을 최소화하라</title>
      <link>https://jaehun2841.github.io/2019/01/20/effective-java-item17/</link>
      <guid>https://jaehun2841.github.io/2019/01/20/effective-java-item17/</guid>
      <pubDate>Sun, 20 Jan 2019 08:53:58 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;불변-클래스immutable-class란&quot;&gt;불변 클래스(immutable class)란?&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다.&lt;/li&gt;
&lt;li&gt;불변 클래스의 인스턴스는 객체가 생성되는 시점에 초
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="불변-클래스immutable-class란">불변 클래스(immutable class)란?</h1><ul><li>인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다.</li><li>불변 클래스의 인스턴스는 객체가 생성되는 시점에 초기화되고 소멸이 될 때까지 값이 변경되지 않는다.</li><li>불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉽다.</li><li>값이 변경되지 않으니 오류가 발생할 일도 적고 안전하다.</li></ul><h1 id="불변-클래스를-만들기-위한-5가지-조건">불변 클래스를 만들기 위한 5가지 조건</h1><h2 id="객체의-상태를-변경하는-메서드변경자를-제공하지-않는다">객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.</h2><ul><li>쉽게 말해 setter나, 필드 정보를 변경하는 메서드를 제공하지 않는다.</li></ul><h2 id="클래스를-확장-할-수-없도록-한다">클래스를 확장 할 수 없도록 한다.</h2><ul><li>클래스를 final로 선언한다.</li><li>모든 생성자는 private으로 만들고 생성자 정적 팩터리 메서드를 제공한다.</li><li>정적 팩터리 메서드는 유연성을 제공한다.</li><li>다음 릴리즈에서 Boolean처럼 <code>캐싱</code>을 이용해 성능을 끌어올릴 수도 있다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class="line"><span class="meta">@AllArgsConstructor</span>(access = AccessLevel.PRIVATE, staticName=<span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="모든-필드를-final로-선언한다">모든 필드를 final로 선언한다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span>(access = AccessLevel.PRIVATE, staticName=<span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>필드에 대해 수정을 막겠다는 설계자의 의도를 보여준다. - final클래스는 생성자에서 딱 <code>1회 초기화</code> 할 수 있기 때문이다.</li><li>인스턴스에 대한 동기화(syncronized)처리 없이도 다른 스레드에서 문제없이 처리 된다.</li></ul><h2 id="모든-필드를-private로-선언한다">모든 필드를 private로 선언한다.</h2><ul><li>필드가 참조하는 가변 객체를 클라이언트에서 직접 접근하여 수정하는 일을 막는다.</li><li>public final로만 처리해도 되지만, 그 안의 내용을 바꿀 수 있고 다 릴리즈에서 내부 표현을 변경하지 못하므로 사용하지 않는게 좋다.</li></ul><h2 id="자신객체-이외에는-내부의-가변-컴포넌트에-접근-할-수-없도록-한다">자신(객체) 이외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.</h2><ul><li>클라이언트에서 인스턴스 내에 가변 객체의 참조를 얻을 수 없게 해야한다. - Collection에 대한 getter를 제공하면 안된다!</li><li>생성자, 접근자(getter), readObject 메서드에서 모두 <code>방어적 복사</code>를 수행해야 한다.</li></ul><h1 id="함수형-프로그래밍">함수형 프로그래밍</h1><ul><li>피연산자에 함수를 적용해 결과를 반환하는 프로그래밍 기법</li><li>피연산자에 대해 연산하지만 피연산자는 값이 변하지 않음(캡처 - 피연산자는 사실상 final)</li><li>코드의 불변이 영역이 되는 비율이 높아져 안전하다.</li></ul><h1 id="불변-객체의-장점">불변 객체의 장점</h1><ul><li>불변 객체는 생성 시점부터 소멸될 때 까지 변하지 않는다. - 서비스 로직에 더 안전하다.</li><li>불변 객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요가 없다. - 스레드에 따라 값이 변하지 않기 때문이다.</li><li>불변 객체는 안심하고 공유 할 수 있다. - 불변 클래스라면 최대한 재사용 하라 (캐싱)</li><li>불변 객체는 방어적 복사본이 필요없다 - 바뀌지 않으므로 방어할 일이 없다.</li><li>불변 객체는 clone메서드를 제공하지 않는게 좋다. - 의미가 없다.</li><li>불변 객체를 key로 하면 이점이 많다.<ul><li>Map의 key</li><li>Set의 원소</li></ul></li><li>불변 객체는 그 자체로 실패 원자성을 제공한다.<ul><li>메서드에서 예외가 발생하더라도 객체의 변경내용이 없다.</li></ul></li><li>불변 객체끼리는 자유롭게 내부 데이터를 공유 할 수 있다.<ul><li>BigInteger 클래스에서 mag는 크기를 나타내는 배열</li><li>signum은 부호를 나타내는 int 필드</li><li>mag는 배열이지만 불변이므로 방어적 복사본을 만들지 않고 원래 객체의 mag를 써도 된다.</li></ul></li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a BigInteger whose value is &#123;<span class="doctag">@code</span> (-this)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> -this&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(<span class="keyword">this</span>.mag, -<span class="keyword">this</span>.signum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>불변 객체는 값이 다르면 반드시 독립된 객체로 만들어야 한다.</li></ul><h1 id="요약">요약</h1><ul><li>접근자(getter)를 제공한다고 습관처럼 수정자(setter)를 만들지 말자<ul><li>꼭 필요한 경우가 아니라면 클래스는 불변이어야 한다.</li><li>장점이 훨씬많고, 단점이라면 잠재적 성능저하 뿐이다.</li></ul></li><li>불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한 줄이자<ul><li>객체가 가질 수 있는 상태를 제한하면, 예외를 예측하기 쉽고, 오류가 생길 가능성이 줄어든다.</li><li>꼭 변경할 필드가 아닌 필드는 final로 선언하자 - 웬만하면 final로 해야한다.</li></ul></li><li>생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.<ul><li>확실한 이유가 없다면, 생성자와 정적팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안된다.</li><li>특히! 객체를 재활용할 목적으로 상태를 다시 초기화 하는 메서드도 안된다.</li><li>복잡성만 커지고 성능 이점은 거의 없다.</li></ul></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 17. 변경 가능성을 최소화하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/20/effective-java-item17/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/01/20/effective-java-item16/</link>
      <guid>https://jaehun2841.github.io/2019/01/20/effective-java-item16/</guid>
      <pubDate>Sun, 20 Jan 2019 08:53:54 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;퇴보한-클래스&quot;&gt;퇴보한 클래스&lt;/h1&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="퇴보한-클래스">퇴보한 클래스</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> x;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이런 클래스는 데이터 필드에 직접 접근하여 수정이 가능하다. 따라서 캡슐화의 이점을 제공하지 못한다.</p><ul><li>API를 수정하지 않고는 내부 표현을 바꿀 수 없다.</li><li>불변식을 보장할 수 없다.</li><li>외부에서 필드에 접근할 때 부수 작업을 수행 할 수도 없다.(예를들면, x값 조회 시, Comma case로 리턴하는 식의?)</li></ul><h1 id="흔하게-만드는-캡슐레이션">흔하게 만드는 캡슐레이션</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">this</span>.x = x; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">this</span>.y = y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>public 클래스라면 반드시 이정도의 접근자와 수정자를 만드는 정도는 해야된다.</li><li>클래스 내부 표현 방식을 언제든지 바꿀 수 있는 유연성을 제공해야 한다.</li><li>package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다해도 문제가 없다.<ul><li>같은 패키지안에서 특정이유 때문에 사용하던가, 톱레벨 클래스에서만 접근 할 것이기 때문이다.</li></ul></li></ul><h1 id="요약">요약</h1><ul><li>public 클래스는 절대 가변 필드를 노출해선 안된다.</li><li>불변 필드라면 노출해도 덜위험 하지만 그래도 하지 말아라.</li><li>package-private 클래스, 톱 레벨 클래스에서는 노출하는 편이 나을 수도 있다. (글쎄..?)</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/20/effective-java-item16/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 15. 클래스와 멤버의 접근 권한을 최소화하라</title>
      <link>https://jaehun2841.github.io/2019/01/19/effective-java-item15/</link>
      <guid>https://jaehun2841.github.io/2019/01/19/effective-java-item15/</guid>
      <pubDate>Sat, 19 Jan 2019 12:54:32 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;잘 설계된 컴포넌트는 클래스는 모든 내부구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리 해놨다.&lt;br&gt;
오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.&lt;br&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>잘 설계된 컴포넌트는 클래스는 모든 내부구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리 해놨다.<br>오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.<br>정보은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.</p><h1 id="정보-은닉의-장점">정보 은닉의 장점</h1><h2 id="시스템-개발-속도를-높인다">시스템 개발 속도를 높인다.</h2><p>여러가지 컴포넌트를 병렬로 개발할 수 있기 때문이다.예를 들어, 회원탈퇴 기능을 개발한다고 해보자</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithdrawalService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">withdrawalMember</span><span class="params">(Member member)</span></span>;</span><br><span class="line">  <span class="function">List&lt;Member&gt; <span class="title">getMembers</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">WithdrawalProcessType <span class="title">getProcessType</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="title">startProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Member&gt; members = getMembers();</span><br><span class="line">    members.stream().foreach(<span class="keyword">this</span>::withdrawalMember);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이러한 회원탈퇴 로직에 대한 인터페이스를 제공하고,일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴등의 로직이 상이하여 Service를 별도로 구현한다고하는 경우 Interface 스펙에 맞추어 여러 개발자가 개발할 수 있기 때문이다.</p><h2 id="시스템-관리-비용을-낮춘다">시스템 관리 비용을 낮춘다.</h2><p>각 컴포넌트를 빨리 파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.<br>위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 로직에 변경이 생긴 경우<br><code>WithdrawalService</code> interface를 구현한 비회원 탈퇴 서비스를 만들면 되기 때문이다.</p><h2 id="성능-최적화에-도움을-준다">성능 최적화에 도움을 준다.</h2><p>완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있다.<br>위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 중 비회원 탈퇴에 대해 처리대상이 많아 startProcess 메서드를 확장하여 내부적으로 withdrawalMember 메서드를 사용하지 않고 회원 리스트에 대해 쿼리를 이용해 Insert~ Select로 한방에 처리 할 수도 있다.</p><h2 id="소프트웨어-재사용성을-높인다">소프트웨어 재사용성을 높인다.</h2><p>외부에 의존하지 않고, 독자적으로 동작할 수 있는 컴포넌트라면, 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크다.<br>예를들면 알림톡 서버 API를 호출 할 수 있는 인터페이스가 있는 경우 그 인터페이스를 그대로 사용할 수 있다.</p><h2 id="큰-시스템을-제작하는-난이도를-낮춰준다">큰 시스템을 제작하는 난이도를 낮춰준다.</h2><p>시스템 전체가 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있다.<br>쉬운 예로 Mockito를 이용한 TestCase 작성이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(MockitoJUnitRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithdrawalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWithdrawalService</span> <span class="keyword">implements</span> <span class="title">WithdrawalService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">withdrawalMember</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">getMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> TestWithdrawalService testWithdrawalService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMocks</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 회원탈퇴_테스트() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        doReturn(Arrays.asList(<span class="keyword">new</span> Member(<span class="string">"Carrey"</span>))).when(testWithdrawalService).getMembers();</span><br><span class="line">        doCallRealMethod().when(testWithdrawalService).startProcess();</span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        String result = testWithdrawalService.startProcess();</span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        assertThat(result, is(<span class="string">"FINISHED"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="java의-접근제한자">Java의 접근제한자</h1><ul><li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li><li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 할 수 있다.</li><li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li><li>public: 모든 곳에서 접근 할 수 있다.</li></ul><h1 id="모든-클래스와-멤버의-접근성을-가능한-좁혀야-한다">모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.</h1><p>소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다.</p><h2 id="클래스-레벨-접근제한자">클래스 레벨 접근제한자</h2><p>톱레벨 수준(파일명 = 클래스명)이 같은 수준에서의 접근제한자는 public과 package-private만 사용 할 수 있다.</p><ul><li>public으로 선언하는 경우 공개 API로 사용 - 하위호환을 평생 신경써야 한다.</li><li>package-private로 사용하는 경우 해당 패키지 안에서만 사용 가능 - 다음 릴리즈에 내부로직을 변경해도 괜찮다.</li></ul><h2 id="이너클래스-사용하기">이너클래스 사용하기</h2><ul><li>한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 사용하는 클래스 안에 private static으로 중첩해보자</li><li>public일 필요가 없는 클래스의 접근 수준을 package-private로 해보자 - 다른 패키지에서 사용하지 못하게 막아야 한다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Shop&gt; shops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Shop&gt; shops;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String owner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="private과-package-private은-해당-클래스의-구현에-해당하므로-공개-api에-영향을-주지-않는다">private과 package-private은 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다.</h2><ul><li>일단 처음에는 모든 멤버는 private으로 만들어야 한다.</li><li>같은 패키지에서 접근해야 하는 멤버가 있는 경우 package-private로 변경</li><li>단, Serialize를 구현한 클래스의 경우 공개 API에 의도치 않게 공개 될 수도 있다.</li><li>필드의 접근 권한을 package-private에서 protected로 바꾸는 순간 필드에 접근 할 수 있는 대상 범위가 늘어나니 주의해야 한다.</li></ul><h2 id="메서드를-재정의-할-경우에는-접근-수준을-상위-클래스에서보다-좁게-설정-할-수-없다">메서드를 재정의 할 경우에는 접근 수준을 상위 클래스에서보다 좁게 설정 할 수 없다.</h2><ul><li>상위 클래스에서 접근제한자가 protected인데 하위클래스에서 갑자기 package-private이나 private로 변경할 수 없다.</li><li>상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환원칙)을 위반하기 때문이다.</li><li>단 인터페이스를 구현하는 경우에는 클래스의 메서드는 모두 public으로 해야 한다.</li></ul><h2 id="코드를-테스트-하려는-목적으로-클래스-인터페이스를-접근-범위를-넓히는-것을-주의하라">코드를 테스트 하려는 목적으로 클래스, 인터페이스를 접근 범위를 넓히는 것을 주의하라</h2><p>public 클래스의 private -&gt; package-private으로 바꾸는거는 괜찮다. 하지만 그이상의 경우 공개 API에 문제가 될 수 있다.</p><h1 id="public-클래스의-인스턴스-필드는-되도록-public이-아니어야-한다">public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.</h1><p>필드가 가변객체를 참조하거나(Collections이나 배열), final이 아닌 인스턴스 필드를 public으로 선언하면 <strong>불변식을 보장할 수 없다.</strong><br>public 가변 필드를 갖는 클래스는 일반적으로 thread safe 하지않다.<br>내부 구현을 바꾸고 싶어도 public 필드를 없애는 방식으로는 리팩터링이 불가하다.</p><p>하지만 상수라면 관례대로 public static final 필드로 공개해도 좋다.<br>필드 명 네이밍은 관례 상 <code>대문자 + _(언더바)</code>로 구성한다.그리고 반드시 불변 객체를 참조하도록 한다.<br>불변성이 깨지는 순간 어마무시한 일이 일어난다.</p><h1 id="클래스에서-public-static-final-배열-필드를-두지말아라">클래스에서 public static final 배열 필드를 두지말아라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123;...&#125;;</span><br></pre></td></tr></table></figure></p><p>이런 경우 VALUES에 대한 참조를 변경할 수는 없지만, 배열내의 내용을 변경하는 것은 가능하다.</p><h2 id="해결책1-thing-배열을-private로-만들고-public-불변-리스트를-추가한다">해결책1. Thing 배열을 private로 만들고 public 불변 리스트를 추가한다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 해결책2. Thing 배열을 private로 만들고 public 메서드를 추가한다.</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">  <span class="keyword">return</span> PRIVATE_VALUES.clone(); <span class="comment">//방어적 복사본</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="java-9에-추가된-modules-project-jigsaw">Java 9에 추가된 Modules (Project Jigsaw)</h1><p>Java9 부터는 Module시스템이라는 개념이 도입 되었다.</p><p>패키지는 클래스의 묶음인 것 처럼, 모듈(Modules)은 패키지의 묶음이다.모듈은 관례 상, 자신이 속하는 패키지 중 공개(export) 할 것을 선언한다.<br>관례상 <strong>module-info.java</strong> 에 선언한다.모듈을 정의하기 위해 3가지 정보를 작성해야 한다.</p><ol><li>module 명 - module 명칭</li><li>공개할 package (export)</li></ol><ul><li>공개한 package의 public type에 접근제한자만 외부에서 접근할 수 있다.</li><li>만약 export에 적지 않은 패키지의 클래스 중 public 접근제한자가 있어도 접근을 할 수 없다.</li></ul><ol start="3"><li>module내 package의 클래스를 사용하기 위해 종속되는 package (require)</li></ol><ul><li>다른 모듈의 대한 require를 작성하면 다른 모듈에서 export하는 클래스의 public type에 접근이 가능하다</li></ul><h2 id="java-8에서-접근-제한자">Java 8에서 접근 제한자</h2><ul><li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li><li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li><li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li><li>public: 모든 곳에서 접근할 수 있다.</li></ul><h2 id="java-9부터의-접근-제한자">Java 9부터의 접근 제한자</h2><ul><li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li><li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li><li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li><li>모듈 내부의 public: 모듈 내부의 모든 곳에서 접근할 수 있다.</li><li>required의 public: 모듈에 종속하는 모듈의 모든 패키지 내의 클래스에 접근할 수 있다.</li><li>export public: module-info.java에서 제공하는 모든 public에 접근할 수 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 15. 클래스와 멤버의 접근 권한을 최소화하라</li><li>https://infoscis.github.io/2017/03/24/First-steps-with-java9-and-jigsaw-part-1/</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/19/effective-java-item15/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 14. Comparable을 구현할지 고려하라</title>
      <link>https://jaehun2841.github.io/2019/01/13/effective-java-item14/</link>
      <guid>https://jaehun2841.github.io/2019/01/13/effective-java-item14/</guid>
      <pubDate>Sun, 13 Jan 2019 10:26:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Comparable을 구현하는 이유는 클래스의 인스턴스들간의 Ordering을 목적으로 구현하는 클래스이다.&lt;br&gt;
따라서 Comparable을 구현한 클래스에 대한 배열은 다음처럼 손쉽게 정렬 할 수 있다.&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Comparable을 구현하는 이유는 클래스의 인스턴스들간의 Ordering을 목적으로 구현하는 클래스이다.<br>따라서 Comparable을 구현한 클래스에 대한 배열은 다음처럼 손쉽게 정렬 할 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(arr);</span><br></pre></td></tr></table></figure></p><p>사실상 자바 플랫폼 라이브러리의 모든 값 클래스와 열거타입은 Compareable을 구현했다.<br>알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면, 반드시 Comparable 인터페이스를 구현하자</p><h1 id="compareto-메서드-규약">compareTo 메서드 규약</h1><p>이 객체와 주어진 객체의 순서를 비교한다.<br>이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 리턴한다.<br>이 객체와 비교할 수 없는 타입이 주어지면 ClassCaseException을 던진다.</p><h2 id="대칭성">대칭성</h2><ul><li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == (y.compareTo(x)) * (-1)을 만족해야 한다.</li><li>따라서 x.compareTo(y)가 예외를 던지는 경우, y.compareTo(x)도 예외를 던져야 한다.</li></ul><h2 id="추이성">추이성</h2><ul><li>Comparable을 구현한 클래스는 모든 x, y, z에 대해 x.compareTo(y) &gt; 0 이고 y.compareTo(z)이면, x.compareTo(z)를 만족해야 한다.</li></ul><h2 id="반사성">반사성</h2><ul><li>Comparable을 구현한 클래스 z는 x.compareTo(y) == 0 이면, sgn(x.compareTo(z)) == sgn(y.compareTo(z))를 만족해야 한다.</li></ul><h2 id="equals">equals</h2><ul><li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == 0 이면, x.equals(y)를 만족하는 것이 좋다. (권고사항은 아니다.)<br>이 권고를 지키지 않으려면, <code>주의: 이 클래스의 순서는 equals 메서드와 일관되지 않다.</code>라고 명시해 주자.</li></ul><h1 id="equals와-compareto-차이점">equals와 compareTo 차이점</h1><p>compareTo 규약 4번째의 예시로 BigDecimal 클래스가 있다.<br>new Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)이 있다고 할 때 두 객체를 HashSet&lt;Decimal&gt;에 담게 되면 size는 2개가 된다.<br>하지만 TreeSet&lt;Decimal&gt;에 담게 되면 size는 1개가 된다.</p><p>왜 이런 결과가 나올까?<br>HashSet에서는 equals를 기반으로 비교하기 때문에 new Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)은 서로 다른 객체이다. 그렇기 때문에 size가 2개가 된다.<br>하지만 TreeSet에서는 객체에 대한 동치성 비교를 compareTo로 하기 때문에 new Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)의 compareTo는 0을 리턴한다.<br>따라서 같은 객체로 인식하여 size가 1개가 된다.</p><h1 id="compareto-안티패턴">compareTo 안티패턴</h1><p>compareTo 메서드에서 관계연산자 (<code>&lt;</code> 와 <code>&gt;</code>)를 사용하지 말아야 한다.<br>대신 Type.compare(T t1, T t2)를 사용하여 비교하는 것이 좋다.</p><p>안티 패턴 코드<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; y ? <span class="number">1</span> : (x == y) ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>hashcode의 차를 이용한 비교는 안된다. (추이성에 위배된다.)</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">  (Object o1, Object o2) -&gt; o1.hashCode() - o2.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드 처럼 실행하면, 정수 overflow를 일으키거나 IEEE754 부동소수점 계산방식에 따른 오류를 발생 시킬 수 있다.<br>따라서 아래 코드로 고쳐서 사용하는 것이 좋다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">  (Object o1, Object o2) -&gt; Integer.compare(o1.hashCode(), o2.hashCode())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());</span><br></pre></td></tr></table></figure></p><h1 id="사용-예제">사용 예제</h1><h2 id="기본-타입-필드가-여러-개-일때-비교자">기본 타입 필드가 여러 개 일때 비교자</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PhoneNumber pn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = Short.compare(<span class="keyword">this</span>.areaCode, pn.areaCode);</span><br><span class="line">  <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">    result = Short.compare(<span class="keyword">this</span>.prefix, pn.prefix);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">      result = Short.compare(<span class="keyword">this</span>.line</span><br><span class="line">      Num, pn.lineNum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>필드의 정렬 우선순위를 정해 같은 값이 있을 때 마다 조건을 추가한다.</p><h2 id="비교자-생성-메서드를-이용한-비교자">비교자 생성 메서드를 이용한 비교자</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR </span><br><span class="line">                        = comparingInt((PhoneNumber pn) -&gt; pn.areaCode)  </span><br><span class="line">                                      .thenComparingInt(pn -&gt; pn.prefix)  </span><br><span class="line">                                      .thenComparingInt(pn -&gt; pn.lineNum)</span><br></pre></td></tr></table></figure></p><p>comparingInt라는 static 메서드를 import하여 사용하고, 2번째 조건 부터 thenComparingInt를 사용하여 비교자를 추가 할 수 있다.<br>최초 사용 시, PhoneNumber pn을 사용하여 람다식에서 타입을 추론 할 수 있도록 코드를 추가 하였다.<br>thenComparingInt부터는 자바 컴파일러가 충분히 타입을 추론 할 수 있으므로 명시적으로 지정하지 않았다.<br>Long타입과 Double타입에 대해서는 각각 comparingLong, thenComparingLong과 comparingDouble, thenComparingDouble이 별도로 있다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 14. Comparable을 구현할지 고려하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/13/effective-java-item14/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Shallow Copy와 Deep Copy</title>
      <link>https://jaehun2841.github.io/2019/01/13/java-object-copy/</link>
      <guid>https://jaehun2841.github.io/2019/01/13/java-object-copy/</guid>
      <pubDate>Sun, 13 Jan 2019 09:59:09 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;객체의-복사copy&quot;&gt;객체의 복사(Copy)&lt;/h1&gt;
&lt;p&gt;객체 지향 프로그래밍에서 객체를 복사하는 방법은 크게 두가지로 나뉜다.&lt;br&gt;
얇은 복사(Shallow Copy)와 깊은 복사(Deep Copy)가 있다.&lt;br&gt;
두가지 개념 모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="객체의-복사copy">객체의 복사(Copy)</h1><p>객체 지향 프로그래밍에서 객체를 복사하는 방법은 크게 두가지로 나뉜다.<br>얇은 복사(Shallow Copy)와 깊은 복사(Deep Copy)가 있다.<br>두가지 개념 모두 원본 객체를 바탕으로 새로운 객체를 만들어 낸다는 점에서는 같지만 미묘한 차이가 있다.</p><p>설명을 진행하기 전에 아래와 같은 Interface를 구현한 객체에 대해 copy가 진행된다고 가정하겠다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Copyable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function">T <span class="title">shallowCopy</span><span class="params">(T t)</span></span>;</span><br><span class="line">   <span class="function">T <span class="title">deepCopy</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="./clone.jpg" alt="clone"></p><h1 id="shallow-copy">Shallow Copy</h1><p>Shallow copy란 원본 객체를 바탕으로 새로운 객체를 생성한 뒤, 내부 필드의 참조에 대해서는 원본 객체와 같은 필드의 참조를 바라보는 형태이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">implements</span> <span class="title">Copyable</span>&lt;<span class="title">Menu</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> Recipe recipe;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Menu <span class="title">shallowCopy</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    Menu copyMenu = <span class="keyword">new</span> Menu(menu.getName(), menu.getPrice(), menu.getRecipe());</span><br><span class="line">    <span class="keyword">return</span> copyMenu;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>불변 객체에 대해서는 같은 객체를 공유한다는 점에서 메모리에 대한 비용을 아낄 수 있다는 장점이 있고, deep copy보다는 빠르다.</p><p>하지만, 가변 객체에 대해서는 원본 객체의 Recipe 객체가 변경되는 경우 의도치 않게 복사한 Recipe도 변경되는 경우가 발생한다.<br>이런 경우에는 Deep Copy를 통해 완전히 분리를 시켜줘야 한다.</p><h1 id="deep-copy">Deep Copy</h1><p>Deep Copy 원본 객체의 타입을 바탕으로 새로운 객체를 생성한 뒤, 내부 필드가 참조하는 객체에 대해서도 새로운 객체를 만들어 주는 방식이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">implements</span> <span class="title">Copyable</span>&lt;<span class="title">Menu</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> Recipe recipe;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Menu <span class="title">deepCopy</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    Menu copyMenu = <span class="keyword">new</span> Menu();</span><br><span class="line">    copyMenu.setName(<span class="keyword">new</span> String(menu.getName));</span><br><span class="line">    copyMenu.setPrice(menu.getPrice());</span><br><span class="line">    copyMenu.setRecipe(Recipe.deepCopy(menu.getRecipe));</span><br><span class="line">    <span class="keyword">return</span> copyMenu;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 필드에 대해 원본객체와 같은 reference를 사용하는 것이 아닌 필드의 reference에 대해서도 새로운 객체를 생성하여 복사하는 방식이다.</p><p>이런 경우 가변객체에 대한 변경에는 안전하다는 장점이 있다.<br>서로 다른 객체를 다루기 떄문에 안전하다.</p><p>하지만 객체 생성 비용이 shallow copy보다 비싸고 상대적으로 느리며,copy하는 객체 수가 많을 수록 메모리를 많이 점유하게 된다는 단점이 있다.</p>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/13/java-object-copy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 13. Clone 재정의는 주의해서 진행하라</title>
      <link>https://jaehun2841.github.io/2019/01/13/effective-java-item13/</link>
      <guid>https://jaehun2841.github.io/2019/01/13/effective-java-item13/</guid>
      <pubDate>Sun, 13 Jan 2019 07:31:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Cloneable은 복제해도 되는 인터페이스 임을 명시하는 용도의 믹스인 인터페이스이다.&lt;br&gt;
하지만 아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone메서드가 선언된 곳이 Cloneab
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Cloneable은 복제해도 되는 인터페이스 임을 명시하는 용도의 믹스인 인터페이스이다.<br>하지만 아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라는데 있다. 그래서 Cloneable을 구현하는 것만으로는 외부에서 clone 메서드를 호출 할 수 없다.</p><h1 id="cloneable-인터페이스는-무슨일을-할까">Cloneable 인터페이스는 무슨일을 할까?</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to</span></span><br><span class="line"><span class="comment"> * indicate to the &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; method that it</span></span><br><span class="line"><span class="comment"> * is legal for that method to make a</span></span><br><span class="line"><span class="comment"> * field-for-field copy of instances of that class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Invoking Object's clone method on an instance that does not implement the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, classes that implement this interface should override</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Object.clone&#125; (which is protected) with a public method.</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; for details on overriding this</span></span><br><span class="line"><span class="comment"> * method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &#123;<span class="doctag">@code</span> clone&#125; method.</span></span><br><span class="line"><span class="comment"> * Therefore, it is not possible to clone an object merely by virtue of the</span></span><br><span class="line"><span class="comment"> * fact that it implements this interface.  Even if the clone method is invoked</span></span><br><span class="line"><span class="comment"> * reflectively, there is no guarantee that it will succeed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#clone()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>자바의 Cloneable 인터페이스를 보면 아무런 메서드도 없다.<br>아무것도 없지만, 사실은 Object의 clone메서드의 동작방식을 결정한다.<br>Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면, 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면, <code>ClassNotSupportedException</code>을 던진다.</p><h1 id="object-클래스의-clone-규약">Object 클래스의 clone 규약</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns a copy of this object.  The precise meaning</span></span><br><span class="line"><span class="comment"> * of "copy" may depend on the class of the object. The general</span></span><br><span class="line"><span class="comment"> * intent is that, for any object &#123;<span class="doctag">@code</span> x&#125;, the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be true, and that the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, but these are not absolute requirements.</span></span><br><span class="line"><span class="comment"> * While it is typically the case that:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the returned object should be obtained by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> super.clone&#125;.  If a class and all of its superclasses (except</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Object&#125;) obey this convention, it will be the case that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> x.clone().getClass() == x.getClass()&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment"> * of this object (which is being cloned).  To achieve this independence,</span></span><br><span class="line"><span class="comment"> * it may be necessary to modify one or more fields of the object returned</span></span><br><span class="line"><span class="comment"> * by &#123;<span class="doctag">@code</span> super.clone&#125; before returning it.  Typically, this means</span></span><br><span class="line"><span class="comment"> * copying any mutable objects that comprise the internal "deep structure"</span></span><br><span class="line"><span class="comment"> * of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment"> * objects with references to the copies.  If a class contains only</span></span><br><span class="line"><span class="comment"> * primitive fields or references to immutable objects, then it is usually</span></span><br><span class="line"><span class="comment"> * the case that no fields in the object returned by &#123;<span class="doctag">@code</span> super.clone&#125;</span></span><br><span class="line"><span class="comment"> * need to be modified.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The method &#123;<span class="doctag">@code</span> clone&#125; for class &#123;<span class="doctag">@code</span> Object&#125; performs a</span></span><br><span class="line"><span class="comment"> * specific cloning operation. First, if the class of this object does</span></span><br><span class="line"><span class="comment"> * not implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125;, then a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> CloneNotSupportedException&#125; is thrown. Note that all arrays</span></span><br><span class="line"><span class="comment"> * are considered to implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125; and that</span></span><br><span class="line"><span class="comment"> * the return type of the &#123;<span class="doctag">@code</span> clone&#125; method of an array type &#123;<span class="doctag">@code</span> T[]&#125;</span></span><br><span class="line"><span class="comment"> * is &#123;<span class="doctag">@code</span> T[]&#125; where T is any reference or primitive type.</span></span><br><span class="line"><span class="comment"> * Otherwise, this method creates a new instance of the class of this</span></span><br><span class="line"><span class="comment"> * object and initializes all its fields with exactly the contents of</span></span><br><span class="line"><span class="comment"> * the corresponding fields of this object, as if by assignment; the</span></span><br><span class="line"><span class="comment"> * contents of the fields are not themselves cloned. Thus, this method</span></span><br><span class="line"><span class="comment"> * performs a "shallow copy" of this object, not a "deep copy" operation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The class &#123;<span class="doctag">@code</span> Object&#125; does not itself implement the interface</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Cloneable&#125;, so calling the &#123;<span class="doctag">@code</span> clone&#125; method on an object</span></span><br><span class="line"><span class="comment"> * whose class is &#123;<span class="doctag">@code</span> Object&#125; will result in throwing an</span></span><br><span class="line"><span class="comment"> * exception at run time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>     a clone of this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  CloneNotSupportedException  if the object's class does not</span></span><br><span class="line"><span class="comment"> *               support the &#123;<span class="doctag">@code</span> Cloneable&#125; interface. Subclasses</span></span><br><span class="line"><span class="comment"> *               that override the &#123;<span class="doctag">@code</span> clone&#125; method can also</span></span><br><span class="line"><span class="comment"> *               throw this exception to indicate that an instance cannot</span></span><br><span class="line"><span class="comment"> *               be cloned.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Cloneable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p><p>Object에 명시된 clone 규약이 주석으로 쓰여져 있다.</p><ul><li>x.clone() != x은 참이다.<br>복사한 객체와 원본 객체는 서로 다른 객체이다.</li><li>x.clone() .getClass() == x.getClass()은 일반적으로 참이다.하지만 반드시 만족해야 하는 것은 아니다.</li><li>x.clone.equals(x) 은 참이다.<br>복사한 객체와 원본객체는 논리적 동치성이 같다.</li><li>x.clone().getClass() == x.getClass()은 참이다.<br>관례상, 이 방법으로 반환된 객체는 독립성이 있어야 한다.<br>이를 만족하려면 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.</li><li>Cloneable을 구현하지 않은 클래스의 경우, CloneNotSupportedException이 throw된다.</li><li>모든 Array는 Cloneable을 구현하도록 고려되었다. clone 메서드는 T[]를 리턴하도록 설계</li><li>T는 기본타입 또는 참조타입으로 설계</li><li>기본적으로 Object.clone은 clone대상 클래스에 대해 새로운 객체를 new로 생성</li><li>모든 필드들에 대해 초기화를 진행</li><li>하지만 필드에 대한 객체를 다시 생성하지 않는 Shallow copy 방식으로 수행한다 (deep copy아님)</li><li>클래스에 대한 복제본을 원하지 않는 경우 clone메서드를 재정의하여 CloneNotSupportedException을 throw하도록 함</li></ul><h1 id="clone-메서드-재정의-시-주의할-점">clone 메서드 재정의 시, 주의할 점</h1><h2 id="기본적인-clone메서드-재정의">기본적인 clone메서드 재정의</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PhoneNumber <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (PhoneNumber) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ClassNotSupportedException e) &#123;</span><br><span class="line">      <span class="comment">//아무처리를 하지 않거나, RuntimeException으로 감싸는 것이 사용하기 편하다.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>super.clone()을 실행하면 PhoneNumber에 대한 완벽한 복제가 이루어진다.</li><li>super.clone()의 리턴 타입은 Object이지만, 자바의 공변 반환타이핑 기능을 통해 PhoneNumber 타입으로 캐스팅하여 리턴하는 것이 가능하다.<br>(추천하는 기능)</li><li>try-catch 부분으로 감싼것은 super.clone() 메서드에서 ClassNotSupportedException이라는 checked exception을 리턴하기 떄문에 처리 해주었다.<ul><li>하지만 PhoneNumber가 Cloneable을 구현하기 떄문에 절대 실패하지 않는다.<br>따라서 이부분은 RuntimeException으로 처리하거나, 아무것도 설정하지 않아야 한다.</li></ul></li></ul><h2 id="가변-상태를-갖는-필드에-대한-복제">가변 상태를 갖는 필드에 대한 복제</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object[] elements;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Stack <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Stack result = (Stack) <span class="keyword">super</span>.clone();</span><br><span class="line">      result.elements = </span><br><span class="line">    &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 클래스가 단순히 clone메서드를 이용해 super.clone()만 실행하게 된다면,<br>new Stack()을 통해 새로운 객체가 생성되고 필드모두 원본 객체와 동일하게 초기화가 될 것이다.<br>하지만, 위에서 얘기한 Object의 clone 기본규약에는 Deep copy가 아닌 Shallow Copy를 이용해 초기화를 진행한다고 적혀있다.<br>따라서 배열과 같은 가변필드는 원본 필드와 객체를 공유하게 된다.</p><p>Clone메서드는 사실상 생성자와 같은 효과를 낸다.<br>즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.<br>그렇기 때문에 제대로 복제하기 위해서는, elements라는 배열을 똑같이 복사해서 만들어줘야 한다.</p><h2 id="배열-복사">배열 복사</h2><p>배열을 복제하는 방법 중 가장 권장하는 방법은array.clone()을 이용해 복사하는 방법이다.<br>사실, 배열은 clone기능을 가장 제대로 사용하는 유일한 예이다.</p><p>하지만, array 필드가 final이 적용되어 있다면 array.clone()을 통한 초기화는 할 수 없다. (final이기 떄문에 객체 생성 이후 초기화 불가)<br><strong>Cloneable 아키텍처는 가변객체를 참조하는 필드는 final로 선언하라 라는 일반 용법과 충돌한다.</strong><br>그래서 복제 할 수 있는 클래스를 만들기 위해 일부 필드에서 final 한정자를 제거해야 할 수도 있다.</p><h2 id="stack-overflow-문제">Stack overflow 문제</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Entry[] buckets = ...;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object key;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry next;</span><br><span class="line"></span><br><span class="line">    Entry(Object key, Object value, Entry next) &#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HashTable <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      HashTable result = (HashTable) <span class="keyword">super</span>.clone();</span><br><span class="line">      result.buckets = buckets.clone();</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Assertion();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>복제본은 자신만의 버킷 배열은 갖지만, 배열내의 Entry는 원본과 같은 연결리스트를 참조하여, 불변성이 꺠지게 된다.</p><p>그래서 HashTable.Entry 클래스는 내부적으로 deep copy를 지원하도록 보강되었다. 연결리스트에 대한 next를 복제할 때 재귀적으로 clone을 호출하도록 되어있는데, 재귀 호출 떄문에 연결리스트의 size만큼 스택프레임을 소비하여, 리스트가 길면 stackoverflow에러를 발생시킬 위험이 있다.<br>이 문제를 해결하기 위해서는 재귀 호출을 통한 deepcopy대신 반복자를 써서 순회하는 방법으로 수정해야 한다.</p><h2 id="안전하지만-느린-copy">안전하지만 느린 copy</h2><p>HashTable을 예로 들면, buckets필드를 새로운 배열로 초기화 한다음 원본테이블의 있는 버킷의 내용을 put(key, value) 메서드를 호출해<br>새로 버킷을 만드는 방법이 있다.<br>이 방법은 안전하긴 하지만, low level에서 작동하는 copy보다는 느리다.</p><h2 id="생성자-내에서는-재정의-될-수-있는-메서드를-호출-하지-말자">생성자 내에서는 재정의 될 수 있는 메서드를 호출 하지 말자</h2><p>만약 clone이 하위 클래스에서 재정의한 메서드를 호출하면, 하위 클래스는 복사과정에서 자신의 상태를 교정할 기회를 잃게되어<br>원본과 복제본의 상태가 달라질 수 있다.</p><h2 id="classnotsupportedexception">ClassNotSupportedException</h2><p>Object의 clone메서드는 CloneNotSupportedException을 던진다고 선언했지만 재정의한 메서드는 그렇지 않다.<br>public인 clone 메서드에서는 throws절을 없애던가, RuntimeException으로 throws 해야한다.<br>그렇지 않으면 clone 메서드를 호출 할 떄마다, 예외처리를 해야 해서 사용하기가 불편하다.</p><p>하위 클래스에서 Clone을 방지하기 위해 동작하지 않게 만들수도 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="스레드-안전성을-고려한다면-적절히-동기화해야-한다">스레드 안전성을 고려한다면 적절히 동기화해야 한다.</h2><p>스레드 안정성을 고려한다면 clone 메서드에 대해 적절히 동기화 처리 해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object result = <span class="keyword">super</span>.clone();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="복사-생성자와-복사-팩터리-메서드">복사 생성자와 복사 팩터리 메서드</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Yum</span><span class="params">(Yum yum)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Yum <span class="title">newInstance</span><span class="params">(Yum yum)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>복사 생성자와 복사 팩터리 메서드는 Cloneable/clone 방식보다 나은 면이 많다.</p><ul><li>언어 모순적이고 위험한 객체 생성 메커니즘을 사용하지 않는다. (super.clone())</li><li>clone 규약에 기대지 않는다.</li><li>정상적인 final필드 용법과도 충돌하지 않는다.</li><li>불필요한 check exception 처리가 필요없다.</li><li>형변환도 필요없다.</li><li>복사 생성자와 복사 팩터리는 인터페이스 타입의 인스턴스를 인수로 받을 수 있다.</li></ul><h1 id="deep-copy-vs-shallow-copy">Deep copy vs Shallow copy</h1><p><a href="http://localhost:4000/2019/01/13/java-object-copy" target="_blank" rel="noopener">Shallow Copy와 Deep Copy</a> - 이 포스팅을 참고하자</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 13. clone 재정의는 주의해서 진행하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/13/effective-java-item13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 12. toString을 항상 재정의하라</title>
      <link>https://jaehun2841.github.io/2019/01/13/effective-java-item12/</link>
      <guid>https://jaehun2841.github.io/2019/01/13/effective-java-item12/</guid>
      <pubDate>Sun, 13 Jan 2019 05:59:25 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Object의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.&lt;br&gt;
이 메서드는 &lt;code&gt;PhoneNumber@adbbd&lt;/code&gt;처럼 단순히 &lt;stron
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Object의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.<br>이 메서드는 <code>PhoneNumber@adbbd</code>처럼 단순히 <strong>클래스이름@16진수로_표현한_해시코드</strong>를 반환할 뿐이다.<br>toString의 일반 규약에 따르면, <code>간결하면서 사람이 읽기 쉬운 형태의 유익한 정보</code>를 반환해야 한다.<br>toString의 규악은 <code>모든 하위클래스에서 이 메서드를 재정의하라</code>라고 하고 있다.</p><h1 id="tostring을-재정의-해야하는-이유">toString을 재정의 해야하는 이유</h1><ul><li>toString을 잘 구현한 클래스는 사용하기 편하고, 그 클래스에 대해 디버깅 하기 쉽다.<ul><li>map객체를 출력하는 경우 <code>{Jenny=PhoneNumber@addbb}</code> 보다는 <code>{Jenney=707-867-5308}</code>이라는 메세지가 가독서이 좋다.</li></ul></li><li>실전에서는 toString메서드를 재작성 할 때, 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.</li><li>toString을 구현할 때면 반환값의 포맷을 문서화 할 지 정해야 한다.<ul><li>포맷을 명시하면, 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다.</li><li>포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</li><li>단, 포맷을 한번 명시하면, 평생 그 포맷에 얽매이게 된다.</li><li>포맷을 명시하지 않는다면 다음 릴리즈에 포맷을 변경할 수 있는 유연성을 더 가져갈 수 있다.</li></ul></li><li>포맷을 명시하든 아니든, 개발자의 의도는 명확히 밝혀야 한다.</li><li>toString이 반환한 값에 대해 포함된 정보를 얻어올 수 있는 API를 제공하자<ul><li>toString에 있는 getter를 제공하지 않는다면, 클라이언트에서 toString을 파싱하여 사용할 지도 모른다.</li></ul></li></ul><h2 id="포맷을-명시하기로-했으면-명시한-포맷에-맞는-문자열과-객체를-상호전환-할-수-있는-정적-팩터리나-생성자를-함께-제공하면-좋다">포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> toString테스트() &#123;</span><br><span class="line">        String phoneNumber = <span class="string">"707-908-9999"</span>;</span><br><span class="line">        assertEquals(PhoneNumber.parse(phoneNumber), <span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">908</span>, <span class="number">9999</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>(expected = UnknownFormatConversionException.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 파싱문자열_오류_테스트() &#123;</span><br><span class="line">        String phoneNumber = <span class="string">"707-908"</span>;</span><br><span class="line">        assertEquals(PhoneNumber.parse(phoneNumber), <span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">908</span>, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer areaCode;</span><br><span class="line">        <span class="keyword">private</span> Integer prefix;</span><br><span class="line">        <span class="keyword">private</span> Integer lineNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern phoneNumberPattern = Pattern.compile(<span class="string">"^\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;4&#125;$"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PhoneNumber pn = (PhoneNumber) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.areaCode.equals(pn.areaCode)</span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.prefix.equals(pn.prefix)</span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.lineNum.equals(pn.lineNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result = Integer.hashCode(areaCode);</span><br><span class="line">            result = <span class="number">31</span> * result + Integer.hashCode(prefix);</span><br><span class="line">            result = <span class="number">31</span> * result + Integer.hashCode(lineNum);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">"%03d-%03d-%04d"</span>, areaCode, prefix, lineNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PhoneNumber <span class="title">parse</span><span class="params">(String phoneNumber)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!phoneNumberPattern.matcher(phoneNumber).find()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnknownFormatConversionException(phoneNumber + <span class="string">" cannot be parsed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] numbers = phoneNumber.split(<span class="string">"-"</span>);</span><br><span class="line">            <span class="keyword">return</span> PhoneNumber.builder()</span><br><span class="line">                    .areaCode(Integer.parseInt(numbers[<span class="number">0</span>]))</span><br><span class="line">                    .prefix(Integer.parseInt(numbers[<span class="number">1</span>]))</span><br><span class="line">                    .lineNum(Integer.parseInt(numbers[<span class="number">2</span>]))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="tostring을-따로-재정의-안해도-되는-경우">toString을 따로 재정의 안해도 되는 경우</h1><ul><li>정적 Utils 클래스는 따로 재정의 하지 않아도 된다.(객체의 상태(state)를 가지는 클래스가 아니기 떄문)</li><li>enum 타입 또한 이미 완벽한 toString을 제공한다.</li><li>대다수의 컬렉션 구현체는 추상 컬렉션 클래스(AbstractMap, AbstractSet등)의 toString 메서드를 상속하여 쓴다.</li><li>라이브러리를 통해 자동생성하자<ul><li>구글의 @Autovalue</li><li>Lombok의 @ToString</li><li>위의 라이브러리들을 이용해 자동생성하는 편이 더 간편하다.</li></ul></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 12. toString을 항상 재정의하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/13/effective-java-item12/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
