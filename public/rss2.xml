<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Carrey`s 기술블로그</title>
    <link>https://jaehun2841.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 23 Jun 2019 12:35:35 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Event-Driven-Architecture란?</title>
      <link>https://jaehun2841.github.io/2019/06/23/2019-06-23-event-driven-architecture/</link>
      <guid>https://jaehun2841.github.io/2019/06/23/2019-06-23-event-driven-architecture/</guid>
      <pubDate>Sun, 23 Jun 2019 08:54:28 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;event-driven-란&quot;&gt;Event Driven 란?&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;./EDA.png&quot; alt=&quot;EDA&quot;&gt;&lt;/p&gt;
&lt;p&gt;Event Driven은 IT 영역에서 오래 사용된 키워드이며, 현재도 그 영향력이 대단하여 2
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="event-driven-란">Event Driven 란?</h1><p><img src="./EDA.png" alt="EDA"></p><p>Event Driven은 IT 영역에서 오래 사용된 키워드이며, 현재도 그 영향력이 대단하여 2018년 Gartner에서 선정한 유망한 기술 트렌드 중 하나로 뽑히기도 했다.<br>(Top 10 Strategic Technology Trends for 2018: Event-Driven Model)</p><p>Event Driven이라는 용어는 programming, architecture와 연결되어 다양한 정의로 표현된다.</p><blockquote><p><strong>EDA (Event-driven architecture)</strong><br>분산된 시스템 간에 이벤트를 생성, 발행 (publishing)하고 발행된 이벤트를 필요로하는 수신자에게 전송된다.<br>이벤트를 수신한 수신자가 이벤트를 처리하는 형태의 시스템 아키텍쳐</p></blockquote><ul><li>Event Driven Pattern - 특정 행동이 자동으로/순서에 따라 발생하는 것이 아닌 어떤 일에 대한 반응으로 동작하는 디자인 패턴</li><li>IO Event - 컴퓨터 회로를 구동시키기 위해 발생하는 일  ( ex)  마우스 클릭, 키보드 타이핑, 모바일 터치 등)</li><li>IOT 기기 등의 센서로부터 유입되는 데이터 스트리밍 기반의 동작</li><li>시스템의 내,외부에서 발생한 <strong>주목할 만한 상태의 변화(a significant change in state)</strong></li></ul><p>주로 Event Driven 시스템은 Message Broker(Kafka, Rabbit MQ, Redis)와 결합하여, Message Driven 시스템으로 구성된다.</p><h2 id="eda-event-driven-architecture의-구성요소">EDA (Event-driven architecture)의 구성요소</h2><p>EDA는 크게 3개의 구성요소로 나누어 볼 수 있다.</p><ul><li>Event generator : 시스템 내,외부의 상태 변화를 감지하여 표준화된 형식의 이벤트를 생성</li><li>Event channel : 이벤트를 필요로 하는 시스템까지 발송</li><li>Event processing engine : 수신한 이벤트를 식별, 적절한 처리를 함. 때에 따라 이벤트 처리의 결과로 또 다른 이벤트를 발생시킬 수 있다.</li></ul><h2 id="event-processing-style">Event Processing Style</h2><p>수신한 이벤트를 처리하는 방법에는 세가지 종류가 있다.</p><h3 id="simple-event-processing">Simple event processing</h3><p>각각의 이벤트가 직접적으로 수행해야할 action과 매핑되어 처리 된다.<br>실시간으로 작업의 흐름을 처리할 때 사용되며, 이벤트 처리 시간과 비용의 손실이 적다.</p><h3 id="event-stream-processing">Event Stream Processing</h3><p>이벤트를 중요도에 따라  필터링하여 걸러진 이벤트만을 수신자에게 전송.<br>실시간으로 정보의 흐름을 처리할 때 사용되며, 기업에 적용될 경우 신속한 의사 결정을 가능케한다.(BAM)</p><h3 id="complex-event-processing">Complex event processing</h3><p>일상적인 이벤트의 패턴을 감지하여 더 복잡한 이벤트의 발생을 추론하는 것.<br>예를 들어 '주식의 등락'이라는 일상적인 이벤트의 패턴을 감지하여 '투자 적기'라는 상위의 이벤트를 추론해 낼 수 있다.</p><h2 id="event-driven-architecture의-장단점">Event Driven Architecture의 장단점</h2><h3 id="장점">장점</h3><ul><li>Decoupling - 시스템 간의 느슨한 결합이 가능 하므로 분산 시스템, Microservice 환경에서 시스템 간 의존성을 배제 할 수 있다<br>(시스템은 Event Channel인 Message Broker에 대한 의존성만 가진다.)</li><li>다른 시스템의 정보를 알 필요가 없다 - 약속된 Event message를 가지고 상호 정보를 교환한다.</li><li>micro service 단위로 시스템을 분리하기 쉽기 때문에 확장성, 탄력성을 고려하기 쉽다.</li></ul><h3 id="단점">단점</h3><ul><li>Broker Dependency - Event를 전송하기 위한 Message Broker에 대한 의존성이 커지기 때문에<br>Message Broker 장애 상황 시, 전체 장애로 이어질 수 있다.</li><li>Transaction 단위가 격리되기 때문에 서비스 장애 발생시 retry/rollback을 고려해야 한다.</li><li>시스템 전체 Flow를 파악하기 어렵다. - 명확한 Flow를 보기 위해서는 시스템을 모니터링하여야 한다.</li><li>디버깅이 어렵다.</li></ul><h1 id="microservice에서의-event">Microservice에서의 Event</h1><p><img src="./EDM.png" alt="EDM"></p><blockquote><p><strong>EDM(Event Driven Microservice)</strong>MSA가 적용된 시스템에서 이벤트 발생시 해당 이벤트 로그를 보관하고 이를 기반으로 동작하며,<br>비동기 통신을 통해 시스템 내 통합(integration)을 수행하는 Architecture</p></blockquote><h2 id="event">Event</h2><p>IT 영역에서의 이벤트는 다양한 정의를 포함하지만, MSA에서 의미하는 이벤트는<br>시스템의 내,외부에서 발생한 <strong>주목할 만한 상태의 변화(a significant change in state)</strong><br>데이터의 생성, 변경, 삭제를 통해 발생하는 서비스의 의미 있는 변화를 의미</p><h2 id="이벤트-로그를-보관">이벤트 로그를 보관</h2><ul><li>github를 예시들어 이해하면 이해가 편할 것 같습니다.</li></ul><h3 id="현재의-데이터는-상태-변경의-누적이다">현재의 데이터는 상태 변경의 누적이다.</h3><ul><li>github의 commit 한 스냅샷의 연속으로 현재의 소스가 변경</li></ul><h3 id="상태-변경은-이벤트를-의미하고-이를-누적하는-행위는-이벤트-로그를-보관하는-것">상태 변경은 이벤트를 의미하고 이를 누적하는 행위는 이벤트 로그를 보관하는 것</h3><ul><li>github에 commit = Eventcommit 로그는 이벤트를 보관하는 행위</li></ul><h3 id="보관된-이벤트는-데이터의-현재-상태를-구성하는-근간">보관된 이벤트는 데이터의 현재 상태를 구성하는 근간</h3><ul><li>github는 commit이라는 이벤트를 보관하는 store의 역할을 해주며commit의 누적으로 인해 현재의 소스를 구성할 수 있다.</li></ul><h3 id="보관된-이벤트를-바탕으로-장애-발생-또는-특정-요구사항에-따라-지정된-시점으로-복원을-수행">보관된 이벤트를 바탕으로 장애 발생 또는 특정 요구사항에 따라 지정된 시점으로 복원을 수행</h3><ul><li>github는 특정시점으로 롤백 및 revert가 가능</li></ul><h2 id="비동기-통신">비동기 통신</h2><p>amqp, mqtt, jms 등 메세징 프로토콜을 통한 메세지 큐 방식이 자주 사용됩니다.<br>서비스에서 데이터의 생성,변경,삭제(CUD)를 통해 이벤트가 발생하면 발행 서비스는 <strong>메세지의 형태로 이벤트를 발행</strong>하고, 해당 이벤트에 관심이 있는 서비스에서 구독을 수행합니다.<br>메세지 큐를 사용함으로 requeue/dlq(dead letter queue) 등의 기능을 활용할 수 있습니다.</p><h2 id="시스템-내-통합integration">시스템 내 통합(integration)</h2><p>이상적으로 구현된 MSA는 서비스 간 데이터 참조를 위한 내부 통신이 필요없지만, 현실적으로 서비스 간 내부 통신이 전혀 없는 시스템을 구현하기란 불가능에 가깝습니다. 다양한 사유로 여러 서비스 간 통신을 통해 연동이 발생합니다.</p><h2 id="트랜잭션-관리">트랜잭션 관리</h2><p>microservice 단위로 분리된 환경이기 때문에 각자 데이터베이스를 적용한 시스템에 대해 데이터 무결성을 보장할 수는 없지만<br>Event를 통해 최종적인 일관성을 유지 할 수는 있습니다.<br><strong>all commit or rollback → eventually consistency</strong> (언젠가는 맞는다.)</p><h1 id="참고">참고</h1><ul><li>https://bigstory.tistory.com/entry/Event-Driven-Architecture</li><li>https://en.wikipedia.org/wiki/Event-driven_architecture</li><li>https://medium.com/dtevangelist/event-driven-microservice-%EB%9E%80-54b4eaf7cc4a</li><li>https://www.confluent.io/blog/event-streaming-platform-1</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/06/23/2019-06-23-event-driven-architecture/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 88. readObject 메서드는 방어적으로 작성하라</title>
      <link>https://jaehun2841.github.io/2019/03/17/effective-java-item88/</link>
      <guid>https://jaehun2841.github.io/2019/03/17/effective-java-item88/</guid>
      <pubDate>Sun, 17 Mar 2019 08:11:59 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Item 50에서는 불변인 날짜 범위 클래스를 만드는데 가변인 Date 필드를 이용했다.&lt;br&gt;
그래서 불변식을 지키고 불변을 유지하기 위해 생성자와 접근자에서 Date객체를 방어적으로 복사하느라 코드가 상당히
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Item 50에서는 불변인 날짜 범위 클래스를 만드는데 가변인 Date 필드를 이용했다.<br>그래서 불변식을 지키고 불변을 유지하기 위해 생성자와 접근자에서 Date객체를 방어적으로 복사하느라 코드가 상당히 길어졌다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Period</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 시작 시각</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 종료 시각; 시작 시각보다 뒤여야 한다.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException start나 end가 null이면 발행한다.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.start.compareTo(<span class="keyword">this</span>.end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(start + <span class="string">"가 "</span> + end + <span class="string">"보다 늦다."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Date(start.getTime()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Date(end.getTime()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start + <span class="string">"-"</span> + end; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 클래스는 물리적 표현과 논리적 표현이 부합하므로 기본 직렬화를 사용해도 좋다.<br>하지만 이렇게 해서는 주요한 Date의 불변식을 보장하지 못한다.</p><h1 id="필요하다면-매개변수를-방어적으로-복사하라">필요하다면 매개변수를 방어적으로 복사하라</h1><ul><li>readObject 메서드는 실질적으로는 또 다른 public 생성자이기 때문에 생성자와 똑같은 수준으로 주의를 기울여야한다.</li><li>readObject 메서드에서 <strong>인수가 유효한지 검사해야하고 필요하다면 방어적으로 복사하라</strong></li><li>readObject에서 이 작업을 제대로 하지 못하면 공격자는 쉽게 클래스의 불변식을 깨뜨릴 수 있다.</li></ul><h2 id="불변식을-깨뜨릴-용도로-스트림을-조작하면-문제가-생긴다">불변식을 깨뜨릴 용도로 스트림을 조작하면 문제가 생긴다</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BogusPeriod</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] serializedForm = &#123;</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xac</span>, (<span class="keyword">byte</span>)<span class="number">0xed</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x73</span>, <span class="number">0x72</span>, <span class="number">0x00</span>, <span class="number">0x06</span>....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Period p = (Period) deserialize(serializedForm);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] sf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(sf)).readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 코드의 serializedForm에서 상위 비트가 1인 바이트 값들은 byte로 형변환했는데,<br>이는 자바가 바이트 리터럴을 지원하지 않고 byte 타입은 부호가 있는 (signed) 타입이기 때문이다.</li><li>위의 프로그램을 실행하면<br><code>Fri Jan 01 12:00:00 PST 1999 - Sun Jan 01 12:00:00 PST 1984</code>를 출력한다.</li><li>Period를 직렬화할 수 있도록 선언한 것 만으로도 불변식을 깨뜨리는 객체를 만들 수 있다.</li></ul><h1 id="역직렬화-시-불변식을-만족하는-유효성-검사를-해야한다">역직렬화 시, 불변식을 만족하는 유효성 검사를 해야한다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 불변식을 만족하는지 검사한다.</span></span><br><span class="line">    <span class="keyword">if</span>(start.compareTo(end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(start + <span class="string">"가 "</span> + end + <span class="string">"보다 늦다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위의 if문 추가로 허용되지 않는 Period 인스턴스가 생성되는 일을 막을 수 있지만, 아직도 미묘한 문제가 숨어있다.</li><li>정상 Period 인스턴스에서 시작된 바이트 스트림 끝에 private Date 필드로의 참조를 추가하면 가변 Period 인스턴스를 만들 수 있다.</li></ul><h1 id="가변-공격을-막기위해서는-방어적-복사본을-만들어야-한다">가변 공격을 막기위해서는 방어적 복사본을 만들어야 한다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePeriod</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Period 인스턴스</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Period period;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//시작 시각 필드 - 외부에서 접근할 수 없어야 한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Date start;</span><br><span class="line">    <span class="comment">//종료 시각 필드 - 외부에서 접근할 수 없어야 한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Date end;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePeriod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectArrayOutputStream out = <span class="keyword">new</span> ObjectArrayOutputStream(bos);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//유효한 Period 인스턴스를 직렬화한다.</span></span><br><span class="line">            out.writeObject(<span class="keyword">new</span> Period(<span class="keyword">new</span> Date(), <span class="keyword">new</span> Date()));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 악의적인 '이전 객체 참조', 즉 내부 Date 필드로의 참조를 추가한다.</span></span><br><span class="line"><span class="comment">             * 상세 내용은 자바 객체 직렬화 명세의 6.4절을 참고</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">byte</span>[] ref = &#123;<span class="number">0x71</span>, <span class="number">0</span>, <span class="number">0x7e</span>, <span class="number">0</span>, <span class="number">5</span>&#125;; <span class="comment">// 참조 #5</span></span><br><span class="line">            bos.write(ref); <span class="comment">// 시작 start 필드 참조 추가</span></span><br><span class="line">            ref[<span class="number">4</span>] = <span class="number">4</span>; <span class="comment">//참조 #4</span></span><br><span class="line">            bos.write(ref); <span class="comment">// 종료(end) 필드 참조 추가</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Period 역직렬화 후 Date 참조를 훔친다.</span></span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray()));</span><br><span class="line">            period = (Period) in.readObject();</span><br><span class="line">            start = (Date) in.readObject();</span><br><span class="line">            end = (Date) in.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>다음 공격 코드를 실행하면 이 공격이 실제로 이뤄지는 모습을 확인할 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MutablePeriod mp = <span class="keyword">new</span> MutablePeriod();</span><br><span class="line">    Period p = mp.period;</span><br><span class="line">    Date pEnd = mp.end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//시간 되돌리기</span></span><br><span class="line">    pEnd.setYear(<span class="number">78</span>);</span><br><span class="line">    System.out.println(p); <span class="comment">// Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1978</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//60년대로 회귀</span></span><br><span class="line">    pEnd.setYear(<span class="number">60</span>);</span><br><span class="line">    System.out.println(p); <span class="comment">// Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1969</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 예시에서 Period 인스턴스는 불변식을 유지한 채 생성됐지만 의도적으로 내부의 값을 수정할 수 있었다.<br>이처럼 변경할 수 있는 Period 인스턴스를 획득한 공격자는 인스턴스가 불변이라고 가정하는 클래스에 넘겨 엄청난 보안 문제를 일으킬 수 있다.</p><p>이 문제의 근원은 <strong>Period의 readObject메서드가 방어적 복사를 충분히 하지 않은 데 있다.</strong><br>객체를 직렬화할 때는 클라이언트가 소유해서는 안 되는 객체 참조를 갖는 필드를 모두 방어적으로 복사해야 한다.<br>따라서 <code>readObject에서는 불변 클래스 안의 모든 private 가변 요소를 방어적으로 복사 해야한다.</code></p><h1 id="readobject-메서드에서는-private-가변요소를-방어-복사하라">readObject 메서드에서는 private 가변요소를 방어 복사하라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 가변 요소들을 방어적으로 복사한다.</span></span><br><span class="line">    start = <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">    end = <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 불변식을 만족하는지 검사한다.</span></span><br><span class="line">    <span class="keyword">if</span>(start.compareTo(end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(start + <span class="string">"가 "</span> + end + <span class="string">"보다 늦다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>방어적 복사를 유효성 검사보다 앞서 수행하며, Date의 clone 메서드는 사용하지 않았음에 주목하자.</li><li>두 조치 모두 Period를 공격으로 부터 보호하는데 필요하다.</li><li>또한 final 필드는 방어적 복사가 불가능 하니 주의하자</li><li>그래서 이 readObject를 사용하려면 start와 end필드에서 final 한정자를 제거해야 한다.</li></ul><h1 id="기본-readobject를-사용해도-되는지에-대한-체크리스트">기본 readObject를 사용해도 되는지에 대한 체크리스트</h1><ul><li>transient 필드를 제외한 모든 필드의 값을 매개변수로 받아 유효성 검사 없이 필드에 대입하는 public 생성자를 추가해도 괜찮은가?<ul><li>아니오 -&gt; 커스텀 readObject 메서드를 만들어 유효성 검사와 방어적 복사를 수행</li><li>예 -&gt; 기본 readObject 메서드 사용</li></ul></li><li>직렬화 프록시 패턴을 사용해도 된다 .<ul><li>역직렬화를 안전하게 만드는 데 필요한 노력을 경감해 준다. (권장)</li></ul></li></ul><h1 id="정리">정리</h1><ul><li>readObject 메서드를 작성할 때는 언제나 public 생성자를 만든다고 생각하고 만들어야 한다.</li><li>private 이어야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사하라 (불변 클래스 내의 가변 요소)</li><li>모든 불변식을 검사하여 어긋나는 게 발견되면 InvalidObjectException을 던진다.<br>방어적 복사 다음에는 반드시 불변식 검사가 뒤따라야 한다.</li><li>역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면 ObjectInputValidation 인터페이스를 사용하라</li><li>직접적이든 간접적이든 readObject메서드에서 재정의 가능한 메서드를 호출해서는 안된다.</li><li>재정의 가능한 메서드가 재정의되면 하위 클래스의 상태가 완전히 역직렬화 되기전에 하위 클래스에서 재정의된 메서드가 실행되므로<br>프로그램 오작동을 일으킬 수 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 88. readObject 메서드는 방어적으로 작성하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/17/effective-java-item88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 87. 커스텀 직렬화 형태를 고려해보라</title>
      <link>https://jaehun2841.github.io/2019/03/17/effective-java-item87/</link>
      <guid>https://jaehun2841.github.io/2019/03/17/effective-java-item87/</guid>
      <pubDate>Sun, 17 Mar 2019 06:21:53 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;개발 일정에 쫓기는 상황에서는 API 설계에 노력을 집중하는 편이 낫다.&lt;br&gt;
다음 릴리스에서 세부적인 기능을 제대로 구현하고 이번 릴리즈는 대충 동작만하게 하면 된다는 뜻이다.&lt;br&gt;
하지만 클래스가 Ser
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>개발 일정에 쫓기는 상황에서는 API 설계에 노력을 집중하는 편이 낫다.<br>다음 릴리스에서 세부적인 기능을 제대로 구현하고 이번 릴리즈는 대충 동작만하게 하면 된다는 뜻이다.<br>하지만 클래스가 Serializable을 구현하고 기본 직렬화 형태를 사용한다면 다음 릴리즈때 버리려 한 현재의 구현에 영원히 발이 묶이게 된다.<br>(현재의 기본 직렬화 형태를 버릴 수 없게 되기 때문이다.)</p><h1 id="먼저-고민해보고-괜찮다고-판단될-때만-기본-직렬화-형태를-사용하라">먼저 고민해보고 괜찮다고 판단될 때만 기본 직렬화 형태를 사용하라</h1><ul><li>기본 직렬화 형태는 유연성,  성능, 정확성, 측면에서 신중히 고민한 후 합당할 때만 사용해야 한다.</li><li>직접 설계하더라도 기본 직렬화 형태와 거의 같은 결과가 나올 경우에만 기본 형태를 써야 한다.</li><li>기본 직렬화 형태는 그 객체를 루트로 하는 객체 그래프의 물리적 모습을 나름 효율적으로 인코딩한다.</li><li>객체가 포함한 데이터들과 그 객체에서부터 시작해 접근할 수 있는 모든 객체를 담아내며 객체들이 연결된 위상(topology)까지 기술한다.</li><li>하지만 이상적인 직렬화 형태는 <strong>물리적인 모습과 독립된 논리적인 모습만을 표현해야 한다.</strong></li></ul><h1 id="객체의-물리적-표현과-논리적-내용이-같다면-기본-직렬화-형태라도-무방하다">객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 성. null이 아니어야함</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lastName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 이름. null이 아니어야 함.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String firstName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 중간이름. 중간이름이 없다면 null.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String middleName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>기본 직렬화 형태가 적합하다고 결정했더라고 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다.</li><li>Name의 3개의 필드는 private임에도 불구하고 문서화 주석이 달려있다.</li><li>이 필드들은 결국 클래스의 직렬화 형태에 포함되는 공개 API에 속하며 공개 API는 모두 문서화 해야 하기 때문이다.</li><li>private 필드의 설명을 API 문서에 포함하라고 자바독에 알려주는 역할은 @serial태그가 한다.</li><li>@serial 태그로 기술한 내용은 API 문서에서 직렬화 형태를 설명하는 특별한 페이지에 기록된다.</li></ul><h1 id="기본-직렬화-형태에-적합하지-않은-클래스">기본 직렬화 형태에 적합하지 않은 클래스</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Entry head = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        String data;</span><br><span class="line">        Entry next;</span><br><span class="line">        Entry previous;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>논리적으로는 이클래스는 일련의 문자열을 표현한다.<br>물리적으로는 문자열을 이중 연결 리스트로 연결했다. 이 클래스에 기본 직렬화 형태를 사용하면 각 노드의 양방향 연결 정보를 포함해 모든 엔트리(Entry)를 철두철미하게 기록한다.</p><h1 id="객체의-물리적-표현과-논리적-표현의-차이가-클-때-기본-직렬화-형태를-사용하는-경우-생기는-문제">객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하는 경우 생기는 문제</h1><h2 id="공개-api가-현재의-내부-표현-방식에-영구히-묶인다">공개 API가 현재의 내부 표현 방식에 영구히 묶인다.</h2><ul><li>앞의 예에서 private 클래스인 StringList.Entry가 공개 API가 되어버린다.</li><li>다음 릴리스에서 내부 표현 방식을 바꾸더라도 StringList 클래스는 여전히 연결 리스트로 표현된 입력도 처리할 수 있어야 한다.</li><li>즉 연결 리스트를 더 이상 사용하지 않더라도 관련 코드를 제거할 수 없다.</li></ul><h2 id="너무-많은-공간을-차지할-수-있다">너무 많은 공간을 차지할 수 있다.</h2><ul><li>앞 예의 직렬화 형태는 연결 리스트의 모든 엔트리와 연결 정보까지 기록했지만, 엔트리와 연결 정보는 내부 구현에 해당하니 직렬화 형태에 포함할 가치가 없다.</li><li>이처럼 직렬화 형태가 너무 커져서 디스크에 저장하거나 네트워크로 전송하는 속도가 느려진다.</li></ul><h2 id="시간이-너무-많이-걸릴-수-있다">시간이 너무 많이 걸릴 수 있다.</h2><ul><li>직렬화 로직은 객체 그래프의 위상에 관한 정보가 없으니 그래프를 직접 순회해볼 수밖에 없다.</li><li>앞의 예제는 간단히 다음 참조를 따라가 보는 정도로 충분하다.</li></ul><h2 id="스택-오버플로를-일으킬-수-있다">스택 오버플로를 일으킬 수 있다.</h2><ul><li>기본 직렬화 과정은 객체 그래프를 재귀 순회하는데 중간정도 크기의 객체 그래프에서도 스택 오버플로 에러가 날 수 있다.</li><li>그때그때 다른 시점에서 스택 오버플로가 날 수 있고, 어떤 플랫폼에서는 에러가 나지 않을 수도 있다.</li></ul><h1 id="합리적인-커스텀-직렬화-형태를-갖춘-stringlist">합리적인 커스텀 직렬화 형태를 갖춘 StringList</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry head = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 이제는 직렬화되지 않는다.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">        String data;</span><br><span class="line">        Entry next;</span><br><span class="line">        Entry previous;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 지정한 문자열을 이 리스트에 추가한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 이 &#123;<span class="doctag">@code</span> StringList&#125; 인스턴스를 직렬화한다.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> 이 리스트의 크기(포함된 문자열의 개수)를 기록한 후</span></span><br><span class="line"><span class="comment">     * (&#123;<span class="doctag">@code</span> int&#125;), 이어서 모든 원소를(각각은 &#123;<span class="doctag">@code</span> String&#125;)</span></span><br><span class="line"><span class="comment">     * 순서대로 기록한다.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//기본 직렬화를 수행한다.</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        s.writeInt(size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 커스텀 역직렬화를 수행한다.</span></span><br><span class="line">        <span class="comment">// 모든 원소를 올바른 순서로 기록한다.</span></span><br><span class="line">        <span class="keyword">for</span> (Entry e = head; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">            s.writeObject(e.data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//기본 역직렬화를 수행한다.</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        <span class="keyword">int</span> numElements = s.readInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 커스텀 역직렬화 부분</span></span><br><span class="line">        <span class="comment">// 모든 원소를 읽어 이 리스트에 삽입한다.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i++) &#123;</span><br><span class="line">            add((String) s.readObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>StringList의 필드 모두가 transient더라도 writeObject와 readObject는 각각 먼저 defaultWriteObject와 defaultReadObject를 호출한다.</p></li><li><p>클래스의 인스턴스가 모두 transient더라도 defaultWriteObject와 defaultReadObject를 호출해줘야 한다.<br>(향후 릴리즈에서 transient가 아닌 필드가 추가되더라도 상호 호환되기 때문이다)</p></li><li><p>신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화하면 새로 추가된 필드들은 무시될 것이다.</p></li><li><p>구버전 readObject 메서드에서 defaultReadObject를 호출하지 않는다면 역직렬화할 때 StreamCorruptedException이 발생할 것이다.</p></li><li><p>writeObject는 private 메서드임에도 문서화 주석이 달려 있다.<br>이 private 메서드는 직렬화 형태에 포함되는 공개 API에 속하며 공개 API는 모두 문서화 해야한다.</p></li><li><p>메서드에 달린 @serialData 태그는 자바독 유틸리티에게 이 내용을 직렬화 형태 페이지에 추가하도록 요청한다.</p></li><li><p>개선한 StringList는 원래버전의 절반정도의 공간을 차지하며 수행속도 또한 두 배 이상 빠르다.</p></li><li><p>개선한 StringList는 스택 오버플로 에러가 발생하지 않는다. (크기의 제한이 사라짐)</p></li><li><p>객체를 직렬화한 후 역직렬화하면 원래 객체를 그 불변식까지 포함해 제대로 복원해낸다는 점에서 정확하다 할 수 있다.</p></li><li><p>하지만 불변식이 세부 구현에 따라 달라지는 객체에서는 이 정확성마저 깨질 수 있다.</p></li></ul><h1 id="객체의-불변식이-깨지는-경우에는-직렬화를-주의해야한다">객체의 불변식이 깨지는 경우에는 직렬화를 주의해야한다.</h1><p>해시 테이블을 예로 생각해보면 이해할 수 있다.  해시 테이블은 물리적으로는 key-value 엔트리를 담은 해시 버킷을 차례로 나열한 형태다.<br>어떤 엔트리를 어떤 버킷에 담을지는 key에서 구한 hashcode가 결정하는데 <strong>그 계산 방식은 구현에 따라 달라질 수 있다.</strong><br>혹은 계산할 때마다 달라지기도 한다.<br>따라서 해시테이블을 직렬화한 후 역직렬화하면 불변식이 심각하게 훼손된 객체들이 생겨날 수 있는 것이다.</p><h1 id="객체의-논리적-상태와-무관한-필드라고-확신하면-transient-한정자를-생략하라">객체의 논리적 상태와 무관한 필드라고 확신하면 transient 한정자를 생략하라</h1><ul><li>기본 직렬화를 수용하든 하지 않든 defaultWriteObject 메서드를 호출하면 transient로 선언하지 않은 모든 인스턴스 필드가 직렬화된다.</li><li>따라서 transient로 선언해되 되는 인스턴스 필드에는 모두 transient를 붙여야 한다.</li><li>JVM을 실행할 때마다 값이 달라지는 필드도 transient를 붙여야 한다.</li><li>커스텀 직렬화 형태를 사용한다면 앞서의 StringList 처럼 대부분의(혹은 모든) 인스턴스 필드를 transient로 선언해야 한다.</li></ul><h1 id="동기화-메커니즘을-직렬화에도-적용해야-한다">동기화 메커니즘을 직렬화에도 적용해야 한다.</h1><p>모든 메서드를 synchronized로 선언하여 스레드 안전하게 만든 객체에서 기본 직렬화를 사용하려면<br>writeObject도 다음 코드 처럼 synchronized로 선언해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>writeObject 메서드 안에서 동기화 하고 싶다면 클래스의 다른 부분에서 사용하는 락 순서를 똑같이 따라야 한다.<br>그렇지 않으면 교착상태 (resource-ordering deadlock)에 빠질 수 있다.</p><h1 id="직렬-버전-uid를-명시적으로-부여하자">직렬 버전 UID를 명시적으로 부여하자</h1><p>어떤 직렬화 형태를 사용하든 직렬 가능 클래스에 모두 직렬 버전 UID를 명시적으로 부여하자.<br>이렇게 하면 직렬 버전 UID가 일으키는 잠재적인 호환성 문제가 사라진다.<br>성능도 조금 빨라지는데 직렬 버전 UID를 명시하지 않으면 런타임에 이 값을 생성하느라 복잡한 연산을 수행하기 때문이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">232923283928929</span>;</span><br></pre></td></tr></table></figure></p><p>위와 같은 형태로 사용하면 된다.<br>Intellij 에서는 alt+insert 단축키를 누르면 serialVersionUID를 자동으로 생성해 주는 메뉴가 있다.<br>기존 클래스를 구버전으로 직렬화된 인스턴스와 호환성을 유지한 채 사용하고 싶다면<br>기존 클래스를 구버전에서 사용한 자동 생성된 값을 그대로 사용해야 한다.</p><h2 id="주의할-점">주의할 점</h2><p><strong>직렬버전 UID는 클래스의 명세가 변경되면 자동 생성된 값이 바뀌기 때문에 이부분도 주의해야 한다.</strong><br>구버전과 호환이 되지 않아 역직렬화가 되지 않는다.<br>기존 버전의 직렬화된 인스턴스를 역직렬화할 때 InvalidClassException이 던져질 것이다.<br>구버전으로 직렬화된 인스턴스들과 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID를 절대 수정하면 안된다.</p><h1 id="정리">정리</h1><ul><li>클래스를 직렬화하기로 했다면 어떤 직렬화 형태를 사용할지 심사숙고 해야한다.</li><li>자바의 기본 직렬화 형태는 객체를 직렬화한 결과가 해당 객체의 논리적 표현에 부합할 때만 사용하고 그렇지 않으면 객체를 적절히 설명하는 커스텀 직렬화 형태를 고안해야 한다.</li><li>직렬화 형태도 공개 메서드를 설계할 때에 준하는 시간을 들여 설계 해야 한다.</li><li>한번 공개된 메서드는 향후 릴리즈에서 제거할 수 없듯이 직렬화 형태에 포함된 필드도 마음대로 제거할 수 없다.</li><li>직렬화 호환성을 유지하기 위해 영원히 지원해야 한다.</li><li>잘못된 직렬화 형태를 선택하면 해당 클래스의 복잡성과 성능에 영구히 부정적인 영향을 남긴다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 87. 커스텀 직렬화 형태를 고려해보라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/17/effective-java-item87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 79. 과도한 동기화는 피하라</title>
      <link>https://jaehun2841.github.io/2019/03/12/effective-java-item79/</link>
      <guid>https://jaehun2841.github.io/2019/03/12/effective-java-item79/</guid>
      <pubDate>Mon, 11 Mar 2019 15:28:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.&lt;br&gt;
&lt;strong&gt;응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.<br><strong>응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.</strong></p><ul><li>동기화(synchronized) 된 코드 블럭 안에서는 재정의 가능한 메서드를 호출해선 안된다.</li><li>클라이언트가 넘겨준 함수객체를 호출해서도 안된다.</li><li>이런 메서드는 동기화도니 클래스 관점에서 외계인 메서드(alien method)라고 칭한다.<br>(무슨일을 할지 모르니, 이 메서드가 예외를 발생시키거나, 교착상태를 만들거나, 데이터를 훼손시킬 수 있다.)</li></ul><h1 id="외계인-메서드">외계인 메서드</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ForwardingSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableSet</span><span class="params">(Set&lt;E&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserver&lt;E&gt;&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            observers.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">return</span> observers.remove(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">for</span>(SetObserver&lt;E&gt; observer : observers) &#123;</span><br><span class="line">                observer.added(<span class="keyword">this</span>, element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> added = <span class="keyword">super</span>.add(element);</span><br><span class="line">        <span class="keyword">if</span>(added) &#123;</span><br><span class="line">            notifyElementAdded(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> added;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : c) &#123;</span><br><span class="line">            result |= add(element); <span class="comment">//notifyElementAdded를 호출</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>관찰자들은 addObserver와 removeObserver 메서드를 호출해 구독을 신청하거나 해지한다.</li><li>두 경우 다음 콜백 인터페이스의 인스턴스를 메서드에 전달</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SetObserver</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//ObservableSet에 원소가 더해지면 호출된다.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet&lt;E&gt; set, E element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 인터페이스는 구조적으로 BiConsumer&lt;ObservableSet&lt;E&gt;,  E&gt;와 똑같다.</li><li>커스텀 함수형 인터페이스를 정의한 이유는 이름이 더 직관적이고 다중 콜백을 지원하도록 확장할 수 있기 때문이다.</li></ul><h1 id="외계인-메서드-예제1">외계인 메서드 - 예제1</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ObservableSet&lt;Integer&gt; set = <span class="keyword">new</span> ObservableSet&lt;&gt;(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    set.addObserver(<span class="keyword">new</span> SetObserver&lt;&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet&lt;Integer&gt; s, Integer e)</span> </span>&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            <span class="keyword">if</span>(e == <span class="number">23</span>) &#123;</span><br><span class="line">                s.removeObserver(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        set.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>s.removeObserver에 this를 넘겨야하는데 람다에서는 방법이 없으므로 익명클래스의 형태로 사용</li><li>이 프로그램은 0~23까지 출력한 후 Observer 자신을 구독해제 한 후 아무런 로그도 뜨지 않고 종료할 것 같다.</li><li>하지만 그렇지 않다. 프로그램은 0~23까지 출력한 후 <code>ConcurrentModificationException</code> 을 던진다.</li><li>왜냐하면 Observer의 added 메서드 호출이 일어난 시점이 notifyElementAdded가 Observer들의 리스트를 순회하는 도중이기 때문이다.</li><li>added 메서드 -&gt; ObservableSet.removeObserver를 호출 -&gt; observers.remove 호출</li><li>리스트에서 원소를 제거하려는데 마침 지금은 이 원소를 순회하는 중 <strong>(허용되지 않은 동작)</strong></li><li>notifyElementAdded 메서드에서 수행하는 순회는 동기화 블록 안에 있으므로 동시 수정이 일어나지 않지만<br>정작 자신이 콜백을 거쳐 되돌아와 수정하는 것을 막진 못한다.</li></ul><h1 id="외계인-메서드-예제-2">외계인 메서드 - 예제 2</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set.addObserver(<span class="keyword">new</span> SetObserver&lt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet&lt;Integer&gt; s, Integer e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">if</span>(e == <span class="number">23</span>) &#123;</span><br><span class="line">            ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                exec.submit(() -&gt; s.removeObserver(<span class="keyword">this</span>)).get(); <span class="comment">//여기서 lock이 걸려서 못들어감</span></span><br><span class="line">                <span class="comment">//하지만 메인 스레드는 너의 작업을 기다리고 있어</span></span><br><span class="line">            &#125; <span class="keyword">catch</span>(ExecutionException | InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(ex);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ul><li>이 프로그램을 실행하면 에러는 나진 않지만 교착상태(Dead-lock)에 빠진다.</li><li>백그라운드 스레드가 s.removeObserver를 호출하면 Observer를 잠그려 시도하지만 락을 얻을 수 없다.<br>(메인스레드가 이미 락을 쥐고 있기 때문 - removeObserver는 synchronized 키워드가 달려있어서 실행 시 락이 걸린다.)</li><li>그와 동시에 메인 스레드는 백그라운드 스레드가 Observer를 제거하기만을 기다리는 중이다.</li></ul><h1 id="교착상태-해결방법">교착상태 해결방법</h1><p>자바 언어의 락은 재진입(reentrant)을 허용하므로 교착상태에 빠지지는 않는다.<br>재진입 가능 락은 객체 지향 멀티스레드 프로그램을 쉽게 구현 할 수 있도록 해준다.<br>하지만 응답 불가(교착상태)가 될 상황을 안전 실패(데이터 훼손)으로 변모시킬 수도 있다.</p><p>이런 경우 외계인 메서드 호출을 동기화 블록 바깥으로 옮기면 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    List&lt;SetObserver&lt;E&gt;&gt; snapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(observers) &#123;</span><br><span class="line">        snapshot = <span class="keyword">new</span> ArrayList&lt;&gt;(observers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SetObserver&lt;E&gt; observer : snapshot) &#123;</span><br><span class="line">        observer.added(<span class="keyword">this</span>, element); <span class="comment">//외계인 메서드를 동기화 블록 바깥으로 옮겼다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="copyonwritearraylist">CopyOnWriteArrayList</h1><p>외계인 메서드 호출을 동기화 블록 바깥으로 옮기는 것 보다 더 나은 방법은 java.util.concurrent 패키지의 CopyOnWriteArrayList를 사용하는 것이 좋다.<br>내부를 변경하는 작업은 항상 깨끗한 복사본을 만들어 수행한다.<br>내부의 배열은 절대 수정되지 않아 락이 없어 빠르다.<br>다른 용도로 쓰인다면 매번 복사해서 느리겠지만, 수정할 일은 드물고 순회만 빈번히 일어나는 Observer 리스트 용으로는 딱이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserser&lt;E&gt;&gt; observers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observers.remove(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (SetObserver&lt;E&gt; observer : observers) &#123;</span><br><span class="line">         observers.added(<span class="keyword">this</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="동기화의-성능">동기화의 성능</h1><p>자바의 동기화 비용은 빠르게 낮아져 왔지만, 과도한 동기화를 피하는일은 오히려 과거 어느 때보다 중요하다.<br>멀티코어가 일반화된 오늘날 과도한 동기화가 초래하는 진짜 비용은 락을 얻는데 드는 CPU 시간이 아니다.<br>서로 스레드끼리 경쟁하는 Race Condition에 낭비가 발생한다.</p><ul><li>병렬로 실행할 기회를 잃는다.</li><li>모든 코어가 메모리를 일관되게 보기위한 지연시간이 진짜 비용</li><li>가상머신의 코드최적화를 제한하는 점도 숨은 비용</li></ul><h2 id="가변-클래스를-작성하는-경우-동기화에-대해-고려할-점">가변 클래스를 작성하는 경우 동기화에 대해 고려할 점</h2><ol><li>동기화를 전혀 하지 말고 가변 클래스를 동시에 사용해야하는 클래스가 외부에서 동기화하자</li><li>동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.<br>(단 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 두번째 방법을 쓴다)</li></ol><h1 id="정리">정리</h1><ul><li>기본 규칙은 동기화 영역에서 가능한 한 일을 적게하는 것이다.<br>(락을 얻고 공유 데이터를 검사하고, 필요하면 수정하고, 락을 놓는다.)</li><li>오래 걸리는 작업이라면 동기화 영역 밖으로 옮기는 방법을 찾아보자.</li><li>여러 스레드가 호출할 가능성이 있는 메서드가 정적 필드를 수정한다면 그 필드를 사용하기 전에 반드시 동기화 해야 한다.</li><li>교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자</li><li>동기화 영역 안에서 작업은 최소한으로 줄이자</li><li>가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자</li><li>지금은 과도한 동기화를 피하는게 제일 중요하다</li><li>합당한 이유가 있을때만 내부에서 동기화하고 동기화 여부를 문서에 남기자.<br>(웬만하면 외부에서 동기화를 하자)</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 79. 과도한 동기화는 피하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/12/effective-java-item79/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 78. 공유 중인 가변 데이터는 동기화해 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/11/effective-java-item78/</link>
      <guid>https://jaehun2841.github.io/2019/03/11/effective-java-item78/</guid>
      <pubDate>Mon, 11 Mar 2019 07:02:45 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;싱글 스레드 기반의 프로그램에서는 하나의 스레드가 하나의 객체를 사용하면 되기 때문에 동기화에 대한 걱정을 하지 않아도 되지만,&lt;br&gt;
멀티 스레드 기반의 환경에서는 여러개의 스레드가 하나의 객체를 공유해서 사
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>싱글 스레드 기반의 프로그램에서는 하나의 스레드가 하나의 객체를 사용하면 되기 때문에 동기화에 대한 걱정을 하지 않아도 되지만,<br>멀티 스레드 기반의 환경에서는 여러개의 스레드가 하나의 객체를 공유해서 사용하는 경우가 있다.<br>하나의 객체를 공유하며 사용하는 경우 불변 객체에 대해서는 동기화를 걱정할 필요가 없지만,<br>스레드가 메서드를 실행하면서 변수의 데이터를 변경하는 경우 다른 스레드에서 동기화되지 않은 데이터를 읽을 수 있다.<br>이런 경우에는 프로그래머가 기대한 결과와는 다른 결과를 초래할 수 있기 때문에 주의해야 한다.</p><h1 id="동기화란">동기화란?</h1><p>동기화(Syncronized)란 멀티스레드 환경에서 하나의 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장하는 것을 의미한다.</p><h2 id="동기화의-특징">동기화의 특징</h2><ul><li>한 객체가 일관된 상태를 가지고 생성되었을 때, 이 객체에 접근하는 메서드는 그 객체에 Lock을 건다.<br>(다른 스레드가 메서드를 실행할 때 실행되지 못하도록 Lock을 건다)</li><li>Lock을 건 메서드는 객체의 상태를 확인하거나 필요하면 수정한다.</li><li>즉 일관된 하나의 상태 -&gt; 다른 일관된 하나의 상태로 변화한다.</li><li>메서드 실행이 끝나면 Lock을 해제한다.</li><li>동기화를 제대로 사용하면 어떤 메서드도 이 객체의 상태가 일관되지 않은 순간을 볼 수 없다.</li><li><strong>동기화 없이는</strong> 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.<br>(동기화가 없다면, 너도나도 접근하는데 시점에 따라 일관된 상태가 아닐 수도 있기 때문)</li><li>언어 명세상 long과 double 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이다.<br>(여러 스레드가 하나의 변수에 동기화 없이 접근해도 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장)</li><li>성능을 높이려면 원자적 데이터를 읽고 쓸 때는 동기화 하지 말아야겠다 <strong>(위험한 발상)</strong><br>(필드를 읽을 때 항상 <strong>수정이 완전히 반영된 값</strong> 을 얻지만, <strong>한 스레드가 저장한 값이 다른 스레드에도 보이는가?</strong> 는 보장하지 않음)</li></ul><h1 id="java에서의-가변-데이터-동기화-방법">Java에서의 가변 데이터 동기화 방법</h1><p>Java에서는 <strong>synchronized</strong> 키워드를 통해 동기화 처리를 할 수 있다.</p><ul><li>가변데이터를 수정하거나 읽는 메서드를 동기화</li><li>가변 객체에 대한 동기화</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">countup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(list) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="한-스레드가-저장한-값이-다른-스레드에도-보이는가">한 스레드가 저장한 값이 다른 스레드에도 보이는가?</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread backgroundThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위의 코드는 대충 보면 1초뒤에 <code>stopRequested</code> 필드가 false로 바뀌면서 스레드 내의 while문이 종료될 것 처럼 보인다.</li><li>하지만 무한루프!!!</li><li>원인은 동기화에 있다.</li><li>동기화하지 않으면 메인 스레드에서 수정한 <code>stopRequested</code> 필드가 언제 false로 보일지 모른다.<br>(맨 마지막에 stopRequested가 false가 되면서 실제 원잣값은 false가 된다)</li><li>위의 문제를 해결하기 위해서는 <code>stopRequested</code> 필드에 대한 동기화 처리가 필요하다</li></ul><h2 id="동기화가-빠지는-경우-jvm에서-최적화를-수행할-수도-있다">동기화가 빠지는 경우 JVM에서 최적화를 수행할 수도 있다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//원래 코드</span></span><br><span class="line"><span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 최적화한 코드</span></span><br><span class="line"><span class="keyword">if</span>(!stopRequested) &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>JVM의 호이스팅 기법을 통해 최적화 할 수 있다.</li><li>이 결과 프로그램은 응답 불가 상태가 되어 더 이상 진전이 없다.</li></ul><h1 id="위의-코드를-동기화-해보자">위의 코드를 동기화 해보자</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">requestStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stopRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">stopRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stopRequested;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread backgroundThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested()) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위와 같이 <strong>stopRequested</strong> 필드의 읽기/쓰기에 대한 동기화처리를 하면 위의 프로그램이 1초뒤에 종료된다.</li><li>읽기/쓰기 메서드 모두 동기화 처리를 하였음에 주목하자</li><li>쓰기 메서드만 동기화처리를 하고 읽기 메서드에는 동기화처리를 하지 않으면 동작을 보장할 수 없다.</li></ul><h1 id="volatile-키워드">volatile 키워드</h1><p>volatile 키워드의 의미는 <code>volatile 변수를 읽어 들일 때 CPU 캐시가 아니라 컴퓨터의 메인 메모리로 부터 읽어들인다.</code><br>즉 read 할 때도 CPU 캐시가 아닌 메인메모리에서 read하고, write할 때도 메인 메모리에 write를 수행</p><p><img src="./java-volatile.png" alt="java-volatile"></p><p>long, double을 제외한 기본타입은 <strong>volitile</strong> 키워드를 사용하면 동기화를 생략해도 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread backgroundThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>volitile 예약어는 배타적 수행(한 블록을 한 스레드가 실행) 하는것과는 관계없다</li><li>volatile 변수는 CPU캐시에서 값을 읽는게 아닌 메인 메모리에서 읽기 때문에 항상 최근에 기록된 값을 읽는다.<br>(그렇기 때문에 위의 프로그램이 1초 뒤에 종료됨)</li></ul><h1 id="volatile-사용-시-주의할-점">volatile 사용 시 주의할 점</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> nextSerialNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">generateSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 메서드는 호출 될 때 마다 1씩 증가하여 스레드에서 고유한 값을 반환할 의도로 만들어 졌다.</li><li>겉보기에는 int이기 때문에 원자적으로 접근할 수 있을 것 같다</li><li>Volatile 키워드가 쓰여져있기 때문에 최신 값을 읽을 수 있을 것 같지만 제대로 된 고유한 값이 나오지 않는다.</li></ul><h2 id="원인은-nextserialnumber">원인은 nextSerialNumber++</h2><p>원인은 nextSerialNumber++에 있었다.<br>실제 이 코드는 1줄이지만 풀어쓰면 nextSerialNumber = nextSerialNumber + 1; 와 같은 형태이다.<br>결국 nextSerialNumber 값을 한번 읽어와 +1 한다음에 다시 nextSerialNumber 변수에 저장하는 형태이다.<br>만약 두번째 스레드가 nextSerialNumber + 1 연산이 이루어지는 시점을 비집고 들어온다면 1이 두번 리턴되는 형국이다.<br>이런 오류를 <strong>안전 실패(safety failure)</strong> 이라고 한다.</p><h2 id="문제-해결은-synchronized">문제 해결은 synchronized</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> nextSerialNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">generateSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 generateSerialNumber 메서드에 synchronized만 붙여주면 문제는 해결된다.<br>동시에 호출해도 배타적으로 실행 (한번에 한 스레드만 실행) 되기 때문이다.<br>만약 위 처럼 generateSerialNumber 메서드에 synchronized를 붙였다면 nextSerialNumber 변수에는 volatile을 제거해야 한다.<br>만약 메서드를 더 견고하게 하려면 int 대신 long을 사용하는게 더 많은 수를 사용할 수 있다.</p><h1 id="long-double을-사용할-때는-더욱-더-주의하자">long, double을 사용할 때는 더욱 더 주의하자</h1><ul><li>Java.util.concurrent.atomic 패키지의 AtomicLong, AtomicDouble을 사용하는 것이 좋다.</li><li>이 패키지는 락 없이도(lock-free) 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨 있다.</li><li>volatile은 동기화 속성 중 통신에 대해서만 보장</li><li>Java.util.concurrent.atomic 패키지는 원자성(배타적 실행) 까지 지원한다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextSerialNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">generateSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNum.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="정리">정리</h1><ul><li>동기화에 대한 문제를 피하는 가장 좋은 방법은 가변 데이터를 공유하지 않는 것이다.</li><li>가변데이터는 단일 스레드에서만 사용하는 것이 좋다</li><li>가변데이터를 단일 스레드에서만 사용한다면 문서에 남겨 유지보수 정책에서도 지켜지는것이 중요하다</li><li>멀티 스레드 환경에서 한 스레드가 데이터를 수정한 후에 다른 스레드에 공유할 때는 해당 객체에서 공유하는 부분만 동기화해도 된다.</li><li>클래스 초기화 과정에서 객체를 정적필드, volatile필드, final 필드, 혹은 보통의 락을 통해 접근하는 필드에 저장해도 된다.</li><li>여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 메서드 모두에 반드시 synchronized 키워드를 붙인다.</li><li>배타적 실행 (한번에 한스레드) 동작이 필요없고, 스레드 간 최신데이터만 읽는 거로도 충분하면 가변 변수에 volatile 키워드만으로도 동기화가 가능하다</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 78. 공유 중인 가변 데이터는 동기화해 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/11/effective-java-item78/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 74. 메서드가 던지는 모든 예외를 문서화하라</title>
      <link>https://jaehun2841.github.io/2019/03/10/effective-java-item74/</link>
      <guid>https://jaehun2841.github.io/2019/03/10/effective-java-item74/</guid>
      <pubDate>Sun, 10 Mar 2019 11:07:57 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;메서드가 던지는 예외는 그 메서드를 올바로 사용하는 데 아주 중요한 정보다.&lt;br&gt;
따라서 각 메서드가 던지는 예외 하나하나를 문서화하는 데 충분한 시간을 쏟아야 한다.&lt;/p&gt;
&lt;h1 id=&quot;검사-예외는-thr
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>메서드가 던지는 예외는 그 메서드를 올바로 사용하는 데 아주 중요한 정보다.<br>따라서 각 메서드가 던지는 예외 하나하나를 문서화하는 데 충분한 시간을 쏟아야 한다.</p><h1 id="검사-예외는-throws-태그로-문서화하라">검사 예외는 @throws 태그로 문서화하라</h1><p>검사 예외(Checked Exception)는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자.<br>공통 상위 예외 클래스 하나로 뭉뚱그려 선언하는 일은 삼가야 한다.<br>극단적인 예로 Exception이나 Throwable을 던진다고 선언해서는 안된다.<br>메서드 사용자에게 각 예외에 대처할 수 있는 힌트를 주지 못할뿐더러 같은 맥락에서 발생할 여지가 있는 다른 예외들 까지 삼켜버릴 수 있기 때문에 API 사용성을 크게 떨어뜨린다.</p><h2 id="잘못된-방법">잘못된 방법</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>같은 맥락에서 발생할 수 있는 다른 예외들까지 삼켜버려 API 사용성이 떨어진다.</li><li>main메서드는 JVM만이 호출하므로 Exception을 던지도록 선언해도 괜찮다.</li></ul><h2 id="권장하는-방법">권장하는 방법</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NumberFormatException - params가 숫자형 데이터가 아닌경우 throw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String params)</span> <span class="keyword">throws</span> IllegalStateException, SQLException, NumberFormatException </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="비검사-예외runtime-exception도-문서로-남기면-좋다">비검사 예외(Runtime Exception)도 문서로 남기면 좋다.</h1><p>자바 언어에서 요구하는 것은 아니지만 비검사 예외(Runtime Exception)도 검사 예외(Checked Exception) 처럼 정성껏 문서화 해두면 좋다.<br>비검사 예외(Runtime Exception)는 일반적으로 프로그래밍 오류를 뜻하는데 자신이 일으킬 수 있는 오류들이 무엇인지 알려주면<br>프로그래머는 자연스럽게 해당 오류가 나지 않도록 코딩하게 된다.<br>잘 정비된 비검사 예외 문서는 그 메서드를 성공적으로 수행하기 위한 전제조건이 된다.</p><p>public 메서드라면 필요한 전제조건을 문서화해야 하며, 그 수단으로 가장 좋은 것이 비검사 예외들을 문서화 하는것이다.<br><strong>특히 인터페이스에서 중요하다.</strong><br>이 조건이 인터페이스의 일반 규약에 속하게 되어 인터페이스를 구현한 모든 구현체가 일관되게 동작하도록 해주기 때문이다.</p><h1 id="비검사-예외runtime-exception은-메서드-시그니처에-추가하지-말자">비검사 예외(Runtime Exception)은 메서드 시그니처에 추가하지 말자</h1><p>메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.<br>검사냐 비검사냐에 따라 사용자가 해야할 일이 달라지므로 이 둘을 확실히 구분하는게 좋다.<br>자바독은 메서드 시그니처에 throws 절에 등장하고 메서드 주석의 @throws 태그에도 명시한 예외와 @throws 태그에만 명시한 예외를 시각적으로 구분해준다.<br>그래서 프로그래머는 어떤 것이 비검사 예외인지 바로 알 수 있다.</p><h1 id="거의-모든-메서드에서-같은-예외를-던진다면-class-설명에-추가하라">거의 모든 메서드에서 같은 예외를 던진다면 Class 설명에 추가하라</h1><p>한 클래스에 정의된 웬만한 메서드에서 같은 이유로 같은 예외를 던진다면 그 예외를 각각의 메서드가 아니라 클래스 설명에 추가하는 방법도 있다.<br>NullPointerException이 가장 흔한 사례다.<br>이럴 때는 클래스의 문서화 주석에 <strong>이 클래스의 모든 메서드는 인수로 null이 넘어오면 NullPointerException을 던진다.</strong> 라고 적어도 좋다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 74. 메서드가 던지는 모든 예외를 문서화하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/10/effective-java-item74/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 73. 추상화 수준에 맞는 예외를 던지라</title>
      <link>https://jaehun2841.github.io/2019/03/10/effective-java-item73/</link>
      <guid>https://jaehun2841.github.io/2019/03/10/effective-java-item73/</guid>
      <pubDate>Sun, 10 Mar 2019 10:31:02 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;수행하려는 일과 관련 없어 보이는 예외가 튀어나오면 당황스럽다.&lt;br&gt;
메서드가 저수준 예외를 처리하지 않고 바깥으로 throw 해버릴 때 상위 메서드에서 종종 발생하는 일이다.&lt;br&gt;
내부 구현방식을 상위에 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>수행하려는 일과 관련 없어 보이는 예외가 튀어나오면 당황스럽다.<br>메서드가 저수준 예외를 처리하지 않고 바깥으로 throw 해버릴 때 상위 메서드에서 종종 발생하는 일이다.<br>내부 구현방식을 상위에 드러내어 윗 레벨 API를 오염 시킬 수 있고, 다음 릴리스에서 구현방식이 변경되면 다른 예외가 튀어나와<br>기존 클라이언트 프로그램을 깨지게 할 수도 있다.</p><h1 id="상위-메서드에서-저수준-예외를-번역해야-한다">상위 메서드에서 저수준 예외를 번역해야 한다.</h1><p>상위 메서드에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다.<br>이를 예외 번역(Exception Translation)이라 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">..<span class="comment">// 저수준 추상화를 이용</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (LowerLevelException e) &#123;</span><br><span class="line">  <span class="comment">// 추상화 수준에 맞게 번역</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> HigherLevelException(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="저수준-예외의-내용이-필요하다면-예외-연쇄를-사용하라">저수준 예외의 내용이 필요하다면 예외 연쇄를 사용하라</h1><p>예외 연쇄(Exception chaining)이란 문제의 근본 원인(cause)인 저수준 예외를 고수준 예외에 실어 보내는 방식이다.<br>별도의 접근자 메서드(Throwable의 getCause메서드)를 통해 필요하면 언제든 저수준 예외를 꺼내 볼 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 저수준 추상화를 이용한다.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (LowerLevelException cause) &#123;</span><br><span class="line">  <span class="comment">// 저수준 예외를 고수준 예외에 실어 보낸다.</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> HigherLevelException(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HigherLevelException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">  HigherLevelException(Throwable cause) &#123;</span><br><span class="line">    <span class="keyword">super</span>(cause);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있다.<br>그렇지 않은 예외라도 Throwable의 initCause 메서드를 이용해 <code>원인</code> 을 직접 못박을 수 있다.<br>예외 연쇄는 문제의 원인을 프로그램에서 접근할 수 있게 해주며 원인과 고수준 예외의 Stack trace를 잘 통합해준다.</p><h1 id="예외-번역을-남용하지-말자">예외 번역을 남용하지 말자</h1><p>가능하다면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.<br>때로는 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 Validator를 이용하여 미리 검사하는 것이 좋다.</p><p>아래 계층에서의 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리하여 문제를 API 호출자에 전파하지 않는 방법이 있다.<br>이 경우 발생한 예외는 log를 활용하여 개발자가 디버깅을 할 수 있는 정도면 충분하다</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  lowerLevelMethod();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="comment">//Exception을 먹어버리고 상위로 전파되지 않도록 한다.</span></span><br><span class="line">  log.error(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="정리">정리</h1><ul><li>아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라</li><li>예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에  좋다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 73. 추상화 수준에 맞는 예외를 던지라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/10/effective-java-item73/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 72. 표준 예외를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/10/effective-java-item72/</link>
      <guid>https://jaehun2841.github.io/2019/03/10/effective-java-item72/</guid>
      <pubDate>Sun, 10 Mar 2019 09:58:11 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;숙련된 프로그래머는 그렇지 못한 프로그래머보다 더 많은 코드를 재사용한다.&lt;br&gt;
예외도 마찬가지로 재사용하는 것이 좋으며, 자바 라이브러리는 대부분 API에서 쓰기에 충분한 수의 예외를 제공한다.&lt;/p&gt;
&lt;h
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>숙련된 프로그래머는 그렇지 못한 프로그래머보다 더 많은 코드를 재사용한다.<br>예외도 마찬가지로 재사용하는 것이 좋으며, 자바 라이브러리는 대부분 API에서 쓰기에 충분한 수의 예외를 제공한다.</p><h1 id="표준-예외를-재사용하라">표준 예외를 재사용하라</h1><ul><li>표준 예외를 사용하면 다른사람이 API를 익히고 사용하기 쉬워진다 (많은 개발자들이 이미 익숙하게 사용하기 때문)</li><li>표준 예외를 사용한 API는 다른 개발자가 API를 사용하더라도 낯선 예외를 사용하지 않아 코드의 가독성이 높아진다.</li><li>예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스를 로딩하는 시간도 적게 걸린다.<br>(무분별하게 커스텀 예외 클래스를 만들면 빌드하는 시간도 오래 걸리고 클래스 로딩 시간도 더 걸린다는 소리)</li></ul><h1 id="가장-많이-사용되는-예외">가장 많이 사용되는 예외</h1><h2 id="illegalargumentexception">IllegalArgumentException</h2><ul><li>호출자가 인수로 부적절한 값을 넘길 때 던지는 예외</li><li>반복 횟수 (loop count)를 지정하는 매개변수에 음수를 건넬 때 쓸 수 있다.</li><li>메서드의 파라미터로 <code>null 값</code>이 들어오면 관례상 IllegalArgumentException보다는 <code>NullPointerException</code>을 던진다.</li><li>시퀀스의 허용 범위를 넘는 값을 건넬 때도 IllegalArgumentException보다는 <code>IndexOutOfBoundsException</code>을 던진다.</li></ul><h2 id="illegalstateexception">IllegalStateException</h2><ul><li>대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때 주로 던진다.</li><li>예를 들면, 초기화되지 않은 객체를 사용하려 할 때 던질 수 있다.</li></ul><h2 id="concurrentmodificationexception">ConcurrentModificationException</h2><ul><li>단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때 던진다.<br>(외부 동기화 방식으로 사용하려고 설계한 객체도 마찬가지다.)</li><li>동시 수정을 확실히 검출할 수 있는 안정된 방법은 없으나, 문제가 생길 가능성 정도만 알려주는 역할도 쓰인다.</li></ul><h2 id="unsupportedoperationexception">UnsupportedOperationException</h2><ul><li>예외는 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 던진다.</li><li>보통 구현하려는 인터페이스의 메서드 일부를 구현할 수 없는 경우에 사용</li></ul><h2 id="arithmeticexception-numberformatexception">ArithmeticException, NumberFormatException</h2><ul><li>복소수나 유리수를 다루는 객체를 사용할 때 사용</li><li>10 / 0 과 같은 연산을 할 때 ArithmeticException이 발생한다.</li><li>숫자형 파라미터가 와야 하는 부분에 String이라든지 다른 형식의 데이터가 들어오는 경우 NumberFormatException이 발생</li></ul><h1 id="예외-사용-시-주의할-점">예외 사용 시 주의할 점</h1><ul><li>Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자.<br>(다른 예외들의 상위 클래스이기 때문에 안정적으로 테스트 할 수 없다.)</li><li>예외에서 더 많은 정보를 제공하길 원한다면 표준 예외를 확장해도 좋다.<br>(단 예외는 직렬화할 수 있기 때문에 주의해야 한다.)</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 72. 표준 예외를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/10/effective-java-item72/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 68. 일반적으로 통용되는 명명 규칙을 따르라</title>
      <link>https://jaehun2841.github.io/2019/03/03/effective-java-item68/</link>
      <guid>https://jaehun2841.github.io/2019/03/03/effective-java-item68/</guid>
      <pubDate>Sun, 03 Mar 2019 10:12:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바 플랫폼은 명명 규칙이 잘 정립되어 있으며, 그중 많은 것이 자바 언어 명세에 기술되어 있다.&lt;br&gt;
자바의 명명 규칙은 철자와 문법 두 범주로 나뉜다.&lt;br&gt;
철자 규칙은 패키지, 클래스, 인터페이스, 메
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바 플랫폼은 명명 규칙이 잘 정립되어 있으며, 그중 많은 것이 자바 언어 명세에 기술되어 있다.<br>자바의 명명 규칙은 철자와 문법 두 범주로 나뉜다.<br>철자 규칙은 패키지, 클래스, 인터페이스, 메서드, 필드, 타입 변수의 이름을 다룬다.<br>이 규칙들은 특별한 이유가 없는 한 반드시 따르는게 좋고 이를 어기면 다른 프로그래머들이 그 코드를 읽기 번거로울 뿐 아니라 다른뜻으로 오해할 수도 있고 그로 인해 장애로 발전할 수 있다.</p><h1 id="명명-규칙">명명 규칙</h1><h2 id="패키지-package">패키지 (Package)</h2><ul><li>패키지 (Package)와 모듈 이름은 각 요소를 **점(.)**으로 구분하여 계층적으로 짓는다.</li><li>요소들은 모두 소문자 알파벳 혹은 숫자로 이뤄진다.</li><li>com.google, kr.co.edu와 같은 식이다.</li><li>패키지를 설명하는 하나이상의 요소로 이루어져 있다.</li><li>일반적으로 8자 이하의 짧은 단어로 한다.</li><li>utilities보다는 util처럼 의미가 통하는 약어가 좋다.</li><li>요소의 이름은 보통 한 단어 혹은 약어로 이루어진다.</li><li>많은 기능을 제공하는 애플리케이션의 경우에는 계층을 더 많은 요소로 나누는 것이 좋다.</li></ul><h2 id="클래스-인터페이스-열거타입">클래스, 인터페이스, 열거타입</h2><ul><li>클래스 명은 하나이상의 단어로 구성되며, 첫글자는 대문자로 작성한다.</li><li>여러 단어의 첫글자만 딴 약자나 널리 통용되는 줄임말을 제외하고는 줄임말을 쓰지 않도록 한다.</li><li>조합한 단어를 구분할 수 있게 <strong>camel case</strong>로 작성한다.</li></ul><h2 id="메서드-필드명">메서드, 필드명</h2><ul><li>첫 글자를 소문자로 작성하고 클래스 명과 같게 단어 별로 <strong>camel case</strong>로 작성한다.</li><li>첫 단어가 약자라면 단어 전체가 소문자여야 한다.</li><li>상수 필드는 예외다. 상수 필드를 구성하는 단어는 모두 대문자로 쓰며 단어 사이는 언더바(_)로 구분한다.<br>(VALUES, NEGATIVE_INFINITY등..)</li><li>상수 필드는 static final인 타입을 의미한다.</li><li>가르키는 객체가 불변이라면, 그 타입은 가변이어도 상수이다.</li><li>지역번수에도 동일한 규칙이 적용된다. 단, 문맥에서 의미를 쉽게 유추할 수 있는 경우에는 <strong>약어를 사용해도 좋다.</strong><br>(i, denom, houseNum등..)</li><li>타입 매개변수의 이름은 한 글자로 표현한다.<ul><li>T: 임의의 타입 (Type)</li><li>E: 컬렉션의 원소 (Element)</li><li>K: 맵의 키 (Key)</li><li>V: 맵의 값 (Value)</li><li>X: 예외 (eXception)</li><li>R: 메서드의 반환타입 (Return)</li><li>그 이외의 타입에는 T, U, V 혹은 T1, T2, T3의 식으로 사용</li></ul></li></ul><h1 id="명명-규칙2">명명 규칙2</h1><ul><li>객체를 생성하는 클래스나 열거타입 인터페이스는 <strong>단수 명사나 명사구를 사용한다.</strong><ul><li>Thread, PriorityQueue, ChessPiece 등..</li></ul></li><li>객체를 생성할 수 없는 클래스 (Utils 클래스)에는 보통 <strong>복수형 명사로 짓는다.</strong><ul><li>Collectors, Collections 등..</li></ul></li><li>인터페이스 이름은 클래스명과 동일하게 짓거나, <strong>ible, able로 끝나는 형용사로 짓는다.</strong><ul><li>Runnable, Iterable, Accessible 등...</li></ul></li><li>애너테이션은 워낙 다양하게 활용되어 지배적인 규칙이 없이 명사, 형용사, 동사, 전치사가 두루 쓰인다.<ul><li>@Binding, @Inject, @ImplementsBy, @Singleton 등..</li></ul></li><li>메서드의 이름은 동사나 목적어를 포함한 <strong>동사구로 짓는다.</strong><ul><li>append, drawImage</li></ul></li><li>boolean 값을 반환하는 메서드라면 <strong>is~, has~로 짓는다.</strong><ul><li>isDigit, isEmpty, hasSiblings 등..</li></ul></li><li>반환타입이 boolean이 아닌경우 보통 명사, 명사구, get~로 짓는다.<ul><li>size, hashcode, getTime 등...</li><li>get으로 시작하는 형태는 주로 자바빈즈(JavaBeans) 명세에 뿌리를 두고 있다.</li><li>보통 getter/setter의 한 묶음 형태로 만드는 경우가 많다.</li></ul></li><li>반환타입을 또다른 타입을 반환하는 경우에는<strong>toType</strong> 의 형태로 짓는다.<ul><li>toString, toArray 등..</li></ul></li><li>객체의 내용을 다른 뷰로 보여주는 메서드는 <strong>asType</strong> 의 형태로 짓는다.<ul><li>asList, asMap 등..</li></ul></li><li>객체의 값을 기본 타입(primitive type)으로 반환하는 경우에는 <strong>typeValue</strong> 의 형태로 짓는다.<ul><li>intValue, longValue 등...</li></ul></li><li>정적 팩터리의 이름은 다양하다<ul><li>from, valueOf, getInstance, newInstance 등..</li></ul></li></ul><h1 id="정리">정리</h1><ul><li>표준 명명 규칙을 체득하여 자연스럽게 사용하도록 연습하자</li><li>철자 규칙은 직관적이라 모호한 부분이 적지만, 문법 규칙은 더 복잡하고 느슨하다</li><li>오랫동안 따라온 규칙과 충돌한다면 그 규칙을 맹종해서는 안된다. 상식대로 가자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 68. 일반적으로 통용되는 명명 규칙을 따르라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/03/effective-java-item68/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 67. 최적화는 신중히 하라</title>
      <link>https://jaehun2841.github.io/2019/03/03/effective-java-item67/</link>
      <guid>https://jaehun2841.github.io/2019/03/03/effective-java-item67/</guid>
      <pubDate>Sun, 03 Mar 2019 09:49:08 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;최적화에-대한-명언&quot;&gt;최적화에 대한 명언&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;맹목적인 어리석음을 포함해 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다 (심지어 효율을 높이지도 못하면서)&lt;/p&gt;
&lt;p&gt;- 윌리엄 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="최적화에-대한-명언">최적화에 대한 명언</h1><blockquote><p>맹목적인 어리석음을 포함해 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다 (심지어 효율을 높이지도 못하면서)</p><p>- 윌리엄 울프(Wulf72)</p></blockquote><blockquote><p>(전체의 97% 정도인) 자그마한 효율성은 모두 잊자. 섣부른 최적화가 만약의 근원이다. - 도널드 크누스(Knuth74)</p></blockquote><blockquote><p>최적화를 할 때는 다음 두 규칙을 따르라.</p><p>첫 번째, 하지마라.<br>두 번째, (전문가 한정) 아직 하지 마라. 다시 말해, 완전히 명백하고 최적화되지 않은 해법을 찾을 때까지는 하지 마라.<br>- M.A 잭슨 (Jackson75)</p></blockquote><p>위의 명언들을 풀어보면,<br>최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고 섣불리 진행하면 특히 더 그렇다.<br>빠르지도 않고 제대로 동작하지도 않으면서 수정하기는 어려운 소프트웨어를 탄생시키는 것이다.</p><h1 id="프로그램을-설계할-때-생각해야-할-점">프로그램을 설계할 때 생각해야 할 점</h1><h2 id="빠른-프로그램보다는-좋은-프로그램을-작성하자">빠른 프로그램보다는 좋은 프로그램을 작성하자</h2><ul><li>좋은 프로그램이지만 원하는 성능이 나오지 않는다면 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것이다.</li><li>좋은 프로그램은 정보 은닉(캡슐화) 원칙을 따르므로 개별 구성요소 내부를 독립적으로 설계할 수 있다.</li><li>따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다.</li><li>구현상의 문제는 나중에 최적화 할 수 있지만, 아키텍처의 결함이 성능을 제한한다면 시스템을 다시 작성해야 하기 때문이다.</li><li>따라서 설계 단계에서 성능을 반드시 염두하자</li></ul><h2 id="성능을-제한하는-설계를-피하라">성능을 제한하는 설계를 피하라</h2><ul><li>완성 후 변경하기가 가장 어려운 설계 요소는 컴포넌트끼리 또는 외부 시스템과의 소통 방식이다.</li><li>API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등이 있다.</li><li>완성후에는 변경하기 어렵거나 불가능 하고, 동시에 시스템 성능을 제한할 수 있다.</li></ul><h2 id="api를-설계할-때-성능에-주는-영향을-고려하라">API를 설계할 때 성능에 주는 영향을 고려하라</h2><ul><li>가변 객체를 사용하여 내부데이터를 변경할 수 있게 만들면 불필요한 방어적 복사를 유발할 수 있다.</li><li>컴포지션으로 해결할 수 있는 경우에도 상속을 이용하면 상위클래스에 영원히 종속되고, 성능 제약까지 물려받는다</li><li>인터페이스도 있는데 굳이 클래스 타입으로 사용하면, 차후 개선된 구현체를 사용하기 어려워진다.</li></ul><h2 id="성능을-위해-api를-왜곡하지-말자">성능을 위해 API를 왜곡하지 말자</h2><ul><li>API를 왜곡하도록 만든 성능 문제는 해당 플랫폼이나 아랫단 소프트웨어의 다음 버전에서 사라질 수 있다.</li><li>왜곡된 API를 지원하는 데 따르는 고통은 영원하다</li></ul><h2 id="프로파일링-도구를-적극-활용하자">프로파일링 도구를 적극 활용하자</h2><ul><li>프로파일링 도구는 최적화 노력을 어디에 집중해야 할지 찾는 데 도움을 준다.</li><li>개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 제공하여 개발자의 수고를 덜어준다.</li><li>JMH도 알아야 하는 도구이다.  프로파일러는 아니지만 자바 코드의 상세한 성능을 알기 쉽게 보여주는 마이크로 벤치마킹 프레임워크다.</li></ul><h1 id="정리">정리</h1><ul><li>빠른프로그램을 작성하려 하지 말고 좋은 프로그램을 작성하려 노력하자. 성능은 따라오기 마련이다.</li><li>시스템을 설계할 때 API, 네트워크 프로토코르 영구 저장용 데이터 포맷을 설계할 때는 성능을 염두하자</li><li>시스템 구현을 완료했으면 측정해보고 충분히 빠르면 최적화를 하지 마라</li><li>성능 측정 시에는 프로파일링 도구를 이용해 문제의 원인이 되는 지점을 찾아 최적화하자</li><li>알고리즘을 잘못 골랐다면, 저수준 최적화는 의미가 없다.</li><li>만족할 만한 성능이 나올 때까지 위의 과정을 반복하고, 변경 후에는 성능 측정을 꼭하자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 67. 최적화는 신중히 하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/03/effective-java-item67/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 66. 네이티브 메서드는 신중히 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/03/effective-java-item66/</link>
      <guid>https://jaehun2841.github.io/2019/03/03/effective-java-item66/</guid>
      <pubDate>Sun, 03 Mar 2019 09:09:15 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바 네이티브 인터페이스(Java Native Interface, JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;네이티브 메서드란?&lt;/p&gt;
&lt;p&gt;C나 C++
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바 네이티브 인터페이스(Java Native Interface, JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다.</p><blockquote><p>네이티브 메서드란?</p><p>C나 C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다.</p></blockquote><h1 id="네이티브-메서드의-주요-쓰임">네이티브 메서드의 주요 쓰임</h1><ul><li>Registry 같은 플랫폼 특화기능을 사용한다.<ul><li>하지만 자바가 진화해가면서 하부 플랫폼의 기능을 흡수하고 있다.</li><li>네이티브 메서드를 사용해야하는 일이 줄어들고 있다.</li><li>자바9 부터는 process API를 추가해 OS에 접근하는 길을 열어주었다.</li></ul></li><li>네이티브 코드로 작성된 기존 라이브러리를 사용해야 하는 경우<ul><li>레거시 데이터를 사용하는 레거시 라이브러리</li><li>Java로 된 라이브러리가 없는 경우 네이티브 라이브러리를 사용한다.</li></ul></li><li>성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.</li></ul><h1 id="네이티브-메서드를-성능개선의-목적으로-사용하지-말라">네이티브 메서드를 성능개선의 목적으로 사용하지 말라</h1><ul><li>자바 초기 시절 (Java 1.3)이전이라면 다른 얘기지만, 그동안 JVM은 빠른 속도로 발전해 왔다.</li><li>대부분의 작업에서 Java는 다른 플랫폼과 견줄만한 성능을 보인다 (자바가 느리다는 것도 옛말)</li><li>네이티브 라이브러리 쪽은 GNU 다중 정밀 연산 라이브러리(GMP)를 필두로 개선 작업이 계속돼왔다.<br>고성능의 다중 정밀 연산이 필요한 경우에는 네이티브 메서드를 통해 GMP를 사용하는것을 고려해보자</li></ul><h1 id="네이티브-메서드의-단점">네이티브 메서드의 단점</h1><ul><li>네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로 부터 안전하지 않다.</li><li>네이티브 언어는 플랫폼 종속성이 있으므로 이식성이 좋지 못하다</li><li>디버깅도 어렵다</li><li>오히려 속도가 더 느릴 수 있다.</li><li>JVM의 가비지 컬렉터는 네이티브 메모리는 자동 회수 하지 못하고 추적도 할 수 없다.</li><li>자바 코드와 네이티브 코드의 경계를 넘나 들때마다 비용이 발생한다.</li><li>자바 코드와 네이티브 코드간의 접착 코드(glue code)를 작성해야 하는데 이 부분도 귀찮고 가독성도 떨어진다.</li></ul><h1 id="정리">정리</h1><ul><li><p>네이티브 메서드를 사용하는 경우는 한번 더 생각하라</p></li><li><p>네이티브 메서드가 그렇게 성능 향상에 도움을 주지는 않는다.</p></li><li><p>네이티브 메서드를 사용해야 하는 경우에는 최소한으로 사용하고 철저한 테스트를 해야한다.</p></li><li><p>숨은 버그하나가 애플리케이션 전체에 영향을 줄 수도 있다.</p></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 66. 네이티브 메서드는 신중히 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/03/effective-java-item66/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 65. 리플렉션보다는 인터페이스를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/03/effective-java-item65/</link>
      <guid>https://jaehun2841.github.io/2019/03/03/effective-java-item65/</guid>
      <pubDate>Sun, 03 Mar 2019 07:57:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;리플렉션 기능(java.lang.reflect)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.&lt;br&gt;
Class 객체가 주어지면 클래스 정보를 통해 아래와 같은 인스턴스를 가져올 수 있다.&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>리플렉션 기능(java.lang.reflect)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.<br>Class 객체가 주어지면 클래스 정보를 통해 아래와 같은 인스턴스를 가져올 수 있다.</p><ul><li>Constructor<ul><li>생성자 시그니처를 가져올 수 있다.</li><li>생성자 인스턴스를 통해 객체를 생성할 수 있다.</li></ul></li><li>Method<ul><li>Method 시그니처를 가져올 수 있다.</li><li>Method 인스턴스를 통해 Method를 실행시킬 수 있다. (Method.invoke)</li></ul></li><li>Field<ul><li>필드타입, 멤버필드 이름등을 가져올 수 있다.</li></ul></li></ul><h1 id="리플렉션의-단점">리플렉션의 단점</h1><p>리플렉션을 이용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있다.<br>(예를들면.. 외부 라이브러리의 클래스를 리플렉션으로 인스턴스를 생성한다든지…)</p><h2 id="컴파일타임-타입-검사가-주는-이점을-누릴-수-없다">컴파일타임 타입 검사가 주는 이점을 누릴 수 없다.</h2><ul><li>예외 검사, 컴파일 타임 에러를 잡아낼 수 없다.</li><li>프로그램이 리플렉션 기능을 써서 존재하지 않는 혹은 접근 불가능한 (private 메서드)를 호출하려 하면 런타임 오류가 발생한다.</li></ul><h2 id="리플렉션을-이용하면-코드가-지저분하고-장황해진다">리플렉션을 이용하면 코드가 지저분하고 장황해진다.</h2><ul><li>지루한 일이고 읽기도 어렵다.</li></ul><h2 id="성능이-떨어진다">성능이 떨어진다.</h2><ul><li>리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느리다.</li><li>고려해야 하는 요소가 많아 정확한 차이는 이야기하기 어렵다</li><li>하지만 분명 느리다.</li></ul><h2 id="리플렉션은-아주-제한된-형태로만-사용해야-그-단점을-피할-수-있다">리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피할 수 있다</h2><ul><li>컴파일타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램은 비록 컴파일타임이라도 적절한 인터페이스나 상위 클래스를 이용할 수는 있을것이다.</li><li>리플렉션은 인스턴스 생성에만 쓰고 이렇게 만든 인터페이스나 상위 클래스로 참조해 사용하자</li></ul><h1 id="리플렉션의-취약한-예">리플렉션의 취약한 예</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 클래스 이름을 Class 객체로 변환</span></span><br><span class="line">    Class&lt;? extends Set&lt;String&gt;&gt; cl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = (Class&lt;? extends Set&lt;String&gt;&gt;) Class.forName(args[<span class="number">0</span>]); <span class="comment">//비검사 형변환</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"클래스를 찾을 수 없습니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생성자를 얻는다.</span></span><br><span class="line">    Constructor&lt;? extends Set&lt;String&gt;&gt; cons = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cons = cl.getDeclaredConstructor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"매개변수 없는 생성자를 찾을 수 없습니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//집합의 인스턴스를 만든다.</span></span><br><span class="line">    Set&lt;String&gt; s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        s = cons.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"생성자에 접근할 수 없습니다."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"클래스를 인스턴스화할 수 없습니다."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"생성자가 예외를 던졌습니다: "</span> + e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"Set을 구현하지 않은 클래스입니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//생성한 집합을 사용한다.</span></span><br><span class="line">    s.addAll(Arrays.asList(args).subList(<span class="number">1</span>, args.length));</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fatalError</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.err.println(msg);</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 예시는 리플렉션의 단점을 보여준다.</p><ul><li>런타임에 총 6가지의 예외를 던질 수 있다.</li><li>위에서 발생하는 예외는 모두 컴파일타임에 체크할 수 있는 예외들이다.</li><li>클래스 이름만으로 인스턴스를 생성해내기 위해 무려 25줄이나 되는 코드를 작성했지만, 그게 아닌 경우에는 생성자 1줄이면 끝난다.</li><li>리플렉션 예외를 각각 잡는 대신 상위 클래스인 ReflectiveOperationException을 잡으면 코드량을 줄일 수 있다.<br>(ReflectiveOperationException은 Java 7부터 지원한다.)</li></ul><h1 id="리플렉션은-무조건-쓰지-말아야-한다">리플렉션은 무조건 쓰지 말아야 한다?</h1><ul><li>Spring MVC, Serialize/Deserialize, BeanUtils.copyProperties등 실무에서 사용하는 코드에 리플렉션이 적용된 예는 굉장히 많다.</li><li>단점이 많다고는 하지만 공통적인 기능을 설계하거나, 재사용 가능한 코드를 설계할 경우에는 오히려 리플렉션이 적합할 수 있다.</li><li>그렇기 때문에 Java 1.3 이후부터 리플렉션에 대한 성능향상을 발전시켜왔다고 한다.</li><li>이러한 발전으로 리플렉션은 우려할 만큼 성능이 떨어지지는 않는다고 한다.</li><li>리플렉션을 남발하는 것이 아닌 필요한 상황에 적시적소에 사용한다면 오히려 서비스 개발을 더 단순화 시킬수 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 65. 리플렉션보다는 인터페이스를 사용하라</li><li><a href="https://kmongcom.wordpress.com/2014/03/15/%EC%9E%90%EB%B0%94-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%A4%ED%95%B4%EC%99%80-%EC%A7%84%EC%8B%A4/" target="_blank" rel="noopener">Java 리플렉션의 오해와 진실</a></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/03/effective-java-item65/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 64. 객체는 인터페이스를 사용해 참조하라</title>
      <link>https://jaehun2841.github.io/2019/03/01/effective-java-item64/</link>
      <guid>https://jaehun2841.github.io/2019/03/01/effective-java-item64/</guid>
      <pubDate>Fri, 01 Mar 2019 12:33:55 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Item 51에 제네릭 타입으로 클래스가 아니라 인터페이스를 사용하라고 설명 되어있다.&lt;br&gt;
이 말의 의미는 &lt;strong&gt;객체는 클래스가 아닌 인터페이스로 참조하라&lt;/strong&gt; 라는 의미로 확장할 수 있
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Item 51에 제네릭 타입으로 클래스가 아니라 인터페이스를 사용하라고 설명 되어있다.<br>이 말의 의미는 <strong>객체는 클래스가 아닌 인터페이스로 참조하라</strong> 라는 의미로 확장할 수 있다.<br>적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언해야 한다.</p><h1 id="유연한-프로그램을-생성하는-인터페이스-타입-변수">유연한 프로그램을 생성하는 인터페이스 타입 변수</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//좋은 예</span></span><br><span class="line">Set&lt;Son&gt; sonSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//나쁜 예</span></span><br><span class="line">LinkedHashSet&lt;Son&gt; sonSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br></pre></td></tr></table></figure></p><ul><li>좋은 예는 Set 인터페이스 타입으로 변수를 선언하였다.</li><li>나쁜 예는 LinkedHashSet 타입으로 변수를 선언하였다.</li></ul><p>만약 LinkedHashSet을 TreeSet으로 변환해야 한다면 어떨까?</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//좋은 예</span></span><br><span class="line">Set&lt;Son&gt; sonSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//나쁜 예</span></span><br><span class="line">LinkedHashSet&lt;Son&gt; sonSet = <span class="keyword">new</span> TreeSet&lt;&gt;(); <span class="comment">//컴파일 에러!</span></span><br></pre></td></tr></table></figure></p><ul><li>위의 좋은 예는 Set 인터페이스 타입이기 때문에 컴파일 타임/런타임에 전혀 문제가 되지 않는다.</li><li>나쁜 예는 LinkedHashSet 타입이기 때문에 TreeSet을 LinkedHashSet로 형변환 할 수 없다고 에러가 발생한다.</li></ul><h1 id="인터페이스-타입의-장점">인터페이스 타입의 장점</h1><ul><li>인터페이스 타입을 사용하면 클라이언트 코드를 수정하지 않고도 참조 객체를 변경할 수 있다.</li><li>다른 타입의 객체를 사용하더라도 컴파일에러/런타임에러에 대한 걱정을 하지 않아도 된다.</li></ul><h1 id="인터페이스-타입의-단점">인터페이스 타입의 단점</h1><ul><li>인터페이스 타입에 선언된 메서드를 구현한 메서드만 사용이 가능하다.</li><li>특정 구현체의 내부 메서드를 사용할 수 없다.</li></ul><h1 id="클래스를-참조해야-하는-경우">클래스를 참조해야 하는 경우</h1><h2 id="값-타입에는-클래스를-참조하라">값 타입에는 클래스를 참조하라</h2><ul><li>String, Integer, Long과 같이 값 타입에 대해서는 인터페이스를 사용할 수 없으니 클래스를 참조해야 한다.</li><li>또한 Integer, Long과 같은 타입을 사용할 때는 Number와 같은 상위 타입을 사용하지 말아야 한다.<br><strong>형변환이 발생 할 때 특정 데이터가 절삭되어 다른 결과가 발생 할 수 있기 때문이다.</strong></li><li>이런 경우에는 인터페이스나 상위타입 보다는 본래의 클래스로 참조하는 것이 좋다.</li></ul><h2 id="인터페이스에는-없는-메서드를-사용할-때에는-클래스를-참조해라">인터페이스에는 없는 메서드를 사용할 때에는 클래스를 참조해라</h2><ul><li>PriorityQueue 클래스에는 Queue 인터페이스에는 없는 comparator 메서드를 제공한다.</li><li>클래스 타입을 직접 사용하는 경우에는 추가 메서드를 사용해야 하는 경우로 최소화 하는 것이 좋다.</li></ul><h1 id="정리">정리</h1><ul><li>인터페이스나 추상클래스를 구현하는 클래스를 사용할 때는 참조 변수를 인터페이스나 추상클래스로 사용하자</li><li>인터페이스나 추상클래스 타입으로 참조 변수를 사용하면 참조 객체를 바꿔도 안전하다</li><li>값 타입을 사용하는 경우에는 클래스 타입의 참조변수를 사용해야 한다.</li><li>인터페이스에는 없는 메서드를 사용할 때는 클래스 타입의 참조변수를 사용해야 한다.</li><li>적합한 인터페이스가 없다면 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 상위 타입을 사용해야 한다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 64. 객체는 인터페이스를 사용해 참조하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/01/effective-java-item64/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 63. 문자열 연결은 느리니 주의하라</title>
      <link>https://jaehun2841.github.io/2019/03/01/effective-java-item63/</link>
      <guid>https://jaehun2841.github.io/2019/03/01/effective-java-item63/</guid>
      <pubDate>Fri, 01 Mar 2019 11:45:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;문자열 연결 연산자(+)는 여러 문자열을 하나로 합쳐주는 편리한 수단이다.&lt;br&gt;
그런데 한 줄짜리 출력값(&lt;code&gt;return prefix + str + suffix;&lt;/code&gt; 정도?)  혹은 작고 크기
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>문자열 연결 연산자(+)는 여러 문자열을 하나로 합쳐주는 편리한 수단이다.<br>그런데 한 줄짜리 출력값(<code>return prefix + str + suffix;</code> 정도?)  혹은 작고 크기가 고정된 객체의 문자열 표현을 만들 때라면 괜찮다.<br>하지만 문자열 여러개를 사용하기 시작하면 성능 저하를 피할 수 없다.</p><p><strong>문자열 연결 연산자로 문자열 n개를 연결하는 시간은 n^2에 비례한다.</strong><br>문자열은 불변이기 때문에 두 문자열을 연결하는 경우에는 양쪽의 내용을 복사하여 연결한 다음 새로운 String 객체를 만들어야 하기 때문이다.</p><h1 id="문자열-연결을-잘못-사용한-예-느리다">문자열 연결을 잘못 사용한 예 - 느리다!</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numItems(); i++) &#123;</span><br><span class="line">        result += lineForItem(i); <span class="comment">//문자열 연결</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="stringbuilder를-사용하여-문자열을-연결한-예">StringBuilder를 사용하여 문자열을 연결한 예</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">statement2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(numItems() * LINE_WIDTH);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numItems(); i++) &#123;</span><br><span class="line">       sb.append(lineForItem(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>자바 6이후 문자열 연결 성능을 다방면으로 개선 했지만, 두 메서드의 성능 차이는 여전하다.</p><h1 id="string-stringbuffer-stringbuilder의-비교">String, StringBuffer, StringBuilder의 비교</h1><ul><li>String과 StringBuffer는 Java 1.0의 등장과 함께 같이 등장하였다.</li><li>StringBuilder는 조금 뒤인 Java 1.5부터 등장하였다.</li><li>String의 concat연산은 + 기호를 사용하여 concatination을 수행한다.</li><li>StringBuffer와 StringBuilder는 append 메서드를 통해 concatination을 수행한다.</li><li>정확히 말하면 StringBuffer와 StringBuilder는 AbstractStringBuilder를 상속하고 있으며,<br>결국은 같은 append 메서드를 사용한다.</li><li>StringBuffer와 StringBuilder 차이점은 thread-safe에 있다.<ul><li>StringBuffer의 append 메서드에는 <code>syncronized</code> 예약어가 붙어있어 thread-safe하다</li><li>StringBuilder의 append 메서드는 thread-safe 하지 않다.</li><li>따라서 multi-thread 환경에서 문자열 결합을 할 때는 StringBuffer를 사용하는 것이 안전하다.</li><li>단일 thread라면 StringBuilder를 사용하는 것이 StringBuffer보다 성능이 더 좋다.<br>(아무래도 동기화 체크를 안해도 되니 말이다.)</li></ul></li></ul><h2 id="string-string-연산이-느린-이유">String + String 연산이 느린 이유</h2><ul><li>String은 불변 클래스이기 때문에 String + String을 하기 위해서는</li><li>String내의 char[] 혹은 byte[]를 copy한다.</li><li>2개의 array의 length를 더한 값으로 새로운 array를 생성한다.</li><li>array에 기존의 값을 채워넣는다.</li><li>new String(byte[]) 생성자를 통해 새로운 String 객체를 생성한다.</li><li>이런식으로 하면 String + String 연산이 일어날 때마다 String 객체가 생성된다.</li><li>Heap Memory에 String 객체가 많아지면 GC가 돌면서 String 객체를 제거한다.</li><li>GC는 동작 시 stop the world라는 행위를 한다. <strong>(JVM의 작동이 일시적으로 멈춘다.</strong>)</li><li>위와 같은 행위가 계속되면 당연히 느려 질 수 밖에 없다.</li></ul><h2 id="stringbuilderappend-메서드-파헤치기">StringBuilder.append() 메서드 파헤치기</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified string to this character sequence.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The characters of the &#123;<span class="doctag">@code</span> String&#125; argument are appended, in</span></span><br><span class="line"><span class="comment">     * order, increasing the length of this sequence by the length of the</span></span><br><span class="line"><span class="comment">     * argument. If &#123;<span class="doctag">@code</span> str&#125; is &#123;<span class="doctag">@code</span> null&#125;, then the four</span></span><br><span class="line"><span class="comment">     * characters &#123;<span class="doctag">@code</span> "null"&#125; are appended.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Let &lt;i&gt;n&lt;/i&gt; be the length of this character sequence just prior to</span></span><br><span class="line"><span class="comment">     * execution of the &#123;<span class="doctag">@code</span> append&#125; method. Then the character at</span></span><br><span class="line"><span class="comment">     * index &lt;i&gt;k&lt;/i&gt; in the new character sequence is equal to the character</span></span><br><span class="line"><span class="comment">     * at index &lt;i&gt;k&lt;/i&gt; in the old character sequence, if &lt;i&gt;k&lt;/i&gt; is less</span></span><br><span class="line"><span class="comment">     * than &lt;i&gt;n&lt;/i&gt;; otherwise, it is equal to the character at index</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;k-n&lt;/i&gt; in the argument &#123;<span class="doctag">@code</span> str&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   str   a string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a reference to this object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    putStringAt(count, str);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위의 코드는 AbstractStringBuilder의 append 메서드이다.</li><li>새로운 String의 길이 만큼 AbstractStringBuilder의 내의 byte[]의 사이즈를 늘리고 복사한다.</li><li>그 다음 String에 대한 byte[]를 AbstractStringBuilder의 내의 byte[]에 추가한다.</li><li>String + String 연산과의 차이점은 불필요한 String 객체가 발생하지 않는다는 점이다</li></ul><h1 id="string-concatination의-발전">String Concatination의 발전</h1><ul><li>Java String 연산에 대한 성능최적화를 다방면으로 생각하고 있고, Java 9 부터 String의 내부 배열을<br><strong>char[] -&gt; byte[]로 변경</strong>하여 성능을 더 향상 시켰다.</li><li>Java 1.5 버전부터 String + String연산에 대해 <strong>Compile Time에 StringBuilder를 사용하도록 코드를 변경한다.</strong><br>하지만 JDK가 항상 자동으로 바꿔준다는 보장이 없으니 String + String 보다는 StringBuilder를 사용해야 한다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 63. 문자열 연결은 느리니 주의하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/01/effective-java-item63/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 62. 다른 타입이 적절하다면 문자열 사용을 피하라</title>
      <link>https://jaehun2841.github.io/2019/03/01/effective-java-item62/</link>
      <guid>https://jaehun2841.github.io/2019/03/01/effective-java-item62/</guid>
      <pubDate>Fri, 01 Mar 2019 10:53:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;문자열(String)은 텍스트를 표현하도록 설계되었고, 그 일을 아주 멋지게 해낸다.&lt;br&gt;
그런데 문자열은 워낙 흔하고 자바가 또 잘 지원해주어 원래 의도하지 않는 용도로도 쓰이는 경향이 있다.&lt;/p&gt;
&lt;h1
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>문자열(String)은 텍스트를 표현하도록 설계되었고, 그 일을 아주 멋지게 해낸다.<br>그런데 문자열은 워낙 흔하고 자바가 또 잘 지원해주어 원래 의도하지 않는 용도로도 쓰이는 경향이 있다.</p><h1 id="문자열의-안티패턴">문자열의 안티패턴</h1><h2 id="문자열은-다른-값-타입을-대신하기에-적합하지-않다">문자열은 다른 값 타입을 대신하기에 적합하지 않다.</h2><p>많은 사람들이 파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때 주로 문자열을 이용한다.<br>하지만 <strong>입력받을 데이터가 진짜 문자열인 경우에만 문자열을 사용하는 것이 좋다.</strong><br>데이터가 수치형이면 int, long, double등 수치에 대한 타입으로 사용하는 것이 좋다.<br>질문의 답이 예/아니오라면 boolean을 사용하는것이 좋다.</p><p>일반화 하여 얘기하자면,<br><strong>기본 타입이든 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고 없다면 새로 하나 타입을 만드는 것이 좋다.</strong></p><h2 id="문자열은-열거-타입-대신하기에-적합하지-않다">문자열은 열거 타입 대신하기에 적합하지 않다.</h2><p>상수를 열거할 경우에는 문자열 열거 패턴 클래스 보다는 열거 타입(enum)이 훨씬 낫다.</p><h2 id="문자열은-혼합-타입을-대신하기에-적합하지-않다">문자열은 혼합 타입을 대신하기에 적합하지 않다.</h2><p>여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String compoundKey = className + <span class="string">"#"</span> + i.next();</span><br></pre></td></tr></table></figure></p><p>이 방식은 단점이 많다.<br>예를 들어 문자열에 # 문자열이 있는 경우 혼란스러운 결과가 발생한다.<br>각 요소를 개별적으로 접근하기 위해서는 특정 기준을 통해 문자열을 파싱해야해서 느리고, 귀찮고, 오류 가능성도 크다.</p><p>이럴바에는 <strong>차라리 전용 클래스를 새로 만들어서 각 데이터 별로 멤버 변수를 취하는 것이 좋다.</strong></p><h2 id="문자열은-권한을-표현하기에-적합하지-않다">문자열은 권한을 표현하기에 적합하지 않다.</h2><p>권한(capacity)를 문자열로 표현하는 경우가 종종 있다.</p><h3 id="잘못된-예-문자열을-사용하여-권한을-구분하였다">잘못된 예 - 문자열을 사용하여 권한을 구분하였다.</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//객체 생성 불가</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 현 스레드의 값을 키로 구분해 저장한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (키가 가르키는) 현 스레드의 값을 반환한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 방식의 문제점은 스레드 구분용 문자열 키가 global namespace에서 공유된다는 점이다.<br>이 방식이 의도대로 동작하려면 각 클라이언트가 고유한 키를 제공해야 한다.<br>만약 두 클라이언트가 서로 소통하지 못해 같은 키를 쓰기로 결정한다면, 의도치 않게 같은 변수를 공유하게 된다.<br>따라서 클라이언트는 제대로 작동하지도 않고 보안에도 취약하다.</p><p>이런 경우에는 String으로 권한을 구분하는 것이 아니라 별도의 타입을 만들어 해결해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//객체 생성 불가</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">        key() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//위조 불가능한 고유 키를 생성한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Key();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Key key, Object value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">(Key key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 방법은 앞서의 문자열 기반 API의 문제점을 해결해 주지만 개선할 부분이 있다.<br>set/get 메서드는 이제 static 메서드일 이유가 없다. 따라서 Key의 인스턴스 메서드로 변경하는 것이 좋다.<br>그렇게 하면 Key는 더 이상 스레드 지역변수를 구분하기 위한 키가 아니라 그 자체가 스레드 지역변수가 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 API는 get으로 얻은 Object를 실제 타입으로 타입 캐스팅 해야 해서 타입안전하지 않다.<br>하지만 제네릭을 사용한다면 조금 더 타입 안전하게 만들 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="정리">정리</h1><ul><li>더 적합한 데이터 티입이 있거나 새로 작성할 수 있다면, 문자열을 쓰지 말자</li><li>문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고 오류 가능성도 크다.</li><li>문자열을 잘못 사용하는 흔한 예로는 기본 타입, 열거 타입, 혼합 타입이 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 62. 다른 타입이 적절하다면 문자열 사용을 피하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/01/effective-java-item62/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/01/effective-jave-item61/</link>
      <guid>https://jaehun2841.github.io/2019/03/01/effective-jave-item61/</guid>
      <pubDate>Fri, 01 Mar 2019 09:27:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바의 데이터 타입은 크게 두 가지로 나눌 수 있다.&lt;br&gt;
&lt;strong&gt;기본 타입 (Primitive type) vs 참조 타입 (Reference Type)&lt;/strong&gt; 으로 구분 할 수 있다.&lt;/p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바의 데이터 타입은 크게 두 가지로 나눌 수 있다.<br><strong>기본 타입 (Primitive type) vs 참조 타입 (Reference Type)</strong> 으로 구분 할 수 있다.</p><h2 id="기본-타입-primitive-type">기본 타입 (Primitive Type)</h2><ul><li>int</li><li>long</li><li>short</li><li>double</li><li>char</li><li>boolean</li></ul><h2 id="참조-타입-reference-type">참조 타입 (Reference Type)</h2><ul><li>String</li><li>Integer</li><li>Long</li><li>Double</li><li>Boolean</li></ul><p>기본 타입에 대응되는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다.</p><h1 id="auto-boxing-vs-auto-unboxing">Auto Boxing vs Auto UnBoxing</h1><p>Java 1.5 부터 기본 타입과 래퍼 타입(Wrapper Type, 참조 타입에 대한 클래스를 래퍼 클래스라고 함)을 자동으로 변환해 주는 기능이 추가되었다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> j = i; <span class="comment">// Auto UnBoxing</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">10</span>;</span><br><span class="line">Integer l = k; <span class="comment">//Auto Boxing</span></span><br></pre></td></tr></table></figure></p><p>이 기능 때문에 개발자는 별도로 Boxing과 UnBoxing을 수행해 주지 않아도 되지만, 그렇다고 두 개가 같은 것은 아니다.<br>기본 타입과 래퍼 타입에는 차이가 있으니 어떤 타입을 사용하는지는 상당히 중요하다.</p><h1 id="기본타입-vs-참조타입">기본타입 vs 참조타입</h1><p>기본 타입과 참조 타입의 차이점은 크게 3가지이다.</p><ul><li><p>기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)란 속성을 갖는다.</p><ul><li><p>기본 타입은 흔히 말하는 리터럴(Literal)이다.</p><blockquote><p>리터럴(Literal)이란?</p><p>소스 코드의 고정된 값을 의미하는 용어이다.상수(Constants) 또는 변수(Variable)에 할당 할 수 있는 값 자체를 일컫는 용어이다.</p></blockquote></li><li><p>기본 타입의 값은 JVM내의 Stack 메모리에 저장된다.</p></li><li><p>참조 타입의 값은 객체 내의 상수에 저장된다. 따라서 JVM 내의 Heap 메모리에 저장된다.</p></li><li><p>따라서 박싱된 타입의 객체는 같은 값이라 하더라도 다른 객체일 경우에는 다르다고 식별이 가능하다.</p></li></ul></li><li><p>기본 타입의 값은 언제나 유효한 값을 가지고 있으나 박싱된 기본타입은 유효하지 않을 수 있다.</p><ul><li>기본타입의 값은 Java의 경우 초기화 되지 않으면 0으로 초기화 된다.</li><li>박싱된 기본 타입의 경우에는 초기화 되지 않으면 null이 될 수 있다.</li></ul></li><li><p>기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.</p><ul><li>박싱된 타입은 heap에 객체를 생성하기 때문에 메모리 사용면에서 더 안좋다.</li><li>기본타입은 변수에 값이 있는 반면, 박싱된 기본 타입은 변수의 객체참조 정보를 바탕으로 heap에서 찾으므로<br>시간적인 측면에서 기본타입보다 값에 접근하는 시간이 더 들게 된다.</li></ul></li></ul><h1 id="잘못-구현된-비교자-예제">잘못 구현된 비교자 예제</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; naturalOrder = (i, j) -&gt; (i &lt; j) ? -<span class="number">1</span> : (i == j ? <span class="number">0</span> : <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><ul><li>위의 코드를 기반으로 Integer비교가 실행되면 같은 값을 비교한다고 해도 1이 나올 수 있다.</li><li>첫번째 i &lt; j 에 대한 연산 시, Integer타입인 i와 j는 기본타입 int로 언박싱된다.</li><li>첫번째 연산이 false이면 두번째 연산 i == j에서도 false가 발생하게 된다.</li><li>이유는, (i, j)의 타입이 Integer로 추론되기 때문에 i == j 연산이 이루어질 때 객체의 동일성검사가 이루어져 false가 발생하기 때문이다. (i와 j는 내부 값은 같지만 서로 다른 객체이기 때문이다.)</li></ul><p><strong>이처럼 같은 객체가 아니라면 박싱된 기본타입에 == 연산자를 이용하여 비교하면 예상과는 다른 결과가 나올 수 있다.</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; naturalOrder = (i, j) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> unBoxi = i;</span><br><span class="line">    <span class="keyword">int</span> unBoxj = j;</span><br><span class="line">    <span class="keyword">return</span> (unBoxi &lt; unBoxj) ? -<span class="number">1</span> : (unBoxi == unBoxj ? <span class="number">0</span> : <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 수정하면 정상적인 결과를 얻을 수 있다.</p><h1 id="갑자기-발생하는-nullpointerexception">갑자기 발생하는 NullPointerException</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unbelievable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Integer i;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">42</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"믿을 수 없군"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 프로그램은 &quot;믿을 수 없군&quot;을 출력하지는 않지만, 전혀 예상하지 못한 결과를 보여준다.<br>i == 42를 검사하는 과정에서 NullPointerException을 던진다.<br>원인은 i가 literal 값인 42와 비교하는 과정에서 i는 Auto UnBoxing을 수행한다.<br>하지만  i는 null이기 때문에 Auto UnBoxing을 수행하는 과정에서 NullPointerException을 발생시키게 된다.</p><p><strong>기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.</strong><br>하지만 박싱된 기본타입이 null인 경우에는 NullPointerException이 발생하니 주의 해야 한다.</p><h1 id="의도하지-않은-auto-boxing으로-인한-성능저하">의도하지 않은 Auto Boxing으로 인한 성능저하</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0L</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">        sum += i; <span class="comment">//sum이 UnBoxing되어 i와 연산되고 연산 후에 AutoBoxing되어 Long타입으로 변환된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 코드는 sum을 Long으로 선언하였기 때문에 엄청난 성능상 안좋은 코드이다.<br>sum += i;를 수행하는 과정에서 <strong>sum이 long타입으로 UnBoxing되고</strong> sum + i 연산이 이루어진다음 <strong>Long타입으로 AutoBoxing되기 때문이다.</strong></p><h1 id="박싱된-기본타입은-언제-사용해야-하는가">박싱된 기본타입은 언제 사용해야 하는가?</h1><ul><li>컬렉션의 원소, 키, 값으로 쓴다.<ul><li>컬렉션은 기본타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본타입을 사용해야 한다.</li></ul></li><li>제네릭(Generics) 타입을 이용하는 경우에도 박싱된 기본타입을 사용한다.<ul><li>제네릭 타입에서는 int, double과 같은 기본타입을 지원하지 않기 때문이다.</li></ul></li><li>리플렉션(Reflection)을 통해 메서드를 호출할 때에도 박싱된 기본타입을 사용한다.</li></ul><h1 id="정리">정리</h1><ul><li>기본 타입과 박싱된 기본 타입을 사용해야 한다면,  가능하면 기본 타입을 사용하는 것이 좋다.</li><li>기본타입은 간단하고 빠르다.</li><li>박싱된 기본 타입을 사용한다면 주의를 기울이자</li><li>AutoBoxing이 기본타입을 변경할 때 번거로움을 줄여주지만 그 위험까지 없애주지는 않는다.<ul><li>박싱된 기본 타입을 == 연산자로 비교한다면 객체의 동일성 비교가 이뤄지는데<br>개발자가 의도한 결과가 나오지 않을 가능성이 크다.</li><li>== 연산에서 기본 타입과 박싱된 기본 타입의 연산이 이루어지면, 박싱된 기본 타입이 UnBoxing되는데<br>박싱된 기본 타입이 null인 경우 NullPointerException이 발생한다.</li></ul></li><li>기본 타입을 Boxing하는 것은 필요없는 객체를 생성하는 부작용이 나올 수 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/01/effective-jave-item61/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 60. 정확한 답이 필요하다면 Float와 Double은 피하라</title>
      <link>https://jaehun2841.github.io/2019/02/28/effective-java-item60/</link>
      <guid>https://jaehun2841.github.io/2019/02/28/effective-java-item60/</guid>
      <pubDate>Thu, 28 Feb 2019 10:34:22 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;float와 double 타입은 과학과 공학 계산용으로 설계되었다.&lt;br&gt;
이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 &lt;strong&gt;근사치&lt;/strong&gt; 로 계산하도록 세심하게 설계되었다
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>float와 double 타입은 과학과 공학 계산용으로 설계되었다.<br>이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 <strong>근사치</strong> 로 계산하도록 세심하게 설계되었다.<br>따라서 정확한 결과가 필요할 때에는 사용해선 안된다<br><strong>float와 double 타입은 특히 금융 관련 계산과는 맞지 않는다.</strong><br>0.1 혹은 10의 거듭 제곱 수를 표현할 수 없기 때문이다.</p><h1 id="예시-금융-계산에-부동소수-타입을-사용">예시 - 금융 계산에 부동소수 타입을 사용</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> funds = <span class="number">1.00</span>;</span><br><span class="line">    <span class="keyword">int</span> itemBought = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> price = <span class="number">0.10</span>; funds &gt;= price; price += <span class="number">0.10</span>) &#123;</span><br><span class="line">        funds -= price;</span><br><span class="line">        itemsBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">"개 구입"</span>);</span><br><span class="line">    System.out.println(<span class="string">"잔돈(달러): "</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>프로그램의 실행결과는 사탕 3개를 구입한 후 잔돈은 0.39999999999999달러가 남는다고 나온다.</li><li>잘못된 결과이며, 올바른 결과를 위해서는 <strong>BigDecimal, int, long</strong> 을 사용해야 한다.</li></ul><h2 id="bigdecimal을-사용한-코드-속도가-느리고-쓰기-불편하다">BigDecimal을 사용한 코드 - 속도가 느리고 쓰기 불편하다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BigDecimal TEN_CENTS = <span class="keyword">new</span> BigDecimal(<span class="string">".10"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> itemBought = <span class="number">0</span>;</span><br><span class="line">    BigDecimal funds = <span class="keyword">new</span> BigDecimal(<span class="string">"1.00"</span>);</span><br><span class="line">    <span class="keyword">for</span>(BigDecimal price = TEN_CENT; funds.compareTo(price) &gt;= <span class="number">0</span>; price = price.add(TEN_CENTS)) &#123;</span><br><span class="line">        funds = funds.subtract(price);</span><br><span class="line">        itemsBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">"개 구입"</span>);</span><br><span class="line">    System.out.println(<span class="string">"잔돈(달러): "</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 프로그램의 실행결과는 사탕 4개 구입 후 잔돈이 0달러가 남는다. 올바른 답이다.</li><li>BigDecimal에는 2가지 단점이 있다.<ul><li>기본 타입보다 쓰기가 훨씬 불편하고, 느리다. 단발성 계산이라면 문제는 아니지만 쓰기 불편하다</li><li>BigDecimal의 대안으로 int, long을 사용해도 된다. 하지만 소수점을 직접 관리해야 한다.</li></ul></li></ul><h2 id="int를-사용한-코드-cent로-문제를-해결">int를 사용한 코드 - Cent로 문제를 해결</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> itemBought = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> funds = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> price = <span class="number">10</span>; funds &gt;= price; price += <span class="number">10</span>) &#123;</span><br><span class="line">        funds -= price;</span><br><span class="line">        itemBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">"개 구입"</span>);</span><br><span class="line">    System.out.println(<span class="string">"잔돈(달러): "</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>int로 사용하면 BigDecimal 보다는 깔끔하고 정확한 답을 얻을 수 있다.</li></ul><h1 id="정리">정리</h1><ul><li>정확한 답이 필요한 계산에는 float나 double을 피해야한다.</li><li>소수점 추적은 시스템에 맡기고 코딩시의 불편함이나 성능저하가 중요하지 않다면 BigDecimal을 사용하라</li><li>BigDecimal은 8가지 반올림 모드를 제공하므로 반올림을 거의 완벽하게 제어할 수 있다.</li><li>성능이 중요하고 소수점을 직접 추적할 수 있고 숫자가 너무 크지 않다면 int나 long을 사용하라</li><li>숫자를 9자리 10진수로 표현한다면 int를 사용하라</li><li>숫자를 18자리 10진수로 표현할 수 있다면 long을 사용하라</li><li>숫자가 18자리가 넘어가면 BigDecimal을 사용해야 한다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 60. 정확한 답이 필요하다면 float와 double은 피하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/28/effective-java-item60/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 59. 라이브러리를 익히고 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/28/effective-java-item59/</link>
      <guid>https://jaehun2841.github.io/2019/02/28/effective-java-item59/</guid>
      <pubDate>Thu, 28 Feb 2019 10:18:25 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;무작위-정수-만들기&quot;&gt;무작위 정수 만들기&lt;/h1&gt;
&lt;p&gt;무작위 정수를 하나 생성한다고 해보자&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="무작위-정수-만들기">무작위 정수 만들기</h1><p>무작위 정수를 하나 생성한다고 해보자</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">random</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(rnd.nextInt()) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>괜찮아 보이지만 3가지의 문제를 내포하고 있다.</p><ul><li><p>n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다.</p></li><li><p>n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 자주 반환된다.</p></li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span> * (Integer.MAX_VALUE / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(random(n) &lt; n/<span class="number">2</span>) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(low);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>random 메서드가 이상적으로 동작한다면 약 50만개가 출력되어야 하지만, 실제로는 666,666에 가까운 값을 얻는다.<br>무작위로 생성된 수 중에서 2/3 가량이 중간값보다 낮은 쪽으로 쏠린 것이다.</p><ul><li>지정한 범위 바깥의 수가 종종 튀어나올 수 있다. rnd.nextInt()가 반환한 값을 Math.abs를 이용해 음수가 아닌 정수로 매핑하기 때문이다.</li></ul><h1 id="표준-라이브러리를-사용하면-다른-프로그래머들의-경험을-활용할-수-있다">표준 라이브러리를 사용하면 다른 프로그래머들의 경험을 활용할 수 있다.</h1><ul><li>메서드의 동작 방식은 몰라도 알고리즘에 능통한 개발자나, 여러 분야의 전문가가 설계와 구현에 시간을 들여 개발한 것이다.</li><li>버그가 발생되더라도 다음 릴리스에 수정 보완 개선이 될 수 있다.</li><li>표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.</li><li>핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 되고 어플리케이션 기능 개발에 집중할 수 있다.</li><li>따로 노력하지 않아도 릴리즈가 나올 때 마다 성능이 지속해서 개선된다.</li><li>기능이 점점 많아진다. 개발자 커뮤니티에서 나온 이야기를 바탕으로 논의 후 다음 릴리즈에 기능이 추가되곤 한다.</li><li>라이브러리를 사용하면 많은 사람들에게 낯익은 코드가 된다. 다른 개발자들이 유지보수 하기 쉬워지고 재사용성이 높아진다.</li></ul><h1 id="메이저-버전-릴리즈-마다-수많은-기능이-추가된다">메이저 버전 릴리즈 마다 수많은 기능이 추가된다.</h1><ul><li>자바는 메이저 릴리즈마다 새로운 기능을 설명하는 웹페이지를 공시한다.</li><li>한 번쯤은 읽어볼만 하다</li><li>너무 많아서 읽기 힘든 경우에는 java.lang, java.util, java.io와 하위 패키지들에는 익숙해져야 한다.</li><li>컬렉션 프레임워크나 concurrent 패키지는 알아두면 도움이 도니다.</li></ul><h2 id="예시-transferto-메서드를-이용해-url-내용-가져오기">예시 - transferTo 메서드를 이용해 URL 내용 가져오기</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;InputStream in = <span class="keyword">new</span> URL(args[<span class="number">0</span>]).openStream()) &#123;</span><br><span class="line">        in.transferTo(System.out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>java 9 버전 부터 URL정보를 쉽게 출력해 주는 transferTo 메서드를 제공한다.</li></ul><h1 id="정리">정리</h1><ul><li>라이브러리가 전문적인 기능을 제공해 주지 못할수도 있지만, 라이브러리를 일단 사용해보자</li><li>특별한 기능이 아니라면 누군가 라이브러리로 만들어 두었을 가능성이 높다.<br>일단 라이브러리가 있는지 찾아보자</li><li>일반적으로 라이브러리의 코드는 개발자가 작성한 것보다 품질이 좋고 개선의 여지가 있다.</li><li>라이브러리 코드는 주목을 많이 받고 개발자 커뮤니티에서 문제점이 많이 거론되므로 코드 품질이 점차 좋아진다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 59. 라이브러리를 익히고 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/28/effective-java-item59/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 58. 전통적인 for 문보다는 For-Each문을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/28/effective-java-item58/</link>
      <guid>https://jaehun2841.github.io/2019/02/28/effective-java-item58/</guid>
      <pubDate>Thu, 28 Feb 2019 09:39:24 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;스트림(Stream)이 제격인 작업이 있고, 반복이 제격인 작업이 있다.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>스트림(Stream)이 제격인 작업이 있고, 반복이 제격인 작업이 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c.iterator(); i.hasNext();) &#123;</span><br><span class="line">    Element e = i.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> z = a[i]; <span class="comment">// a[i]로 무언가를 한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 for문과 같은 관용구들은 while문 보다는 낫지만 가장 탁월한 방법은 아니다.<br><strong>반복자와 인덱스 변수는 모두 코드를 지저분하게 할 뿐 우리에게 필요한 건 원소들 뿐이다.</strong><br>또한 컬렉션이냐 배열이냐에 따라 코드 형태가 달라지기 때문에 주의해야 한다.</p><h1 id="향상된-for문-enhanced-for-statement">향상된 for문 (enhanced for statement)</h1><ul><li>반복자와 인덱스 변수를 사용하지 않으니 코드가 깔끔해지고 오류가 날 일이 없다.</li><li>하나의 관용구로 되어있어서 배열이든 컬렉션이든 코드의 형태가 같다.</li><li>콜론(:)은 <strong>안의(in)</strong> 라고 읽으면 된다. (elements안의 각 원소 e에 대해)</li><li>반복 대상이 컬렉션이든 배열이든 for-each문을 사용해도 속도는 그대로이다.</li><li>for-each 문이 만들어 내는 코드는 사람이 손으로 최적화한 것과 사실상 같다.</li></ul><h1 id="컬렉션이-중첩되는-경우-for-each의-이점이-커진다">컬렉션이 중첩되는 경우 for-each의 이점이 커진다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Suit &#123; CLUB, DIAMOND, HEART, SPADE&#125;</span><br><span class="line"><span class="keyword">enum</span> Rank &#123; ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Collection&lt;Suit&gt; suits = Arrays.asList(Suit.values());</span><br><span class="line"><span class="keyword">static</span> Collection&lt;Rank&gt; ranks = Arrays.asList(Rank.values());</span><br><span class="line"></span><br><span class="line">List&lt;Card&gt; deck = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Suit&gt; i = suits.iterator(); i.hasNext();) &#123;</span><br><span class="line">    <span class="keyword">for</span>(Iterator&lt;Rank&gt; j = ranks.iterator(); j.hasNext();) &#123;</span><br><span class="line">        deck.add(<span class="keyword">new</span> Card(i.next(), j.next()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>deck.add(new Card(i.next(), j.next()));</code> 줄이 오류를 일으킨다.</li><li>원래대로 하면 숫자 1개당 rank가 여러번 불려야 하는데 저러면 숫자 1개에 rank 1개 불려 <code>NoSuchElementException</code> 을 던진다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Suit &#123; CLUB, DIAMOND, HEART, SPADE&#125;</span><br><span class="line"><span class="keyword">enum</span> Rank &#123; ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Collection&lt;Suit&gt; suits = Arrays.asList(Suit.values());</span><br><span class="line"><span class="keyword">static</span> Collection&lt;Rank&gt; ranks = Arrays.asList(Rank.values());</span><br><span class="line"></span><br><span class="line">List&lt;Card&gt; deck = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Suit suit : suits) &#123;</span><br><span class="line">    <span class="keyword">for</span>(Rank rank : ranks) &#123;</span><br><span class="line">        deck.add(<span class="keyword">new</span> Card(suit, rank));   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위와 같이 for-each를 사용하면 깔끔하고 간단하게 코드를 짤 수 있다.</li></ul><h1 id="for-each를-사용할-수-없는-상황">for-each를 사용할 수 없는 상황</h1><ul><li><strong>파괴적인 필터링(destructive filtering)</strong><ul><li>컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 호출해야 한다.</li><li>Java 8 부터 Collection의 removeIf 메서드를 사용해 컬렉션을 명시적으로 순회하지 않을 수 있다.</li></ul></li><li><strong>변형(transforming)</strong><ul><li>리스트나 배열을 순회하면서 원소 값 일부 혹은 전체를 교체하는 경우에는 인덱스를 사용해야 한다.</li></ul></li><li><strong>병렬 반복(parallel iteration)</strong><ul><li>여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.</li></ul></li></ul><h1 id="정리">정리</h1><ul><li>for문 대신 for-each를 사용할 수 있는 경우는 무조건 사용하자</li><li>전통적인 for문과 비교했을 때, for-each문은 명료하고 유연하고 버그를 예방해 준다.</li><li>for-each문은 컬렉션과 배열은 물론 Iterable 인터페이스를 구현한 객체라면 무엇이든 순회 가능하다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 58. 전통적인 for 문보다는 for-each문을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/28/effective-java-item58/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 57. 지역변수의 범위를 최소화하라</title>
      <link>https://jaehun2841.github.io/2019/02/28/effective-java-item57/</link>
      <guid>https://jaehun2841.github.io/2019/02/28/effective-java-item57/</guid>
      <pubDate>Thu, 28 Feb 2019 09:23:54 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;클래스의 멤버와 접근권한을 최소화하라 (Item 15)&lt;/strong&gt; 와 취지가 비슷한 장이다.&lt;br&gt;
지역변수의 유효범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p><strong>클래스의 멤버와 접근권한을 최소화하라 (Item 15)</strong> 와 취지가 비슷한 장이다.<br>지역변수의 유효범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.</p><h1 id="가장-처음-쓰일-때-선언하라">가장 처음 쓰일 때 선언하라</h1><ul><li>사용하려면 멀었는데 미리 변수부터 선언하는 코드는 어수선하고 가독성이 좋지 못하다.</li><li>막상 쓰일 시점에 되서는 무슨 타입이었는지, 무슨 값으로 초기화 했는지 기억이 나지 않을 경우가 있다.</li><li>변수가 쓰이는 범위보다 너무 앞서 선언하거나, 다 쓴 뒤에도 할당해제가 되지 않고 여전히 살아있게 된다.</li><li>변수의 scope를 제한하지 못하면 예상하지 못한 결과를 초래할 수 있으니 주의해야 한다.</li></ul><h1 id="모든-지역변수는-선언과-동시에-초기화-하라">모든 지역변수는 선언과 동시에 초기화 하라</h1><ul><li><p>초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야한다.</p></li><li><p>try-catch-finally 구문에서는 예외다.</p></li><li><p>변수를 초기화 하는 표현식에서 checked exception을 던질 가능성이 있으면, try 절 안에서 초기화 해야한다.</p></li><li><p>만약, catch나 finally절에서 변수를 이용해야 한다면, try절 바로 앞에 변수를 선언해야 한다.</p></li><li><p>반복문에서는 반복 변수(loop variable)의 범위가 반복문의 몸체, 그리고 for 키워드와 몸체 사이 괄호 안으로 제한된다.</p></li><li><p>반복자 (index)를 사용해야 하는 경우에는 for-each 구문보다 전통적인 for문이 낫다.</p></li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Element e : c) &#123;</span><br><span class="line">    <span class="comment">// e로 무언가를 반복하는 로직을 구성</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c.iterator(); i.hasNext();) &#123;</span><br><span class="line">    Element e = i.next(); <span class="comment">//e와 i로 무언가를 한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="while-문을-사용하는-경우에도-for문을-사용하는-것이-낫다">while 문을 사용하는 경우에도 for문을 사용하는 것이 낫다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Element&gt; i = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext()) &#123;</span><br><span class="line">    doSomeThing(i.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator&lt;Element&gt; i2 = c2.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext()) &#123; </span><br><span class="line">    doSomeThing(i2.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>복붙의 여파로 i2.hasNext()이지만 i.hasNext()를 사용하였다.</li><li>컴파일도 잘되고 실행도 잘되지만, 기대한 결과가 도출되지 않는다.</li><li>for문을 포함한 for-each문을 사용하는 경우에는 이러한 문제를 컴파일 타임에 잡아준다.(반복자의 유효범위가 for문의 종료와 함께 끝나기 때문이다.)</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c.iterator(); i.hasNext();) &#123;</span><br><span class="line">    Element e = i.next();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i2 = c2.iterator(); i.hasNext();) &#123;</span><br><span class="line">    Element e2 = i2.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>두번째 코드의 i.hasNext()에서 i를 찾을 수 없다는 오류를 보여준다.</li></ul><h1 id="메서드를-작게-유지하고-한-가지-기능에-집중하라">메서드를 작게 유지하고 한 가지 기능에 집중하라</h1><ul><li>한 메서드에서 여러 가지 기능을 처리한다면 그중 한 기능과만 관련된 지역변수라도 다른 기능을 수행하는 코드에서 접근할 수 있다.</li><li>단순히 메서드를 기능별로만 쪼개자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 57. 지역변수의 범위를 최소화하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/28/effective-java-item57/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
