<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Carrey`s 기술블로그</title>
    <link>https://jaehun2841.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 30 Dec 2018 07:54:28 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Mybatis 조회 시, All Element Are Null 이슈</title>
      <link>https://jaehun2841.github.io/2018/12/30/2018-12-30-mybatis-returnInstanceForEmptyRow/</link>
      <guid>https://jaehun2841.github.io/2018/12/30/2018-12-30-mybatis-returnInstanceForEmptyRow/</guid>
      <pubDate>Sun, 30 Dec 2018 05:55:24 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;들어가며&quot;&gt;들어가며&lt;/h1&gt;
&lt;p&gt;사내 시스템 운영 중, SMS를 전송해 주는 부분에서 장애가 발생 하였다.
어디에선가 NullPointer Exception이 발생하고 있었다. stacktrace기준으로 추적해 보니,
Mybatis를 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="들어가며">들어가며</h1><p>사내 시스템 운영 중, SMS를 전송해 주는 부분에서 장애가 발생 하였다.어디에선가 NullPointer Exception이 발생하고 있었다. stacktrace기준으로 추적해 보니,Mybatis를 통해 데이터를 조회 한다음 데이터를 가공하는 과정에서 NullPointerException이 발생하고 있었다.일단 디버깅 이전에 코드를 봤다. 아무리 생각해도 null이 발생하지 않을 것 같았다.</p><p>실제 코드를 돌려보았다.<img src="./all_element_are_null-6151072.png" alt="all_elememt_are_null 에러"></p><p>이 메세지는 무엇?구글에 검색해 보니 List내의 모든 Element의 reference가 null인 것이었다.그래서 size는 있지만, 가르키는 instance가 없기 때문에 Nullpointer Exception이 발생하고 있었다.</p><p>일단은 조회된 모든 컬럼이 null이면 mybatis에는 null을 리턴해 주는건가? 라는 심증만 가지고절대 null이 될 수 없는 id 컬럼을 조회컬럼에 추가해 주었다. (쿼리내에 outer join의 여파로 null만 나오는 쿼리였다.)일단은 id 컬럼을 추가 해주니, 정상적으로 id만 값이 있고 다른 property는 모두 null인 객체가 생성되었다.일단 이렇게 이슈를 종료하고자 했지만, 너무 찝찝했다</p><p>아니 왜? 모든 컬럼이 null이면 왜 객체 생성을 안하지? 우리가 원하는건 null이 아닐텐데...하물며 이런상황에 앞서 조회된 내용에 대해 null 체크를 할 생각을 하니 끔찍했다.</p><p>분명 설정이 있으리라 생각하고 mybatis 사이트를 뒤져보았다.뒤져보니 요런게 있었다.</p><h2 id="returninstanceforemptyrow">returnInstanceForEmptyRow</h2><blockquote><p>MyBatis, by default, returns null when all the columns of a returned row are NULL. When this setting is enabled, MyBatis returns an empty instance instead. Note that it is also applied to nested results (i.e. collectioin and association). Since: 3.4.2</p></blockquote><p>한 마디로 mybatis option중에는 <code>returnInstanceForEmptyRow</code> 이란 옵션이 있는데, 모든 컬럼이 null이면 row를 null로 리턴해 준단다. (이런 ㅡㅡ)근데 설정 옵션이 true이면 null 대신에 모든 값이 null인 인스턴스를 반환해주고 false이면 null을 반환해 준다고 한다.하지만 default옵션이 false이기 때문에 아무 설정도 안한 회사소스에서는 당연히 null이 리턴되게 된다.<code>이 옵션은 mybatis 3.4.2부터 지원한다</code> (회사에서는 mybatis/3.4.2이상 버전을 사용하고 있다.)</p><h1 id="test-코드">Test 코드</h1><p>테스트 환경은 아래와 같이 설정해 보았다</p><ul><li>Spring Boot</li><li>Mybatis</li><li>H2DB</li></ul><h2 id="환경-설정">환경 설정</h2><p>pom.xml<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyBatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>application.properties<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#Datasource</span><br><span class="line">spring.datasource.url=jdbc:h2:mem:test</span><br><span class="line">spring.datasource.initialization-mode=always</span><br><span class="line">spring.datasource.username=sa</span><br><span class="line">spring.datasource.password=</span><br><span class="line">spring.datasource.driver-class-name=org.h2.Driver</span><br><span class="line"></span><br><span class="line">#h2 setting</span><br><span class="line">spring.h2.console.enabled=true</span><br><span class="line">spring.h2.console.path=/h2-console</span><br><span class="line"></span><br><span class="line"># Mybatis Setting</span><br><span class="line">mybatis.mapper-locations=classpath*:mapper/**/*SqlMap.xml</span><br><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br><span class="line">mybatis.configuration.return-instance-for-empty-row=false</span><br></pre></td></tr></table></figure></p><p>schema.sql<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INTEGER</span> AUTO_INCREMENT primary <span class="keyword">key</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    description <span class="built_in">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>data.sql<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span>(<span class="keyword">id</span>, <span class="keyword">name</span>, description) <span class="keyword">values</span> (<span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p><p>TestRepository.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;TestDTO&gt; <span class="title">getTestAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TestSqlMap.xml<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.springstudy.demo6.TestRepository"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTestAll"</span> <span class="attr">resultType</span>=<span class="string">"com.example.springstudy.demo6.TestDTO"</span>&gt;</span></span><br><span class="line">        select name, description from test</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>MybatisConfig.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.example.springstudy.demo6"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="test-case">Test Case</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactoryBean sqlSessionFactoryBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestConfiguration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">                    .setType(EmbeddedDatabaseType.H2)</span><br><span class="line">                    .addDefaultScripts()</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            SqlSessionFactoryBean sqlSessionFactoryBean = </span><br><span class="line">            <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">            sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">            sqlSessionFactoryBean.getObject()</span><br><span class="line">             .getConfiguration()</span><br><span class="line">                                 .setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">                                 </span><br><span class="line">            sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> ClassPathResource[]&#123;</span><br><span class="line">            <span class="keyword">new</span> ClassPathResource(<span class="string">"mapper/TestSqlMap.xml"</span>)&#125;);</span><br><span class="line">            <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * returnInstanceForEmptyRow 설정이 false일때,</span></span><br><span class="line"><span class="comment">     * 모든 컬럼의 데이터가 null인 경우, List내의 항목이 null이 되는 경우 테스트</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">all_element_null_test_returnInstanceForEmptyRow_false</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        sqlSessionFactoryBean.getObject()</span><br><span class="line">                             .getConfiguration()</span><br><span class="line">                             .setReturnInstanceForEmptyRow(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;TestDTO&gt; tests = sqlSessionFactoryBean.getObject()</span><br><span class="line">                .openSession()</span><br><span class="line">                .getMapper(TestRepository.class)</span><br><span class="line">                .getTestAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//모든 항목이 null인 경우, List내의 Element가 null이 되므로 제거 된다</span></span><br><span class="line">        tests.removeIf(Objects::isNull);</span><br><span class="line">        assertThat(tests).isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * returnInstanceForEmptyRow 설정이 true일때,</span></span><br><span class="line"><span class="comment">     * 모든 컬럼의 데이터가 null인 경우, 모든 property가 null인 인스턴스가 생성되는지에 대한 테스트</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">all_element_null_test_returnInstanceForEmptyRow_true</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        sqlSessionFactoryBean.getObject()</span><br><span class="line">                             .getConfiguration()</span><br><span class="line">                             .setReturnInstanceForEmptyRow(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;TestDTO&gt; tests = sqlSessionFactoryBean.getObject()</span><br><span class="line">                .openSession()</span><br><span class="line">                .getMapper(TestRepository.class)</span><br><span class="line">                .getTestAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//모든 항목이 null인 경우, List내의 Element가 null이 되므로 제거 된다</span></span><br><span class="line">        tests.removeIf(Objects::isNull);</span><br><span class="line">        assertThat(tests).isNotEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>http://www.mybatis.org/mybatis-3/configuration.html</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/30/2018-12-30-mybatis-returnInstanceForEmptyRow/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2018년 회고</title>
      <link>https://jaehun2841.github.io/2018/12/16/2018-12-16-remind/</link>
      <guid>https://jaehun2841.github.io/2018/12/16/2018-12-16-remind/</guid>
      <pubDate>Sun, 16 Dec 2018 06:59:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;새-직장으로-이직&quot;&gt;새 직장으로 이직&lt;/h1&gt;
&lt;p&gt;2017년 8월 중순 중소 SI업체를 용기있게(?) 뛰쳐나왔다.
그 곳에서는 오직 나 한명으로 여러 프로젝트를 돌리고 있었고, 같이 일할 선임개발자도 없었기 때문에
굉장히 나름대로 스트
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="새-직장으로-이직">새 직장으로 이직</h1><p>2017년 8월 중순 중소 SI업체를 용기있게(?) 뛰쳐나왔다.그 곳에서는 오직 나 한명으로 여러 프로젝트를 돌리고 있었고, 같이 일할 선임개발자도 없었기 때문에굉장히 나름대로 스트레스를 받고 있었다.그리고 모든 프로젝트가 나에게 의존적이었기 때문에 관리해야 할 사이트도 많았고..매일매일 프로젝트 했던 사이트들에 대한 유지보수 전화를 받아가며, 신규 프로젝트를 진행하고 있었다.이렇게 개발자로서 소모되어 가고 있다는 생각이 들어 과감하게 퇴사를 하게되었다. 다음에는 어느정도 조직이 구성되어있고 내가 조직원으로서 일할 수 있는 직장을 찾아야겠다! 라는 생각을 하게되었다.이직하고자 하는 회사의 조건은 이렇다.</p><ol><li>개발자 한명이 기획, 개발, 유지보수, 영업을 담당하는 작은회사는 가지 않겠다.</li><li>더 이상 SI는 하지 않겠다. (지방 출장이 잦고, 프로젝트 단위로 사업이 돌아가는 곳은 가지 않겠다.)</li><li>근무지 한 곳에서만 근무 할 수 있는 환경 (예전에는 지방을 여기저기 많이 다녔다.)</li><li>시니어 개발자와 주니어 개발자 층이 어느정도 있고, 같이 의논하며 개발할 수 있는 환경</li><li>Spring 4 / Java 1.8 이상을 사용하여 개발하는 조직</li><li>내가 더 발전할 수 있는 조직</li><li>연봉도 많이 올려주면 좋고~! ^^</li></ol><p>하지만 생각보다 이직은 쉽지 않았다. (특히나 선퇴사 후이직 이어서.. 11월쯤에는 굉장히 쫄렸다.)일단 서비스 회사로 이직을 목표로 잡았지만, 기존의 했던 업무가 제조업이나 MES관련 개발을 주로 했었기 때문에 서비스 회사에서는 대부분의 서류 낙방을 경험했다. (이력서를 처음 써봐서 정말 못써서 그럴 수도 있겠지만.)서류 한 군데만 붙어라... 면접은 완전 잘 볼 자신있다!라는 생각으로 서류만 2개월 이상 쓰다보니 10월쯤에는 서류 합격하는 회사가 몇 군데 있었다. 서류합격 메일을 받았을 때 기분이란....크 면접일자가 정해지고, 인터넷에 돌아다니는 예상 면접질문을 바탕으로 하나하나 정리를 하였다. 대게 기술질문은 그 테두리 안에서 나온다는 것이 여러사람들의 의견이었다.그리고 9월쯤엔 대기업 신입공채를 준비했어서, 오랜만에 컴퓨터 이론을 한번 정리 했었는데 이 부분이 정말 도움이 많이 되었다. 자주 안보는 만큼 지금도 기억에서 많이 사라졌는데, 가끔씩 리마인드를 해주는 것이 좋겠다.</p><p>면접은 두 군데정도 봤는데 둘 다 자신감있게 봤었다.아무래도 SI하면서 고객사 상대로 발표도 하고 회의도 자주 하다보니, 남들이랑 대화하고 그런거는 긴장되지 않았다.그렇기 때문에 면접을 보면서 긴장을 덜하고 면접장에서 어필할 수 있었던 것 같다.결국 최종적으로 한 곳의 회사만 합격을 하였는데, 그 곳이 NHN티켓링크이다.최종합격 후 천만다행이라는 생각이 들었고, 2018년 1월 초에 입사를 하게 되었다.</p><h1 id="우리-팀의-개발문화">우리 팀의 개발문화</h1><p>예전 SI할 때는 혼자서 사이트를 다 만들어야 했기 때문에, 프론트엔드도 하고 백엔드도하고, 서버설치 등을 혼자 다했다. 하지만 여기와서는 인프라 관련해서는 시스템팀이 별도로 있었고, DBA팀도 별도로 있었다. 내가 할 업무는 티켓링크 백엔드 개발과 약간의 간단한 프론트엔드 작업만 하면되었다.기획팀도 별도로 나뉘어져 있다보니, 내가 직접 기획서를 쓰지 않아도 되고 개발에만 집중 할 수 있다는 환경이 참 좋았다.</p><h2 id="git-flow를-사용한-브랜치-전략">git flow를 사용한 브랜치 전략</h2><p>SI할때는 SVN만 사용해봤는데 그냥 master에 커밋치던 나에게는 신세계였다. 뭔가 구글링하면서 지나쳤던 얘기들을 실천하고 있는 조직이라는 생각이 들었다.git도 처음 사용해 봤는데, SVN보다 더 유연하고 좋다는 생각이 들었다. (특히 브랜치를 왔다갔다 하면서 작업할 수 있는 점이 좋았던 것 같다.)</p><h2 id="pull-request-코드리뷰">Pull Request + 코드리뷰</h2><p>두 번째로는 Pull Request를 올려서 코드리뷰를 강제화 하도록 하는 문화이다.첫 업무를 받아서 PR을 올렸을 때는 Conversation이 50개 이상이 달려서 코드리뷰를 엄청나게 받았다.뭔가 탈탈 털렸다라는 느낌도 받았고, 앞으로 공부해야 할 게 많구나라는 생각이 들었다.한 가지 아쉬운점은... <code>코드리뷰를 하는 사람만 한다.</code> 다른사람들도 적극적으로 해주면 좋을텐데..라는 생각이 들었다.처음에는 나도 다른사람의 코드를 리뷰해줘야지! 라는 생각으로 코드리뷰에 참여하려고 했지만.. 한마디도 달 수 없었다. 그때 딱 드는 생각이, <strong>&quot;내가 아는게 없어서 코드리뷰를 해줄 수가 없구나.. 코드리뷰에 한마디라도 할 수 있도록 공부하자&quot;</strong> 라는 생각을 하게 되었다.돌이켜보면 나는 여태까지 <code>&quot;공부하지 않는 개발자&quot;</code>였다.팀원들을 보면 아침에 일찍와서 책을보는 분도 계셨고, 따로 스터디모임을 하시는 분도 계셨다.입사초기에 나는 살 좀 빼야지.. 라는 생각으로 아침운동을 다녀서 아침에 일찍 공부하기는 힘들었다. 그래서 주로 퇴근 후나 주말에 내가 하고자 하는 공부를 하였다. 그리고 꼭 공부한 내용은 블로그를 작성해서 남겨야겠다고 생각했다.공부는 조금조금씩 계속 했지만, 본격적으로 블로그를 설치하고 시작한 것은 7월 정도인 것 같다.현재 4년차에 Spring기반으로 개발을 계속 해왔다고는 하지만 Spring의 기본을 공부해본적이 없었다.여태까지는 그냥 <code>이렇게 하면 이렇게 되네~</code> 방식의 개발을 해와서, 뭐가 안되면 원인 파악하기가 무척이나 어려웠다.그래서 처음에는 <strong>Spring core</strong>에 대한 공부를 시작했다. 토비의 Spring 책도 사고, 회사 소스에 적용된 기술들을 하나하나 파보기 시작했다. 하나하나 익히고 나니 너무 유용한 기술들이 많이 있었고, 개발할 때 직접 써먹으면서 실전 응용력을 키울 수 있었던 것 같다.</p><h2 id="주간-기술공유">주간 기술공유</h2><p>세 번째는 매주 목요일 기술공유 시간을 짧게 갖는다.팀원 한 명씩 돌아가면서 신기술에 대한 공유나 코드리뷰등을 하는 시간이다. 이런 걸 해보지 않아서 처음에는 무슨 내용을 공유하지?라는 걱정이 앞섰는데, 다행히도 공유 순서가 가까워지면 항상 공유 할 내용이 있었다. 그리고 내 순서가 아니어도 최대한 공유를 하려고 노력했다. (순서가 아니어도 또 해도 된다. 하지만 내 순번에는 또 공유를 해야한다. ㅎㅎ) 최대한 공유를 많이 하려고 노력했고, 기술공유 준비를 하면서 내가 했던 일들이나 기술에 대해 다시 한번 정리하는 시간이 되어 개인적으로 기술에 대한 기억을 오랫동안 보존할 수 있는 방법이었다.또 다른사람의 기술공유를 들었다가 내가 필요할 때 써먹거나, 미처 몰랐던 내용들도 있어서 개발팀 문화 중에 나름 유의미한 시간이라고 생각하고 있다.</p><h1 id="블로그-시작">블로그 시작</h1><p>올해 목표 중 하나가 블로그에 공부한 내용에 대한 글을 꾸준히 작성하는 것이었다.블로그는 7월쯤에 만들어서 꾸준히 작성하려고 노력하고 있다.</p><p>현재까지 수를 보니..</p><ul><li>7월 - 5개</li><li>8월 - 6개</li><li>9월 - 3개</li><li>10월 - 2개</li><li>11월 - 7개</li><li>12월 - 8개</li></ul><p>정도 해서 총 31개의 포스팅을 작성했다. 시리즈 물로 된 글도 많았고, 회사에서 사용한 기술들을 다시 좀 다듬어서 기록으로 남긴 것들도 있다. (회사 업무내용을 최대한 제외하려 한게 참 힘들었다ㅜㅜ)처음에는 블로그도 안써봐서 글 쓰는데 시간도 오래걸리고 뭐 어떻게 써야하나...라는 생각으로 다른 블로그들을 참고하며 많이 썼던것 같다. 그리고 하나 쓰는데 시간도 꽤 오래 걸린것 같다.한 30개의 글을 써보니 대충 블로그 쓰는 법도 감이 왔다.</p><ul><li>일단 내가 100% 이해하지 못한 상황에서 글을 쓸 수 없다.</li><li>처음에는 블로그 포스팅 수를 늘리고 싶어서 무조건 post부터 생성하고 봤는데, 글의 진도가 나가지 않았다.</li><li>블로그를 빠르고 쉽게 작성하기 위해서는 목차를 먼저 잡고 그에 대한 지식을 채운 다음에 각 섹션별로 담아내고자 하는 내용을 짧게 정리했다.</li><li>예제가 필요한 경우 미리 예제에 대한 실습을 마쳐 놓아야 한다.<ul><li>그때그때 예제코드 작성하면 시간이 오래걸리고, 내가 무슨 글을 쓰던 중이었는지 까먹게 된다.</li></ul></li></ul><p>블로그를 쓰다보니 지식에 대한 인덱스도 나름 생기고, 나중에 기억 안나도 예제코드를 찾아볼 수 있어서 좋았다.앞으로도 계속 블로그를 작성할 예정인데, 제발 귀찮아지지만 않았으면 좋겠다..!</p><h1 id="회사-업무">회사 업무</h1><h2 id="1~2월에는-회사-적응도-하고-바로-또-업무를-할당-받았다">1~2월에는 회사 적응도 하고, 바로 또 업무를 할당 받았다.</h2><p>나의 첫 업무는 티켓링크 카카오톡 알림톡 연동이었다. 기존에는 SMS/MMS만 사용했는데, 카카오톡 알림톡을 지원하도록 하는 업무였다. 지금 생각해보면 업무는 단순했다. 카카오톡 API를 연동 인터페이스만 구현해주면 되는 것이었는데, 외부 API 연동을 처음 해보는터라 시간도 오래걸리고, 회사 소스를 파악하면서 해야해서 1달이상의 시간이 걸렸던 것 같다.기존 코드의 리팩토링도 해가면서 해서, 나름 재미있게 개발을 했던 첫 업무였다.</p><h2 id="3~4월에는-캡차-시스템-개발을-진행했다">3~4월에는 캡차 시스템 개발을 진행했다.</h2><p>티켓시스템에는 사람들이 좌석을 빨리 차지하기 위해 매크로를 많이 쓴다.최근에는 뉴스기사에도 아이돌 콘서트니, 인기 공연에 대해 매크로를 돌려서 빠르게 예매한 다음에 몇배의 가격으로 불려서 암표를 파는 사람이 많다는 기사가 나왔다. 최소한이라도 예방하기 위해 티켓링크에서는 캡차 도입을 고민하고 있었다. 구글의 리캡차나 국내의 캡차 솔루션을 도입하자라는 의견도 나왔고, 직접 구축하는 것이 좋다!라는 의견이 나오고 있을때쯤 집에서 한번 오픈소스를 이용해서 간단하게 캡차를 만들어보았다. 어렵지 않게 예시를 만들수 있었고, 다음날 바로 팀장님께 보여드렸다. 그렇게 캡차 개발은 내 업무가 되었다^^나름 보안과 성능을 생각하며, 이미지 캐싱등의 작업을 하였다. 그리고 캡차를 사용하기 위해서는 Global캐시 Store가 하나는 필요했다. 이로인해 팀에서 NoSQL 도입을 생각하게 되었다.캡차 개발 완료 후 nGrinder를 통해 성능테스트로 진행하였는데 15,000 TPS정도의 높은 성능이 나와서 나름 만족하고 있었다.(하지만 아직 회사에서 인기 공연이나 예매에 사용을 안해서.. 아쉬웠다.)</p><h2 id="redis-도입">Redis 도입</h2><p>캡차 사용을 위해 Redis를 도입하게 되었다. 원래 사용하는 NoSQL이 있지만, 추가적으로 NoSQL서버를 자체 구축할 예정이었다. (이유는 따로 적지 않겠다.) 여러가지 NoSQL이 물망에 올랐다. Redis, Arcus등 여러가지 Key-value store가 거론되었지만, 내 욕심 상 Redis를 해보고 싶었다. (아무래도 Key-value store 1순위인 Redis를 써보고 싶었다.)Redis를 도입하면서 단순하게 서버에 Redis만 설치해서 쓰고 싶지는 않았다. 인프라 시스템은 항상 scale out을 고려해야 했기 때문에, 주변에서 Docker를 이용해서 설치 해보라는 얘기가 나왔다.Docker는 난생 처음 들어보는 거였는데.. Docker에 대한 삽질을 어마무시하게 하면서 거의 3주만에 Redis 설치와 Cluster 설치까지 완료했다. 이 기회를 가지면서 Redis에 대한 전반적인 이해가 생기게 되었고, 나름 삽질을 거치면서 Docker라는 시스템도 어느정도 이해하게 되었다. (다시는 까먹지 않게 팀내에서도 3일에 걸쳐 공유를 하고 11부작 정도로 블로그도 작성해 두었다^^)</p><h2 id="결제시스템-개편">결제시스템 개편</h2><p>어쩌다보니 내가 티켓링크 결제 시스템 '부'가 되어서 티켓링크 결제시스템 개편 업무를 많이 했다.Payco결제, IC카드결제, 네이버페이 연동등을 경험하며, 외부 빌링업체의 결제 프로세스를 경험 할 수 있던 기회였다.네이버페이는 거의 처음부터 만들게 되었는데, Web에서의 결제, App에서의 결제를 모두 봐야 해서 꽤 고생했던 기억이 있다. 하지만 결제관련 Flow는 어느정도 알게 되었던 업무였다.</p><h2 id="msa시도-해보기">MSA시도 해보기</h2><p>티켓링크 시스템은 Monolothic 시스템 구조를 가지고 있다. 그렇기 때문에 빌드시간도 만만치않게 걸리고 배포하려고 해도 사이드 이펙트가 발생할 확률이 높다. 그렇기 때문에 올해 말부터 하나씩 하나씩 쪼개는 작업을 진행하고 있다. MSA까지는 아니어도 점진적으로 모듈을 분리하여, 빌드 시간을 단축 시키고, 시스템 안정성을 높이기 위함에 있다.이 부분에 대해서는 나도 의견을 많이 내고 시니어 개발자분들도 관심있게 보는 부분이어서, 내년에 더 활발하게 작업이 진행 될 것 같다.</p><h1 id="내년에는">내년에는..</h1><p>내년 공부의 시작은 개발 필독 서적을 몇가지 읽어보려고 한다.</p><ul><li>clean code</li><li>TDD 개발 방법론</li><li>Effective Java 3rd Edition(2rd Edition은 한번봤는데, Java8에 대한 내용이 추가되었다고 하니 한번더 봐야겠다.)</li><li>Java ORM 표준 JPA프로그래밍</li><li>현재 MyBatis기반으로 시스템이 구성되어있는데, 새로 만드는 시스템은 무조건 JPA를 도입하자고 얘기가 나오고 있다. 이전 회사에서 JPA사용경험이 있어서 나도 JPA도입을 대찬성하고 있는데, 더 지식을 쌓고 개발할 필요성을 느끼고 있다. 그래서 이 책을 아마 1순위로 공부하지 않을까.. 싶다.</li></ul><p>회사 업무에서는 주니어 개발자이지만, 목소리를 내보려 노력하고 있다.팀에서도 그런 분위기를 조성하려하고 있는 것 같고, 내 의견이 묵살되더라도 생각이라도 해보고, 다른사람의 의견과 비교할 수 있기 때문에 적극적으로 목소리를 내보고자 한다.</p><h1 id="마무리">마무리..</h1><p>올해 회고를 쭉 작성해보니 생각보다 많은 일을 했다는 생각이 든다. 그리고 그 과정 속에서 한단계 더 성장한 개발자가 되었다고 나름 생각하고 만족하고 있다. 회고를 쓰면서 회사 얘기가 조금 나와서.. 글을 좀 수정해야 할 경우가 생길 수도 있지만.. 딱히 그럴만한 내용은 없다고 생각이 든다.앞으로는 1년 단위로 회고를 작성하여 한번씩 되돌아보고 추억할 수 있는 시간이 되면 좋겠다.</p>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/16/2018-12-16-remind/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (11) Redis-Cli Docker로 사용하기</title>
      <link>https://jaehun2841.github.io/2018/12/07/2018-12-07-docker-11/</link>
      <guid>https://jaehun2841.github.io/2018/12/07/2018-12-07-docker-11/</guid>
      <pubDate>Fri, 07 Dec 2018 12:08:14 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;들어가며&quot;&gt;들어가며&lt;/h1&gt;
&lt;p&gt;Redis를 운영하다 보면 redis-cli를 주로 사용하게 되는데
항상 docker exec 명령을 통해 docker container 내의 redis-cli를 사용하여 불편한 점이 많았습니다.&lt;/p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="들어가며">들어가며</h1><p>Redis를 운영하다 보면 redis-cli를 주로 사용하게 되는데항상 docker exec 명령을 통해 docker container 내의 redis-cli를 사용하여 불편한 점이 많았습니다.</p><p>찾아보니 간단하게 Docker로 Redis-cli를 사용할 방법이 있어 기록을 남기게 되었습니다.</p><h1 id="docker로-redis-cli-접속하기">Docker로 Redis-cli 접속하기</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it \                                  </span><br><span class="line">                --rm \ </span><br><span class="line">                --net host \ </span><br><span class="line">                redis:5.0.0-alpine redis-cli \</span><br><span class="line">                -a <span class="string">"&lt;password&gt;"</span> \</span><br><span class="line">                -p &lt;port&gt;</span><br></pre></td></tr></table></figure></p><ul><li>it 옵션 : container와 conversation이 가능한 옵션</li><li>rm옵션 : container가 종료되면 container를 삭제</li><li>net옵션 : network 옵션</li><li>redis:5.0.0-alpine redis-cli : redis:5.0.0-alpine이미지의 redis-cli를 사용</li><li>a 옵션 : redis에서 requirepass를 사용하는 경우 password를 적어준다.</li><li>p 옵션 : 접속 port</li><li>h 옵션 : 접속하고자 하는 host (옵션 안주면 127.0.0.1로 접속한다)</li></ul><h1 id="docker-redis-cli로-cluster-설정하기">Docker Redis-cli로 cluster 설정하기</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it \                                  </span><br><span class="line">                --rm \ </span><br><span class="line">                --net host \ </span><br><span class="line">                redis:5.0.0-alpine redis-cli \</span><br><span class="line">                -a <span class="string">"&lt;password&gt;"</span></span><br><span class="line">                --cluster create host:port host:port host:port  \  //master host&amp;port</span><br><span class="line">                 host:port host:port host:port \ //slave host&amp;port</span><br><span class="line">                --cluster-replicas 1</span><br></pre></td></tr></table></figure></p><ul><li>--cluster : cluster mode 명령어 수행</li><li>create : cluster 생성 명령</li><li>--cluster-replicas 1 : Redis Replication 명령, Master node 1개당 Slave node 1개를 의미</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/07/2018-12-07-docker-11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (10) Redis Cluster Mode 설정하기</title>
      <link>https://jaehun2841.github.io/2018/12/03/2018-12-03-docker-10/</link>
      <guid>https://jaehun2841.github.io/2018/12/03/2018-12-03-docker-10/</guid>
      <pubDate>Mon, 03 Dec 2018 06:54:18 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;들어가며&quot;&gt;들어가며&lt;/h1&gt;
&lt;p&gt;이전 장 까지 했던 Redis 구조는 &lt;code&gt;Redis Replication + Redis Sentinel&lt;/code&gt;을 이용한 failover 기능을 구성하고 있었습니다. Spring Applica
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="들어가며">들어가며</h1><p>이전 장 까지 했던 Redis 구조는 <code>Redis Replication + Redis Sentinel</code>을 이용한 failover 기능을 구성하고 있었습니다. Spring Application에서 Jedis를 이용하여 Application sharding을 구성하여 사용을 하였습니다. 이렇게 Redis를 잘 사용하나 싶었지만, 최근 Spring Cache Abstraction에 대해 공부했었고, Redis Replication + Sharding + Failover를 사용하면서 <strong>Spring-Data-Redis를 사용할 방법이 없을까?</strong> 라는 생각을 하게 되었습니다.</p><p>맨 처음에 회사에서 Spring + Redis연동을 할 때 당연히 Spring-Data-Redis를 염두하고 시작을 했었지만, 어느 블로그에서 <strong>Spring-Data-Redis는 Sharding을 지원하지 않는다!</strong> 라는 절망적인 얘기를 보고 여태까지 Docker를 이용해 설치한 방식에서 Jedis를 이용한 Sharding을 이용하고 있었습니다.</p><p>그 이후, Redis 관련 문서를 쭉 보던 중.. Redis 공식 홈페이지에서 <code>Redis Cluster Mode</code>에 대한 내용을 보게 되었습니다.그 내용을 요약하자면</p><ul><li>Redis3 버전 부터 Redis는 <code>Cluster Mode</code>를 지원한다.</li><li>Cluster Mode에서는 Redis Sentinel의 도움없이 <code>Cluster 자체적으로 Failover를 진행</code>한다.</li><li>Cluster Mode에서는 Master-Slave 노드 구조를 가질 수 있고, <code>노드 간 Replication을 지원</code>한다.</li><li>Cluster Mode에서는 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행<code>Auto Sharding을 지원</code>한다 (이야!!!!!!!!!!!!)</li><li>Application Sharding이 필요없기 때문에, <code>Spring-Data-Redis 사용이 가능하다.</code>(사실은 이 목적 때문에 Cluster Mode 설치를 해보게 되었습니다.)</li></ul><h1 id="기존에-설치한-redis-구조와-다른-점은">기존에 설치한 Redis 구조와 다른 점은?</h1><h2 id="이전-장까지-설치-했던-redis-구조">이전 장까지 설치 했던 Redis 구조</h2><p><img src="./Redis-Cluster-archi.PNG" alt="Redis-Cluster-archi"></p><ul><li>Master - Slave -Slave 구조</li><li>Redis Sentinel을 이용한 Master 감시 + Fail over 기능 지원</li><li>HAProxy를 이용한 Master / Slave 접근 Port 분리</li></ul><h2 id="새롭게-구성한-redis-cluster">새롭게 구성한 Redis Cluster</h2><p><img src="./new-redis-cluster.PNG" alt="new-redis-cluster"></p><ul><li><p>HAProxy는 5000번 포트만 사용하도록 축소 5001~5005는 불필요하기 때문</p><ul><li>앞으로는 무조건 Master에만 통신</li><li>어떤 Node와 통신하여 데이터를 set하거나 get 할 수 있음 (Cluster Mode 지원)</li><li>어떤 Node에 set하더라도 자동으로 Sharding</li></ul></li><li><p>감시자 역할의 Sentinel 제거</p><ul><li>Cluster Mode에서는 Redis Node끼리 감시하며 Fail over가 가능합니다.</li></ul></li><li><p>Slave 갯수도 한개로 축소</p></li></ul><h1 id="cluster-mode에서-지원하는-기능">Cluster Mode에서 지원하는 기능</h1><h2 id="fail-over">Fail Over</h2><p><img src="./new-redis-cluster2.PNG" alt="new-redis-cluster2"></p><ul><li>Redis Cluster Mode에서는 기존의 Sentinel을 별도로 설치하여 감시자 역할을 하는 것에서 벗어나 Cluster 자체적으로 Node들을 감시하고 Failover를 수행 할 수 있습니다.</li><li>Redis Cluster Mode를 사용하기 위해서는 각 Redis Node 별로 2개의 port가 열려 있어야 합니다.<ul><li>6379, 6380 default - Redis 서버 접속 포트</li><li>16379, 16380 default  <code>(접속 포트 + 10000)</code> - Redis Cluster Bus</li></ul></li><li>Cluster Bus를 이용해 Redis Cluster는 각 노드를 감시하고 서버 다운 시 또는 Connection 유실 시 Fail over를 수행합니다.</li><li>Cluster Bus는 노드 간 데이터 교환에 대해 다른 바이너리 프로토콜을 사용합니다.</li><li>이 프로토콜은 대역폭과 처리 시간을 적게 사용하여 노드 간에 정보를 교환하는 데 더 적합합니다.</li></ul><h2 id="auto-sharding">Auto Sharding</h2><ul><li>Redis Cluster Mode에서는 자동으로 Cluster Node에 대한 자동 샤딩을 제공합니다.</li><li>Redis Cluster에는 16384개의 slot이 있으며, slot에 대한 구간 별로 샤딩이 가능합니다.</li><li>slot을 계산하기 위해 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행합니다.<ul><li>[0-5500] 까지는 1번 Redis Node에 저장</li><li>[5501-11000] 까지는 2번 Redis Node에 저장</li><li>[11001-16384] 까지는 3번 Redis Node에 저장</li><li>Redis Node가 scale out 되는 경우 Master Node 수를 나눈 만큼 대역이 할당</li></ul></li></ul><h2 id="redis-cli를-이용한-cluster-명령">Redis-cli를 이용한 cluster 명령</h2><p>Redis 5버전에 포함된 redis-cli 버전 부터 cluster 옵션이 추가 되었습니다.Redis 4버전 이하에 대해서는 별도로 Ruby 기반의 프로그램을 설치해야 되서 번거로워서, Redis 5버전으로 설치를 해보았습니다. (성능도 더 좋을라나?ㅎ)</p><h3 id="redis-cluster-생성">Redis Cluster 생성</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.137.101:6379 192.168.137.102:6379 192.168.137.103:6379 \</span><br><span class="line">192.168.137.102:6380 192.168.137.103:6380 192.168.137.101:6380 \</span><br><span class="line">--cluster-replicas 1</span><br></pre></td></tr></table></figure></p><ul><li>Redis Cluster를 생성하기 위해서는 Master Node가 최소 3개 이상 필요합니다.</li><li>맨 처음 등록하는 3개의 노드가 Master Node</li><li><code>--cluster-replicas 1</code> 의 의미는 각 Slave Node가 1개임을 의미합니다.</li><li>6개의 노드가 등록 되었다면 처음 3개는 Master, 뒤의 3개는 Slave가 됩니다</li><li>Slave는 선언된 순서 대로 Master의 Slave로 등록 됩니다<ul><li>192.168.137.101:6379 -&gt; 192.168.137.102:6380</li><li>192.168.137.102:6379 -&gt; 192.168.137.103:6380</li><li>192.168.137.103:6379 -&gt; 192.168.137.101:6380</li></ul></li></ul><p><img src="./cluster-setting.PNG" alt="cluster-setting"></p><p><img src="./cluster-setting2.PNG" alt="cluster-setting2"></p><p>redis-cli에 접속하여 cluster nodes 명령어로 cluster를 구성하는 nodes에 대한 정보를 조회해 보았습니다.</p><p><img src="./cluster-nodes.png" alt="cluster-nodes"></p><h3 id="redis-node-add-remove">Redis Node ADD / REMOVE</h3><p>새로운 노드를 추가하는 과정은 기본적으로 2가지입니다.</p><ul><li>새로운 Master를 추가하는 경우</li><li>새로운 Slave를 추가하는 경우</li></ul><h3 id="master-추가">Master 추가</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.137.104:6379 192.168.137.101:6379</span><br></pre></td></tr></table></figure></p><ul><li>위 명령은 cluster에 새로운 노드를 추가하는 명령어입니다.</li><li>192.168.137.101:6379 구성 된 Cluster에 192.168.137.104:6379 추가한다는 명령어입니다.</li><li>cluster를 지정할 때는 master node를 아무거나 지정하면 됩니다. (192.168.137.101~103:6379)</li><li>여기까지 했을 때는 Cluster에 일원이 되어 Cluster로 묶여는지나, <code>실제로 데이터는 저장 되지 않습니다.</code></li><li>hash slot이 할당 되지 않았기 때문에 데이터는 저장되지 않습니다.</li><li><code>re-sharding</code>을 통해 slot의 대역을 할당 받아야 합니다.</li></ul><h3 id="slave-추가">Slave 추가</h3><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave</span><br></pre></td></tr></table></figure></p><ul><li>위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.</li><li>이 경우에는 새롭게 추가된 노드를 <code>복제본의 수가 적은 마스터</code> 나 임의의 마스터에 대한 Slave로 추가됩니다.</li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave\</span><br><span class="line">--cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e1</span><br></pre></td></tr></table></figure></p><ul><li>위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.</li><li>이 경우에는 master node를 지정하기 때문에 특정 master-id에 해당하는 master node의 slave로 추가됩니다.</li></ul><h2 id="node-제거">Node 제거</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node 192.168.137.101:6379 `&lt;node-id&gt;`</span><br><span class="line">redis-cli --cluster del-node 192.168.137.101:6379</span><br><span class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br></pre></td></tr></table></figure></p><ul><li>위 명령은 Redis Cluster의 node를 제거하는 명령어입니다.</li><li>Redis Cluster에 포함된 아무 node를 적어준다 <code>192.168.137.101:6379 는 Redis Cluster 노드 중 하나</code></li><li>node-id는 삭제하고자 하는 node의 id입니다.</li><li>node-id는 cluster nodes 명령어를 통해 검색하여 적어줍니다.</li><li>Slave는 막 지울 수 있습니다!</li><li>하지만 <strong>Master는 노드에 저장된 내용이 하나도 없어야 삭제가 가능합니다.</strong></li><li>지울 수 있는 대안으로는 수동으로 failover를 하여 slave로 만든 다음에 삭제를 하는 방법이 있습니다.</li></ul><h3 id="re-sharding">Re-sharding</h3><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 192.168.137.101:6379</span><br></pre></td></tr></table></figure></p><ul><li>위 명령은 현재 cluster에 대한 reshard를 수행하는 명령어입니다.</li><li>cluster내의 master node 아무거나 써주면 자동으로 cluster node를 스캔하여 reshard를 수행합니다.</li><li>resharding 중에도 무중단으로 redis를 사용할 수 있습니다.</li><li>하지만 resharding을 <strong>수행하는 key에 대해서는 lock이 걸립니다.</strong></li><li>만약 resharding 대상이 많은 경우에는 redis 서버가 중지되었다가 다시 시작 될 수 있습니다.</li></ul><h1 id="redis-설치">Redis 설치</h1><h2 id="docker-설정하기">Docker 설정하기</h2><h3 id="docker-composeyml">docker-compose.yml</h3><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">   redis-master:</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">redis:5.0-alpine</span></span><br><span class="line"><span class="attr">      build:</span></span><br><span class="line"><span class="attr">         context:</span> <span class="string">..</span></span><br><span class="line"><span class="attr">         dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">      network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">      environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REQUIREPASS=&lt;password&gt;</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTPORT=6379</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"../../new_redis-data/redis1:/data"</span></span><br><span class="line"><span class="attr">      restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">   redis-slave:</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">redis:5.0-alpine</span></span><br><span class="line"><span class="attr">      build:</span></span><br><span class="line"><span class="attr">         context:</span> <span class="string">..</span></span><br><span class="line"><span class="attr">         dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">      network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">      environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REQUIREPASS=&lt;password&gt;</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTPORT=6380</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"../../new_redis-data/redis2:/data"</span></span><br><span class="line"><span class="attr">      restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure></p><ul><li>redis-cli의 cluster option을 사용하기 위해 redis:5.0-alpine 버전을 사용하였습니다.</li><li>redis:5.0.0이 RELEASE 버전이지만, Dockerfile에서 sed 명령어 사용 시, <code>Permission denied</code>가 발생하는 버그가 있습니다.</li><li>network_mode 는 <code>host</code>로 설정. <code>Docker Redis는 NAT에 대한 지원을 하지 않습니다.</code></li><li>외부 볼륨 연동을 위해 ../../new_redis-data/master 폴더와 docker container 내의 /data 폴더를 연동하였습니다.</li><li>container down 시 항상 재시작 하도록 restart policy를 always로 설정 하였습니다.</li></ul><h3 id="docker-entrypointsh">docker-entrypoint.sh</h3><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment">## from redis-5</span></span><br><span class="line">sed -i <span class="string">"s/bind 127.0.0.1/bind <span class="variable">$CLIENTHOST</span> 127.0.0.1/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">sed -i <span class="string">"s/port 6379/port <span class="variable">$CLIENTPORT</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">sed -i <span class="string">"s/# requirepass foobared/requirepass <span class="variable">$REQUIREPASS</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">sed -i <span class="string">"s/# masterauth &lt;master-password&gt;/masterauth <span class="variable">$REQUIREPASS</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">sed -i <span class="string">"s/# cluster-enabled yes/cluster-enabled yes/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">sed -i <span class="string">"s/# cluster-config-file nodes-6379.conf/cluster-config-file nodes.conf/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">sed -i <span class="string">"s/# cluster-node-timeout 15000/cluster-node-timeout 5000/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;1#-&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ] || [ <span class="string">"<span class="variable">$&#123;1%.conf&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">set</span> -- redis-server <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'redis-server'</span> -a <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></span><br><span class="line">chown -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure></p><ul><li>sed명령어를 통해 container내의 redis.conf파일을 치환<code>치환자에 대한 설정은 docker-compose.yml &gt; environment에 등록</code><ul><li>bind 옵션에 대해 CLINET IP를 설정</li><li>port도 기본 6379 port에서 6379, 6380으로 치환하였습니다.</li><li>requirepass도 설정</li><li>masterauth도 requirepass와 동일하게 설정</li><li>cluster-mode를 사용하기 위해 <code>cluster-enable yes</code>로 설정</li><li>cluster에 대한 로그를 볼 수 있도록 <code>cluster-config-file nodes.conf</code> conf 파일 지정 (여기에 로그 생성)</li><li>cluster failover를 위해 <code>cluster-node-timeout</code>을 5초로 지정</li></ul></li></ul><h1 id="failover-test">Failover Test</h1><p>테스트를 위해 192.168.137.101:6379 (master1)에 대한 docker container를 죽여보았습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 030bb02a246e</span><br></pre></td></tr></table></figure></p><p><img src="./master-down.png" alt="master-down"></p><ul><li>docker ps -a 명령으로 볼 때 192.168.137.101:6379 (master1)에 대한 docker container가 다운!!</li></ul><p><img src="./failover-1.png" alt="failover-1"></p><ul><li><p>5초 정도 지나니 무슨 로그가 올라왔습니다. epoch vote라는 로그를 보아하니 새로운 마스터를 선출하였습니다.</p></li><li><p>redis-cli를 통해 <code>cluster nodes</code>를 검색해 보니 <code>192.168.137.101:6379 (master1)</code>의 slave였던 <code>192.168.137.103:6380 (slave1)</code> 가 새로운 master로 promote 되었습니다.</p></li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 030bb02a246e</span><br></pre></td></tr></table></figure></p><ul><li>docker start 명령으로 다시 container를 살려보았습니다.</li></ul><p><img src="./failover2.png" alt="failover2"></p><ul><li>기존의 master는 slave로 편입되어 정상적인 cluster가 작동하고 있습니다.</li></ul><h1 id="sharding-test">Sharding Test</h1><p><img src="./cluster-keys-command.PNG" alt="cluster-keys-command"></p><ul><li>redis-cli를 통해 foo1~foo10까지 key를 만들어 set해 보았습니다.</li><li>set할때 마다 16384 modules 연산을 통해 slot별로 sharding이 되는 모습입니다.</li><li>각 redis-cli에서 keys * 명령을 통해 조회 해보면 고르게 sharding이 되어있음을 확인 할 수 있습니다.</li></ul><h1 id="node-addremove">Node ADD/REMOVE</h1><p><img src="./cluster-add.PNG" alt="cluster-add"></p><ul><li>신규 Master node (192.168.137.104:6379)를 새로이 추가해 보았습니다.</li></ul><p><img src="./cluster-add-node-slave.PNG" alt="cluster-add-node-slave"><img src="./slave-add-result.png" alt="slave-add-result"></p><ul><li>신규 Slave node (192.168.137.104:6380)를 새로이 추가해 보았습니다.</li><li>신규 Master node (192.168.137.104:6379)의 slave로 추가해보았다.</li><li>정상적으로 모두 등록 되었다.</li></ul><p><img src="./slave-del.png" alt="slave-del"></p><ul><li>slave를 삭제해 보았습니다.</li></ul><p><img src="./slave-del-result.png" alt="slave-del-result"></p><ul><li>slave가 정상적으로 삭제 되었습니다.</li></ul><p><img src="./master-del-fail.png" alt="master-del-fail"></p><ul><li>master 삭제를 시도해 보았습니다.</li><li>slot이 비어있지 않아 삭제가 불가능 했습니다.</li><li>이런 경우 reshard를 통해 slot을 비워준뒤에 삭제 해야합니다.</li></ul><p><img src="./sub-reshard.PNG" alt="sub-reshard"></p><ul><li>reshard 명령을 다시 실행 합니다.</li><li><code>What is the receiving node ID?</code> 라는 질문에 192.168.137.101:6379 node-id를 지정합니다.</li><li><code>Source node</code> 항목에는 우리가 삭제할 192.168.137.104:6379 node-id를 지정합니다.</li><li><code>source node</code> 두번째 항목에는 done을 입력하여 Source node 항목을 모두 입력하였음을 선언해 줍니다.</li></ul><p><img src="./master-del-success.png" alt="master-del-success"></p><ul><li>다시 master를 삭제하니 정상적으로 삭제가 됩니다.</li></ul><h1 id="re-sharding-test">Re-Sharding Test</h1><p><img src="./reshard-test-1-3831920.PNG" alt="reshard-test-1"></p><ul><li>새롭게 추가한 노드에 reshard를 해보았습니다.</li><li>4000개정도를 새로이 옮긴다고 조건을 주고 Resharding을 실행 해보았습니다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br></pre></td></tr></table></figure></li></ul><p><img src="./reshard-test-2-3832564.PNG" alt="reshard-test-2"></p><p><img src="./reshard-test-3.PNG" alt="reshard-test-3"></p><ul><li>정상적으로 resharding이 되어 데이터가 4개의 node에 고르게 분포 되었습니다.</li></ul><h1 id="참고">참고</h1><ul><li>https://redis.io/topics/cluster-tutorial</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/03/2018-12-03-docker-10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (9) Redis-Stats을 이용한 모니터링</title>
      <link>https://jaehun2841.github.io/2018/12/03/2018-12-03-redis-stats/</link>
      <guid>https://jaehun2841.github.io/2018/12/03/2018-12-03-redis-stats/</guid>
      <pubDate>Mon, 03 Dec 2018 06:04:50 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;redis-stats&quot;&gt;Redis-stats&lt;/h1&gt;
&lt;p&gt;Redis-stat은 대표적인 &lt;code&gt;오픈소스 Redis 모니터링 도구&lt;/code&gt;입니다.&lt;/p&gt;
&lt;p&gt;Ruby 기반으로 동작하는 프로그램이며, Ruby만 설치되어 있다면 설
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="redis-stats">Redis-stats</h1><p>Redis-stat은 대표적인 <code>오픈소스 Redis 모니터링 도구</code>입니다.</p><p>Ruby 기반으로 동작하는 프로그램이며, Ruby만 설치되어 있다면 설치가 간편하고 Web 또는 Console로 Redis 서버를 모니터링 할 수 있습니다.비슷한 모니터링 도구로 Redmon, RedisLive등이 있지만.. Redis 4이상 버전을 아직 지원하지 않아서 Redis-stat으로 설치 해보게 되었습니다.</p><h1 id="redis-stats-설치하기">Redis-stats 설치하기</h1><h2 id="install-dependency">Install Dependency</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc-c++ patch readline readline-devel zlib zlib-devel openssl-devel make</span><br><span class="line">yum install -y bzip2 autoconf automake libtool bison iconv-devel sqlite-devel libyaml-devel libffi-devel</span><br></pre></td></tr></table></figure></p><h2 id="install-rvm-ruby-version-manager">Install RVM (Ruby Version Manager)</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://rvm.io/mpapis.asc | gpg --import</span><br><span class="line">curl -L get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure></p><h2 id="setup-rvm-environment">Setup RVM Environment</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile.d/rvm.sh</span><br><span class="line">rvm reload</span><br></pre></td></tr></table></figure></p><h2 id="install-ruby-233">Install Ruby 2.3.3</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm install 2.3.3</span><br></pre></td></tr></table></figure></p><h2 id="set-default-ruby-version">Set Default Ruby Version</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rvm list</span><br><span class="line">rvm use 2.3.3 --default</span><br></pre></td></tr></table></figure></p><h2 id="setup-redis-stat">Setup Redis-stat</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install redis-stat</span><br></pre></td></tr></table></figure></p><h1 id="redis-stat-실행하기">Redis-stat 실행하기</h1><p>Redis-stat은 Web에서 조회하는 방법과 Console에서 조회하는 방법이 있습니다.두 가지 형태의 모니터링 방법과 속성에 대해 알아보겠습니다.</p><h2 id="redis-stat-옵션">Redis-stat 옵션</h2><table><thead><tr><th><strong>명령어</strong></th><th><strong>설명</strong></th><th><strong>비고</strong></th></tr></thead><tbody><tr><td>redis-stat 1</td><td>localhost:6379 1초 간격으로 조회</td><td></td></tr><tr><td>redis-stat 1 10</td><td>localhost:6379 1초 간격으로 10회 조회</td><td></td></tr><tr><td>redis-stat --verbose</td><td>localhost:6379 2초 간격으로 보여주기</td><td></td></tr><tr><td>redis-stat 192.168.0.2:6379 192.168.0.2:6380 5</td><td>192.168.0.2:6379 192.168.0.2:6380서버를 5초 간격으로 보여주기</td><td></td></tr><tr><td>redis-stat --csv=/temp/redis-log.csv</td><td>csv파일 남기기</td><td></td></tr><tr><td>redis-stat --daemon --server 8888</td><td>daemon 모드로 실행 port 8888번으로 접속 시, Web Monitoring mode로 작동</td><td>daemon과 server는 반드시 같이 사용해야하는 옵션</td></tr><tr><td>redis-stat -a (--auth) password</td><td>-a 또는 --auth 옵션을 통해 requirepass 비밀번호 설정</td><td></td></tr></tbody></table><h2 id="redis-stat-console-monitoring">Redis-stat (Console Monitoring)</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#192.168.137.101 서버의 6379~6381 포트 정보를 조회</span></span><br><span class="line">redis-stat 1 -a password1234 \</span><br><span class="line">192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381</span><br></pre></td></tr></table></figure></p><p><img src="./redis-stat-1.PNG" alt="redis-stat-1"></p><h2 id="redis-stat-web-monitoring">Redis-stat (Web Monitoring)</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># CentOs 방화벽 포트 open</span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-port 8888/tcp</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"> </span><br><span class="line"><span class="comment">#192.168.137.101 서버의 6379~6381 포트 정보를 조회</span></span><br><span class="line">redis-stat 1 -a &lt;requirepass&gt; \</span><br><span class="line">192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381 \</span><br><span class="line">--daemon --server=8888</span><br></pre></td></tr></table></figure></p><h2 id="1921681371048888-서버로-접속">192.168.137.104:8888 서버로 접속</h2><p><img src="./redis-stat-web.PNG" alt="redis-stat-web"></p><p><img src="./redis-stat-web2.PNG" alt="redis-stat-web2"></p><h1 id="아쉬운-점">아쉬운 점</h1><ol><li>그 당시의 모니터링만 가능하다. (별도 저장소가 없기 때문) -&gt; 이전 로그를 보기 위해선 CSV 파일을 남기는 것이 최선</li><li>보고자 하는 정보가 적다. 기본적으로 메모리 사용량, Client 수 Key Size정도는 제공을 하지만 다른 툴에서는 더 많은 정보가 제공되는 것 같다.</li></ol><h1 id="참고">참고</h1><ul><li><a href="https://github.com/junegunn/redis-stat" target="_blank" rel="noopener">https://github.com/junegunn/redis-stat</a></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/03/2018-12-03-redis-stats/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (8) HAProxy를 이용한 분산처리 환경 구축하기</title>
      <link>https://jaehun2841.github.io/2018/12/02/2018-12-02-docker-8/</link>
      <guid>https://jaehun2841.github.io/2018/12/02/2018-12-02-docker-8/</guid>
      <pubDate>Sun, 02 Dec 2018 11:32:11 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;haproxy란&quot;&gt;HAProxy란?&lt;/h1&gt;
&lt;p&gt;HAProxy는 기존의 하드웨어 스위치(L4/L7)을 대체하는 소프트웨어 로드밸런서입니다.
로드 밸런싱이란 부하 분산을 위해서 가상IP를 통해 여러서버에 접속하도록 트래픽을 분배해 주는 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="haproxy란">HAProxy란?</h1><p>HAProxy는 기존의 하드웨어 스위치(L4/L7)을 대체하는 소프트웨어 로드밸런서입니다.로드 밸런싱이란 부하 분산을 위해서 가상IP를 통해 여러서버에 접속하도록 트래픽을 분배해 주는 기능을 의미합니다.</p><h1 id="redis-cluster에-haproxy가-필요한-이유">Redis-Cluster에 HAProxy가 필요한 이유</h1><p>Redis Cluster에서는 Failover가 일어날 수 있습니다.</p><p>처음에 1번이 Master였다가, 2번이 Master가 되고, 3번이 Master가 될 수 있습니다.하지만 Redis Cluster를 사용하는 Application에서 항상 바뀌는 Master의 포트정보를 찾는것은 매우 비용을 낭비하는 행위라 볼 수 있습니다.</p><p>따라서 HAProxy에서 Health check를 하면서 실시간으로 Master를 찾아 신호를 보내줄 수 있기 때문에 HAProxy를 Redis-Cluster에 접목하였습니다.</p><h1 id="다시-한번-보는-redis-cluster-구성도">다시 한번 보는 Redis Cluster 구성도</h1><p><img src="./Redis-Cluster-archi.PNG" alt="Redis-Cluster-archi"></p><p>HAProxy Port를 6개를 지정합니다. (각각 1개는 Master Port, Slave Port라고 가정하고 (1(master)+1(slave)) x 3 (서버대수))</p><p>5000, 5002, 5004번 Port는 각 서버의 Master Redis를 체크합니다.따라서 5000, 5002, 5004으로 들어온 요청은 각각의 서버의 Master Redis에 전달 됩니다.</p><p>다음으로 5001, 5003, 5005번 Port는 각 서버의 Slave Redis를 체크합니다.따라서 5001, 5003, 5005으로 들어온 요청은 각각의 서버의 Slave Redis들에게 전달됩니다. (HAProxy에는 여러 서버에 대한 분배방식을 설정 할 수 있는데 고루게 요청할 수 있도록 RoundRobin 방식으로 설정하였습니다)</p><h1 id="haproxy-설치방법">HAProxy 설치방법</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 관련 모듈을 yum으로 설치한다.</span></span><br><span class="line">yum install gcc gcc-c++ pcre-devel openssl-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># wget명령어도 haproxy 다운로드</span></span><br><span class="line">wget http://www.haproxy.org/download/1.8/src/haproxy-1.8.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 압축을 풀어준다.</span></span><br><span class="line">tar zxvf haproxy-1.8.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 디렉토리 이동</span></span><br><span class="line"><span class="built_in">cd</span> haproxy-1.8.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># c파일을 컴파일 해준다. https 사용이 필요한 경우 USE_OPENSSL=1 설정 추가</span></span><br><span class="line">make TARGET=linux2628 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># /usr/local/haproxy 디렉토리에 설치</span></span><br><span class="line">make PREFIX=/usr/<span class="built_in">local</span>/haproxy DESTDIR= install</span><br></pre></td></tr></table></figure></p><h1 id="haproxycfg-파일-작성">haproxy.cfg 파일 작성</h1><p>haproxy.cfg 파일을 작성 할 때는 크게 2가지 관점으로 작성합니다.</p><ul><li>frontend : haproxy에서 사용할 포트 설정, 포트로 신호가 왔을 시 실행할 backend 연결</li><li>backend : frontend로 부터 온 신호를 바탕으로 연결가능한 서버에 트래픽을 분배</li></ul><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">global</span><br><span class="line">  <span class="built_in">log</span> 127.0.0.1 local0</span><br><span class="line">  <span class="built_in">log</span> 127.0.0.1 local1 notice</span><br><span class="line"> </span><br><span class="line">defaults REDIS</span><br><span class="line">mode tcp</span><br><span class="line">timeout connect 4s</span><br><span class="line">timeout server 15s</span><br><span class="line">timeout client 15s</span><br><span class="line"><span class="comment"># timeout tunnel 365d</span></span><br><span class="line"> </span><br><span class="line">frontend front_redis_master1</span><br><span class="line"> <span class="built_in">bind</span> *:5000 name redis                 <span class="comment">#5000번 포트에 대한 bind 정보입니다.</span></span><br><span class="line"> default_backend back_redis_master1     <span class="comment">#5000번 포트로 신호가 들어오면 backend를 실행</span></span><br><span class="line"> </span><br><span class="line">backend back_redis_master1</span><br><span class="line"> option tcp-check                       <span class="comment">#tcp-check를 통해 접근가능한 서버 필터링</span></span><br><span class="line"> tcp-check send AUTH\ password1234\r\n  <span class="comment">#비밀번호 password1234를 입력하고 Redis 서버에 접속합니다.</span></span><br><span class="line"> tcp-check expect string +OK            <span class="comment">#OK가 왔는지?</span></span><br><span class="line"> tcp-check send PING\r\n                <span class="comment">#PING을 날려 신호를 점검합니다.</span></span><br><span class="line"> tcp-check expect string +PONG          <span class="comment">#PONG이라는 응답이 왔는지?</span></span><br><span class="line"> tcp-check send info\ replication\r\n   <span class="comment">#info replication 명령을 날려 Redis에 대한 정보를 받아옵니다.</span></span><br><span class="line"> tcp-check expect string role:master    <span class="comment">#role이 master인지 확인 합니다.</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">#repl_backlog_active의 값이 1인지 확인합니다 </span></span><br><span class="line"> <span class="comment">#이 조건을 추가한 이유는 Failover간 잠시의 시간동안 Master가 2대가 되는데 그것을 방지 하기 위함입니다.</span></span><br><span class="line"> <span class="comment">#(진짜 Master Redis에만 1, slave는 0)</span></span><br><span class="line"> tcp-check expect string repl_backlog_active:1 </span><br><span class="line"> tcp-check send QUIT\r\n                <span class="comment">#QUIT 명령을 전송</span></span><br><span class="line"> tcp-check expect string +OK</span><br><span class="line"> server redis1 192.168.137.101:6379 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis2 192.168.137.101:6380 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis3 192.168.137.101:6381 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> </span><br><span class="line">frontend front_redis_slave1</span><br><span class="line"><span class="built_in">bind</span> *:5001 name redis                <span class="comment">#5001번 포트에 대한 bind 정보입니다.</span></span><br><span class="line">default_backend back_redis_slave1</span><br><span class="line"> </span><br><span class="line">backend back_redis_slave1</span><br><span class="line"> balance roundrobin                   <span class="comment">#라운드 로빈 방식으로 분배</span></span><br><span class="line"> option tcp-check</span><br><span class="line"> tcp-check send AUTH\ password1234\r\n        </span><br><span class="line"> tcp-check expect string +OK</span><br><span class="line"> tcp-check send PING\r\n              </span><br><span class="line"> tcp-check expect string +PONG</span><br><span class="line"> tcp-check send info\ replication\r\n </span><br><span class="line"> tcp-check expect string role:slave   <span class="comment">#role key가 slave인지 확인 합니다.</span></span><br><span class="line"> tcp-check send QUIT\r\n</span><br><span class="line"> tcp-check expect string +OK</span><br><span class="line"> server redis1 192.168.137.101:6379 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis2 192.168.137.101:6380 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis3 192.168.137.101:6381 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#Listen on all IP's on port 9000 //9000 포트로 접근 시, Web Console에 진입할 수 있습니다. </span></span><br><span class="line">listen stats</span><br><span class="line">   <span class="built_in">bind</span> 0.0.0.0:9000 </span><br><span class="line">   mode http</span><br><span class="line">   balance</span><br><span class="line">   timeout client 5000</span><br><span class="line">   timeout connect 4000</span><br><span class="line">   timeout server 30000</span><br><span class="line"> </span><br><span class="line">   <span class="comment">#This is the virtual URL to access the stats page</span></span><br><span class="line">   stats uri /haproxy_stats //URL주소는 ip:9000/haproxy_stats입니다.</span><br><span class="line">   <span class="comment">#Authentication realm. This can be set to anything. Escape space characters with a backslash.</span></span><br><span class="line">   stats realm HAProxy\ Statistics</span><br><span class="line"> </span><br><span class="line">   <span class="comment">#The user/pass you want to use. Change this password!</span></span><br><span class="line">   stats auth admin:1234 <span class="comment">#Web Console에 접근하는 계정/암호 설정</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">#This allows you to take down and bring up back end servers.</span></span><br><span class="line">   <span class="comment">#This will produce an error on older versions of HAProxy.</span></span><br><span class="line">   stats admin <span class="keyword">if</span> TRUE</span><br></pre></td></tr></table></figure></p><p>위의 내용에서는 일단 하나의 Master-Slave에 대한 설정값만 있습니다.여태까지 설치 내용에서는 Master-Slave 구성이 3세트이기 때문에 실제 haproxy.cfg를 작성 할 경우에는5002~5005번 포트를 사용하는 설정에 대해서도 추가해야 합니다.</p><h1 id="haproxy-web-console-확인하기">HAProxy Web Console 확인하기</h1><p><img src="./haproxy1.PNG" alt="haproxy1"></p><p><strong>haproxy-server-ip:9000</strong> 으로 접속하였습니다현재 192.168.137.101 서버에는 6379, 6380, 6381 포트를 사용하는 Redis 노드가 3개가 동작하고 있습니다.현재 master 역할을 수행하는 것은 6380 포트를 사용하는 redis2 노드입니다.따라서 <strong>haproxy-server-ip:5000</strong> 으로 접속하게 되면 redis2 노드에 신호가 분배되어 Redis master서버에 대한 명령을 실행 할 수 있습니다.</p><p>현재 slave 역할을 수행하는 것은 6379, 6381포트를 사용하는 redis1, redis3노드 입니다.따라서 <strong>haproxy-server-ip:5001</strong>으로 접속하게 되면 RoundRobin 방식으로 redis1, redis3 노드에 신호가 분배되어 Redis slave 서버에 대한 명령을 실행 할 수 있습니다</p><blockquote><p><strong>HAProxy를 구성한 이유</strong></p><p>Application에서 Redis를 사용하면서, Master에만 데이터를 입력하고, Slave에서만 데이터를 조회하려는 행위를 많이 하게 됩니다. 아무래도 Redis서버에 대한 부하를 줄여주고자 이러한 행위를 하게 되는데, Haproxy를 설정 해 두면, Application Server에서 failover로 인해 변하는 master/slave 포트에 대한 걱정을 할 필요가 없습니다.HAProxy에서 알아서 tcp-check를 통해 master/slave를 정해주기 때문입니다.</p></blockquote><h1 id="failover-test">Failover Test</h1><p>Sentinel 테스트와 동일하게 Master를 죽여보도록 하겠습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;master-node-id&gt;</span><br></pre></td></tr></table></figure></p><p><img src="./haproxy2.PNG" alt="haproxy2"></p><p>Master node를 죽이니, 5000번 포트에서는 더이상 master로 갈 수 있는 서버가 없다고 나옵니다.(<strong>이 때 순단을 최소화 하려면 failover 시간과, HAProxy tcp-check 시간을 최소로 줄여야 합니다.</strong>)</p><p><img src="./haproxy3.PNG" alt="haproxy3"></p><p>잠시 시간이 지나고 Redis Failover가 진행됩니다. 진행이 완료되면, HAProxy에서도 tcp-check가 이루어집니다.</p><p><img src="./haproxy4.PNG" alt="haproxy4"></p><p>tcp-check가 끝나고 redis1 노드가 master로 선출되어, 5000번 포트로 접근 시, redis1 노드로 분산되게 됩니다.</p><p>다시, 죽었던 redis2 노드를 살려보겠습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;redis2_node_id&gt;</span><br></pre></td></tr></table></figure></p><p><img src="./haproxy5.PNG" alt="haproxy5"></p><p>redis2 노드가 다시 살아나고, sentinel에서도 role-change 작업이 이루어집니다.곧이어, HAProxy에서도 tcp-check를 통해 redis2노드가 slave가 되었음을 확인하고 5001 포트에서 분배가능한 서버로 분류됩니다.</p><p><img src="./haproxy6.PNG" alt="haproxy6"></p><p>이와 같이 Application Server에서는 무조건 master port는 5000번, slave port는 5001번 이라고만 알고 있으면 Redis서버에서 failover가 진행되더라도, 설정을 바꿀 필요없이 사용이 가능합니다.</p><h1 id="참고">참고</h1><ul><li>http://blog.whitelife.co.kr/321</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/02/2018-12-02-docker-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (7) Docker를 이용한 Redis Sentinel 설치하기</title>
      <link>https://jaehun2841.github.io/2018/12/02/2018-12-02-docker-7/</link>
      <guid>https://jaehun2841.github.io/2018/12/02/2018-12-02-docker-7/</guid>
      <pubDate>Sun, 02 Dec 2018 06:46:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;redis-sentinel이란&quot;&gt;Redis Sentinel이란?&lt;/h1&gt;
&lt;p&gt;Redis Cluster 운영환경에서 Master-Slave 관계를 가진 Redis가 있습니다.
시스템 오류나 알수 없는 원인으로 인해 Master Redis
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="redis-sentinel이란">Redis Sentinel이란?</h1><p>Redis Cluster 운영환경에서 Master-Slave 관계를 가진 Redis가 있습니다.시스템 오류나 알수 없는 원인으로 인해 Master Redis가 down되어 연결이 중단 되면, 사용자나 Application에서는 Redis Master를 통해 데이터를 등록 할 수 없게 됩니다.이런 경우 Slave Redis를 Master Redis로 승격시켜 시스템이 정상적으로 운영 될 수 있도록 해야 합니다.</p><p>이 때 사용하는 게 Redis Sentinel입니다.Sentinel은 Master Redis의 상태를 감시합니다. 그러다가 Master Redis가 Down이 되어버리면, Sentinel들은 Slave Redis들 중에 어떤 Redis 서버를 Master로 승격시킬지 투표하게 됩니다.Slave Redis 중 Sentinel의 투표를 더 많이 받은 Redis Server가 Master Redis로 승격됩니다.이후 장애를 해결한 원래 Master Redis는 재시작 시, 현재 Master Redis의 Slave Redis로 시작되게 됩니다.</p><p>이와같이, Redis Sentinel은 Redis Cluster 환경에서의 Failover를 자동으로 해주는 Redis의 한 Mode입니다.</p><h1 id="role-change-원리">Role Change 원리</h1><p><img src="./Redis-failover-1.PNG" alt="Redis-failover-1"></p><p>위의 상황은 6379 포트를 사용하는 Master Redis가 Down된 상황입니다.Sentinel들은 일제히 Master Redis를 감시하다가 Down된 상황을 인지하고2번째 그림처럼 Slave Redis들 중 어떤 Redis 서버를 Master Redis로 승격할 지 투표로 정하게 됩니다.여기서 중요한 건 Redis Sentinel의 노드 갯수는 <code>항상 홀수로 설정</code>해야 합니다. (짝수 인 경우 1:1, 2:2 상황이 되어 어떤 Redis Server를 승격 시킬지 알 수 없기 때문입니다.)위의 예제에서는 15485 번 포트를 사용하는 Slave Redis가 2대1로 선택되었습니다.Sentinel은 바로 redis.conf 파일을 조작하여 Slave Redis를 Master Redis로 변경합니다.그리고 자기 자신의 sentinel.conf 정보를 조작하여 감시하는 Redis 서버 정보를 update 합니다.이후 Down되었던 기존의 Master Redis의 장애가 처리되어 Restart되는 경우를 보도록 하겠습니다.</p><p><img src="./Redis-failover-2.PNG" alt="Redis-failover-2"></p><p>Sentinel은 Down되었던 Master 정보를 메모리에 저장하고 있습니다.이후 Down되었던 Master Redis가 장애를 처리하고 다시 시작 되는 경우, Master Redis의 redis.conf 파일을 조작하여현재 Master Redis의 Slave로 설정합니다.</p><blockquote><p>이 경우 Sentinel의 설정 값이 따라 다르지만,일시적으로 Master Redis가 2대가 됩니다.만약에 Down 되었다가 Restart된 Redis에 Data가 저장되는 경우, Slave Redis로 전환되면서 Master의 rdb파일을 바탕으로 Data를 Update하기 때문에 데이터가 사라지는 상황이 오게 됩니다.따라서 Down 되었다가 살아나는 Redis에 접근 하지 못하도록 막아야 합니다.</p></blockquote><h1 id="redis-sentinel-설치하기">Redis Sentinel 설치하기</h1><p>Docker, Docker-Compose, git은 Redis Cluster를 설치하며 설치 했다고 가정하겠습니다.</p><h2 id="redis-sentinel-파일-다운로드">Redis Sentinel 파일 다운로드</h2><p>기존에 github에 올려둔 Sentienel 설정파일을 다운로드 합니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkdir -p /home/redis/redis-sentinel <span class="comment">#Redis-sentinel home 생성</span></span><br><span class="line"><span class="built_in">cd</span> /home/redis</span><br><span class="line">mkdir -p ./sentinel-data/sentinel1   <span class="comment">#외부 log파일 볼륨 설정</span></span><br><span class="line">mkdir -p ./sentinel-data/sentinel2</span><br><span class="line">mkdir -p ./sentinel-data/sentinel3</span><br><span class="line"> </span><br><span class="line">git init</span><br><span class="line">git remote add origin <span class="string">"https://github.com/jaehun2841/redis-sentinel-on-docker.git"</span></span><br><span class="line">git pull origin master <span class="comment">#github에서 sentinel 설정 파일 다운로드</span></span><br></pre></td></tr></table></figure></p><h2 id="redis-sentinel-build">Redis sentinel Build</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/redis/redis-sentinel</span><br><span class="line">docker-compose -f conf/sentinel-docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure></p><h1 id="redis-sentinel-생성을-위한-docker-composeyml파일">Redis Sentinel 생성을 위한 docker-compose.yml파일</h1><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">  redis-sentinel1:</span>                        <span class="comment">#Sentinel Container명</span></span><br><span class="line"><span class="attr">     image:</span> <span class="string">lgatica/redis-sentinel:4.0.2</span>  <span class="comment">#redis-sentinel 이미지를 바탕으로 빌드합니다.</span></span><br><span class="line"><span class="attr">     build:</span></span><br><span class="line"><span class="attr">       context:</span> <span class="string">..</span>                        <span class="comment">#Dockerfile context 설정</span></span><br><span class="line"><span class="attr">       dockerfile:</span> <span class="string">Dockerfile</span>             <span class="comment">#Dockerfile명 설정 (Default는 Dockerfile로 된 파일명을 찾습니다.)</span></span><br><span class="line"><span class="attr">     network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">     environment:</span>                         <span class="comment">#Container에서 사용할 환경 변수 설정</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTPORT=26379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERPORT=6379</span>                   <span class="comment">#Sentinel의 mymaster port를 적어줍니다.</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">QUORUM=2</span>                          <span class="comment">#QUORUM 값은 Sentinel들이 투표했을때 득표수가 2 이상인 Redis에 대해 Master로 승격할 수 있도록 하는 조건 값입니다.</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DOWN_AFTER_MILLISEC=3000</span>          <span class="comment">#Redis master node down 후 3초 이후 failover 시작</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">FAILOVER_TIMEOUT=3000</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line"><span class="attr">     volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"../../sentinel-data/sentinel1:/redis"</span>  <span class="comment">#Container 외부 볼륨 설정</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span>                         <span class="comment">#restart policy Container가 중지되거나 down되는 경우 무조건 다시 시작합니다.</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">  redis-sentinel2:</span></span><br><span class="line"><span class="attr">     image:</span> <span class="string">lgatica/redis-sentinel:4.0.2</span></span><br><span class="line"><span class="attr">     build:</span></span><br><span class="line"><span class="attr">       context:</span> <span class="string">..</span></span><br><span class="line"><span class="attr">       dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">     network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTPORT=26380</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">QUORUM=2</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DOWN_AFTER_MILLISEC=3000</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">FAILOVER_TIMEOUT=3000</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line"><span class="attr">     volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"../../sentinel-data/sentinel2:/redis"</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">  redis-sentinel3:</span></span><br><span class="line"><span class="attr">     image:</span> <span class="string">lgatica/redis-sentinel:4.0.2</span></span><br><span class="line"><span class="attr">     build:</span></span><br><span class="line"><span class="attr">       context:</span> <span class="string">..</span></span><br><span class="line"><span class="attr">       dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">     network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTPORT=26381</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">QUORUM=2</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DOWN_AFTER_MILLISEC=3000</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">FAILOVER_TIMEOUT=3000</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line"><span class="attr">     volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"../../sentinel-data/sentinel3:/redis"</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure></p><h1 id="redis-sentinel-이미지-생성을-위한-dockerfile-작성">Redis Sentinel 이미지 생성을 위한 Dockerfile 작성</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#redis-sentinel 이미지 기반으로 빌드합니다.</span></span><br><span class="line">FROM lgatica/redis-sentinel:4.0.2   </span><br><span class="line"> </span><br><span class="line">MAINTAINER Carrey </span><br><span class="line"> </span><br><span class="line"><span class="comment">## Copy Redis File</span></span><br><span class="line"><span class="comment">## 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 한다.</span></span><br><span class="line"><span class="comment"># 기존 container의 sentinel-entrypoint.sh 삭제합니다.</span></span><br><span class="line">RUN rm -rf /usr/<span class="built_in">local</span>/bin/sentinel-entrypoint.sh         </span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel 설정이 담긴 sentinel.conf 파일 복사합니다.</span></span><br><span class="line">ADD sentinel.conf /usr/<span class="built_in">local</span>/bin/sentinel.conf                          </span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel container 시작 시, 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.</span></span><br><span class="line">ADD sentinel-entrypoint.sh /usr/<span class="built_in">local</span>/bin/sentinel-entrypoint.sh         </span><br><span class="line"> </span><br><span class="line"><span class="comment">## change access authority</span></span><br><span class="line"><span class="comment"># 복사한 파일에 대한 권한을 변경합니다. (Permission Denied 문제)</span></span><br><span class="line">RUN chmod 755 /usr/<span class="built_in">local</span>/bin/sentinel.conf                               </span><br><span class="line">RUN chmod 755 /usr/<span class="built_in">local</span>/bin/sentinel-entrypoint.sh</span><br><span class="line">RUN chown redis:redis /usr/<span class="built_in">local</span>/bin/sentinel.conf</span><br><span class="line">RUN chown redis:redis /usr/<span class="built_in">local</span>/bin/sentinel-entrypoint.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Redis Container에 대한 Port를 지정합니다. (host 모드이기 때문에 외부 노출)</span></span><br><span class="line">EXPOSE <span class="variable">$CLIENTPORT</span>                                    </span><br><span class="line"></span><br><span class="line"><span class="comment"># Container가 생성, 시작하는 시점에 실행됩니다.</span></span><br><span class="line">ENTRYPOINT [<span class="string">"/usr/local/bin/sentinel-entrypoint.sh"</span>]        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Container 빌드가 완료되고 Sentinel Server를 실행시킵니다. </span></span><br><span class="line"><span class="comment"># conf 파일 뿐만 아니라 --sentinel 옵션을 추가하여 Redis가 Sentinel 모드로 실행 되도록 합니다.</span></span><br><span class="line"><span class="comment"># Sentinel 또한 Redis Server이지만, Sentinel 설정을 하여 실행 시키는 것 뿐입니다.</span></span><br><span class="line">CMD [ <span class="string">"redis-server"</span>,<span class="string">"/usr/local/bin/sentinel.conf"</span>, <span class="string">"--sentinel"</span> ]</span><br></pre></td></tr></table></figure></p><h1 id="redis-sentinel-설정">Redis Sentinel 설정</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"> </span><br><span class="line"><span class="comment"># bind 127.0.0.1 문자열을 각 이미지에서 설정한 $CLIENTHOST 값으로 변경합니다. </span></span><br><span class="line"><span class="comment"># $CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.</span></span><br><span class="line">sed -i <span class="string">"s/bind 127.0.0.1/bind <span class="variable">$CLIENTHOST</span>/g"</span> /usr/<span class="built_in">local</span>/bin/sentinel.conf      </span><br><span class="line">         </span><br><span class="line"><span class="comment"># port 6379 문자열을 각 이미지에서 설정한 $CLIENTPORT 값으로 변경합니다. </span></span><br><span class="line"><span class="comment"># Sentinel 이미지 별로 port다르게 설정</span></span><br><span class="line">sed -i <span class="string">"s/port 6379/port <span class="variable">$CLIENTPORT</span>/g"</span> /usr/<span class="built_in">local</span>/bin/sentinel.conf  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># sentinel에 대한 mymaster를 설정하는 부분입니다. </span></span><br><span class="line"><span class="comment"># 실제 Master Redis의 ip와 port를 설정하고 QUORUM 값을 설정합니다.</span></span><br><span class="line"><span class="comment"># QUORUM 값은 Slave-&gt;Master Role Change 시, slave redis가 받아야 하는 최소 투표 수 입니다.</span></span><br><span class="line">sed -i <span class="string">"s/sentinel monitor mymaster 127.0.0.1 6379 2/sentinel monitor mymaster <span class="variable">$MASTERHOST</span> <span class="variable">$MASTERPORT</span> <span class="variable">$QUORUM</span>/g"</span> /usr/<span class="built_in">local</span>/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Redis server가 다운되고 후처리 실행 시간 까지 걸리는 시간을 지정합니다. </span></span><br><span class="line"><span class="comment"># ex)3000 -&gt; 3000 밀리세컨드 -&gt; 3초</span></span><br><span class="line">sed -i <span class="string">"s/sentinel down-after-milliseconds mymaster 30000/sentinel down-after-milliseconds mymaster <span class="variable">$DOWN_AFTER_MILLISEC</span>/g"</span> /usr/<span class="built_in">local</span>/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Redis failover timeout 시간을 설정 합니다.</span></span><br><span class="line">sed -i <span class="string">"s/sentinel failover-timeout mymaster 180000/sentinel failover-timeout mymaster <span class="variable">$FAILOVER_TIMEOUT</span>/g"</span> /usr/<span class="built_in">local</span>/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># sentinel이 master redis에 접근할 때 인증하는 비밀번호를 설정합니다.</span></span><br><span class="line">sed -i <span class="string">"s/# sentinel auth-pass mymaster MySUPER--secret-0123passw0rd/sentinel auth-pass mymaster <span class="variable">$REQUIREPASS</span>/g"</span> /usr/<span class="built_in">local</span>/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;1#-&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ] || [ <span class="string">"<span class="variable">$&#123;1%.conf&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">set</span> -- redis-server <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'redis-server'</span> -a <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure></p><h1 id="redis-sentinel-실행-결과">Redis Sentinel 실행 결과</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f conf/sentinel-docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure></p><p><img src="./redis-sentinel-log.PNG" alt="redis-sentinel-log"></p><p>sentinel 1~3 까지의 로그를 모아보았습니다.테스트용 port인 (6379~6381) 에 대한 master/slave 정보를 가지고 있는것을 볼수 있습니다.</p><p>로그처럼</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel2_1  | 1:X 02 Dec 10:06:24.082 # +monitor master mymaster 192.168.137.101 6379 quorum 2</span><br></pre></td></tr></table></figure></p><p>sentinel이 자신의 마스터에 대한 정보를 가지고 모니터 하며 quorum 2를 가지고 있는 것을 볼 수 있습니다.</p><h1 id="failover-test">Failover Test</h1><p>자, Failover를 구성 했으니 실제로 Master를 한번 죽여보도록 해보겠습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;master_node_id&gt; <span class="comment"># Redis Master Container를 중지</span></span><br></pre></td></tr></table></figure></p><p><img src="./redis-failover-log.PNG" alt="redis-failover-log"></p><p>맨 처음 로그를 살펴보면 각 sentinel 노드에서 sdown 시그널을 발생시키고 있습니다.</p><p>중간정도 줄을 보면</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+odown master mymaster 192.168.137.101 6379 <span class="comment">#quorum 3/2</span></span><br></pre></td></tr></table></figure></p><p>라는 로그가 나오게 되는데 3개의 sentinel에서 모두 sdown으로 인지하게 되는것입니다.3/2의 뜻은  2개 노드에서 sdown이 발생 했을 때, odown 판정을 내린다는 다수결 투표 숫자입니다.그런데 3개의 노드가 모두 투표를 하여 과반수 이상이 되었으므로 192.168.137.101 6379인 Redis 노드는 odown상태가 되었습니다.</p><p>그 바로 다음 줄 부터 failover 작업이 시작됩니다.위의 예제에서는 6380 포트를 사용하는 redis노드가 새로운 마스터로 선출 되었습니다.따라서 6380 포트를 사용하는 redis노드는 master로 role-change가 되면서 master 노드로써 역할을 수행하게 됩니다.</p><p>이렇게 Redis Sentinel을 이용하여 master node를 감시하며, 장애 상황에 대한 failover를 지원하고 있습니다.</p><h2 id="sdown-vs-odown">sdown vs odown</h2><p>Sentinel에서 down을 판단하는 방법은 <code>sdown</code>과 <code>odown</code>으로 이루어집니다.failover 시 Master가 죽었다는 걸 판단하기 위해서는 <code>다수결의 원칙</code>이 적용됩니다. (그래서 Sentinel노드 갯수를 홀수로 설정하는 이유입니다.)</p><p>먼저, Master가 죽게 되면 Sentinel은 자신이 감시하고 있는 Master가 죽었다고 sdown 시그널을 표현합니다 (<code>Subjective Down</code> 이라 합니다.)sdown은 단지 Master와 Sentinel 자기 자신이 연결이 되지 않음을 의미합니다.</p><p>위에서 보듯이 Master가 죽었으니 다른 Sentinel들도 연결이 끊어졌다고 sdown 시그널을 보냅니다.그렇게 되면 다수결에 원칙에 따라 quorum값 만큼의 sdown이 발생하면 sentinel은 odown 시그널을 보냅니다. (<code>Objective Down</code>이라 합니다.)</p><p>odown은 다수결에 의해서 명시적으로 Master가 Down되었다고 선포하는 것과 같습니다.그렇게 되면 Sentinel들은 다음 Master를 선출하기 위해 남아있는 Slave Redis들에게 투표를 하게 됩니다.다수결의 원칙으로 더 많은 투표수를 받은 Slave가 Master로 선출되게 됩니다.</p><h2 id="중단되었던-6379-포트를-사용하는-redis-노드가-살아나면">중단되었던 6379 포트를 사용하는 Redis 노드가 살아나면?</h2><p>아까 stop했던 container를 다시 살려보겠습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;redis1_node_id&gt;</span><br></pre></td></tr></table></figure></p><p><img src="./redis-failover-3-3748019.PNG" alt="redis-failover-3"></p><p>3번째 줄부터 보시면, sentinel에서 <code>-sdown</code> 로그를 찍어주고 있습니다.sentinel에서 연결되지 않았던 6379번 노드에 대해 정상적으로 커넥션이 맺어지고 있기 때문입니다.중간 줄 부터 보게 되면다른 sentinel 노드에서도 <code>-sdown</code> 로그를 찍어주며 6379번 노드에 대한 부활을 알려주고 있습니다.</p><p>그런 다음에 <code>+convert-to-slave</code> 로그를 보면, 기존의 6379번 노드는 원래 master role을 수행 하던 Redis 노드였습니다.하지만 현재 sentinel에 대한 mymaster는 6380번 노드이기 때문에 6379번 노드는 master role을 수행 할 수 없습니다.</p><p>따라서  <code>+role-change</code> 명령을 통해  기존에 master role -&gt; slave role로 변경되어야 합니다.그리고 현재 master role 권한이 있는 6380번 노드의 slave으로 편입되게 됩니다.redis-cli를 통해 6379번 노드에 접속하여 <code>info replication</code> 명령을 날려보았습니다.</p><p><img src="./redis-failover-4.PNG" alt="redis-failover-4"></p><p>현재 role은 <code>slave</code> 이며, 6380번 노드를 master로 설정하고 있습니다.</p><blockquote><p><strong>왜 기존의 master가 살아나면, slave로 전환하여 사용해야 할까?</strong></p><p>이유는 간단합니다.Redis Master-Slave간 데이터 Replication을 이해 하면 쉽게 이해 할 수 있습니다Redis의 데이터 Replication은 dump.rdb파일을 통해 이루어지는데,master노드 만 dump.rdb파일에 데이터를 write 할 수 있습니다.slave노드에서는 dump.rdb파일을 읽어서 데이터 replication을 하게 되는데,만약 기존의 master의 role이 유지된다면, dump.rdb파일을 조작하여 기존의 master가 다운된 시간 동안들어온 데이터가 삭제될 수 있습니다.그렇게 때문에 데이터 정합성을 위해 기존의 master는 slave로 role이 전환되어야 합니다.</p></blockquote>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/02/2018-12-02-docker-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (6) Docker를 이용한 Redis Cluster 설치하기</title>
      <link>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-6/</link>
      <guid>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-6/</guid>
      <pubDate>Sat, 01 Dec 2018 08:53:04 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;redis-cluster-구성도&quot;&gt;Redis Cluster 구성도&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;./Redis-Cluster-archi.PNG&quot; alt=&quot;Redis-Cluster-archi&quot;&gt;&lt;/p&gt;
&lt;p&gt;간단하게 정리하면.&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="redis-cluster-구성도">Redis Cluster 구성도</h1><p><img src="./Redis-Cluster-archi.PNG" alt="Redis-Cluster-archi"></p><p>간단하게 정리하면.</p><ul><li>각 서버 별로 Redis 3대를 설치. Master 1개, Slave 2개로 구성하여 Replication을 지원할 수 있도록 Cluster를 구성하였습니다.</li><li>각 서버 별로 Sentinel 3대를 설치. 양대비 원리에 맞추어 홀수개로 설정 하였습니다.</li><li>각각의 서버의 Sentinel 3대가 서버의 Master Redis를 감시합니다. (Failover 대기)</li><li>Redis Cluster를 서버 3대에 설치. Data Sharding을 하기 위해 저장소를 3개로 분리하였습니다.</li><li>HAProxy로 분산 처리 구축. 5000, 5002, 5004번 포트는 각 서버의 Master Redis를 바라봅니다.</li><li>5001, 5003, 5005번 포트는 각 서버의 Slave Redis 2대씩 바라봅니다.</li></ul><p>지금부터 Redis Cluster를 어떻게 설치 하였는지 설치 과정에 대해 알아보도록 하겠습니다.</p><h1 id="docker를-이용한-redis-cluster-설치">Docker를 이용한 Redis Cluster 설치</h1><p>Redis-Cluster를 설치하는 순서는 아래와 같습니다. (CentOS 7기준으로 설치 하였습니다.)</p><ul><li>Git 설치 (미리 올려둔 Docker file들을 다운받기 위함)</li><li>Docker 설치</li><li>Docker-Compose 설치</li><li>Docker Build</li></ul><h2 id="git-설치-docker-file-다운로드">Git 설치 + Docker file 다운로드</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git설치</span></span><br><span class="line">yum -y install git</span><br><span class="line">git --version <span class="comment"># git 버전 확인</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#Redis-Cluster 디렉터리 생성</span></span><br><span class="line">mkdir -p /home/redis/redis-cluster</span><br><span class="line"> </span><br><span class="line"><span class="comment">#Redis-Cluster-Home 이동</span></span><br><span class="line"><span class="built_in">cd</span> /home/redis/redis-cluster</span><br><span class="line"> </span><br><span class="line"><span class="comment">#아래 디렉터리들은 각 Redis Container의 외부볼륨으로 설정하기 위해 생성하였습니다.</span></span><br><span class="line"><span class="comment">#==&gt; Container 외부 볼륨을 설정해야 Redis Container가 삭제되더라도 Data가 보존됩니다.</span></span><br><span class="line"><span class="comment">#===&gt; dump.rdb 파일이 생성되는 장소</span></span><br><span class="line">mkdir -p ./redis-data/redis1</span><br><span class="line">mkdir -p ./redis-data/redis2</span><br><span class="line">mkdir -p ./redis-data/redis3</span><br><span class="line"> </span><br><span class="line"><span class="comment">#Docker file Download</span></span><br><span class="line"><span class="comment">#설치파일을 다운받습니다.</span></span><br><span class="line">git init</span><br><span class="line">git remote add origin <span class="string">"https://github.com/jaehun2841/redis-cluster-on-docker.git"</span></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p><h2 id="docker-설치">Docker 설치</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker 설치</span></span><br><span class="line">curl -fsSL https://get.docker.com/ | sh</span><br><span class="line"> </span><br><span class="line"><span class="comment">#docker 설치 후 docker 시작</span></span><br><span class="line">service docker start</span><br></pre></td></tr></table></figure></p><p>Docker를 yum으로도 설치가 가능하지만 버전이 낮아 Docker-compose를 설치 할 수 없습니다.차후에 update까지 필요하니 위 url에서 제공하는 shell script를 실행하여 설치하도록 합니다.<strong>※ 위 Script는 sudo 명령 또는 root 권한을 필요로 합니다.</strong></p><p>Docker 설치 내용은 2장에서 기술한 내용을 참고하시길 바랍니다.</p><h2 id="docker-compose-설치">Docker-Compose 설치</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker 공식 github에서 다운로드</span></span><br><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></p><p>Docker-Compose 설치 내용은 4장에서 기술한 내용을 참고하시길 바랍니다.</p><h2 id="docker-build">Docker build</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cluster home 이동</span></span><br><span class="line"><span class="built_in">cd</span> /home/redis/redis-cluster</span><br><span class="line"> </span><br><span class="line"><span class="comment">#docker build</span></span><br><span class="line">docker-compose -f conf/docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure></p><ul><li>-f 옵션으로 docker-compose.yml 파일을 설정합니다.(docker-compose.yml 파일은 github redis-cluster 설치파일을 받을때 다운 받았습니다. )</li><li>up 명령으로 docker container를 실행합니다.</li><li>--build 옵션으로 build후 container를 실행합니다.</li><li>-d 옵션으로 background로 실행되도록 합니다.(-d 옵션을 빼면 redis의 로그가....나오며 exit하는 순간 container가 stop됩니다.)</li></ul><h1 id="redis-cluster를-빌드하기-위한-docker-composeyml-파일">Redis Cluster를 빌드하기 위한 docker-compose.yml 파일</h1><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-master:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="attr">redis:5.0-alpine</span>   <span class="comment"># image 옵션으로 redis공식이미지를 기반으로 생성합니다.</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span>             <span class="comment"># build file에 대한 context를 지정</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span>  <span class="comment">#dockerfile명을 지정합니다. (Default는 "Dockerfile" 파일명을 가진 파일을 실행합니다.)</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">"host"</span>      <span class="comment"># Image가 Container가 되었을때 network모드를 host모드로 설정합니다 (docker0 인터페이스를 사용하지 않고 Host OS의 eth0 인터페이스 사용)</span></span><br><span class="line">     <span class="attr">environment:</span>              <span class="comment"># Container 내부에서 사용 할 환경변수를 설정합니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=</span></span><br><span class="line">     <span class="attr">volumes:</span>  <span class="comment"># Host OS의 디렉터리와 Container내의 디렉터리와 연동합니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"../redis-data/redis1:/data"</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-slave1:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="attr">redis:5.0-alpine</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"../redis-data/redis2:/data"</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-slave2:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="attr">redis:5.0-alpine</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6381</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span> </span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"../redis-data/redis3:/data"</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Redis Container의 Network모드가 Host인 이유</strong>Redis 공식 홈페이지의 cluster-tutorial에서 발췌한 내용입니다.</p><blockquote><p>Redis Cluster and Docker</p><p>Currently Redis Cluster does not support NATted environments and in general environments where IP addresses or TCP ports are remapped.Docker uses a technique called port mapping: programs running inside Docker containers may be exposed with a different port compared to the one the program believes to be using.This is useful in order to run multiple containers using the same ports, at the same time, in the same server.<code>In order to make Docker compatible with Redis Cluster you need to use the host networking mode of Docker.</code> Please check the --net=host option in the Docker documentation for more information.</p></blockquote><p>Redis Cluster에서는 NAT환경과 IP주소 또는 TCP포트가 재 매핑되는 환경을 지원하지 않는다고 합니다.따라서 Docker에서 Redis Cluster를 호환되게 하기 위해서는 Host 모드로 사용할 것을 권고하고 있습니다.</p></blockquote><h1 id="redis-container-생성을-위한-dockerfile-작성">Redis Container 생성을 위한 Dockerfile 작성</h1><p>Docker-Compose build를 사용하면서 Dockerfile에는 Redis Container를 구성하는 공통적인 로직을 담았습니다.주로 내부에서 file을 생성하거나 Host OS의 파일을 Container가 생성하는 시점에 복사하기 위한 로직이 주로 들어있습니다.그리고 접근권한이 막혀 파일이 실행되지 않는 문제를 해결하기 위해 접근권한을 변경하였습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FROM redis:5.0-alpine //redis 이미지를 기반으로 빌드됨을 의미합니다.</span><br><span class="line"> </span><br><span class="line">MAINTAINER Carrey (jaehun2841@gmail.com)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Copy Redis File</span></span><br><span class="line"><span class="comment"># 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 합니다.</span></span><br><span class="line"><span class="comment"># 기존의 docker-entryporint.sh 파일을 삭제합니다.</span></span><br><span class="line">RUN rm -rf /usr/<span class="built_in">local</span>/bin/docker-entrypoint.sh  </span><br><span class="line"><span class="comment"># 공통적으로 적용할 redis.conf 파일을 복사합니다.</span></span><br><span class="line">ADD redis.conf /usr/<span class="built_in">local</span>/bin/redis.conf    </span><br><span class="line"><span class="comment"># Container가 생성, 시작하는 시점에 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.</span></span><br><span class="line">ADD docker-entrypoint.sh /usr/<span class="built_in">local</span>/bin        </span><br><span class="line"> </span><br><span class="line"><span class="comment">## change access authority</span></span><br><span class="line">RUN chmod 755 /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">RUN chmod 755 /usr/<span class="built_in">local</span>/bin/docker-entrypoint.sh</span><br><span class="line"> </span><br><span class="line">RUN chown redis:redis /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">RUN chown redis:redis /usr/<span class="built_in">local</span>/bin/docker-entrypoint.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#Redis Container에 대한 Port를 지정합니다. (내부포트이며 외부노출은 안됨)</span></span><br><span class="line">EXPOSE <span class="variable">$CLIENTPORT</span> <span class="comment">#CLIENTPORT에 대한 값은 docker-compose.yml에 정의되어 있습니다.          </span></span><br><span class="line"><span class="comment"># Container가 생성, 시작하는 시점에 실행됩니다.</span></span><br><span class="line">ENTRYPOINT [<span class="string">"/usr/local/bin/docker-entrypoint.sh"</span>] </span><br><span class="line"><span class="comment"># Container 빌드가 완료되고 Redis Server를 실행시킵니다.</span></span><br><span class="line">CMD [ <span class="string">"redis-server"</span>,<span class="string">"/usr/local/bin/redis.conf"</span> ]</span><br></pre></td></tr></table></figure></p><h1 id="redis-cluster-설정">Redis Cluster 설정</h1><p>Redis Cluster에 대한 Replication 설정에 대해 알아보겠습니다.</p><p>설정 방법은 redis.conf 파일을 각 Container로 복사하여 공통적인 설정을 하였습니다.각 redis.conf 파일에 대한 변경사항은 <code>docker-entrypoint.sh</code> 파일을 통해 redis.conf 파일 정보를 replace하였습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"> </span><br><span class="line"><span class="comment">## from redis-5.0</span></span><br><span class="line"><span class="comment"># Redis서버에 접근가능한 Host를 설정합니다.</span></span><br><span class="line">sed -i <span class="string">"s/bind 127.0.0.1/bind <span class="variable">$CLIENTHOST</span> 127.0.0.1/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">### redis port inside redis.conf</span></span><br><span class="line"><span class="comment">#redis.conf 파일의 port 6379 문자열을 port $CLINETPORT로 변경합니다. </span></span><br><span class="line"><span class="comment">#($CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.)</span></span><br><span class="line">sed -i <span class="string">"s/port 6379/port <span class="variable">$CLIENTPORT</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf </span><br><span class="line"></span><br><span class="line"><span class="comment"># requirepass foobared 문자열을 requirepass $REQUIREPASS로 변경하였습니다. </span></span><br><span class="line"><span class="comment">#(Redis 접속 시 비밀번호를 설정하였습니다.)</span></span><br><span class="line">sed -i <span class="string">"s/# requirepass foobared/requirepass <span class="variable">$REQUIREPASS</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf          </span><br><span class="line">sed -i <span class="string">"s/# masterauth &lt;master-password&gt;/masterauth <span class="variable">$REQUIREPASS</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf   </span><br><span class="line"></span><br><span class="line"><span class="comment">### slaveof &lt;masterip&gt; &lt;masterport&gt; =&gt; slaveof $MASTERHOST $MASTERPORT</span></span><br><span class="line"><span class="comment"># $MASTERPORT가 공백이 아닌 Container에 대해 slaveof 설정을 통해 Master-Slave 설정을 합니다.</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$MASTERPORT</span>"</span> != <span class="string">""</span> ];<span class="keyword">then</span></span><br><span class="line">    sed -i <span class="string">"s/# slaveof &lt;masterip&gt; &lt;masterport&gt;/slaveof <span class="variable">$MASTERHOST</span> <span class="variable">$MASTERPORT</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf  </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;1#-&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ] || [ <span class="string">"<span class="variable">$&#123;1%.conf&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">set</span> -- redis-server <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'redis-server'</span> -a <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure></p><h1 id="redis-cluster-실행-결과">Redis Cluster 실행 결과</h1><p>Redis.log<img src="./redis-replication-3746317.PNG" alt="redis-replication"></p><p>로그에서 0 clients connected (2 slaves) 라는 로그가 보입니다.Redis에 접속한 클라이언트 수는 0 client이며2개의 slave redis와 연결하고 있습니다.</p><p>중간부분 로그에서 로그를 보면 slave로 설정한 Redis와 연동이 되는 것을 확인 할 수 있습니다.</p><p>redis-cli &gt; info replication<img src="./redis-replication2-3746337.PNG" alt="redis-replication2"></p><p>redis-cli에서 info replication 명령을 실행하였을 때, 조회되는 내용입니다.slave0, slave1에 대한 참조를 가지고 있는 것을 확인 할 수 있습니다.</p><h1 id="참고">참고</h1><ul><li>https://redis.io/topics/cluster-tutorial</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (5) Docker Network구조</title>
      <link>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-5/</link>
      <guid>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-5/</guid>
      <pubDate>Sat, 01 Dec 2018 08:25:03 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;docker-network-모드&quot;&gt;Docker Network 모드&lt;/h1&gt;
&lt;p&gt;Docker에서 제공하는 Network 모드는 총 4개 입니다.
(추가적으로 2개의 모드가 더 있습니다. Overlay, Macvlan 모드가 있지만 Doc
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="docker-network-모드">Docker Network 모드</h1><p>Docker에서 제공하는 Network 모드는 총 4개 입니다.(추가적으로 2개의 모드가 더 있습니다. Overlay, Macvlan 모드가 있지만 Docker Swarm과 관련된 내용이므로 이번 장에서는 기술 하지 않겠습니다.)</p><ul><li>Bridge 모드</li><li>Container 모드 (이것도 Bridge 모드의 일종)</li><li>Host 모드</li><li>none 모드</li></ul><p>이번 장에서는 위 Network 모드에 대해 알아보도록 하겠습니다.</p><h1 id="bridge-모드">Bridge 모드</h1><p>Docker에서 network 설정을 별도로 하지 않으면 Default로 작용하는 모드입니다.Docker가 설치되면 docker0라는 네트워크 인터페이스가 생성됩니다. (Virtual Interface)</p><p><img src="./docker-bridge-mode.png" alt="docker-bridge-mode"></p><p>위는 docker0 인터페이스를 바탕으로 각 Container와 Bridge 형식으로 엮어진 모습입니다.</p><p><img src="./docker-bridge-2.PNG" alt="docker-bridge-2"></p><p>Host OS에서 network interface를 검색해 보면 docker0라는 virtual interface를 확인할 수 있습니다.</p><blockquote><p><strong>docker0 interface의 특징</strong></p><ul><li>IP는 자동으로 172.17.0.1로 설정</li><li>IP는 DHCP로 할당받는 것이 아닌 Docker 내부로직에 의해 결정</li><li>docker0는 virtual ethernet bridge</li><li>L2 통신 기반</li></ul></blockquote><p><code>&quot;docker bridge 모드는 같은 host 내에서만 사용 가능하다.&quot;</code> 라는 제약이 있다.즉, 다른 host(다른서버)와의 docker와는 통신이 불가능합니다.왜냐하면 다른 서버가 docker0 인터페이스의 외부에 있기 때문에 그렇습니다.</p><h1 id="docker0-interface와-container의-연결-방식">docker0 interface와 Container의 연결 방식</h1><p><img src="./docker0-interface.PNG" alt="docker0-interface"></p><p>위 이미지를 보면, 현재 Docker를 이용하여 redis와 nginx를 설치한 상태입니다.두 번째 명령을 보면 brctl명령으로 docker0 interface에 연결된 interfaces가 2개 보입니다.</p><ul><li>veth062947b</li><li>veth3b5bdll</li></ul><p>container 2개가 bridge 방식으로 연결 되어 있기 때문에 veth~하는 interface가 생성되어있습니다.위에 그림에서 보듯이 veth와 각 container 내부의 eth0 interface와 연결되어 있습니다.</p><p><img src="./ip.PNG" alt="ip"></p><p>Redis Container에 대해 docker inspect 명령을 날려보았습니다.네트워크 설정 부분이 아래에 나오는데 Network 부분을 보시면 Gateway는 172.17.0.1이라 되어 있습니다.이 ip 주소는 docker0 interface의 ip주소입니다.따라서 docker0의 bridge로 연결되어 172.17.0.2라는 내부 ip를 가진 Container로 생성된 것입니다.</p><h1 id="container-모드-이것도-bridge-모드의-일부">Container 모드 (이것도 Bridge 모드의 일부)</h1><p>Container 모드는 다른 Container의 네트워크 리소스를 같이 쓰는? 개념입니다.</p><p>먼저 httpd를 설치하고..그다음에 redis를 설치하여 httpd의 container 정보를 가지고 net설정을 해주었습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d httpd</span><br><span class="line">docker run -d --net=container:(httpd의 containerId) redis</span><br></pre></td></tr></table></figure></p><p><img src="./httpd.PNG" alt="httpd"></p><p>위 이미지(httpd에 대한 정보)를 보면 docker0 interface를 이용하고 bridge 모드로 설정되어 있습니다.</p><p><img src="./redis1.PNG" alt="redis1"></p><p>하지만, Redis의 Network 정보를 보면 텅텅 비어있습니다.이는 docker0 interface를 통해 네트워크 설정이 bind 되지 않았다는 의미입니다.</p><p>약간 위로 올려보면</p><p><img src="./redis2.PNG" alt="redis2"></p><p>NetworkMode에 httpd의 container 자원을 사용하여 접근하는 것을 알 수 있습니다.다른 docker image 중 내부 명령어로 ip addr을 지원하는 image가 있다면</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> &lt;container ID&gt; ip addr show</span><br></pre></td></tr></table></figure></p><p>위 명령을 통해 Mac Address가 Container자원을 할당한 Container의 Mac Address와 같음을 알 수 있습니다.</p><h1 id="host-모드">Host 모드</h1><p>Host 모드는 docker0 interface를 사용하지 않고 Host OS의 네트워크 자원을 사용합니다.bridge 형식으로 사용하지 않기 때문에 brctl show docker0 명령으로 검색해도 interfaces에 나타나지 않습니다.<strong>Bridge를 쓰지 않기 때문에 Container에서 <code>Port를 노출하지 않는 경우 사용할 수가 없는 점</code>을 유의 해야 합니다.</strong>(Redis Cluster를 구성 할 때에도 Redis에서는 Cluster모드 구현 시, docker bridge mode를 지원하지 않기 때문에 host로 설정했었습니다.)</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=host -p <span class="string">"6515"</span> <span class="comment">#이렇게 옵션을 추가해주면 됩니다. (port는 문자열로!)</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#또는 docker-compose.yml 파일에서</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">  network_mode:</span> <span class="string">host</span> <span class="comment">#이 처럼 표기하시면 됩니다.</span></span><br></pre></td></tr></table></figure></p><h1 id="none-모드">none 모드</h1><p>--net=none 옵션으로 Container 생성 시, 격리된 네트워크 영역을 갖기는 하지만 network 인터페이스가 없는 Container가 생성 됩니다.</p><p>아래의 코드로 테스트를 해보았습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=none -d httpd</span><br><span class="line">docker <span class="built_in">exec</span> httpd ip addr show</span><br></pre></td></tr></table></figure></p><p><img src="./none.PNG" alt="none"></p><p>검색되는 내부 네트워크 인터페이스가 없습니다.</p><blockquote><p><strong>none으로 처리하는 이유</strong>network mode를 none으로 하는 경우는 보통 사용자 정의 interface를 사용할 때 입니다.network 환경을 깔끔하게 만든 다음에 사용자 정의 interface를 적용하기 위함입니다.</p></blockquote><h1 id="참고">참고</h1><ul><li>http://bluese05.tistory.com/38</li><li>https://docs.docker.com/network/network-tutorial-standalone/#use-the-default-bridge-network</li><li>https://docs.docker.com/network/network-tutorial-host/</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (4) Docker-Compose 설치 및 사용방법</title>
      <link>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-4/</link>
      <guid>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-4/</guid>
      <pubDate>Sat, 01 Dec 2018 07:44:03 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;docker-compose-이란&quot;&gt;Docker-Compose 이란?&lt;/h1&gt;
&lt;p&gt;기존에는 Docker를 이용해서 1개의 이미지를 바탕으로 하나의 소프트웨어에 대한 컨테이너를 만들 수 있었습니다.
하지만 목표는 Web Server도 설치
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="docker-compose-이란">Docker-Compose 이란?</h1><p>기존에는 Docker를 이용해서 1개의 이미지를 바탕으로 하나의 소프트웨어에 대한 컨테이너를 만들 수 있었습니다.하지만 목표는 Web Server도 설치하고, DB도 설치하고, IDE도 설치해서 한 세트로 배포를 해주고 싶은데... 지금까지 배운 방법으로는 Docker image를 내가 필요한 것만큼 다운받아서 Container를 생성해야 합니다.</p><p>이때 필요한 개념이 Docker-Compose입니다.Docker-Compose는 사용자에게 한번에 여러가지 소프트웨어에 대한 이미지 정보를 담아 빌드 할 수 있습니다.사용자는 Docker-Compose로 만든 파일을 다운받아 이미지 내에 포함된 소프트웨어에 대한 Container를 한번에 만들 수 있습니다.</p><h1 id="docker-compose-설치">Docker-Compose 설치</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker 공식 github에서 다운로드</span></span><br><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></p><p>다운로드 받은 docker-compose 파일을 실행 가능한 파일로 만듭니다.(보통의 리눅스 실행파일 path는 <code>/usr/local/bin</code>입니다. <strong>OS별로 다를 수 있습니다.</strong>)</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></p><h1 id="docker-composeyml">Docker-compose.yml</h1><p>Docker-compose.yml 파일은 생성하고자 하는 Container들의 image 정보들을 담고 있는 설정 파일입니다.여기에 설치하고자 하는 소프트웨어들의 빌드정보를 지정 할 수 있습니다.또한 Docker에서 사용한 설정정보를 기술 할 수 있어 사용자는 파일을 받아 별도의 옵션 없이 Container만 생성하면 됩니다.</p><h1 id="docker-composeyml에서-자주-사용하는-options">Docker-Compose.yml에서 자주 사용하는 options</h1><h2 id="build">build</h2><p>build는 해당 이미지가 빌드 될 때 사용 할 Dockerfile을 지정할 수 있는 options입니다.</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1:</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">redis:5.0-alpine</span></span><br><span class="line"><span class="attr">     build:</span></span><br><span class="line"><span class="attr">       context:</span> <span class="string">..</span></span><br><span class="line"><span class="attr">       dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">       args:</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">buildno</span> <span class="string">:</span> <span class="number">1</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">username</span> <span class="string">:</span> <span class="string">carrey</span></span><br></pre></td></tr></table></figure></p><ul><li><p>context : dockerfile의 위치를 지정합니다. Default는 현재위치 (./) 입니다.</p></li><li><p>dockerfile : dockerfile명을 지정합니다 Default는 Dockerfile 입니다.</p></li><li><p>args : Dockerfile내에서 사용할 Arguments를 설정합니다.</p></li></ul><h2 id="command">command</h2><p>command는 Dockerfile에서 CMD역할을 했던 명령을 <code>Override</code>합니다.(Dockerfile과 같이 사용하는 경우 Dockerfile의 CMD명령이 아닌 <code>Docker-compose의 command명령이 실행</code>)</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1:</span></span><br><span class="line">  <span class="string">command</span> <span class="string">:</span> <span class="string">startup.sh</span> <span class="bullet">-p</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure></p><h2 id="depends_on">depends_on</h2><p>Docker-compose 내의 이미지가 2개 이상인 경우 실행 의존성을 줄 수 있습니다.예를들어 DB가 먼저 실행된 다음에 WAS가 실행되어야 하는 경우 Docker-Compose에서는 depend_on 설정에 따라 다른 이미지를 먼저 빌드 합니다.</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    depends_on:</span> <span class="string">//web</span> <span class="string">이미지에</span> <span class="string">대한</span> <span class="string">Container는</span> <span class="string">redis와</span> <span class="string">db가</span> <span class="string">생성되고</span> <span class="string">시작되기</span> <span class="string">전에는</span> <span class="string">빌드되지</span> <span class="string">않습니다.</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">db</span>       </span><br><span class="line"><span class="bullet">      -</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure></p><h2 id="entrypoint">entrypoint</h2><p>Container가 run 또는 start 시, entrypoint 로직을 실행 합니다.entrypoint와 Dockerfile이 함께 사용되는 경우, <code>Dockerfile의 ENTRYPOINT설정은 무시됩니다.</code></p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">redis1</span> <span class="string">:</span> </span><br><span class="line"><span class="attr">image:</span> <span class="attr">redis:5.0-alpine</span></span><br><span class="line"><span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure></p><h2 id="env_file">env_file</h2><p>Env 파일을 Container 내부에 import 하는 경우에 사용합니다.</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ubuntu:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line">    <span class="string">env_file</span> <span class="string">:</span> <span class="string">../env/environments.env</span></span><br></pre></td></tr></table></figure></p><h2 id="environment">environment</h2><p>Container 내부에서 사용할 환경 변수를 등록합니다.</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1:</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REQUIREPASS=1234</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTHOST=192.168.130.93</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTPORT=6380</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERHOST=192.168.130.93</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERPORT=6379</span></span><br></pre></td></tr></table></figure></p><h2 id="expose">expose</h2><p>Container내의 내부 포트만 설정 (외부 노출은되지 않습니다.)link된 Container끼리는 expose에 설정된 포트로 통신이 가능</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line"><span class="attr">expose:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"3000"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"8000"</span></span><br></pre></td></tr></table></figure></p><h2 id="ports">ports</h2><p>Host OS 포트와 Container 내부포트 매핑 (포트포워딩)Host OS 포트를 사용할 수 있으므로 외부접속이 가능</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tomcat:</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"80:8080"</span>  <span class="comment"># &lt;Host OS포트&gt; : &lt;컨테이너 내부포트&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">#Short Syntax --&gt; 권장하는 방식</span></span><br><span class="line"><span class="attr">ubuntu:</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"3000"</span>        <span class="comment">#이 구문은 "3000:3000" 과 동일</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"3000-3005"</span>   <span class="comment">#이 구문은 "3000-3005:3000-3005"와 동일</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"8000:8000"</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"9090-9091:8080-8081"</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"49100:22"</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"127.0.0.1:8001:8001"</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"127.0.0.1:5000-5010:5000-5010"</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"6060:6060/udp"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#Long Syntax --&gt; 권장하지 않는 방식</span></span><br><span class="line"><span class="attr">tomcat2:</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">target</span> <span class="string">:</span> <span class="number">8080</span> <span class="comment">#Container 내부포트</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">published</span> <span class="string">:</span> <span class="number">80</span> <span class="comment"># 외부 OS 포트</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">protocol</span> <span class="string">:</span> <span class="string">tcp</span> <span class="comment"># tcp 또는 udp</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">mode</span> <span class="string">:</span> <span class="string">host</span> <span class="comment">#host: 각각의 Container 노드와 1:1로 매핑</span></span><br></pre></td></tr></table></figure></p><blockquote><p>포트 매핑 시 주의 할 점Host : Container 형식으로 포트를 매핑하면 YAML이 xx:yy 형식은 구문 분석시에 default를 60으로 주기 때문에 60번 이하 포트에 대해서 잘못된 결과가 초래될 수 있음.(8000 : 22 와 같이 숫자만 적는 경우 문제가 발생)따라서, <code>포트 매핑은 항상 문자열로 적어야 합니다.</code>( &quot;8000 : 22&quot;와 같이 문자열로 선언해야 안전합니다. ) ==&gt; 60번 이하 포트를 쓰지말라는 소리가 아님.</p></blockquote><h2 id="image">image</h2><p>어떤 image를 바탕으로 생성할 것인지 지정합니다.</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span> </span><br><span class="line"><span class="attr">      image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">ubuntu:</span> </span><br><span class="line"><span class="attr">      image:</span> <span class="attr">ubuntu:14.04</span></span><br></pre></td></tr></table></figure></p><h2 id="link">link</h2><ul><li>다른 Container와 연결하기 위해 설정합니다.</li><li>외부 Port노출이 안되어도 Expose명령으로 노출된 Port로 연결</li><li>network_mode가 <code>host인 경우 사용할 수 없습니다.</code> (host인 경우 Host OS의 port를 직접 사용하기 때문)</li><li>서비스 이름:Alias 형태로 선언하거나 서비스 이름만 지정합니다.</li></ul><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line"><span class="attr">  link:</span></span><br><span class="line"><span class="attr">    - db:</span><span class="string">mycontainerdb-alias</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">db:</span> </span><br><span class="line"><span class="attr">  image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">redis:</span> </span><br><span class="line"><span class="attr">  image:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure></p><h2 id="network_mode">network_mode</h2><p>Docker network policy 설정 (다음 장에 상세 설명하겠습니다.)</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">"bridge"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"none"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"service:[service name]"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"container:[container name/id]"</span></span><br></pre></td></tr></table></figure></p><blockquote><p>Docker Swarm을 사용하는 경우 network_mode 옵션은 무시됩니다.</p></blockquote><h2 id="volumes">volumes</h2><ul><li>Host OS의 디렉터리 경로를 Container 내부의 디렉터리에 Mount 합니다. (쉽게 말해서 디렉토리가 연동됩니다.)</li><li>docker run -v 또는 --volume과 같습니다.</li><li>Dockerfile의 VOLUME[] 과 같습니다.</li><li>docker-compose.yml의 volumes에는 상대경로를 지정할 수 있습니다.</li><li>호스트:컨테이너:권한 순으로 작성하여 읽기/쓰기 권한 설정을 할 수 있습니다. (Default는 rw)<ul><li>ro : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수만 있음. Container에서 파일에 대한 수정이 불가능합니다.</li><li>rw : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수 있고, Container에서 파일 수정이 가능하고, Host OS 디렉토리에 반영이 됩니다.</li></ul></li></ul><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span> </span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">/usr/local/redis/data:/data</span> <span class="comment"># &lt;Host OS 디렉터리 경로&gt; : &lt;Container 내부 data 경로&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">/usr/local/redis/data:/data:ro</span> <span class="comment">#ReadOnly </span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">/usr/local/redis/data:/data:rw</span> <span class="comment">#ReadWrite</span></span><br></pre></td></tr></table></figure></p><h2 id="restart">restart</h2><p>Container 재 시작에 대한 policy를 설정합니다.</p><ul><li>no : 문제가 발생하여 Container가 중지된 경우 재시작 하지 않음 (default)</li><li>always : 어떠한 문제로 Container가 중지되는 경우 무조건 재시작</li><li>on-failure : Container의 exit code 0 이 아닌 경우 재시작</li><li>unless-stopped : 명시적으로 중지되거나, Docker 자체가 중지되는 경우 재시작</li></ul><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="literal">no</span>            </span><br><span class="line"><span class="attr">restart:</span> <span class="string">always</span>          </span><br><span class="line"><span class="attr">restart:</span> <span class="string">on-failure</span>      </span><br><span class="line"><span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>https://docs.docker.com/compose/compose-file/</li><li>http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/</li><li>https://www.joinc.co.kr/w/man/12/docker/Guide/DataWithContainer</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (3) Dockerfile</title>
      <link>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-3/</link>
      <guid>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-3/</guid>
      <pubDate>Sat, 01 Dec 2018 06:44:03 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;dockerfile-이란&quot;&gt;Dockerfile 이란?&lt;/h1&gt;
&lt;p&gt;이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="dockerfile-이란">Dockerfile 이란?</h1><p>이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소프트웨어에 대한 공식이미지도 있지만, Docker Hub 사용자들이 공식이미지를 바탕으로 커스터마이징하여 배포한 이미지도 등록되어 있습니다.</p><p>어떻게 이미지를 빌드하고 배포 할 수 있었을까요? <strong>Dockerfile을 이용한 이미지 빌드를 이용하면 가능합니다.</strong></p><p>Dockerfile은 이미지를 바탕으로 몇가지 명령을 실행 할 수 있는 로직을 담은 파일입니다.Dockerfile을 통해 더 유연하게 이미지에 대한 설정을 변경할 수 있고, 그 설정을 이미지에 담아 배포 할 수 있습니다.</p><p>물론 Docker run 구문에서 options을 사용하여 같은 기능을 하도록 구현 할 수 있지만, Dockerfile로 작성하게 되면 향후 유지보수가 쉬워지고 run 구문에 대한 options을 전부 기억하지 않아도 되는 장점이 있습니다.</p><p>이번 장에서는 Dockerfile을 작성하는 명령어를 위주로 알아보겠으며, 간단한 예제 Dockerfile을 보도록 하겠습니다.</p><h1 id="dockerfile-사용방법">Dockerfile 사용방법</h1><p>Dockerfile을 이용한 docker build</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dockerfile이 위치한 directory의 dockerfile을 가지고 build합니다.</span></span><br><span class="line">docker build -f /path/to/dockerfile</span><br></pre></td></tr></table></figure></p><h1 id="dockerfile을-구성하는-핵심-명령어">Dockerfile을 구성하는 핵심 명령어</h1><h2 id="from-dockerfile의-시작">From - Dockerfile의 시작</h2><p>From 명령어는 어떤 이미지를 바탕으로 container를 빌드 할 것인지 명시합니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis:5.0-alpine 이미지를 바탕으로 빌드</span></span><br><span class="line">From redis:5.0-alpine</span><br></pre></td></tr></table></figure></p><h2 id="cmd-dockerfile의-끝">CMD - Dockerfile의 끝</h2><ul><li>CMD명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li><li>보통은 해당 프로그램을 실행시키는 명령을 사용합니다. ( ex&gt; startup.sh)</li><li>CMD 명령은 Dockerfile에서 <code>단 한번만 사용</code>할 수 있습니다.</li></ul><p>명령어 예제</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 일반적인 실행 방법</span></span><br><span class="line">CMD [<span class="string">"execute.sh"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># Entrypoint 실행을 위한 Default Parameter - Entrypoint를 위한 파라미터를 제공</span></span><br><span class="line">CMD [<span class="string">"param1"</span>, <span class="string">"param2"</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># shell form</span></span><br><span class="line">CMD execute.sh param1 param2</span><br></pre></td></tr></table></figure></p><blockquote><p>CMD 구문 사용 시, 주의사항!</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker build -f ./dockerfile <span class="built_in">test</span></span><br><span class="line">&gt; <span class="comment"># Container 생성 시, docker run [이미지] [실행파일 또는 명령] 입니다.</span></span><br><span class="line">&gt; docker run <span class="built_in">test</span> <span class="built_in">echo</span> <span class="string">"test!"</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>위 예시 처럼 run 명령 시, 이미지 명 뒤에 <code>실행파일이나 명령어</code>가 오게되면 CMD에 설정된 명령은 <code>무시</code>되고 docker run 구문에서 사용된 명령이 <strong>CMD 대신 실행</strong>됩니다.</p></blockquote><h2 id="entrypoint">ENTRYPOINT</h2><ul><li>ENTRYPOINT명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li><li>보통 스크립트를 실행하거나, 실행명령을 수행하게 됩니다.</li><li>ENTRYPOINT명령은 Dockerfile에서 <code>단 한번만 사용가능</code> 합니다.</li><li>기본적으로 FROM에서 설정한 이미지의 /bin/sh 파일을 기반으로 실행되며, 이미지에 /bin/sh 파일이 없는 경우 실행이 불가능 합니다.</li></ul><p>ENTRYPOINT 사용 예시<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">"docker-entrypoint.sh"</span>]</span><br><span class="line">ENTRYPOINT [<span class="string">"docker-entrypoint.sh"</span>, <span class="string">"--param1=true"</span>, <span class="string">"--param2=1"</span>]</span><br></pre></td></tr></table></figure></p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#run 명령의 options으로 구현한 방식</span></span><br><span class="line"><span class="comment">#이러한 방식으로도 사용할 수 있지만, 추천하지 않는 안티패턴입니다.</span></span><br><span class="line">docker run --entrypoint=<span class="string">"docker-entrypoint.sh"</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><h1 id="dockerfile에서-자주-사용하는-명령어">Dockerfile에서 자주 사용하는 명령어</h1><h2 id="add-파일을-container에-추가">ADD - 파일을 Container에 추가</h2><ul><li>Container 내부에 Host OS의 파일을 추가하려고 할 때 사용합니다.</li><li>ADD &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li><li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li><li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li><li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li><li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li><li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀어서 Container에 추가됩니다.(Container에 압축 해제 된 파일들이 추가됨)</li><li>인터넷에 있는 파일 URL은 압축만 해제된 뒤, tar파일만 추가됩니다.</li><li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li><li>ADD로 추가되는 파일은 root root 기존 권한을 따릅니다 (단, URL로 추가된 파일의 경우 600)</li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADD ../file.sh /home/file.sh (x) <span class="comment">#상위 디렉터리 사용x</span></span><br><span class="line">ADD /home/user/file.sh /home/file.sh(x) <span class="comment">#절대경로 사용x</span></span><br><span class="line">ADD file.sh ../../file.sh (x) <span class="comment">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class="line"> </span><br><span class="line">ADD file.sh /home/file.sh (O) <span class="comment">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class="line">ADD *.sh /home (O) <span class="comment"># 와일드카드를 이용하여 복사 가능</span></span><br><span class="line">ADD compress.tar.gz / <span class="comment"># Container / 경로에 compress.tar파일의 풀어진 형태로 파일 추가</span></span><br><span class="line">ADD http://file.co.kr/file/1234.tar.gz / <span class="comment"># Container 내부의 / 경로에 1234.tar.gz 파일 추가</span></span><br></pre></td></tr></table></figure></p><h2 id="copy-파일을-container로-복사">COPY - 파일을 Container로 복사</h2><ul><li>ADD의 기능과 거의 유사합니다.</li><li>COPY &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li><li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li><li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li><li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li><li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li><li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀지않고 그대로 복사됩니다. <strong>(ADD와 차이점)</strong></li><li>인터넷에 있는 파일 URL은 사용 불가. <strong>(ADD와 차이점)</strong></li><li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li><li>COPY로 추가되는 파일은 root root 기존 권한을 따릅니다</li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">COPY ../file.sh /home/file.sh (x) <span class="comment">#상위 디렉터리 사용x</span></span><br><span class="line">COPY /home/user/file.sh /home/file.sh(x) <span class="comment">#절대경로 사용x</span></span><br><span class="line">COPY file.sh ../../file.sh (x) <span class="comment">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class="line"> </span><br><span class="line">COPY file.sh /home/file.sh (O) <span class="comment">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class="line">COPY *.sh /home (O) <span class="comment"># 와일드카드를 이용하여 복사 가능</span></span><br><span class="line">COPY compress.tar.gz / (O)<span class="comment"># Container / 경로에 compress.tar파일이 복사</span></span><br><span class="line">COPY http://file.co.kr/file/1234.tar.gz / (X) <span class="comment"># COPY는 인터넷 파일URL 사용 불가</span></span><br></pre></td></tr></table></figure></p><h2 id="run-container-내부에서-명령-실행">RUN - Container 내부에서 명령 실행</h2><ul><li>기본적으로 /bin/sh 파일로 실행됩니다.</li><li>Window의 경우 cmd 기반 명령을 수행합니다.</li></ul><p>Dockerfile 내 RUN 명령어 사용법<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># software 설치 명령 실행 (예시의 경우 yum이 Container내부에 설치되어야 합니다.)</span></span><br><span class="line">RUN yum -y install software  </span><br><span class="line"><span class="comment"># /usr/local/redis directory 생성</span></span><br><span class="line">RUN mkdir -p /usr/<span class="built_in">local</span>/redis </span><br><span class="line"><span class="comment"># execute.sh 파일 실행 </span></span><br><span class="line">RUN [<span class="string">"execute.sh"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]</span><br></pre></td></tr></table></figure></p><p>명령어의 길이가 긴 경우 \ 문자를 사용하여 append 가능합니다</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN yum -y install software \</span><br><span class="line">         <span class="built_in">echo</span> <span class="string">"install software"</span> \</span><br><span class="line">         mkdir -p /usr/<span class="built_in">local</span>/redis</span><br></pre></td></tr></table></figure></p><h2 id="env-container-내부에서-사용할-환경-변수-추가">ENV - Container 내부에서 사용할 환경 변수 추가</h2><p>Container는 Host OS와 독립된 공간이기 때문에 Container 내부에서 사용 할 환경변수를 추가할 수 있습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV LOCAL_PORT 80</span><br><span class="line">ENV REDIS_HOME /usr/<span class="built_in">local</span>/bin/redis</span><br></pre></td></tr></table></figure></p><h2 id="expose-container의-port-설정">EXPOSE - Container의 Port 설정</h2><ul><li>Host OS - Container와 통신할 포트를 설정</li><li>EXPOSE는 Host OS와 연결만 할 뿐 외부에 노출 되지는 않습니다.</li><li>포트를 노출 하기 위해서는 docker run -p 또는 -P 옵션 사용해야 합니다.</li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 80   <span class="comment">#Container 내의 Web Server Port 노출</span></span><br><span class="line">EXPOSE 6379 <span class="comment">#Container 내의 Redis Server Port 노출</span></span><br><span class="line"> </span><br><span class="line">EXPOSE 80 6379 <span class="comment">#포트 여러개 노출</span></span><br></pre></td></tr></table></figure></p><h2 id="volume-외부-볼륨-설정">VOLUME - 외부 볼륨 설정</h2><ul><li>Container 내부의 Directory와 Host OS의 Directory를 동기화 시키는 설정</li><li>log파일이나 설정파일은 보통 Container 내부에만 있는데 이를 Host OS에 동기화 하여 파일에 대한 접근이 가능하게 한다.</li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile volume 설정</span></span><br><span class="line">VOLUME [<span class="string">"/data"</span>, <span class="string">"/var/log"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker run 사용 시, volumn 설정</span></span><br><span class="line"><span class="comment"># -v 옵션을 사용하여 설정 -v &lt;host 디렉터리&gt;:&lt;컨테이너 디렉터리&gt;</span></span><br><span class="line">docker run -v /host/os/data:/container/data app</span><br></pre></td></tr></table></figure></p><h2 id="workdir-container의-work-directory-설정">WORKDIR - Container의 Work Directory 설정</h2><ul><li>RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉터리</li><li>중간에 Directory가 변경되는 경우 바꿀수 있다.</li><li>리눅스의 cd 명령어와 비슷하다.</li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /usr/<span class="built_in">local</span>/bin</span><br><span class="line">ADD redis.conf /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line"> </span><br><span class="line">WORKDIR /usr/<span class="built_in">local</span></span><br><span class="line">ADD redis.log /usr/<span class="built_in">local</span>/redis.log</span><br><span class="line"></span><br><span class="line">WORKDIR var</span><br><span class="line">WORKDIR lib</span><br><span class="line">RUN touch file.sh <span class="comment"># /var/lib/file.sh 생성</span></span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>http://pyrasis.com/book/DockerForTheReallyImpatient</li><li>https://docs.docker.com/engine/reference/builder</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (2) Docker 설치 및 사용방법</title>
      <link>https://jaehun2841.github.io/2018/11/28/2018-11-28-docker-2/</link>
      <guid>https://jaehun2841.github.io/2018/11/28/2018-11-28-docker-2/</guid>
      <pubDate>Wed, 28 Nov 2018 14:50:01 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;들어가며&quot;&gt;들어가며&lt;/h1&gt;
&lt;p&gt;지난 장에서는 Docker에 대한 개념, Image와 컨테이너, VM과의 차이점등을 그림으로 설명하였습니다.
이번 장부터는 Docker를 linux서버에 설치하는 과정을 설명하고자 합니다.
(Linux서
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="들어가며">들어가며</h1><p>지난 장에서는 Docker에 대한 개념, Image와 컨테이너, VM과의 차이점등을 그림으로 설명하였습니다.이번 장부터는 Docker를 linux서버에 설치하는 과정을 설명하고자 합니다.(Linux서버 설치는 hyper-v를 이용하여 vm으로 설치 하였습니다. &lt;차후에 hyper-v 설정기를 올릴 예정입니다.&gt;)Windows, Mac에도 설치 할 수 있지만, Linux에 설치하는게 거의 표준이다 싶히 사용되고 있으며, Windows, Mac에 설치를 하더라도 어차피 가상화 환경에서 Docker가 설치 되기 때문에... linux를 설치하여 Docker를 설치하였습니다.(지울 때 편하게 지우고 싶어서 그런건 안비밀)</p><h1 id="centos-7-환경에서-docker-설치하기">CentOS 7 환경에서 Docker 설치하기</h1><p>Docker를 설치하는 방법은 다양한 방법이 있겠지만.. 가장 간단한 방법으로 설치해 보도록 하겠습니다.</p><p>설치 환경은 아래와 같습니다.</p><ul><li>OS: CentOS 7 (VM 환경(Hyper-v)에서 테스트)</li><li>user: docker-user (일부러 root가 아닌 사용자를 생성하였습니다... 이유는 아래에)</li><li>SW: Redis 5</li></ul><blockquote><p>Docker 다운로드 yum을 이용해서 Docker를 받는 방법도 있지만, <code>최신버전이 아닙니다.</code>차후 Docker-compose를 사용하기 위해서는 Docker버전이 1.13 이상이 되야 합니다.따라서 한번에 패키지로 설치해 주는 url로 설치하도록 합니다.</p></blockquote><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -fsSL https://get.docker.com/ | sudo sh</span><br><span class="line">sudo sh sudo service docker start <span class="comment">#Docker Daemon Start</span></span><br></pre></td></tr></table></figure></p><h1 id="docker의-permission">Docker의 Permission</h1><p>Docker를 설치하고 확인하기 위해 Docker 명령을 입력하였습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure></p><p><img src="./docker-permission.png" alt="docker permission"></p><p>docker명령을 입력했을 시, permission denied 에러가 발생한 것을 볼 수 있습니다.docker는 명령을 실행 할 때 기본적으로 root계정을 필요로 합니다. (docker의 특성상 시스템의 내부적인 부분에 접근하는 게 많다보니... 그렇다고 합니다.)그렇기 때문에 sudo명령을 사용하여 docker 명령을 실행 할 수 있습니다.</p><p><code>하지만 sudo가 너무 귀찮다! 하시는 분들은...</code> 아래 명령을 실행하여 계정을 <code>docker 그룹</code>에 포함 시켜주시면 됩니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br><span class="line">sudo service docker restart</span><br><span class="line"> </span><br><span class="line"><span class="built_in">exit</span> <span class="comment">#로그아웃</span></span><br><span class="line">docker-user &lt;password&gt; <span class="comment">#다시 로그인</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure></p><p><img src="./sudo-docker.png" alt="sudo docker"></p><p>이제 sudo 명령 없이도 docker 명령어 실행이 잘 됩니다!</p><h1 id="간단한-docker-container깡통를-만들어-봅시다">간단한 Docker Container(깡통)를 만들어 봅시다!</h1><p>Docker Hub(<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com</a>) 사이트에 들어가면 우리가 필요로하는 많은 프로그램들이 이미지로 올라가 있습니다.이번 예제에서는 Redis를 가지고 Docker Container를 만들어보도록 하겠습니다.</p><p><img src="./docker-hub.png" alt="docker-hub"></p><p>docker hub 사이트에서 redis를 검색해 보았습니다.여러가지 redis 이미지가 보이는데 official이라고 되어있는 것이 공식이미지 입니다.bitnami/redis라고 되어있는 것은 docker hub의 사용자들이 올린 이미지입니다.</p><p><img src="./redis-versions.png" alt="redis-versions"></p><p>official 이미지의 상세 버전을 보니 4.x~5.0.1까지 있습니다.이번 예제에서는 그나마 stable한 버전인 인 5.0-alpine 버전을 사용해 보도록 하겠습니다.</p><h1 id="docker-이미지-다운로드-docker-hub-gt-docker-client">Docker 이미지 다운로드 (Docker hub -&gt; Docker Client)</h1><p>pull 명령을 통해 docker hub에 있는 이미지를 다운로드 합니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:&lt;tag&gt; <span class="comment"># ex) redis:5.0-alpine, redis:4-alpine, redis:latest(가장 마지막 배포 버전입니다.)</span></span><br><span class="line">docker pull redis <span class="comment">#tag version을 적지 않은 경우 자동으로 lastest 버전을 다운로드 합니다.</span></span><br></pre></td></tr></table></figure></p><h1 id="docker-이미지-확인-삭제">Docker 이미지 확인 / 삭제</h1><h2 id="docker-이미지-확인">Docker 이미지 확인</h2><p>images 명령을 이용하여 docker image리스트를 확인합니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></p><ul><li>자주 사용하는 options<ul><li>-a --all : 숨겨진 임시 이미지를 보여줍니다.</li><li>-f --filter : filter를 이용하여 이미지 조회 조건을 변경하여 조회 할 수 있습니다.</li><li>-q --quite : image의 image ID만 출력합니다.</li></ul></li></ul><blockquote><p>docker의 이미지는 1개의 파일이 아닌, 여러 이미지의 레이어(Layer)로 구성되어 있습니다.따라서 Redis이미지를 다운받더라고 Redis 이미지 하나가 아닌 여러 이미지의 레이어로 구성되어 있습니다.<img src="./image-layer.png" alt="image layer">따라서 하나의 이미지라도 여러 이미지가 투영되어 보이는 결과물이라 볼 수 있습니다.</p></blockquote><h2 id="docker-이미지-삭제">Docker 이미지 삭제</h2><p>rmi 명령을 이용하여 docker의 image를 삭제 할 수 있습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex) docker rmi redis:5.0-alpine, docker rmi &lt;imageID&gt;</span></span><br><span class="line">docker rmi &#123;이미지명/이미지ID&#125;</span><br></pre></td></tr></table></figure></p><ul><li>자주 사용하는 Options<ul><li>-f --force : 이미지를 강제로 삭제합니다. (해당 이미지로 만들어진 Docker Container가 존재하는 경우 이미지를 삭제 할 수 없는데, 그 때 강제로 삭제 하기위해 사용)</li></ul></li></ul><h1 id="docker-container-생성-삭제">Docker Container 생성 / 삭제</h1><h2 id="docker-container-생성">Docker Container 생성</h2><p>run 명령으로 Container를 생성합니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex) docker run -it -d redis:5.0-alpine,</span></span><br><span class="line"><span class="comment">#     docker run -it -d 4760dc956b2d</span></span><br><span class="line">docker run &#123;options&#125; &lt;image명/image ID&gt;</span><br></pre></td></tr></table></figure></p><ul><li><p>자주 사용하는 Options</p><ul><li>-d --detach : Container 생성 후 Background로 실행 (이 옵션 없을 시, Redis 같은 경우에는 Console에 Redis log가 지속적으로 표시됩니다.)</li><li>-h --hostname : Container 명 지정</li><li>-i --interactive : 소통형 모드로 실행 (주로 ubuntu와 같은 Container 실행 시 사용)</li><li>-p --publish : 해당 Container의 외부 Port 지정 (10000:6379) (외부:내부) 형식으로 지정</li><li>-P --publish-all : 여러개의 Port 노출 (1000-1100)</li><li>--rm : Container 종료 시, Container 삭제 <code>(자주 사용되는 옵션입니다)</code></li><li>-v --volume : 외부 볼륨 연동 /home/user/data:/data (외부 OS 디렉토리:컨테이너 내부 디렉토리) - 상호 데이터가 공유됨</li></ul></li></ul><h2 id="docker-container-목록-조회">Docker Container 목록 조회</h2><p>ps 명령으로 Container 목록을 조회합니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps &#123;options&#125;</span><br></pre></td></tr></table></figure></p><ul><li>자주 사용하는 Options</li><li>-a : 비활성 상태의 Container까지 조회</li><li>-q : Container ID만 조회</li><li>-f --filter : Container 조회 시, Filter를 이용하여 조회</li></ul><h2 id="docker-container-내부-접속">Docker Container 내부 접속</h2><p>attach 명령을 이용하여 접속<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [container명/container ID]</span><br></pre></td></tr></table></figure></p><blockquote><p>attach 명령은 /bin/bash로 실행 되기 때문에, Container에 /bin/bash가 없는 경우에는 접속이 불가능 합니다.</p></blockquote><p>exec 명령을 이용하여 Container 내부 명령 수행<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex) docker exec -it redis:5.0-alpine /bin/sh</span></span><br><span class="line"><span class="comment"># Redis의 경우 Container에 bin/bash가 없어 bin/sh로 실행하면 내부접속이 가능합니다</span></span><br><span class="line">docker <span class="built_in">exec</span> &#123;options&#125; [container명/container ID] [명령어]</span><br></pre></td></tr></table></figure></p><ul><li>자주 사용하는 options<ul><li>-d --detach : 명령수행을 Background 모드로 수행</li><li>-e --env : 환경변수 (Environment) 설정</li><li>-i --interaction : 대화형 모드로 설정</li></ul></li></ul><h1 id="docker-container-삭제">Docker Container 삭제</h1><p>rm 명령으로 Container를 삭제 합니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex) docker rm -f redis:5.0-alpine</span></span><br><span class="line">docker rm &#123;options&#125; [container명/container ID]</span><br></pre></td></tr></table></figure></p><ul><li>자주 사용하는 options<ul><li>-f --force : 활성(active) 상태의 Container 강제삭제</li><li>-l --link : Container간 link가 관계인 Container 삭제</li><li>-v --volumes : Container 관련 볼륨(외부 디렉토리) 삭제</li></ul></li></ul><h1 id="자주-사용한-명령어-모음">자주 사용한 명령어 모음</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Container 전체 삭제 (-a -q 옵션으로 전체 Container의 ID만 뽑아온다.)</span></span><br><span class="line">docker rm -f $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Image 전체 삭제 (-q 옵션으로 images에 대한 Image ID만 뽑아온다.)</span></span><br><span class="line">docker rmi $(docker images -q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#특정 Container 삭제 (grep 명령으로 Container ID만 뽑아온다.)</span></span><br><span class="line">docker rm -f $(docker ps -a | grep <span class="string">"redis:5.0-alpine"</span>| awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#특정 이미지 삭제 (grep + awk 명령어로 image ID만 뽑아온다.)</span></span><br><span class="line">docker rmi $(docker images | grep <span class="string">"^redis"</span>| awk <span class="string">'&#123;print $3&#125;'</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#Docker 삭제</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">yum remove -y docker*</span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>http://www.sauru.so/blog/docker-installation-and-test-drive/</li><li>https://hub.docker.com/_/redis/</li><li>http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03</li><li>https://docs.docker.com/engine/reference/run/</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/11/28/2018-11-28-docker-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (1) Docker란 무엇인가?</title>
      <link>https://jaehun2841.github.io/2018/11/25/2018-11-25-docker-1/</link>
      <guid>https://jaehun2841.github.io/2018/11/25/2018-11-25-docker-1/</guid>
      <pubDate>Sun, 25 Nov 2018 09:51:22 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;docker란-무엇인가&quot;&gt;Docker란 무엇인가?&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;./docker-logo.png&quot; alt=&quot;docker-logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;Docker란 &lt;strong&gt;Linux 컨테이너(Container) 기반의
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="docker란-무엇인가">Docker란 무엇인가?</h1><p><img src="./docker-logo.png" alt="docker-logo"></p><p>Docker란 <strong>Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼</strong> 입니다.</p><p>위의 Docker 이미지처럼 선박에 화물을 수송하는 이미지를 떠올리면 이해하기가 쉬운데, 실제 선박에는 자동차, 오토바이, 전자제품등 여러 물건을 담을 수 있습니다.</p><p>선박에 대한 이미지를 유지한 채, Web Service 운영환경을 생각해 보면..Web Service 운영환경을 구성하기 위해서는 Web Application이 구동 될 수 있는 WAS와 DataBase가 필요합니다.</p><p>이 2가지 프로그램을 Docker라는 선박에 담는다고 생각해 봅시다.그 다음 우리가 배포할 서버를 항구(Port)라고 생각하고,각 서버에 Web Service 운영환경을 싣고 있는 선박을 정착 시켜 서버에서 접근가능한 서비스로 이용할 수 있습니다. 따라서 어떤 서버에서도 Docker만 설치되어 있다면, 다양한 <code>프로그램과 실행환경을 추상화 하여 동일한 인터페이스를 제공</code>하고 서버관리를 쉽고 단순하게 만들어 줄 수 있습니다.</p><p>Docker에서는 <code>Image</code>와 <code>Container</code>라는 개념을 사용하는데, 이 두 가지 개념에 대해 알아보도록 하겠습니다.</p><h1 id="docker-image">Docker Image</h1><p><img src="./docker-image.png" alt="docker-image"></p><p>Docker Image는 우리가 사용할 프로그램을 추상화 한 개념입니다.</p><p>Image에는 Container 실행에 필요한 파일(redis.conf, redis.log...., docker-entrypoing.sh등)등을 포함하고,설정값(port, env, data directory등) 정보를 포함하고 있습니다.<code>1개의 이미지</code>를 바탕으로<code>여러 개의 컨테이너</code>를 만들 수 있습니다.(ex. 하나의 Redis 이미지를 바탕으로 3개의 Redis Container를 구성하여 Cluster환경을 구성할 수 있습니다.)이 내용을 좀 더 쉽게 이해하자면, 한번 쯤은 WM에 Linux를 설치 해 본 경험이 있을텐데, Linux를 설치 하기 위해선 linux.iso 파일이 필요 합니다.이때 iso파일이 Linux를 구성하기 위한 파일과 설정 정보를 담고 있고 VM에 Linux를 설치 할 수 있게 해줍니다.여기서 <code>iso파일</code>을 <code>Image</code>라고 생각하고, <code>VM위에 설치되는 리눅스</code>를 <code>Container</code>라고 이해 할 수 있겠습니다.</p><p>Docker를 이용한 운영 배포 시, 이미지를 <code>Docker Hub</code>라는 곳에 올려 각 서버에서 받아 사용할 수 있습니다.(Docker Hub는 github나 maven repository 같은 클라우드 저장소 같은 개념으로 이해 하시면 됩니다.)</p><h1 id="docker-container">Docker Container</h1><p>Container란, <strong>프로그램의 실행에 필요한 실행환경을 독립적으로 운용할 수 있도록, 다른 실행환경과의 간섭을 막고 독립성을 확보해 주는 운영체제 수준의 격리 기술</strong>을 의미합니다.</p><p>이러한 격리된 환경이 필요한 경우를 생각해 볼 수 있는데, 극단적인 예시로 Java 1.6 환경에서만 실행되는 프로그램과 Java 1.8이상 환경에서만 실행 되는 프로그램을 하나의 서버에 설치한다고 가정하겠습니다.</p><p>프로그램이 실행 되기 위해서는 운영체제에 설치 된 라이브러리의 대해 의존성을 가질 수 밖에 없는데, 하나의 OS에서 Java Version에 대한 격리 환경을 가지게 하는 것은 상당히 번거로운 일입니다.이러한 경우 Docker를 사용하면 격리된 구역에서 실행 환경을 만들어 줄 수 있기 때문에 타 시스템에 영향을 주지 않고 안정적으로 운영환경을 구성 할 수 있습니다.</p><p>Docker을 처음 공부할 때 Image와 Container 관계가 무척이나 헷갈렸는데.. 예시를 통해 이해해 보겠습니다.Image는 실행 환경에 대한 파일과 설정 정보를 담고 있다고 했습니다. 그리고 프로그램을 추상화 한 개념이라고 하였습니다.이는 Java의 Class와 같은 개념으로 인식 할 수 있습니다.Container는 Image를 기반으로 생성된 격리 된 실행환경이라 했습니다. 그리고 Container를 실행 할 경우 파라미터를 통해 Container 내부 설정정보를 변경 할 수도 있습니다.이는 Class를 바탕으로 만들어진 Instance의 개념으로 이해 할 수 있습니다.이처럼 Java의 Class와 Instance의 관계로 이해한다면, Docker에서의 Image와 Container 관계에 대해 어렵지 않게 이해 할 수 있을 것 같습니다.</p><p><img src="./docking-image.png" alt="docking-image"></p><p>도킹에 성공한 Container는 Host OS에 설치 된 프로그램 처럼 사용할 수 있다.</p><h1 id="docker-vs-virtual-machine">Docker vs Virtual Machine</h1><p>위에서 설명하길 &quot;Docker란 <strong>Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼</strong>입니다.&quot; 라고 이야기 하였습니다.가상화라고 하면 대표적인 예가 Virtual Machine 즉 VM을 떠올릴 수 있는데요.</p><p>VM과 Docker는 몇가지 차이점이 있습니다.먼저 그림으로 그 구조를 확인해 보겠습니다.</p><p><img src="./vm-vs-docker.png" alt="vm-vs-docker"></p><p>먼저 VM의 가상화 방식은 기존의 <code>Host OS위에 Hyper Visor를 이용</code>하여 가상화 OS를 띄우는 방식으로 많이 구현했습니다.주로 Windows에서 VMWare, Virtual Box, Hyper-V등 가상화 도구를 이용해 Guest OS를 설치하고 그 OS 위에 우리가 사용하고자 하는 프로그램을 설치하여 사용하였습니다.</p><p>이러한 방식은 <code>완벽한 수준의 격리</code>이며, Host OS에서 Guest OS의 프로그램을 직접적으로 제어할 수 없습니다또한 Host OS에서 할당한 자원(Resource)밖에 사용할 수 없기 때문에 Host OS에서도 가상 OS에 점유한 자원을 유동적으로 사용할 수 없어 낭비가 생깁니다.</p><p>반면에 Container 방식은 <strong>기존의 Host OS위에 Docker를 이용하여 해당 프로그램의 의존성 라이브러리(프로그램 구동에 필요한 라이브러리)만 가지고 Container가 생성</strong>됩니다. 그렇기에 <code>최소한의 용량으로 이미지를 구성</code> 할 수 있습니다.VM에서 사용되는 OS나 Kernel이 없기 때문에 부팅을 할 필요도 없으며, Host OS의 Resource 또한 유동적으로 사용할 수 있어 자원관리가 효율적입니다.</p><p>단순히 프로세스를 격리시키는 것이기 때문에 <code>VM에 비해 매우 빠르게 동작</code>합니다.단점인 부분은 <strong>Host OS에 종속적인 부분이 있습니다.</strong>VM방식의 경우 각각의 OS에 대한 독립성을 가지고 있어, Host OS에 대해 독립적입니다. (예를들어 Host OS가 리눅스이고, Guest OS가 Windows인 경우, MSSQL을 Guest OS에서 사용할 수 있다)하지만 Container방식은 Host OS의 자원을 기반으로 생성 되기 때문에 <code>Host OS에서 작동할 수 없는 프로그램은 Container 내부에서 작동 할 수 없습니다.</code></p><h1 id="docker-for-xx">Docker for XX</h1><p>Docker는 리눅스 컨테이너 기반으로 동작하지만 최근 Windows와 Mac에 대해서도 Docker를 지원하고 있습니다.하지만 Linux기반 Docker와 조금 차이점이 있습니다.아무래도 Linux 기반 컨테이너이기 때문에 Windows에서는 Hyper-V에 리눅스를 설치하여 연동되게 되어있습니다.이 경우 Host OS가 Windows가 되는 것이 아니라, Hyper-V의 리눅스가 Host OS가 되는 것이기 때문에 Hyper-V에 할당된 메모리와 디스크 용량을 기반으로 자원을 활용하게 됩니다.Linux가 아닌 다른 운영체제에서 Docker 설치 시 유의해야 할 부분입니다.</p><h1 id="참고">참고</h1><ul><li><p><a href="http://www.sauru.so/blog/getting-started-with-docker/" target="_blank" rel="noopener">http://www.sauru.so/blog/getting-started-with-docker/</a></p></li><li><p><a href="http://www.sauru.so/blog/getting-started-with-docker/" target="_blank" rel="noopener">http://www.sauru.so/blog/getting-started-with-docker/</a></p></li><li><p><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank" rel="noopener">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p></li><li><p><a href="https://www.docker.com/enterprise-edition#/platform" target="_blank" rel="noopener">https://www.docker.com/enterprise-edition#/platform</a></p></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/11/25/2018-11-25-docker-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>SpEL Expression(2)</title>
      <link>https://jaehun2841.github.io/2018/11/25/2018-11-25-spel-expression-2/</link>
      <guid>https://jaehun2841.github.io/2018/11/25/2018-11-25-spel-expression-2/</guid>
      <pubDate>Sun, 25 Nov 2018 08:11:42 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;리터럴-표현식-literal-expression&quot;&gt;리터럴 표현식 (Literal Expression)&lt;/h1&gt;
&lt;p&gt;리터럴 표현식을 제공하는 타입은 문자열(String), 숫자(int, real, hex), boolean, null이다.
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="리터럴-표현식-literal-expression">리터럴 표현식 (Literal Expression)</h1><p>리터럴 표현식을 제공하는 타입은 문자열(String), 숫자(int, real, hex), boolean, null이다.</p><ul><li>문자열 (Strings)는 따옴표(')로 구분된다 <code>(쌍따옴표가 아님)</code> - 문자열 표현 시, <code>'Hello World'</code> 처럼 SpEL을 작성</li></ul><p>다음은 리터럴 표현식 (Literal Expression)에 대한 간단한 예제이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line"><span class="comment">//따옴표로 이루어진 'Hello World' =&gt; Hello World라는 문자열로 평가 된다.</span></span><br><span class="line">String helloWorld = (String) parser.parseExpression(<span class="string">"'Hello World'"</span>).getValue();</span><br><span class="line"><span class="comment">//Double 타입의 숫자로 평가</span></span><br><span class="line"><span class="keyword">double</span> avogadrosNumber = (Double) parser.parseExpression(<span class="string">"6.0221415E+23"</span>).getValue();</span><br><span class="line"><span class="comment">//2147483647로 평가</span></span><br><span class="line"><span class="keyword">int</span> maxValue = (Integer) parser.parseExpression(<span class="string">"0x7FFFFFFF"</span>).getValue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> trueValue = (Boolean) parser.parseExpression(<span class="string">"true"</span>).getValue();</span><br><span class="line"><span class="comment">//null로 평가 된다. -&gt; null String이 아니다. (주의)</span></span><br><span class="line">Object nullValue = parser.parseExpression(<span class="string">"null"</span>).getValue();</span><br></pre></td></tr></table></figure></p><ul><li>숫자는 음수기호(-), 지수표시(E), 소수점(.)을 지원한다.</li><li>기본적으로 실제 숫자는 Double.parseDouble()로 파싱한다.</li></ul><h1 id="메서드-호출">메서드 호출</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String 리터럴 abc에 대한 substring 메서드 호출 -&gt; bc가 리턴된다.</span></span><br><span class="line">String c = parser.parseExpression(<span class="string">"'abc'.substring(2, 3)"</span>).getValue(String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//사용자 정의 메서드 호출 (Return Type : Boolean) -&gt; boolean 타입으로 평가된다.</span></span><br><span class="line"><span class="keyword">boolean</span> isMember = parser.parseExpression(<span class="string">"isMember('Mihajlo Pupin')"</span>).getValue(</span><br><span class="line">        societyContext, Boolean.class);</span><br></pre></td></tr></table></figure></p><p>위의 코드는 메서드 호출에 대한 예제 코드이다.</p><ul><li>메서드는 Java 문법을 사용하여 호출 할 수 있다.</li><li>Literal에 대한 메서드 호출도 가능하다.</li><li>Varargs 형식의 파라미터도 지원하고 있다.</li></ul><h1 id="프로퍼티-배열-리스트-맵에-대한-접근-지원">프로퍼티, 배열, 리스트, 맵에 대한 접근 지원</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 발명품 배열</span></span><br><span class="line">StandardEvaluationContext teslaContext = <span class="keyword">new</span> StandardEvaluationContext(tesla);</span><br><span class="line"></span><br><span class="line"><span class="comment">// "Induction motor"로 평가된다.</span></span><br><span class="line">String invention = parser.parseExpression(<span class="string">"inventions[3]"</span>).getValue(teslaContext, String.class); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 회원 리스트</span></span><br><span class="line">StandardEvaluationContext societyContext = <span class="keyword">new</span> StandardEvaluationContext(ieee);</span><br><span class="line"></span><br><span class="line"><span class="comment">// "Nikola Tesla"로 평가된다.</span></span><br><span class="line">String name = parser.parseExpression(<span class="string">"Members[0].Name"</span>).getValue(societyContext, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리스트와 배열 탐색</span></span><br><span class="line"><span class="comment">// "Wireless communication"로 평가된다.</span></span><br><span class="line">String invention = parser.parseExpression(<span class="string">"Members[0].Inventions[6]"</span>).getValue(societyContext, String.class);</span><br></pre></td></tr></table></figure></p><ul><li>프로퍼티의 맨 첫글자는 대소문자를 구별하지 않는다.</li><li>SpEL은 표준 <code>dot 표기법</code>(예: prop1.prop2.prop3)을 사용해서 중첩된 프로퍼티와 프로퍼티의 값 설정도 지원한다.</li><li>public 필드에 대한 접근을 지원한다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Officer의 딕션어리</span></span><br><span class="line">Inventor pupin = parser.parseExpression(<span class="string">"Officers['president']"</span>).getValue(societyContext, Inventor.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// "Idvor"로 평가된다</span></span><br><span class="line">String city = parser.parseExpression(<span class="string">"Officers['president'].PlaceOfBirth.City"</span>).getValue(societyContext, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 값을 설정한다</span></span><br><span class="line">parser.parseExpression(<span class="string">"Officers['advisors'][0].PlaceOfBirth.Country"</span>).setValue(societyContext, <span class="string">"Croatia"</span>);</span><br></pre></td></tr></table></figure></p><ul><li>대괄호<code>[]</code> 를 사용하여 Map의 key를 바탕으로 데이터에 접근한다.(위의 예제에서는 Officers가 <code>Map</code>, president가 <code>key</code>이다.)</li><li>SpEL은 표준 'dot' 표기법(예: prop1.prop2.prop3)을 사용해서 Map내의 value 객체의 프로퍼티에도 접근 가능하다.</li><li>setValue 메서드를 통해 데이터를 수정할 수 있다.</li></ul><h1 id="인라인-리스트-inline-list">인라인 리스트 (Inline list)</h1><p>리스트는 {} 표기법을 사용하여 리스트로 사용 할 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4개의 숫자를 담고 있는 리스트로 평가된다</span></span><br><span class="line">List&lt;Integer&gt; numbers = (List) parser.parseExpression(<span class="string">"&#123;1,2,3,4&#125;"</span>).getValue(context); </span><br><span class="line"></span><br><span class="line"><span class="comment">//List의 List의 형태의 List로 평가된다.</span></span><br><span class="line"><span class="comment">//listOfLists[0] = &#123;'a', 'b'&#125;</span></span><br><span class="line"><span class="comment">//listOfLists[1] = &#123;'x', 'y'&#125;</span></span><br><span class="line">List listOfLists = (List) parser.parseExpression(<span class="string">"&#123;&#123;'a','b'&#125;,&#123;'x','y'&#125;&#125;"</span>).getValue(context);</span><br></pre></td></tr></table></figure></p><h1 id="배열-생성">배열 생성</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers1 = (<span class="keyword">int</span>[]) parser.parseExpression(<span class="string">"new int[4]"</span>).getValue(context); </span><br><span class="line"></span><br><span class="line"><span class="comment">// initializer가진 배열</span></span><br><span class="line"><span class="keyword">int</span>[] numbers2 = (<span class="keyword">int</span>[]) parser.parseExpression(<span class="string">"new int[]&#123;1,2,3&#125;"</span>).getValue(context); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 다차원 배열</span></span><br><span class="line"><span class="keyword">int</span>[][] numbers3 = (<span class="keyword">int</span>[][]) parser.parseExpression(<span class="string">"new int[4][5]"</span>).getValue(context);</span><br></pre></td></tr></table></figure></p><ul><li>Java 문법과 같은 표현식을 사용하여 배열을 생성 할 수 있다.</li><li>{} 표현식을 통해 초기값을 세팅할 수 있다.</li><li>2차원 배열이상의 다차원 배열도 선언이 가능하다. (<code>단, 다차원 배열은 초기값을 설정할 수 없다.</code>)</li></ul><h1 id="연산자">연산자</h1><h2 id="관계-연산자">관계 연산자</h2><p>표준 관계 연산자를 사용한다. 사용 할 수 있는 관계 연산자는 아래와 같다.</p><ul><li>같음 (<code>==</code>)</li><li>같지 않음 (<code>!=</code>)</li><li>작음 (<code>&lt;</code>)</li><li>작거나 같음 (<code>&lt;=</code>)</li><li>큼 (<code>&gt;</code>)</li><li>크거나 같음 (<code>&gt;=</code>)</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(<span class="string">"2 == 2"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// false로 평가된다</span></span><br><span class="line"><span class="keyword">boolean</span> falseValue = parser.parseExpression(<span class="string">"2 &lt; -5.0"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(<span class="string">"'black' &lt; 'block'"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p><h2 id="심볼릭-연산자">심볼릭 연산자</h2><p>XML과 같이 문서형식에 관계 연산자가 제한을 받는 경우, 사용 가능한 문자 표현식을 제공한다.연산자에 대한 대소문자는 구별하지 않는다.</p><ul><li>같음 (<code>eq</code>)</li><li>같지 않음 (<code>ne</code>)</li><li>작음 (<code>lt</code>)</li><li>작거나 같음 (<code>le</code>)</li><li>큼 (<code>gt</code>)</li><li>크거나 같음 (<code>gt</code>)</li><li>div (<code>/</code>)</li><li>mod (<code>%</code>)</li><li>not (<code>!</code>)</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(<span class="string">"22 eq 22"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// false로 평가된다</span></span><br><span class="line"><span class="keyword">boolean</span> falseValue = parser.parseExpression(<span class="string">"'test' eq 'test!'"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p><h2 id="정규-표현식">정규 표현식</h2><p>matches를 이용한 정규표현식을 지원한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(<span class="string">"'5.00' matches '^-?\\d+(\\.\\d&#123;2&#125;)?$'"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// false로 평가된다</span></span><br><span class="line"><span class="keyword">boolean</span> falseValue = parser.parseExpression(<span class="string">"'5.0067' matches '^-?\\d+(\\.\\d&#123;2&#125;)?$'"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p><h2 id="instanceof">instanceof</h2><p>Java에서 super타입에 대한 연산을 위해 instanceof를 표현식으로 사용할 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false로 평가된다</span></span><br><span class="line"><span class="keyword">boolean</span> falseValue = parser.parseExpression(<span class="string">"'xyz' instanceof T(int)"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true로 평가된다.</span></span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(<span class="string">"'xyz' instanceof T(String)"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p><h2 id="논리연산자">논리연산자</h2><p>AND, OR, NOT에 대한 표현식을 지원한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -- AND --</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false로 평가된다</span></span><br><span class="line"><span class="keyword">boolean</span> falseValue = parser.parseExpression(<span class="string">"true and false"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line">String expression =  <span class="string">"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')"</span>;</span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- OR --</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(<span class="string">"true or false"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line">String expression =  <span class="string">"isMember('Nikola Tesla') or isMember('Albert Einstien')"</span>;</span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- NOT --</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false로 평가된다</span></span><br><span class="line"><span class="keyword">boolean</span> falseValue = parser.parseExpression(<span class="string">"!true"</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- AND and NOT --</span></span><br><span class="line">String expression =  <span class="string">"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')"</span>;</span><br><span class="line"><span class="keyword">boolean</span> falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br></pre></td></tr></table></figure></p><h2 id="수식-연산자">수식 연산자</h2><ul><li>더하기 (+) 연산자를 숫자, 날짜, 문자열에 사용할 수 있다.</li><li>빼기(-) 연산자를 숫자, 날짜에 사용할 수 있다.</li><li>곱하기(*), 나누기(/), 나머지(%)에 대한 연산은 숫자에만 사용 할 수 있다.</li><li>연산자 우선 순위 법칙이 적용된다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 더하기</span></span><br><span class="line"><span class="keyword">int</span> two = parser.parseExpression(<span class="string">"1 + 1"</span>).getValue(Integer.class); <span class="comment">// 2</span></span><br><span class="line">String testString = parser.parseExpression(<span class="string">"'test' + ' ' + 'string'"</span>).getValue(String.class);  <span class="comment">// 'test string'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 빼기</span></span><br><span class="line"><span class="keyword">int</span> four =  parser.parseExpression(<span class="string">"1 - -3"</span>).getValue(Integer.class); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">double</span> d = parser.parseExpression(<span class="string">"1000.00 - 1e4"</span>).getValue(Double.class); <span class="comment">// -9000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 곱하기</span></span><br><span class="line"><span class="keyword">int</span> six =  parser.parseExpression(<span class="string">"-2 * -3"</span>).getValue(Integer.class); <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">double</span> twentyFour = parser.parseExpression(<span class="string">"2.0 * 3e0 * 4"</span>).getValue(Double.class); <span class="comment">// 24.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 나누기</span></span><br><span class="line"><span class="keyword">int</span> minusTwo =  parser.parseExpression(<span class="string">"6 / -3"</span>).getValue(Integer.class); <span class="comment">// -2</span></span><br><span class="line"><span class="keyword">double</span> one = parser.parseExpression(<span class="string">"8.0 / 4e0 / 2"</span>).getValue(Double.class); <span class="comment">// 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 계수(Modulus)</span></span><br><span class="line"><span class="keyword">int</span> three =  parser.parseExpression(<span class="string">"7 % 4"</span>).getValue(Integer.class); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">int</span> one = parser.parseExpression(<span class="string">"8 / 5 % 2"</span>).getValue(Integer.class); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 연산자 우선순위</span></span><br><span class="line"><span class="keyword">int</span> minusTwentyOne = parser.parseExpression(<span class="string">"1+2-3*8"</span>).getValue(Integer.class); <span class="comment">// -21</span></span><br></pre></td></tr></table></figure></p><h2 id="3항-연산자-if-then-else">3항 연산자 (If-Then-Else)</h2><p>표현식에서 3항연산자를 통해 if-then-else 로직을 수행할 수 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//falseExp로 평가 된다.</span></span><br><span class="line">String falseString = parser.parseExpression(<span class="string">"false ? 'trueExp' : 'falseExp'"</span>).getValue(String.class);</span><br></pre></td></tr></table></figure></p><h2 id="elvis-연산자">Elvis 연산자</h2><ul><li>Elvis 연산자는 3항 연산자 구문을 단축시키고 Groovy 언어로 사용된다.</li><li>3항 연산자는 변수를 2번 반복해서 써야하는 단점이 있다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"Elvis Presley"</span>;</span><br><span class="line">String displayName = name != <span class="keyword">null</span> ? name : <span class="string">"Unknown"</span>;</span><br></pre></td></tr></table></figure></p><p>이런 조잡한 표현식 대신에 Elvis 연산자를 사용하면..<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">String name = parser.parseExpression(<span class="string">"name?:'Unknown'"</span>).getValue(String.class);  </span><br><span class="line">System.out.println(name); <span class="comment">// 'Unknown'</span></span><br></pre></td></tr></table></figure></p><p>간단하게 변수에 대해 <code>?</code> 를 붙여주는 것만으로도 null 체크를 해준다.? 모양이 엘비스 프레슬리의 머리모양을 닮아서 Elvis 연산자라고 명명하였다고 한다.</p><h2 id="안전한탐색navigation-연산자">안전한탐색(Navigation) 연산자</h2><ul><li>안전한 탐색 연산자는 NPE를 피하기 위해 사용, Groovy 언어로 제공</li><li>java로 코딩을 하다보면 습관적으로 if(variable == null) 과 같은 체크를 하게 된다.</li><li>하지만 Safe Navigation 연산자를 사용하면 NPE를 발생시키지 않고, 그냥 null을 리턴해 준다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">"Nikola Tesla"</span>, <span class="string">"Serbian"</span>);</span><br><span class="line">tesla.setPlaceOfBirth(<span class="keyword">new</span> PlaceOfBirth(<span class="string">"Smiljan"</span>));</span><br><span class="line"></span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);</span><br><span class="line"></span><br><span class="line"><span class="comment">//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행</span></span><br><span class="line">String city = parser.parseExpression(<span class="string">"PlaceOfBirth?.City"</span>).getValue(context, String.class);</span><br><span class="line">System.out.println(city); <span class="comment">// Smiljan</span></span><br><span class="line"></span><br><span class="line">tesla.setPlaceOfBirth(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행</span></span><br><span class="line">city = parser.parseExpression(<span class="string">"PlaceOfBirth?.City"</span>).getValue(context, String.class);</span><br><span class="line">System.out.println(city); <span class="comment">// null - null pointer exception이 발생하지 않는다.</span></span><br></pre></td></tr></table></figure></p><h1 id="할당">할당</h1><ul><li>할당연산자(<code>=</code>)를 이용하여 Context내의 프로퍼티에 value를 할당 할 수 있다.</li><li>보통은 setValue 메서드를 이용하여 value를 할당</li><li>getValue 메서드를 이용하여 할당 할 수도 있다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Inventor inventor = <span class="keyword">new</span> Inventor();</span><br><span class="line">StandardEvaluationContext inventorContext = <span class="keyword">new</span> StandardEvaluationContext(inventor);</span><br><span class="line"><span class="comment">//inventor.name에 Alexander Seovic2 문자열을 할당</span></span><br><span class="line">parser.parseExpression(<span class="string">"Name"</span>).setValue(inventorContext, <span class="string">"Alexander Seovic2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//할당연산자(`=`)를 이용하여 inventor.name에 Alexander Seovic2 문자열을 할당</span></span><br><span class="line">String aleks = parser.parseExpression(<span class="string">"Name = 'Alexandar Seovic'"</span>).getValue(inventorContext, String.class);</span><br></pre></td></tr></table></figure></p><h1 id="클래스-표현식">클래스 표현식</h1><ul><li><code>T</code> 연산자를 통해 클래스의 인스턴스를 지정하는데 사용할 수 있다.</li><li><code>T</code> 연산자를 통해 클래스의 static method도 사용할 수 있다.</li><li>웬만하면 full package를 적어준다.</li><li>StandardEvaluationContext는 타입을 찾으려고 TypeLocator를 사용</li><li>StandardTypeLocator는 java.lang 패키지로 만들어진다.</li><li>따라서 java.lang.String과 같은 타입은 T(String)으로 간단하게 표현 가능하다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class dateClass = parser.parseExpression(<span class="string">"T(java.util.Date)"</span>).getValue(Class.class);</span><br><span class="line"></span><br><span class="line">Class stringClass = parser.parseExpression(<span class="string">"T(String)"</span>).getValue(Class.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> trueValue = parser.parseExpression(<span class="string">"T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR"</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p><h1 id="생성자-호출">생성자 호출</h1><ul><li>생성자는 새로운 연산자를 사용해서 호출할 수 있다.</li><li>primitive type(원시 타입 int, double등..)과 String 외에는 모두 정규화된 클래스명을 사용해야 한다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inventor einstein = p.parseExpression(<span class="string">"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')"</span>).getValue(Inventor.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//리스트의 add 메서드내에서 새로운 inventor 인스턴스를 생성한다</span></span><br><span class="line">p.parseExpression(<span class="string">"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))"</span>).getValue(societyContext);</span><br></pre></td></tr></table></figure></p><h1 id="변수">변수</h1><ul><li><code>#</code> 표현식을 통해 표현식 내에 변수를 참조할 수 있다.</li><li>StandardEvaluationContext에서 setVariable 메서드를 사용해서 변수를 설정한다.</li><li>자주 쓰이는 표현식이다. (@Cacheable Annotation에서도 사용)</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">"Nikola Tesla"</span>, <span class="string">"Serbian"</span>);</span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);</span><br><span class="line">context.setVariable(<span class="string">"newName"</span>, <span class="string">"Mike Tesla"</span>); <span class="comment">//newName변수에 대한 value할당</span></span><br><span class="line"></span><br><span class="line">parser.parseExpression(<span class="string">"Name = #newName"</span>).getValue(context);</span><br><span class="line"></span><br><span class="line">System.out.println(tesla.getName()) <span class="comment">// "Mike Tesla"</span></span><br></pre></td></tr></table></figure></p><h2 id="root">#root</h2><ul><li>변수 #root는 항상 정의되며 루트 컨텍스트 개체의미</li><li>#root는 항상 루트를 나타낸다.</li><li>setRootObject 메서드를 통해 root를 정의한다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);</span><br><span class="line"></span><br><span class="line">SomeCustomObject someObject = <span class="keyword">new</span> SomeCustomObject();</span><br><span class="line">context.setRootObject(someObject);</span><br><span class="line"></span><br><span class="line">String name = <span class="string">"kocko"</span>;</span><br><span class="line">context.setVariable(<span class="string">"name"</span>, kocko);</span><br><span class="line">String statement = <span class="string">"#root.stringLength(#kocko) == 5"</span>;</span><br><span class="line">Expression expression = parser.parseExpression(statement);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> result = expression.getValue(context, Boolean.class);</span><br></pre></td></tr></table></figure></p><ul><li>#root는 SomeCustomObject를 의미</li></ul><h2 id="this">#this</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create an array of integers</span></span><br><span class="line">List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">primes.addAll(Arrays.asList(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 파서를 생성하고 'primes' 변수를 정수 배열로 설정한다</span></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">context.setVariable(<span class="string">"primes"</span>,primes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리스트에서 10보다 큰 모든 소수(?&#123;...&#125; 선택을 사용)</span></span><br><span class="line"><span class="comment">// [11, 13, 17]로 평가된다</span></span><br><span class="line">List&lt;Integer&gt;</span><br><span class="line"> primesGreaterThanTen = (List&lt;Integer&gt;) </span><br><span class="line">parser.parseExpression(<span class="string">"#primes.?[#this&gt;10]"</span>).getValue(context);</span><br><span class="line"><span class="comment">//#primes 변수에 대해 평가하며, #this는 2~17까지 값을 의미한다.</span></span><br></pre></td></tr></table></figure></p><ul><li>#this는 항상 정의되어 있고, 현재 평가되는 객체를 가리킨다.</li><li>#this는 계속 변경될 수 있다. (위의 예제에서 보면 2,3,5,7등 평가 시점에 따라 달라질수 있다.)</li></ul><h1 id="사용자-정의-함수">사용자 정의 함수</h1><ul><li>표현식 문자열 내에서 호출 가능한 사용자 정의 함수를 등록하여 SpEL의 기능을 확장할 수 있다.</li><li>StandardEvaluationContext에 사용자정의 함수를 등록하여 사용하면 된다.</li></ul><p>예시로 문자열을 reverse 하는 메서드를 구현하였다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        StringBuilder backwards = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++)</span><br><span class="line">            backwards.append(input.charAt(input.length() - <span class="number">1</span> - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> backwards.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>메서드를 StandardEvaluationContext에 등록<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringUtils 클래스에 정의된 reserveString 메서드를 등록한다.</span></span><br><span class="line"><span class="comment">//파라미터 타입은 String 타입 객체 1개이다.</span></span><br><span class="line">context.registerFunction(<span class="string">"reverseString"</span>, StringUtils.class.getDeclaredMethod(<span class="string">"reverseString"</span>, <span class="keyword">new</span> Class[] &#123; String.class &#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello 문자열을 뒤집은 olleh가 리턴된다.</span></span><br><span class="line">String helloWorldReversed = parser.parseExpression(<span class="string">"#reverseString('hello')"</span>).getValue(context, String.class);</span><br></pre></td></tr></table></figure></p><h1 id="bean-참조">Bean 참조</h1><p>evaluation context에 Bean Resolver가 설정된 경우 <code>@</code> 표현식으로 bean을 사용할 수 있다.Spring Docs에 있는 예제는 잘 이해가 안되어 직접 테스트 해보았다.</p><p>Bean 클래스 생성<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"do Test"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">//실용적인 테스트를 위해 Application Context의 BeanFactory를 설정</span></span><br><span class="line">DefaultListableBeanFactory factory = (DefaultListableBeanFactory) ((ConfigurableApplicationContext) applicationContext).getBeanFactory();</span><br><span class="line">context.setBeanResolver(<span class="keyword">new</span> BeanFactoryResolver(factory));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Application Context에 등록된 testBean이라는 bean을 불러와 test메서드를 실행하였다.</span></span><br><span class="line">String result = parser.parseExpression(<span class="string">"@testBean.test()"</span>).getValue(context, String.class);</span><br><span class="line"><span class="keyword">return</span> result; <span class="comment">//do Test가 리턴되었다.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="collection-선택-기능">Collection 선택 기능</h1><ul><li>컬렉션 (Collection) 선택 기능은 Context내의 Collection 필드에 접근하여 조건(Criteria)를 기반으로 서브 컬렉션을 반환 할 수 있다.</li><li><code>?[selectionExpression]</code> 표현식을 이용한다.</li><li>리스트, 맵에서 모두 사용 가능하다</li><li>객체가 context로 들어오는 경우 object.?[필드에 대한 조건]</li><li>컬렉션이 context로 들어오는 경우 .?[필드에 대한 조건] (별도의 필드가 없는 경우 #this를 사용)</li></ul><p>Twice 클래스를 선언<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Twice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Member&gt; members = <span class="keyword">new</span> ArrayList&lt;Member&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"지효"</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"나연"</span>, <span class="number">24</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"모모"</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"사나"</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"다현"</span>, <span class="number">21</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"미나"</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"채영"</span>, <span class="number">19</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"쯔위"</span>, <span class="number">19</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"정연"</span>, <span class="number">23</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Twice&gt; <span class="title">twice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">    StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Twice의 멤버 필드에 접근</span></span><br><span class="line">    <span class="comment">// 컬렉션의 age 필드에 대해 20 이하인 대상을 반환</span></span><br><span class="line">    List&lt;Twice&gt; filterList = (List&lt;Twice&gt;) parser.parseExpression(<span class="string">"members.?[age &lt; 20]"</span>).getValue(<span class="keyword">new</span> Twice());</span><br><span class="line">    <span class="keyword">return</span> filterList; <span class="comment">//[&#123;"name":"채영","age":19&#125;,&#123;"name":"쯔위","age":19&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="collection-투영-기능">Collection 투영 기능</h1><ul><li>투영기능은 컬렉션에 하위표현식을 반영하여 새로운 컬렉션을 리턴한다.</li><li><code>![projectionExpression]</code> 표현식을 사용한다.</li></ul><p>위의 Twice 예제를 바탕으로 설명하겠다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">twice2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">    StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line"></span><br><span class="line">    List&lt;Member&gt; testList = <span class="keyword">new</span> ArrayList&lt;Member&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"지효"</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"나연"</span>, <span class="number">24</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"모모"</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"사나"</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"다현"</span>, <span class="number">21</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"미나"</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"채영"</span>, <span class="number">19</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"쯔위"</span>, <span class="number">19</span>));</span><br><span class="line">            add(<span class="keyword">new</span> Member(<span class="string">"정연"</span>, <span class="number">23</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Twice 멤버 배열을 받아, 컬렉션 투영기능을 이용하여 그중 name에 대한 필드만 뽑아온 것이다.</span></span><br><span class="line">    List&lt;String&gt; filterList = (List&lt;String&gt;) parser.parseExpression(<span class="string">"![name]"</span>).getValue(testList);</span><br><span class="line">    <span class="keyword">return</span> filterList; <span class="comment">//["지효","나연","모모","사나","다현","미나","채영","쯔위","정연"]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="표현식-템플릿">표현식 템플릿</h1><ul><li>표현식 템플릿을 사용하면 평가 블록과 Literal text를 혼합할 수 있다.</li><li>평가블록은 prefix와 subfix로 구분</li><li>일반적으로 <code>#{</code> 와 <code>}</code>로 구분한다.</li><li>parseExpression() 메서드의 두번째 파라미터로 사용자 정의 ParseContext 객체를 넣어준다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateParserContext</span> <span class="keyword">implements</span> <span class="title">ParserContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"#&#123;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "random number is 0.7038186818312008"로 평가된다</span></span><br><span class="line">String randomPhrase = </span><br><span class="line">   parser.parseExpression(<span class="string">"random number is #&#123;T(java.lang.Math).random()&#125;"</span>, <span class="keyword">new</span> TemplateParserContext()).getValue(String.class);</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/11/25/2018-11-25-spel-expression-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>SpEL Expression(1)</title>
      <link>https://jaehun2841.github.io/2018/11/21/2018-11-21-spel-expression/</link>
      <guid>https://jaehun2841.github.io/2018/11/21/2018-11-21-spel-expression/</guid>
      <pubDate>Wed, 21 Nov 2018 05:11:42 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;들어가며&quot;&gt;들어가며&lt;/h1&gt;
&lt;p&gt;Spring Cache Abstraction 기능을 사용하게 되면서, key modeling 시, 필요한 SpEL에 대해 알아보게 되었다.
기본적인 설명과 예제는 Spring Docs를 기반으로 번역&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="들어가며">들어가며</h1><p>Spring Cache Abstraction 기능을 사용하게 되면서, key modeling 시, 필요한 SpEL에 대해 알아보게 되었다.기본적인 설명과 예제는 Spring Docs를 기반으로 번역</p><h1 id="spel-ltugtspltugtring-ltugteltugtxpression-ltugtlltugtanguage이란">SpEL (&lt;u&gt;Sp&lt;/u&gt;ring &lt;u&gt;E&lt;/u&gt;xpression &lt;u&gt;L&lt;/u&gt;anguage)이란?</h1><p>Spring Expression Language (줄여서 SpEL)은 런타임에 쿼리를 지원하고 객체를 조작할 수 있는 강력한 표현식 언어이다. 언어 구문은 Unified EL과 유사하지만, 여러가지 추가 기능을 제공한다.</p><p>다른 Java에서 사용가능한 표현식 언어가 있지만, SpEL은 Spring 커뮤니티에 표현식 언어를 제공하기 위해 만들어졌다.Spring 포트폴리오 내에서 표현식 평가 (Expression evaluation)의 기반으로 SpEL을 제공하지만, SpEL은 Spring과 직접 연계되지 않고 독립적으로 사용 할 수 있다.독립적으로 사용하기 위해서는 Parser 같은 Bootstraping 기반 클래스에 대한 설정을 몇가지 할 필요가 있다.하지만 웬만한 개발자들은 이런 기반 클래스에 대한 설정 없이 SpEL 표현식만 잘 작성하면 된다.</p><h1 id="spel에서-지원하는-기능">SpEL에서 지원하는 기능</h1><ul><li>리터럴 표현식 (Literal Expression)</li><li>Boolean과 관계형 Operator (Boolean and Relational Operator)</li><li>정규 표현식 (Regular Expression)</li><li>클래스 표현식 (Class Expression)</li><li>프로퍼티, 배열, 리스트, 맵에 대한 접근 지원 (Accessing properties, arrays, lists, maps)</li><li>메서드 호출 (Method Invocation)</li><li>관계형 Operator (Relational Operator)</li><li>할당 (Assignment)</li><li>생성자 호출 (Calling Constructors)</li><li>Bean 참조 (Bean References)</li><li>배열 생성 (Array Contruction)</li><li>인라인 리스트/맵 (Inline List/Map)</li><li>삼항 연산자 (Ternary Operator)</li><li>변수 (Variables)</li><li>사용자 정의 함수 (User defined functions)</li><li>컬렉션 투영 (Collections Projection)</li><li>컬렉션 선택 (Collections Selection)</li><li>Template 표현식 (Templated expression)</li></ul><h1 id="expression-인터페이스를-이용한-표현식-파싱">Expression 인터페이스를 이용한 표현식 파싱</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String message = parseExpression(<span class="string">"\"Hello World\""</span>, String.class);</span><br><span class="line">        System.out.println(message); <span class="comment">//"Hello World"</span></span><br><span class="line"></span><br><span class="line">        String message2 = parseExpression(<span class="string">"\"Hello World\".concat('!')"</span>, String.class);</span><br><span class="line">        System.out.println(message2); <span class="comment">//"Hello World!"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">parseExpression</span><span class="params">(String expression, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        Expression exp = parser.parseExpression(expression);</span><br><span class="line">        <span class="keyword">return</span> exp.getValue(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위의 코드는 SpEL표현식 문자열에 대한 파싱(Parsing) 하는 프로그램의 예제 코드이다.</li><li>ExpressionParser Interface를 구현하는 SpelExpressionParser로 SpEL 표현식의 내용을 파싱(Parsing) 할 수 있다.</li><li>exp.getValue() 메서드를 이용해 파싱된 결과값을 Object 타입으로 얻거나, Class정보를 파라미터로 추가해 자동으로 타입 캐스팅이 가능하다.</li></ul><h1 id="evaluationcontext-인터페이스를-이용한-표현식-파싱">EvaluationContext 인터페이스를 이용한 표현식 파싱</h1><ul><li>Property, Method, Field에 대한 파싱을 처리</li><li>타입변환을 수행하는 표현식을 평가 할 때 EvaluationContext 인터페이스를 사용</li><li>EvaluationContext의 구현체인 StandardEvaluationContext는 객체를 조작하기 위해 java reflection의 기능을 사용</li><li>성능을 향상 시키기 위해 java.lang.reflect의 Method, Field, Constructor를 캐싱한다.</li></ul><p>SpEL의 더 일반적인 사용법은 특정 객체 인스턴스(root객체)에 대해 평가되는 표현식 문자열을 제공하는 것이다.root객체를 제공하는 방식은 2가지 방식이 있다.</p><h2 id="root-객체를-똑같이-제공하는-경우">root 객체를 똑같이 제공하는 경우</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create and set a calendar</span></span><br><span class="line">GregorianCalendar c = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">c.set(<span class="number">1856</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// name, birthday, nationality를 파라미터로 갖는 생성자이다.</span></span><br><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">"Nikola Tesla"</span>, c.getTime(), <span class="string">"Serbian"</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">"name"</span>); <span class="comment">//tesla객체의 name 프로퍼티가 파싱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Context에 tesla객체를 넣어준다.</span></span><br><span class="line">EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);</span><br><span class="line">String name = (String) exp.getValue(context); <span class="comment">//name = "Nikola Tesla"</span></span><br></pre></td></tr></table></figure></p><ul><li>StandardEvaluationContext는 <code>name</code> 프로퍼티가 평가 될 객체를 지정하는 클래스이다.(위의 예제는 root객체, 즉 tesla 객체를 고정하여 사용하는 예제)</li><li>위의 SpelExpressionParser가 표현식을 평가 할 때, 표현식의 대한 기준을 Tesla 객체로 지정하는 부분이다.</li><li><code>parser.parseExpression(&quot;name&quot;);</code> 가 실행되면, tesla 객체의 name 프로퍼티가 파싱된다.</li><li>name변수에는 <code>Nikola Tesla</code> 문자열이 리턴된다.</li><li>타입 캐스팅 실패 시에는, <code>EvaluationException</code>이 throw된다.</li></ul><h2 id="root-객체가-계속-변경되는-경우">root 객체가 계속 변경되는 경우</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create and set a calendar</span></span><br><span class="line">GregorianCalendar c = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">c.set(<span class="number">1856</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// name, birthday, nationality를 파라미터로 갖는 생성자이다.</span></span><br><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">"Nikola Tesla"</span>, c.getTime(), <span class="string">"Serbian"</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">"name"</span>); <span class="comment">//tesla객체의 name 프로퍼티가 파싱</span></span><br><span class="line"></span><br><span class="line">String name = (String) exp.getValue(tesla);</span><br></pre></td></tr></table></figure></p><p>getValue 메서드 호출 시에, StandardEvaluationContext를 사용하지 않고 root 객체를 직접 지정해 준다.</p><h2 id="두-가지-방식의-차이">두 가지 방식의 차이</h2><ul><li>StandardEvaluationContext를 사용하는 경우 생성 비용이 상대적으로 많이 든다.</li><li>반복적으로 사용하는 동안 <code>Field에 대해 캐싱되고 있기 때문에 표현식 파싱이 더 빠르다</code>는 장점이 있다.</li><li>설정 파일에서 SpEL을 사용하는 경우에는, root 객체를 고정하고 SpEL 표현식만 개발자에게 설정 하도록 하는 것이 좋다.</li></ul><h1 id="bean을-정의하는-표현식">Bean을 정의하는 표현식</h1><ul><li>BeanDefinition을 정의하는 XML이나, Annotation 기반의 설정에는 MetaData와 SpEL표현식을 같이 사용할 수 있다.</li><li><code>#{&lt;expression&gt;}</code> 문법으로 사용한다.</li></ul><h2 id="xml-based">XML Based</h2><ul><li>프로퍼티나 생성자 Argument 값을 표현식으로 나타낼 수 있다.<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"numberGuess"</span> <span class="attr">class</span>=<span class="string">"org.spring.samples.NumberGuess"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"randomNumber"</span> <span class="attr">value</span>=<span class="string">"#&#123; T(java.lang.Math).random() * 100.0 &#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>systemProperties bean을 미리 지정하여 사용할 수 있다. (bean을 사용하였지만 <code>@</code> 문자를 안붙인 것을 주의)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"taxCalculator"</span> <span class="attr">class</span>=<span class="string">"org.spring.samples.TaxCalculator"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultLocale"</span> <span class="attr">value</span>=<span class="string">"#&#123; systemProperties['user.region'] &#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>아래 예제 처럼 다른 bean의 Properties를 사용할 수 있다.<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"numberGuess"</span> <span class="attr">class</span>=<span class="string">"org.spring.samples.NumberGuess"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"randomNumber"</span> <span class="attr">value</span>=<span class="string">"#&#123; T(java.lang.Math).random() * 100.0 &#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shapeGuess"</span> <span class="attr">class</span>=<span class="string">"org.spring.samples.ShapeGuess"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialShapeSeed"</span> <span class="attr">value</span>=<span class="string">"#&#123; numberGuess.randomNumber &#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="annotation-based">Annotation Based</h2><ul><li>기본값을 지정하기 위해 @Value Annotation을 이용해 Field, Method, Method-Parameter에 붙일 수 있다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldValueTestBean</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">  @Value("#&#123; systemProperties['user.region'] &#125;")</span><br><span class="line">  <span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultLocale</span><span class="params">(String defaultLocale)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDefaultLocale</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.defaultLocale;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValueTestBean</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">private</span> <span class="title">String</span> <span class="title">defaultLocale</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"#&#123; systemProperties['user.region'] &#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultLocale</span><span class="params">(String defaultLocale)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(MovieFinder movieFinder, </span></span></span><br><span class="line"><span class="function"><span class="params">                 @Value(<span class="string">"#&#123; systemProperties['user.region'] &#125;"</span>&#125; String defaultLocale)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">  <span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html</li><li>https://blog.outsider.ne.kr/835</li><li>https://blog.outsider.ne.kr/837</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/11/21/2018-11-21-spel-expression/#disqus_thread</comments>
    </item>
    
    <item>
      <title>EHCache 설정방법 (Spring Boot)</title>
      <link>https://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springboot/</link>
      <guid>https://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springboot/</guid>
      <pubDate>Wed, 07 Nov 2018 14:38:43 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;ehcache-설정하기&quot;&gt;EHCache 설정하기&lt;/h1&gt;
&lt;p&gt;설정 순서는 아래와 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Maven Dependency 설정&lt;/li&gt;
&lt;li&gt;Ehcache.xml 작성 (ehcache 설정파일)&lt;/li&gt;
&lt;li&gt;@
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="ehcache-설정하기">EHCache 설정하기</h1><p>설정 순서는 아래와 같다.</p><ol><li>Maven Dependency 설정</li><li>Ehcache.xml 작성 (ehcache 설정파일)</li><li>@EnableCaching 설정</li></ol><h1 id="maven-dependency-설정">Maven Dependency 설정</h1><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="ehcachexml-작성-ehcache-설정파일">Ehcache.xml 작성 (ehcache 설정파일)</h1><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"http://ehcache.org/ehcache.xsd"</span></span></span><br><span class="line">         maxBytesLocalHeap="300M" &lt;!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 --&gt;</span><br><span class="line">         updateCheck="false"&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 임시저장 경로를 설정 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"java.io.tmpdir"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,</span></span><br><span class="line"><span class="comment">        maxDepthExceededBehavior = "continue" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색</span></span><br><span class="line"><span class="comment">        maxDepthExceededBehavior = "abort" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sizeOfPolicy</span> <span class="attr">maxDepth</span>=<span class="string">"100000"</span> <span class="attr">maxDepthExceededBehavior</span>=<span class="string">"continue"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- default Cache 설정 (반드시 선언해야 하는 Cache) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">"1200"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 사용하고자 하는 캐시 별 설정 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"LocalCacheData"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">"1200"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"AuthMemberList"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">"1200"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)</li><li>cache는 하나의 캐시를 사용할 때마다 구현</li><li>name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.</li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>name</td><td>코드에서 사용할 캐시 name</td><td>필수</td></tr><tr><td>maxEntriesLocalHeap</td><td>메모리에 생성 될 최대 캐시 갯수</td><td>0</td></tr><tr><td>maxEntriesLocalDisk</td><td>디스크에 생성 될 최대 캐시 갯수</td><td>0</td></tr><tr><td>eternal</td><td>영속성 캐시 설정 (지워지는 캐시인지?) &lt;br /&gt;external = &quot;true&quot;이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨</td><td>false</td></tr><tr><td>timeToIdleSecond</td><td>해당 초동안 캐시가 호출 되지 않으면 삭제</td><td>0</td></tr><tr><td>timeToLiveSeconds</td><td>해당 초가 지나면 캐시가 삭제</td><td>0</td></tr><tr><td>overflowToDisk</td><td>오버플로우 된 항목에 대해 disk에 저장할 지 여부</td><td>false</td></tr><tr><td>diskPersistent</td><td>캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정</td><td>false</td></tr><tr><td>diskExpiryThreadIntervalSeconds</td><td>Disk Expiry 스레드의 작업 수행 간격 설정</td><td>0</td></tr><tr><td>memoryStoreEvictionPolicy</td><td>캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정&lt;br /&gt;LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제&lt;br /&gt;LFU : 호출 빈도가 가장 적은 캐시를 삭제&lt;br /&gt;FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제</td><td>LRU</td></tr></tbody></table><p>#@EnableCaching 설정</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span>(proxyTargetClass = <span class="keyword">true</span>, mode = AdviceMode.PROXY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EHCacheConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EhCacheManagerFactoryBean <span class="title">ehCacheManagerFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = <span class="keyword">new</span> EhCacheManagerFactoryBean();</span><br><span class="line">        ehCacheManagerFactoryBean.setConfigLocation(<span class="keyword">new</span> ClassPathResource(<span class="string">"config/ehcache.xml"</span>));</span><br><span class="line">        ehCacheManagerFactoryBean.setShared(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ehCacheManagerFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EhCacheCacheManager <span class="title">ehCacheCacheManager</span><span class="params">(EhCacheManagerFactoryBean ehCacheManagerFactoryBean)</span> </span>&#123;</span><br><span class="line">        EhCacheCacheManager ehCacheCacheManager = <span class="keyword">new</span> EhCacheCacheManager();</span><br><span class="line">        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());</span><br><span class="line">        <span class="keyword">return</span> ehCacheCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>@EnableCaching Annotation은 <code>&lt;cache:annotation-driven&gt;</code>와 마찬가지로 어노테이션 기반 캐시를 사용 할 수 있는 설정</li><li>내부적으로 Spring AOP를 통해 @Cacheable, @CacheEvict와 같은 어노테이션을 Pointcut으로 이용해서 Cache기능을 구현하는 듯 하다.</li><li>proxyTargetClass : class 기반 프록시를 생성함을 의미 (CGLIB라이브러리에 대한 의존성 필요)</li><li>Mode : 어떤 Advisor 모듈을 선택할지에 대한 설정<ul><li>PROXY : Spring AOP Proxy방식을 이용</li><li>ASPECTJ : LTW, CTW기능을 이용한 위빙</li></ul></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springboot/#disqus_thread</comments>
    </item>
    
    <item>
      <title>EHCache 설정방법 (Spring Framework)</title>
      <link>https://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springframework/</link>
      <guid>https://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springframework/</guid>
      <pubDate>Wed, 07 Nov 2018 14:38:22 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;ehcache-설정하기&quot;&gt;EHCache 설정하기&lt;/h1&gt;
&lt;p&gt;설정 순서는 아래와 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Maven Dependency 설정&lt;/li&gt;
&lt;li&gt;Ehcache.xml 작성 (ehcache 설정파일)&lt;/li&gt;
&lt;li&gt;C
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="ehcache-설정하기">EHCache 설정하기</h1><p>설정 순서는 아래와 같다.</p><ol><li>Maven Dependency 설정</li><li>Ehcache.xml 작성 (ehcache 설정파일)</li><li>CacheManager 설정 (xml)</li></ol><h1 id="maven-dependency-설정">Maven Dependency 설정</h1><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- EHCache 모듈 (블로그 작성 시점에서 2.10.6이 최신이다.) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Spring Caching Interface --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.20.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- EHCache Support 모듈, 다른 Caching 지원모듈 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.20.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="ehcachexml-작성">ehcache.xml 작성</h1><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"http://ehcache.org/ehcache.xsd"</span></span></span><br><span class="line">         maxBytesLocalHeap="300M" &lt;!-- CacheManager에 의해 관리되는 캐시의 메모리를 300M로 제한 --&gt;</span><br><span class="line">         updateCheck="false"&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 임시저장 경로를 설정 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"java.io.tmpdir"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,</span></span><br><span class="line"><span class="comment">        maxDepthExceededBehavior = "continue" :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색</span></span><br><span class="line"><span class="comment">        maxDepthExceededBehavior = "abort" : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sizeOfPolicy</span> <span class="attr">maxDepth</span>=<span class="string">"100000"</span> <span class="attr">maxDepthExceededBehavior</span>=<span class="string">"continue"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- default Cache 설정 (반드시 선언해야 하는 Cache) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">"1200"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 사용하고자 하는 캐시 별 설정 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"LocalCacheData"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">"1200"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"AuthMemberList"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">"1200"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)</li><li>cache는 하나의 캐시를 사용할 때마다 구현</li><li>name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.</li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>name</td><td>코드에서 사용할 캐시 name</td><td>필수</td></tr><tr><td>maxEntriesLocalHeap</td><td>메모리에 생성 될 최대 캐시 갯수</td><td>0</td></tr><tr><td>maxEntriesLocalDisk</td><td>디스크에 생성 될 최대 캐시 갯수</td><td>0</td></tr><tr><td>eternal</td><td>영속성 캐시 설정 (지워지는 캐시인지?) &lt;br /&gt;external = &quot;true&quot;이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨</td><td>false</td></tr><tr><td>timeToIdleSecond</td><td>해당 초동안 캐시가 호출 되지 않으면 삭제</td><td>0</td></tr><tr><td>timeToLiveSeconds</td><td>해당 초가 지나면 캐시가 삭제</td><td>0</td></tr><tr><td>overflowToDisk</td><td>오버플로우 된 항목에 대해 disk에 저장할 지 여부</td><td>false</td></tr><tr><td>diskPersistent</td><td>캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정</td><td>false</td></tr><tr><td>diskExpiryThreadIntervalSeconds</td><td>Disk Expiry 스레드의 작업 수행 간격 설정</td><td>0</td></tr><tr><td>memoryStoreEvictionPolicy</td><td>캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정&lt;br /&gt;LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제&lt;br /&gt;LFU : 호출 빈도가 가장 적은 캐시를 삭제&lt;br /&gt;FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제</td><td>LRU</td></tr></tbody></table><h1 id="cachemanager-bean-설정">CacheManager Bean 설정</h1><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">z<span class="comment">&lt;!-- Annotation 기반 캐시 사용 (@Cacheable, @CacheEvict..) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- EHCache 기반 CacheManager 설정 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheCacheManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"ehcache"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ehcache.xml 설정 로드 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ehcache"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheManagerFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:config/ehcache.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"shared"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>https://github.com/skoh/common/blob/master/common-web/src/main/resources/ehcache.xml</li><li>https://www.mkyong.com/spring/spring-caching-and-ehcache-example/</li><li>http://hyeooona825.tistory.com/86</li><li>http://blog.naver.com/PostView.nhn?blogId=kyung778&amp;logNo=60164009610</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springframework/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Cache에 대하여.. (Spring+EHCache)</title>
      <link>https://jaehun2841.github.io/2018/11/07/2018-10-03-spring-ehcache/</link>
      <guid>https://jaehun2841.github.io/2018/11/07/2018-10-03-spring-ehcache/</guid>
      <pubDate>Wed, 07 Nov 2018 14:33:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;들어가며&quot;&gt;들어가며..&lt;/h1&gt;
&lt;p&gt;엔터프라이즈 급 Application에서는 DBMS의 부하를 줄이고, 성능을 높이기 위해 캐시(Cache)를 사용한다. 우리 회사에서도 EHCache, Redis를 사용하지만, EHCache쪽은 공부
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="들어가며">들어가며..</h1><p>엔터프라이즈 급 Application에서는 DBMS의 부하를 줄이고, 성능을 높이기 위해 캐시(Cache)를 사용한다. 우리 회사에서도 EHCache, Redis를 사용하지만, EHCache쪽은 공부한 적이 없어서 이번 기회에 정리하면서 공부해 보게 되었다.대부분 <code>docs.spring.io</code>의 문서를 번역한 내용을 위주로 정리 하였다.</p><h1 id="cache란">Cache란?</h1><p>Cache의 사전적인 의미를 알아보기 위해 위키백과를 검색해 보았다.</p><blockquote><p><strong>캐시</strong>(cache, <a href="https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4" target="_blank" rel="noopener">문화어</a>: 캐쉬, 고속완충기, 고속완충기억기)는 <a href="https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99" target="_blank" rel="noopener">컴퓨터 과학</a>에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 캐시는 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.</p><p>캐시는 시스템의 효율성을 위해 여러 분야에서 두루 쓰인다.</p></blockquote><p>결국 캐시란, 반복적으로 데이터를 불러올 때 지속적으로 DBMS 혹은 서버에 요청하는 것이 아닌 메모리에 데이터를 저장하였다가 데이터를 불러다가 쓰는 것을 의미한다. 따라서 서버나 DBMS에 부담을 덜어주고, 엄청 빠르기 때문에 많은 시스템에서 사용하고 있다.대표적으로 Browser Cache, Apacha Cache, DNS Cache등 여러가지 형태로 캐시가 사용되고 있다.</p><p>EHCache 사이트에서는 캐시에 대한 용어를 이렇게 정리 하였다.</p><ul><li><strong>Cache</strong> : 캐시는 <code>미래에 필요할 것이고 빠르게 검색할 수 있는 데이터를 담은 저장소</code> 라고 정의 한다. 캐시는 다른 곳에 있는 데이터를 복제하거나, 계산 결과를 임시적으로 저장하는 데이터 저장소이다. 캐시에 있는 데이터는 시간과 자원 면에서 최소한의 비용으로 반복적으로 접근 할 수 있다.</li><li><strong>Cache Hit</strong> : 데이터 요소가 캐시에 요청되고 해당 키에 대한 요소가 존재하면 Cache Hit (또는 단순히 'Hit')라고 한다.</li><li><strong>Cache Miss</strong>:데이터 요소가 캐시에 요청되고 해당 키에 대해 요소가 존재하지 않으면 Cache Miss (또는 단순히 'Miss')라고 한다.</li><li><strong>System-of-record</strong> : 데이터에 대한 신뢰할 수있는 정보원. 이것을 흔히 시스템 레코드(SOR)이라고 한다. 캐시는 시스템 레코드에서 검색되거나 시스템 레코드에 저장된 데이터의 로컬 사본으로 작동된다. Ehcache를 사용하기 위해 SOR은 데이터베이스로 간주된다.</li></ul><h1 id="long-tail-법칙">Long Tail 법칙</h1><p><img src="./17110B4350CC5EC51D.jpeg" alt="Long Tail"></p><p>20%의 요구가 시스템 리소스의 대부분을 잡아먹는다는 법칙.자주 사용되는 <code>20%의 기능에 캐시를 이용</code>하면 리소스 사용량을 대폭 줄일 수 있어, <code>시스템의 성능을 대폭 향상</code> 시킬 수 있다.</p><h1 id="local-cache-vs-global-cache">Local Cache vs Global Cache</h1><ul><li><p>Local Cache</p><ul><li>Local 장비 내에서만 사용 되는 캐시</li><li>Local 장비의 Resource를 이용한다 (Memory, Disk)</li><li>Local에서 작동 되기 때문에 속도가 빠르다.</li><li>Local에서만 작동되기 때문에 다른 서버와 데이터 공유가 어렵다</li></ul></li><li><p>Global Cache</p><ul><li>여러 서버에서 Cache Server에 접근하여 사용하는 캐시</li><li>데이터를 분산하여 저장 할 수 있다.<ul><li>Replication - 데이터를 복제</li><li>Sharding - 데이터를 분산하여 저장</li></ul></li><li>Local Cache에 비해 상대적으로 느리다 (네트워크 트래픽)</li><li>별도의 Cache Server를 이용하기 때문에 서버 간 데이터 공유가 쉽다.</li></ul></li></ul><h1 id="spring-cache-abstraction">Spring Cache Abstraction</h1><p>Spring 3.1버전부터 Spring Application에 캐시를 쉽게 추가할 수 있도록 기능을 제공하게 되었다. 유사 트랜잭션을 지원하고, 사용하고 있는 코드(메소드)에 영향을 최소화 하면서 일관된 방법으로 캐시를 사용 할 수 있게 되었다.</p><p>Spring에서 캐시 추상화는 메소드를 통해 기능을 지원하는데, 메소드가 실행되는 시점에 파라미터에 대한 캐시 존재 여부를 판단하여 없으면 캐시를 등록하게 되고, 캐시가 있으면 메소드를 실행 시키지 않고 캐시 데이터를 Return 해주게 된다.</p><p>Spring 캐시 추상화를 지원하기 때문에 개발자는 별도의 캐시 로직을 작성하지 않아도 된다. 하지만 캐시를 저장하는 저장소는 직접 설정을 해주어야 한다. Spring에서는 <code>CacheManager</code>라는 Interface를 제공하여 캐시를 구현하도록 하고 있다.</p><p>&lt;br/&gt;</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Spring Boot에서는 <code>spring-boot-starter-cache</code> Artifact를 추가 하여 CacheManager를 구성 할 수 있다.기본적으로 별도의 추가적인 서드파티 모듈이 없는 경우에는 Local Memory에 저장이 가능한 ConcurrentMap기반인 <code>ConcurrentMapCacheManager</code>가 Bean으로 자동 생성 된다.</p><p>이외에도 EHCache, Redis등의 서드파티 모듈을 추가 하게 되면 <code>EHCacheCacheManager</code>, <code>RedisCacheManager</code>를 Bean으로 등록 하여 사용할 수 있다. 이렇게 되면 별도로 다른 설정 없이도  단순 Memory Cache가 아닌 Cache Server를 대상으로 캐시를 저장 할 수 있도록 지원하고 있다.</p><h1 id="spring-cache-annotation">Spring Cache Annotation</h1><p>Spring에서는 Cache Annotation을 지원하여 좀 더 쉽게 메서드에 대한 캐시를 제어할 수 있다.</p><ul><li>@EnableCaching<ul><li>Annotation 기반 캐싱 설정을 사용 (내부적으로 Spring AOP 이용)</li></ul></li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>proxyTargetClass</td><td>클래스 기반의 Proxy생성 여부&lt;br /&gt;false인 경우 JDK Dynamic Proxy 사용 (Interface 기반)&lt;br /&gt;true인 경우 CGLIB Proxy 사용 (Class 기반)</td><td>false</td></tr><tr><td>mode</td><td>위빙 (Weaving) 모드에 대한 설정&lt;br /&gt;PROXY : 기존의 Spring AOP 방식을 이용한 RTW방식 사용&lt;br /&gt;ASPECTJ : aspectj 라이브러리를 이용한 CTW, LTW 방식 지원</td><td>PROXY</td></tr><tr><td>order</td><td>AOP order 설정</td><td>Integer.MAX_VALUE</td></tr></tbody></table><ul><li>@Cacheable<ul><li>캐싱할 수 있는 메서드를 지정하기 위해 사용</li></ul></li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>value, cacheName</td><td>캐시 명</td><td>{}</td></tr><tr><td>key</td><td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td><td>&quot;&quot;</td></tr><tr><td>keyGenerator</td><td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용&lt;br /&gt;4.0이후 버전 부터 SimpleKeyGenerator를 사용&lt;br /&gt;Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td><td>&quot;&quot;</td></tr><tr><td>cacheManager</td><td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td><td>&quot;&quot;</td></tr><tr><td>cacheResolver</td><td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)&lt;br /&gt;CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td><td>&quot;&quot;</td></tr><tr><td>condition</td><td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용&lt;br /&gt;and, or 표현식등을 통해 복수 조건 사용가능&lt;br /&gt;연산 조건이 <code>true</code>인 경우에만 캐싱</td><td>&quot;&quot;</td></tr><tr><td>unless</td><td>캐싱이 이루어지지 않는 조건을 설정&lt;br /&gt;연산 조건이 <code>true</code> 이면 경우에는 캐싱되지 않는다&lt;br /&gt;예시 : id가 null아 아닌 경우에만 캐싱 (unless = &quot;#id == null&quot;)</td><td>&quot;&quot;</td></tr><tr><td>sync</td><td>캐시 구현체가 Thread safe 하지 않는 경우, 자체적으로 캐시에 동기화를 거는 속성</td><td>false</td></tr></tbody></table><ul><li>@CacheEvict<ul><li>메서드 실행 시, 해당 캐시를 삭제</li></ul></li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>value, cacheName</td><td>캐시 명</td><td>{}</td></tr><tr><td>key</td><td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td><td>&quot;&quot;</td></tr><tr><td>keyGenerator</td><td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용&lt;br /&gt;4.0이후 버전 부터 SimpleKeyGenerator를 사용&lt;br /&gt;Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td><td>&quot;&quot;</td></tr><tr><td>cacheManager</td><td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td><td>&quot;&quot;</td></tr><tr><td>cacheResolver</td><td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)&lt;br /&gt;CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td><td>&quot;&quot;</td></tr><tr><td>condition</td><td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용&lt;br /&gt;and, or 표현식등을 통해 복수 조건 사용가능&lt;br /&gt;연산 조건이 <code>true</code>인 경우에만 캐시 삭제</td><td>&quot;&quot;</td></tr><tr><td>allEntries</td><td>Cache Key에 대한 전체 데이터 삭제 여부</td><td>false</td></tr><tr><td>beforeInvocation</td><td>true면 메서드 실행 이전에 캐시 삭제, false면 메서드 실행 이후 삭제</td><td>false</td></tr></tbody></table><ul><li>@CachePut<ul><li>메서드 실행에 영향을 주지 않고 캐시를 갱신해야 하는 경우 사용</li><li>보통은 @Cacheable과 @CachePut Annotation을 같이 사용하지 않는다.(둘은 다른 동작을 하기 때문에, 실행순서에 따라 다른 결과가 나올 수 있다.)</li><li>@CachePut Annotation은 캐시 생성용으로만 사용한다.</li></ul></li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>value, cacheName</td><td>캐시 명</td><td>{}</td></tr><tr><td>key</td><td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td><td>&quot;&quot;</td></tr><tr><td>keyGenerator</td><td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용&lt;br /&gt;4.0이후 버전 부터 SimpleKeyGenerator를 사용&lt;br /&gt;Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td><td>&quot;&quot;</td></tr><tr><td>cacheManager</td><td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td><td>&quot;&quot;</td></tr><tr><td>cacheResolver</td><td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)&lt;br /&gt;CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td><td>&quot;&quot;</td></tr><tr><td>condition</td><td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용&lt;br /&gt;and, or 표현식등을 통해 복수 조건 사용가능&lt;br /&gt;연산 조건이 <code>true</code>인 경우에만 캐싱</td><td>&quot;&quot;</td></tr><tr><td>unless</td><td>캐싱이 이루어지지 않는 조건을 설정&lt;br /&gt;연산 조건이 <code>true</code> 이면 경우에는 캐싱되지 않는다&lt;br /&gt;예시 : id가 null아 아닌 경우에만 캐싱 (unless = &quot;#id == null&quot;)</td><td>&quot;&quot;</td></tr></tbody></table><ul><li>@Caching<ul><li>@CacheEvict이나 @CachePut을 여러개 지정해야 하는 경우에 사용</li><li>조건식이나 표현식이 다른 경우에 사용한다.</li><li>여러가지의 key에 대한 캐시를 중첩적으로 삭제해야 할 때 사용</li></ul></li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>cacheable[]</td><td>@Cacheable 적용할 Annotation을 등록한다.</td><td>{}</td></tr><tr><td>put[]</td><td>@CachePut 적용할 Annotation을 등록한다.</td><td>{}</td></tr><tr><td>evict[]</td><td>@CacheEvic 적용할 Annotation을 등록한다.</td><td>{}</td></tr></tbody></table><ul><li>@CacheConfig<ul><li>클래스 단위로 캐시설정을 동일하게 하는데 사용</li><li>이 설정은 CacheManager가 여러개인 경우에만 사용</li><li>Member조회 클래스에서는 Redis기반 캐시를 사용하고Product 조회 클래스에서는 EHCache 기반 캐시를 사용할 때각 클래스 별로 CacheManager를 지정 가능</li></ul></li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>cacheNames</td><td>캐시 명</td><td>{}</td></tr><tr><td>keyGenerator</td><td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용&lt;br /&gt;4.0이후 버전 부터 SimpleKeyGenerator를 사용&lt;br /&gt;Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td><td>&quot;&quot;</td></tr><tr><td>cacheManager</td><td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td><td>&quot;&quot;</td></tr><tr><td>cacheResolver</td><td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)&lt;br /&gt;CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td><td>&quot;&quot;</td></tr></tbody></table><h1 id="ehcache">EHCache</h1><p><img src="./EHCACHE.png" alt="EHCACHE"></p><ul><li>EHCache는 오픈 소스 기반의 Local Cache이다.</li><li>속도가 빠르며 경량 Cache라는 장점이 있다.</li><li>Disk, Memory 저장이 가능한 형태</li><li>서버 간 분산 캐시를 지원한다 (동기/비동기 복제)</li><li>JSR107 JCache 표준을 지원한다.따라서 JCache에서 제공하는 Annotation을 통해 이미 작성된 코드에 간단하게 기능 추가가 쉽다.</li></ul><blockquote><p><strong>JSR-107</strong> : (JCACHE – Java Temporary Caching API) 객체 생성, 공유 액세스, 스풀링, 무효화 및 JVM 전반에 걸친 일관성을 포함하여 Java 객체의 메모리 캐싱에서 사용할 API 에 대한 기준으로 볼 수 있다.    해당 Spec 으로 구현된 cache로는 EhCache가 유명하며, Hazelcast, Infinispan, Couchbase, Redis, Caffeine 등도 해당 기준을 따르는 것으로 알려져 있다.</p></blockquote><h1 id="ehcache-설정-방법">EHCache 설정 방법</h1><p>내용이 길어 질 것 같아 별도의 포스트로 작성</p><ul><li><a href="http://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springframework/">EHCache 설정방법 (Spring Framework)</a></li><li><a href="http:/jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springboot/" target="_blank" rel="noopener">EHCache 설정방법 (Spring Boot)</a></li></ul><h1 id="ehcache-예시-코드">EHCache 예시 코드</h1><p>테스트 시나리오</p><ol><li>가상으로 DBMS에서 데이터를 조회 하는 Repository를 생성</li><li>3초 정도 슬로우쿼리가 실행된다고 가정</li><li>최초 1회는 DB에서 조회, 2회차 부턴 캐시 사용</li><li>캐시를 조회했을 때, 걸리는 시간 확인</li><li>캐시가 만료되었을때, 걸리는 시간 확인</li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EHCacheController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EHCacheRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/data/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String data = repository.getData(id);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"쿼리 수행 시간 : &#123;&#125;ms"</span>, end-start);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/data/delete/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getExpireCache</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</span><br><span class="line">        repository.evictCache(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EHCacheRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span>(cacheNames = <span class="string">"testData"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test-data"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict</span>(cacheNames = <span class="string">"testData"</span>, allEntries = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictCache</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"delete cache all"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span>(proxyTargetClass = <span class="keyword">true</span>, mode = AdviceMode.PROXY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EHCacheConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EhCacheManagerFactoryBean <span class="title">ehCacheManagerFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EhCacheManagerFactoryBean ehCacheManagerFactoryBean = <span class="keyword">new</span> EhCacheManagerFactoryBean();</span><br><span class="line">        ehCacheManagerFactoryBean.setConfigLocation(<span class="keyword">new</span> ClassPathResource(<span class="string">"config/ehcache.xml"</span>));</span><br><span class="line">        ehCacheManagerFactoryBean.setShared(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ehCacheManagerFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EhCacheCacheManager <span class="title">ehCacheCacheManager</span><span class="params">(EhCacheManagerFactoryBean ehCacheManagerFactoryBean)</span> </span>&#123;</span><br><span class="line">        EhCacheCacheManager ehCacheCacheManager = <span class="keyword">new</span> EhCacheCacheManager();</span><br><span class="line">        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());</span><br><span class="line">        <span class="keyword">return</span> ehCacheCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"http://ehcache.org/ehcache.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxBytesLocalHeap</span>=<span class="string">"300M"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">updateCheck</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"java.io.tmpdir"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sizeOfPolicy</span> <span class="attr">maxDepth</span>=<span class="string">"100000"</span> <span class="attr">maxDepthExceededBehavior</span>=<span class="string">"continue"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">"1200"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"LocalCacheData"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">"1200"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"testData"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>&lt;br/&gt;</p><p>결과</p><p><img src="./ehcache-test.png" alt="ehcache-test"></p><ol><li>최초로 <code>GET localhost:8080/data/1</code> 요청 시, 3초 이상의 슬로우 쿼리가 실행</li><li>두번째로 동일하게 <code>GET localhost:8080/data/1</code> 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)</li><li><code>GET localhost:8080/data/delete/1</code> 요청으로 캐시 삭제</li><li><code>GET localhost:8080/data/1</code> 요청 시, 3초 이상의 슬로우 쿼리가 실행 (캐시 삭제 후 요청)</li><li><code>GET localhost:8080/data/1</code> 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)</li></ol><blockquote><p>주의 할 점!</p><p>EHCache는 ehcache.xml 또는 Java 코드에서 addCache를 이용하여 반드시 Cache Key를 등록해 줘야 함이거를 안 등록하고 Cache Key를 막쓰다가.. 계속 Cache Key가 없다는 오류가 발생하여 잠깐 삽질..</p></blockquote><h1 id="참고">참고</h1><ul><li>http://www.ehcache.org/documentation/2.8/integrations/spring.html#introduction</li><li>https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache</li><li>http://blog.breakingthat.com/2018/03/19/springboot-ehcache-%EC%A0%81%EC%9A%A9/</li><li>https://jojoldu.tistory.com/57</li><li>http://www.ehcache.org/documentation/2.8/configuration/index.html</li><li>https://www.slideshare.net/heungrae_kim/spring-31-ehcache</li><li>https://shortstories.gitbooks.io/studybook/content/cache.html</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/11/07/2018-10-03-spring-ehcache/#disqus_thread</comments>
    </item>
    
    <item>
      <title>@Import와 @ImportResource Annotation</title>
      <link>https://jaehun2841.github.io/2018/10/21/2018-10-21-java-config-import/</link>
      <guid>https://jaehun2841.github.io/2018/10/21/2018-10-21-java-config-import/</guid>
      <pubDate>Sun, 21 Oct 2018 09:53:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;들어가며&quot;&gt;들어가며&lt;/h1&gt;
&lt;p&gt;회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.
아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고
최근에 일부 xml Config를 Ja
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="들어가며">들어가며</h1><p>회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.</p><h1 id="import">@Import</h1><p>@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.사용하는 개념은 기존에 xml 파일을 import하는.. &lt;import /&gt; 구분과 동일하게 사용된다.</p><p>예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면..</p><p><strong>RedisClusterConfig</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(value = RedisShardsConfig.class) <span class="comment">// Redis Shard정보에 대한 Config이다.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClusterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"redisConfig"</span>)</span><br><span class="line"><span class="keyword">private</span> Properties redisConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GenericObjectPoolConfig <span class="title">jedisPoolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    poolConfig.setMaxTotal(redisConfig.getProperty(<span class="string">"redis.cluster.connectionCount"</span>));</span><br><span class="line">poolConfig.setMaxIdle(commonConfig.getProperty(<span class="string">"redis.cluster.connectionCount"</span>));</span><br><span class="line">poolConfig.setMinIdle(commonConfig.getProperty(<span class="string">"redis.cluster.connectionCount"</span>));</span><br><span class="line">poolConfig.setNumTestsPerEvictionRun(<span class="number">2</span>);</span><br><span class="line">poolConfig.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">poolConfig.setTestOnReturn(<span class="keyword">false</span>);</span><br><span class="line">poolConfig.setTestWhileIdle(<span class="keyword">true</span>);</span><br><span class="line">poolConfig.setTimeBetweenEvictionRunsMillis(<span class="number">300000</span>);</span><br><span class="line"><span class="keyword">return</span> poolConfig;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShardedJedisPool <span class="title">masterShardedPool</span><span class="params">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisMasterShards)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ShardedJedisPool(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShardedJedisPool <span class="title">slaveShardedPool</span><span class="params">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisSlaveShards)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ShardedJedisPool(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>RedisShardsConfig.java</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisShardsConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"redisConfig"</span>)</span><br><span class="line"><span class="keyword">private</span> Properties redisConfig;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;JedisShardInfo&gt; <span class="title">redisMasterShards</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String url = redisConfig.getProperty(<span class="string">"redis.cluster.url"</span>);</span><br><span class="line">        <span class="comment">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class="line">        Integer masterPort1 = redisConfig.getProperty(<span class="string">"redis.cluster.master.port1"</span>);</span><br><span class="line">        Integer masterPort2 = redisConfig.getProperty(<span class="string">"redis.cluster.master.port2"</span>);</span><br><span class="line">        Integer masterPort3 = redisConfig.getProperty(<span class="string">"redis.cluster.master.port3"</span>);</span><br><span class="line">        </span><br><span class="line">        String masterShardKey1 = redisConfig.getProperty(<span class="string">"redis.cluster.master.key1"</span>);</span><br><span class="line">        String masterShardKey2 = redisConfig.getProperty(<span class="string">"redis.cluster.master.key2"</span>);</span><br><span class="line">        String masterShardKey3 = redisConfig.getProperty(<span class="string">"redis.cluster.master.key3"</span>);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class="line">&#123;</span><br><span class="line">add(<span class="keyword">new</span> JedisShardInfo(url, masterPort1, masterShardKey1));</span><br><span class="line">add(<span class="keyword">new</span> JedisShardInfo(url, masterPort2, masterShardKey2));</span><br><span class="line">add(<span class="keyword">new</span> JedisShardInfo(url, masterPort3, masterShardKey3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;JedisShardInfo&gt; <span class="title">redisSlaveShards</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String url = redisConfig.getProperty(<span class="string">"redis.cluster.url"</span>);</span><br><span class="line">        <span class="comment">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class="line">        Integer slavePort1 = redisConfig.getProperty(<span class="string">"redis.cluster.slave.port1"</span>);</span><br><span class="line">        Integer slavePort2 = redisConfig.getProperty(<span class="string">"redis.cluster.slave.port2"</span>);</span><br><span class="line">        Integer slavePort3 = redisConfig.getProperty(<span class="string">"redis.cluster.slave.port3"</span>);</span><br><span class="line">        </span><br><span class="line">        String slaveShardKey1 = redisConfig.getProperty(<span class="string">"redis.cluster.slave.key1"</span>);</span><br><span class="line">        String slaveShardKey2 = redisConfig.getProperty(<span class="string">"redis.cluster.slave.key2"</span>);</span><br><span class="line">        String slaveShardKey3 = redisConfig.getProperty(<span class="string">"redis.cluster.slave.key3"</span>);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;JedisShardInfo&gt;() &#123;</span><br><span class="line">&#123;</span><br><span class="line">add(<span class="keyword">new</span> JedisShardInfo(url, slavePort1, slaveShardKey1));</span><br><span class="line">add(<span class="keyword">new</span> JedisShardInfo(url, slavePort2, slaveShardKey2));</span><br><span class="line">add(<span class="keyword">new</span> JedisShardInfo(url, slavePort3, slaveShardKey3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>RedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.RedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다.이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.xml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.</p><h1 id="importresource">@ImportResource</h1><p>모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들...)</p><p>그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.</p><p>예시는 아래와 같다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(value = &#123;</span><br><span class="line"><span class="string">"classpath:applicationContextForExternalMember.xml"</span>,    <span class="comment">//External-Member</span></span><br><span class="line"><span class="string">"classpath*:applicationContextForExternalAPI.xml"</span>,      <span class="comment">//External-API</span></span><br><span class="line"><span class="string">"classpath*:applicationContextForExternalLogger.xml"</span>    <span class="comment">//External-Logger</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.</p>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/10/21/2018-10-21-java-config-import/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Application-Context와 Servlet-Context</title>
      <link>https://jaehun2841.github.io/2018/10/21/2018-10-21-spring-context/</link>
      <guid>https://jaehun2841.github.io/2018/10/21/2018-10-21-spring-context/</guid>
      <pubDate>Sun, 21 Oct 2018 08:00:54 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;들어가며&quot;&gt;들어가며&lt;/h1&gt;
&lt;p&gt;회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.
문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.
core가 되는 프로젝트
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="들어가며">들어가며</h1><p>회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.core가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.Bean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.</p><p>이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.</p><h1 id="web-application-context">Web Application Context</h1><p><img src="./99A34C3359FEAA8410.png" alt="img"></p><h2 id="application-context">Application Context</h2><ul><li>Web Application 최상단에 위치하고 있는 Context</li><li>Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context</li><li>Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한설정정보를 담은 파일 (Bean 선언 등..)</li><li>Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)</li><li>특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)</li><li>서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.</li><li><strong>Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.</strong></li></ul><h2 id="servlet-context-servlet-contextxml">Servlet-Context (servlet-context.xml)</h2><ul><li>Servlet 단위로 생성되는 context</li><li>Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일(Interceptor, Bean생성, ViewResolver등..)</li><li>URL설정이 있는 Bean을 생성 (@Controller, Interceptor)</li><li>Application Context를 자신의 부모 Context로 사용한다.</li><li>Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,Servlet Context에 선언된 Bean을 사용한다.</li><li>Bean 찾는 순서<ul><li>Servlet Context에서 먼저 찾는다.</li><li>만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.</li></ul></li><li><strong>Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.</strong></li></ul><h1 id="webxml-설정-살펴보기">web.xml 설정 살펴보기</h1><h2 id="webxml-이란">web.xml 이란</h2><p>서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.여기서 서블릿 클래스를 등록하는 곳의 이름을 <code>Web application deployment descriptor</code>라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 <code>web.xml</code>이다. <code>web.xml</code> 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.</p><p>DD는 WAS 구동 시 <code>/WEB-INF</code> 디렉토리에 존재하는 <code>web.xml</code>을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">"2.5"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">              org.springframework.web.context.ContextLoaderListener</span><br><span class="line">          <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">&lt;!-- Processes application requests --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">              <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 --&gt;</span></span><br><span class="line">                  /WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class="line">              <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">&lt;!-- dispatcherServlet 대한 url-pattern을 정의 </span></span><br><span class="line"><span class="comment">        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="그래서-context-설정은-어떻게-쓰냐">그래서 Context 설정은 어떻게 쓰냐?</h1><p>Spring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.</p><ul><li>Application Context<ul><li>공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등..)</li><li>각 Servlet에서 공유할 수 있는 Bean</li></ul></li><li>Servlet Context<ul><li>Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등..)</li></ul></li></ul><p>가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.</p><p>ApplicationContext.xml</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.myapp.core, com.myapp.app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Component-scan대상에서 @Controller annotation Class는 제외한다. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Servlet-Context.xml</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.myapp.app"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Component-scan대상은 @Controller annotation Class만 scan한다. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Servlet-Context.xml 설정 시, <code>use-default-filters</code> 속성을 <code>false</code>로 처리 하였다.<code>use-default-filters</code> 속성은 원래 <code>default가 true</code>인데,@Compont Annotation(@Controller, @Service, @Repository등..) 의 <code>클래스를 자동으로 Bean으로 등록해 주는 filter속성</code>이다.따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.</p><h1 id="참조">참조</h1><ul><li>http://hoonmaro.tistory.com/31</li><li>https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/10/21/2018-10-21-spring-context/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
