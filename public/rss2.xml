<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Carrey`s 기술블로그</title>
    <link>https://jaehun2841.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 06 Jun 2020 19:05:09 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Objects Study - Chapter8. 의존성 관리하기</title>
      <link>https://jaehun2841.github.io/2020/06/06/object-chapter8/</link>
      <guid>https://jaehun2841.github.io/2020/06/06/object-chapter8/</guid>
      <pubDate>Sat, 06 Jun 2020 07:10:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;잘 설계된 객체지향 어플리케이션은 작고 응집도 높은 객체들로 구성된다.&lt;br&gt;
작고 응집성 높은 객체란 책임의 초점이 명확하고 한 가지 일만 잘하는 객체를 의미한다.&lt;br&gt;
따라서 객체 간 협력을 통해 다른 객
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>잘 설계된 객체지향 어플리케이션은 작고 응집도 높은 객체들로 구성된다.<br>작고 응집성 높은 객체란 책임의 초점이 명확하고 한 가지 일만 잘하는 객체를 의미한다.<br>따라서 객체 간 협력을 통해 다른 객체에게 도움을 요청하여 여러가지 일을 수행할 수 있다.<br><strong>협력은 객체가 다른 객체에 대해 알 것을 강요한다</strong><br><strong>다른 객체와 협력하기 위해서는 그런 객체 또는 클래스가 있다는 사실을 알고 있어야 한다.</strong><br><strong>객체가 수신할 수 있는 메세지에 대해서도 알고 있어야 한다.</strong></p><p>이런 지식들이 객체 사이의 의존성을 낳는다.</p><h1 id="의존성이란">의존성이란</h1><p><strong>의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성</strong>을 의미한다.<br>어떤 객체가 협력하기 위해 다른 객체로 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다.<br>나아가 두 객체 사이 뿐만 아니라 모듈이나 더 큰 규모의 실행 시스템일 수도 있다. (ex. API 의존성)<br>의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.</p><ul><li>실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.</li><li>구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.</li></ul><h2 id="의존성은-방향성을-가진다">의존성은 방향성을 가진다.</h2><p>의존성은 방향성을 가지며 항상 단방향이다. (그 역은 성립하지 않는다.)<br>예를들어 PerioidCondition class에서 Screening class를 인자로 받는 경우</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Screening screening)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> screenging.startTime() ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>PeriodCondition 클래스는 Screening 클래스에 의존한다</code> 라고 표현한다.</p><p><img src="./dependency.jpg" alt="의존성표현"></p><h2 id="의존성은-변경에-취약하다">의존성은 변경에 취약하다</h2><p>설계과 관련된 대부분의 용어들이 변경과 관련이 있다.<br>의존성 역시 변경과 관련이 있다.<br>두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다.<br>따라서 의존성은 변경에 의한 영향의 전파가능성을 암시한다.</p><h1 id="의존성-전이">의존성 전이</h1><p><img src="./dependency-transfer.jpg" alt="dependency-transfer"></p><p>PeriodCondition 클래스가 Screening 클래스에 의존하고,  Screening 클래스가 Movie 클래스에 의존하는 경우 의존성이 전이될 수 있다.</p><p>의존성이란 함께 변경될 수 있는 <strong>가능성</strong> 을 의미하기 때문에 모든 경우에 의존성이 전이되는 것은 아니다.<br>의존성이 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다.</p><p>단, 의존성 전이는 변경에 의해 영향이 전파될 수도 있다는 일종의 경고이다.</p><h2 id="직접-의존성과-간접-의존성">직접 의존성과 간접 의존성</h2><ul><li>직접 의존성: 말 그대로 한 요소가 다른 요소에 직접 의존하는 경우를 가르킨다.</li><li>위의 예제에서 PeriodCondition은 Screening에 직접 의존한다.</li><li>이 경우 의존성은 코드에 명시적으로 드러난다. (PeriodCondition 내부 코드에서 Screening을 참조하는 코드가 존재한다)</li><li>간접 의존성: 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 가리킨다.<ul><li>위의 예제에서 Movie 클래스 변경으로 인해 PeriodCondition까지 변경의 영향이 있을 수도 있음을 의미한다.</li><li>이 경우 의존성은 명시적으로 드러나지 않는다. (PeriodCondition 내부 코드에서 Movie에 대한 참조는 없다)</li></ul></li></ul><h1 id="runtime-의존성과-compile-time-의존성">Runtime 의존성과 Compile time 의존성</h1><h2 id="runtime-의존성">Runtime 의존성</h2><ul><li>어플리케이션이 실행되는 시점에 갖는 의존성을 의미</li><li>런타임에 실제 생성되는 객체 간의 의존성을 가리킨다.</li></ul><p><img src="./runtime-dependency.jpg" alt="runtime-dependency"></p><p>Movie라는 클래스와 AmountDiscountPolicy, PercentDiscountPolicy는 런타임에 직접적인 의존성을 갖는다.</p><h2 id="compile-time-의존성">Compile time 의존성</h2><ul><li>작성된 코드를 컴파일 하는 시점을 의미 (또는 문맥에 따라서는 코드 그 차제를 가리키기도 한다.)</li><li>동적 타입 언어의 경우에는 컴파일 타입이 존재하지 않기 때문에 컴파일이 수행되는 시점으로만 생각하면 의미가 모호해진다.</li><li>컴파일 타임에서는 코드에 대한 의존성을 가리킨다.</li><li>코드 관점에서는 Class 간의 의존성을 가리킨다.</li></ul><p><img src="./compiletime-dependency.jpg" alt="compiletime-dependency"></p><p>Movie라는 클래스는 DiscountPolicy라는 클래스는 컴파일타임 의존성을 갖는다.<br>실제 Movie 클래스와 AmountDiscountPolicy, PercentDiscountPolicy는 코드 관점에서의 의존성은 존재하지 않는다.</p><h1 id="유연하고-재사용-가능한-설계">유연하고 재사용 가능한 설계</h1><p>유연하고 재사용 가능한 설계를 하기 위해서는 동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 한다.<br>어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안된다.<br>실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다.<br>만약 클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 읺스턴스와 협력할 가능성 자체가 없어지게 된다.<br>따라서 <strong>컴파일 타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연하고 재사용 가능해 진다.</strong></p><blockquote><p>객체지향 프로그램의 실행 구조는 소스코드 구조와 일치하지 않는 경우가 종종 있다.<br>코드 구조는 컴파일 시점에 확정되는 것이고 이 구조에는 고정된 상속 클래스 관계들이 포함된다.<br>하지만 프로그램 실행 시점 구조는 협력하는 객체에 따라 달라질 수 있다.</p></blockquote><h2 id="컨텍스트-독립성">컨텍스트 독립성</h2><p>유연하고 확장 가능한 설계를 만들기 위해서는 compile time 의존성과 runtime 의존성이 달라야 한다.<br>클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안 된다.<br>구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문이다.</p><p>클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다.<br>클래스가 사용 될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다.</p><p>이를 <strong>컨텍스트 독립성</strong> 이라 부른다.</p><p><strong>설계를 유연하게 만드는 마법</strong></p><ul><li>자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 작게 알아야 한다.<ul><li>각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못한다는 의미</li><li>최소한의 정보만 알자</li></ul></li><li>정보가 적으면 다양한 컨텍스트에서 재사용 될 수 있다.</li><li>설계는 더 유연해지고 변경에 대응하기 쉬워진다.<ul><li>응집력 있는 객체를 만들 수 있다</li><li>객체 구성 조합에 따라 변경 가능한 시스템으로 나아갈 수 있다.</li></ul></li></ul><h2 id="의존성-해결하기">의존성 해결하기</h2><p><strong>compile time 의존성은 구체적인 runtime 의존성으로 대체돼야 한다.</strong></p><p>이를 <strong>의존성 해결</strong> 이라 부른다.</p><p>의존성을 해결하는 방법은 일반적으로 다음과 같은 세 가지 방법을 사용한다.</p><ul><li><p>객체를 생성하는 시점에 생성자를 통해 의존성을 해결</p><ul><li>new A(new B())</li></ul></li><li><p>객체 생성 후 setter 메서드를 통해 의존성 해결</p><ul><li>(new A()).setB(new B())</li></ul></li><li><p>메서드 실행 시 인자를 이용해 의존성 해결</p><ul><li>(new A()).method(new B())</li><li>이 방식은 협력 대상에 대해 지속적으로 의존 관계를 맺을 필요 없이 메서드가 실행되는 동안만 의존 관계가 존재해도 무방한 경우</li><li>메서드 실행 시마다 의존 대상이 매번 달라져야 하는 경우에 유용</li></ul></li></ul><h2 id="setter-method-방식의-단점">Setter Method 방식의 단점</h2><p>setter 메서드를 이용하는 방법은 실행 시점에 의존 대상을 변경할 수 있기 때문에 설계를 좀 더 유연하게 만들 수 있다.<br>하지만 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에<br><strong>객체를 생성하고 의존 대상을 설정하기 전까지는 객체의 상태가 불완전</strong>할 수 있다는 점이다.</p><p>아래와 같은 코드는 NullPointerException 예외가 발생할 것이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Movie avatar = <span class="keyword">new</span> Movie();</span><br><span class="line">avatar.caculateFee(); <span class="comment">//discount policy가 아직 설정되지 않았기 때문에 NPE가 발생한다</span></span><br><span class="line">avatar.setDiscountPolicy(<span class="keyword">new</span> AmountDiscountPolicy());</span><br></pre></td></tr></table></figure></p><h2 id="생성자-방식-setter-방식">생성자 방식 + setter 방식</h2><p>setter method 방식을 보완하기 위해서는 생성자 방식와 setter 방식을 혼합하는 것이다.<br>항상 객체를 생성할 때 의존성을 해결해서 완전한 상태의 객체를 생성한 후 필요에 따라 setter 메서드를 이용해 의존대상을 변경할 수 있게 할 수 있다.<br>이 방법은 시스템의 상태를 안정적으로 유지하면서도 유연성을 향상시킬 수 있기 때문에 의존성 해결을 위해 가장 선호되는 방법이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Movie avatar = <span class="keyword">new</span> Movie(<span class="keyword">new</span> AmountDiscountPolicy());</span><br><span class="line">avatar.setDiscountPolicy(<span class="keyword">new</span> PercentDiscountPolicy());</span><br></pre></td></tr></table></figure></p><h1 id="의존성과-결합도">의존성과 결합도</h1><p>객체지향 패러다임의 근간은 협력이다. 따라서 객체들이 협력하기 위해서는 서로의 존재와 수행 가능한 책임을 알아야한다.<br>이런 지식들이 의존성을 낳는다.<br>따라서 모든 의존성이 나쁜 것은 아니다. 의존성은 객체들의 협력을 가능하게 하는 매개체이기 때문이다.<br>하지만 의존성이 과하면 문제가 된다.</p><p>바람직한 의존성을 위해서는 <strong>재사용성</strong>을 고려해야한다.</p><ul><li>어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못하다<ul><li>특정 컨텍스트에 강하게 결합된 의존성은 바람직하지 못하다</li></ul></li><li>어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 있다면 그 의존성은 바람직하다.<ul><li>특정 컨텍스트에 독립적인 의존성은 바람직한 의존성이다.</li></ul></li></ul><p>바람직한 의존성과 바람직 하지 못한 의존성을 나타내는 용어로 <strong>결합도</strong> 라는 용어를 사용한다.</p><ul><li>강한 결합도 (tight coupling)<ul><li>의존성이 다양한 환경에서 클래스를 재사용할 수 없는 바람직하지 못한 의존성</li></ul></li><li>약한 결합도 (loose coupling)<ul><li>의존성이 다양한 환경에서 클래스를 재사용할 수 있는 의존성</li><li>컨텍스트 독립적인 의존성</li></ul></li></ul><h2 id="지식이-결합을-낳는다">지식이 결합을 낳는다.</h2><p>결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.<br>많은 요소를 알고 있을 수록 두 요소는 강하게 결합된다.</p><p>예시</p><ul><li>일단 가격을 계산한다. -&gt; 약한 결합도</li><li>가격을 계산하는데 할인방식은 금액 할인 방식이고 평일에만 할인이 된다. -&gt; 강한 결합도</li></ul><h2 id="추상화에-의존하라">추상화에 의존하라</h2><p>추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나<br>감춤으로써 복잡도를 극복하는 방법이다.</p><p>추상화를 이용하면 현재 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다.<br>따라서 대상에 대해 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있다.</p><p>목록에서 아래쪽으로 갈수록 클라이언트가 알아야하는 지식의 양이 적어지기 때문에 결합도가 느슨해진다.</p><ul><li>구체 클래스 의존성 (concrete class dependency)</li><li>추상 클래스 의존성 (abstract class dependency)</li><li>인터페이스 의존성 (interface dependency)</li></ul><p>따라서 의존하는 대상이 더 추상적일 수록 결합도는 낮아진다</p><h2 id="명시적인-의존성">명시적인 의존성</h2><p>결합도를 느슨하게 만들기 위해서는 인스턴스 변수의 타입을 추상 클래스나 인터페이스로 선언하는 것만으로는 부족하다<br>클래스 안에서 구체 클래스에 대한 모든 의존성을 제거해야 한다. (아예 import도 안되게)<br>하지만 런타임에는 구체클래스의 인스턴스와 협력해야 하기 때문에 클래스의 인스턴스 타입이 뭔지는 알아야 한다.</p><p>위에서 얘기했던 것 처럼 의존성을 해결하는 방법에는 생성자, setter 메서드, 메서드 파라미터를 사용하는 세 가지 방식이 있다.<br>여기서의 방법은 인스턴스 변수의 타입은 추상 클래스나 인터페이스로 정의하고<br>생성자, setter 메서드, 메서드 파라미터로 실제 코드를 작성할 때에는 구체 클래스를 사용하는 것이다</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">(DiscountPoilcy discountPolicy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Movie movie = Movie(<span class="keyword">new</span> AccountDiscountPolicy());</span><br></pre></td></tr></table></figure></p><p>의존성을 대상을 <strong>생성자의 인자로 전달받는 방법</strong>과 <strong>생성자 안에서 직접 생성하는 방식</strong> 의 큰 차이점은<br>퍼블릭 인터페이스를 통해 할인 정책을 설정할 수 있는 방법을 제공하는지의 대한 여부다명시적으로 퍼블릭 인터페이스를 통해 의존성을 노출하는 방식을 <strong>명시적인 의존성</strong> 이라고 부른다.</p><h2 id="숨겨진-의존성">숨겨진 의존성</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.discountPolicy = <span class="keyword">new</span> AccountDiscountPolicy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>반면 위와 같은 코드에서는 할인 정책에 대한 의존성을 퍼블릭 인터페이스로 제공하지 않고 코드 내에 숨겨져 있다.<br>의존성이 퍼블릭 인터페이스에 표현되지 않는 방식을 <strong>숨겨진 의존성</strong> 이라고 부른다.<br>의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수 밖에 없다.</p><h2 id="의존성을-내부-구현으로-숨겨두지-마라">의존성을 내부 구현으로 숨겨두지 마라</h2><p>의존성은 명시적으로 표현되어야 한다.<br>의존성을 내부 구현에 숨겨 두면 개발자가 직접 내부 구현을 살펴봐야하는 고통이 따른다.<br>유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계이다.<br>명시적인 의존성을 사용해야지만 퍼블릭 인터페이스를 통해 컴파일 타임 의존성을 적절한 런타임 의존성으로 교체할 수  있다.</p><h2 id="new는-해롭다">new는 해롭다</h2><p>대부분의 언어에서는 클래스의 인스턴스를 생성할 수 있는 new 연산자를 제공한다.<br>안타까운 사실은 new를 잘못 사용하면 클래스 사이의 결합도가 극단적으로 높아진다.<br>결합도 측면에서 new가 해로운 이유는 크게 두 가지다.</p><ul><li>new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 서술하여야 한다.<ul><li>따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수밖에 없기 때문에 결합도가 높아진다.</li></ul></li><li>new 연산자는 생성하려는 구체 클래스 뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다.<ul><li>따라서 new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다.</li></ul></li></ul><p>따라서 new 연산자를 통한 구체 클래스 생성을 잘못하면 결합도가 높아지므로 변경에 의해 영향을 받기 쉬워진다.<br>또한 new를 통해 구체 클래스 생성에 끝나는 것이 아닌 협력할 구체 클래스의 인스턴스를 생성하기 위해 아래와 같은 지식이 필요하다</p><ul><li>어떤 인자들이 필요한가?</li><li>어떤 순서로 파라미터를 사용해야 하는가?</li><li>인자들에 대한 타입도 의존성에 추가된다</li></ul><h2 id="new를-없애기-위해서는">new를 없애기 위해서는</h2><p>new를 사용하지 않도록 하기 위해서는 다음과 같은 방법을 사용하면 된다.</p><p><strong>인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리한다.</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">(DiscountPolicy discountPolicy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//다른 클라이언트 코드에서 생성</span></span><br><span class="line">Movie movie = <span class="keyword">new</span> Movie(<span class="keyword">new</span> AmountDiscountPolicy()); <span class="comment">//1</span></span><br><span class="line">movie.setDiscountPolicy(<span class="keyword">new</span> PercentDiscountPolicy()); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p><p>위의 코드처럼 사용한다면 Movie라는 클래스 내에서는 구체 클래스에 대한 의존성 없이 DiscountPolicy라는 인터페이스 의존성만 존재한다.</p><ol><li><p>실제 구체 클래스가 되는 AmountDiscountPolicy의 대한 생성 책임은 Movie 클래스를 생성하는 클라이언트로 옮겨지고<br>Movie는 AmountDiscountPolicy의 인스턴스를 사용하는 책임만 남는다.</p></li><li><p>DiscountPolicy라는 인터페이스 의존성만 Movie 클래스에 두었기 때문에 다른 할인정책을 적용하더라도 유연하게 사용이 가능하다</p></li></ol><h2 id="new를-가끔은-사용해도-괜찮다">new를 가끔은 사용해도 괜찮다.</h2><p>클래스 안에서 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우도 있다.<br>주로 협력하는 기본 객체를 설정하고 싶은 경우가 이에 속한다.</p><p>대부분의 경우에는 <code>AmountDiscountPolicy</code> 의 인스턴스와 협력하는 경우를 생각해보자</p><p>이런 상황에서 모든 경우에 인스턴스를 생성하는 책임을 클라이언트로 옮긴다면 클라이언트 코드들 사이에 중복 코드가 늘어나고<br>Movie의 사용성도 나빠질 것이다.</p><p>이런 문제를 해결하는 방법을 기본 객체에 생성하는 생성자를 추가하고<br>이 생성자에서 DiscountPolicy의 인스턴스를 인자로 받는 생성자를 체이닝 하는 것이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>(<span class="keyword">new</span> AmountDiscountPolicy()); <span class="comment">//1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">(DiscountPolicy discountPolicy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>기본 생성자에서 DiscountPolicy를 파라미터로 받는 생성자를 호출한다.<br>호출 시, AmountDiscountPolicy 객체를 사용하여 Movie 객체를 생성하도록 한다.</li></ol><p>이제 클라이언트에서는 대부분의 경우에 기본 생성자를 통해 AmountDiscountPolicy의 인스턴스와 협력하게 하면서도<br>컨텍스트에 적절한 DiscountPolicy의 인스턴스로 의존성을 교체할 수 있다.</p><h2 id="표준-클래스에-대한-의존은-해롭지-않다">표준 클래스에 대한 의존은 해롭지 않다</h2><p>의존성이 불편한 이유는 그것이 항상 변경에 대한 영향을 암시하기 때문이다.<br>따라서 변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다.</p><p>예를 들어 JDK에 포함된 표준 클래스가 이 부류에 속한다.<br>String, ArrayList와 같은 클래스들은 거의 제로에 가깝기 때문에 인스턴스를 직접 new로 생성하더라도 문제가 되지 않는다.</p><p>비록 클래스를 직접 생성하더라도 가능한 추상적인 타입을 사용하는 것이 확장성 측면에서 유리하다<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;DiscountCondition&gt; conditions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>위의 코드와 같이 ArrayList를 사용하여 객체를 생성하더라도 타입을 ArrayList의 인터페이스인 List를 사용하면<br>확장성 측면에서 유리하다</p><p>추가적으로 <strong>의존성에 대한 영향이 적은 경우에도 추상화에 의존하고 의존성을 명시적으로 드러내는 것은 좋은 설계</strong>이다.</p><h1 id="조합-가능한-행동">조합 가능한 행동</h1><p>어떤 객체와 협력하느냐에 따라 객체의 행동이 달라지는 것은 유연하고 재사용 가능한 설계가 가진 특징이다.<br>유연하고 재사용 가능한 설계는 응집도 높은 책임들을 가진 작은 객체들을 다양한 방식으로 연결함으로써 애플리케이션의 기능을 쉽게 확장할 수 있다.</p><p>그렇다면 유연하고 재사용 가능한 설계는 무엇인가?<br>바로 객체가 어떻게(how) 하는지에 대한 코드를 장황하게 나열하지 않고,<br>객체들의 조합을 통해 무엇(what)을 하는지를 표현하는 클래스들로 구성된다.</p><p>따라서 클래스의 인스턴스를 생성하는 코드를 보는 것만으로 객체가 어떤 일을 하는지 쉽게 파악할 수 있다.<br>코드에 드러난 로직을 해석할 필요 없이 객체가 어떤 객체와 연결됐는지를 보는 것만으로도 객체의 행동을 쉽게 예상하고 이해할 수 있기 때문이다.</p><p>다시 말해 선언적으로 객체의 행동을 정의할 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Movie(</span><br><span class="line">  <span class="string">"아바타"</span>,</span><br><span class="line">  Duration.ofMinutes(<span class="number">120</span>),</span><br><span class="line">  Money.wons(<span class="number">10000</span>),</span><br><span class="line">  <span class="keyword">new</span> AmountDiscountPolicy(</span><br><span class="line">    Money.wons(<span class="number">800</span>),</span><br><span class="line">    <span class="keyword">new</span> SequenceCondition(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> SequenceCondition(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">new</span> PeriodCondition(</span><br><span class="line">      DayOfWeek.MONDAY, </span><br><span class="line">      LocalTime.of(<span class="number">10</span>, <span class="number">0</span>), </span><br><span class="line">      LocalTime.of(<span class="number">12</span>, <span class="number">0</span>)</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> PeriodCondition(</span><br><span class="line">      DayOfWeek.THURSDAY, </span><br><span class="line">      LocalTime.of(<span class="number">10</span>, <span class="number">0</span>), </span><br><span class="line">      LocalTime.of(<span class="number">21</span>, <span class="number">0</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>위의 코드를 보면 객체의 행동이 짐작이 간다.</p><ol><li>영화 제목은 아바타</li><li>영화의 가격은 10,000원</li><li>가격 할인 정책이 적용된다</li><li>할인 금액은 800원</li><li>1회차, 10회차 영화에 대해 할인이 적용된다</li><li>월요일에는 10시~12시 사이의 영화에 대해서 할인이 적용된다</li><li>목요일에는 10시~21시 사이의 영화에 대해서 할인이 적용된다</li></ol><p>이와 같이 유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로써 새로운 행돌을 이끌어낼 수 있는 설계다<br><strong>훌륭한 객체지향 설계란 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계다</strong></p><p>그리고 지금까지 설명한 것처럼 이런 설계를 창조하는 데 있어서의 핵심은 의존성을 관리하는 것이다.</p><h1 id="참고">참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter8. 의존성 관리하기</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2020/06/06/object-chapter8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Objects Study - Chapter7. 객체 분해</title>
      <link>https://jaehun2841.github.io/2020/05/30/object-chapter7/</link>
      <guid>https://jaehun2841.github.io/2020/05/30/object-chapter7/</guid>
      <pubDate>Sat, 30 May 2020 07:16:50 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;추상화와-분해&quot;&gt;추상화와 분해&lt;/h1&gt;
&lt;p&gt;불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만을 남기는 작업을 &lt;strong&gt;추상화&lt;/strong&gt; 라고 부른다.&lt;br&gt;
가장 일반적인 추상화 방법은 한 번에 다뤄야 하는 문제의 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="추상화와-분해">추상화와 분해</h1><p>불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만을 남기는 작업을 <strong>추상화</strong> 라고 부른다.<br>가장 일반적인 추상화 방법은 한 번에 다뤄야 하는 문제의 크기를 줄이는 것이다.</p><p>이처럼 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 <strong>분해(decomposition)</strong> 이라고 부른다.<br>분해의 목적은 큰 문제를 한번에 처리할 수 있는 규모의 문제로 나누는 것이다.<br>한 가지 주목할 점은 정보의 가장 작은 단위로서의 개별 항목을 의미하는 것이 아니라 하나의 단위로 취급될 수 있는 논리적인 chunk를 의미한다.</p><p>추상화와 분해는 인간이 세계를 인식하고 반응하기 위해 사용하는 가장 기본적인 사고 도구이다.<br>복잡성이 존재하는 곳에 추상화와 분해 역시 함께 존재한다.<br>소프트웨어 개발 영역에서는 복잡한 문제를 해결하기 위해 추상화와 분해를 사용한다.</p><h1 id="프로시저-추상화와-데이터-추상화">프로시저 추상화와 데이터 추상화</h1><p>프로그래밍 언어의 발전은 좀 더 효과적인 추상화를 이용해 복잡성을 극복하려는 개발자들의 노력에서 출발했다.<br>프로그래밍 언어를 통해 표현되는 추상화의 발전은 다양한 프로그래밍 패러다임의 탄생으로 이어졌다.<br>프로그래밍 패러다임은 프로그래밍을 구성하기 위해 사용하는 추상화의 종류와 이 추상화를 이용해 소프트웨어를 분해나는 방법의 두 가지 요소로 결정된다.<br>따라서 모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명할 수 있다.</p><p>현대적인 프로그래밍 언어를 특징 짓는 중요한 두 가지 추상화 메커니즘은 <strong>프로시저 추상화</strong>와 <strong>데이터 추상화</strong> 이다.</p><h2 id="프로시저-추상화">프로시저 추상화</h2><ul><li>프로시저 추상화를 중심으로 시스템을 분해하는 것은 기능 분해(functional decomposition)을 통해 추상화 하는 기법이다.</li><li>기능 분해는 알고리즘 분해(algorithmic decomposition)이라고 부르기도 한다.</li></ul><h2 id="데이터-중심-추상화">데이터 중심 추상화</h2><p>데이터 중심으로 추상화 하는 방법은 타입 추상화와 프로시저 추상화 두 가지가 있다.</p><ul><li><strong>타입 추상화(type abstraction)</strong><ul><li>추상 데이터 타입이라 부른다.</li></ul></li><li><strong>프로시저 추상화(procedure abstraction)</strong><ul><li>객체지향이라 부른다.</li><li>역할과 책임을 수행하는 객체</li></ul></li></ul><h1 id="프로시저-추상화와-기능-분해">프로시저 추상화와 기능 분해</h1><p>기능은 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용됐다.<br>이 같은 시스템 분해 방식을 <strong>알고리즘 분해</strong> 또는 <strong>기능 분해</strong>라고 부른다.<br>기능 분해의 관점에서 추상화의 단위는 프로시저이며 시스템은 프로시저를 단위로 분해된다.</p><p><strong>프로시저(procedure)</strong> 란</p><ul><li>반복적으로 실행되거나 거의 유사하게 실행되는 작업들의 모임</li><li>로직을 재상용하고 중복을 방지할 수 있는 추상화 방법</li><li>내부의 상세구현을 모르더라도 외부에 공개된 인터페이스만 알면 프로시저를 사용할 수 있다.</li><li>프로시저는 잠재적으로 정보 은닉의 가능성을 제시<ul><li>하지만 효과적인 정보은닉 체계를 구축하는데는 한계가 있다.</li></ul></li></ul><h1 id="하향식-접근법top-down-approach">하향식 접근법(Top-Down Approach)</h1><p>전통적인 분해 방법은 <strong>하향식 접근법</strong>을 따른다.<br>하향식 접근법이란 시스템을 구성하는 최상위 기능을 정의하고 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법<br>분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지 계속된다.<br>각 세분화 단계는 바로 위 단계보다 구체적이어야 한다. (상위 기능보다 덜 추상적이어야 한다.)</p><h2 id="하향식-접근법의-문제점">하향식 접근법의 문제점</h2><p>하향식 기능 분해 방법은 겉으로는 이상적일 수 있지만, 실제로 설계에 적용하다 보면 다음과 같은 다양한 문제에 직면한다.</p><ul><li>시스템은 하나의 메인 함수로 구성돼 있지 않다.</li><li>기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.</li><li>비지니스 로직이 사용자 인터페이스와 강하게 결합된다.</li><li>하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.</li><li>데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.</li></ul><p>위와 같은 문제로 인해 하향식 접근법과 기능 분해가 가지는 근본적인 문제점은 변경에 취약한 설계를 낳는다는 것이다.</p><h2 id="시스템은-하나의-메인-함수로-구성되지-않는다">시스템은 하나의 메인 함수로 구성되지 않는다.</h2><ul><li><p>어떤 시스템도 최초에 릴리즈됐던 당시의 모습을 그대로 유지하지는 않는다.</p></li><li><p>시간이 지나고 사용자를 만족시키기 위한 새로운 요구사항을 도출해나가면서 지속적으로 새로운 기능을 추가하게 된다.<br>이것은 시스템이 오직 하나의 메인 함수만으로 구현된다는 개념과는 완전히 모순된다.</p></li><li><p>하향식 접근법은 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에는 적합하지만 현대적인 상호작용 시스템을 개발하는 데는 적합하지 않다.</p></li></ul><h2 id="기능-추가나-요구사항-변경으로-인해-메인-함수는-빈번하게-수정된다">기능 추가나 요구사항 변경으로 인해 메인 함수는 빈번하게 수정된다.</h2><ul><li>시스템 안에는 여러 개의 정상급 함수가 존재하기 때문에 결과적으로 하나의 메인 함수를 유일한 정상으로 간주하기 어렵다.</li><li>하향식 기능 분해의 경우에는 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 한다.</li><li><strong>기존 로직과는 아무런 상관이 없는 새로운 함수의 적절한 위치를 확보해야 하기 때문</strong>에 메인 함수의 구조를 급격하게 변경하거나 새로 짤 수 밖에 없다.</li><li>코드의 빈번한 수정으로 인한 버그 발생 확률이 높아지고 시스템은 변경에 취약해질 수 밖에 없다.</li></ul><h2 id="비지니스-로직이-사용자-인터페이스와-강하게-결합된다">비지니스 로직이 사용자 인터페이스와 강하게 결합된다.</h2><ul><li>하향식 접근법은 비지니스 로직을 설계하는 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다.</li><li>결과적으로 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합된다.</li><li>사용자 인터페이스 로직과 비즈니스 로직을 한데 섞기 때문에 사용자 인터페이스를 변경하면 비즈니스 로직까지 영향을 받게 된다.</li><li>하향식 접근법은 기본적으로 변경에 불안정한 아키텍처 구조를 갖게 된다.</li></ul><h2 id="너무-이른-시기에-함수들의-실행-순서를-고정시키기-때문에-유연성과-재사용성이-저하된다">너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.</h2><ul><li>하향식으로 기능을 분해하는 과정에서 함수는 더 작은 함수들로 분해되고, 분해된 함수들의 실행 순서를 결정하는 작업으로 요약된다.</li><li>설계를 시작하는 시점부터 시스템이 무엇을 해야하는지가 아니라 어떻게 동작해야 하는지에 집중하게 한다</li><li>처음부터 구현을 염두에 두기 때문에 자연스럽게 함수들의 시간적 실행 순서를 강조한다.</li><li>결과적으로 모든 중요한 제어 흐름의 결정이 상위 함수에서 이뤄지고 하위 함수는 상위 함수의 흐름에 따라 적절한 시점에 호출된다.</li><li>결과적으로 기능을 추가하서나 변경하는 작업은 기존의 함수 제어 구조를 변경하게 만든다.</li><li>분해된 함수를 재사용하기 어렵다.<ul><li>재사용이라는 개념은 <strong>일반성</strong>이라는 의미를 내포한다. (상위 함수보다 일반적이다)</li><li>하향식 접근법에서는 하위 함수는 상위 함수에 비해 일반적일 수 없다. (재사용이 어렵다.)</li></ul></li></ul><h2 id="데이터-형식이-변경될-경우-파급효과를-예측할-수-없다">데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.</h2><p>하향식 기능분해의 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다.<br>따라서 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어렵다.<br>이것은 의존성과 결합도의 문제이다. 그리고 테스트의 문제이기도 하다</p><p>데이터의 변경으로 인한 영향은 데이터를 직접 참조하는 모든 함수로 퍼져나간다.<br>따라서 데이터 변경으로 인해 발생하는 함수에 대한 영향도를 파악하는 것은 예측할 수 없다.</p><p>데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다.<br>데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고 외부에서는 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제한다</p><p>변경에 대한 영향을 최소화하기 위해 영향을 받는 부분과 받지않는 부분을 명확하게 분리하고<br>잘 정의된 퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제해야 한다.</p><h2 id="언제-하향식-분해가-유용한가">언제 하향식 분해가 유용한가?</h2><ul><li><p>하향식 접근법은 이미 완전히 이해된 사실을 서술하기에 적합하다</p><ul><li>시스템이나 프로그램 개발자가 이미 완료한 결과에 대한 명확한 아이디어를 서술하기 위해 하향식을 사용하기 좋다.</li><li>작은 프로그램과 개별 알고리즘을 위해서는 하향식 접근법은 유용하다</li><li>프로그래밍 과정에서 이미 해결된 알고리즘을 문서화하고 서술하는 데에는 훌륭한 기법이다.</li></ul></li><li><p>새로운 것을 개발하고 설계하고 발전하는 데는 적합하지 않다.</p></li></ul><h1 id="정보-은닉과-모듈">정보 은닉과 모듈</h1><p>시스템의 변경을 관리하는 기본적인 전략은 함께 변경되는 부분을 하나의 구현단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것이다.<br>기능을 기반으로 시스템을 분해하는 것이 아니라 변경의 방향에 맞춰 시스템을 분해하는 것이다.</p><p>정보 은닉은 시스템을 모듈 단위로 분해하기 위한 기본 원리로<br>시스템에서 <strong>자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것</strong>이 핵심이다.</p><p>정보 은닉은 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리다.<br>모듈은 변경될 가능성이 있는 비밀을 내부로 감추고 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공해서<br>내부의 비밀에 함부로 접근하지 못하게 한다.</p><p>비밀을 결정하고 모듈을 분해한 후에는 기능 분해를 이용해 모듈에 필요한 퍼블릭 인터페이스를 구현할 수 있다.</p><blockquote><p>시스템을 모듈 단위로 어떻게 분해할 것인가?정답은 시스템이 감춰야하는 비밀을 찾는 것이다.<br>외부에서 내부의 비밀에 접근하지 못하도록 커다란 방어막을 쳐서 에워싸라.<br>그렇게 하면 이 방어막이 바로 퍼블릭 인터페이스가 된다.</p></blockquote><p>모듈은 다음과 같은 두 가지 비밀을 감춰야 한다.</p><ul><li>복잡성<ul><li>모듈이 너무 복잡한 경우 이해하고 사용하기 어렵다.</li><li>외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다.</li></ul></li><li>변경 가능성<ul><li>변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다.</li><li>변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감춘다.</li><li>외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.</li></ul></li></ul><p>시스템의 가장 일반적인 비밀은 <strong>데이터</strong>다<br>비밀이 반드시 데이터일 필요는 없으며 복잡한 로직이나 변경 가능성이 큰 자료 구조일 수도 있다.<br>그럼에도 변경 시 시스템을 굴복시키는 대부분의 경우는 데이터가 변경되는 경우다.</p><h1 id="모듈의-장점과-한계">모듈의 장점과 한계</h1><p><strong>모듈의 장점</strong></p><ul><li><p>모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.</p><ul><li>모듈을 사용하면 모듈 내부에 정의된 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한할 수 있다.</li><li>어떤 데이터가 변경됐을 때 영향을 받는 함수를 찾기 위해 해당 데이터를 정의한 모듈만 검색하면 된다.</li><li>모듈은 데이터 변경으로 인한 파급효과를 제어할 수 있기 때문에 코드를 수정하고 디버깅하기 용이하다</li></ul></li><li><p>비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다</p></li><li><p>전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염(namespace pollution)을 방지한다.</p><ul><li>모듈의 한 가지 용도는 네임스페이스를 제공하는 것이다.</li><li>변수와 함수를 모듈 내부에 포함시키기 때문에 다른 모듈에서도 동일한 이름을 사용할 수 있다.</li><li>모듈은 전역 네임스페이스의 오염을 방지하는 동시에 이름 충돌의 위험을 완화한다.</li></ul></li><li><p>모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다.</p><ul><li>모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합이다.<ul><li>모듈에 있어 외부에 감춰야 하는 비밀은 데이터다.</li></ul></li><li>모듈 내부는 높은 응집도를 유지한다</li><li>모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신한다</li><li>모듈과 모듈 사이에는 낮은 결합도를 유지한다.</li><li>모듈은 데이터와 함수가 통함된 한 차원 높은 추상화를 제공하는 설계 단위이다.</li></ul></li></ul><p><strong>모듈의 단점</strong></p><ul><li>모듈이 프로시저 추상화 보다는 높은 추상화를 제공한다.</li><li>모듈은 인스턴스의 개념을 제공하지 않는다는 단점이 있다.</li></ul><h1 id="데이터-추상화와-추상-데이터-타입">데이터 추상화와 추상 데이터 타입</h1><h2 id="추상-데이터-타입">추상 데이터 타입</h2><ul><li><p>프로그래밍 언어에서 <strong>타입(Type)</strong> 이란 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미한다.</p></li><li><p>프로그래밍 언어는 다양한 형태의 내장 타입(built-in type)을 제공한다.</p><ul><li>기능 분해 시대에 사용되던 절차형 언어들은 적은 수의 내장 타입만을 제공</li><li>새로운 타입을 추가하는 것이 불가능하거나 제한적이었다.</li></ul></li></ul><p>추상 데이터 타입은 프로시저 추상화 대신 데이터 추상화를 시반으로 소프트웨어를 개발하게 된 최초의 한걸음이다.<br>추상 데이터 타입을 구현하려면 다음과 같은 특성을 위한 프로그래밍 언어의 지원이 필요하다.</p><ul><li>타입 정의를 선언할 수 있어야 한다.</li><li>타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.</li><li>제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.</li><li>타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.</li></ul><blockquote><p>리스코프는 추상 데이터 타입을 정의하기 위해 제시한 언어적인 메커니즘을 <strong>오퍼레이션 클러스터(operation cluster)</strong> 라고 불렀다.</p></blockquote><h1 id="클래스는-추상-데이터-타입인가">클래스는 추상 데이터 타입인가?</h1><p>대부분의 프로그래밍 서적에서는 클래스를 추상 데이터 타입으로 설명한다.<br>그러나 명확한 의미에서 추상 데이터 타입과 클래스는 동일하지 않다.</p><ul><li>클래스는 상속과 다형성을 지원하는 데 비해 추상 데이터 타입은 지원하지 못한다.</li><li>상속과 다형성을 지원하는 프로그래밍 기법을 객체지향 프로그래밍 (Object-Oriented Programming)이라 한다.</li><li>상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍 기법을 객체기반 프로그래밍(Object-Based Programming)이라 한다.</li><li>추상 데이터 타입은 Type을 추상화한 것</li><li>클래스는 절차를 추상화한 것</li></ul><p>윌리엄 쿡은 하나의 대표적인 타입이 다수의 세부적인 타입을 감출 수 있기 때문에 이를 타입 추상화라 불렀다.</p><p><strong>타입 추상화</strong></p><p><img src="./type-abstraction.jpg" alt="type-abstraction"></p><ul><li>개별 오퍼레이션이 모든 개념적인 타입에 대한 구현을 포괄 하도록 함으로써 하나의 물리적인 타입 안에 전체 타임을 감춘다.</li><li>타입 추상화는 오퍼레이션을 기준으로 타입을 통합하는 데이터 추상화 기법이다.</li></ul><p><strong>객체지향</strong></p><p><img src="./procedural-abstraction.jpg" alt="procedural-abstraction"></p><ul><li>타입을 기준으로 오퍼레이션을 묶는다.</li><li>두 가지 이상의 클래스로 분리할 경우 공통로직을 어디에 둘 것인지가 이슈<ul><li>공통 로직을 제공하기 위한 간단한 방법은 공통 로직을 포함할 부모 클래스를 정의하고 상속 시킨다.</li></ul></li><li>클라이언트는 부모 클래스 참조자에 대해 메세지를 전송하면 실제 클래스가 무엇인지에 따라 다른 메소드가 실행된다.</li><li>실제로 내부에서 수행되는 절차는 다르지만 클래스를 이용한 다형성은 절차에 대한 차이점을 감춘다.<ul><li>따라서 객체지향은 절차 추상화(procedural abstraction)이다</li></ul></li></ul><h1 id="변경을-기준으로-선택하라">변경을 기준으로 선택하라</h1><p>단순히 클래스를 구현 단위로 사용한다는 것이 객체지향 프로그래밍을 한다는 것을 의미하지 않는다.<br>비록 클래스를 사용하고 있더라도 타입을 기준으로 절차를 추상화하지 않았다면 그것은 객체지향 분해가 아니다.</p><p><strong>추상 데이터 타입 위반 사항 check list</strong></p><ul><li>클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는가?<ul><li>인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체 지향을 위반하는 것으로 간주된다.</li></ul></li></ul><p><strong>객체 지향 위반 사항 check list</strong></p><p><img src="./Polymorphism.jpg" alt="Polymorphism"></p><ul><li><p>타입 변수를 이용한 조건문으로 구분하는가?</p><ul><li>클라이언트가 객체의 타입을 확인하고 메서드를 호출하게 해선 안된다.</li><li>객체가 메세지를 처리할 적절한 메서드를 처리하게 해야한다.</li></ul></li><li><p>OCP (Open-Closed Principle) 개방-폐쇄 원칙을 위반하는가?</p><ul><li>OCP란 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성이다.</li><li>기존코드에서 특성 변수에 대한 분기 로직이 있었다면, 새로운 요구사항이 있는 경우 코드를 수정해야 한다.</li><li>하지만 객체지향을 이용하면 코드 수정없이도 새로운 유형과 행위를 추가할 수 있다.</li></ul></li></ul><h1 id="추상-데이터-타입-vs-객체지향-당신의-선택은">추상 데이터 타입 vs 객체지향 당신의 선택은?</h1><ul><li>타입 추가가 빈번한가?  =&gt; <strong>객체지향</strong><ul><li>추상데이터 타입의 경우 일일이 새로운 타입에 대해 체크하는 클라이언트 코드를 수정해야 한다.</li><li>객체지향의 경우 코드 수정없이 새로운 클래스를 상속 계층에 추가하면 된다.</li></ul></li><li>오퍼레이션 추가가 빈번한가?  =&gt; <strong>추상 데이터 타입</strong><ul><li>객체지향의 경우 새로운 오퍼레이션을 추가하기 위해서는 상속 계층에 속하는 모든 클래스를 한번에 수정해야 한다.</li><li>추상 데이터 타입의 경우에는 전체 타입에 대한 구현 코드가 하나의 구현체에 포함되어 있다.</li><li>따라서 새로운 오퍼레이션을 추가하는 작업이 상대적으로 간단하다</li></ul></li></ul><h1 id="참고">참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter7. 객체 분해</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2020/05/30/object-chapter7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Objects Study - Chapter6. 메세지와 인터페이스</title>
      <link>https://jaehun2841.github.io/2020/05/24/object-chapter6/</link>
      <guid>https://jaehun2841.github.io/2020/05/24/object-chapter6/</guid>
      <pubDate>Sun, 24 May 2020 09:21:34 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;협력과-메세지&quot;&gt;협력과 메세지&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.&lt;/li&gt;
&lt;li&gt;메세지는 객체 사이의 협력을 가능하게 하는 매개체다&lt;/li&gt;
&lt;li&gt;객체가 다른 객체에게 접근할 수 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="협력과-메세지">협력과 메세지</h1><ul><li>협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.</li><li>메세지는 객체 사이의 협력을 가능하게 하는 매개체다</li><li>객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메세지를 전송하는 것뿐이다.</li><li>메세지는 매개로 하는 요청과 응답의 조합이 두 객체 사이의 협력을 구성한다.</li></ul><h2 id="클라이언트-서버-모델">클라이언트 서버 모델</h2><p>두 객체 사이의 협력관계를 설명하기 위해 사용하는 전통적인 메타포는 <strong>클라이언트-서버(Client-Server)모델</strong>이다.</p><ul><li>클라이언트 : 협력 안에서 메세지를 전송하는 객체</li><li>서버: 협력 안에서 메세지를 수신하는 객체</li></ul><p><img src="./client-server.jpg" alt="client-server"></p><p>객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 <strong>동시에 수행하는 것이 일반적</strong>이다.<br>협력의 관점에서 객체는 두 가지 종류의 메세지 집합으로 구성된다.</p><ol><li>객체가 수신하는 메세지의 집합</li><li>외부의 객체에게 전송하는 메세지의 집합</li></ol><p><img src="./client-server2.jpg" alt="client-server2"></p><h2 id="메세지와-메세지-전송">메세지와 메세지 전송</h2><p><strong>메세지(Message)</strong> 는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.</p><ul><li>한 객체가 다른 객체에게 도움을 요청하는 것을 <strong>메세지 전송(message sending)</strong> 또는 <strong>메세지 패싱(message passing)</strong> 이라 부른다.</li><li>메세지를 전송하는 객체를 <strong>메세지 전송자(message sender)</strong> 혹은 <strong>클라이언트</strong>라고 부른다.</li><li>메세지를 수신하는 객체를 <strong>메세지 수신자(message receiver)</strong> 혹은 <strong>서버</strong>라고 부른다.</li></ul><p><img src="./message.jpg" alt="message"></p><ul><li>메세지는 오퍼레이션 + 인자로 구성</li><li>메세지 전송은 수신자 + 오퍼레이션 + 인자로 구성</li></ul><h2 id="메세지와-메서드">메세지와 메서드</h2><p>메세지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 <strong>메서드</strong>라 부른다.<br>중요한 점은 코드 상에서 동일한 이름의 변수(condition)에게 동일한 메세지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수가 있다는 것이다.</p><ul><li>전통적인 방식 - 컴파일 레벨에서 어떤 코드가 실행될지 정확하게 알고 있는 상황에서 함수 호출이나 프로시저 호출 구문을 작성한다.</li><li>객체지향 방식 - 메세지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.<ul><li>메세지와 메서드의 구분은 메세지 전송자와 메세지 수신자가 느슨하게 결합되도록 한다.</li><li>메세지 전송자는 자신이 어떤 메세지를 객체에 전송할 지만 알면된다.</li><li>메세지 수신자는 누가 전송하는지는 알 필요가 없고 전송받은 메세지를 처리하기 위해 필요한 메서드를 스스로 결정할 수 있는 자율권을 누린다.</li></ul></li></ul><p><strong>실행 시점에 메세지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.</strong></p><h2 id="public-인터페이스와-오퍼레이션">Public 인터페이스와 오퍼레이션</h2><ul><li><p>객체가 의사소통을 위해 외부에 공개하는 메세지의 집합을 <strong>퍼블릭 인터페이스(public interface)</strong> 라고 한다.</p></li><li><p>퍼블릭 인터페이스에 포함된 메세지를 <strong>오퍼레이션(operation)</strong> 이라고 부른다.</p></li><li><p>오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다</p></li></ul><p>프로그래밍 언어의 관점에서 객체가 다른 객체에게 메세지를 전송하면 런타임 시스템은 메세지 전송을 <strong>오퍼레이션 호출</strong>로 해석한다.<br>메세지를 수신한 객체의 실제 타입을 기반으로 적잘한 메서드를 찾아 실행한다.<br>따라서 퍼블릭 인터페이스와 메세지의 관점에서 보면 <strong>메서드 호출</strong>보다는 <strong>오퍼레이션 호출</strong>이라는 용어를 사용하는 것이 더 적절하다.</p><p><img src="./message-operation.jpg" alt="message-operation"></p><h2 id="메서드-시그니처">메서드 시그니처</h2><p>오퍼레이션(또는 메서드)와 파라미터 목록을 합쳐 메서드 시그니처 (method signature)라고 부른다.<br>오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이다.<br>메서드는 이 시그니처에 구현을 더한 것이다.<br>이반적으로 메세지를 수신하면 오퍼레이션의 시그니처와 동일한 메서드가 실행된다.</p><p>오퍼레이션의 관점에서 <strong>다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것</strong>이라고 정의할 수 있다.</p><h1 id="인터페이스와-설계-품질">인터페이스와 설계 품질</h1><p>좋은 인터페이스는 <strong>최소한의 인터페이스</strong>와 <strong>추상적인 인터페이스</strong>라는 조건을 만족해야 한다.</p><ul><li>최소한의 인터페이스는 오퍼레이션만을 인터페이스에 포함한다.</li><li>추상적인 인터페이스는 어떻게 수행하는지가 아닌 무엇을 하는지를 표현한다.</li></ul><p><strong>책임 주도 설계 방법</strong>은 메세지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지한다.<br>따라서 인터페이스는 최소의 오퍼레이션만 포함하게 된다.</p><h2 id="디미터-법칙">디미터 법칙</h2><p><strong>디미터 법칙(Law of Demeter)</strong> 는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이다.<br>요약하자면, 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.</p><ul><li>낯선 자에게 말하지 말라 (don`t talk to strangers)</li><li>오직 인접한 이웃하고만 말하라 (only talk to your immediate neighbors)</li><li>자바와 같이 도트(.)를 이용해 메세지를 전송을 표현하는 언어에서는 &quot;오직 하나의 도트만 사용하라(use only one dot)&quot;</li></ul><p>디미터 프로젝트를 진행하던 사람들은 디미터 법칙을 이용하여 <strong>객체들간의 협력 경로를 제한하면 결합도를 효과적으로 낮출 수 있다</strong>는 사실을 발견하였다.</p><p>디미터 법칙을 따르면 <strong>부끄럼타는 코드 (shy code)</strong> 를 작성할 수 있다.<br>부끄럽타는 코드란 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다.<br>디미터 법칙을 따르는 코드는 메세지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메세지 전송자는 수신자의 내부 구현에 결합되지 않는다.<br>따라서 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.</p><h3 id="디미터-법칙을-어기는-코드">디미터 법칙을 어기는 코드</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screening.getMovie().getDiscountConditions();</span><br></pre></td></tr></table></figure></p><p>메세지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메세지를 전송한다.<br>흔히 이와 같은 코드를 <strong>기차 충돌(train wreck)</strong> 이라고 부른다.</p><p>이와 같은 코드는 Movie의 내부 구현을 외부로 노출 시키게 되므로 메세지 수신자의 캡슐화는 무너지고<br>메세지 전송자가 메세지 수신자의 내부 구현에 강하게 결합된다.</p><p>디미터 법칙은 객체의 내부 구조를 묻는 메세지가 아니라 수신자에게 무언가를 시키는 메세지가 더 좋다고 얘기한다.</p><h2 id="묻지-말고-시켜라">묻지 말고 시켜라</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screening.getMovie().getDiscountConditions();</span><br></pre></td></tr></table></figure></p><p>위와 같은 코드는 screening에게 직접 요금을 계산할 책임을 할당한 것이다.<br>디미터 법칙은 훌륭한 메세지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.<br>메세지 전송자는 메세지 수신자의 상태를 기반으로 결정을 내린 후 메세지 수신자의 상태를 바꿔서는 안된다.<br>객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.</p><p>묻지말고 시켜라 원칙으로 얻는 이점</p><ul><li>밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.<ul><li>객체지향의 기본은 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다.</li></ul></li><li>객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.</li><li>자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.</li></ul><h2 id="의도를-드러내는-인터페이스">의도를 드러내는 인터페이스</h2><p>켄트 백(Kent Beck)은 Smalltalk Best Practice Patterns에서 메서드를 명명하는 두 가지 방법을 설명했다.</p><ol><li>메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는다.</li><li>&quot;어떻게&quot;가 아니라 &quot;무엇&quot;을 하는지 드러낸다.</li></ol><h3 id="메서드가-작업을-어떻게-수행하는지를-나타내도록-이름-짓는다">메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는다.</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeriodCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedByPeriod</span><span class="params">(Screening screening)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBySequence</span><span class="params">(Screening screening)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같은 스타일은 좋지 않다.</p><ul><li>메서드에 대해 제대로 커뮤니케이션 하지 못한다.  두 메서드 모두 할인 조건을 판단하는 메서드이다.</li><li>하지만 메서드의 이름이 다르기 때문에 두 메서드의 내부 구현을 정확하게 이해하지 못한다면 두 메서드가 동일한 작업을 수행하는 사실을 알아채기 어렵다.</li><li>메서드 수준에서 캡슐화를 위반한다.</li><li>위의 메서드들은 클라이언트로 하여금 객체의 종류를 알도록 강요한다.</li><li>만약에 할인여부가 변경된다면 메세지를 전송하는 클라이언트 코드의  메서드의 이름또한 변경되어야 한다.</li><li>따라서 책임을 수행하는 방법을 드러내는 메서드를 사용한 설계는 변경에 취약할 수밖에 없다.</li></ul><h3 id="quot어떻게quot가-아니라-quot무엇quot을-하는지-드러낸다">&quot;어떻게&quot;가 아니라 &quot;무엇&quot;을 하는지 드러낸다.</h3><p>어떻게 수행하는지를 드러내는 이름이란 메서드의 내부 구현을 설명하는 이름이다.<br>협력을 설계하기 시작하는 이른 시기부터 클래스의 내부 구현에 관해 고민할 수 밖에 없다.<br>반면 무엇을 하는지 드러내도록 메서드의 이름을 짓기 위해서는 객체가 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다.<br>이것은 외부의 객체가 메세지를 전송하는 목적을 먼저 생각하도록 만들며, 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeriodCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Screening screening)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Screening screening)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>클라이언트 관점에서 두 메서드 모두 다 할인 여부를 판단하기 위한 작업을 수행한다.<br>따라서 두 메서드 모두 클라이언트들의 의도를 담을 수 있도록 <code>isSatisfiedBy</code>로 변경하는 것이 적절하다</p><p>자바와 같은 정적 타이핑 언어에서는 단순히 메서드 이름이 같다고 해서 동일한 메세지를 처리할 수 있는 것은 아니다.<br>클라이언트가 동인할 타입으로 간주할 수 있도록 동일한 타입 계층으로 묶어야 한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Screening screening)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>가장 간단한 방법은 DiscountCondition이라는 인터페이스를 정의하고 이 인터페이스에 isSatisfiedBy 오퍼레이션을 정의하는 것이다.</p><h3 id="의도를-드러내는-선택자-intention-revealing-selector">의도를 드러내는 선택자 (Intention Revealing Selector)</h3><p>메서드가 어떻게 수행하느냐가 아니라 무엇을 하느냐에 초점을 맞추면 클라이언트의 관점에서 동일한 작업을 수행하는 메서드를 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다.<br>그 결과, 다양한 타입의 개규체가 참여할 수 있는 유연한 협력을 얻게 된다.</p><p>이처럼 어떻게 수행하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 <strong>의도를 드러내는 선택자 (Intention Revealing Selector)</strong> 라고 부른다.</p><blockquote><p>하나의 구현을 가진 메세지 이름을 일반화 하도록 도와주는 간단한 방법</p><p>매우 다른 두 번째 구현을 상상하라. 그러고는 메서드에 동일한 이름을 붙인다고 생각해보라<br>그렇게 하면 아마도 그 순간 가장 추상적인 이름을 메서드에 붙일 수 있을 것이다.</p></blockquote><h3 id="의도를-드러내는-인터페이스-intention-revealing-interface">의도를 드러내는 인터페이스 (Intention Revealing Interface)</h3><p>&lt;도메인 주도 설계&gt;에서 에릭에반스는 <strong>의도를 드러내는 선택자</strong>를 인터페이스 레벨로 확장한 <strong>의도를 드러내는 인터페이스</strong>를 제시했다.<br>의도를 드러내는 인터페이스란, <strong>구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다는 것</strong>이다.</p><ul><li><p>수행 방법에 관해서는 언급하지 말고 결과와 목적만을 포함하도록 클래스와 오퍼레이션의 이름을 부여하라<br>이렇게 하면 클라이언트 개발자가 내부를 이해해야 할 필요성이 줄어들게 된다.</p></li><li><p>방법이 아닌 의도를 표현하는 추상적인 인터페이스 뒤로 모든 까다로운 메커니즘을 캡슐화해야 한다.<br>도메인의 퍼블릭 인터페이스에서는 관계와 규칙을 시행하는 방법이 아닌 이벤트와 규칙 그 자체만 명시한다.</p></li></ul><h1 id="원칙의-함정">원칙의 함정</h1><h2 id="디미터-법칙은-하나의-도트를-강제하는-규칙이-아니다">디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.</h2><p>디미터 법칙은 &quot;오직 하나의 도트만을 사용하라&quot;라는 말로 요약되기도 한다.<br>그렇다면 builder패턴이나 lambda 식에서 주로 볼 수 있는 method chaining은 디미터 법칙을 위반하는 것일까?<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="number">1</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">9</span>)</span><br><span class="line">         .filter(x -&gt; x &gt; <span class="number">10</span>)</span><br><span class="line">         .distinct()</span><br><span class="line">         .count();</span><br></pre></td></tr></table></figure></p><p>위의 코드에서 <code>of</code>, <code>filter</code>, <code>distinct</code> 메서드는 모두 IntStream이라는 동일한 클래스의 인스턴스를 반환한다.</p><p>따라서 이 코드는 디미터 법칙을 위반하지 않는다.<br>디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.<br>위의 코드에서는 IntStream의 내부 구조가 외부로 노출되지 않았다.<br>단지 IntStream을 다른 IntStream으로 변환할 뿐, 객체를 둘러싸고 있는 캡슐은 그대로 유지된다.</p><p>따라서 하나 이상의 도트(.)를 사용하는 모든 케이스가 디미터 법칙 위반인 것은 아니다.<br>기차 충돌처럼 보이는 코드라도 객체 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.</p><p>또한 이 메서드들은 객체의 내부에 대한 어떤 내용도 묻지 않는다.<br>그저 객체를 다른 객체로 변환하는 작업을 수행하라고 시킬 뿐이다. 따라서 묻지말고 시켜라 원칙을 위반하지 않는다.</p><blockquote><p>로버트 마틴은 &lt;클린코드&gt;에서 디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료구조 인지에 따라 다르다고 한다.<br>객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는게 좋다.<br>자료 구조는 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.</p></blockquote><h1 id="명령-쿼리-분리-원칙-cqrs">명령-쿼리 분리 원칙 (CQRS)</h1><p>명령-쿼리 분리 원칙은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.</p><ul><li>Routine: 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈. 루틴은 프로시져와 함수로 나뉜다.<ul><li>Procedure: 정해진 절차에 따라 내부의 상태를 변경. 부수효과(side effect)를 발생시킬 수 있지만 값을 반환할 수 없다.</li><li>Function: 함수는 값을 반환할 수 있지만, 부수효과(side effect)를 발생시킬 수 없다.</li></ul></li></ul><p>명령(Command)와 쿼리(Query)는 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름이다.</p><ul><li>Command = Procedure : 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.</li><li>Query = Function : 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.</li></ul><h2 id="기계로서의-객체-메타포">기계로서의 객체 메타포</h2><p><img src="./metaphor_machine.jpg" alt="metaphor_machine"></p><p>버트란드 마이어(Bertrand Meyer)는 &lt;Object-Oriented Software Construction&gt;에서 명령-쿼리 분리 원칙을 설명할 때 기계 메타포를 이용한다.<br>이 관점에서 객체는 블랙박스이며 객체의 인터페이스는 객체의 관찰 가능한 상태를 보기 위한 일련의 디스플레이와 객체의 상태를 변경하기 위해 누를 수 있는 버튼의 집합이다.</p><p>이런 스타일의 인터페이스를 사용함으로써 객체의 캡슐화와 다양한 문맥에서의 재사용성을 보장할 수 있다.<br>마틴 파울러는 명령-쿼리 분리 원칙에 따라 작성된 인터페이스를 <strong>명령-쿼리 인터페이스(Command-Query Interface)</strong> 라고 부른다.</p><ul><li>insert, delete, merge, search는 명령(Command) 버튼으로써 기계의 상태가 변경된다.</li><li>명령(Command) 버튼은 실행 결과를 제공하지 않기 때문에 명령 버튼을 누른 직후에는 기계 내부의 상태를 직접 확인할 수 없다.</li><li>empty, current, first, last는 쿼리(Query) 버튼으로서 기계의 상태를 확인할 수 있다.</li><li>명령(Command) 버튼을 누르지 않고 쿼리(Query) 버튼을 계속 누르게 되면 항상 똑같은 값이 패널에 표시될 것이다.</li></ul><h2 id="명령-쿼리-분리와-참조-투명성">명령-쿼리 분리와 참조 투명성</h2><ul><li>명령과 쿼리를 엄격하게 분류하면 객체의 부수효과(side effect)를 제어하기 수월해진다.</li><li>쿼리는 <strong>객체의 상태를 변경하지 않기 때문에 몇 번이고 반복적으로 호출하더라도 상관이 없다.</strong> (항상 같은 값을 리턴한다.)</li><li>명령이 개입하지 않는 한 쿼리의 값은 변경되지 않기 때문에 쿼리의 결과를 예측하기 쉬워진다.</li><li>또한 쿼리의 순서를 자유롭게 변경할 수도 있다.</li></ul><p>명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 <strong>참조 투명성(referential transparency)</strong> 의 장점을 제한적이나마 누릴 수 있게 된다.<br>참조 투명성을 잘 활용하면 버그가 적고, 디버깅이 용이하고, 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성할 수 있다.</p><p>하지만 명령-쿼리 분리를 하지 않은 함수에서는 내부에 부수효과를 포함할 경우 동일한 인자를 전달하더라도 부수효과에 의해 그 결괏값이 매번 달라질 수 있다.</p><h2 id="수학으로-보는-참조-투명성">수학으로 보는 참조 투명성</h2><p>참조 투명성이란 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라고 결과가 달라지지 않는 특성을 의미한다.</p><p>어떤 함수 f(n)이 존재 할 때 n의 값으로 1을 대입하면 그 결과가 3이라고 가정하자 (f(1) = 3)</p><ul><li>f(1) + f(1) = 6</li><li>f(1) * 2 = 6</li><li>f(1)  - 1 = 2</li></ul><p>위에서 f(1) = 3 이라고 했기 때문에 대입하여 결과를 얻어내기 쉬웠다.<br>f(1) 자리에 3으로 바꿔보자</p><ul><li>3 + 3 = 6</li><li>3 * 2 = 6</li><li>3  - 1 = 2</li></ul><p>이것이 바로 참조 투명성이다.<br>수학에서의 함수는 항상 동일한 입력에 대해 동일한 값을 반환하기 때문에 수학의 함수는 참조 투명성을 만족 시키는 이상적인 예이다.</p><p>따라서 참조 투명성은 식을 값으로 치환하는 방법을 통해 결과를 쉽게 계산할 수 있게 해준다.<br>여기서 f(1)의 값을 항상 3이라고 말할 수 있는 이유는 f(1)의 값이 변하지 않기 때문이다.<br>이처럼 어떤 값이 변하지 않는 성질을 불변성(immutability)이라고 부른다.<br>어떤 값이 불변한다는 말은 부수효과(side effect)가 발생하지 않았다는 말과 동일하다.</p><p>참조 투명성을 만족하는 식은 두 가지 장점을 제공한다.</p><ul><li>모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.</li><li>모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.</li></ul><p>객체지향 패러다임이 객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다.<br>하지만 명령-쿼리 분리 원칙을 사용하면 조금이나마 예외를 줄일 수 있다.<br>명령-쿼리 분리 원칙은 부수효과를 가지는 명령으로부터 부수효과를 가지지 않는 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있다.</p><h2 id="명령형-프로그래밍과-함수형-프로그래밍">명령형 프로그래밍과 함수형 프로그래밍</h2><ul><li>명령형 프로그래밍 : 부수효과를 기반으로 하는 프로그래밍 방식<ul><li>상태를 변경시키는 연산들을 적절한 순서대로 나열하여 프로그램을 작성한다.</li><li>대부분의 객체지향 프로그래밍 언어는 메세지에 의한 객체의 상태 변경에 집중하기 때문에 명령형 프로그래밍 언어로 본다.</li></ul></li><li>함수형 프로그래밍 : 부수효과가 존재하지 않는 수학적인 함수에 기반한다.<ul><li>참조 투명성의 장점을 극대화할 수 있다.</li><li>명령형 프로그래밍에 비해 프로그램의 실행 결과를 이해하고 예측하기가 쉽다.</li></ul></li></ul><h1 id="요약">요약</h1><ul><li>디미터 법칙: 협력이라는 컨텍스트 안에서 객체보다 메세지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다.<br>수신할 객체를 알지 못한 상태에서 메세지를 먼저 선택하기 때문에 객체의 내부 구조에 대해 고민할 필요가 없어진다.<br>따라서 메세지가 객체를 선택하게 함으로써 의도적으로 디미터 법칙을 위반할 위험을 최소화할 수 있다.</li><li>묻지 말고 시켜라: 메세지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다.<br>클라이언트의 관점에서 메세지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메세지를 전송하면 된다.</li><li>의도를 드러내는 인터페이스: 메세지를 먼저 선택한다는 것은 메세지를 전송하는 클라이엍느의 관점에서 메세지의 이름을 정한다는 것이다.<br>당연히 그 이름에는 클라이언트가 무엇을 원하는지, 그 의도가 분명하게 드러날 수 밖에 없다.</li><li>명령-쿼리 분리 원칙: 메세지를 먼저 선택한다는 것은 협력이라는 문맥 안에서 객체의 인터페이스에 관해 고민한다는 것을 의미한다.<br>객체가 단순히 어떤 일을 해야 하는지뿐만 아니라 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게 된다. 따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.</li></ul><h1 id="참고">참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter6. 메세지와 인터페이스</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2020/05/24/object-chapter6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Objects Study - Chapter5. 책임 할당하기</title>
      <link>https://jaehun2841.github.io/2020/05/17/object-chapter5/</link>
      <guid>https://jaehun2841.github.io/2020/05/17/object-chapter5/</guid>
      <pubDate>Sat, 16 May 2020 23:26:01 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;책임-주도-설계를-향해&quot;&gt;책임 주도 설계를 향해&lt;/h1&gt;
&lt;p&gt;책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 &lt;strong&gt;어떤 객체에게 어떤 책임을 할당할지를 결정하기가 쉽지 않다는 것&lt;/strong&gt;이다.&lt;br&gt;
책임 할
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="책임-주도-설계를-향해">책임 주도 설계를 향해</h1><p>책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 <strong>어떤 객체에게 어떤 책임을 할당할지를 결정하기가 쉽지 않다는 것</strong>이다.<br>책임 할당 과정은 일종의 트레이드오프 활동이다.<br>동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라진다.<br>따라서 올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가할 수 있어야 한다.<br>chapter 5에서는 GRASP 패턴을 이용하여 책임 할당의 어려움을 해결하는 방법을 제시하였다.</p><h1 id="데이터-중심-설계-gt-책임-주도-설계">데이터 중심 설계 -&gt; 책임 주도 설계</h1><p>데이터 중심의 설계에서 책임 중심의 설계로 전환하기 위해서는 다음의 두 가지 원칙을 따라야 한다.</p><ul><li>데이터보다 행동을 먼저 결정하라</li><li>협력이라는 문맥 안에서 책임을 결정하라</li></ul><h1 id="데이터보다-행동을-먼저-결정하라">데이터보다 행동을 먼저 결정하라</h1><p>객체에게 중요한 것은 데이터가 아니라 외부에 제공하는 행동이다.<br>클라이언트의 관점에서 객체가 수행하는 행동이란 곧 객체의 책임을 의미한다.<br>객체는 협력에 참여하기 위해 존재하며 협력안에서 수행하는 책임이 객체의 존재가치를 증명한다.</p><p>따라서 <strong>이 객체가 수행해야 하는 일은 무엇인가?</strong> -&gt; <strong>이 객체가 이 일을 수행하기 위해 필요한 데이터는 무엇인가?</strong>  의 순서로 접근해야 한다.</p><h1 id="협력이라는-문맥-안에서-책임을-결정하라">협력이라는 문맥 안에서 책임을 결정하라</h1><p>객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정된다.</p><ul><li>객체에 할당된 책임이 협력에 어울리지 않는다면 그 책임은 나쁜 책임이다.</li><li>책임이 조금 어색해도 협력에 적합하다면 그 책임은 좋은 것이다.</li><li>책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다.</li><li>협력에 적합한 책임이란 메세지 수신자가 아닌 메세지 전송자에게 적합한 책임이다.<ul><li>메세지를 실제로 요청하는 입장에서 메서드를 작성한다.</li></ul></li><li>협력에 적합한 책임을 수확하기 위해서는 메세지를 결정한 후에 객체를 선택해야 한다.<ul><li>~한 일을 해야 하는데 ~객체를 사용해야 한다.</li><li>메세지를 전송해야하는데 누구한테 전송하지?</li></ul></li><li>클라이언트는 단지 임의의 객체가 메세지를 수신할 것이라는 사실을 믿고 자신의 의도를 표현한 메세지를 전송할 뿐이다<ul><li>실제 메세지를 수신하는 객체가 메세지를 처리할 <code>책임</code>을 할당 받게 된다.</li></ul></li></ul><h1 id="책임-주도-설계의-흐름">책임 주도 설계의 흐름</h1><ol><li>시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.</li><li>시스템 책임을 더 작은 책임으로 분할한다.</li><li>분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.</li><li>객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다</li><li>해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.</li></ol><p>책임 주도 설계의 핵심은 책임을 결정한 후에 책임을 수행할 객체를 결정하는 것이다.<br>협력에 참여하는 객체들의 책임이 어느정도 정리될 때 까지는 객체의 내부 상태에 대해 관심을 가지지 않는 것이다.</p><h1 id="grasp-패턴">GRASP 패턴</h1><p>GRASP (General Responsibility Assignment Software Pattern)의 약자로 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것이다.</p><h2 id="도메인-개념에서-출발하기">도메인 개념에서 출발하기</h2><p>설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려 보는 것이 유용하다<br>따라서 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념이다.</p><p><img src="./domain.jpeg" alt="domain"></p><p>설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요는 없다.<br>중요한 것은 설계를 시작하는 것이지 도메인 개념들을 완벽하게 정리하는 것이 아니다.<br>도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현으로 넘어가는 것이 좋다.</p><h2 id="정보-전문가에게-책임을-할당하라">정보 전문가에게 책임을 할당하라</h2><p>책임 주도 설계 방식의 첫 단계는 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것이다.책임의 관점에서 질문을 해본다.</p><ol><li>메세지를 전송할 객체는 무엇을 원하는가?</li><li>메세지를 수신할 적합한 객체는 누구인가?</li></ol><p>이 질문에 답하기 위해서는 객체가 <strong>상태와 행동을 통합한 캡슐화의 단위</strong>라는 사실에 집중해야 한다.<br>객체는 자신의 상태를 스스로 처리하는 자율적인 존재여야 한다.<br>따라서 객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다.<br>이를 <strong>INFORMATION EXPERT(정보 전문가) 패턴</strong>이라고 부른다.</p><blockquote><p>INFORMATION EXPERT(정보 전문가) 패턴<br>책임을 정보 전문가. 즉 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하라<br>INFORMATION EXPERT(정보 전문가) 패턴은 객체가 자율적인 존재여야 한다는 사실을 한번 더 상기시킨다.<br>정보를 알고 있는 객체만이 책임을 어떻게 수행할지 스스로 결정할 수 있기 때문이다.</p><p>INFORMATION EXPERT(정보 전문가) 패턴을 따르면 정보와 행동을 최대한 가까운 곳(=같은 클래스 내)에 위치 시키기 때문에 캡슐화를 유지할 수 있다.<br>필요한 정보를 가진 객체들로 책임이 분산되기 때문에 더 응집력 있고, 이해하기 쉬워진다.<br>따라서 높은 응집도, 낮은 결합도를 가진 시스템을 구축할 수 있다.</p></blockquote><p><strong>책임을 수행하는 객체가 정보를 <code>알고</code> 있다고 해서 반드시 그 정보를 저장하는 변수를 만들 필요는 없다.</strong><br>다른 객체의 도움을 받아 전달받을 수도 있기 때문이다.</p><h1 id="low-copling낮은-결합도-패턴">LOW COPLING(낮은 결합도) 패턴</h1><p>어떻게 하면 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있을까?<br>설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라.</p><p>낮은 결합도는 모든 설계 결정에서 염두에 둬야 하는 원리다. 다시 말해 설계 결정을 평가할 때 적용할 수 있는 평가원리다.<br>현재의 책임 할당을 검토하거나 여러 설계 대안들이 있을 때 낮은 결합도를 유지할 수 있는 설계를 선택해야한다.</p><h1 id="high-cohesion높은-응집도-패턴">HIGH COHESION(높은 응집도) 패턴</h1><p>어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가? 높은 응집도를 유지할 수 있게 책임을 할당하라</p><p>낮은 결합도처럼 높은 응집도 역시 모든 설계 결정에서 염두에 둬야 할 원리다.<br>다시 말해 설계 결정을 평가할 때 적용할 수 있는 평가 원리다.<br>현재의 책임 할당을 검토하고 있거나 여러 설계 대안 중 하나를 선택해야 한다면 높은 응집도를 유지할 수 있는 설계를 선택해야 한다.</p><h2 id="클래스-응집도-판단하기">클래스 응집도 판단하기</h2><ul><li>클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다. 변경의 이유를 기준으로 클래스를 분리하라<ul><li>다양한 기능이 짬뽕된 클래스이다</li></ul></li><li>클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다.<br>초기화되는 속성의 그룹을 기준으로 클래스를 분리하라<ul><li>인스턴스 생성 시, 모든 변수가 다 초기화 되어야 한다.</li><li>어떤 변수는 초기화 되고 어떤 변수는 초기화가 되지않으면 초기화가 되는 변수들 끼리 묶어서 클래스를 분리한다</li></ul></li><li>메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다.<br>이들 그룹을 기준으로 클래스를 분리하라<ul><li>메서드 내에서 클래스내의 변수를 사용해야 한다.</li><li>메서드 2개에서 사용하는 변수들이 틀리다면 변수들을 기준으로 클래스를 분리 해야한다.</li></ul></li><li>메서드가 너무 긴 경우 private 메서드로 잘게 쪼개면 숨겨진 문제점이 드러나는 경우가 많다</li></ul><h1 id="creator-패턴">CREATOR 패턴</h1><p>객체 A를 생성해야 할 떄 어떤 객체에게 객체 생성 책임을 할당해야 하는가? 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라.</p><ul><li>B가 A 객체를 포함하거나 참조한다.</li><li>B가 A 객체를 기록한다</li><li>B가 A 객체를 긴밀하게 사용한다</li><li>B가 A 객체를 초기화 하는데 필요한 데이터를 가지고 있다 (이 경우 B는 A에 대한 정보 전문가다)</li></ul><p>CREATOR 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.<br>생성될 객체에 대해 잘 알고 있어야 하거나 그 객체를 사용해야 하는 객체는 어떤 방식으로든 생성될 객체와 연결될 것이다.<br>다시 말해 두 객체는 서로 결합된다.</p><p>이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다.<br>결과적으로 CREATOR 패턴은 이미 존재하는 객체 사이의 관계를 이용하기 때문에 설계가 낮은 결합도를 유지할 수 있게 해준다.</p><h1 id="polymorphism-패턴">POLYMORPHISM 패턴</h1><p>객체의 타입에 따라 변하는 로직이 있을 때 변하는 로직을 담당할 책임을 어떻게 할당해야 하는가?<br>타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하라</p><p>조건에 따른 변화는 프로그램의 기본 논리다. <strong>프로그램을 if-else 또는 switch case 등의 조건 논리를 사용해서 설계</strong>한다면<br>새로운 변화가 일어난 경우 조건 논리를 수정해야 한다.<br><strong>이것은 프로그램을 수정하기 어렵고 변경에 취약하게 만든다.</strong></p><p>POLYMORPHISM 패턴은 객체의 타입을 검사해서 타입에 따라 여러 대안들을 수행하는 조건적인 논리를 사용하지 말라고 경고 한다.<br>대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하라고 권고한다.</p><h1 id="protected-variations-패턴">PROTECTED VARIATIONS 패턴</h1><p>객체, 서브시스템 그리고 시스템을 어떻게 설계해야 변화와 불안정성이 다른 요소에 나쁜 영향을 미치지 않도록 방지할 수 있을까?<br>변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라</p><p>PROTECTED VARIATIONS 패턴은 책임 할당의 관점에서 캡슐화를 설명한 것이다. <strong>&quot;설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화하라&quot;</strong> 라는 객체지향의 오랜격언은 PROTECTED VARIATIONS 패턴의 본질을 잘 설명해준다.</p><p>우리가 캡슐화해야 하는 것은 변경이다.</p><p><strong>변경될 가능성이 높은가? 그렇다면 캡슐화를 해야한다.</strong></p><h1 id="리팩터링">리팩터링</h1><p>책임 주도 설계에 익숙해지기 위해서는 부단한 노력과 시간이 필요하다.<br>한번에 하기 힘들기에 일단은 <strong>절차지향적 방식</strong>으로 프로그램을 구성한 다음에 리팩터링을 통해 <strong>책임 주도 설계로 전환</strong>하는 방법을 사용해보자</p><h2 id="긴-메서드의-단점">긴 메서드의 단점</h2><ul><li>어떤 일을 수행하는지 한눈에 파악하기 어렵기 때문에 코드를 이해하는데 많은 시간이 걸린다.</li><li>하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.</li><li>메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다</li><li>로직의 일부만 재사용하는 것이 불가능하다</li><li>코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣는 것뿐이므로 코드 중복을 초래하기 쉽다.</li></ul><h2 id="이해하기-쉬운-메서드">이해하기 쉬운 메서드</h2><ul><li>메서드가 잘게 나눠진 메서드 (재사용성이 높아진다.)</li><li>고수준의 메서드를 볼때 간략한 코드만으로 어떤 기능을 수행하는지 알 수 있다.</li><li>메서드 이름만으로도 무슨 기능을 수행하는지 파악할 수 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter5. 책임 할당하기</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2020/05/17/object-chapter5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Objects Study - Chapter4. 설계 품질과 트레이드오프</title>
      <link>https://jaehun2841.github.io/2020/05/16/object-chapter4/</link>
      <guid>https://jaehun2841.github.io/2020/05/16/object-chapter4/</guid>
      <pubDate>Sat, 16 May 2020 07:20:24 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;데이터-중심의-설계&quot;&gt;데이터 중심의 설계&lt;/h1&gt;
&lt;p&gt;객체지향 설계에는 두 가지 방법을 이용해 시스템을 객체로 분할할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터를 분할의 중심축으로 삼는 방법 (Entity를 먼저 정의하고 비지니스 로직 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="데이터-중심의-설계">데이터 중심의 설계</h1><p>객체지향 설계에는 두 가지 방법을 이용해 시스템을 객체로 분할할 수 있다.</p><ul><li>데이터를 분할의 중심축으로 삼는 방법 (Entity를 먼저 정의하고 비지니스 로직 구현)<ul><li>데이터 중심의 관점에서는 객체는 <strong>자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의</strong></li><li>객체는 독립된 데이터 덩어리처럼 바라본다</li></ul></li><li>책임을 분할의 중심축으로 삼는 방법 (Interface 기반의 비지니스 로직을 구현하고 필요한 속성을 정의)<ul><li>객체는 다른 객체가 요청할 수 있는 <strong>오퍼레이션을 위해 필요한 데이터만 생성</strong>하는 정도</li><li>객체랑 협력하는 공동체의 일환으로 바라본다</li></ul></li></ul><h1 id="데이터-중심-설계가-안-좋은-이유">데이터 중심 설계가 안 좋은 이유</h1><p>객체지향 설계는 데이터가 아닌 책임에 초점을 맞춰야한다.</p><ul><li><p>객체의 상태는 구현에 속한다</p></li><li><p>구현은 불안정하기 때문에 변화하기 쉽다</p></li><li><p>상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들어 캡슐화가 무너진다.</p></li><li><p>상태 변경 -&gt; 인터페이스의 변경 -&gt; 의존성을 갖는 객체에게 변경 영향이 퍼짐</p></li><li><p>데이터에 초점을 맞추는 설계는 변경에 취약하다</p></li><li><p>객체의 내부 구현을 인터페이스의 일부로 만든다. <strong>(캡슐화 위반)</strong></p><ul><li>getter/setter와 같은 메서드가 퍼블릭으로 생성되어 어디서든 접근이 가능하다</li></ul></li></ul><h1 id="데이터-중심-설계의-문제점">데이터 중심 설계의 문제점</h1><p>데이터 중심 설계가 변경에 취약한 이유는 두 가지이다.</p><ul><li>데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 한다.<ul><li>데이터 중심으로 클래스를 구성하다 보면 책임에 대해 무감각해져 캡슐화를 위반하기 쉽다.</li><li>데이터 중심 관점에서는 객체란 그냥 데이터 덩어리이기 때문에 별도로 분리된 객체에서 로직을 구현하게 된다.<ul><li>이는 getter/setter의 남용을 불러온다.</li><li>이로 인해 캡슐화가 무너진다.</li></ul></li><li>데이터를 먼저 잡고 오퍼레이션을 잡기 때문에 데이터에 대한 정보가 인터페이스로 외부에 표현된다.</li><li>따라서 객체 내부 구현이 객체의 인터페이스를 어지럽히고 객체의 응집도와 결합도에 나쁜 영향을 준다. (변경에 취약)</li></ul></li><li>데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.<ul><li>올바른 객체지향 설계의 무게중심은 항상 객체 내부가 아니라 외부에 포커스가 가야한다.</li><li>내부에서 어떤 상태를 가지고 뭘하는지는 부가적인 문제이다.</li><li>항상 다른 객체와 어떻게 협력하는지 부터 생각해야 한다.</li><li>데이터 중심 설계에서는 이미 구현(=데이터)가 결정된 상태에서 다른 객체와의 협력을 고려하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워 맞출 수 밖에 없다.</li><li>따라서 내부가 변경되면 협력하는 객체 모두가 영향을 받게 된다.</li></ul></li></ul><h1 id="데이터-중심-설계에서-빠지는-착각">데이터 중심 설계에서 빠지는 착각</h1><p>데이터 중심으로 객체를 설계하다보면 객체가 필요한 데이터에 집중하게 된다.<br>이는 예전 DB 기반의 설계를 하던 것과 유사하다</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> Duration runningTime;</span><br><span class="line">  <span class="keyword">private</span> Money fee;</span><br><span class="line">  <span class="keyword">private</span> List&lt;DiscountCondition&gt; discountConditions;</span><br><span class="line">  <span class="keyword">private</span> MovieType movieType;</span><br><span class="line">  <span class="keyword">private</span> Money discountAmount;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> discountPercent;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Duration <span class="title">getRunningTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.runningTime;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Money <span class="title">getFee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fee;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunningTime</span><span class="params">(Duration runningTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.runningTime = runningTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFee</span><span class="params">(Money fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fee = fee;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>객체지향의 가장 중요한 원칙은 캡슐화가 맞다.<br>내부 데이터가 객체를 빠져나가 외부의 다른 객체들을 오염시키는 것을 막아야 한다.<br>이를 위한 가장 간단한 방법은 위의 코드와 같이 접근자(getter) / 수정자(setter)를 추가하는 것이다.</p><p>위와 같은 코드는 직접 객체의 내부에 접근할 수 없기 때문에 캡슐화의 원칙을 지키고 있는 것 처럼 보인다.<br>하지만 위의 예시는 객체 내부 상태에 대한 어떤 정보도 캡슐화하지 못한다.<br>getter/setter는 <strong>객체 내부에 Title, RunningTime, Fee라는 인스턴스 변수가 존재한다는 사실을  public 인터페이스에 노골적으로 드러낸다.</strong></p><p>캡슐화를 한다고 코드를 위와같이 짰지만 캡슐화를 위반하는 코드가 되는 셈이다.</p><h1 id="캡슐화">캡슐화</h1><p>객체지향에서 가장 중요한 원리는 캡슐화다.</p><ul><li><p>외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다</p></li><li><p>불안정한 구현의 세부 사항을 안정적인 인터페이스 뒤로 숨기는 것이다.</p></li><li><p>캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다.</p></li><li><p>즉, 캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다.</p></li></ul><h2 id="구현과-인터페이스">구현과 인터페이스</h2><ul><li>구현이란 변경될 가능성이 높은 부분을 의미한다<ul><li>변경될 가능성이 높은 부분은 객체 내부로 숨겨야 한다.</li><li>한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 조절하기 위해서다</li></ul></li><li>인터페이스란 상대적으로 안정적인 부분이다.</li></ul><h1 id="응집도와-결합도">응집도와 결합도</h1><p>객체 지향에서의 좋은 설계란, 높은 응집도와 낮은 결합도로 가진 모듈로 구성된 설계를 의미한다.</p><ul><li>응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.<ul><li>모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면, 그 모듈은 높은 응집도를 가진다.</li><li>모듈 내의 요소들이 서로 다른 목적을 추구 한다면 그 모듈은 낮은 응집도를 가진다.</li><li>객체지향 관점에서 응집도는 객체 또는 클래스에 얼마나 높은 책임들을 할당했는지 나타낸다.</li><li>쉽게 말하면 객체 하나가 이 일 저 일 다하면 응집도가 낮은것이다.</li></ul></li><li>결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많이 알고 있는지를 나타낸다.<ul><li>A 모듈이 B 모듈에 대해 너무 자세한 구현부까지 알고 있다면 두 모듈은 높은 결합도를 가진다.</li><li>A 모듈이 B 모듈에 대해 간단한 인터페이스정도만 알고 있다면 두 모듈은 낮은 결합도를 가진다.</li><li>결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있다.</li></ul></li></ul><h2 id="높은-응집도와-낮은-결합도를-추구-해야하는-이유">높은 응집도와 낮은 결합도를 추구 해야하는 이유</h2><p><strong>변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.</strong></p><ul><li>하나의 변경에 의해 여러개의 모듈이 변경되면 <strong>응집도가 낮다</strong>, <strong>결합도가 높다</strong></li><li>하나의 변경에 의해 하나의 모듈이 변경되면 <strong>응집도가 높다</strong>, <strong>결합도가 낮다</strong></li></ul><p>클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.</p><h2 id="결합도가-높아도-상관-없는-경우도-있다">결합도가 높아도 상관 없는 경우도 있다</h2><p>일반적으로 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것은 아무런 문제가 되지 않는다.<br>표준 라이브러리에 포함된 모듈이나 성숙 단계에 접어든 프레임 워크에 의존하는 경우가 여기에 속한다.<br>ex) String, ArrayList와 같은 클래스는 변경될 확률이 매우 낮기 때문에 결합도에 대해 고민할 필요가 없다</p><p>하지만 직접 작성한 코드는 항상 불안정하며 언제라도 변경될 가능성이 높기 때문에 주의해야 한다.<br><strong>이런 높은 응집도와 낮은 응집도를 실현하기 위해서는 캡슐화를 향상 시키면 된다.</strong></p><h1 id="캡슐화를-항상-생각하자">캡슐화를 항상 생각하자</h1><ul><li>캡슐화는 설계의 제 1원칙이다.</li><li>데이터 중심의 설계가 낮은 응집도와 높은 결합도라는 문제로 몸살을 앓게 된 근본적인 원인은 바로 캡슐화를 위반했기 때문이다.</li><li>객체는 자신이 어떤 데이터를 가지고 있는지를 내부에서만 알아야 하고 외부에 공개하면 안된다.  (getter/setter를 만들지 마라)</li></ul><h2 id="rectangle-클래스로-보는-캡슐화의-중요성">Rectangle 클래스로 보는 캡슐화의 중요성</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> left;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> right;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> bottom;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.left = left;</span><br><span class="line">    <span class="keyword">this</span>.top = top;</span><br><span class="line">    <span class="keyword">this</span>.right = right;</span><br><span class="line">    <span class="keyword">this</span>.bottom = bottom;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeft</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> left; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(<span class="keyword">int</span> left)</span> </span>&#123; <span class="keyword">this</span>.left = left &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRight</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> right; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(<span class="keyword">int</span> right)</span> </span>&#123; <span class="keyword">this</span>.right = right &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTop</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> top; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTop</span><span class="params">(<span class="keyword">int</span> top)</span> </span>&#123; <span class="keyword">this</span>.top = top &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBottom</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bottom; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBottom</span><span class="params">(<span class="keyword">int</span> bottom)</span> </span>&#123; <span class="keyword">this</span>.bottom = bottom &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">anyMethod</span><span class="params">(Rectangle rectangle, <span class="keyword">int</span> multiple)</span> </span>&#123;</span><br><span class="line">    rectangle.setRight(rectangle.getRight() * multiple)</span><br><span class="line">    rectangle.setBottom(rectangle.getBottom() * multiple)</span><br><span class="line">    rectangle.setLeft(rectangle.getLeft() * multiple)</span><br><span class="line">    rectangle.setTop(rectangle.getTop() * multiple)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같은 코드는 많은 문제점이 있다.</p><ul><li><code>코드중복</code>이 발생할 확률이 높다.<ul><li>다른 곳에서도 사각형의 너비와 높이를 증가시키는 코드가 필요하면 또 이 코드를 작성해야 한다.</li><li>악의 근원인 setter를 남발하고 있다.</li></ul></li><li>변경에 취약하다<ul><li>Rectangle이 right와 bottom 대신 length와 height를 이용해서 사각형을 표현하게 되면 여러 부분에 코드를 수정해야 한다.</li><li>이런 변경은 기존 getter/setter를 사용하던 코드 전반적으로 영향을 미치게 된다</li></ul></li></ul><p>해결 방법은 캡슐화를 강화시키는 것이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enlarge</span><span class="params">(<span class="keyword">int</span> multiple)</span> </span>&#123;</span><br><span class="line">    right *= multiple;</span><br><span class="line">    bottom *= multiple;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>자신의 크기를 코드 외부에서 증가시키는 것이 아닌 Rectangle 클래스 내부에서 스스로 할 수 있도록 <strong>책임을 이동하였다.</strong></p><h1 id="캡슐화의-진정한-의미">캡슐화의 진정한 의미</h1><p>캡슐화는 단순히 객체 내부의 데이터를 외부로부터 감추는 것 이상의 의미를 가진다.<br>사실 상 변경될 수 있는 어떤 것이라도 감추는 것이 진정한 캡슐화이다.<br>내부 속성을 외부로 부터 감추는 것은 <strong>데이터 캡슐화</strong>라고 불리는 캡슐화의 한 종류일 뿐이다.<br><strong>만약 클래스 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는 다면 그것은 캡슐화를 위반한 것이다.</strong><br>정리하자면 캡슐화란 무엇이든 변하는 것은 감추는 것이다.</p><h1 id="참고">참고</h1><ul><li>​Objects(코드로 이해하는 객체지향 설계) - Chapter4. 설계 품질과 트레이드오프</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2020/05/16/object-chapter4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Objects Study - Chapter3. 역할, 책임, 협력</title>
      <link>https://jaehun2841.github.io/2020/05/10/object-chapter3/</link>
      <guid>https://jaehun2841.github.io/2020/05/10/object-chapter3/</guid>
      <pubDate>Sun, 10 May 2020 09:10:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;역할-책임-협력&quot;&gt;역할, 책임, 협력&lt;/h1&gt;
&lt;p&gt;객체지향 패러다임의 관점에서의 핵심은 역할(role), 책임(responsibility), 협력(collaboration)이다.&lt;br&gt;
애플리케이션의 기능을 구현하기 위해 &lt;strong
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="역할-책임-협력">역할, 책임, 협력</h1><p>객체지향 패러다임의 관점에서의 핵심은 역할(role), 책임(responsibility), 협력(collaboration)이다.<br>애플리케이션의 기능을 구현하기 위해 <strong>어떤 협력이 필요하고</strong> 협력을 위해 <strong>어떤 역할과 책임이 필요한지</strong> 고민하지 않은 채 너무 이른 시기에 구현에만 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.</p><ul><li>협력: 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용</li><li>역할: 객체들이 협력안에서 수행하는 책임들을 일컫는 말 (= 인터페이스라 의역하면 이해가 쉽다)</li><li>책임: 객체가 협력에 참여하기 위해 수행하는 로직 (= 인터페이스 구현체 또는 객체)</li></ul><h1 id="협력">협력</h1><p>협력은 객체지향 세계에서 기능을 구현할 수 있는 유일한 방법이다.<br>하나의 객체가 모든 일을 처리하는 것이 아닌 각각의 역할을 수행할 수 있는 객체들간의 <strong>메세지 전송</strong>이라는 커뮤니케이션 수단을 이용하여 객체 간 협력을 통해 애플리케이션 기능을 수행할 수 있다.</p><blockquote><p><strong>협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다.</strong><br>한 객체는 어떤 것이 필요할 때 다른 객체에게 전적으로 위임하거나 서로 협력한다.<br>즉, 두 객체가 상호작용을 통해 더 큰 책임을 수행하는 것이다.<br>객체 사이의 협력을 설계할 때는 <strong>객체를 서로 분리된  인스턴스가 아닌 협력하는 파트너로 인식해야한다.</strong></p></blockquote><p>자율적인 객체는 자신에게 할당된 책임을 수행하던 중 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메세지를 전송해서 협력을 요청한다.</p><p>객체들 사이의 협력을 구성하는 일련의 요청과 응답을 통해 애플리케이션의 기능이 구현된다.</p><h1 id="협력이-설계를-위한-문맥을-결정한다">협력이 설계를 위한 문맥을 결정한다.</h1><ul><li>애플리케이션 안에서 객체가 필요하다면 그 이유는 단 하나여야 한다. (그 객체가 어떠한 협력에 참여하고 있기 때문)</li><li>객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 가지고 있기 때문이다.</li><li>객체는 행동(action)과 상태(state)로 구성된다.<ul><li>행동(action)은 협력 안에서 객체가 처리할 메세지</li><li>상태(state)는 객체가 행동하는데 필요한 정보</li></ul></li><li>협력은 객체를 설계하는데 필요한 일종의 context를 제공한다.</li></ul><h1 id="책임">책임</h1><p>책임이란, 협력에 참여하기 위해 객체 수행하는 행동(action)이라 부른다.<br>책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합으로 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장이다.<br>즉, 객체의 책임은 <strong>'무엇을 알고 있는가'</strong>, <strong>'무엇을 할 수 있는가'</strong> 로 구성된다.</p><p><strong>하는 것</strong></p><ul><li>객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것</li><li>다른 객체의 행동을 시작시키는 것 (메세지를 전송하는 것)</li><li>다른 객체의 활동을 제어하고 조절하는 것</li></ul><p><strong>아는 것</strong></p><ul><li>사적인 정보에 관해 아는 것</li><li>관련된 객체에 관해 아는 것 (의존성)</li><li>자신이 유도하거나 계산할 수 있는 것에 대해 아는 것</li></ul><p>책임은 객체지향 설계의 핵심이다.<br><strong>객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것</strong><br>사실 협력이 중요한 이유는 객체에게 할당할 책임을 결정할 수 있는 문맥을 제공하기 때문이다.</p><h1 id="책임-주도-설계">책임 주도 설계</h1><p>협력을 설계하기 위해서는 책임에 초점을 맞춰야 한다.<br>어떤 책임을 선택하느냐가 전체적인 설계의 방향과 흐름을 결정하기 때문이다.<br>이처럼 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을<br><strong>책임 주도 설계(Responsibility-Driven Design, RDD)</strong> 라고 부른다</p><h2 id="책임-주도-설계-방법">책임 주도 설계 방법</h2><ol><li>시스템이 사용자에게 제공해야 하는 기능인 시스템의 책임을 판단한다.<ul><li>sms 전송요청 받은 요청을 sms로 보낼 수 있다.</li></ul></li><li>시스템 책임을 더 작은 책임으로 분할한다.<ul><li>sms 요청을 가공한다.</li><li>가공된 sms 요청을 벤더사로 전송한다.</li></ul></li><li>분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.<ul><li>sms 요청을 가공한다. -&gt; MessageTransformer</li><li>가공된 sms 요청을 벤더사로 전송한다. -&gt; MessageVenderSender</li></ul></li><li>객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.<ul><li>sms 요청을 Template 기반으로 변경한다. -&gt; TemplateMessageTransformer</li><li>발신번호가 예전 번호인 경우 신규 발신번호로 변경한다. -&gt; LegacySendNumberExchanger</li></ul></li><li>해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.</li></ol><p>예시<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmsSendRequest</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> sendNo: String,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> recipientNo: String,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> templateId: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MessageTransformer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(smsSendRequest: <span class="type">SmsSendRequest</span>)</span></span>: VendorMessageSendRequest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateMessageTransformer</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> templateLoader: TemplateLoader</span><br><span class="line">): MessageTransformer() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(smsSendRequest: <span class="type">SmsSendRequest</span>)</span></span>: VendorMessageSendRequest &#123;</span><br><span class="line">    <span class="keyword">val</span> template = templateLoader.findByTemplateId(templateId)</span><br><span class="line">    <span class="keyword">return</span> VendorMessageSendRequest(</span><br><span class="line">      sendNo = smsSendRequest.sendNo,</span><br><span class="line">      recipientNo = smsSendRequest.reciepientNo,</span><br><span class="line">      title = template.title,</span><br><span class="line">      contents = template.contents</span><br><span class="line">    )  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmsSendProcessor</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> messageTransformer: MessageTransformer</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> legacySendNumberExchanger: LegacySendNumberExchanger</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> messageVenderSender: MessageVenderSender</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">sendSms</span><span class="params">(smsSendRequest: <span class="type">SmsSendRequest</span>)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    legacySendNumberExchanger.exchange(smsSendRequest)</span><br><span class="line">    <span class="keyword">val</span> vendorMessageSendRequest = messageTransformer.transform(smsSendRequest)</span><br><span class="line">    </span><br><span class="line">    messageVenderSender.sendTo(vendorMessageSendRequest)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="메세지가-객체를-결정한다">메세지가 객체를 결정한다.</h2><p>객체에게 책임을 할당하는 데 필요한 메세지를 먼저 식별하고 메세지를 처리할 객체를 나중에 선택하는 것이 중요하다</p><p>이유는 2가지가 있다.</p><ol><li>객체가 최소한의 인터페이스를 가질 수 있게 된다.<ul><li>필요한 메세지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않게 된다.</li><li>객체는 꼭 필요한 퍼블릭 인터페이스만 가질 수 있다.</li></ul></li><li>객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.<ul><li>객체의 인터페이스는 무엇을 하는지?는 표시해야하지만 어떻게 하는지는 노출하면 안된다.</li><li>메세지는 외부의 객체가 요청하는 무언가를 의미하기 때문에<br>메세지를 먼저 식별하면 무엇을 수행할지에 초점을 맞추는 인터페이스를 얻을 수 있다.</li></ul></li></ol><h2 id="행동이-상태를-결정한다">행동이 상태를 결정한다.</h2><p>객체가 존재하는 이유는 협력에 참여하기 위해서다.<br>따라서 객체는 협력에 필요한 행동을 제공해야 한다.<br>그렇기 때문에 객체는 상태보다는 행동에 초점을 맞춰야 한다.</p><p>적절한 객체를 만들었는지에 대한 기준은 얼마나 적절한 책임을 할당했느냐에 달려 있고, 책임이 얼마나 적절한지는 협력에 얼마나 적절한가에 달려있다.</p><p>객체지향 패러다임에서 <strong>가장 쉽게 하는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것이다.</strong><br>객체의 행동을 고려하지 않고 일단 필드부터 정의하고 보는 행동이다.<br>이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다.</p><p>상태란, 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료에 지나지 않는다.</p><h1 id="역할">역할</h1><p>객체는 협력이라는 주어진 문맥 안에서 특정한 목적을 갖게 된다.<br>객체의 목적은 협력 안에서 객체가 맡게 되는 책임의 집합으로 표시된다.<br>이처럼 <strong>객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합</strong>을 <strong>역할</strong>이라고 부른다.</p><p>역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문이다. (like 인터페이스)<br>인터페이스와 같이 협력 안에서 객체를 바꿔낄 수 있는 슬롯의 역할을 한다.</p><p>따라서 책임과 역할을 중심으로 협력을 바라보는 것이 바로 변경과 확장이 용이한 유연한 설계로 나아가는 첫걸음이다.</p><h2 id="객체-vs-역할">객체 vs 역할</h2><p>만약 오직 한 종류의 객체만 협력에 참여하는 상황이라면 역할이라는 개념을 추가하는 것이 과연 좋을까?<br>역할의 개념을 생략하고 바로 협력에 객체를 이용하는 것이 좋지 않을까?<br>(spring에서 하나의 service를 사용하는 과정에서 굳이 인터페이스를 만들어야 할까 말아야 할까와 같다)</p><p>레베카 워브스브록은</p><blockquote><p>협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 필요가 있다면 그 후보는 역할이 되지만,<br>단지 한 종류의 객체만이 협력에 참여할 필요가 있다면 후보는 객체가 된다.</p></blockquote><p>(즉, 하나의 Service만 필요하다면 클래스 기반의 Service를 만들면 되고, 2개 이상의 Service가 필요하다면 인터페이스 기반의 Service를 만들면 된다.)</p><p><strong>만약 서비스 개발 초반에 역할과 객체를 구분하는 것이 애매하다면 일단 객체로 시작해보자</strong><br><strong>객체로 시작하게 되면 자연스럽게 반복되고 중복되는 코드가 등장하게 되고 그때 역할로 분리해 내면 된다.</strong></p><p>협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용이 가능해진다.<br>역할의 가장 큰 장점은 설계의 구성 요소를 추상화할 수 있다는 점이다.</p><h2 id="역할과-추상화">역할과 추상화</h2><p>추상화는 2가지 장점이 있다.</p><ol><li>추상화 계층만을 이용하면 중요한 정책을 상위 수준에서 단순화 할 수 있다.<ul><li>역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화로 볼 수 있다.</li><li>협력이라는 관점에서는 세부적인 구현보다는 추상적인 책임에 집중하는게 유용하다.</li></ul></li><li>설계가 좀 더 유연해 진다.<ul><li>역할은 다양한 종류의 객체를 끼워 넣을 수 있는 슬롯이기 때문에 서로 대체가 가능하다</li><li>역할은 다양한 환경에서 다양한 객체들을 수용할 수 있게 해주기 때문에 협력에 유연하다</li></ul></li></ol><h1 id="참고">참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - Chapter3. 역할, 책임, 협력</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2020/05/10/object-chapter3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Objects Study - Chapter2. 객체지향 프로그래밍</title>
      <link>https://jaehun2841.github.io/2020/05/10/object-chapter2/</link>
      <guid>https://jaehun2841.github.io/2020/05/10/object-chapter2/</guid>
      <pubDate>Sun, 10 May 2020 06:43:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;객체지향을-설계하는-방법&quot;&gt;객체지향을 설계하는 방법&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;클래스가 아닌 실제 working하는 instance(객체)에 초점을 둔다.&lt;/li&gt;
&lt;li&gt;클래스는 객체들의 특징을 추상화 한 것&lt;/li&gt;
&lt;li&gt;클래스 -&amp;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="객체지향을-설계하는-방법">객체지향을 설계하는 방법</h1><ul><li>클래스가 아닌 실제 working하는 instance(객체)에 초점을 둔다.</li><li>클래스는 객체들의 특징을 추상화 한 것</li><li>클래스 -&gt; 객체가 아닌 객체들을 정의하고 객체들의 특징을 기반으로 클래스를 정의한다.</li><li>객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다.</li><li>객체는 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 구성원의 일원으로 봐야한다.<ul><li>객체를 협력하는 공동체의 일원으로 바라보게 되면 설계를 유연하고 확장 가능하게 만든다.</li></ul></li></ul><p>따라서 객체를 나열 -&gt; 타입으로 분류 -&gt; 클래스 작성 하는 순서를 따르는 것이 좋다.</p><h1 id="도메인-구조를-따르는-프로그램-구조">도메인 구조를 따르는 프로그램 구조</h1><p>도메인이란? 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야<br>도메인 개념을 구현하기 위해 클래스를 사용<br>클래스 이름은 도메인 개념과 동일하거나 최대한 유사하게 짓는다.</p><h1 id="클래스를-설계할-때는-내부와-외부로-나눈다">클래스를 설계할 때는 내부와 외부로 나눈다.</h1><ul><li>내부는 private, 외부에 공개할 것은 public으로 만든다.</li><li>경계의 명확성이 객체의 자율성을 보장한다.</li><li>클래스를 사용하는 입장에서는 public으로 공개된 인터페이스만 알면 된다. (내부의 구현에 대해서는 알 필요가 없다.)</li><li>클래스를 만들고 수정하는 입장에서는 private으로 된 부분은 클래스 외부에서 참조 하지 않으니 마음대로 구현을 변경해도 된다.</li><li>이러한 내/외부의 경계를 잘 나눠야 하는 이유는 변경을 관리 하기 위해서이다.<ul><li>변경될 가능성이 있는 세부적인 구현 내용을 private 영역에 감춤으로써 변경으로 인한 혼란을 최소화 할 수 있다.</li></ul></li></ul><h1 id="객체는-상호-협력하는-존재들이다">객체는 상호 협력하는 존재들이다.</h1><ul><li>객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청할 수 있다.</li><li>요청 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답한다.</li></ul><h2 id="객체의-협력">객체의 협력</h2><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> b: B</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.method() <span class="comment">// 의존성을 가지는 B 클래스의 method 라는 메세지를 전송할 수 있다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">()</span></span> &#123; </span><br><span class="line">    doAction() </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메세지를 전송(send a message) 하는 것 뿐이다.<br>(의역하자면 다른 객체가 가지고 있는 공개된 인터페이스의 method signature를 호출한다.)</li><li>메세지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메세지를 처리할 방법을 결정한다.<br>수신된 메세지를 처리하기 위한 자신만의 방법을 메서드(method)라고 부른다.<br>(의역하자면 요청 받은 클래스의 인터페이스를 구현한 mehtod body 부분을 메서드라고 하는 것 같다.)</li><li>메세지와 메서드의 구분에서부터 다형성(polymorphism)의 개념이 출발한다.<br>(메세지 : method signature, 메서드 : 실제 method 구현부)</li></ul><h1 id="상속">상속</h1><ul><li>상속은 객체 지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.</li><li>자식 클래스는 부모 클래스가 수신할 수 있는 모든 메세지를 수신할 수 있다.<br>그렇기 때문에 자식 클래스는 부모 클래스와 동일한 Type으로 볼 수 있다.</li><li>상속은 부모 클래스의 코드를 기반으로 전혀 수정하지 않거나 일부분을 추가/수정 하여 새로운 클래스를 만들 수 있다. (코드의 재사용)<ul><li>부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 차이에 의한 프로그래밍 (programming by difference)라 한다.</li></ul></li><li>자식 클래스가 부모 클래스를 대신하는 것을 업 캐스팅(up casting)이라 한다.</li></ul><h1 id="상속의-단점">상속의 단점</h1><ul><li>상속은 캡슐화를 위반한다.<ul><li>상속을 이용하기 위해선 부모 클래스의 내부 구조를 잘 알고 있어야 한다.</li><li>부모 클래스의 구현이 자식 클래스에 노출 되기 때문에 캡슐화가 약화된다.+</li><li>캡슐화는 자식 클래스와 부모 클래스의 강결합을 만들어 부모 클래스가 변경되야 하는 경우 자식 클래스도 함께 변경되게 된다.</li><li>상속을 과도하게 사용하면 코드를 변경하기 어렵게 된다.</li></ul></li><li>설계를 유연하게 하지 못한다.<ul><li>부모 클래스와 자식 클래스의 관계를 컴파일 타임에 결정한다.</li></ul></li></ul><h1 id="합성-composition">합성 (composition)</h1><ul><li>인터페이스에 정의된 메세지를 통해서만 코드를 재사용하는 방법을 <strong>합성</strong>이라 한다.</li><li>인터페이스에 정의된 메세지를 통해서만 재사용이 가능하기 때문에 구현을 캡슐화 하기 용이하다</li><li>의존하는 인스턴스를 교체하는 것이 비교적 쉬워 설계를 유연하게 만든다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDiscountPolicy</span><span class="params">(DiscountPolicy discountPolicy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Movie avartar = <span class="keyword">new</span> Movie(<span class="keyword">new</span> AmountDiscount());</span><br><span class="line">avartar.changeDiscountPolicy(<span class="keyword">new</span> PercentDiscountPolicy());</span><br></pre></td></tr></table></figure></li></ul><h1 id="다형성">다형성</h1><ul><li>동일한 메세지를 수신할 수 있지만, 어떤 메서드가 실행될 지는 수신하는 클래스에 따라 달라진다.<br>(인터페이스의 메서드를 호출할 수 있지만 메서드의 실행은 인터페이스를 구현한 클래스에 따라 달라진다.)</li><li>실행되는 메서드는 Runtime에 결정된다.<ul><li>이를 Lazy Binding 또는 Dynamic Binding이라 한다.</li></ul></li></ul><h1 id="다형성의-trade-off">다형성의 Trade off</h1><ul><li>다형성을 사용하게 되면 코드의 의존성과 Runtime의 의존성이 서로 다를 수 있다.<ul><li>어떤 클래스를 주입하느냐에 따라 의존성이 달라진다.</li><li>하지만 코드 상으로는 인터페이스 / 추상클래스에 대한 의존성만 가지고 있다.</li></ul></li><li>확장 가능한 객체 지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다.</li><li>코드의 의존성과 실행시점의 의존성이 다르면 코드를 이해하기 어렵고 디버깅을 어렵게 만든다.</li></ul><h1 id="추상화의-힘">추상화의 힘</h1><ul><li>추상화 계층만 따로 떼어 놓고 보면 요구사항의 정책을 높은 수준에서 서술할 수 있다.<br>(뒤에 자세한 구현부는 모르겠지만 전체적인 틀을 잡기 편하다)</li><li>추상화를 이용하면 설계가 조금 더 유연해 진다.</li><li>Runtime에 주입되는 코드는 추상화를 이용해서 정의한 상위의 흐름을 따라가게 된다.</li><li>디자인 패턴(design pattern)이나 프레임워크(framework) 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 매커니즘을 활용하고 있다.</li><li>추상화를 이용하여 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.</li><li>유연성이 필요한 곳에 추상화를 사용하라</li></ul><h1 id="참고">참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - 객체지향 프로그래밍</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2020/05/10/object-chapter2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Objects Study - Chapter1. 객체, 설계</title>
      <link>https://jaehun2841.github.io/2020/05/09/object-chapter1/</link>
      <guid>https://jaehun2841.github.io/2020/05/09/object-chapter1/</guid>
      <pubDate>Sat, 09 May 2020 12:27:33 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;소프트웨어의-목적&quot;&gt;소프트웨어의 목적&lt;/h1&gt;
&lt;p&gt;Robert C. Martin은 &lt;strong&gt;클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천방법&lt;/strong&gt;에서 소프트웨어 모듈이 가져야 하는 세 가지 기능에 관해 설명한다.&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="소프트웨어의-목적">소프트웨어의 목적</h1><p>Robert C. Martin은 <strong>클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천방법</strong>에서 소프트웨어 모듈이 가져야 하는 세 가지 기능에 관해 설명한다.<br>(모듈이란, 크기와 상관 없이 클래스나 패키지, 라이브러리와 같은 프로그램을 구성하는 임의의 요소를 의미한다.)</p><ol><li>실행 중에 오류 없이 제대로 동작해야 한다.</li><li>소프트웨어는 변경을 위해 존재한다.<ul><li>대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다.</li><li>변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 한다.</li></ul></li><li>코드를 읽는 사람과 의사소통 해야 한다.<ul><li>모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다.</li><li>읽는 사람과 소통할 수 없는 모듈은 개선해야 한다.</li></ul></li></ol><h1 id="읽기-어려운-코드는-무엇일까">읽기 어려운 코드는 무엇일까?</h1><p>하나의 Class 또는 Method에서 너무 많은 항목을 다룬다.<br>다시 말해 Class, Method에서 하나 이상의 책임을 가지고 동작하는 코드이기 때문에<br>코드를 읽는 사람이 집중해야 할 부분이 많다.</p><p>코드를 작성하는 사람뿐만 아니라 코드를 읽고 이해해야 하는 사람에게 모두 부담이 된다.</p><h1 id="의존성dependency이란">의존성(Dependency)이란?</h1><p>의존성이란 하나의 객체 안에서 다른 객체에 대한 코드를 호출하는 것이다.<br>의존성은 변경이란 문제와 직결된다. (의존성을 갖는 코드를 변경하게 되면 호출하는 객체에도 수정이 필요하기 때문)<br>객체 사이의 의존성이 강한 경우를 가리켜 <strong>결합도(Coupling)</strong> 가 높다고 말한다.</p><p>좋은 소프트웨어를 설계하기 위한 목표는 결합도가 낮은 코드를 설계하는 것이다.</p><h1 id="결합도는-낮추는-방법은-무엇인가">결합도는 낮추는 방법은 무엇인가?</h1><h2 id="객체에게-자율성을-부여하자">객체에게 자율성을 부여하자</h2><p>자율성이란 객체 내부의 데이터를 변경하는 것을 객체 스스로에게 위임하는 행위를 말한다.<br>객체 내의 데이터를 다른 객체가 변경하는 것을 막는 것만으로도 결합도를 낮출 수 있다.</p><p>이 처럼 객체 스스로 자기 자신의 data를 제어하는 코드를 <strong>응집도(cohesion)</strong> 가 높은 코드라고 말한다.</p><ul><li>객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임진다.</li><li>객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 한다.</li></ul><h2 id="객체를-캡슐화-한다">객체를 캡슐화 한다</h2><p>개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 <strong>캡슐화(encapsulation)</strong> 라 한다.<br>캡슐화의 목적은 <strong>변경하기 쉬운 객체</strong> 를 만들기 위함이다.</p><ul><li>객체 내부의 접근을 제한한다.</li><li>다른 객체에서 객체 내부의 데이터를 접근하거나 수정하지 못하도록 막으면,<br>객체 내에서 일어하는 일만 수정하면 되기 때문에 하나의 Class 파일만 변경할 수 있어 변경에 용이하다.</li></ul><h2 id="의존관계는-interface에만-의존한다">의존관계는 Interface에만 의존한다</h2><p>객체를 Interface와 구현부로 나누고 Interface만 공개한다.<br>객체간의 의존성이 필요한 부분은 Interface에서 제공하는 메서드를 가지고 코드를 작성하고 실제 구현부는<br>각각의 객체에 위임한다.</p><h1 id="절차-지향-vs-객체-지향">절차 지향 vs 객체 지향</h1><p>절차 지향 프로그래밍(Procedural Programming)이란, Process (객체의 행위)와 데이터가 별도의 모듈에 위치한다.<br>객체 내의 데이터를 변경하는 주체가 모듈 내에서 변경하는 것이 아닌 다른 모듈에서 변경 시킨다.</p><p>객체 지향 프로그래밍 (Object Oriented Programming)이란, Process(객체의 행위)와 데이터가 같은 모듈 내에 위치 한다.</p><h1 id="요약">요약</h1><ul><li>변경하기 쉬운 설계는 한번에 하나만을 변경 할 수 있는 설계이다.<ul><li>설계를 어렵게 만드는 것은 의존성이다.</li><li>하나의 변경으로 인해 의존성을 갖는 여러 코드를 변경하는 것은 좋지 못하다.</li></ul></li><li>훌륭한 객체 지향 설계는 캡슐화를 이용해 의존성을 적절히 관리하여 의존성을 최대한 낮추는 것이다.<ul><li>객체 외부의 파급력이 없어서 변경이 수월하다.</li><li>캡슐화를 하면 객체의 자율성↑, 응집도↑, 결합도↓</li></ul></li><li>객체는 생물 처럼 스스로 생각하고 행동하도록 의인화하며 설계하면 도움이 된다.<ul><li>객체에 대한 적절한 책임을 위임한다.</li><li>기능은 최대한 객체에 위임한다.</li></ul></li><li>좋은 설계란, 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용 할 수 있어야 한다.<ul><li>개발을 시작하는 시점에 요구사항 분석이 100% 이루어지는 것은 불가능에 가깝다.</li><li>코드는 변화하고 살아 숨쉰다. 변화에 유연하게 대처할 수 있는 코드를 작성할 수 있는 설계를 해야 한다.</li></ul></li></ul><h1 id="참고">참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - 객체, 설계</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2020/05/09/object-chapter1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HikariCP Maximum Pool Size 설정 시, 고려해야할 부분</title>
      <link>https://jaehun2841.github.io/2020/01/27/2020-01-27-hikaricp-maximum-pool-size-tuning/</link>
      <guid>https://jaehun2841.github.io/2020/01/27/2020-01-27-hikaricp-maximum-pool-size-tuning/</guid>
      <pubDate>Mon, 27 Jan 2020 13:25:52 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이-글의-예상-독자&quot;&gt;이 글의 예상 독자&lt;/h1&gt;
&lt;p&gt;아래와 같은 에러의 원인을 찾아헤멘 개발자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 0, SQLStat
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="이-글의-예상-독자">이 글의 예상 독자</h1><p>아래와 같은 에러의 원인을 찾아헤멘 개발자</p><ul><li>o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 0, SQLState: null</li><li>o.h.engine.jdbc.spi.SqlExceptionHelper   : hikari-pool-1 - Connection is not available, request timed out after 30000ms.</li><li>unable to obtain isolated JDBC connection; nested exception is org.hibernate.exception.JDBCConnectionException: unable to obtain isolated JDBC connection</li><li>Could not open JPA EntityManager for transaction; nested exception is org.hibernate.exception.JDBCConnectionException: Unable to acquire JDBC Connection</li></ul><p>또는 HikariCP maximum pool size 설정할 때, 고려할게 있나?  그냥 대충 많이 만들어 두면 되는거 아니었어? 라고 하시는 개발자</p><h1 id="장애를-맞았습니다">장애를 맞았습니다.</h1><p><img src="./db-insert-flow.png" alt="db-insert-flow"></p><p>사내에서 사용하는 시스템의 간략한 모식도 입니다.<br>Message Queue를 통해 Data를 application에서 consume하여 consume 한 데이터를 DB에 insert하고 있습니다.</p><p><img src="./db-write-lag.png" alt="db-write-lag"></p><p>시스템 운영중 Message Queue에 많은 데이터가 한번에 유입되었습니다. 그로 인해</p><ol><li>DB에 insert하는 과정에서 쓰기지연이 발생 하였습니다.</li><li>쓰기 지연이 발생하여, Message Queue의 lag이 증가하여 많은 량의 Data를 처리하지 못하고 밀리는 상황이 되었습니다.</li></ol><p>원인은 분석하니, Message Queue Consumer Thread 갯수와 HikariCP maximum pool size간의 상관관계가 있음을 발견하였고,<br>그 과정에서 <strong>HikariCP의 Pool Size로 인한 Thread dead lock이 발생하여 Insert Query가 실패하고 있음을 알게 되었습니다.</strong><br>이번 장애를 통해 알게 된 <strong>Dead lock을 피할 수 있는 HikariCP maximum pool size 갯수</strong>를 설정하는 방법에 대해 공유하고자 합니다.</p><h1 id="hikaricp에서는-connection을-어떻게-관리하나">HikariCP에서는 Connection을 어떻게 관리하나?</h1><p>Springboot 2.x가 출범하면서 HikariCP를 default JDBC Connection Pool로 사용하고 있고,  성능이 좋고 빠르기로 이미 검증된 Connection Pool입니다.<br>이번 문제를 해결하면서 하나의 스레드가 Hikari Pool에서 커넥션을 얻고 <strong>(getConnection)</strong>, 커넥션을 반납 <strong>(close)</strong> 하는 과정을 살펴보았습니다.</p><p>아래 내용을 보시기 전에...</p><ul><li>HikariPool에서는 Connection 객체를 한번 wrapping한  PoolEntry라는 Type으로 내부적으로 Connection을 관리합니다.<br>아래 글에서는 이해를 편하게 하도록 Connection이라는 용어로 언급하도록 하겠습니다.</li><li><strong>1인칭 Thread 시점</strong>을 통해 생각해 보았습니다.</li></ul><h2 id="하나의-query가-실행되는-과정">하나의 Query가 실행되는 과정</h2><p>내부적인 코드는 더 잘 구성이 되어있지만, 간략한 코드로 표현하자면 아래와 같을 것 입니다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = <span class="keyword">null</span>;</span><br><span class="line">PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  connection = hikariDataSource.getConnection(); </span><br><span class="line">  preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">  preparedStatement.executeQuery();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(preparedStatement != <span class="keyword">null</span>) &#123;</span><br><span class="line">    preparedStatement.close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">    connection.close(); <span class="comment">// this returns the connection to the pool</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>hikariDataSource.getConnection()을 통해 hikariPool에서 Connection을 하나 얻습니다.</li><li>execute()를 통해 쿼리를 실행하고 connection.close()을 통해 hikari pool에 connection을 반납합니다.</li></ol><p>getConnection(), close()를 조금 더 내려가서 HikariPool에서의 처리를 자세하게 살펴보겠습니다.</p><h2 id="hikari님-connection-하나만-주세여">Hikari님! Connection 하나만 주세여</h2><p>Hikari Pool에서 getConnection 로직은 3단계를 통해 Connection 객체를 얻을 수 있게 되어있습니다.<br><strong>(HikariCP에서 얼마나 성능을 올리기 위해 노력했는지 코드로 보입니다.)</strong><br>Hikari CP에서는 <strong>ConcurrentBag</strong>이라는 구조체를 이용해 Connection을 관리하고 있습니다.<br><strong>HikariPool.getConnection() -&gt; concurrentBag.borrow()</strong> 라는 메서드를 통해 사용가능한 Connection을 리턴하도록 되어있습니다.</p><p>1인칭 Thread 시점으로 Hikari Pool에게 Connection을 하나 요청해 보았습니다.<br><strong><em>(개발은 유치하게 이해할수록 이해도 잘되고 기억에 잘 남는것 같아서.. 각본을 준비해봤습니다.)</em></strong></p><p><em><strong>[Thread-1님]</strong> 안녕하세요 Hikari님! Connection 하나만 주세요~</em><br><strong>[Hikari님]</strong> 안녕하세요 Thread-1님! 저희 pool에서는 Connection을 주는 규칙이 있답니다. 확인해볼게요~<br><strong>[Hikari님]</strong> 이전에 Thread-1님이 저희 pool에 방문한 내역 먼저 살펴볼게요!<br><strong>[Hikari님]</strong> 오! 이전에 방문한 내역이 있으시네요~ 근데 그때 사용한 Connection은 다른 Thread 님이 사용 중(IN_USE) 이시네요~<br>                  다른 Thread님이 안 쓰셨으면 빠르게 이 Connection 먼저 드렸을 텐데 아쉽네요ㅠㅠ<br><em><strong>[Thread-1님]</strong> 괜찮아요! Hikari님 다른 Connection 주세요~</em><br><strong>[Hikari님]</strong> Pool 전체에서 사용 가능한(idle) Connection이 있는지 찾아볼께요~<br><strong>[Hikari님]</strong> (Loop 돌면서 찾는중...)<br><strong>[Hikari님]</strong> Thread-1님 지금 전체 Connection이 다 사용중이에요! ㅠㅠ<br>                 저기 handoffQueue 앞에 가서 좀 기다리셔야 할 것 같아요 ㅜㅜ<br><em><strong>[Thread-1님]</strong> 네 괜찮아요! (안 괜찮음) 저기서 30초만 기다려보고 없으면 Exception내면 되죠^^<br>                       <strong>(깨알 Tip. HikariCP default Connection timeout은 30초 입니다.)</strong></em><br><strong>[Hikari님]</strong> 네 죄송합니다 Thread-1님. 다음에 또 다시 방문해주세요~<br><em><strong>[Thread-1님]</strong> (handoffQueue에서 다른 Thread가 쓰고 반납한 Connection을 얻었다!)</em></p><p>혹시 잘 이해가 가셨을까요..?<br>이해가 아직 안되신 분들을 위한 Flow chart를 준비해보았습니다.</p><p><img src="./getConnection-flow.png" alt="getConnection-flow"></p><p>코드 레벨로 확인해보시려면 -&gt; <a href="https://github.com/brettwooldridge/HikariCP/blob/dev/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java#L126" target="_blank" rel="noopener">ConcurrentBag.borrow()</a></p><h2 id="hikari님-connection-다-썼어요">Hikari님! Connection 다 썼어요</h2><p>HikariCP에서 얻은 Connection은 <code>(ProxyConnection) Connection.close()</code>를 하게 되면 HikariPool에 반납이 됩니다.<br>(HikariPool에서 얻은 Connection은 ProxyConnection 타입입니다.)<br>정상적인 transaction이 마무리 되거나, Rollback이 호출 되어도 <code>connection.close()</code>가 호출되어 Connection을 반납합니다.<br>getConnection과 마찬가지로 <code>connection.close()</code> 시, <code>concurrentBag.requite()</code>이 실행되며 Connection이 반납됩니다.</p><p>위와 같이 1인칭 Thread 시점으로 각본을 짜보겠습니다.</p><p><em><strong>[Thread-1님]</strong> Transaction내의 쿼리를 모두 수행하고 Commit이 되었어 이제 Connection을 반납해볼까?</em><br><em><strong>[Thread-1님]</strong> Thread-1님이 (ProxyConnection) connection.close()을 실행하였습니다.</em><br><strong>[Hikari님]</strong> 안녕하세요 Thread-1님! Connection 이용은 만족스러우셨나요? Connection 반납 절차 도와드리겠습니다.<br><strong>[Hikari님]</strong> 일단 PoolEntry의 상태를 STATE_NOT_IN_USE로 바꿀게요. <strong>(여기서 idle connection이 됩니다.)</strong><br><strong>[Hikari님]</strong> handOffQueue에서 Connection을 받길 원하는 다른 Thread님이 있나봐요~<br><strong>[Hikari님]</strong> (handOffQueue에 Connection 삽입)<br><strong>[Hikari님]</strong> Thread-1님 고생하셨습니다~ 이번에 사용한 Connection 정보 등록해 드릴께요~! 다음에 빠르게 이용하실 수 있으실거에요<br><em><strong>[Thread-1님]</strong> 감사합니다! Hikari님 또 Connection 받으러 올께요~</em></p><p>혹시 잘 이해가 가셨을까요..?<br>이해가 아직 안되신 분들을 위한 Flow chart를 준비해보았습니다.</p><p><img src="./close-flow.png" alt="close-flow"></p><p>코드 레벨로 확인해보시려면 -&gt; <a href="https://github.com/brettwooldridge/HikariCP/blob/dev/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java#L181" target="_blank" rel="noopener">ConcurrentBag.requite()</a></p><h1 id="hikaricp에서-dead-lock이-발생하는-case">HikariCP에서 Dead lock이 발생하는 Case</h1><p>consumer thread 갯수에 따른 충분한 HikariCP의 maximum pool size를 설정하지 못해 Dead lock이 발생하여 이번 장애로 이어지게 되었습니다.<br>도데체 무슨 관계가 있다고 Dead lock이 발생했을까요?<br>간단한 예시를 통해 알아보도록 하겠습니다.</p><p>Thread count와 maximum pool size의 조건은 아래와 같습니다.</p><ul><li>Thread Count: 1개</li><li>HikariCP MaximumPoolSize: 1개</li><li>하나의 트랜잭션에서 요구되는 Connection 갯수: <strong>2개!!</strong></li></ul><p>조금은 감이 오시나요?<br>그림으로 살펴보도록 하겠습니다.</p><p><img src="./dead-lock-case.png" alt="dead-lock-case"></p><ol><li>하나의 Thread가 Repository.save(entity) 라는 insert query를 실행하기 위해 Transaction을 구성합니다.</li><li>Transaction용 Connection을 하나 가져옵니다. <strong>(PoolStats : total=1, active=1, idle=0, waiting=0)</strong></li><li>Transaction을 시작하였고 Repository.save를 하기 위해 Connection이 하나 더 필요하다고 <strong>가정</strong>해보겠습니다.</li><li>Thread-1은 Hikari Pool에 Connection을 요청합니다.<ol><li>위의 3단계 절차대로, 현재 자기 Thread의 방문내역을 살펴봅니다.<br>아직 방문내역이 등록된 게 없습니다.</li><li>전체 Hikari Pool에서 idle상태의 Connection을 스캔합니다.<br>Pool Size는 1개이고 1개 있던 Connection은 Thread-1에서 이미 사용중입니다.</li><li>마지막으로 handOffQueue에서 누군가 반납한 Connection이 있길 기대하며 30초 동안 기다립니다.<br>하나 있던 Connection을 자기 자신이 사용하고 있기 때문에 자기 자신이 반납하지 않는 이상 사용할 Connection이 없습니다.<br><strong>(PoolStats : total=1, active=1, idle=0, waiting=1)</strong></li><li>결국 30초가 지나고 Connection Timeout이 발생하고<br><code>hikari-pool-1 - Connection is not available, request timed out after 30000ms.</code> 와 같은 에러가 발생</li></ol></li><li>Transaction에 대한 evictMark가 찍히고 트랜잭션이 롤백 됩니다.</li><li>롤백 됨과 동시에 Transaction용 Connection은 다시 Pool에 반납됩니다. <strong>(PoolStats : total=1, active=0, idle=0, waiting=0)</strong></li></ol><p>이렇게 Thread내에서 하나의 Task에 수행하는데 필요한 Connection갯수가 모자라게 되면<br><strong>Dead Lock 상태에 빠져 Insert Query를 실행할 수 없게 됩니다.</strong></p><h1 id="위에는-예시이고-실제-상황은-뭐였어요">위에는 예시이고, 실제 상황은 뭐였어요?</h1><p>제가 장애를 맞았던 실제 환경에 대해 설명해드리겠습니다.</p><p>장애 환경에 대한 Thread count와 maximum pool size의 조건은 아래와 같습니다.</p><ul><li><p>CPU Core : 4개</p></li><li><p>Thread Count: 16개</p></li><li><p>HikariCP MaximumPoolSize: 10개</p></li><li><p>하나의 트랜잭션에서 요구되는 Connection 갯수: <strong>2개</strong><br>(처음엔 1개일거라 생각했지만, getConnection에 대한 디버깅을 해보니 2번의 getConnection 요청이 발생했습니다.)</p></li></ul><p>실제 구현부의 간단한 코드입니다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> String contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">save</span><span class="params">(<span class="keyword">final</span> Message message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> repository.save(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>혹시 이 코드에서 왜 Connection이 2개나 필요한지 짐작이 되시나요?<br>코드만 보면 하나의 Connection으로 Insert가 잘 될 것 같습니다.<br>여태까지 그런줄 알았고 이번 장애가 아니었다면 몰랐을 것이었습니다.</p><h2 id="generatedvaluestrategy-generationtypeauto">@GeneratedValue(strategy = GenerationType.AUTO)</h2><p>이 사건의 범인은 이 코드로 부터 시작됩니다.<br>GeneratedValue(strategy = GenerationType.AUTO)인 경우에는 JPA 구현체가 자동으로 ID값 생성전략을 결정합니다.<br>사내에서 사용하는 RDB는 MySQL을 사용하고 있습니다.<br>ID의 Type이 long 타입이고, <code>hibernate.id_new_generator_mappings</code> 값이<code>true</code> (default true)이기 때문에<br>ID 필드에 대한 Generator는 내부적으로 SequenceStyleGenerator를 사용하게 됩니다.<br>하지만 MySQL에서는 Oracle처럼 Sequence라는게 존재하지 않기 때문에 <code>hibernate_sequence</code>라는 테이블을 생성하고, 테이블에 단일 로우로 된 id값을 계속 update하며 sequence처럼 관리합니다.</p><p>getConnection에 대한 call tree를 역주행하면서 hibernate 내부 코드까지 보게 되었습니다.<br>call tree에 대한 대략적인 단계는 아래와 같습니다.</p><ol><li>repository.save(entity): 내부적으로 SimpleJpaRepository.save가 호출됩니다.</li><li>DefaultPersistEventListener에 의해 saveWithGeneratedId가 호출됩니다.</li><li>saveWithGeneratedId가 실행되며, Entity의 Id값을 생성할 때 SequenceStyleGenerator를 이용하여 생성합니다.</li><li>SequenceStyleGenerator.generate 코드에서 databaseStructure.buildCallback()이 실행되며, TableStructure.buildCallBack()이 실행됩니다<br>(이 코드에서 hibernate_sequence에 대한 조회, update가 이루어집니다.)</li><li>hibernate_sequence를 조회, update를 하는데에 있어서 별도의 Transaction으로 동작하게 됩니다.<br><code>select next_val as id_val from hibernate_sequence for update</code> 쿼리를 실행하게 되고, 트랜잭션이 끝나기 전까지 Table Lock이 걸리게 됩니다.(만약 같은 Transaction 내에서 동작했다면은 hibernate_sequence table에 대한 Table Lock이 동작해 다른 스레드에서 id값을 생성하지 못할 것입니다.)</li><li><strong>별도의 트랜잭션으로 동작하게 되면서 새로운 Connection을 하나 받아오게 됩니다</strong> (여기서 2번째 connection을 받아옵니다.)</li></ol><p>위의 call tree에 대한 코드 입니다.</p><p><img src="./save.png" alt="save"></p><p><img src="./AbstractSaveEventListener.saveWithGeneratedId.png" alt="AbstractSaveEventListener.saveWithGeneratedId"></p><p><img src="./id_generator.png" alt="id_generator"></p><p><img src="./execute_hibernate_sequence.png" alt="execute_hibernate_sequence"></p><p><img src="./TableStructure.delegateWork.png" alt="TableStructure.delegateWork"></p><h2 id="하나의-task에서-필요한-connection은-2개인데-왜-dead-lock이-걸리죠">하나의 Task에서 필요한 Connection은 2개인데 왜 Dead Lock이 걸리죠?</h2><p>부하가 크게 걸리지 않는 일반적인 상황에서는 문제가 없을 것입니다. 스레드 전체가 일을 하지 않을 것이기 때문입니다.<br>문제는 전체 스레드가 동시에 일을 하게 되는 부하 상황 시에 발생합니다.</p><p><img src="./dead-lock-case2.png" alt="dead-lock-case2"></p><p>이런 식으로 16개의 스레드 중 10개의 스레드가 10개의 Connection을 모두 잡고 있으면 10개의 스레드 중 하나의 스레드에서<br>2번째 Connection에 대한 timeout이 발생하지 않으면 계속 30초씩 지연이 발생하게 됩니다.<br>하물며 idle Connection이 다시 발생한들 남은 6개의 Thread들 중 하나가 Connection을 가져가면 dead lock의 악순환의 고리에 빠지게 됩니다.<br>간혹 운이 좋게 하나의 스레드가 Connection 2개를 획득하여 트랜잭션이 성공하는 case도 있을 것 입니다.<br>(이런 경우 간헐적으로 동작하기 때문에 원인 파악이 매우 힘들어 집니다.)</p><h1 id="dead-lock을-피하는-maximum-pool-size는-어떻게-설정하나요">Dead lock을 피하는 Maximum pool size는 어떻게 설정하나요?</h1><p>HikariCP의 Dead lock에 대한 case는 이미 HikariCP issue에 등록되어있다.<br>HikariCP에서는 Dead Lock을 피하기 위한 최적의 Maximum Pool Size를 방법을 제시하고 있다.</p><p>공식은 아래와 같다.</p><blockquote><h3 id="pool-size-tn-x-cm-1-1"><em>pool size = Tn x (Cm - 1) + 1</em></h3></blockquote><ul><li><em>Tn</em> : Thread의 최대 수</li><li><em>Cm</em>: 하나의 Task에서 필요한 Connection 갯수</li></ul><h2 id="실제로-맞는-공식인지-알아보자">실제로 맞는 공식인지 알아보자</h2><ul><li>Thread Count : 8개</li><li>하나의 Task에 필요한 Connection 갯수: 2개</li><li>pool Size = 8 x ( 2 - 1) + 1 = 9개</li></ul><p><img src="./avoid-dead-lock.png" alt="avoid-dead-lock"></p><ul><li>thread 8개가 골고루 Connection을 하나씩 얻었고 7개의 스레드가 2번째 스레드를 기다리고 있다.</li><li>이렇게 되면 스레드 2번의 2번째 Connection은 빠르게 hibernate_sequence만 조회, update하고 빠르게 반납되게 된다.</li><li>이로 인해 다른 스레드에서도 Connection을 받을 수 있게 된다</li><li>thread 2번에서도 정상적으로 트랜잭션이 처리되게 된다. -&gt; connection이 반납된다.</li><li>위와 같은 pool size로 dead lock을 피할 수 있는 최소한의 pool size를 얻을 수 있게 되었다.</li></ul><h1 id="이-글을-쓰고나니-생기는-질문">이 글을 쓰고나니 생기는 질문</h1><ul><li><p>Embedded Tomcat의 default thread count는 200개인데 공식을 적용하면 hikari pool size가 수백개가 될 수도 있다.</p><ul><li>기본적으로 task당 1개의 connection만 필요하면 poolSize 1개로도 모든 요청은 다 처리할 수 있다.</li><li>2개 이상의 connection이 필요한 경우에는 tomcat thread count를 줄이고 hikari pool size도 100개 이하로 조정한다.</li><li>퍼포먼스가 안나오는 경우에는 DB에 insert하는 application의 아키텍쳐를 수정하는 방법도 있을 것 같다.</li></ul></li><li><p>퍼포먼스 저하는 없었나?</p><ul><li>기존 16개인 thread를 4개 정도로 조절했다.</li><li>1 thread 당 300 TPS정도의 성능이 나와 4 core인 환경에서는 문제 없이 처리할 수 있다.</li><li>오히려 thread 수를 줄여 message queue의 throttling을 할 수 있게 되었다.</li><li>core 수에 맞게 제한된 리소스를 사용하는 것이 오히려 context-switching에 대한 overhead를 줄여 성능상의 이점이 있다고 한다.<br>([About Pool Sizing] - &lt;https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing)</li></ul></li></ul><blockquote><h4 id="limited-resources">Limited Resources</h4><p>It is not quite as simple as stated above, but it's close. There are a few other factors at play. When we look at what the major bottlenecks for a database are, they can be summarized as three basic categories: <em>CPU</em>, <em>Disk</em>, <em>Network</em>. We could add <em>Memory</em> in there, but compared to <em>Disk</em> and <em>Network</em> there are several orders of magnitude difference in bandwidth.</p><p>If we ignored <em>Disk</em> and <em>Network</em> it would be simple. On a server with 8 computing cores, setting the number of connections to 8 would provide optimal performance, and anything beyond this would start slowing down due to the overhead of context switching. But we cannot ignore <em>Disk</em> and <em>Network</em>. Databases typically store data on a <em>Disk</em>, which traditionally is comprised of spinning plates of metal with read/write heads mounted on a stepper-motor driven arm. The read/write heads can only be in one place at a time (reading/writing data for a single query) and must &quot;seek&quot; to a new location to read/write data for a different query. So there is a seek-time cost, and also a rotational cost whereby the disk has to wait for the data to &quot;come around again&quot; on the platter to be read/written. Caching of course helps here, but the principle still applies.</p></blockquote><h1 id="참고">참고</h1><ul><li>[About Pool Sizing] - <a href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing" target="_blank" rel="noopener">https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing</a></li><li>[Down the Rabbit Hole] - <a href="https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole" target="_blank" rel="noopener">https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole</a></li><li><a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">https://github.com/brettwooldridge/HikariCP</a></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2020/01/27/2020-01-27-hikaricp-maximum-pool-size-tuning/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HikariCP Failed to Validate Connection Warning 이야기</title>
      <link>https://jaehun2841.github.io/2020/01/08/2020-01-08-hikari-pool-validate-connection/</link>
      <guid>https://jaehun2841.github.io/2020/01/08/2020-01-08-hikari-pool-validate-connection/</guid>
      <pubDate>Wed, 08 Jan 2020 10:13:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;hikari-pool-failed-to-validate-connection&quot;&gt;hikari-pool - Failed to validate connection&lt;/h1&gt;
&lt;p&gt;Springboot2.x를 사용하다 보면 이런 warn level 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="hikari-pool-failed-to-validate-connection">hikari-pool - Failed to validate connection</h1><p>Springboot2.x를 사용하다 보면 이런 warn level 에러를 마주칠 수 있습니다.</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hikari-pool - Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl@1e2db70  </span><br><span class="line">(No operations allowed after connection closed.).  </span><br><span class="line">Possibly consider using a shorter maxLifetime value.</span><br></pre></td></tr></table></figure></p><p>로그의 내용을 의역하면 아래와 같습니다.</p><ul><li>Hikari pool의 connection을 validate하는데 실패 했다.</li><li>이미 close된 connection에 어떤 operation을 하는것은 안된다.</li><li>HikariPool의 <code>maxLifetime</code> 값을 짧게 하는 것을 생각해봐라</li></ul><h3 id="무슨말-일까요"><strong>무슨말 일까요?</strong></h3><p>요약하자면, connection을 갱신하고자 하는데 이미 닫힌 커넥션이라 어떤 행위도 할 수 없다. 입니다.여기서 중요한건 HikariConfig의 MaxLifetime과 MySQL의 wait_timeout의 상관관계를 알아야 합니다.</p><h1 id="hikari-pool의-maxlifetime">Hikari Pool의 MaxLifetime</h1><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">This property controls the maximum lifetime of a connection in the pool.  </span><br><span class="line">An in-use connection will never be retired, only when it is closed will it then be removed.  </span><br><span class="line">On a connection-by-connection basis, minor negative attenuation is applied to avoid mass-extinction in the pool.  </span><br><span class="line">We strongly recommend setting this value, and it should be several seconds shorter than any  </span><br><span class="line">database or infrastructure imposed connection time limit.   </span><br><span class="line">A value of 0 indicates no maximum lifetime (infinite lifetime),  </span><br><span class="line">subject of course to the idleTimeout setting. Default: 1800000 (30 minutes)</span><br></pre></td></tr></table></figure></p><p>구글번역기로 대충 돌려보면..</p><ul><li>MaxLifetime은 Hikari pool에서 Connection이 살아 있을 수 있는 시간</li><li>현재 사용중인 Connection은 종료하지 않고 이미 닫혀 있는 경우에만 제거</li><li>Connection을 한번에 대량으로 종료하고 생성하면 비용이 많이 듬 (실제로 2.5%의 유격으로 maxLifetime이 Connection에 설정됨)</li><li>Database에 설정된 Connection time limit 보다 짧아야 한다.</li><li>0으로 설정하면 무한으로 Connection이 살아있음</li><li>default 180000ms (= 30분)</li></ul><p>Hikari Pool 내부적으로 Connection의 life time을 관리하는 속성입니다.</p><p>maxLifetime은 최소 30초 이상으로 설정하여야 합니다. (안그러면 180000ms로 설정)</p><p><img src="./minimum-maxLifetime.png" alt="minimum-maxLifetime"></p><h1 id="mysql의-wait_timeout">MySQL의 wait_timeout</h1><ul><li>wait_timeout: 활동하지 않는 커넥션을 끊을때까지 서버가 대기하는 시간</li></ul><p>현재 아무것도 안하고 sleep 상태인 Connection을 끊는 주기입니다.</p><h2 id="주의">주의!</h2><p>wait_timeout은 session, global variable 두 개로 구성되어있습니다.</p><ul><li>show variables like 'wait_timeout'; : 현재 연결된 session에 대한 wait_timeout 값</li><li>show <strong>global</strong> variables like 'wait_timeout': global wait_timeout값</li></ul><p>활동하지 않는 커넥션을 종료하는 것은 mysql daemon에서 해주기 때문에 global wait_timeout 값에 의해 종료됩니다.</p><p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>;</span><br></pre></td></tr></table></figure></p><p>위의 명령어는 현재 mysql에서 동작중인 process (= connection) 정보입니다.</p><p><img src="./processlist.png" alt="processlist"></p><p>Time 필드의 값이 Sleep Command가 실행되고 경과된 시간입니다.<br>Time 필드의 값이 설정된 global wait_timeout 시간이 지나면 <strong>Connection을 종료하게 됩니다.</strong></p><h1 id="hikari-pool에서-connection을-관리하는-방법">Hikari Pool에서 Connection을 관리하는 방법</h1><p>JDBC4를 지원하는 드라이버에서는 예전처럼 더이상 <code>validationQuery</code> 를 수행하여 Connection을 갱신하지 않습니다.<br>이제는 Connection이 생성될 때 Hikari PoolEntry에 Scheduled Event를 걸어 maxLifetime 시간 이후에 강제적으로 Connection을 종료하도록 되어있습니다.</p><p><img src="./createPoolEntry.png" alt="createPoolEntry"></p><p>maxLifeTime에 2.5%의 변화를 주어 모든 Connection이 한순간에 종료되지 않도록 설정하였습니다.</p><p><img src="./softEvictConnection.png" alt="softEvictConnection"><img src="./reserve-PoolEntry-Status.png" alt="reserve-PoolEntry-Status">softEvict Connection. 말 그대로 status만 변경하여 evict connection을 수행합니다.</p><p><img src="./soft-remove.png" alt="soft-remove"></p><p>위에서 변경한 Connection의 상태에 따라 진짜로 connection을 close 할지 말지 결정합니다.<br>(STATE_RESERVED 상태인 PoolEntry에 대한 Connection을 제거 합니다.)</p><p><img src="./connection-close.png" alt="connection-close"></p><h1 id="진짜-validationquery는-필요없어졌나">진짜 validationQuery는 필요없어졌나?</h1><p>기존에는 validationQuery, ConnectionTestQuery = SELECT 1등, test-idle-while 같은 기능을 구현하기 위해 또는<br>Connection의 갱신, validation을 하기 위해 의미 없는 Query를 실행하여, DB에 부하를 계속 주고 있었습니다.</p><p>하지만 JDBC4를 구현한 driver에서는 더 이상 validationQuery, ConnectionTestQuery를 사용하지 않도록 권장합니다.<br>(지금도 Hikari CP에는 기능은 있으나 코드가 실행안됨)</p><p>Connection Pool에서 한 개의 Connection을 받아 사용하기 전에 <code>isConnectionAlive</code> 라는 메서드가 실행됩니다.<br>(내가 지금 받은 커넥션이 유효한가? 에 대한 검사입니다.)</p><p><img src="./isConnectionAlive.png" alt="isConnectionAlive"></p><p>위의 코드를 보면 Jdbc4Validation을 사용하는 경우에는 Connection.isValid 메서드를 통해 현재 커넥션이 유효한지 검사합니다.<br>하지만, Jdbc4Validation을 사용하지 않는 경우에는 직접 ConnectionTestQuery를 실행하여 현재 커넥션에 대한 유효성을 판단합니다.</p><p><img src="./isUseJdbc4Validation.png" alt="isUseJdbc4Validation"></p><p>HikariPool 설정에서는 ConnectionTestQuery property가 null인 경우 Jdbc4Validation으로 동작합니다.</p><h1 id="그래서-failed-to-validate-connection-로그는-왜-나오나요">그래서  Failed to validate connection 로그는 왜 나오나요</h1><p>저의 경우에는mysql의 global wait_timeout 값이 60초로 설정되어 있었습니다.<br>Hikari Pool의 maxLifetime 값은 default로 180000ms (= 30분) 으로 되어져 있었습니다 .</p><p>따라서 30분마다 PoolEntry에서 놀고 있는 Connection을 종료하고자 하였지만, 이미 MySQL process는 종료되었기에<br><strong>이미 닫힌 커넥션에 왜 무언가를 하려고하는가?</strong> 라고 warning log가 발생하였습니다.</p><p><img src="./isConnectionAlive.png" alt="isConnectionAlive"></p><p>catch 절에서 Exception이 발생하여 해당 로그가 찍히게 됩니다.</p><h1 id="maxlifetime-wait_timeout-어떻게-설정해야-하나요">maxLifetime, wait_timeout 어떻게 설정해야 하나요?</h1><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">We strongly recommend setting this value, and it should be at least 30 seconds less than any  </span><br><span class="line">database or infrastructure imposed connection time limit.</span><br></pre></td></tr></table></figure></p><p>Hikari CP에서는 maxLifetime을 MySQL의 wait_timeout보다 최소 30초 이상 적게 주도록 권장하고 있습니다.<br>(하지만 이는 잘못되었다고 합니다. <a href="https://pkgonan.github.io/2018/04/HikariCP-test-while-idle" target="_blank" rel="noopener">pkgonan님 질문 참고</a>)</p><p>pkgonan님이 받으신 답변을 참고하면</p><p>답변 요약</p><ul><li>max_lifetime을 Database의 wait_timeout보다 30초 이상 짧게 주라는 것은 잘못 되었다.<br>공식 문서 업데이트를 진행하지 않은 것이다.</li><li>HikariCP는 DBA를 존중하기 때문에 DBA가 설정한 wait_timeout을 지킨다.</li><li>HikariCP는 커넥션 풀을 관리하기 위해 HouseKeeper라는 Thread가 30초마다 돌고 있다.</li><li>HouseKeeper가 30초마다 돌며 커넥션을 종료하였기에, 이전 29.xx초까지의 커넥션들에 대해 유효성 체크가 누락될 수 있어서 30초의 여유를 준 것이다.</li><li>현재 방식은, ThreadLocal에서 각각 타이머를 통해 max-lifetime에 도달했는지 체크를 하는 방식으로 변경되었다.</li><li><code>따라서, max-lifetime은 네트워크 통신 등을 감안해서 Database의 wait_timeout으로 부터 2~3초 정도 짧게 주면 된다.</code></li><li><code>커넥션이 사용중일 경우 즉시 종료를 하지 않기에 커넥션이 매우 바쁜 상황을 감안해서 여유있게 준다면 wait_timeout으로 부터 5초정도까지 짧게 주면 된다는 개발자의 추가 답변.</code></li></ul><p>결론적으로<br>maxLifetime = wait_timeout - (2~5초) 정도로 설정하면 됩니다.</p><h1 id="결과">결과</h1><p>저의 경우에는 maxLifetime의 Default를 더 존중하여 30분을 유지하도록 하고<br>MySQL의 global wait_timeout 값을 1830초 정도로(그냥 넉넉하게) 수정하여 사용하도록 변경하였습니다.<br>(maxLifetime을 바꾸자니 너무 잦은 커넥션 생성 비용이 염려스러웠습니다.)</p><p>이렇게 설정하고 나니 더 이상 Failed to validate connection WARN 로그는 발생하지 않았습니다.</p><h1 id="참고">참고</h1><ul><li><a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">https://github.com/brettwooldridge/HikariCP</a></li><li><a href="https://pkgonan.github.io/2018/04/HikariCP-test-while-idle" target="_blank" rel="noopener">https://pkgonan.github.io/2018/04/HikariCP-test-while-idle</a></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2020/01/08/2020-01-08-hikari-pool-validate-connection/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring-Kafka-Streams Serde 내부 이야기</title>
      <link>https://jaehun2841.github.io/2019/12/23/2019-12-23-kafka-streams-binder-feature/</link>
      <guid>https://jaehun2841.github.io/2019/12/23/2019-12-23-kafka-streams-binder-feature/</guid>
      <pubDate>Mon, 23 Dec 2019 05:33:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;version-up&quot;&gt;Version Up&lt;/h1&gt;
&lt;p&gt;팀에서 사용하는 Spring boot version up (2.1.6 -&amp;gt; 2.2.2)을 하면서 호환성을 맞추기 위해&lt;br&gt;
spring-cloud-stream-binder-k
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="version-up">Version Up</h1><p>팀에서 사용하는 Spring boot version up (2.1.6 -&gt; 2.2.2)을 하면서 호환성을 맞추기 위해<br>spring-cloud-stream-binder-kafka-streams 라이브러리도 같이 버전업을 하게 되었습니다. (2.2.0 -&gt; 2.3.4)<br>그 과정에서 발생한 value Serde 이슈에 대한 내용을 얘기해 보고자 합니다.</p><h1 id="kafka-streams란">Kafka Streams란?</h1><p>kafka streams는 kafka streams api를 사용하여, 지속적으로 흘러들어오는 데이터에 대한 분석, 처리를 위한 클라이언트 라이브러리 입니다.</p><p>간단하게는 어떤 Topic으로 들어오는 데이터를 Consume하여, streams api를 통해 처리 후<br>다른 Topic으로 전송(Producing) 하거나 끝내는 행위를 하게 됩니다.</p><h1 id="spring에서-사용하기">Spring에서 사용하기</h1><p>Springboot에서 kafka streams를 사용하게 되면 <code>@StreamListener</code> annotation을 사용해서 로직을 구현하게 됩니다.</p><p><img src="./StreamListener-annoataion.png" alt="StreamListener-annoataion"></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(MessageDispatcher.Dispatch.class)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageDispatcher</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@StreamListener</span>(Dispatch.TOPIC)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(KStream&lt;String, Message&gt; input)</span> </span>&#123;</span><br><span class="line">    input.mapValues(value -&gt; value.markSendFlag())</span><br><span class="line">      .to(<span class="string">"next-topic"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC = <span class="string">"message-topic"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Input</span>(TOPIC)</span><br><span class="line">    <span class="function">KStream&lt;String, Message&gt; <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>간단하게 Message를 처리하는 kafka streams code를 작성해 보았습니다<br><code>message-topic</code>토픽으로 들어오는 메세지를 consume하여 sendFlag 처리를 하고 <code>next-topic</code>으로 다시 producing하는 코드 입니다.</p><p>기본적으로 kafka에서 쓰이는 content-type은 <code>application/json</code>이기 때문에  value fotmat을 Json으로 사용하고 있습니다.</p><p>그렇다면 kafka에는 <strong>분명 value가 json string일텐데,</strong> @StreamListener 메서드에서는 <code>어떻게 json -&gt; Pojo로 Deserializing 해주었을까요?</code></p><p>이걸 찾아보기 전까지는 막연하게 default.value.serde (Serializier/DeSerializer)가 해주는줄 알았습니다.  <code>(반은 맞고 반은 아님)</code><br>하지만 이번 version up 이슈를 통해 자세하게 알아보았고, 그 내용을 적어보았습니다.</p><h1 id="spring-cloud-stream-binder-kafka-streams-220">spring-cloud-stream-binder-kafka-streams 2.2.0</h1><p><code>@StreamListener</code> annoataion은 <code>StreamListenerAnnotationPostProcessor</code> class에 의해 annotation processing 작업이 이루어집니다.</p><p>그 내부에서 StreamListenerSetupMethodOrchestrator class에 의해 processing이 이루어지며,<br>정확히는 <code>KafkaStreamsStreamListenerSetupMethodOrchestrator</code> 입니다.</p><p>살펴볼 코드의 순서는 이렇습니다.</p><ol><li><code>orchestrateStreamListenerSetupMethod</code></li><li><code>adaptAndRetrieveInboundArguments</code></li><li><code>keySerde, valueSerde</code> 설정하는 부분</li><li><code>valueSerde 설정</code> (과연 valueSerde는 뭐를 쓰고 있었을까?)</li><li><code>if (parameterType.isAssignableFrom(KStream.class))</code></li><li><code>getkStream(inboundName, spec, bindingProperties, streamsBuilder, keySerde, valueServde, autoOffsetReset)</code></li><li><code>streamListenerParameterAdapter.adapt</code></li><li><code>deserializeOnInbound</code></li><li><code>convertAndSetMessage</code></li><li><code>ApplicationJsonMessageMarshallingConverter.convertFromInternal</code></li></ol><h2 id="3-keyserde-valueserde-설정">3. keySerde, valueSerde 설정</h2><p><img src="./setSerde.png" alt="setSerde"></p><p>6번째 줄부터 keySerde, valueSerde를 설정하는 부분을 볼 수 있습니다.</p><h2 id="4-valueserde-설정">4. valueSerde 설정</h2><p><img src="./getInboundValueSerde-7085172.png" alt="getInboundValueSerde"></p><p>중요!한 valueSerde 설정 부분입니다.<br>try 블록 첫번째 if문을 보면 consumerProperties에 <code>useNativeDecoding</code> 속성이 true인 경우에만 getValueSerde() 메서드를 호출하여 default.value.serde가 적용되게 됩니다.<br>그게 아니라면 ByteArray Serde가 적용됩니다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When set to true, the inbound message is deserialized directly by client library,</span></span><br><span class="line"><span class="comment"> * which must be configured correspondingly (e.g. setting an appropriate Kafka</span></span><br><span class="line"><span class="comment"> * producer value serializer). <span class="doctag">NOTE:</span> This is binder specific setting which has no</span></span><br><span class="line"><span class="comment"> * effect if binder does not support native serialization/deserialization. Currently</span></span><br><span class="line"><span class="comment"> * only Kafka binder supports it. Default: 'false'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useNativeDecoding;</span><br></pre></td></tr></table></figure></p><p>default는 false이기 때문에 기본적으로 ByteArray Serde가 적용됩니다.<br>(그것도 모르고 default.value.serde에 명시한 Serde가 적용되는 줄 알았습니다.)</p><p><img src="./getValueSerde.png" alt="getValueSerde"></p><h2 id="5-if-parametertypeisassignablefromkstreamclass">5. if (parameterType.isAssignableFrom(KStream.class))</h2><p><img src="./KStream-if.png" alt="KStream-if"></p><p>여기서 중요하게 봐야 할 부분은 두군데 입니다.</p><ul><li>getkStream()</li><li>streamListenerParameterAdapter.adapt(kStreamWrapper, methodParameter)</li></ul><h2 id="6-getkstream">6. getkStream()</h2><p><img src="./getStream.png" alt="getStream"></p><p>마지막의 stream.mapValues 쪽을 잘봐야 합니다.<br>여기에도 nativeDecoding에 대한 조건이 있습니다.<br>contentType은 default를 사용하고 있기 때문에 <code>application/json</code>이 적용됩니다.<br>stream.mapValues내의 함수는 runtime에서 실행되는 함수이기 때문에 kafka streams에서 message를 consume하고 실행하는 함수입니다.</p><p>정리해보면..</p><ul><li>contentType = <code>application/json</code></li><li>useNativeDecoding = <code>false</code></li></ul><p>이므로</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">returnValue = MessageBuilder.withPayload(value)</span><br><span class="line">  .setHeader(MessageHeaders.CONTENT_TYPE, contentType)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure></p><p>kafka에서 처리하는 Message Type으로 처리가 되게 됩니다.</p><h1 id="7-streamlistenerparameteradapteradapt">7. streamListenerParameterAdapter.adapt</h1><p><img src="./streamListenerParameterAdapter.png" alt="streamListenerParameterAdapter"></p><p><img src="./StreamListenerParameterAdapter-interface.png" alt="StreamListenerParameterAdapter-interface"></p><p>다음은 @StreamListener가 달린 Parameter를 처리하기 위한 Adapter 설정입니다.<br>이 메서드 내에서 KStream&lt;String, YourPojoType&gt;인 KStream의 Deserializing이 이루어집니다.</p><p><img src="./adapt.png" alt="adapt"></p><p>interface 구현체는 <code>KStreamStreamListenerParameterAdapter</code> 클래스입니다.<br>여기서도 useNativeDecoding 속성에 따라 코드가 분기가 됩니다.<br>default = false이기 때문에 아래 deserializeOnInbound 메서드가 호출됩니다.</p><h2 id="8-deserializeoninbound">8. deserializeOnInbound</h2><p><img src="./deSerializeOnInbound.png" alt="deSerializeOnInbound"></p><p>쭉~ 복잡한 코드가 보입니다.<br>그중에서도 볼것은 <code>convertAndSetMessage</code> 메서드입니다.</p><h2 id="9-convertandsetmessage">9. convertAndSetMessage</h2><p><img src="./convertAndSetMessage.png" alt="convertAndSetMessage"></p><p><img src="./CompositeMessageConverter-fromMessage.png" alt="CompositeMessageConverter-fromMessage"></p><p>valueClass.isAssignableFrom() = false이므로 messageConverter.fromMessage() 메서드가 실행됩니다.<br>(여기서 사용되는 messageConverter는 여러가지 messageConvert를 모아둔 <code>CompositeMessageConverter</code> 가 사용됩니다.)</p><p>그중에서도 <code>ApplicationJsonMessageMarshallingConverter</code>를 사용하여 Json Data를 targetClass 타입으로 변환시킵니다.<br><strong>그렇기 때문에 따로 Serde를 정의하지 않아도 Kafka Stream 라이브러리에서 알아서 잘 deserialize를 해주었습니다.</strong></p><h2 id="10-applicationjsonmessagemarshallingconverterconvertfrominternal">10. ApplicationJsonMessageMarshallingConverter.convertFromInternal</h2><p><img src="./convertFromInternal2.png" alt="convertFromInternal2"></p><p>내부적으로는 Jackson 라이브러리의 objectMapper를 이용하여 deserialize 하는 코드가 있습니다.</p><h2 id="요약">요약</h2><ul><li>spring kafka streams에 대한 별다른 설정을 안했다면 default로 작동할 것 입니다.</li><li>useNativeDecoding = false로 설정 되어있을 것입니다.</li><li>위의 설정을 true로 하지 않았다면, default.key.serde, default.value.serde 설정은 먹히지 않습니다.</li><li>기본적으로 ByteArray valueSerde를 사용했을 것입니다.</li><li>ApplicationJsonMessageMarshallingConverter에 의해 Json String이 파라미터에 정의한 타입에 맞게 알아서 잘 deserializing 해줬을 것입니다.</li></ul><h1 id="spring-cloud-stream-binder-kafka-streams-234">spring-cloud-stream-binder-kafka-streams 2.3.4</h1><p>대부분의 코드 및 설정은 2.2.0 버전과 같습니다.<br>하지만 2.2.0을 default로 세팅해서 사용하시는 분들은 버전 업 후에는 잘 안되는것을 보실수 있습니다.<br>2.3.4에서 크게 바뀐 점 한 가지로 인해서 코드가 정상적으로 동작하지 않을 수 있게 되었습니다.</p><h2 id="usenativedecoding의-default가-true로-변경">useNativeDecoding의 default가 true로 변경</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When set to true, the inbound message is deserialized directly by client library,</span></span><br><span class="line"><span class="comment"> * which must be configured correspondingly (e.g. setting an appropriate Kafka</span></span><br><span class="line"><span class="comment"> * producer value serializer). <span class="doctag">NOTE:</span> This is binder specific setting which has no</span></span><br><span class="line"><span class="comment"> * effect if binder does not support native serialization/deserialization. Currently</span></span><br><span class="line"><span class="comment"> * only Kafka binder supports it. Default: 'false'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useNativeDecoding;</span><br></pre></td></tr></table></figure></p><p>2.3.4의 ConsumerProperties의 useNativeDecoding 주석을 보면 여전히 Default: false로 표기되어 있습니다.<br>하지만 로직 상에서는 아무런 처리도 하지 않은 <strong>useNativeDecoding의 값이 true로 나오게 됩니다.</strong></p><p><strong>어디서 useNativeDecoding 값을 true로 바꿨을까요?</strong><br>call tree를 찾아보니 다행히도 딱  세 군데에서만 호출하고 있습니다.</p><ul><li>KStreamBoundElementFactory</li><li>KTableBoundElementFactory</li><li>GlobalKTableBoundElementFactory</li></ul><p><img src="./createInput2-2-0.png" alt="createInput 2.2.0"><img src="./createInput.png" alt="createInput 2.3.4"></p><p>createInput 메서드에 집중해 보겠습니다.<br>createInput 메서드는 @StreamListener에 대한 post processing 단계에서 호출되는 코드입니다.</p><p>parameter로 들어오는 name은 input binding name입니다. (@StreamListener에 설정한 input name)<br>코드를 보면 consumerProperties의 useNativeDecoding을 무조건 true로 만들어 주고 있습니다.<br>(2.2.0 버전에서는 없던 코드가 추가되었습니다. useNativeDecoding이 default false였네요)</p><ul><li>KStreamBoundElementFactory</li><li>KTableBoundElementFactory</li><li>GlobalKTableBoundElementFactory</li></ul><p>그래서 useNativeDecoding가 true가 되었다는 의미는<br><strong>더이상 kafka에서 제공하는 Message Type으로 자동 deserializing이 되지 않고 개발자가 하나하나 deserializer을 지정해주어야 함을 의미합니다.</strong></p><p>이를 해결하기 위한 방법은 2가지 있습니다.</p><ol><li>useNativeDecoding을 false로 설정한다. =&gt; 다시 kafka에서 제공하는 자동 deserialize 기능을 사용한다.</li><li>binding input 별로 하나하나 deserializer를 지정한다.</li></ol><p>해결방법을 보고나니 spring에서 왜 이렇게 코드를 변경했는지 알 것만 같습니다.</p><p>기존에는 별도로 지정하지 않게 되면 무조건 자동 deserialize가 되도록 했는데,<br>일부러 true로 바꾸었다는 것은 bindings 별로 deserializer를 각각 지정하도록 권장하는 것 같습니다.</p><h2 id="1-usenativedecoding을-false로-설정한다">1. useNativeDecoding을 false로 설정한다.</h2><p><img src="./createInput.png" alt="createInput"></p><p>위의 코드를 잘 보게되면, encodingDecodingBindAdviceHandler.isDecodingSettingProvided() = false일때 true로 설정하게 합니다.<br>저 코드도 궁금해서 한번 들어가보았습니다.</p><p><img src="./EncodingDecodingBindAdviceHandler.png" alt="EncodingDecodingBindAdviceHandler"></p><p>apply() 메서드를 보게되면 spring configuration properties를 모두 읽으면서 조건에 맞는 configName을 찾고 있습니다.<br>아마도 <code>spring.cloud.streams.binding.[input-name].use-native-decoding</code> 또는 <code>encoding</code>을 찾는가 봅니다.<br>저게 설정이 있으면 true로 변경되니 일단 원하는대로 설정을 해줘보겠습니다.</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.stream.bindings.message-topic.use-native-decoding=false</span><br></pre></td></tr></table></figure></p><p>이렇게 하면 use-native-decoding 설정이 false가 되어 2.2.0에서 제공하던 kafka의 자동 deserialize 기능이 동작해서 이전버전과 동일하게 동작합니다.</p><blockquote><p>주의) use-native-decoding default 설정을 다시 전체 false로 하고 싶은데..<br>아쉽게도 binder 별로 설정이 적용되어 전체를 하기 어렵게 되었습니다.<br>귀찮더라도 하나하나 지정해 줍시다.</p><p>spring.cloud.stream.bindings.message-topic1.use-native-decoding=false<br>spring.cloud.stream.bindings.message-topic2.use-native-decoding=false</p></blockquote><h2 id="2-binding-input-별로-하나하나-deserializer를-지정한다">2. binding input 별로 하나하나 deserializer를 지정한다.</h2><p>이번 spring-kafka 버전에서 원하는대로 input 별로 하나하나 deserializer를 지정해 주겠습니다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageSerde</span> <span class="keyword">implements</span> <span class="title">Serde</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Serializer&lt;Message&gt; <span class="title">serializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (topic, data) -&gt; JsonUtils.toByteArray(data);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Deserializer&lt;Message&gt; <span class="title">deserializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (topic, data) -&gt; JsonUtils.fromJson(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>참고. JsonUtils는 제가 만든 Json 변환 Utils입니다.</code></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    stream:</span><br><span class="line">      kafka:</span><br><span class="line">        streams:</span><br><span class="line">          binder:</span><br><span class="line">           configuration:</span><br><span class="line">            default:</span><br><span class="line">              key.serde: org.apache.kafka.common.serialization.Serdes$StringSerde</span><br><span class="line">              value.serde: org.springframework.kafka.support.serializer.JsonSerde</span><br><span class="line">          bindings:</span><br><span class="line">            message-topic:</span><br><span class="line">              consumer:</span><br><span class="line">                applicationId: messageDispatcher</span><br><span class="line">                keySerde: org.apache.kafka.common.serialization.Serdes$StringSerde</span><br><span class="line">                valueSerde: com.my.packages.serde.MessageSerde</span><br></pre></td></tr></table></figure></p><p><strong>주의) property의 depth가 깊어서 틀리지 않게 주의해야 합니다.</strong></p><p>default key, value serde는 <code>spring.cloud.stream.kafka.streams.binder.configuration</code> 아래에 정의합니다.<br>binding input 별 key, value serde는 <code>spring.cloud.stream.kafka.streams.bindings.[input-name].consumer</code> 아래에 정의합니다.</p><h1 id="추가내용">추가내용</h1><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-stream-binder-kafka/3.0.0.M3/reference/html/spring-cloud-stream-binder-kafka.html#_kafka_streams_properties" target="_blank" rel="noopener">https://cloud.spring.io/spring-cloud-static/spring-cloud-stream-binder-kafka/3.0.0.M3/reference/html/spring-cloud-stream-binder-kafka.html#_kafka_streams_properties</a></p><p>내용을 보면 <code>useNativeEncoding</code> 과 <code>useNativeDecoding</code> 의 default value가 true라고 알려주고 있습니다.<br>spring-cloud-stream의 backend가 무엇이냐에 따라 default 값이 달라지므로 주의해야할 것 같습니다.<br>(kafka에서는 default가 true이고 다른 backend는 default가 false일 수 있습니다.)</p>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/12/23/2019-12-23-kafka-streams-binder-feature/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Custom @Enable Annotation 만들어보기</title>
      <link>https://jaehun2841.github.io/2019/12/22/2019-12-22-spring-import/</link>
      <guid>https://jaehun2841.github.io/2019/12/22/2019-12-22-spring-import/</guid>
      <pubDate>Sun, 22 Dec 2019 07:04:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;multi-모듈-프로젝트에서-발생하는-일&quot;&gt;Multi 모듈 프로젝트에서 발생하는 일&lt;/h1&gt;
&lt;p&gt;Maven, Gradle을 이용해서 멀티 모듈을 구성하다 보면 각 모듈 별로 중복된 Bean을 계속 생성 코드를 만드는 경우가 있습니다.&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="multi-모듈-프로젝트에서-발생하는-일">Multi 모듈 프로젝트에서 발생하는 일</h1><p>Maven, Gradle을 이용해서 멀티 모듈을 구성하다 보면 각 모듈 별로 중복된 Bean을 계속 생성 코드를 만드는 경우가 있습니다.<br>(ex: Datasource, TransactionManager 등등)</p><blockquote><p>예시 : Custom Module에서만 사용하는 JPA 환경 구성입니다.<br>일반적으로 하나의 DataSource를 사용하신다면, Spring AutoConfiguration을 이용하면 편리하게 구성하실 수 있습니다.<br>하지만 실무에서는 DataSource를 2개 이상 구성해서 쓰는 경우도 있기에, 직접 경험한 예시를 사용하게 되었습니다.</p></blockquote><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EntityScan</span>(basePackages = &#123;<span class="string">"com.your.packages.module1"</span>&#125;)</span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>(basePackages = &#123;<span class="string">"com.your.packages.module1"</span>&#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module_1_Configuration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.custom-module.datasource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> HikariConfig <span class="title">hikariConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariConfig();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@FlywayDatasource</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    EntityManagerFactoryBuilder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">    DataSource dataSource</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="string">"com.your.packages.module1"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EntityScan</span>(basePackages = &#123;<span class="string">"com.your.packages.module2"</span>&#125;)</span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>(basePackages = &#123;<span class="string">"com.your.packages.module2"</span>&#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module_2_Configuration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.custom-module.datasource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> HikariConfig <span class="title">hikariConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariConfig();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    EntityManagerFactoryBuilder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">    DataSource dataSource</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="string">"com.your.packages.module2"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 두 Configuation 코드는 99% 같은 코드입니다.<br>하지만 왜 같은 코드 두개를 짰을까요?</p><p>첫 번째는 packages 설정이 달랐습니다.</p><ul><li>packages(&quot;com.your.packages.module1&quot;)</li><li>packages(&quot;com.your.packages.module2&quot;)</li></ul><p>두 번째는 EntityScan, EnableJpaRepositories의 basePackages 설정이 달랐습니다.</p><ul><li>basePackages = {&quot;com.your.packages.module1&quot;}</li><li>basePackages = {&quot;com.your.packages.module2&quot;}</li></ul><p>세 번째는</p><ul><li>module1에서는 DataSource Bean에 <code>@FlywayDataSource</code> annotation이 있고</li><li>module2에서는 DataSource Bean에 <code>@FlywayDataSource</code> annotation이 없습니다.</li></ul><p>코드가 거의 같더라도, 약간의 설정이 다르다는 이유로 거의 같은 두 개의 Configuration을 사용했습니다.</p><h1 id="리팩토링1-enablecustomdatasource">리팩토링1 - @EnableCustomDataSource</h1><p>Spring을 사용하다 보면 @Enable~ 하는 Annotation을 자주 보았을 것이고, 실제로도 많이 사용해 보셨을 겁니다.</p><ul><li>EnableCaching</li><li>EnableTransactionManagement</li><li>EnableJpaRepositories</li><li>EnableConfigurationProperties</li><li>EnableAsync</li></ul><p>이 처럼 많은 Enable Annotation들을 Spring에서 사용하고 있고, 실제로 개발자가 해야할 귀찮은<br>Configuration이나 BeanPostProcessing 같은 처리들을 손쉽게 하도록 도와줍니다.</p><p>그렇기 때문에 이번 리팩토링도 Spring의 이런 부분을 벤치마킹하여 <code>@EnableCustomDataSource</code> 를 한번 만들어 보겠습니다.</p><p>최종적인 모습은 아래와 같은 코드로 깔끔하게 리팩토링을 하는 그림이면 좋겠네요</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCustomDataSource</span>(basePackage = &#123;<span class="string">"com.your.packages.module1"</span>&#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module1Configuration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="리팩토링2-다른-enable~-annotation-내부는-어떻게-생겼을까">리팩토링2 - 다른 @Enable~ Annotation 내부는 어떻게 생겼을까?</h1><p><img src="./EnableAsync.png" alt="EnableAsync"></p><p><img src="./EnableConfigurationProperties.png" alt="EnableConfigurationProperties"></p><p><img src="./EnableJpaRepositories.png" alt="EnableJpaRepositories"></p><p>혹시 3개의 Annotation의 공통점이 보이시나요?<br>모두 <code>@Import</code> Annotation을 통해 어떤 class를 import하고 있습니다.<br>대부분의 Enable의 Annotation은 위와 같이 Configuration 클래스를 Import하는 형식으로 많이 작성되고 있습니다.<br>(이외에는 SpringAutoConfiguration으로 작동하는 것들도 있는 것 같습니다.)</p><h1 id="리팩토링3-enablecustomdatasource-생성">리팩토링3 - @EnableCustomDataSource 생성</h1><p>위 에서 많은 개발자들이 만든 @Enable Annotation 생성 방식을 모방하여 만들어 보겠습니다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.Type)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(??.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>일단 @EnableCustomDataSource를 만들었습니다.<br>근데 @Import Annotation에 지정할 Configuration Class가 없어서.. 어떻게 해야 할지 잘 모르겠네요.<br>위에는 2개의 Configuration이 있는데 말이죠</p><h1 id="리팩토링-4-importselector를-이용한-선택적-configuration-사용">리팩토링 4 - ImportSelector를 이용한 선택적 Configuration 사용</h1><p>spring-context 라이브러리에서는 @Import Annotation processing에 대한 3가지 Interface를 지원합니다.</p><ul><li>ImportSelector</li><li>ImportBeanDefinitionRegistrar</li><li>ImportAware</li></ul><p>먼저 ImportSelector를 사용하여 선택적으로 Configuration을 사용해 보겠습니다.ImportSelector는 Annotation Attribute의 값에 따라 Import할 Configuration을 지정할 수 있습니다.</p><p>그렇기 때문에 @EnableCustomDataSource의 Attribute를 수정해보았습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.Type)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(CustomDataSourceConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">  <span class="function">Module <span class="title">module</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Module &#123; ONE, TWO &#125;</span><br></pre></td></tr></table></figure></p><p>ImportSelector를 구현한 CustomDataSourceConfigurationSelector 코드를 구성하였습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceConfigurationSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//find annotation attribute (module)</span></span><br><span class="line">    Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">    AnnotationAttributes attributes = AnnotationAttributes.fromMap(metaData);</span><br><span class="line">    Module <span class="keyword">module</span> = attributes.getEnum(<span class="string">"module"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//determine configuration class</span></span><br><span class="line">    String configurationClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">module</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> ONE:</span><br><span class="line">          configurationClass = Module_1_Configuration.class.getName();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TWO:</span><br><span class="line">          configurationClass = Module_2_Configuration.class.getName();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;configurationClass&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Module1의 CustomDataSourceConfiguration에서 Module.ONE이라고 설정을 정의해주면<br>Module_1_Configuration에 대한 설정을 Import할 수 있습니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCustomDataSource</span>(<span class="keyword">module</span> = Module.ONE)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="리팩토링-5-importbeandefinitionregistrar를-이용한-직접-bean-생성하기">리팩토링 5 - ImportBeanDefinitionRegistrar를 이용한 직접 Bean 생성하기</h1><p>ImportBeanDefinitionRegistrar를 이용하면 직접 beanRegistry에 Bean을 등록할 수 있습니다.</p><blockquote><p>하지만 추천하는 방식은 아닙니다.<br>실제로 Bean이 등록되는 순서를 제어하기 어렵기 때문에 원하는대로 실행이 되지 않을 수 있습니다.<br>토비의 스프링 ver2에서도 가급적이면 사용을 하지 않을 것을 권장하고 있습니다.</p></blockquote><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">"customDataSourceConfiguration"</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">      Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">      AnnotationAttributes attributes = AnnotationAttributes.fromMap(metaData);</span><br><span class="line">      EnableCustomDataSource.Module <span class="keyword">module</span> = attributes.getEnum(<span class="string">"module"</span>);</span><br><span class="line"></span><br><span class="line">      AbstractBeanDefinition beanDefinition = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">module</span>) &#123;</span><br><span class="line">          <span class="keyword">case</span> ONE:</span><br><span class="line">              beanDefinition = BeanDefinitionBuilder</span><br><span class="line">                      .rootBeanDefinition(Module_1_Configuration.class)</span><br><span class="line">                      .getBeanDefinition();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> TWO:</span><br><span class="line">              beanDefinition = BeanDefinitionBuilder</span><br><span class="line">                      .rootBeanDefinition(Module_2_Configuration.class)</span><br><span class="line">                      .getBeanDefinition();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      registry.registerBeanDefinition(BEAN_NAME, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.Type)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(CustomDataSourceBeanDefinitionRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">  <span class="function">Module <span class="title">module</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="리팩토링-6-importaware를-이용한-annoataion-attribute-주입">리팩토링 6 - ImportAware를 이용한 Annoataion attribute 주입</h1><p>마지막으로 ImportAware입니다.</p><p>ImportAware interface는 @Import하는 Configuration class에 @Import 메타 annoatation을 사용하는 annoatation의 attribute를 사용할 수 있도록 해줍니다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.Type)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(CustomDataSourceConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.custom-module.datasource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> HikariConfig <span class="title">hikariConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariConfig();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    EntityManagerFactoryBuilder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">    DataSource dataSource</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="string">"com.your.packages.module2"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(annoatationMetadata: AnnotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//use @EnableCustomDataSource annotation attribute</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 @EnableCustomDataSource annotation의 attribute를 사용할 수 있는 메서드를 제공합니다.</p><p>그렇게 되면, 애초에 2개의 파일로 분리되었던</p><ul><li>Module_1_Configuration</li><li>Module_2_Configuration</li></ul><p>이 두가지 파일을 하나로 합칠 수 있을 것 같습니다.</p><p>두개의 파일을 하나로 합쳐서 CustomDataSourceConfiguration이라는 class를 만들고<br>@EnableCustomDataSource annotation에서 @Import 해보겠습니다.</p><h2 id="basepackages-attribute-추가">basePackages attribute 추가</h2><p>@EnableCustomDataSource annotation의 attribute를 조금 변경해 보겠습니다.<br>여태까지 사용한 module attribute는 이제 의미가 없을 것 같습니다.<br>파일을 하나로 합치기로 했기 때문이죠</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.Type)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(CustomDataSourceConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">  String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Module1Configuration class에 드디어 우리가 원하던 대로 @EnableCustomDataSource를 사용해보게 되었습니다.<br>이게 껍데기는 완성되었고 내부 로직만 잘 구성하면 될듯 합니다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCustomDataSource</span>(basePackages = &#123;<span class="string">"com.your.package.module1"</span>&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module1Configuration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="importaware-메서드-코드-구성">ImportAware 메서드 코드 구성</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String[] basePackages;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.custom-module.datasource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> HikariConfig <span class="title">hikariConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariConfig();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    EntityManagerFactoryBuilder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">    DataSource dataSource</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="keyword">this</span>.basePackages)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(annoatationMetadata: AnnotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//use @EnableCustomDataSource annotation attribute</span></span><br><span class="line">    Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">    AnnotationAttributes attributes = AnnotationAttributes.fromMap(metaData);</span><br><span class="line">    </span><br><span class="line">    String[] basePackages = attributes.get(<span class="string">"basePackages"</span>);</span><br><span class="line">    <span class="keyword">this</span>.basePackages = basePackages; <span class="comment">// initialize member variable basePackages</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CustomDataSourceConfiguration을 @Import를 통해 Import하게 되면 @Bean 메서드 보다 setImportMetadata가 먼저 실행됩니다.<br>(이유는 ImportAwareBeanPostProcessor에 의해 @Configuration Bean 초기화 이전에 setImportMetadata 메서드가 실행되기 때문입니다.)</p><blockquote><p>주의: ImportAware를 구현한 Configuration class에는 반드시 @Configuration Annotation을 붙여야 합니다.그래야 Spring 내부적으로 ConfigurationClassPargser가 작동할 때 scan 되어 나중에 ImportAwareBeanPostProcessor에 의해 Post Processing이 될 수 있습니다.</p></blockquote><h1 id="리팩토링-7-아직-끝나지-않았다">리팩토링 7 - 아직 끝나지 않았다.</h1><p>아직 끝나지 않았습니다.</p><p>Configuration class를 두 개로 나눈 두번째 이유 @EntityScan, @EnableJpaRepositories의 basePackages에 대한 설정이 다르기 때문입니다.<br>이 문제를 해결하기 위해서는 Spring에서 제공하는 @AliasFor annoataion을 사용해 보았습니다.</p><p><img src="./AliasFor.png" alt="AliasFor"></p><p>@AliasFor Annotation은 Spring 4.2에서 추가된 Annotation입니다.</p><ul><li>AliasFor을 이용해 Attribute의 다른 속성에 값을 바인딩 할 수 있습니다.<br>위의 예시처럼 value로 들어온 값을 attribute의 값에 바인딩</li><li>Annotation의 메타 Annotation의 attribute에 값을 바인딩 할 수 있습니다.<strong>(우리는 이 기능을 사용해 보도록 할 것입니다.)</strong></li></ul><blockquote><p>주의: Spring framework 5.2 하위버전에서 AliasFor이 Array에 대해서는 잘 적용이 안되는 이슈가 있었습니다.<br>이 이슈는 Spring framework 5.2, Springboot 2.2.0 이후에는 잘 적용이 됩니다.<br>혹시나 적용이 안되시는 분은 Spring version up을 권장드립니다.</p></blockquote><h2 id="enablecustomdatasource-수정">@EnableCustomDataSource 수정</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.Type)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@EntityScan</span> <span class="comment">// meta annotation으로 추가</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span> <span class="comment">// meta annotation으로 추가</span></span><br><span class="line"><span class="meta">@Import</span>(CustomDataSourceConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">  <span class="meta">@AliasFor</span>(annotation = EntityScan.class, attribute = <span class="string">"basePackages"</span>)</span><br><span class="line">  String[] jpaEntityBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">  <span class="meta">@AliasFor</span>(annotation = EnableJpaRepositories.class, attribute = <span class="string">"basePackages"</span>)</span><br><span class="line">  String[] jpaRepositoriesBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@AliasFor annotation은 @Repeatable meta annotation이 없기 때문에 하나의 메서드에 중첩해서 사용할 수 없습니다.<br>그렇기 때문에 @EntityScan에 대한 basePackages를 설정할 수 있는 메서드와<br>@EnableJpaRepositories에 대한 basePacakges를 설정할 수 있는 메서드로 분리 하였습니다.</p><p>위와 같이 설정해 주면<br>jpaEntityBasePackages -&gt; <code>EntityScan.basePackages</code>로 바인딩 됩니다.<br>jpaRepositoriesBasePackages -&gt; <code>EnableJpaRepositories.basePackages</code>로 바인딩 됩니다.<br>물론 EnableCustomDataSource의 attribute로도 사용할 수 있습니다.</p><h2 id="customdatasourceconfiguration-수정">CustomDataSourceConfiguration 수정</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String[] basePackages;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(annoatationMetadata: AnnotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//use @EnableCustomDataSource annotation attribute</span></span><br><span class="line">    Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">    AnnotationAttributes attributes = AnnotationAttributes.fromMap(metaData);</span><br><span class="line">    </span><br><span class="line">    String[] basePackages = attributes.get(<span class="string">"jpaEntityBasePackages"</span>);</span><br><span class="line">    <span class="keyword">this</span>.basePackages = basePackages; <span class="comment">// initialize member variable basePackages</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>attribute가 변경되어 attribute명을 변경하였습니다.</p><h1 id="리팩토링-8-flywaydatasource는-어째요">리팩토링 8 - FlywayDataSource는 어째요?</h1><p>Flyway는 Database 자동 구성에 도움을 주는 라이브러리입니다.<br>(저장된 sql을 versioning하고 내부적으로 version관리를 하여 자동으로 Database를 초기화 하도록 해줍니다.)</p><p>이런 FlywayDatasource는 보통 하나의 모듈에서만 초기화 하게됩니다.<br>보통 하나의 DataSource만 사용하는 상황에서는 Flyway를 적용하는 대상도 하나이기 때문에 문제가 안되지만<br>지금과 같은 다중 DataSource를 사용하는 상황에서는 제약이 생길 수 있습니다.</p><p>그래서 @FlywayDataSource annotation을 지정하여 이 DataSource에 Flyway를 적용할 지 말지 결정할 수 있습니다.<br>여기서는 Springboot에서 제공하는 @ConditionalOnProperty를 이용하여 Bean 생성을 해보도록 하겠습니다.</p><p><img src="./ConditionalOnProperty.png" alt="ConditionalOnProperty"></p><ul><li><strong>prefix</strong>: 사용하고자 하는 property의 prefix입니다.</li><li><strong>name</strong>: Condition에 유효한 property인지 테스트할 property명</li><li><strong>havingValue</strong>: prefix + name property의 값이 어떤 value일 경우 조건식이 참이 될지 결정하는 값입니다.</li><li><strong>matchIfMissing</strong>: property를 찾을 수 없는 경우 조건식의 default 값을 정의합니다.</li></ul><h2 id="property-추가">property 추가</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.custom.datasource.flyway.enable = true</span><br></pre></td></tr></table></figure></p><p>이와 같이 custom property를 추가해보겠습니다. (custom datasource에 대한 flyway를 쓸지 말지에 대한 설정입니다.)</p><h2 id="customdatasourceconfiguration-수정">CustomDataSourceConfiguration 수정</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDataSourceConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.custom-module.datasource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> HikariConfig <span class="title">hikariConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariConfig();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ConditionalOnProperty</span>(</span><br><span class="line">    prefix = <span class="string">"spring.custom.datasource.flyway"</span>, </span><br><span class="line">    name = [<span class="string">"enable"</span>],</span><br><span class="line">    havingValue = <span class="string">"true"</span>, </span><br><span class="line">    matchIfMissing = <span class="keyword">false</span></span><br><span class="line">  )</span><br><span class="line">  <span class="meta">@FlywayDataSource</span></span><br><span class="line">  <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceUsingFlyway</span><span class="params">(HikariConfig hikariConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ConditionalOnProperty</span>(</span><br><span class="line">    prefix = <span class="string">"spring.custom.datasource.flyway"</span>, </span><br><span class="line">    name = [<span class="string">"enable"</span>],</span><br><span class="line">    havingValue = <span class="string">"false"</span>, </span><br><span class="line">    matchIfMissing = <span class="keyword">true</span></span><br><span class="line">  )</span><br><span class="line">  <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  EntityManagerFactoryBuilder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">    DataSource dataSource</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="string">"com.your.packages.module2"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(annoatationMetadata: AnnotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//use @EnableCustomDataSource annotation attribute</span></span><br><span class="line">    Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">    AnnotationAttributes attributes = AnnotationAttributes.fromMap(metaData);</span><br><span class="line">    </span><br><span class="line">    String[] basePackages = attributes.get(<span class="string">"jpaEntityBasePackages"</span>);</span><br><span class="line">    <span class="keyword">this</span>.basePackages = basePackages; <span class="comment">// initialize member variable basePackages</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이와 같이 CustomDataSourceConfiguration에서 DataSource Bean을 생성하는 코드를 두개로 하고<br><code>spring.custom.datasource.flyway.enable</code> 값에 따라 자동으로 Bean을 생성하도록 코드를 구성하였습니다.</p><p>FlywayDataSource를 사용하는 module에만 <code>spring.custom.datasource.flyway.enable</code> 를 추가하여 Bean이 생성되도록 하였습니다.<br>FlywayDataSource를 사용하지 않는 module에는 <code>spring.custom.datasource.flyway.enable</code> 를 설정하지 않고 사용하여<br>일반적인 DataSource만 사용하도록 구성하였습니다.</p><h1 id="참고">참고</h1><ul><li>토비의 스프링 Ver.2</li><li><a href="https://medium.com/@circlee7/spring-conditional-annotation-e288ccf6b536" target="_blank" rel="noopener">Spring Conditional annotation</a></li><li><a href="https://docs.spring.io/spring/docs/4.2.0.RC2_to_4.2.0.RC3/Spring%20Framework%204.2.0.RC3/org/springframework/core/annotation/AliasFor.html" target="_blank" rel="noopener">Spring AliasFor</a></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/12/22/2019-12-22-spring-import/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Rest Docs를 이용한 API 문서 만들기</title>
      <link>https://jaehun2841.github.io/2019/08/04/2019-08-04-spring-rest-docs/</link>
      <guid>https://jaehun2841.github.io/2019/08/04/2019-08-04-spring-rest-docs/</guid>
      <pubDate>Sun, 04 Aug 2019 06:02:21 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Spring Rest API 문서를 자동으로 생성하고자  할 때, 보통 Swagger로 많이 사용하지만
이번에는 Spring Rest Docs를 사용하여 API 문서를 자동으로 작성 할 수 있도록 해봤습니다.&lt;/p&gt;
&lt;p&gt;포스팅에 작성된 코드는 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Spring Rest API 문서를 자동으로 생성하고자  할 때, 보통 Swagger로 많이 사용하지만이번에는 Spring Rest Docs를 사용하여 API 문서를 자동으로 작성 할 수 있도록 해봤습니다.</p><p>포스팅에 작성된 코드는 <a href="https://github.com/jaehun2841/spring-rest-docs-example" target="_blank" rel="noopener">https://github.com/jaehun2841/spring-rest-docs-example</a> 에서 참고하시길 바랍니다.</p><h1 id="spring-rest-docs란">Spring Rest Docs란</h1><p>Spring Rest Docs는 테스트 코드를 기반으로 자동으로 API문서를 작성할 수 있게 해주는 프레임워크입니다.<br>그렇기 때문에 반드시 <code>Test가 통과되어야 문서가 작성</code> 된다는 장점이 있습니다.<br>(그렇기 때문에 API Spec이 변경되거나 추가/삭제 되는 부분에 대해 항상 테스트 코드를 수정하여야 하며, API 문서가 최신화 될 수 있도록 해줍니다.)<br>기본적으로 asciidoc을 사용하여 문서를 작성합니다 . (asciidoc은 마크다운과 비슷하게 html문서를 작성할 수 있는 언어입니다.)<br>원하는 경우에는 mark down을 사용할 수도 있지만, 이번 포스트에서는 asciidoc을 이용하여 API 문서를 작성해 보도록 하겠습니다.</p><h1 id="spring-rest-docs-architecture">Spring Rest Docs Architecture</h1><p><img src="./asciidoctor.png" alt="asciidoctor-task"></p><ul><li>Test Case를 수행하면 산출물이 &lt;document-name&gt;.adoc 파일로 /build/generate-snippets 디렉토리에 생성됩니다. (default path)</li><li>/src/docs/asciidoc 디렉토리에 /build/generate-snippets에 있는 adoc 파일을 include하여 문서를 생성할 수 있습니다.<ul><li>/build/generate-snippets/*.adoc 파일들은 API Request, Response에 대한 명세들만 있는 파일이고</li><li>/src/docs/asciidoc/*.adoc 파일들이 실제 사용자에게 html파일로 변환되어 제공되는 API 문서 파일입니다.</li><li>따라서 /src/docs/asciidoc/*.adoc 에 API 문서를 작성하고,<br>필요한 API Request, Response Spec은 자동 생성된 /build/generate-snippets/*.adoc 파일들을 이용해 표현해줍니다.</li><li>이렇게 하면 향후 API Spec이 변경되더라도, 문서를 수정하지 않아도 되는 장점이 있습니다.</li></ul></li><li>이렇게 생성된 asciidoc 문서는 AsciidoctorTask를 통해 html 문서로 processing 되어 /build/asciidoc/html5 하위에 html문서로 생성됩니다.<ul><li>html 문서가 생성되는 기준은 /src/docs/asciidoc/*.adoc 파일을 기준으로 생성됩니다.</li></ul></li></ul><h2 id="예시">예시</h2><h3 id="srcdocsasciidoc-디렉토리-내에-html로-제공될-문서를-asciidoc으로-작성">/src/docs/asciidoc 디렉토리 내에 html로 제공될 문서를 asciidoc으로 작성</h3><p><img src="./src-template.png" alt="docuement-templates"></p><h3 id="test-case의-산출물">Test Case의 산출물</h3><ul><li>/build/generated-snippets 디렉토리 하위에 생성</li><li>Request, Response Spec에 대한 정보를 생성</li><li>/src/docs/asciidoc/*.adoc 파일에서 include해서 사용<img src="./snippets.png" alt="snippets"></li></ul><h3 id="srcdocsasciidoc-디렉토리-adoc파일을-기반으로-생성된-html-파일">/src/docs/asciidoc 디렉토리 adoc파일을 기반으로 생성된 html 파일</h3><p><img src="./processed-html.png" alt="processed-html"></p><p>자세한 부분은 아래 예시를 따라하면서 보시면 좋을 것 같습니다.</p><h1 id="spring-rest-docs-시작하기">Spring Rest Docs 시작하기</h1><h2 id="개발-스펙">개발 스펙</h2><ul><li>Spring Boot 2.1.6.RELEASE</li><li>Junit 5</li><li>Kotlin 1.3.41 (저희 팀에서 코틀린만 써서 코틀린이 편하네요)</li><li>Gradle 5.4.1</li><li>Asciidoctor 1.5.9.2</li></ul><h2 id="test-library">Test Library</h2><p>Spring Rest Docs는 3가지 테스트 라이브러리를 지원합니다.</p><ul><li>MockMvc (@WebMvcTest)</li><li>WebTestClient (Mono / Flux, @WebTestClient)</li><li>Rest Assured (IntegrationTest, @SpringBootTest)</li></ul><p>API 문서를 작성할 때 Spring Mvc를 사용하는 환경이라면 가장 가볍게 돌릴 수 있는게 MockMvc를 사용하는 것이라 생각합니다.<br>그래서 이번 포스팅에서는 MockMvc를 사용한 예제로만 진행하도록 하겠습니다.</p><h2 id="gradle-설정">Gradle 설정</h2><h3 id="asciidoctor-plugin-설정">asciidoctor plugin 설정</h3><p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        kotlinVersion = <span class="string">'1.3.41'</span></span><br><span class="line">        springBootVersion = <span class="string">"2.1.6.RELEASE"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$springBootVersion"</span></span><br><span class="line">        classpath <span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'org.asciidoctor.convert'</span> version <span class="string">'1.5.9.2'</span></span><br><span class="line">    id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.1.6.RELEASE'</span></span><br><span class="line">    id <span class="string">"io.spring.dependency-management"</span> version <span class="string">"1.0.5.RELEASE"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"groovy"</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"org.springframework.boot"</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"io.spring.dependency-management"</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin-kapt"</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'com.example'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="string">'1.8'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    set(<span class="string">'snippetsDir'</span>, file(<span class="string">"build/generated-snippets"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line">    testImplementation(<span class="string">"org.springframework.boot:spring-boot-starter-test"</span>) &#123;</span><br><span class="line">        exclude <span class="string">group:</span> <span class="string">"junit"</span>, <span class="string">module:</span> <span class="string">"junit"</span></span><br><span class="line">    &#125;</span><br><span class="line">    testImplementation <span class="string">"org.junit.jupiter:junit-jupiter-api"</span></span><br><span class="line">    testImplementation <span class="string">"org.junit.jupiter:junit-jupiter-params"</span></span><br><span class="line">    testRuntimeOnly <span class="string">"org.junit.jupiter:junit-jupiter-engine"</span></span><br><span class="line">    testImplementation <span class="string">'org.springframework.restdocs:spring-restdocs-mockmvc'</span></span><br><span class="line">    testImplementation <span class="string">"com.nhaarman:mockito-kotlin:1.6.0"</span></span><br><span class="line">    implementation <span class="string">"org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlinVersion"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kapt &#123;</span><br><span class="line">    useBuildCache = <span class="literal">true</span></span><br><span class="line">    correctErrorTypes = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">    outputs.dir snippetsDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asciidoctor &#123;</span><br><span class="line">    inputs.dir snippetsDir</span><br><span class="line">    dependsOn test <span class="comment">//test Task 이후에 실행될 수 있도록 Dependency를 설정</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asciidoctor.doFirst &#123;</span><br><span class="line">    println <span class="string">"=====start asciidoctor"</span></span><br><span class="line">    <span class="comment">//asciidoctor 실행전 기존에 생성된 API 문서 삭제</span></span><br><span class="line">    delete file(<span class="string">'src/main/resources/static/docs'</span>)</span><br><span class="line">&#125;</span><br><span class="line">asciidoctor.doLast &#123;</span><br><span class="line">    println <span class="string">"=====finish asciidoctor"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task copyDocument(<span class="string">type:</span> Copy) &#123;</span><br><span class="line">    dependsOn asciidoctor</span><br><span class="line">    from file(<span class="string">"build/asciidoc/html5"</span>)</span><br><span class="line">    <span class="comment">// resources/static/docs 로 복사하여 서버가 돌아가고 있을때 /docs/index.html 로 접속하면 볼수 있음</span></span><br><span class="line">    into file(<span class="string">"src/main/resources/static/docs"</span>)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build &#123;</span><br><span class="line">    dependsOn copyDocument</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bootJar &#123;</span><br><span class="line">    archiveName = <span class="string">'app.jar'</span></span><br><span class="line">    dependsOn asciidoctor</span><br><span class="line">    <span class="comment">//실제 배포 시, BOOT-INF/classes가 classpath가 됩니다.</span></span><br><span class="line">    from (<span class="string">"$&#123;asciidoctor.outputDir&#125;/html5"</span>) &#123;</span><br><span class="line">        into <span class="string">"BOOT-INF/classes/static/docs"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileKotlin &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        freeCompilerArgs = [<span class="string">"-Xjsr305=strict"</span>]</span><br><span class="line">        jvmTarget = <span class="string">"1.8"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileTestKotlin &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        freeCompilerArgs = [<span class="string">"-Xjsr305=strict"</span>]</span><br><span class="line">        jvmTarget = <span class="string">"1.8"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar.enabled = <span class="literal">false</span></span><br><span class="line">bootJar.enabled = <span class="literal">true</span></span><br><span class="line">bootJar.mainClassName = <span class="string">'com.example.restdocs.RestdocsApplication'</span></span><br></pre></td></tr></table></figure></p><ul><li><code>testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc'</code> : mockMvc 테스트를 통해 API adoc 파일을 생성해주도록 하는 라이브러리 입니다.</li><li><code>id 'org.asciidoctor.convert' version '1.5.9.2'</code> : asciidoc 파일을 html 파일로 processing 해주는 플러그인 입니다.</li><li><code>asciidoctor</code> :  asciidoc 파일을 html 파일로 processing 해주는 Gradle Task를 정의합니다.</li></ul><h2 id="user-api-코드-작성">User API 코드 작성</h2><h2 id="usercontrollerkt">UserController.kt</h2><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Suppress(<span class="meta-string">"SpringJavaInjectionPointsAutowiringInspection"</span>)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/user"</span>)</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>(</span><br><span class="line">        <span class="keyword">val</span> userService: UserService</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/&#123;userId&#125;"</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable(value = <span class="meta-string">"userId"</span>)</span> userId: <span class="type">Long</span>)</span></span>: Response&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> searchUser = userService.search(userId)</span><br><span class="line">    <span class="keyword">return</span> Response.success(searchUser)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(<span class="meta">@RequestBody</span> userDto: <span class="type">UserDto</span>)</span></span>: Response&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> createUser = userService.create(User(name = userDto.name, address = userDto.address, age = userDto.age))</span><br><span class="line">    <span class="keyword">return</span> Response.success(createUser)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@PutMapping(<span class="meta-string">"/&#123;userId&#125;"</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">updateUser</span><span class="params">(<span class="meta">@PathVariable(<span class="meta-string">"userId"</span>)</span> userId: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="meta">@RequestBody</span> userDto: <span class="type">UserDto</span>)</span></span>: Response&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> updateUser = userService.update(User(id = userId, name = userDto.name, address = userDto.address, age = userDto.age))</span><br><span class="line">    <span class="keyword">return</span> Response.success(updateUser)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@DeleteMapping(<span class="meta-string">"/&#123;userId&#125;"</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable(value = <span class="meta-string">"userId"</span>)</span> userId: <span class="type">Long</span>)</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    userService.delete(userId)</span><br><span class="line">    <span class="keyword">return</span> Response.success()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping(<span class="meta-string">"/&#123;userId&#125;/role/&#123;roleId&#125;"</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">grantRole</span><span class="params">(<span class="meta">@PathVariable(value = <span class="meta-string">"userId"</span>)</span> userId: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="meta">@PathVariable(value = <span class="meta-string">"roleId"</span>)</span> roleId: <span class="type">Long</span>)</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">     userService.grantRole(userId = userId, roleId = roleId)</span><br><span class="line">    <span class="keyword">return</span> Response.success()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="userservicekt">UserService.kt</h2><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">search</span><span class="params">(userId: <span class="type">Long</span>)</span></span>: User?</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(user: <span class="type">User</span>)</span></span>: User?</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(user: <span class="type">User</span>)</span></span>: User?</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(userId: <span class="type">Long</span>)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">grantRole</span><span class="params">(userId: <span class="type">Long</span>, roleId: <span class="type">Long</span>)</span></span>: User?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="responsekt">Response.kt</h2><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">val</span> code: <span class="built_in">Int</span>,</span><br><span class="line">        <span class="keyword">val</span> message: String,</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span>: T?,</span><br><span class="line">        <span class="keyword">val</span> error: T?</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">success</span><span class="params">()</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; = success(<span class="literal">null</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">success</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>?)</span></span>: Response&lt;T&gt; = Response(<span class="number">200</span>, <span class="string">"OK"</span>, <span class="keyword">data</span>, <span class="literal">null</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">error</span><span class="params">(error: <span class="type">T</span>?)</span></span>: Response&lt;T&gt; = Response(<span class="number">500</span>, <span class="string">"Server Error"</span>, <span class="literal">null</span>, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="userkt">User.kt</h2><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">        <span class="keyword">val</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">val</span> name: String,</span><br><span class="line">        <span class="keyword">val</span> age: <span class="built_in">Int</span>,</span><br><span class="line">        <span class="keyword">val</span> address: String,</span><br><span class="line">        <span class="keyword">var</span> roles: MutableList&lt;Role&gt; = mutableListOf()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="test-코드-작성">Test 코드 작성</h2><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(RestDocumentationExtension::class, SpringExtension::class)</span> <span class="comment">// (1)</span></span><br><span class="line"><span class="meta">@WebMvcTest(UserController::class, secure = false)</span> <span class="comment">// (2)</span></span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span> <span class="comment">// (3)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> mockMvc: MockMvc <span class="comment">// (4)</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@MockBean</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> userService: UserService <span class="comment">// (5)</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> `user search api docs`<span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    given(userService.search((eq(<span class="number">1</span>L))))</span><br><span class="line">            .willReturn(User(<span class="number">1</span>, <span class="string">"배달이"</span>, <span class="number">10</span>, <span class="string">"서울특별시 송파구 올림픽로 295"</span>)) <span class="comment">// (6)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    <span class="keyword">val</span> resultActions = mockMvc.perform(</span><br><span class="line">            RestDocumentationRequestBuilders.<span class="keyword">get</span>(<span class="string">"/user/&#123;userId&#125;"</span>, <span class="number">1</span>)</span><br><span class="line">                    .header(<span class="string">"x-api-key"</span>, <span class="string">"API-KEY"</span>)</span><br><span class="line">                    .accept(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">    ).andDo(MockMvcResultHandlers.print()) <span class="comment">// (7)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//then</span></span><br><span class="line">    resultActions</span><br><span class="line">            .andExpect(status().isOk) <span class="comment">// (8)</span></span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-search"</span>, <span class="comment">// (9)</span></span><br><span class="line">                            getDocumentRequest(), <span class="comment">// (10)</span></span><br><span class="line">                            getDocumentResponse(), <span class="comment">// (11)</span></span><br><span class="line">                            requestHeaders(*header()),  <span class="comment">// (12)</span></span><br><span class="line">                          pathParameters(userIdPathParameter()),  <span class="comment">// (13)</span></span><br><span class="line">                            responseFields(*common())  <span class="comment">// (14)</span></span><br><span class="line">                                    .andWithPrefix(<span class="string">"data."</span>, *user()) </span><br><span class="line">                                    .andWithPrefix(<span class="string">"data.roles[]."</span>, *role())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;...&#125; <span class="comment">//중략..</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserDto</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"""</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        "name": "배달이",</span></span><br><span class="line"><span class="string">        "age": 10,</span></span><br><span class="line"><span class="string">        "address": "서울특별시 송파구 올림픽로 295"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    """</span>.trimIndent()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">header</span><span class="params">()</span></span>: Array&lt;HeaderDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arrayOf(headerWithName(<span class="string">"x-api-key"</span>).description(<span class="string">"Api Key"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">userIdPathParameter</span><span class="params">()</span></span>: ParameterDescriptor &#123;</span><br><span class="line">    <span class="keyword">return</span> parameterWithName(<span class="string">"userId"</span>).description(<span class="string">"USER ID"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">roleIdPathParameter</span><span class="params">()</span></span>: ParameterDescriptor &#123;</span><br><span class="line">    <span class="keyword">return</span> parameterWithName(<span class="string">"roleId"</span>).description(<span class="string">"ROLE ID"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">common</span><span class="params">()</span></span>: Array&lt;FieldDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arrayOf(</span><br><span class="line">            fieldWithPath(<span class="string">"code"</span>).type(JsonFieldType.NUMBER).description(<span class="string">"응답 코드"</span>),</span><br><span class="line">            fieldWithPath(<span class="string">"message"</span>).type(JsonFieldType.STRING).description(<span class="string">"응답 메세지"</span>),</span><br><span class="line">            subsectionWithPath(<span class="string">"error"</span>).type(JsonFieldType.OBJECT).description(<span class="string">"에러 Data"</span>).optional(),</span><br><span class="line">            subsectionWithPath(<span class="string">"data"</span>).type(JsonFieldType.OBJECT).description(<span class="string">"응답 Data"</span>).optional()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">user</span><span class="params">()</span></span>: Array&lt;FieldDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arrayOf(</span><br><span class="line">            fieldWithPath(<span class="string">"id"</span>).type(JsonFieldType.NUMBER).description(<span class="string">"User ID"</span>),</span><br><span class="line">            fieldWithPath(<span class="string">"name"</span>).type(JsonFieldType.STRING).description(<span class="string">"이름"</span>),</span><br><span class="line">            fieldWithPath(<span class="string">"age"</span>).type(JsonFieldType.NUMBER).description(<span class="string">"나이"</span>),</span><br><span class="line">            fieldWithPath(<span class="string">"address"</span>).type(JsonFieldType.STRING).description(<span class="string">"주소"</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">role</span><span class="params">()</span></span>: Array&lt;FieldDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arrayOf(</span><br><span class="line">            fieldWithPath(<span class="string">"id"</span>).type(JsonFieldType.NUMBER).description(<span class="string">"Role ID"</span>).optional(),</span><br><span class="line">            fieldWithPath(<span class="string">"name"</span>).type(JsonFieldType.STRING).description(<span class="string">"Role명"</span>).optional()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> RestApiDocumentUtils &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getDocumentRequest</span><span class="params">()</span></span>: OperationRequestPreprocessor &#123; <span class="comment">// (10)</span></span><br><span class="line">    <span class="keyword">return</span> Preprocessors.preprocessRequest(</span><br><span class="line">            modifyUris()</span><br><span class="line">              .scheme(<span class="string">"http"</span>)</span><br><span class="line">              .host(<span class="string">"user.api.com"</span>)</span><br><span class="line">              .removePort(),</span><br><span class="line">            Preprocessors.prettyPrint()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getDocumentResponse</span><span class="params">()</span></span>: OperationResponsePreprocessor &#123; <span class="comment">// (11)</span></span><br><span class="line">    <span class="keyword">return</span> Preprocessors.preprocessResponse(Preprocessors.prettyPrint())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="코드-설명">코드 설명</h3><ol><li>Junit5에서 Spring Rest Docs를 사용할 때, RestDocumentationExtension::class, SpringExtension::class Extension 두개를 사용합니다.<br>ExtendWith는 Junit 4 에서 RunWith와 같은 기능입니다.</li><li>@WebMvcTest annotation을 사용하여, mockMvc를 사용할 수 있는 환경을 설정합니다.</li><li>이 예제에서는 UserController에 대한 테스트와 API문서를 작성하므로, controller를 UserController로 지정합니다.</li><li>spring security를 사용하는 경우, <code>secure=false</code> 옵션을 통해 Spring Security 사용 안함으로 설정할 수 있습니다.</li><li>Spring Rest Docs에 대한 Auto Configuration을 설정합니다.</li><li>mockMvc를 사용하기 위해 MockMvc bean을 Autowiring 해줍니다.</li><li>UserService에 대한 Mocking을 위해 @MockBean annotation을 통해 Test Context에 bean으로 등록해줍니다.</li><li>UserService.search() function에 대한 stubbing을 해줍니다. (호출 시, return 되는 값 지정)</li><li>mockMvc를 이용하여, <code>GET /user/1</code> API를 호출 합니다.</li><li>API 호출 결과에 대해 간단한 status체크 정도로 테스트 항목을 추가했습니다.</li><li>andDo function으로 Asciidoc을 생성하도록 설정합니다.<br><code>user-search</code>는 테스트가 수행 된 후, adoc 파일이 생성될 디렉토리 이름입니다.<br><code>/build/generate-snippets/user-search/*.adoc</code> path에 adoc 파일이 생성됩니다.</li><li>DocumentRequest에 대한 설정을 추가합니다.</li><li>modifyUris()를 통해 adoc 파일에 어떤 도메인으로 API를 호출 할 지, 정의할 수 있습니다.(Default는 <code>http://localhost:8080</code> 입니다.)</li><li>Request Json을 이쁘장하게 출력하도록 해줍니다</li><li>DocumentResponse에 대한 설정을 추가합니다.</li><li>Response Json을 이쁘장하게 출력하도록 해줍니다</li><li>requestHeader 정보를 추가합니다.</li><li>path parameter 정보를 추가합니다.</li><li>responseFields 정보를 추가합니다.</li></ol><h2 id="document-생성하기">Document 생성하기</h2><p>asciidoctor를 이용하면 6개의 snippet 파일을 기본적으로 생성해줍니다.</p><h3 id="예시">예시</h3><ul><li><p><code>&lt;output-directory&gt;/&lt;document-name&gt;/curl-request.adoc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[source,bash]</span><br><span class="line">----</span><br><span class="line">$ curl &apos;http://user.api.com/user/1&apos; -i -X GET \</span><br><span class="line">    -H &apos;Accept: application/json;charset=UTF-8&apos; \</span><br><span class="line">    -H &apos;x-api-key: API-KEY&apos;</span><br><span class="line">----</span><br></pre></td></tr></table></figure></p></li><li><p><code>&lt;output-directory&gt;/&lt;document-name&gt;/http-request.adoc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[source,http,options=&quot;nowrap&quot;]</span><br><span class="line">----</span><br><span class="line">GET /user/1 HTTP/1.1</span><br><span class="line">Accept: application/json;charset=UTF-8</span><br><span class="line">Host: user.api.com</span><br><span class="line">x-api-key: API-KEY</span><br><span class="line"></span><br><span class="line">----</span><br></pre></td></tr></table></figure></p></li><li><p><code>&lt;output-directory&gt;/&lt;document-name&gt;/http-response.adoc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[source,http,options=&quot;nowrap&quot;]</span><br><span class="line">----</span><br><span class="line">GET /user/1 HTTP/1.1</span><br><span class="line">Accept: application/json;charset=UTF-8</span><br><span class="line">Host: user.api.com</span><br><span class="line">x-api-key: API-KEY</span><br><span class="line"></span><br><span class="line">----</span><br></pre></td></tr></table></figure></p></li><li><p><code>&lt;output-directory&gt;/&lt;document-name&gt;/httpie-request.adoc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[source,bash]</span><br><span class="line">----</span><br><span class="line">$ http GET &apos;http://user.api.com/user/1&apos; \</span><br><span class="line">    &apos;Accept:application/json;charset=UTF-8&apos; \</span><br><span class="line">    &apos;x-api-key:API-KEY&apos;</span><br><span class="line">----</span><br></pre></td></tr></table></figure></p></li><li><p><code>&lt;output-directory&gt;/&lt;document-name&gt;/request-body.adoc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[source,http,options=&quot;nowrap&quot;]</span><br><span class="line">----</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;홍길동&quot;</span><br><span class="line">&#125;</span><br><span class="line">----</span><br></pre></td></tr></table></figure></p></li><li><p><code>&lt;output-directory&gt;/&lt;document-name&gt;/response-body.adoc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[source,options=&quot;nowrap&quot;]</span><br><span class="line">----</span><br><span class="line">&#123;</span><br><span class="line">  &quot;code&quot; : 200,</span><br><span class="line">  &quot;message&quot; : &quot;OK&quot;,</span><br><span class="line">  &quot;data&quot; : &#123;</span><br><span class="line">    &quot;id&quot; : 1,</span><br><span class="line">    &quot;name&quot; : &quot;배달이&quot;,</span><br><span class="line">    &quot;age&quot; : 10,</span><br><span class="line">    &quot;address&quot; : &quot;서울특별시 송파구 올림픽로 295&quot;,</span><br><span class="line">    &quot;roles&quot; : [ ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;error&quot; : null</span><br><span class="line">&#125;</span><br><span class="line">----</span><br></pre></td></tr></table></figure></p></li></ul><p>Optional하게 생성되는 snippet도 존재합니다.</p><ul><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/path-parameters.adoc.adoc</code> : Path Parameters에 대한 정보를 표로 나타냅니다.</li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/request-headers.adoc.adoc</code> : request header에 대한 정보를 표로 나타냅니다.</li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/request-fieldadoc</code> : request fields에 대한 정보를 표로 나타냅니다.</li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/response-fields.adoc</code> : response fields에 대한 정보를 표로 나타냅니다.</li></ul><h3 id="api-document-생성하기">API Document 생성하기</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ifndef::snippets[]</span><br><span class="line">:snippets: ../../../build/generated-snippets</span><br><span class="line">endif::[]</span><br><span class="line">:doctype: book</span><br><span class="line">:icons: font</span><br><span class="line">:source-highlighter: highlightjs</span><br><span class="line">:toc: left</span><br><span class="line">:toclevels: 4</span><br><span class="line">:sectlinks:</span><br><span class="line">:site-url: /build/asciidoc/html5/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">== Request</span><br><span class="line"></span><br><span class="line">=== [Request URL]</span><br><span class="line">....</span><br><span class="line">GET /user/&#123;userId&#125;</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">=== [Request Headers]</span><br><span class="line">include::&#123;snippets&#125;/user-search/request-headers.adoc[]</span><br><span class="line"></span><br><span class="line">=== [Request Path Parameters]</span><br><span class="line"></span><br><span class="line">include::&#123;snippets&#125;/user-search/path-parameters.adoc[]</span><br><span class="line"></span><br><span class="line">=== [Request HTTP Example]</span><br><span class="line"></span><br><span class="line">include::&#123;snippets&#125;/user-search/http-request.adoc[]</span><br><span class="line"></span><br><span class="line">== Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=== [Response Fields]</span><br><span class="line"></span><br><span class="line">include::&#123;snippets&#125;/user-search/response-fields.adoc[]</span><br><span class="line"></span><br><span class="line">=== [Response HTTP Example]</span><br><span class="line"></span><br><span class="line">include::&#123;snippets&#125;/user-search/http-response.adoc[]</span><br></pre></td></tr></table></figure></p><ul><li>/src/docs/asciidoc 디렉토리를 생성하고 user-search.adoc 파일을 생성합니다.</li><li>이 파일은 html로 변환될 adoc 파일입니다.</li><li>snippet에 대한 path를 지정하고 <code>include::</code> 를 통해 adoc 파일을 include하여 processing 할 수 있습니다.</li><li>include 된 파일은 include한 부분에 html 태그로 직접 삽입됩니다.</li><li>processing 된 html 파일은 <code>/build/docs/html5</code> 디렉토리에 생성됩니다 (default)</li><li>부가적으로 API 문서에 대한 내용을 작성하여 API 문서를 만들 수 있습니다. (ex: API 설명, 담당자, 주의사항)</li></ul><h1 id="html-문서-serving-해보기">HTML 문서 Serving 해보기</h1><p>Spring Rest Docs로 만들어진 API 문서의 최종 형태는 HTML 파일로 제공됩니다.<br>그렇기 때문에 Spring Static Resource Handler를 이용하여 간단하게 html 파일을 Serving하여 웹 브라우져를 통해 사용자에게 API문서를 제공 할 수 있습니다.</p><p>SpringBoot의 WebMvcConfigure를 상속하여 Configuration을 추가합니다.</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.restdocs.configuration</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Configuration</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.<span class="keyword">annotation</span>.ResourceHandlerRegistry</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.<span class="keyword">annotation</span>.WebMvcConfigurer</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span>: <span class="type">WebMvcConfigurer &#123;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addResourceHandlers</span><span class="params">(registry: <span class="type">ResourceHandlerRegistry</span>)</span></span> &#123;</span><br><span class="line">    registry.addResourceHandler(<span class="string">"/docs/**"</span>).addResourceLocations(<span class="string">"classpath:/static/docs/"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 설정을 추가하게 되면<br><code>localhost:8080/docs/index.html</code>  과 같이 <code>/docs/**</code> 패턴으로 유입되는 url에 대해<br>classpath 하위의 /static/docs/ 디렉토리 아래의 파일을 찾아 반환하도록 해줍니다.</p><p><img src="./static-resource-path.png" alt=""></p><h1 id="여러가지-function-사용해보기">여러가지 Function 사용해보기</h1><h2 id="pathparameters">PathParameters</h2><ul><li>API의 Path Parameter에 대한 Snippet을 생성합니다.</li><li>/build/generated-snippets/&lt;document-name&gt;/path-parameters.adoc 인 파일명으로 생성됩니다.</li><li>pathParameter(parameterWithName(&quot;key 명칭&quot;).description(&quot;key가 의미 하는 내용&quot;)) 으로 코드를 작성합니다.</li></ul><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-update"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(parameterWithName(<span class="string">"userId"</span>).description(<span class="string">"유저 ID"</span>)),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .andWithPrefix(<span class="string">"data."</span>, *user())</span><br><span class="line">                                    .andWithPrefix(<span class="string">"data.roles[]."</span>, *role())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><h2 id="requestheader">requestHeader</h2><ul><li>API의 Request Header에 대한 Snippet을 생성합니다.</li><li>/build/generated-snippets/&lt;document-name&gt;/request-headers.adoc 인 파일명으로 생성됩니다.</li><li>requestHeader(headerWithName(&quot;header-key명&quot;).description(&quot;header-key가 의미하는 내용&quot;))</li></ul><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">          .andExpect(status().isOk)</span><br><span class="line">          .andDo(</span><br><span class="line">                  document(</span><br><span class="line">                          <span class="string">"user-grant-role"</span>,</span><br><span class="line">                          getDocumentRequest(),</span><br><span class="line">                          getDocumentResponse(),</span><br><span class="line">                          requestHeaders(headerWithName(<span class="string">"api-auth-key"</span>).description(<span class="string">"API 인증 키"</span>)),</span><br><span class="line">                      pathParameters(userIdPathParameter(), roleIdPathParameter()),</span><br><span class="line">                          responseFields(*common())</span><br><span class="line">                                  .andWithPrefix(<span class="string">"data."</span>, *user())</span><br><span class="line">                                  .andWithPrefix(<span class="string">"data.roles[]."</span>, *role())</span><br><span class="line">                  )</span><br><span class="line">          )</span><br></pre></td></tr></table></figure></p><h2 id="fieldwithpath">fieldWithPath</h2><ul><li>API의 Request, Response Snippet을 구성하는 요소를 정의하는 가장 기본적인 function입니다.</li><li>fieldWithPath(&quot;key&quot;) 형태로 API Request, Response 내의 요소를 정의 할 수 있습니다.</li><li>Attributes<ul><li>description(&quot;내용&quot;) : Request, Response 내의 요소의 내용을 정의합니다.</li><li>type(JsonFieldType.TYPE) : Request, Response 내의 요소의 타입을 정의합니다.</li><li>optional() : Request, Response 내의 요소의 필수값 여부를 정의합니다. (optional()를 선언하면 필수값 아님)</li></ul></li></ul><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-grant-role"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter(), roleIdPathParameter()),</span><br><span class="line">                            responseFields(</span><br><span class="line">                            fieldWithPath(<span class="string">"code"</span>).type(JsonFieldType.NUMBER).description(<span class="string">"응답 코드"</span>),</span><br><span class="line">                fieldWithPath(<span class="string">"message"</span>).type(JsonFieldType.STRING).description(<span class="string">"응답 메세지"</span>),</span><br><span class="line">                subsectionWithPath(<span class="string">"error"</span>).type(JsonFieldType.OBJECT).description(<span class="string">"에러 Data"</span>).optional(),</span><br><span class="line">                subsectionWithPath(<span class="string">"data"</span>).type(JsonFieldType.OBJECT).description(<span class="string">"응답 Data"</span>).optional()</span><br><span class="line">      )</span><br><span class="line">                      .andWithPrefix(<span class="string">"data."</span>, *user())</span><br><span class="line">                      .andWithPrefix(<span class="string">"data.roles[]."</span>, *role())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><h2 id="subsectionwithpath">subSectionWithPath</h2><ul><li>API Request, Response Snippet을 구성하는 요소를 정의하는 function입니다.</li><li>요소의 하위를 선언하고 싶지 않거나, 가변적인 Request, Response가 오는 경우 사용하기 좋습니다.</li><li>subSectionWithPath는 root key가 존재하는 지만 체크하고 하위 key에 대한 체크는 하지 않습니다.</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"Parameter validation error"</span>,</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">4000</span>,</span><br><span class="line">  <span class="attr">"errors"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"field"</span>: <span class="string">"receivers[0].phone"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"010469090"</span>,</span><br><span class="line">      <span class="attr">"errorMessage"</span>: <span class="string">"유효하지 않은 수신자 번호입니다."</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같은 응답이 오는 경우</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-grant-role"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter(), roleIdPathParameter()),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .and(fieldWithPath(<span class="string">"errors"</span>).type(JsonFieldType.ARRAY).description(<span class="string">"에러 Data"</span>)) <span class="comment">//에러 발생!!</span></span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><p>아래와 같은 에러가 발생하게 됩니다.<br>에러 내용을 요약하자면, payload에 있는 정보를 문서화 하지 않았다는 에러입니다.<br>즉, errors 하위에 field, value, errorMessage 정보를 문서화 하지 않았기 때문에 발생하는 에러입니다.</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.restdocs.snippet.SnippetException: The following parts of the payload were not documented:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errors"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"field"</span>: <span class="string">"receivers[0].phone"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"010469090"</span>,</span><br><span class="line">      <span class="attr">"errorMessage"</span>: <span class="string">"유효하지 않은 수신자 번호입니다."</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하지만 subSectionWithPath를 사용하게 되면 errors 하위에 대한 정보는 문서화 하지 않겠다!를 의미하므로<br>에러가 발생하지 않고, errors 까지만 문서화 됩니다.</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-grant-role"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter(), roleIdPathParameter()),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .and(subSectionWithPath(<span class="string">"errors"</span>).type(JsonFieldType.ARRAY).description(<span class="string">"에러 Data"</span>)) </span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><h2 id="responsefieldand">responseField().and()</h2><ul><li>response에 대한 Field정보가 많은 경우 가독성을 해칠 수 있고, Field Snippet에 대한 재사용성이 떨어질 수 있습니다.</li><li>이럴때 and를 사용하면 좋습니다.</li><li>requestField(), responseField() 함수 뒤에 and() 함수를 사용하여 FieldDescriptor에 대한 Concatenation이 가능합니다.</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"OK"</span>,</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"배달이"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"address"</span>: <span class="string">"서울특별시 송파구 올림픽로 295"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 모든 요소가 1레벨인 Json이 Response로 오는 경우<br>code, message 는 모든 API Response에 대한 공통 요소 입니다.<br>id, name, age, address는 User API Response에만 응답오는 요소라고 할 떄,<br>두 요소에 대한 관리를 별도로 하여 재사용성을 높일 수 있습니다.</p><p>아래와 같이 and를 사용하여 Response에 대한 FieldDesciptor를 concatenation 하여 구성할 수 있습니다.</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-update"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter()),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .and(*user())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><h2 id="responsefieldandwithprefix">responseField().andWithPrefix()</h2><ul><li>and()의 사용예제와 동일합니다.</li><li>하지만, andWithPrefix는 key 앞에 prefix를 붙여 depth를 표현할 수 있도록 해줍니다.</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"OK"</span>,</span><br><span class="line">  <span class="attr">"data"</span> : &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"배달이"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"address"</span>: <span class="string">"서울특별시 송파구 올림픽로 295"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 data에 대한 키가 2레벨인 Json이 Response로 오는 경우<br>아래와 같이 and를 사용하여 Response에 대한 FieldDesciptor를 concatination 하여 구성할 수 있습니다.</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-update"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter()),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .andWithPrefix(<span class="string">"data."</span>, *user())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><h2 id="beneathpath">beneathPath</h2><ul><li>API를 사용하다 보면 특정 Field의 명세만 별도로 추출하여 문서화 하는 needs가 있을 수 있습니다.</li><li>beneathPath(&quot;data-path&quot;) function을 사용하면 특정 data-path에 대한 field를 별도의 snippet으로 생성해 줍니다.</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"OK"</span>,</span><br><span class="line">  <span class="attr">"data"</span> : &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"배달이"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"address"</span>: <span class="string">"서울특별시 송파구 올림픽로 295"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-search"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter()),</span><br><span class="line">                            responseFields(</span><br><span class="line">                                    beneathPath(<span class="string">"data"</span>).withSubsectionId(<span class="string">"user"</span>),</span><br><span class="line">                                    *user(),</span><br><span class="line">                                    subsectionWithPath(<span class="string">"roles"</span>).description(<span class="string">"User Role"</span>)</span><br><span class="line">                    )</span><br></pre></td></tr></table></figure></p><ul><li>data 필드 하위의 내용을 문서화 해줍니다.</li><li>beneathPath(&quot;data&quot;) : data 필드 하위의 내용이라는 Path 지정</li><li>.withSubsectionId(&quot;user&quot;) : response-fields-user.adoc이라고 SubSectionId로 response-fields.adoc 파일이 별도로 만들어 집니다.</li></ul><h1 id="spring-rest-docs-추가-기능">Spring Rest Docs 추가 기능</h1><h2 id="custom-필드-삽입하기">Custom 필드 삽입하기</h2><ul><li>Spring Rest Docs에서 기본적으로 제공하는 path, description, optional, type 이외에 다른 메타정보를 추가하고 싶을 때 Custom 필드를 만들어 사용할 수 있습니다.</li><li>AbstractDescriptor에서 제공하는 attributes라는 Map을 이용합니다.</li><li>저는 비고, 최대길이라는 필드를 표현하기 위해 Kotlin Extension Function을 이용하여 기능을 추가해보았습니다.</li><li>기본적으로 AbstractDescriptor의 attributes라는 Map에 key, value라는 내용을 넣어주면 됩니다.<br>(Java에서는 이 방식을 사용하세요)</li></ul><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : AbstractDescriptor&lt;T&gt;</span>&gt; AbstractDescriptor<span class="type">&lt;T&gt;</span>.<span class="title">remarks</span><span class="params">(remarks: <span class="type">String</span>)</span></span>: T &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.attributes(key(<span class="string">"remarks"</span>).value(remarks))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : AbstractDescriptor&lt;T&gt;</span>&gt; AbstractDescriptor<span class="type">&lt;T&gt;</span>.<span class="title">maxLength</span><span class="params">(length: <span class="type">Int</span>)</span></span>: T &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.attributes(key(<span class="string">"maxLength"</span>).value(length))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"user-update"</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter()</span><br><span class="line">                              .maxLength(<span class="number">10</span>)</span><br><span class="line">                              .remarks(<span class="string">"User ID가 없는 경우는 먼저 생성하세요"</span>)),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .andWithPrefix(<span class="string">"data."</span>, *user())</span><br><span class="line">                                    .andWithPrefix(<span class="string">"data.roles[]."</span>, *role())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure></p><p>위의 예제에서는 일단 ParameterDescriptor에 maxLength와 remark 속성을 추가 했습니다.<br>ParameterDescriptor 뿐만 아니라, AbstractDescriptor를 구현하는 모든 Descriptor에 적용이 가능합니다.<br>(FieldDescriptor, SubsectionDescriptor, HeaderDescriptor등...)</p><p>이렇게 추가한 속성을 snippet에 출력해보도록 하겠습니다.<br>위의 예시는 path parameter에 추가한 속성이므로, path-parameters snippet을 override하여 출력해 줄 수 있습니다.</p><h3 id="path-parameters-snippet-override">path-parameters snippet override</h3><ul><li>/test/org/springframework/restdocs/templates 하위에 path-parameters.snippet 파일을 새로 등록합니다.</li><li>snippet 파일은 mustache 문법을 사용합니다.</li><li>여기에 제가 추가한 최대길이, 비고 컬럼을 추가하였습니다.</li><li>mustache 문법 중 <code>#maxLength</code> 문법은 maxLength 속성이 존재하는가? 라는 if문과 비슷한 문법입니다.</li><li>반대되는 문법으로 <code>^maxLength</code> 문법은 maxLength 속성이 존재하지 않는가? 라는 문법입니다.</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.+&#123;&#123;path&#125;&#125;+</span><br><span class="line">|===</span><br><span class="line">|Parameter|Description|최대길이|비고</span><br><span class="line">&#123;&#123;#parameters&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;`+&#123;&#123;name&#125;&#125;+`&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;&#123;&#123;description&#125;&#125;&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;&#123;&#123;#maxLength&#125;&#125;&#123;&#123;maxLength&#125;&#125;&#123;&#123;/maxLength&#125;&#125;&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;&#123;&#123;#remarks&#125;&#125;&#123;&#123;remarks&#125;&#125;&#123;&#123;/remarks&#125;&#125;&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">&#123;&#123;/parameters&#125;&#125;</span><br><span class="line">|===</span><br></pre></td></tr></table></figure></p><h3 id="결과">결과</h3><p><img src="./add-path-parameter-custom-fields.png" alt="add-path-parameter-custom-fields"></p><h2 id="custom-snippet-생성하기">Custom Snippet 생성하기</h2><p>API 문서를 작성하다 보면, 특정 API와 관계없는 응답코드나, Status 값에 대한 명세를 정의하고 문서화 해야 할 요구사항이 있을 수 있습니다.<br>그런 경우 Custom Snippet을 생성하여 문서화하면, 별도로 응답코드나 Status가 추가되거나 변경되어도 항상 문서를 최신화 할 수 있습니다.</p><p>생성해야 할 것은 4가지 입니다.</p><ol><li>Test 용 Controller</li><li>Custom Snippet Template 파일</li><li>ResponseCodeSnippet 클래스 (AbstractFieldsSnippet 상속)</li><li>Test Code</li></ol><h3 id="test용-controller">Test용 Controller</h3><p>MockMvc 기반에서 생성되는 문서이다 보니 사용하지 않더라도, Test용 Controller가 하나 필요합니다.<br>실제 코드에 영향이 없도록 <code>/test</code> 디렉토리 하위에 Controller를 만들었습니다.</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponseCodeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/response-code"</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getResponseCode</span><span class="params">()</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Response.success()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="custom-snippet-template-파일">Custom Snippet Template 파일</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;title&#125;&#125;</span><br><span class="line">|===</span><br><span class="line">|Code|Message</span><br><span class="line">&#123;&#123;#fields&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;`+&#123;&#123;path&#125;&#125;+`&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;&#123;&#123;description&#125;&#125;&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">&#123;&#123;/fields&#125;&#125;</span><br><span class="line">|===</span><br></pre></td></tr></table></figure></p><ul><li>title을 변수로 받아서 출력할 예정입니다.</li><li>표에 출력할 필드는 code값과 description입니다.</li></ul><h3 id="responsecodesnippet-클래스">ResponseCodeSnippet 클래스</h3><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponseCodeSnippet</span></span>(</span><br><span class="line">        name: String, </span><br><span class="line">        descriptors: MutableList&lt;FieldDescriptor&gt;,</span><br><span class="line">        attributes: Map&lt;String, Any&gt;,</span><br><span class="line">        ignoreUndocumentedFields: <span class="built_in">Boolean</span></span><br><span class="line">) : AbstractFieldsSnippet(name, descriptors, attributes, ignoreUndocumentedFields) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getContentType</span><span class="params">(operation: <span class="type">Operation</span>)</span></span>: MediaType? &#123;</span><br><span class="line">    <span class="keyword">return</span> operation.response.headers.contentType</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getContent</span><span class="params">(operation: <span class="type">Operation</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">return</span> operation.response.content</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>name: 생성할 snippet 템플릿의 prefix입니다. (실제 파일은 {name}-fields.snippet 파일로 생성됩니다.)</li></ul><p><img src="./AbstractFieldSnippet-Constructor.png" alt="AbstractFieldSnippet-Constructor"></p><ul><li>descriptors : snippet에 출력될 field 정보들입니다. (예제에서는 ResponseCode 하나하나가 Row가 됩니다.)</li><li>attributes: snippet에 출력할 추가적인 속성입니다.</li></ul><h3 id="test-code">Test Code</h3><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(RestDocumentationExtension::class, SpringExtension::class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(ResponseCodeController::class, secure = false)</span></span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponseCodeDocs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> mockMvc: MockMvc</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> `build response code snippet`<span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    mockMvc.perform(<span class="keyword">get</span>(<span class="string">"/response-code"</span>)</span><br><span class="line">            .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">    ).andDo(MockMvcResultHandlers.print())</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">"common"</span>,</span><br><span class="line">                            responseCodeFields(</span><br><span class="line">                                    <span class="string">"response-code"</span>, <span class="comment">//&#123;name&#125;-fields.snippet 이라는 파일명으로 생성</span></span><br><span class="line">                                    Attributes.attributes(Attributes.key(<span class="string">"title"</span>).value(<span class="string">"공통 응답 코드"</span>)),</span><br><span class="line">                                    *convertResponseCodeToFieldDescriptor(ResponseCode.values())</span><br><span class="line">                            )</span><br><span class="line">                    )</span><br><span class="line">            )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">responseCodeFields</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">          attributes: <span class="type">Map</span>&lt;<span class="type">String</span>, Any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">vararg</span> descriptors: <span class="type">FieldDescriptor</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>: ResponseCodeSnippet &#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseCodeSnippet(name, mutableListOf(*descriptors), attributes, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">convertResponseCodeToFieldDescriptor</span><span class="params">(enumTypes: <span class="type">Array</span>&lt;<span class="type">ResponseCode</span>&gt;)</span></span>: Array&lt;FieldDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(enumTypes)</span><br><span class="line">            .map &#123;</span><br><span class="line">              fieldWithPath(it.code.toString()).type(JsonFieldType.NUMBER).description(it.message).optional()</span><br><span class="line">            &#125;</span><br><span class="line">            .collect(Collectors.toList())</span><br><span class="line">            .toTypedArray()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="결과">결과</h3><p><img src="./custom-snippet.png" alt="custom-snippet"></p><h3 id="추가">추가</h3><p>위의 예시에서는 Custom Field Snippet으로 예시를 들었지만</p><ul><li>AbstractParametersSnippet</li><li>AbstractBodySnippet</li><li>AbstractHeadersSnippet</li></ul><p>위의 AbstractSnippet이 더 있는 걸로 보아 다른 Custom Snippet도 생성할 수 있는 것 같습니다.<br>필요할 때마다 한번씩 써보면 좋겠죠?</p><h1 id="reference">Reference</h1><ul><li>https://docs.spring.io/spring-restdocs/docs/current/reference/html5/#introduction</li><li>https://asciidoctor.org/docs/asciidoctor-gradle-plugin/</li><li>https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/</li><li>http://woowabros.github.io/experience/2018/12/28/spring-rest-docs.html</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/08/04/2019-08-04-spring-rest-docs/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Event-Driven-Architecture란?</title>
      <link>https://jaehun2841.github.io/2019/06/23/2019-06-23-event-driven-architecture/</link>
      <guid>https://jaehun2841.github.io/2019/06/23/2019-06-23-event-driven-architecture/</guid>
      <pubDate>Sun, 23 Jun 2019 08:54:28 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;event-driven-란&quot;&gt;Event Driven 란?&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;./EDA.png&quot; alt=&quot;EDA&quot;&gt;&lt;/p&gt;
&lt;p&gt;Event Driven은 IT 영역에서 오래 사용된 키워드이며, 현재도 그 영향력이 대단하여 2
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="event-driven-란">Event Driven 란?</h1><p><img src="./EDA.png" alt="EDA"></p><p>Event Driven은 IT 영역에서 오래 사용된 키워드이며, 현재도 그 영향력이 대단하여 2018년 Gartner에서 선정한 유망한 기술 트렌드 중 하나로 뽑히기도 했다.<br>(Top 10 Strategic Technology Trends for 2018: Event-Driven Model)</p><p>Event Driven이라는 용어는 programming, architecture와 연결되어 다양한 정의로 표현된다.</p><blockquote><p><strong>EDA (Event-driven architecture)</strong><br>분산된 시스템 간에 이벤트를 생성, 발행 (publishing)하고 발행된 이벤트를 필요로하는 수신자에게 전송된다.<br>이벤트를 수신한 수신자가 이벤트를 처리하는 형태의 시스템 아키텍쳐</p></blockquote><ul><li>Event Driven Pattern - 특정 행동이 자동으로/순서에 따라 발생하는 것이 아닌 어떤 일에 대한 반응으로 동작하는 디자인 패턴</li><li>IO Event - 컴퓨터 회로를 구동시키기 위해 발생하는 일  ( ex)  마우스 클릭, 키보드 타이핑, 모바일 터치 등)</li><li>IOT 기기 등의 센서로부터 유입되는 데이터 스트리밍 기반의 동작</li><li>시스템의 내,외부에서 발생한 <strong>주목할 만한 상태의 변화(a significant change in state)</strong></li></ul><p>주로 Event Driven 시스템은 Message Broker(Kafka, Rabbit MQ, Redis)와 결합하여, Message Driven 시스템으로 구성된다.</p><h2 id="eda-event-driven-architecture의-구성요소">EDA (Event-driven architecture)의 구성요소</h2><p>EDA는 크게 3개의 구성요소로 나누어 볼 수 있다.</p><ul><li>Event generator : 시스템 내,외부의 상태 변화를 감지하여 표준화된 형식의 이벤트를 생성</li><li>Event channel : 이벤트를 필요로 하는 시스템까지 발송</li><li>Event processing engine : 수신한 이벤트를 식별, 적절한 처리를 함. 때에 따라 이벤트 처리의 결과로 또 다른 이벤트를 발생시킬 수 있다.</li></ul><h2 id="event-processing-style">Event Processing Style</h2><p>수신한 이벤트를 처리하는 방법에는 세가지 종류가 있다.</p><h3 id="simple-event-processing">Simple event processing</h3><p>각각의 이벤트가 직접적으로 수행해야할 action과 매핑되어 처리 된다.<br>실시간으로 작업의 흐름을 처리할 때 사용되며, 이벤트 처리 시간과 비용의 손실이 적다.</p><h3 id="event-stream-processing">Event Stream Processing</h3><p>이벤트를 중요도에 따라  필터링하여 걸러진 이벤트만을 수신자에게 전송.<br>실시간으로 정보의 흐름을 처리할 때 사용되며, 기업에 적용될 경우 신속한 의사 결정을 가능케한다.(BAM)</p><h3 id="complex-event-processing">Complex event processing</h3><p>일상적인 이벤트의 패턴을 감지하여 더 복잡한 이벤트의 발생을 추론하는 것.<br>예를 들어 '주식의 등락'이라는 일상적인 이벤트의 패턴을 감지하여 '투자 적기'라는 상위의 이벤트를 추론해 낼 수 있다.</p><h2 id="event-driven-architecture의-장단점">Event Driven Architecture의 장단점</h2><h3 id="장점">장점</h3><ul><li>Decoupling - 시스템 간의 느슨한 결합이 가능 하므로 분산 시스템, Microservice 환경에서 시스템 간 의존성을 배제 할 수 있다<br>(시스템은 Event Channel인 Message Broker에 대한 의존성만 가진다.)</li><li>다른 시스템의 정보를 알 필요가 없다 - 약속된 Event message를 가지고 상호 정보를 교환한다.</li><li>micro service 단위로 시스템을 분리하기 쉽기 때문에 확장성, 탄력성을 고려하기 쉽다.</li></ul><h3 id="단점">단점</h3><ul><li>Broker Dependency - Event를 전송하기 위한 Message Broker에 대한 의존성이 커지기 때문에<br>Message Broker 장애 상황 시, 전체 장애로 이어질 수 있다.</li><li>Transaction 단위가 격리되기 때문에 서비스 장애 발생시 retry/rollback을 고려해야 한다.</li><li>시스템 전체 Flow를 파악하기 어렵다. - 명확한 Flow를 보기 위해서는 시스템을 모니터링하여야 한다.</li><li>디버깅이 어렵다.</li></ul><h1 id="microservice에서의-event">Microservice에서의 Event</h1><p><img src="./EDM.png" alt="EDM"></p><blockquote><p><strong>EDM(Event Driven Microservice)</strong>MSA가 적용된 시스템에서 이벤트 발생시 해당 이벤트 로그를 보관하고 이를 기반으로 동작하며,<br>비동기 통신을 통해 시스템 내 통합(integration)을 수행하는 Architecture</p></blockquote><h2 id="event">Event</h2><p>IT 영역에서의 이벤트는 다양한 정의를 포함하지만, MSA에서 의미하는 이벤트는<br>시스템의 내,외부에서 발생한 <strong>주목할 만한 상태의 변화(a significant change in state)</strong><br>데이터의 생성, 변경, 삭제를 통해 발생하는 서비스의 의미 있는 변화를 의미</p><h2 id="이벤트-로그를-보관">이벤트 로그를 보관</h2><ul><li>github를 예시들어 이해하면 이해가 편할 것 같습니다.</li></ul><h3 id="현재의-데이터는-상태-변경의-누적이다">현재의 데이터는 상태 변경의 누적이다.</h3><ul><li>github의 commit 한 스냅샷의 연속으로 현재의 소스가 변경</li></ul><h3 id="상태-변경은-이벤트를-의미하고-이를-누적하는-행위는-이벤트-로그를-보관하는-것">상태 변경은 이벤트를 의미하고 이를 누적하는 행위는 이벤트 로그를 보관하는 것</h3><ul><li>github에 commit = Eventcommit 로그는 이벤트를 보관하는 행위</li></ul><h3 id="보관된-이벤트는-데이터의-현재-상태를-구성하는-근간">보관된 이벤트는 데이터의 현재 상태를 구성하는 근간</h3><ul><li>github는 commit이라는 이벤트를 보관하는 store의 역할을 해주며commit의 누적으로 인해 현재의 소스를 구성할 수 있다.</li></ul><h3 id="보관된-이벤트를-바탕으로-장애-발생-또는-특정-요구사항에-따라-지정된-시점으로-복원을-수행">보관된 이벤트를 바탕으로 장애 발생 또는 특정 요구사항에 따라 지정된 시점으로 복원을 수행</h3><ul><li>github는 특정시점으로 롤백 및 revert가 가능</li></ul><h2 id="비동기-통신">비동기 통신</h2><p>amqp, mqtt, jms 등 메세징 프로토콜을 통한 메세지 큐 방식이 자주 사용됩니다.<br>서비스에서 데이터의 생성,변경,삭제(CUD)를 통해 이벤트가 발생하면 발행 서비스는 <strong>메세지의 형태로 이벤트를 발행</strong>하고, 해당 이벤트에 관심이 있는 서비스에서 구독을 수행합니다.<br>메세지 큐를 사용함으로 requeue/dlq(dead letter queue) 등의 기능을 활용할 수 있습니다.</p><h2 id="시스템-내-통합integration">시스템 내 통합(integration)</h2><p>이상적으로 구현된 MSA는 서비스 간 데이터 참조를 위한 내부 통신이 필요없지만, 현실적으로 서비스 간 내부 통신이 전혀 없는 시스템을 구현하기란 불가능에 가깝습니다. 다양한 사유로 여러 서비스 간 통신을 통해 연동이 발생합니다.</p><h2 id="트랜잭션-관리">트랜잭션 관리</h2><p>microservice 단위로 분리된 환경이기 때문에 각자 데이터베이스를 적용한 시스템에 대해 데이터 무결성을 보장할 수는 없지만<br>Event를 통해 최종적인 일관성을 유지 할 수는 있습니다.<br><strong>all commit or rollback → eventually consistency</strong> (언젠가는 맞는다.)</p><h1 id="참고">참고</h1><ul><li>https://bigstory.tistory.com/entry/Event-Driven-Architecture</li><li>https://en.wikipedia.org/wiki/Event-driven_architecture</li><li>https://medium.com/dtevangelist/event-driven-microservice-%EB%9E%80-54b4eaf7cc4a</li><li>https://www.confluent.io/blog/event-streaming-platform-1</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/06/23/2019-06-23-event-driven-architecture/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 88. readObject 메서드는 방어적으로 작성하라</title>
      <link>https://jaehun2841.github.io/2019/03/17/effective-java-item88/</link>
      <guid>https://jaehun2841.github.io/2019/03/17/effective-java-item88/</guid>
      <pubDate>Sun, 17 Mar 2019 08:11:59 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Item 50에서는 불변인 날짜 범위 클래스를 만드는데 가변인 Date 필드를 이용했다.&lt;br&gt;
그래서 불변식을 지키고 불변을 유지하기 위해 생성자와 접근자에서 Date객체를 방어적으로 복사하느라 코드가 상당히
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Item 50에서는 불변인 날짜 범위 클래스를 만드는데 가변인 Date 필드를 이용했다.<br>그래서 불변식을 지키고 불변을 유지하기 위해 생성자와 접근자에서 Date객체를 방어적으로 복사하느라 코드가 상당히 길어졌다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Period</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 시작 시각</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 종료 시각; 시작 시각보다 뒤여야 한다.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException start나 end가 null이면 발행한다.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.start.compareTo(<span class="keyword">this</span>.end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(start + <span class="string">"가 "</span> + end + <span class="string">"보다 늦다."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Date(start.getTime()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Date(end.getTime()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start + <span class="string">"-"</span> + end; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 클래스는 물리적 표현과 논리적 표현이 부합하므로 기본 직렬화를 사용해도 좋다.<br>하지만 이렇게 해서는 주요한 Date의 불변식을 보장하지 못한다.</p><h1 id="필요하다면-매개변수를-방어적으로-복사하라">필요하다면 매개변수를 방어적으로 복사하라</h1><ul><li>readObject 메서드는 실질적으로는 또 다른 public 생성자이기 때문에 생성자와 똑같은 수준으로 주의를 기울여야한다.</li><li>readObject 메서드에서 <strong>인수가 유효한지 검사해야하고 필요하다면 방어적으로 복사하라</strong></li><li>readObject에서 이 작업을 제대로 하지 못하면 공격자는 쉽게 클래스의 불변식을 깨뜨릴 수 있다.</li></ul><h2 id="불변식을-깨뜨릴-용도로-스트림을-조작하면-문제가-생긴다">불변식을 깨뜨릴 용도로 스트림을 조작하면 문제가 생긴다</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BogusPeriod</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] serializedForm = &#123;</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xac</span>, (<span class="keyword">byte</span>)<span class="number">0xed</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x73</span>, <span class="number">0x72</span>, <span class="number">0x00</span>, <span class="number">0x06</span>....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Period p = (Period) deserialize(serializedForm);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] sf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(sf)).readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 코드의 serializedForm에서 상위 비트가 1인 바이트 값들은 byte로 형변환했는데,<br>이는 자바가 바이트 리터럴을 지원하지 않고 byte 타입은 부호가 있는 (signed) 타입이기 때문이다.</li><li>위의 프로그램을 실행하면<br><code>Fri Jan 01 12:00:00 PST 1999 - Sun Jan 01 12:00:00 PST 1984</code>를 출력한다.</li><li>Period를 직렬화할 수 있도록 선언한 것 만으로도 불변식을 깨뜨리는 객체를 만들 수 있다.</li></ul><h1 id="역직렬화-시-불변식을-만족하는-유효성-검사를-해야한다">역직렬화 시, 불변식을 만족하는 유효성 검사를 해야한다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 불변식을 만족하는지 검사한다.</span></span><br><span class="line">    <span class="keyword">if</span>(start.compareTo(end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(start + <span class="string">"가 "</span> + end + <span class="string">"보다 늦다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위의 if문 추가로 허용되지 않는 Period 인스턴스가 생성되는 일을 막을 수 있지만, 아직도 미묘한 문제가 숨어있다.</li><li>정상 Period 인스턴스에서 시작된 바이트 스트림 끝에 private Date 필드로의 참조를 추가하면 가변 Period 인스턴스를 만들 수 있다.</li></ul><h1 id="가변-공격을-막기위해서는-방어적-복사본을-만들어야-한다">가변 공격을 막기위해서는 방어적 복사본을 만들어야 한다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePeriod</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Period 인스턴스</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Period period;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//시작 시각 필드 - 외부에서 접근할 수 없어야 한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Date start;</span><br><span class="line">    <span class="comment">//종료 시각 필드 - 외부에서 접근할 수 없어야 한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Date end;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePeriod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectArrayOutputStream out = <span class="keyword">new</span> ObjectArrayOutputStream(bos);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//유효한 Period 인스턴스를 직렬화한다.</span></span><br><span class="line">            out.writeObject(<span class="keyword">new</span> Period(<span class="keyword">new</span> Date(), <span class="keyword">new</span> Date()));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 악의적인 '이전 객체 참조', 즉 내부 Date 필드로의 참조를 추가한다.</span></span><br><span class="line"><span class="comment">             * 상세 내용은 자바 객체 직렬화 명세의 6.4절을 참고</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">byte</span>[] ref = &#123;<span class="number">0x71</span>, <span class="number">0</span>, <span class="number">0x7e</span>, <span class="number">0</span>, <span class="number">5</span>&#125;; <span class="comment">// 참조 #5</span></span><br><span class="line">            bos.write(ref); <span class="comment">// 시작 start 필드 참조 추가</span></span><br><span class="line">            ref[<span class="number">4</span>] = <span class="number">4</span>; <span class="comment">//참조 #4</span></span><br><span class="line">            bos.write(ref); <span class="comment">// 종료(end) 필드 참조 추가</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Period 역직렬화 후 Date 참조를 훔친다.</span></span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray()));</span><br><span class="line">            period = (Period) in.readObject();</span><br><span class="line">            start = (Date) in.readObject();</span><br><span class="line">            end = (Date) in.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>다음 공격 코드를 실행하면 이 공격이 실제로 이뤄지는 모습을 확인할 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MutablePeriod mp = <span class="keyword">new</span> MutablePeriod();</span><br><span class="line">    Period p = mp.period;</span><br><span class="line">    Date pEnd = mp.end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//시간 되돌리기</span></span><br><span class="line">    pEnd.setYear(<span class="number">78</span>);</span><br><span class="line">    System.out.println(p); <span class="comment">// Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1978</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//60년대로 회귀</span></span><br><span class="line">    pEnd.setYear(<span class="number">60</span>);</span><br><span class="line">    System.out.println(p); <span class="comment">// Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1969</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 예시에서 Period 인스턴스는 불변식을 유지한 채 생성됐지만 의도적으로 내부의 값을 수정할 수 있었다.<br>이처럼 변경할 수 있는 Period 인스턴스를 획득한 공격자는 인스턴스가 불변이라고 가정하는 클래스에 넘겨 엄청난 보안 문제를 일으킬 수 있다.</p><p>이 문제의 근원은 <strong>Period의 readObject메서드가 방어적 복사를 충분히 하지 않은 데 있다.</strong><br>객체를 직렬화할 때는 클라이언트가 소유해서는 안 되는 객체 참조를 갖는 필드를 모두 방어적으로 복사해야 한다.<br>따라서 <code>readObject에서는 불변 클래스 안의 모든 private 가변 요소를 방어적으로 복사 해야한다.</code></p><h1 id="readobject-메서드에서는-private-가변요소를-방어-복사하라">readObject 메서드에서는 private 가변요소를 방어 복사하라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 가변 요소들을 방어적으로 복사한다.</span></span><br><span class="line">    start = <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">    end = <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 불변식을 만족하는지 검사한다.</span></span><br><span class="line">    <span class="keyword">if</span>(start.compareTo(end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(start + <span class="string">"가 "</span> + end + <span class="string">"보다 늦다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>방어적 복사를 유효성 검사보다 앞서 수행하며, Date의 clone 메서드는 사용하지 않았음에 주목하자.</li><li>두 조치 모두 Period를 공격으로 부터 보호하는데 필요하다.</li><li>또한 final 필드는 방어적 복사가 불가능 하니 주의하자</li><li>그래서 이 readObject를 사용하려면 start와 end필드에서 final 한정자를 제거해야 한다.</li></ul><h1 id="기본-readobject를-사용해도-되는지에-대한-체크리스트">기본 readObject를 사용해도 되는지에 대한 체크리스트</h1><ul><li>transient 필드를 제외한 모든 필드의 값을 매개변수로 받아 유효성 검사 없이 필드에 대입하는 public 생성자를 추가해도 괜찮은가?<ul><li>아니오 -&gt; 커스텀 readObject 메서드를 만들어 유효성 검사와 방어적 복사를 수행</li><li>예 -&gt; 기본 readObject 메서드 사용</li></ul></li><li>직렬화 프록시 패턴을 사용해도 된다 .<ul><li>역직렬화를 안전하게 만드는 데 필요한 노력을 경감해 준다. (권장)</li></ul></li></ul><h1 id="정리">정리</h1><ul><li>readObject 메서드를 작성할 때는 언제나 public 생성자를 만든다고 생각하고 만들어야 한다.</li><li>private 이어야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사하라 (불변 클래스 내의 가변 요소)</li><li>모든 불변식을 검사하여 어긋나는 게 발견되면 InvalidObjectException을 던진다.<br>방어적 복사 다음에는 반드시 불변식 검사가 뒤따라야 한다.</li><li>역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면 ObjectInputValidation 인터페이스를 사용하라</li><li>직접적이든 간접적이든 readObject메서드에서 재정의 가능한 메서드를 호출해서는 안된다.</li><li>재정의 가능한 메서드가 재정의되면 하위 클래스의 상태가 완전히 역직렬화 되기전에 하위 클래스에서 재정의된 메서드가 실행되므로<br>프로그램 오작동을 일으킬 수 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 88. readObject 메서드는 방어적으로 작성하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/17/effective-java-item88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 87. 커스텀 직렬화 형태를 고려해보라</title>
      <link>https://jaehun2841.github.io/2019/03/17/effective-java-item87/</link>
      <guid>https://jaehun2841.github.io/2019/03/17/effective-java-item87/</guid>
      <pubDate>Sun, 17 Mar 2019 06:21:53 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;개발 일정에 쫓기는 상황에서는 API 설계에 노력을 집중하는 편이 낫다.&lt;br&gt;
다음 릴리스에서 세부적인 기능을 제대로 구현하고 이번 릴리즈는 대충 동작만하게 하면 된다는 뜻이다.&lt;br&gt;
하지만 클래스가 Ser
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>개발 일정에 쫓기는 상황에서는 API 설계에 노력을 집중하는 편이 낫다.<br>다음 릴리스에서 세부적인 기능을 제대로 구현하고 이번 릴리즈는 대충 동작만하게 하면 된다는 뜻이다.<br>하지만 클래스가 Serializable을 구현하고 기본 직렬화 형태를 사용한다면 다음 릴리즈때 버리려 한 현재의 구현에 영원히 발이 묶이게 된다.<br>(현재의 기본 직렬화 형태를 버릴 수 없게 되기 때문이다.)</p><h1 id="먼저-고민해보고-괜찮다고-판단될-때만-기본-직렬화-형태를-사용하라">먼저 고민해보고 괜찮다고 판단될 때만 기본 직렬화 형태를 사용하라</h1><ul><li>기본 직렬화 형태는 유연성,  성능, 정확성, 측면에서 신중히 고민한 후 합당할 때만 사용해야 한다.</li><li>직접 설계하더라도 기본 직렬화 형태와 거의 같은 결과가 나올 경우에만 기본 형태를 써야 한다.</li><li>기본 직렬화 형태는 그 객체를 루트로 하는 객체 그래프의 물리적 모습을 나름 효율적으로 인코딩한다.</li><li>객체가 포함한 데이터들과 그 객체에서부터 시작해 접근할 수 있는 모든 객체를 담아내며 객체들이 연결된 위상(topology)까지 기술한다.</li><li>하지만 이상적인 직렬화 형태는 <strong>물리적인 모습과 독립된 논리적인 모습만을 표현해야 한다.</strong></li></ul><h1 id="객체의-물리적-표현과-논리적-내용이-같다면-기본-직렬화-형태라도-무방하다">객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 성. null이 아니어야함</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lastName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 이름. null이 아니어야 함.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String firstName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 중간이름. 중간이름이 없다면 null.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String middleName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>기본 직렬화 형태가 적합하다고 결정했더라고 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다.</li><li>Name의 3개의 필드는 private임에도 불구하고 문서화 주석이 달려있다.</li><li>이 필드들은 결국 클래스의 직렬화 형태에 포함되는 공개 API에 속하며 공개 API는 모두 문서화 해야 하기 때문이다.</li><li>private 필드의 설명을 API 문서에 포함하라고 자바독에 알려주는 역할은 @serial태그가 한다.</li><li>@serial 태그로 기술한 내용은 API 문서에서 직렬화 형태를 설명하는 특별한 페이지에 기록된다.</li></ul><h1 id="기본-직렬화-형태에-적합하지-않은-클래스">기본 직렬화 형태에 적합하지 않은 클래스</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Entry head = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        String data;</span><br><span class="line">        Entry next;</span><br><span class="line">        Entry previous;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>논리적으로는 이클래스는 일련의 문자열을 표현한다.<br>물리적으로는 문자열을 이중 연결 리스트로 연결했다. 이 클래스에 기본 직렬화 형태를 사용하면 각 노드의 양방향 연결 정보를 포함해 모든 엔트리(Entry)를 철두철미하게 기록한다.</p><h1 id="객체의-물리적-표현과-논리적-표현의-차이가-클-때-기본-직렬화-형태를-사용하는-경우-생기는-문제">객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하는 경우 생기는 문제</h1><h2 id="공개-api가-현재의-내부-표현-방식에-영구히-묶인다">공개 API가 현재의 내부 표현 방식에 영구히 묶인다.</h2><ul><li>앞의 예에서 private 클래스인 StringList.Entry가 공개 API가 되어버린다.</li><li>다음 릴리스에서 내부 표현 방식을 바꾸더라도 StringList 클래스는 여전히 연결 리스트로 표현된 입력도 처리할 수 있어야 한다.</li><li>즉 연결 리스트를 더 이상 사용하지 않더라도 관련 코드를 제거할 수 없다.</li></ul><h2 id="너무-많은-공간을-차지할-수-있다">너무 많은 공간을 차지할 수 있다.</h2><ul><li>앞 예의 직렬화 형태는 연결 리스트의 모든 엔트리와 연결 정보까지 기록했지만, 엔트리와 연결 정보는 내부 구현에 해당하니 직렬화 형태에 포함할 가치가 없다.</li><li>이처럼 직렬화 형태가 너무 커져서 디스크에 저장하거나 네트워크로 전송하는 속도가 느려진다.</li></ul><h2 id="시간이-너무-많이-걸릴-수-있다">시간이 너무 많이 걸릴 수 있다.</h2><ul><li>직렬화 로직은 객체 그래프의 위상에 관한 정보가 없으니 그래프를 직접 순회해볼 수밖에 없다.</li><li>앞의 예제는 간단히 다음 참조를 따라가 보는 정도로 충분하다.</li></ul><h2 id="스택-오버플로를-일으킬-수-있다">스택 오버플로를 일으킬 수 있다.</h2><ul><li>기본 직렬화 과정은 객체 그래프를 재귀 순회하는데 중간정도 크기의 객체 그래프에서도 스택 오버플로 에러가 날 수 있다.</li><li>그때그때 다른 시점에서 스택 오버플로가 날 수 있고, 어떤 플랫폼에서는 에러가 나지 않을 수도 있다.</li></ul><h1 id="합리적인-커스텀-직렬화-형태를-갖춘-stringlist">합리적인 커스텀 직렬화 형태를 갖춘 StringList</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry head = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 이제는 직렬화되지 않는다.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">        String data;</span><br><span class="line">        Entry next;</span><br><span class="line">        Entry previous;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 지정한 문자열을 이 리스트에 추가한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 이 &#123;<span class="doctag">@code</span> StringList&#125; 인스턴스를 직렬화한다.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> 이 리스트의 크기(포함된 문자열의 개수)를 기록한 후</span></span><br><span class="line"><span class="comment">     * (&#123;<span class="doctag">@code</span> int&#125;), 이어서 모든 원소를(각각은 &#123;<span class="doctag">@code</span> String&#125;)</span></span><br><span class="line"><span class="comment">     * 순서대로 기록한다.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//기본 직렬화를 수행한다.</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        s.writeInt(size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 커스텀 역직렬화를 수행한다.</span></span><br><span class="line">        <span class="comment">// 모든 원소를 올바른 순서로 기록한다.</span></span><br><span class="line">        <span class="keyword">for</span> (Entry e = head; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">            s.writeObject(e.data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//기본 역직렬화를 수행한다.</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        <span class="keyword">int</span> numElements = s.readInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 커스텀 역직렬화 부분</span></span><br><span class="line">        <span class="comment">// 모든 원소를 읽어 이 리스트에 삽입한다.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i++) &#123;</span><br><span class="line">            add((String) s.readObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>StringList의 필드 모두가 transient더라도 writeObject와 readObject는 각각 먼저 defaultWriteObject와 defaultReadObject를 호출한다.</p></li><li><p>클래스의 인스턴스가 모두 transient더라도 defaultWriteObject와 defaultReadObject를 호출해줘야 한다.<br>(향후 릴리즈에서 transient가 아닌 필드가 추가되더라도 상호 호환되기 때문이다)</p></li><li><p>신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화하면 새로 추가된 필드들은 무시될 것이다.</p></li><li><p>구버전 readObject 메서드에서 defaultReadObject를 호출하지 않는다면 역직렬화할 때 StreamCorruptedException이 발생할 것이다.</p></li><li><p>writeObject는 private 메서드임에도 문서화 주석이 달려 있다.<br>이 private 메서드는 직렬화 형태에 포함되는 공개 API에 속하며 공개 API는 모두 문서화 해야한다.</p></li><li><p>메서드에 달린 @serialData 태그는 자바독 유틸리티에게 이 내용을 직렬화 형태 페이지에 추가하도록 요청한다.</p></li><li><p>개선한 StringList는 원래버전의 절반정도의 공간을 차지하며 수행속도 또한 두 배 이상 빠르다.</p></li><li><p>개선한 StringList는 스택 오버플로 에러가 발생하지 않는다. (크기의 제한이 사라짐)</p></li><li><p>객체를 직렬화한 후 역직렬화하면 원래 객체를 그 불변식까지 포함해 제대로 복원해낸다는 점에서 정확하다 할 수 있다.</p></li><li><p>하지만 불변식이 세부 구현에 따라 달라지는 객체에서는 이 정확성마저 깨질 수 있다.</p></li></ul><h1 id="객체의-불변식이-깨지는-경우에는-직렬화를-주의해야한다">객체의 불변식이 깨지는 경우에는 직렬화를 주의해야한다.</h1><p>해시 테이블을 예로 생각해보면 이해할 수 있다.  해시 테이블은 물리적으로는 key-value 엔트리를 담은 해시 버킷을 차례로 나열한 형태다.<br>어떤 엔트리를 어떤 버킷에 담을지는 key에서 구한 hashcode가 결정하는데 <strong>그 계산 방식은 구현에 따라 달라질 수 있다.</strong><br>혹은 계산할 때마다 달라지기도 한다.<br>따라서 해시테이블을 직렬화한 후 역직렬화하면 불변식이 심각하게 훼손된 객체들이 생겨날 수 있는 것이다.</p><h1 id="객체의-논리적-상태와-무관한-필드라고-확신하면-transient-한정자를-생략하라">객체의 논리적 상태와 무관한 필드라고 확신하면 transient 한정자를 생략하라</h1><ul><li>기본 직렬화를 수용하든 하지 않든 defaultWriteObject 메서드를 호출하면 transient로 선언하지 않은 모든 인스턴스 필드가 직렬화된다.</li><li>따라서 transient로 선언해되 되는 인스턴스 필드에는 모두 transient를 붙여야 한다.</li><li>JVM을 실행할 때마다 값이 달라지는 필드도 transient를 붙여야 한다.</li><li>커스텀 직렬화 형태를 사용한다면 앞서의 StringList 처럼 대부분의(혹은 모든) 인스턴스 필드를 transient로 선언해야 한다.</li></ul><h1 id="동기화-메커니즘을-직렬화에도-적용해야-한다">동기화 메커니즘을 직렬화에도 적용해야 한다.</h1><p>모든 메서드를 synchronized로 선언하여 스레드 안전하게 만든 객체에서 기본 직렬화를 사용하려면<br>writeObject도 다음 코드 처럼 synchronized로 선언해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>writeObject 메서드 안에서 동기화 하고 싶다면 클래스의 다른 부분에서 사용하는 락 순서를 똑같이 따라야 한다.<br>그렇지 않으면 교착상태 (resource-ordering deadlock)에 빠질 수 있다.</p><h1 id="직렬-버전-uid를-명시적으로-부여하자">직렬 버전 UID를 명시적으로 부여하자</h1><p>어떤 직렬화 형태를 사용하든 직렬 가능 클래스에 모두 직렬 버전 UID를 명시적으로 부여하자.<br>이렇게 하면 직렬 버전 UID가 일으키는 잠재적인 호환성 문제가 사라진다.<br>성능도 조금 빨라지는데 직렬 버전 UID를 명시하지 않으면 런타임에 이 값을 생성하느라 복잡한 연산을 수행하기 때문이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">232923283928929</span>;</span><br></pre></td></tr></table></figure></p><p>위와 같은 형태로 사용하면 된다.<br>Intellij 에서는 alt+insert 단축키를 누르면 serialVersionUID를 자동으로 생성해 주는 메뉴가 있다.<br>기존 클래스를 구버전으로 직렬화된 인스턴스와 호환성을 유지한 채 사용하고 싶다면<br>기존 클래스를 구버전에서 사용한 자동 생성된 값을 그대로 사용해야 한다.</p><h2 id="주의할-점">주의할 점</h2><p><strong>직렬버전 UID는 클래스의 명세가 변경되면 자동 생성된 값이 바뀌기 때문에 이부분도 주의해야 한다.</strong><br>구버전과 호환이 되지 않아 역직렬화가 되지 않는다.<br>기존 버전의 직렬화된 인스턴스를 역직렬화할 때 InvalidClassException이 던져질 것이다.<br>구버전으로 직렬화된 인스턴스들과 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID를 절대 수정하면 안된다.</p><h1 id="정리">정리</h1><ul><li>클래스를 직렬화하기로 했다면 어떤 직렬화 형태를 사용할지 심사숙고 해야한다.</li><li>자바의 기본 직렬화 형태는 객체를 직렬화한 결과가 해당 객체의 논리적 표현에 부합할 때만 사용하고 그렇지 않으면 객체를 적절히 설명하는 커스텀 직렬화 형태를 고안해야 한다.</li><li>직렬화 형태도 공개 메서드를 설계할 때에 준하는 시간을 들여 설계 해야 한다.</li><li>한번 공개된 메서드는 향후 릴리즈에서 제거할 수 없듯이 직렬화 형태에 포함된 필드도 마음대로 제거할 수 없다.</li><li>직렬화 호환성을 유지하기 위해 영원히 지원해야 한다.</li><li>잘못된 직렬화 형태를 선택하면 해당 클래스의 복잡성과 성능에 영구히 부정적인 영향을 남긴다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 87. 커스텀 직렬화 형태를 고려해보라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/17/effective-java-item87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 79. 과도한 동기화는 피하라</title>
      <link>https://jaehun2841.github.io/2019/03/12/effective-java-item79/</link>
      <guid>https://jaehun2841.github.io/2019/03/12/effective-java-item79/</guid>
      <pubDate>Mon, 11 Mar 2019 15:28:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.&lt;br&gt;
&lt;strong&gt;응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.<br><strong>응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.</strong></p><ul><li>동기화(synchronized) 된 코드 블럭 안에서는 재정의 가능한 메서드를 호출해선 안된다.</li><li>클라이언트가 넘겨준 함수객체를 호출해서도 안된다.</li><li>이런 메서드는 동기화도니 클래스 관점에서 외계인 메서드(alien method)라고 칭한다.<br>(무슨일을 할지 모르니, 이 메서드가 예외를 발생시키거나, 교착상태를 만들거나, 데이터를 훼손시킬 수 있다.)</li></ul><h1 id="외계인-메서드">외계인 메서드</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ForwardingSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableSet</span><span class="params">(Set&lt;E&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserver&lt;E&gt;&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            observers.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">return</span> observers.remove(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">for</span>(SetObserver&lt;E&gt; observer : observers) &#123;</span><br><span class="line">                observer.added(<span class="keyword">this</span>, element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> added = <span class="keyword">super</span>.add(element);</span><br><span class="line">        <span class="keyword">if</span>(added) &#123;</span><br><span class="line">            notifyElementAdded(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> added;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : c) &#123;</span><br><span class="line">            result |= add(element); <span class="comment">//notifyElementAdded를 호출</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>관찰자들은 addObserver와 removeObserver 메서드를 호출해 구독을 신청하거나 해지한다.</li><li>두 경우 다음 콜백 인터페이스의 인스턴스를 메서드에 전달</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SetObserver</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//ObservableSet에 원소가 더해지면 호출된다.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet&lt;E&gt; set, E element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 인터페이스는 구조적으로 BiConsumer&lt;ObservableSet&lt;E&gt;,  E&gt;와 똑같다.</li><li>커스텀 함수형 인터페이스를 정의한 이유는 이름이 더 직관적이고 다중 콜백을 지원하도록 확장할 수 있기 때문이다.</li></ul><h1 id="외계인-메서드-예제1">외계인 메서드 - 예제1</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ObservableSet&lt;Integer&gt; set = <span class="keyword">new</span> ObservableSet&lt;&gt;(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    set.addObserver(<span class="keyword">new</span> SetObserver&lt;&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet&lt;Integer&gt; s, Integer e)</span> </span>&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            <span class="keyword">if</span>(e == <span class="number">23</span>) &#123;</span><br><span class="line">                s.removeObserver(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        set.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>s.removeObserver에 this를 넘겨야하는데 람다에서는 방법이 없으므로 익명클래스의 형태로 사용</li><li>이 프로그램은 0~23까지 출력한 후 Observer 자신을 구독해제 한 후 아무런 로그도 뜨지 않고 종료할 것 같다.</li><li>하지만 그렇지 않다. 프로그램은 0~23까지 출력한 후 <code>ConcurrentModificationException</code> 을 던진다.</li><li>왜냐하면 Observer의 added 메서드 호출이 일어난 시점이 notifyElementAdded가 Observer들의 리스트를 순회하는 도중이기 때문이다.</li><li>added 메서드 -&gt; ObservableSet.removeObserver를 호출 -&gt; observers.remove 호출</li><li>리스트에서 원소를 제거하려는데 마침 지금은 이 원소를 순회하는 중 <strong>(허용되지 않은 동작)</strong></li><li>notifyElementAdded 메서드에서 수행하는 순회는 동기화 블록 안에 있으므로 동시 수정이 일어나지 않지만<br>정작 자신이 콜백을 거쳐 되돌아와 수정하는 것을 막진 못한다.</li></ul><h1 id="외계인-메서드-예제-2">외계인 메서드 - 예제 2</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set.addObserver(<span class="keyword">new</span> SetObserver&lt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet&lt;Integer&gt; s, Integer e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">if</span>(e == <span class="number">23</span>) &#123;</span><br><span class="line">            ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                exec.submit(() -&gt; s.removeObserver(<span class="keyword">this</span>)).get(); <span class="comment">//여기서 lock이 걸려서 못들어감</span></span><br><span class="line">                <span class="comment">//하지만 메인 스레드는 너의 작업을 기다리고 있어</span></span><br><span class="line">            &#125; <span class="keyword">catch</span>(ExecutionException | InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(ex);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ul><li>이 프로그램을 실행하면 에러는 나진 않지만 교착상태(Dead-lock)에 빠진다.</li><li>백그라운드 스레드가 s.removeObserver를 호출하면 Observer를 잠그려 시도하지만 락을 얻을 수 없다.<br>(메인스레드가 이미 락을 쥐고 있기 때문 - removeObserver는 synchronized 키워드가 달려있어서 실행 시 락이 걸린다.)</li><li>그와 동시에 메인 스레드는 백그라운드 스레드가 Observer를 제거하기만을 기다리는 중이다.</li></ul><h1 id="교착상태-해결방법">교착상태 해결방법</h1><p>자바 언어의 락은 재진입(reentrant)을 허용하므로 교착상태에 빠지지는 않는다.<br>재진입 가능 락은 객체 지향 멀티스레드 프로그램을 쉽게 구현 할 수 있도록 해준다.<br>하지만 응답 불가(교착상태)가 될 상황을 안전 실패(데이터 훼손)으로 변모시킬 수도 있다.</p><p>이런 경우 외계인 메서드 호출을 동기화 블록 바깥으로 옮기면 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    List&lt;SetObserver&lt;E&gt;&gt; snapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(observers) &#123;</span><br><span class="line">        snapshot = <span class="keyword">new</span> ArrayList&lt;&gt;(observers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SetObserver&lt;E&gt; observer : snapshot) &#123;</span><br><span class="line">        observer.added(<span class="keyword">this</span>, element); <span class="comment">//외계인 메서드를 동기화 블록 바깥으로 옮겼다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="copyonwritearraylist">CopyOnWriteArrayList</h1><p>외계인 메서드 호출을 동기화 블록 바깥으로 옮기는 것 보다 더 나은 방법은 java.util.concurrent 패키지의 CopyOnWriteArrayList를 사용하는 것이 좋다.<br>내부를 변경하는 작업은 항상 깨끗한 복사본을 만들어 수행한다.<br>내부의 배열은 절대 수정되지 않아 락이 없어 빠르다.<br>다른 용도로 쓰인다면 매번 복사해서 느리겠지만, 수정할 일은 드물고 순회만 빈번히 일어나는 Observer 리스트 용으로는 딱이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserser&lt;E&gt;&gt; observers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observers.remove(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (SetObserver&lt;E&gt; observer : observers) &#123;</span><br><span class="line">         observers.added(<span class="keyword">this</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="동기화의-성능">동기화의 성능</h1><p>자바의 동기화 비용은 빠르게 낮아져 왔지만, 과도한 동기화를 피하는일은 오히려 과거 어느 때보다 중요하다.<br>멀티코어가 일반화된 오늘날 과도한 동기화가 초래하는 진짜 비용은 락을 얻는데 드는 CPU 시간이 아니다.<br>서로 스레드끼리 경쟁하는 Race Condition에 낭비가 발생한다.</p><ul><li>병렬로 실행할 기회를 잃는다.</li><li>모든 코어가 메모리를 일관되게 보기위한 지연시간이 진짜 비용</li><li>가상머신의 코드최적화를 제한하는 점도 숨은 비용</li></ul><h2 id="가변-클래스를-작성하는-경우-동기화에-대해-고려할-점">가변 클래스를 작성하는 경우 동기화에 대해 고려할 점</h2><ol><li>동기화를 전혀 하지 말고 가변 클래스를 동시에 사용해야하는 클래스가 외부에서 동기화하자</li><li>동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.<br>(단 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 두번째 방법을 쓴다)</li></ol><h1 id="정리">정리</h1><ul><li>기본 규칙은 동기화 영역에서 가능한 한 일을 적게하는 것이다.<br>(락을 얻고 공유 데이터를 검사하고, 필요하면 수정하고, 락을 놓는다.)</li><li>오래 걸리는 작업이라면 동기화 영역 밖으로 옮기는 방법을 찾아보자.</li><li>여러 스레드가 호출할 가능성이 있는 메서드가 정적 필드를 수정한다면 그 필드를 사용하기 전에 반드시 동기화 해야 한다.</li><li>교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자</li><li>동기화 영역 안에서 작업은 최소한으로 줄이자</li><li>가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자</li><li>지금은 과도한 동기화를 피하는게 제일 중요하다</li><li>합당한 이유가 있을때만 내부에서 동기화하고 동기화 여부를 문서에 남기자.<br>(웬만하면 외부에서 동기화를 하자)</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 79. 과도한 동기화는 피하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/12/effective-java-item79/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 78. 공유 중인 가변 데이터는 동기화해 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/11/effective-java-item78/</link>
      <guid>https://jaehun2841.github.io/2019/03/11/effective-java-item78/</guid>
      <pubDate>Mon, 11 Mar 2019 07:02:45 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;싱글 스레드 기반의 프로그램에서는 하나의 스레드가 하나의 객체를 사용하면 되기 때문에 동기화에 대한 걱정을 하지 않아도 되지만,&lt;br&gt;
멀티 스레드 기반의 환경에서는 여러개의 스레드가 하나의 객체를 공유해서 사
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>싱글 스레드 기반의 프로그램에서는 하나의 스레드가 하나의 객체를 사용하면 되기 때문에 동기화에 대한 걱정을 하지 않아도 되지만,<br>멀티 스레드 기반의 환경에서는 여러개의 스레드가 하나의 객체를 공유해서 사용하는 경우가 있다.<br>하나의 객체를 공유하며 사용하는 경우 불변 객체에 대해서는 동기화를 걱정할 필요가 없지만,<br>스레드가 메서드를 실행하면서 변수의 데이터를 변경하는 경우 다른 스레드에서 동기화되지 않은 데이터를 읽을 수 있다.<br>이런 경우에는 프로그래머가 기대한 결과와는 다른 결과를 초래할 수 있기 때문에 주의해야 한다.</p><h1 id="동기화란">동기화란?</h1><p>동기화(Syncronized)란 멀티스레드 환경에서 하나의 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장하는 것을 의미한다.</p><h2 id="동기화의-특징">동기화의 특징</h2><ul><li>한 객체가 일관된 상태를 가지고 생성되었을 때, 이 객체에 접근하는 메서드는 그 객체에 Lock을 건다.<br>(다른 스레드가 메서드를 실행할 때 실행되지 못하도록 Lock을 건다)</li><li>Lock을 건 메서드는 객체의 상태를 확인하거나 필요하면 수정한다.</li><li>즉 일관된 하나의 상태 -&gt; 다른 일관된 하나의 상태로 변화한다.</li><li>메서드 실행이 끝나면 Lock을 해제한다.</li><li>동기화를 제대로 사용하면 어떤 메서드도 이 객체의 상태가 일관되지 않은 순간을 볼 수 없다.</li><li><strong>동기화 없이는</strong> 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.<br>(동기화가 없다면, 너도나도 접근하는데 시점에 따라 일관된 상태가 아닐 수도 있기 때문)</li><li>언어 명세상 long과 double 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이다.<br>(여러 스레드가 하나의 변수에 동기화 없이 접근해도 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장)</li><li>성능을 높이려면 원자적 데이터를 읽고 쓸 때는 동기화 하지 말아야겠다 <strong>(위험한 발상)</strong><br>(필드를 읽을 때 항상 <strong>수정이 완전히 반영된 값</strong> 을 얻지만, <strong>한 스레드가 저장한 값이 다른 스레드에도 보이는가?</strong> 는 보장하지 않음)</li></ul><h1 id="java에서의-가변-데이터-동기화-방법">Java에서의 가변 데이터 동기화 방법</h1><p>Java에서는 <strong>synchronized</strong> 키워드를 통해 동기화 처리를 할 수 있다.</p><ul><li>가변데이터를 수정하거나 읽는 메서드를 동기화</li><li>가변 객체에 대한 동기화</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">countup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(list) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="한-스레드가-저장한-값이-다른-스레드에도-보이는가">한 스레드가 저장한 값이 다른 스레드에도 보이는가?</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread backgroundThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위의 코드는 대충 보면 1초뒤에 <code>stopRequested</code> 필드가 false로 바뀌면서 스레드 내의 while문이 종료될 것 처럼 보인다.</li><li>하지만 무한루프!!!</li><li>원인은 동기화에 있다.</li><li>동기화하지 않으면 메인 스레드에서 수정한 <code>stopRequested</code> 필드가 언제 false로 보일지 모른다.<br>(맨 마지막에 stopRequested가 false가 되면서 실제 원잣값은 false가 된다)</li><li>위의 문제를 해결하기 위해서는 <code>stopRequested</code> 필드에 대한 동기화 처리가 필요하다</li></ul><h2 id="동기화가-빠지는-경우-jvm에서-최적화를-수행할-수도-있다">동기화가 빠지는 경우 JVM에서 최적화를 수행할 수도 있다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//원래 코드</span></span><br><span class="line"><span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 최적화한 코드</span></span><br><span class="line"><span class="keyword">if</span>(!stopRequested) &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>JVM의 호이스팅 기법을 통해 최적화 할 수 있다.</li><li>이 결과 프로그램은 응답 불가 상태가 되어 더 이상 진전이 없다.</li></ul><h1 id="위의-코드를-동기화-해보자">위의 코드를 동기화 해보자</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">requestStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stopRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">stopRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stopRequested;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread backgroundThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested()) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위와 같이 <strong>stopRequested</strong> 필드의 읽기/쓰기에 대한 동기화처리를 하면 위의 프로그램이 1초뒤에 종료된다.</li><li>읽기/쓰기 메서드 모두 동기화 처리를 하였음에 주목하자</li><li>쓰기 메서드만 동기화처리를 하고 읽기 메서드에는 동기화처리를 하지 않으면 동작을 보장할 수 없다.</li></ul><h1 id="volatile-키워드">volatile 키워드</h1><p>volatile 키워드의 의미는 <code>volatile 변수를 읽어 들일 때 CPU 캐시가 아니라 컴퓨터의 메인 메모리로 부터 읽어들인다.</code><br>즉 read 할 때도 CPU 캐시가 아닌 메인메모리에서 read하고, write할 때도 메인 메모리에 write를 수행</p><p><img src="./java-volatile.png" alt="java-volatile"></p><p>long, double을 제외한 기본타입은 <strong>volitile</strong> 키워드를 사용하면 동기화를 생략해도 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread backgroundThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>volitile 예약어는 배타적 수행(한 블록을 한 스레드가 실행) 하는것과는 관계없다</li><li>volatile 변수는 CPU캐시에서 값을 읽는게 아닌 메인 메모리에서 읽기 때문에 항상 최근에 기록된 값을 읽는다.<br>(그렇기 때문에 위의 프로그램이 1초 뒤에 종료됨)</li></ul><h1 id="volatile-사용-시-주의할-점">volatile 사용 시 주의할 점</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> nextSerialNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">generateSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 메서드는 호출 될 때 마다 1씩 증가하여 스레드에서 고유한 값을 반환할 의도로 만들어 졌다.</li><li>겉보기에는 int이기 때문에 원자적으로 접근할 수 있을 것 같다</li><li>Volatile 키워드가 쓰여져있기 때문에 최신 값을 읽을 수 있을 것 같지만 제대로 된 고유한 값이 나오지 않는다.</li></ul><h2 id="원인은-nextserialnumber">원인은 nextSerialNumber++</h2><p>원인은 nextSerialNumber++에 있었다.<br>실제 이 코드는 1줄이지만 풀어쓰면 nextSerialNumber = nextSerialNumber + 1; 와 같은 형태이다.<br>결국 nextSerialNumber 값을 한번 읽어와 +1 한다음에 다시 nextSerialNumber 변수에 저장하는 형태이다.<br>만약 두번째 스레드가 nextSerialNumber + 1 연산이 이루어지는 시점을 비집고 들어온다면 1이 두번 리턴되는 형국이다.<br>이런 오류를 <strong>안전 실패(safety failure)</strong> 이라고 한다.</p><h2 id="문제-해결은-synchronized">문제 해결은 synchronized</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> nextSerialNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">generateSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 generateSerialNumber 메서드에 synchronized만 붙여주면 문제는 해결된다.<br>동시에 호출해도 배타적으로 실행 (한번에 한 스레드만 실행) 되기 때문이다.<br>만약 위 처럼 generateSerialNumber 메서드에 synchronized를 붙였다면 nextSerialNumber 변수에는 volatile을 제거해야 한다.<br>만약 메서드를 더 견고하게 하려면 int 대신 long을 사용하는게 더 많은 수를 사용할 수 있다.</p><h1 id="long-double을-사용할-때는-더욱-더-주의하자">long, double을 사용할 때는 더욱 더 주의하자</h1><ul><li>Java.util.concurrent.atomic 패키지의 AtomicLong, AtomicDouble을 사용하는 것이 좋다.</li><li>이 패키지는 락 없이도(lock-free) 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨 있다.</li><li>volatile은 동기화 속성 중 통신에 대해서만 보장</li><li>Java.util.concurrent.atomic 패키지는 원자성(배타적 실행) 까지 지원한다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextSerialNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">generateSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNum.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="정리">정리</h1><ul><li>동기화에 대한 문제를 피하는 가장 좋은 방법은 가변 데이터를 공유하지 않는 것이다.</li><li>가변데이터는 단일 스레드에서만 사용하는 것이 좋다</li><li>가변데이터를 단일 스레드에서만 사용한다면 문서에 남겨 유지보수 정책에서도 지켜지는것이 중요하다</li><li>멀티 스레드 환경에서 한 스레드가 데이터를 수정한 후에 다른 스레드에 공유할 때는 해당 객체에서 공유하는 부분만 동기화해도 된다.</li><li>클래스 초기화 과정에서 객체를 정적필드, volatile필드, final 필드, 혹은 보통의 락을 통해 접근하는 필드에 저장해도 된다.</li><li>여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 메서드 모두에 반드시 synchronized 키워드를 붙인다.</li><li>배타적 실행 (한번에 한스레드) 동작이 필요없고, 스레드 간 최신데이터만 읽는 거로도 충분하면 가변 변수에 volatile 키워드만으로도 동기화가 가능하다</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 78. 공유 중인 가변 데이터는 동기화해 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/11/effective-java-item78/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 74. 메서드가 던지는 모든 예외를 문서화하라</title>
      <link>https://jaehun2841.github.io/2019/03/10/effective-java-item74/</link>
      <guid>https://jaehun2841.github.io/2019/03/10/effective-java-item74/</guid>
      <pubDate>Sun, 10 Mar 2019 11:07:57 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;메서드가 던지는 예외는 그 메서드를 올바로 사용하는 데 아주 중요한 정보다.&lt;br&gt;
따라서 각 메서드가 던지는 예외 하나하나를 문서화하는 데 충분한 시간을 쏟아야 한다.&lt;/p&gt;
&lt;h1 id=&quot;검사-예외는-thr
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>메서드가 던지는 예외는 그 메서드를 올바로 사용하는 데 아주 중요한 정보다.<br>따라서 각 메서드가 던지는 예외 하나하나를 문서화하는 데 충분한 시간을 쏟아야 한다.</p><h1 id="검사-예외는-throws-태그로-문서화하라">검사 예외는 @throws 태그로 문서화하라</h1><p>검사 예외(Checked Exception)는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자.<br>공통 상위 예외 클래스 하나로 뭉뚱그려 선언하는 일은 삼가야 한다.<br>극단적인 예로 Exception이나 Throwable을 던진다고 선언해서는 안된다.<br>메서드 사용자에게 각 예외에 대처할 수 있는 힌트를 주지 못할뿐더러 같은 맥락에서 발생할 여지가 있는 다른 예외들 까지 삼켜버릴 수 있기 때문에 API 사용성을 크게 떨어뜨린다.</p><h2 id="잘못된-방법">잘못된 방법</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>같은 맥락에서 발생할 수 있는 다른 예외들까지 삼켜버려 API 사용성이 떨어진다.</li><li>main메서드는 JVM만이 호출하므로 Exception을 던지도록 선언해도 괜찮다.</li></ul><h2 id="권장하는-방법">권장하는 방법</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NumberFormatException - params가 숫자형 데이터가 아닌경우 throw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String params)</span> <span class="keyword">throws</span> IllegalStateException, SQLException, NumberFormatException </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="비검사-예외runtime-exception도-문서로-남기면-좋다">비검사 예외(Runtime Exception)도 문서로 남기면 좋다.</h1><p>자바 언어에서 요구하는 것은 아니지만 비검사 예외(Runtime Exception)도 검사 예외(Checked Exception) 처럼 정성껏 문서화 해두면 좋다.<br>비검사 예외(Runtime Exception)는 일반적으로 프로그래밍 오류를 뜻하는데 자신이 일으킬 수 있는 오류들이 무엇인지 알려주면<br>프로그래머는 자연스럽게 해당 오류가 나지 않도록 코딩하게 된다.<br>잘 정비된 비검사 예외 문서는 그 메서드를 성공적으로 수행하기 위한 전제조건이 된다.</p><p>public 메서드라면 필요한 전제조건을 문서화해야 하며, 그 수단으로 가장 좋은 것이 비검사 예외들을 문서화 하는것이다.<br><strong>특히 인터페이스에서 중요하다.</strong><br>이 조건이 인터페이스의 일반 규약에 속하게 되어 인터페이스를 구현한 모든 구현체가 일관되게 동작하도록 해주기 때문이다.</p><h1 id="비검사-예외runtime-exception은-메서드-시그니처에-추가하지-말자">비검사 예외(Runtime Exception)은 메서드 시그니처에 추가하지 말자</h1><p>메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.<br>검사냐 비검사냐에 따라 사용자가 해야할 일이 달라지므로 이 둘을 확실히 구분하는게 좋다.<br>자바독은 메서드 시그니처에 throws 절에 등장하고 메서드 주석의 @throws 태그에도 명시한 예외와 @throws 태그에만 명시한 예외를 시각적으로 구분해준다.<br>그래서 프로그래머는 어떤 것이 비검사 예외인지 바로 알 수 있다.</p><h1 id="거의-모든-메서드에서-같은-예외를-던진다면-class-설명에-추가하라">거의 모든 메서드에서 같은 예외를 던진다면 Class 설명에 추가하라</h1><p>한 클래스에 정의된 웬만한 메서드에서 같은 이유로 같은 예외를 던진다면 그 예외를 각각의 메서드가 아니라 클래스 설명에 추가하는 방법도 있다.<br>NullPointerException이 가장 흔한 사례다.<br>이럴 때는 클래스의 문서화 주석에 <strong>이 클래스의 모든 메서드는 인수로 null이 넘어오면 NullPointerException을 던진다.</strong> 라고 적어도 좋다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 74. 메서드가 던지는 모든 예외를 문서화하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/10/effective-java-item74/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 73. 추상화 수준에 맞는 예외를 던지라</title>
      <link>https://jaehun2841.github.io/2019/03/10/effective-java-item73/</link>
      <guid>https://jaehun2841.github.io/2019/03/10/effective-java-item73/</guid>
      <pubDate>Sun, 10 Mar 2019 10:31:02 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;수행하려는 일과 관련 없어 보이는 예외가 튀어나오면 당황스럽다.&lt;br&gt;
메서드가 저수준 예외를 처리하지 않고 바깥으로 throw 해버릴 때 상위 메서드에서 종종 발생하는 일이다.&lt;br&gt;
내부 구현방식을 상위에 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>수행하려는 일과 관련 없어 보이는 예외가 튀어나오면 당황스럽다.<br>메서드가 저수준 예외를 처리하지 않고 바깥으로 throw 해버릴 때 상위 메서드에서 종종 발생하는 일이다.<br>내부 구현방식을 상위에 드러내어 윗 레벨 API를 오염 시킬 수 있고, 다음 릴리스에서 구현방식이 변경되면 다른 예외가 튀어나와<br>기존 클라이언트 프로그램을 깨지게 할 수도 있다.</p><h1 id="상위-메서드에서-저수준-예외를-번역해야-한다">상위 메서드에서 저수준 예외를 번역해야 한다.</h1><p>상위 메서드에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다.<br>이를 예외 번역(Exception Translation)이라 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">..<span class="comment">// 저수준 추상화를 이용</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (LowerLevelException e) &#123;</span><br><span class="line">  <span class="comment">// 추상화 수준에 맞게 번역</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> HigherLevelException(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="저수준-예외의-내용이-필요하다면-예외-연쇄를-사용하라">저수준 예외의 내용이 필요하다면 예외 연쇄를 사용하라</h1><p>예외 연쇄(Exception chaining)이란 문제의 근본 원인(cause)인 저수준 예외를 고수준 예외에 실어 보내는 방식이다.<br>별도의 접근자 메서드(Throwable의 getCause메서드)를 통해 필요하면 언제든 저수준 예외를 꺼내 볼 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 저수준 추상화를 이용한다.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (LowerLevelException cause) &#123;</span><br><span class="line">  <span class="comment">// 저수준 예외를 고수준 예외에 실어 보낸다.</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> HigherLevelException(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HigherLevelException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">  HigherLevelException(Throwable cause) &#123;</span><br><span class="line">    <span class="keyword">super</span>(cause);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있다.<br>그렇지 않은 예외라도 Throwable의 initCause 메서드를 이용해 <code>원인</code> 을 직접 못박을 수 있다.<br>예외 연쇄는 문제의 원인을 프로그램에서 접근할 수 있게 해주며 원인과 고수준 예외의 Stack trace를 잘 통합해준다.</p><h1 id="예외-번역을-남용하지-말자">예외 번역을 남용하지 말자</h1><p>가능하다면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.<br>때로는 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 Validator를 이용하여 미리 검사하는 것이 좋다.</p><p>아래 계층에서의 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리하여 문제를 API 호출자에 전파하지 않는 방법이 있다.<br>이 경우 발생한 예외는 log를 활용하여 개발자가 디버깅을 할 수 있는 정도면 충분하다</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  lowerLevelMethod();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="comment">//Exception을 먹어버리고 상위로 전파되지 않도록 한다.</span></span><br><span class="line">  log.error(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="정리">정리</h1><ul><li>아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라</li><li>예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에  좋다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 73. 추상화 수준에 맞는 예외를 던지라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/10/effective-java-item73/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
