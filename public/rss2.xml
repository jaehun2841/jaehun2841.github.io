<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Carrey`s 기술블로그</title>
    <link>https://jaehun2841.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 11 Mar 2019 17:03:01 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Item 79. 과도한 동기화는 피하라</title>
      <link>https://jaehun2841.github.io/2019/03/12/effective-java-item79/</link>
      <guid>https://jaehun2841.github.io/2019/03/12/effective-java-item79/</guid>
      <pubDate>Mon, 11 Mar 2019 15:28:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.&lt;br&gt;
&lt;strong&gt;응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.<br><strong>응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.</strong></p><ul><li>동기화(synchronized) 된 코드 블럭 안에서는 재정의 가능한 메서드를 호출해선 안된다.</li><li>클라이언트가 넘겨준 함수객체를 호출해서도 안된다.</li><li>이런 메서드는 동기화도니 클래스 관점에서 외계인 메서드(alien method)라고 칭한다.<br>(무슨일을 할지 모르니, 이 메서드가 예외를 발생시키거나, 교착상태를 만들거나, 데이터를 훼손시킬 수 있다.)</li></ul><h1 id="외계인-메서드">외계인 메서드</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ForwardingSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableSet</span><span class="params">(Set&lt;E&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserver&lt;E&gt;&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            observers.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">return</span> observers.remove(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">for</span>(SetObserver&lt;E&gt; observer : observers) &#123;</span><br><span class="line">                observer.added(<span class="keyword">this</span>, element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> added = <span class="keyword">super</span>.add(element);</span><br><span class="line">        <span class="keyword">if</span>(added) &#123;</span><br><span class="line">            notifyElementAdded(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> added;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : c) &#123;</span><br><span class="line">            result |= add(element); <span class="comment">//notifyElementAdded를 호출</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>관찰자들은 addObserver와 removeObserver 메서드를 호출해 구독을 신청하거나 해지한다.</li><li>두 경우 다음 콜백 인터페이스의 인스턴스를 메서드에 전달</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SetObserver</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//ObservableSet에 원소가 더해지면 호출된다.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet&lt;E&gt; set, E element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 인터페이스는 구조적으로 BiConsumer&lt;ObservableSet&lt;E&gt;,  E&gt;와 똑같다.</li><li>커스텀 함수형 인터페이스를 정의한 이유는 이름이 더 직관적이고 다중 콜백을 지원하도록 확장할 수 있기 때문이다.</li></ul><h1 id="외계인-메서드-예제1">외계인 메서드 - 예제1</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ObservableSet&lt;Integer&gt; set = <span class="keyword">new</span> ObservableSet&lt;&gt;(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    set.addObserver(<span class="keyword">new</span> SetObserver&lt;&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet&lt;Integer&gt; s, Integer e)</span> </span>&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            <span class="keyword">if</span>(e == <span class="number">23</span>) &#123;</span><br><span class="line">                s.removeObserver(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        set.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>s.removeObserver에 this를 넘겨야하는데 람다에서는 방법이 없으므로 익명클래스의 형태로 사용</li><li>이 프로그램은 0~23까지 출력한 후 Observer 자신을 구독해제 한 후 아무런 로그도 뜨지 않고 종료할 것 같다.</li><li>하지만 그렇지 않다. 프로그램은 0~23까지 출력한 후 <code>ConcurrentModificationException</code> 을 던진다.</li><li>왜냐하면 Observer의 added 메서드 호출이 일어난 시점이 notifyElementAdded가 Observer들의 리스트를 순회하는 도중이기 때문이다.</li><li>added 메서드 -&gt; ObservableSet.removeObserver를 호출 -&gt; observers.remove 호출</li><li>리스트에서 원소를 제거하려는데 마침 지금은 이 원소를 순회하는 중 <strong>(허용되지 않은 동작)</strong></li><li>notifyElementAdded 메서드에서 수행하는 순회는 동기화 블록 안에 있으므로 동시 수정이 일어나지 않지만<br>정작 자신이 콜백을 거쳐 되돌아와 수정하는 것을 막진 못한다.</li></ul><h1 id="외계인-메서드-예제-2">외계인 메서드 - 예제 2</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set.addObserver(<span class="keyword">new</span> SetObserver&lt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet&lt;Integer&gt; s, Integer e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">if</span>(e == <span class="number">23</span>) &#123;</span><br><span class="line">            ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                exec.submit(() -&gt; s.removeObserver(<span class="keyword">this</span>)).get(); <span class="comment">//여기서 lock이 걸려서 못들어감</span></span><br><span class="line">                <span class="comment">//하지만 메인 스레드는 너의 작업을 기다리고 있어</span></span><br><span class="line">            &#125; <span class="keyword">catch</span>(ExecutionException | InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(ex);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ul><li>이 프로그램을 실행하면 에러는 나진 않지만 교착상태(Dead-lock)에 빠진다.</li><li>백그라운드 스레드가 s.removeObserver를 호출하면 Observer를 잠그려 시도하지만 락을 얻을 수 없다.<br>(메인스레드가 이미 락을 쥐고 있기 때문 - removeObserver는 synchronized 키워드가 달려있어서 실행 시 락이 걸린다.)</li><li>그와 동시에 메인 스레드는 백그라운드 스레드가 Observer를 제거하기만을 기다리는 중이다.</li></ul><h1 id="교착상태-해결방법">교착상태 해결방법</h1><p>자바 언어의 락은 재진입(reentrant)을 허용하므로 교착상태에 빠지지는 않는다.<br>재진입 가능 락은 객체 지향 멀티스레드 프로그램을 쉽게 구현 할 수 있도록 해준다.<br>하지만 응답 불가(교착상태)가 될 상황을 안전 실패(데이터 훼손)으로 변모시킬 수도 있다.</p><p>이런 경우 외계인 메서드 호출을 동기화 블록 바깥으로 옮기면 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    List&lt;SetObserver&lt;E&gt;&gt; snapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(observers) &#123;</span><br><span class="line">        snapshot = <span class="keyword">new</span> ArrayList&lt;&gt;(observers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SetObserver&lt;E&gt; observer : snapshot) &#123;</span><br><span class="line">        observer.added(<span class="keyword">this</span>, element); <span class="comment">//외계인 메서드를 동기화 블록 바깥으로 옮겼다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="copyonwritearraylist">CopyOnWriteArrayList</h1><p>외계인 메서드 호출을 동기화 블록 바깥으로 옮기는 것 보다 더 나은 방법은 java.util.concurrent 패키지의 CopyOnWriteArrayList를 사용하는 것이 좋다.<br>내부를 변경하는 작업은 항상 깨끗한 복사본을 만들어 수행한다.<br>내부의 배열은 절대 수정되지 않아 락이 없어 빠르다.<br>다른 용도로 쓰인다면 매번 복사해서 느리겠지만, 수정할 일은 드물고 순회만 빈번히 일어나는 Observer 리스트 용으로는 딱이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserser&lt;E&gt;&gt; observers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observers.remove(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (SetObserver&lt;E&gt; observer : observers) &#123;</span><br><span class="line">         observers.added(<span class="keyword">this</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="동기화의-성능">동기화의 성능</h1><p>자바의 동기화 비용은 빠르게 낮아져 왔지만, 과도한 동기화를 피하는일은 오히려 과거 어느 때보다 중요하다.<br>멀티코어가 일반화된 오늘날 과도한 동기화가 초래하는 진짜 비용은 락을 얻는데 드는 CPU 시간이 아니다.<br>서로 스레드끼리 경쟁하는 Race Condition에 낭비가 발생한다.</p><ul><li>병렬로 실행할 기회를 잃는다.</li><li>모든 코어가 메모리를 일관되게 보기위한 지연시간이 진짜 비용</li><li>가상머신의 코드최적화를 제한하는 점도 숨은 비용</li></ul><h2 id="가변-클래스를-작성하는-경우-동기화에-대해-고려할-점">가변 클래스를 작성하는 경우 동기화에 대해 고려할 점</h2><ol><li>동기화를 전혀 하지 말고 가변 클래스를 동시에 사용해야하는 클래스가 외부에서 동기화하자</li><li>동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.<br>(단 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 두번째 방법을 쓴다)</li></ol><h1 id="정리">정리</h1><ul><li>기본 규칙은 동기화 영역에서 가능한 한 일을 적게하는 것이다.<br>(락을 얻고 공유 데이터를 검사하고, 필요하면 수정하고, 락을 놓는다.)</li><li>오래 걸리는 작업이라면 동기화 영역 밖으로 옮기는 방법을 찾아보자.</li><li>여러 스레드가 호출할 가능성이 있는 메서드가 정적 필드를 수정한다면 그 필드를 사용하기 전에 반드시 동기화 해야 한다.</li><li>교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자</li><li>동기화 영역 안에서 작업은 최소한으로 줄이자</li><li>가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자</li><li>지금은 과도한 동기화를 피하는게 제일 중요하다</li><li>합당한 이유가 있을때만 내부에서 동기화하고 동기화 여부를 문서에 남기자.<br>(웬만하면 외부에서 동기화를 하자)</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 79. 과도한 동기화는 피하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/12/effective-java-item79/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 78. 공유 중인 가변 데이터는 동기화해 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/09/effective-java-item78/</link>
      <guid>https://jaehun2841.github.io/2019/03/09/effective-java-item78/</guid>
      <pubDate>Sat, 09 Mar 2019 07:02:45 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;싱글 스레드 기반의 프로그램에서는 하나의 스레드가 하나의 객체를 사용하면 되기 때문에 동기화에 대한 걱정을 하지 않아도 되지만,&lt;br&gt;
멀티 스레드 기반의 환경에서는 여러개의 스레드가 하나의 객체를 공유해서 사
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>싱글 스레드 기반의 프로그램에서는 하나의 스레드가 하나의 객체를 사용하면 되기 때문에 동기화에 대한 걱정을 하지 않아도 되지만,<br>멀티 스레드 기반의 환경에서는 여러개의 스레드가 하나의 객체를 공유해서 사용하는 경우가 있다.<br>하나의 객체를 공유하며 사용하는 경우 불변 객체에 대해서는 동기화를 걱정할 필요가 없지만,<br>스레드가 메서드를 실행하면서 변수의 데이터를 변경하는 경우 다른 스레드에서 동기화되지 않은 데이터를 읽을 수 있다.<br>이런 경우에는 프로그래머가 기대한 결과와는 다른 결과를 초래할 수 있기 때문에 주의해야 한다.</p><h1 id="동기화란">동기화란?</h1><p>동기화(Syncronized)란 멀티스레드 환경에서 하나의 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장하는 것을 의미한다.</p><h2 id="동기화의-특징">동기화의 특징</h2><ul><li>한 객체가 일관된 상태를 가지고 생성되었을 때, 이 객체에 접근하는 메서드는 그 객체에 Lock을 건다.<br>(다른 스레드가 메서드를 실행할 때 실행되지 못하도록 Lock을 건다)</li><li>Lock을 건 메서드는 객체의 상태를 확인하거나 필요하면 수정한다.</li><li>즉 일관된 하나의 상태 -&gt; 다른 일관된 하나의 상태로 변화한다.</li><li>메서드 실행이 끝나면 Lock을 해제한다.</li><li>동기화를 제대로 사용하면 어떤 메서드도 이 객체의 상태가 일관되지 않은 순간을 볼 수 없다.</li><li><strong>동기화 없이는</strong> 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.<br>(동기화가 없다면, 너도나도 접근하는데 시점에 따라 일관된 상태가 아닐 수도 있기 때문)</li><li>언어 명세상 long과 double 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이다.<br>(여러 스레드가 하나의 변수에 동기화 없이 접근해도 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장)</li><li>성능을 높이려면 원자적 데이터를 읽고 쓸 때는 동기화 하지 말아야겠다 <strong>(위험한 발상)</strong><br>(필드를 읽을 때 항상 <strong>수정이 완전히 반영된 값</strong> 을 얻지만, <strong>한 스레드가 저장한 값이 다른 스레드에도 보이는가?</strong> 는 보장하지 않음)</li></ul><h1 id="java에서의-가변-데이터-동기화-방법">Java에서의 가변 데이터 동기화 방법</h1><p>Java에서는 <strong>synchronized</strong> 키워드를 통해 동기화 처리를 할 수 있다.</p><ul><li>가변데이터를 수정하거나 읽는 메서드를 동기화</li><li>가변 객체에 대한 동기화</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">countup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(list) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="한-스레드가-저장한-값이-다른-스레드에도-보이는가">한 스레드가 저장한 값이 다른 스레드에도 보이는가?</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread backgroundThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위의 코드는 대충 보면 1초뒤에 <code>stopRequested</code> 필드가 false로 바뀌면서 스레드 내의 while문이 종료될 것 처럼 보인다.</li><li>하지만 무한루프!!!</li><li>원인은 동기화에 있다.</li><li>동기화하지 않으면 메인 스레드에서 수정한 <code>stopRequested</code> 필드가 언제 false로 보일지 모른다.<br>(맨 마지막에 stopRequested가 false가 되면서 실제 원잣값은 false가 된다)</li><li>위의 문제를 해결하기 위해서는 <code>stopRequested</code> 필드에 대한 동기화 처리가 필요하다</li></ul><h2 id="동기화가-빠지는-경우-jvm에서-최적화를-수행할-수도-있다">동기화가 빠지는 경우 JVM에서 최적화를 수행할 수도 있다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//원래 코드</span></span><br><span class="line"><span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 최적화한 코드</span></span><br><span class="line"><span class="keyword">if</span>(!stopRequested) &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>JVM의 호이스팅 기법을 통해 최적화 할 수 있다.</li><li>이 결과 프로그램은 응답 불가 상태가 되어 더 이상 진전이 없다.</li></ul><h1 id="위의-코드를-동기화-해보자">위의 코드를 동기화 해보자</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">requestStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stopRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">stopRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stopRequested;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread backgroundThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested()) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위와 같이 <strong>stopRequested</strong> 필드의 읽기/쓰기에 대한 동기화처리를 하면 위의 프로그램이 1초뒤에 종료된다.</li><li>읽기/쓰기 메서드 모두 동기화 처리를 하였음에 주목하자</li><li>쓰기 메서드만 동기화처리를 하고 읽기 메서드에는 동기화처리를 하지 않으면 동작을 보장할 수 없다.</li></ul><h1 id="volatile-키워드">volatile 키워드</h1><p>volatile 키워드의 의미는 <code>volatile 변수를 읽어 들일 때 CPU 캐시가 아니라 컴퓨터의 메인 메모리로 부터 읽어들인다.</code><br>즉 read 할 때도 CPU 캐시가 아닌 메인메모리에서 read하고, write할 때도 메인 메모리에 write를 수행</p><p><img src="./java-volatile.png" alt="java-volatile"></p><p>long, double을 제외한 기본타입은 <strong>volitile</strong> 키워드를 사용하면 동기화를 생략해도 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread backgroundThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>volitile 예약어는 배타적 수행(한 블록을 한 스레드가 실행) 하는것과는 관계없다</li><li>volatile 변수는 CPU캐시에서 값을 읽는게 아닌 메인 메모리에서 읽기 때문에 항상 최근에 기록된 값을 읽는다.<br>(그렇기 때문에 위의 프로그램이 1초 뒤에 종료됨)</li></ul><h1 id="volatile-사용-시-주의할-점">volatile 사용 시 주의할 점</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> nextSerialNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">generateSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 메서드는 호출 될 때 마다 1씩 증가하여 스레드에서 고유한 값을 반환할 의도로 만들어 졌다.</li><li>겉보기에는 int이기 때문에 원자적으로 접근할 수 있을 것 같다</li><li>Volatile 키워드가 쓰여져있기 때문에 최신 값을 읽을 수 있을 것 같지만 제대로 된 고유한 값이 나오지 않는다.</li></ul><h2 id="원인은-nextserialnumber">원인은 nextSerialNumber++</h2><p>원인은 nextSerialNumber++에 있었다.<br>실제 이 코드는 1줄이지만 풀어쓰면 nextSerialNumber = nextSerialNumber + 1; 와 같은 형태이다.<br>결국 nextSerialNumber 값을 한번 읽어와 +1 한다음에 다시 nextSerialNumber 변수에 저장하는 형태이다.<br>만약 두번째 스레드가 nextSerialNumber + 1 연산이 이루어지는 시점을 비집고 들어온다면 1이 두번 리턴되는 형국이다.<br>이런 오류를 <strong>안전 실패(safety failure)</strong> 이라고 한다.</p><h2 id="문제-해결은-synchronized">문제 해결은 synchronized</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> nextSerialNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">generateSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 generateSerialNumber 메서드에 synchronized만 붙여주면 문제는 해결된다.<br>동시에 호출해도 배타적으로 실행 (한번에 한 스레드만 실행) 되기 때문이다.<br>만약 위 처럼 generateSerialNumber 메서드에 synchronized를 붙였다면 nextSerialNumber 변수에는 volatile을 제거해야 한다.<br>만약 메서드를 더 견고하게 하려면 int 대신 long을 사용하는게 더 많은 수를 사용할 수 있다.</p><h1 id="long-double을-사용할-때는-더욱-더-주의하자">long, double을 사용할 때는 더욱 더 주의하자</h1><ul><li>Java.util.concurrent.atomic 패키지의 AtomicLong, AtomicDouble을 사용하는 것이 좋다.</li><li>이 패키지는 락 없이도(lock-free) 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨 있다.</li><li>volatile은 동기화 속성 중 통신에 대해서만 보장</li><li>Java.util.concurrent.atomic 패키지는 원자성(배타적 실행) 까지 지원한다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextSerialNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">generateSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNum.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="정리">정리</h1><ul><li>동기화에 대한 문제를 피하는 가장 좋은 방법은 가변 데이터를 공유하지 않는 것이다.</li><li>가변데이터는 단일 스레드에서만 사용하는 것이 좋다</li><li>가변데이터를 단일 스레드에서만 사용한다면 문서에 남겨 유지보수 정책에서도 지켜지는것이 중요하다</li><li>멀티 스레드 환경에서 한 스레드가 데이터를 수정한 후에 다른 스레드에 공유할 때는 해당 객체에서 공유하는 부분만 동기화해도 된다.</li><li>클래스 초기화 과정에서 객체를 정적필드, volatile필드, final 필드, 혹은 보통의 락을 통해 접근하는 필드에 저장해도 된다.</li><li>여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 메서드 모두에 반드시 synchronized 키워드를 붙인다.</li><li>배타적 실행 (한번에 한스레드) 동작이 필요없고, 스레드 간 최신데이터만 읽는 거로도 충분하면 가변 변수에 volatile 키워드만으로도 동기화가 가능하다</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 78. 공유 중인 가변 데이터는 동기화해 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/09/effective-java-item78/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 68. 일반적으로 통용되는 명명 규칙을 따르라</title>
      <link>https://jaehun2841.github.io/2019/03/03/effective-java-item68/</link>
      <guid>https://jaehun2841.github.io/2019/03/03/effective-java-item68/</guid>
      <pubDate>Sun, 03 Mar 2019 10:12:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바 플랫폼은 명명 규칙이 잘 정립되어 있으며, 그중 많은 것이 자바 언어 명세에 기술되어 있다.&lt;br&gt;
자바의 명명 규칙은 철자와 문법 두 범주로 나뉜다.&lt;br&gt;
철자 규칙은 패키지, 클래스, 인터페이스, 메
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바 플랫폼은 명명 규칙이 잘 정립되어 있으며, 그중 많은 것이 자바 언어 명세에 기술되어 있다.<br>자바의 명명 규칙은 철자와 문법 두 범주로 나뉜다.<br>철자 규칙은 패키지, 클래스, 인터페이스, 메서드, 필드, 타입 변수의 이름을 다룬다.<br>이 규칙들은 특별한 이유가 없는 한 반드시 따르는게 좋고 이를 어기면 다른 프로그래머들이 그 코드를 읽기 번거로울 뿐 아니라 다른뜻으로 오해할 수도 있고 그로 인해 장애로 발전할 수 있다.</p><h1 id="명명-규칙">명명 규칙</h1><h2 id="패키지-package">패키지 (Package)</h2><ul><li>패키지 (Package)와 모듈 이름은 각 요소를 **점(.)**으로 구분하여 계층적으로 짓는다.</li><li>요소들은 모두 소문자 알파벳 혹은 숫자로 이뤄진다.</li><li>com.google, kr.co.edu와 같은 식이다.</li><li>패키지를 설명하는 하나이상의 요소로 이루어져 있다.</li><li>일반적으로 8자 이하의 짧은 단어로 한다.</li><li>utilities보다는 util처럼 의미가 통하는 약어가 좋다.</li><li>요소의 이름은 보통 한 단어 혹은 약어로 이루어진다.</li><li>많은 기능을 제공하는 애플리케이션의 경우에는 계층을 더 많은 요소로 나누는 것이 좋다.</li></ul><h2 id="클래스-인터페이스-열거타입">클래스, 인터페이스, 열거타입</h2><ul><li>클래스 명은 하나이상의 단어로 구성되며, 첫글자는 대문자로 작성한다.</li><li>여러 단어의 첫글자만 딴 약자나 널리 통용되는 줄임말을 제외하고는 줄임말을 쓰지 않도록 한다.</li><li>조합한 단어를 구분할 수 있게 <strong>camel case</strong>로 작성한다.</li></ul><h2 id="메서드-필드명">메서드, 필드명</h2><ul><li>첫 글자를 소문자로 작성하고 클래스 명과 같게 단어 별로 <strong>camel case</strong>로 작성한다.</li><li>첫 단어가 약자라면 단어 전체가 소문자여야 한다.</li><li>상수 필드는 예외다. 상수 필드를 구성하는 단어는 모두 대문자로 쓰며 단어 사이는 언더바(_)로 구분한다.<br>(VALUES, NEGATIVE_INFINITY등..)</li><li>상수 필드는 static final인 타입을 의미한다.</li><li>가르키는 객체가 불변이라면, 그 타입은 가변이어도 상수이다.</li><li>지역번수에도 동일한 규칙이 적용된다. 단, 문맥에서 의미를 쉽게 유추할 수 있는 경우에는 <strong>약어를 사용해도 좋다.</strong><br>(i, denom, houseNum등..)</li><li>타입 매개변수의 이름은 한 글자로 표현한다.<ul><li>T: 임의의 타입 (Type)</li><li>E: 컬렉션의 원소 (Element)</li><li>K: 맵의 키 (Key)</li><li>V: 맵의 값 (Value)</li><li>X: 예외 (eXception)</li><li>R: 메서드의 반환타입 (Return)</li><li>그 이외의 타입에는 T, U, V 혹은 T1, T2, T3의 식으로 사용</li></ul></li></ul><h1 id="명명-규칙2">명명 규칙2</h1><ul><li>객체를 생성하는 클래스나 열거타입 인터페이스는 <strong>단수 명사나 명사구를 사용한다.</strong><ul><li>Thread, PriorityQueue, ChessPiece 등..</li></ul></li><li>객체를 생성할 수 없는 클래스 (Utils 클래스)에는 보통 <strong>복수형 명사로 짓는다.</strong><ul><li>Collectors, Collections 등..</li></ul></li><li>인터페이스 이름은 클래스명과 동일하게 짓거나, <strong>ible, able로 끝나는 형용사로 짓는다.</strong><ul><li>Runnable, Iterable, Accessible 등...</li></ul></li><li>애너테이션은 워낙 다양하게 활용되어 지배적인 규칙이 없이 명사, 형용사, 동사, 전치사가 두루 쓰인다.<ul><li>@Binding, @Inject, @ImplementsBy, @Singleton 등..</li></ul></li><li>메서드의 이름은 동사나 목적어를 포함한 <strong>동사구로 짓는다.</strong><ul><li>append, drawImage</li></ul></li><li>boolean 값을 반환하는 메서드라면 <strong>is~, has~로 짓는다.</strong><ul><li>isDigit, isEmpty, hasSiblings 등..</li></ul></li><li>반환타입이 boolean이 아닌경우 보통 명사, 명사구, get~로 짓는다.<ul><li>size, hashcode, getTime 등...</li><li>get으로 시작하는 형태는 주로 자바빈즈(JavaBeans) 명세에 뿌리를 두고 있다.</li><li>보통 getter/setter의 한 묶음 형태로 만드는 경우가 많다.</li></ul></li><li>반환타입을 또다른 타입을 반환하는 경우에는<strong>toType</strong> 의 형태로 짓는다.<ul><li>toString, toArray 등..</li></ul></li><li>객체의 내용을 다른 뷰로 보여주는 메서드는 <strong>asType</strong> 의 형태로 짓는다.<ul><li>asList, asMap 등..</li></ul></li><li>객체의 값을 기본 타입(primitive type)으로 반환하는 경우에는 <strong>typeValue</strong> 의 형태로 짓는다.<ul><li>intValue, longValue 등...</li></ul></li><li>정적 팩터리의 이름은 다양하다<ul><li>from, valueOf, getInstance, newInstance 등..</li></ul></li></ul><h1 id="정리">정리</h1><ul><li>표준 명명 규칙을 체득하여 자연스럽게 사용하도록 연습하자</li><li>철자 규칙은 직관적이라 모호한 부분이 적지만, 문법 규칙은 더 복잡하고 느슨하다</li><li>오랫동안 따라온 규칙과 충돌한다면 그 규칙을 맹종해서는 안된다. 상식대로 가자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 68. 일반적으로 통용되는 명명 규칙을 따르라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/03/effective-java-item68/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 67. 최적화는 신중히 하라</title>
      <link>https://jaehun2841.github.io/2019/03/03/effective-java-item67/</link>
      <guid>https://jaehun2841.github.io/2019/03/03/effective-java-item67/</guid>
      <pubDate>Sun, 03 Mar 2019 09:49:08 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;최적화에-대한-명언&quot;&gt;최적화에 대한 명언&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;맹목적인 어리석음을 포함해 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다 (심지어 효율을 높이지도 못하면서)&lt;/p&gt;
&lt;p&gt;- 윌리엄 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="최적화에-대한-명언">최적화에 대한 명언</h1><blockquote><p>맹목적인 어리석음을 포함해 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다 (심지어 효율을 높이지도 못하면서)</p><p>- 윌리엄 울프(Wulf72)</p></blockquote><blockquote><p>(전체의 97% 정도인) 자그마한 효율성은 모두 잊자. 섣부른 최적화가 만약의 근원이다. - 도널드 크누스(Knuth74)</p></blockquote><blockquote><p>최적화를 할 때는 다음 두 규칙을 따르라.</p><p>첫 번째, 하지마라.<br>두 번째, (전문가 한정) 아직 하지 마라. 다시 말해, 완전히 명백하고 최적화되지 않은 해법을 찾을 때까지는 하지 마라.<br>- M.A 잭슨 (Jackson75)</p></blockquote><p>위의 명언들을 풀어보면,<br>최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고 섣불리 진행하면 특히 더 그렇다.<br>빠르지도 않고 제대로 동작하지도 않으면서 수정하기는 어려운 소프트웨어를 탄생시키는 것이다.</p><h1 id="프로그램을-설계할-때-생각해야-할-점">프로그램을 설계할 때 생각해야 할 점</h1><h2 id="빠른-프로그램보다는-좋은-프로그램을-작성하자">빠른 프로그램보다는 좋은 프로그램을 작성하자</h2><ul><li>좋은 프로그램이지만 원하는 성능이 나오지 않는다면 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것이다.</li><li>좋은 프로그램은 정보 은닉(캡슐화) 원칙을 따르므로 개별 구성요소 내부를 독립적으로 설계할 수 있다.</li><li>따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다.</li><li>구현상의 문제는 나중에 최적화 할 수 있지만, 아키텍처의 결함이 성능을 제한한다면 시스템을 다시 작성해야 하기 때문이다.</li><li>따라서 설계 단계에서 성능을 반드시 염두하자</li></ul><h2 id="성능을-제한하는-설계를-피하라">성능을 제한하는 설계를 피하라</h2><ul><li>완성 후 변경하기가 가장 어려운 설계 요소는 컴포넌트끼리 또는 외부 시스템과의 소통 방식이다.</li><li>API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등이 있다.</li><li>완성후에는 변경하기 어렵거나 불가능 하고, 동시에 시스템 성능을 제한할 수 있다.</li></ul><h2 id="api를-설계할-때-성능에-주는-영향을-고려하라">API를 설계할 때 성능에 주는 영향을 고려하라</h2><ul><li>가변 객체를 사용하여 내부데이터를 변경할 수 있게 만들면 불필요한 방어적 복사를 유발할 수 있다.</li><li>컴포지션으로 해결할 수 있는 경우에도 상속을 이용하면 상위클래스에 영원히 종속되고, 성능 제약까지 물려받는다</li><li>인터페이스도 있는데 굳이 클래스 타입으로 사용하면, 차후 개선된 구현체를 사용하기 어려워진다.</li></ul><h2 id="성능을-위해-api를-왜곡하지-말자">성능을 위해 API를 왜곡하지 말자</h2><ul><li>API를 왜곡하도록 만든 성능 문제는 해당 플랫폼이나 아랫단 소프트웨어의 다음 버전에서 사라질 수 있다.</li><li>왜곡된 API를 지원하는 데 따르는 고통은 영원하다</li></ul><h2 id="프로파일링-도구를-적극-활용하자">프로파일링 도구를 적극 활용하자</h2><ul><li>프로파일링 도구는 최적화 노력을 어디에 집중해야 할지 찾는 데 도움을 준다.</li><li>개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 제공하여 개발자의 수고를 덜어준다.</li><li>JMH도 알아야 하는 도구이다.  프로파일러는 아니지만 자바 코드의 상세한 성능을 알기 쉽게 보여주는 마이크로 벤치마킹 프레임워크다.</li></ul><h1 id="정리">정리</h1><ul><li>빠른프로그램을 작성하려 하지 말고 좋은 프로그램을 작성하려 노력하자. 성능은 따라오기 마련이다.</li><li>시스템을 설계할 때 API, 네트워크 프로토코르 영구 저장용 데이터 포맷을 설계할 때는 성능을 염두하자</li><li>시스템 구현을 완료했으면 측정해보고 충분히 빠르면 최적화를 하지 마라</li><li>성능 측정 시에는 프로파일링 도구를 이용해 문제의 원인이 되는 지점을 찾아 최적화하자</li><li>알고리즘을 잘못 골랐다면, 저수준 최적화는 의미가 없다.</li><li>만족할 만한 성능이 나올 때까지 위의 과정을 반복하고, 변경 후에는 성능 측정을 꼭하자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 67. 최적화는 신중히 하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/03/effective-java-item67/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 66. 네이티브 메서드는 신중히 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/03/effective-java-item66/</link>
      <guid>https://jaehun2841.github.io/2019/03/03/effective-java-item66/</guid>
      <pubDate>Sun, 03 Mar 2019 09:09:15 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바 네이티브 인터페이스(Java Native Interface, JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;네이티브 메서드란?&lt;/p&gt;
&lt;p&gt;C나 C++
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바 네이티브 인터페이스(Java Native Interface, JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다.</p><blockquote><p>네이티브 메서드란?</p><p>C나 C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다.</p></blockquote><h1 id="네이티브-메서드의-주요-쓰임">네이티브 메서드의 주요 쓰임</h1><ul><li>Registry 같은 플랫폼 특화기능을 사용한다.<ul><li>하지만 자바가 진화해가면서 하부 플랫폼의 기능을 흡수하고 있다.</li><li>네이티브 메서드를 사용해야하는 일이 줄어들고 있다.</li><li>자바9 부터는 process API를 추가해 OS에 접근하는 길을 열어주었다.</li></ul></li><li>네이티브 코드로 작성된 기존 라이브러리를 사용해야 하는 경우<ul><li>레거시 데이터를 사용하는 레거시 라이브러리</li><li>Java로 된 라이브러리가 없는 경우 네이티브 라이브러리를 사용한다.</li></ul></li><li>성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.</li></ul><h1 id="네이티브-메서드를-성능개선의-목적으로-사용하지-말라">네이티브 메서드를 성능개선의 목적으로 사용하지 말라</h1><ul><li>자바 초기 시절 (Java 1.3)이전이라면 다른 얘기지만, 그동안 JVM은 빠른 속도로 발전해 왔다.</li><li>대부분의 작업에서 Java는 다른 플랫폼과 견줄만한 성능을 보인다 (자바가 느리다는 것도 옛말)</li><li>네이티브 라이브러리 쪽은 GNU 다중 정밀 연산 라이브러리(GMP)를 필두로 개선 작업이 계속돼왔다.<br>고성능의 다중 정밀 연산이 필요한 경우에는 네이티브 메서드를 통해 GMP를 사용하는것을 고려해보자</li></ul><h1 id="네이티브-메서드의-단점">네이티브 메서드의 단점</h1><ul><li>네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로 부터 안전하지 않다.</li><li>네이티브 언어는 플랫폼 종속성이 있으므로 이식성이 좋지 못하다</li><li>디버깅도 어렵다</li><li>오히려 속도가 더 느릴 수 있다.</li><li>JVM의 가비지 컬렉터는 네이티브 메모리는 자동 회수 하지 못하고 추적도 할 수 없다.</li><li>자바 코드와 네이티브 코드의 경계를 넘나 들때마다 비용이 발생한다.</li><li>자바 코드와 네이티브 코드간의 접착 코드(glue code)를 작성해야 하는데 이 부분도 귀찮고 가독성도 떨어진다.</li></ul><h1 id="정리">정리</h1><ul><li><p>네이티브 메서드를 사용하는 경우는 한번 더 생각하라</p></li><li><p>네이티브 메서드가 그렇게 성능 향상에 도움을 주지는 않는다.</p></li><li><p>네이티브 메서드를 사용해야 하는 경우에는 최소한으로 사용하고 철저한 테스트를 해야한다.</p></li><li><p>숨은 버그하나가 애플리케이션 전체에 영향을 줄 수도 있다.</p></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 66. 네이티브 메서드는 신중히 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/03/effective-java-item66/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 65. 리플렉션보다는 인터페이스를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/03/effective-java-item65/</link>
      <guid>https://jaehun2841.github.io/2019/03/03/effective-java-item65/</guid>
      <pubDate>Sun, 03 Mar 2019 07:57:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;리플렉션 기능(java.lang.reflect)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.&lt;br&gt;
Class 객체가 주어지면 클래스 정보를 통해 아래와 같은 인스턴스를 가져올 수 있다.&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>리플렉션 기능(java.lang.reflect)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.<br>Class 객체가 주어지면 클래스 정보를 통해 아래와 같은 인스턴스를 가져올 수 있다.</p><ul><li>Constructor<ul><li>생성자 시그니처를 가져올 수 있다.</li><li>생성자 인스턴스를 통해 객체를 생성할 수 있다.</li></ul></li><li>Method<ul><li>Method 시그니처를 가져올 수 있다.</li><li>Method 인스턴스를 통해 Method를 실행시킬 수 있다. (Method.invoke)</li></ul></li><li>Field<ul><li>필드타입, 멤버필드 이름등을 가져올 수 있다.</li></ul></li></ul><h1 id="리플렉션의-단점">리플렉션의 단점</h1><p>리플렉션을 이용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있다.<br>(예를들면.. 외부 라이브러리의 클래스를 리플렉션으로 인스턴스를 생성한다든지…)</p><h2 id="컴파일타임-타입-검사가-주는-이점을-누릴-수-없다">컴파일타임 타입 검사가 주는 이점을 누릴 수 없다.</h2><ul><li>예외 검사, 컴파일 타임 에러를 잡아낼 수 없다.</li><li>프로그램이 리플렉션 기능을 써서 존재하지 않는 혹은 접근 불가능한 (private 메서드)를 호출하려 하면 런타임 오류가 발생한다.</li></ul><h2 id="리플렉션을-이용하면-코드가-지저분하고-장황해진다">리플렉션을 이용하면 코드가 지저분하고 장황해진다.</h2><ul><li>지루한 일이고 읽기도 어렵다.</li></ul><h2 id="성능이-떨어진다">성능이 떨어진다.</h2><ul><li>리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느리다.</li><li>고려해야 하는 요소가 많아 정확한 차이는 이야기하기 어렵다</li><li>하지만 분명 느리다.</li></ul><h2 id="리플렉션은-아주-제한된-형태로만-사용해야-그-단점을-피할-수-있다">리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피할 수 있다</h2><ul><li>컴파일타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램은 비록 컴파일타임이라도 적절한 인터페이스나 상위 클래스를 이용할 수는 있을것이다.</li><li>리플렉션은 인스턴스 생성에만 쓰고 이렇게 만든 인터페이스나 상위 클래스로 참조해 사용하자</li></ul><h1 id="리플렉션의-취약한-예">리플렉션의 취약한 예</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 클래스 이름을 Class 객체로 변환</span></span><br><span class="line">    Class&lt;? extends Set&lt;String&gt;&gt; cl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = (Class&lt;? extends Set&lt;String&gt;&gt;) Class.forName(args[<span class="number">0</span>]); <span class="comment">//비검사 형변환</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"클래스를 찾을 수 없습니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생성자를 얻는다.</span></span><br><span class="line">    Constructor&lt;? extends Set&lt;String&gt;&gt; cons = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cons = cl.getDeclaredConstructor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"매개변수 없는 생성자를 찾을 수 없습니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//집합의 인스턴스를 만든다.</span></span><br><span class="line">    Set&lt;String&gt; s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        s = cons.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"생성자에 접근할 수 없습니다."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"클래스를 인스턴스화할 수 없습니다."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"생성자가 예외를 던졌습니다: "</span> + e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        fatalError(<span class="string">"Set을 구현하지 않은 클래스입니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//생성한 집합을 사용한다.</span></span><br><span class="line">    s.addAll(Arrays.asList(args).subList(<span class="number">1</span>, args.length));</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fatalError</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.err.println(msg);</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 예시는 리플렉션의 단점을 보여준다.</p><ul><li>런타임에 총 6가지의 예외를 던질 수 있다.</li><li>위에서 발생하는 예외는 모두 컴파일타임에 체크할 수 있는 예외들이다.</li><li>클래스 이름만으로 인스턴스를 생성해내기 위해 무려 25줄이나 되는 코드를 작성했지만, 그게 아닌 경우에는 생성자 1줄이면 끝난다.</li><li>리플렉션 예외를 각각 잡는 대신 상위 클래스인 ReflectiveOperationException을 잡으면 코드량을 줄일 수 있다.<br>(ReflectiveOperationException은 Java 7부터 지원한다.)</li></ul><h1 id="리플렉션은-무조건-쓰지-말아야-한다">리플렉션은 무조건 쓰지 말아야 한다?</h1><ul><li>Spring MVC, Serialize/Deserialize, BeanUtils.copyProperties등 실무에서 사용하는 코드에 리플렉션이 적용된 예는 굉장히 많다.</li><li>단점이 많다고는 하지만 공통적인 기능을 설계하거나, 재사용 가능한 코드를 설계할 경우에는 오히려 리플렉션이 적합할 수 있다.</li><li>그렇기 때문에 Java 1.3 이후부터 리플렉션에 대한 성능향상을 발전시켜왔다고 한다.</li><li>이러한 발전으로 리플렉션은 우려할 만큼 성능이 떨어지지는 않는다고 한다.</li><li>리플렉션을 남발하는 것이 아닌 필요한 상황에 적시적소에 사용한다면 오히려 서비스 개발을 더 단순화 시킬수 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 65. 리플렉션보다는 인터페이스를 사용하라</li><li><a href="https://kmongcom.wordpress.com/2014/03/15/%EC%9E%90%EB%B0%94-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%A4%ED%95%B4%EC%99%80-%EC%A7%84%EC%8B%A4/" target="_blank" rel="noopener">Java 리플렉션의 오해와 진실</a></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/03/effective-java-item65/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 64. 객체는 인터페이스를 사용해 참조하라</title>
      <link>https://jaehun2841.github.io/2019/03/01/effective-java-item64/</link>
      <guid>https://jaehun2841.github.io/2019/03/01/effective-java-item64/</guid>
      <pubDate>Fri, 01 Mar 2019 12:33:55 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Item 51에 제네릭 타입으로 클래스가 아니라 인터페이스를 사용하라고 설명 되어있다.&lt;br&gt;
이 말의 의미는 &lt;strong&gt;객체는 클래스가 아닌 인터페이스로 참조하라&lt;/strong&gt; 라는 의미로 확장할 수 있
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Item 51에 제네릭 타입으로 클래스가 아니라 인터페이스를 사용하라고 설명 되어있다.<br>이 말의 의미는 <strong>객체는 클래스가 아닌 인터페이스로 참조하라</strong> 라는 의미로 확장할 수 있다.<br>적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언해야 한다.</p><h1 id="유연한-프로그램을-생성하는-인터페이스-타입-변수">유연한 프로그램을 생성하는 인터페이스 타입 변수</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//좋은 예</span></span><br><span class="line">Set&lt;Son&gt; sonSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//나쁜 예</span></span><br><span class="line">LinkedHashSet&lt;Son&gt; sonSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br></pre></td></tr></table></figure></p><ul><li>좋은 예는 Set 인터페이스 타입으로 변수를 선언하였다.</li><li>나쁜 예는 LinkedHashSet 타입으로 변수를 선언하였다.</li></ul><p>만약 LinkedHashSet을 TreeSet으로 변환해야 한다면 어떨까?</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//좋은 예</span></span><br><span class="line">Set&lt;Son&gt; sonSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//나쁜 예</span></span><br><span class="line">LinkedHashSet&lt;Son&gt; sonSet = <span class="keyword">new</span> TreeSet&lt;&gt;(); <span class="comment">//컴파일 에러!</span></span><br></pre></td></tr></table></figure></p><ul><li>위의 좋은 예는 Set 인터페이스 타입이기 때문에 컴파일 타임/런타임에 전혀 문제가 되지 않는다.</li><li>나쁜 예는 LinkedHashSet 타입이기 때문에 TreeSet을 LinkedHashSet로 형변환 할 수 없다고 에러가 발생한다.</li></ul><h1 id="인터페이스-타입의-장점">인터페이스 타입의 장점</h1><ul><li>인터페이스 타입을 사용하면 클라이언트 코드를 수정하지 않고도 참조 객체를 변경할 수 있다.</li><li>다른 타입의 객체를 사용하더라도 컴파일에러/런타임에러에 대한 걱정을 하지 않아도 된다.</li></ul><h1 id="인터페이스-타입의-단점">인터페이스 타입의 단점</h1><ul><li>인터페이스 타입에 선언된 메서드를 구현한 메서드만 사용이 가능하다.</li><li>특정 구현체의 내부 메서드를 사용할 수 없다.</li></ul><h1 id="클래스를-참조해야-하는-경우">클래스를 참조해야 하는 경우</h1><h2 id="값-타입에는-클래스를-참조하라">값 타입에는 클래스를 참조하라</h2><ul><li>String, Integer, Long과 같이 값 타입에 대해서는 인터페이스를 사용할 수 없으니 클래스를 참조해야 한다.</li><li>또한 Integer, Long과 같은 타입을 사용할 때는 Number와 같은 상위 타입을 사용하지 말아야 한다.<br><strong>형변환이 발생 할 때 특정 데이터가 절삭되어 다른 결과가 발생 할 수 있기 때문이다.</strong></li><li>이런 경우에는 인터페이스나 상위타입 보다는 본래의 클래스로 참조하는 것이 좋다.</li></ul><h2 id="인터페이스에는-없는-메서드를-사용할-때에는-클래스를-참조해라">인터페이스에는 없는 메서드를 사용할 때에는 클래스를 참조해라</h2><ul><li>PriorityQueue 클래스에는 Queue 인터페이스에는 없는 comparator 메서드를 제공한다.</li><li>클래스 타입을 직접 사용하는 경우에는 추가 메서드를 사용해야 하는 경우로 최소화 하는 것이 좋다.</li></ul><h1 id="정리">정리</h1><ul><li>인터페이스나 추상클래스를 구현하는 클래스를 사용할 때는 참조 변수를 인터페이스나 추상클래스로 사용하자</li><li>인터페이스나 추상클래스 타입으로 참조 변수를 사용하면 참조 객체를 바꿔도 안전하다</li><li>값 타입을 사용하는 경우에는 클래스 타입의 참조변수를 사용해야 한다.</li><li>인터페이스에는 없는 메서드를 사용할 때는 클래스 타입의 참조변수를 사용해야 한다.</li><li>적합한 인터페이스가 없다면 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 상위 타입을 사용해야 한다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 64. 객체는 인터페이스를 사용해 참조하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/01/effective-java-item64/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 63. 문자열 연결은 느리니 주의하라</title>
      <link>https://jaehun2841.github.io/2019/03/01/effective-java-item63/</link>
      <guid>https://jaehun2841.github.io/2019/03/01/effective-java-item63/</guid>
      <pubDate>Fri, 01 Mar 2019 11:45:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;문자열 연결 연산자(+)는 여러 문자열을 하나로 합쳐주는 편리한 수단이다.&lt;br&gt;
그런데 한 줄짜리 출력값(&lt;code&gt;return prefix + str + suffix;&lt;/code&gt; 정도?)  혹은 작고 크기
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>문자열 연결 연산자(+)는 여러 문자열을 하나로 합쳐주는 편리한 수단이다.<br>그런데 한 줄짜리 출력값(<code>return prefix + str + suffix;</code> 정도?)  혹은 작고 크기가 고정된 객체의 문자열 표현을 만들 때라면 괜찮다.<br>하지만 문자열 여러개를 사용하기 시작하면 성능 저하를 피할 수 없다.</p><p><strong>문자열 연결 연산자로 문자열 n개를 연결하는 시간은 n^2에 비례한다.</strong><br>문자열은 불변이기 때문에 두 문자열을 연결하는 경우에는 양쪽의 내용을 복사하여 연결한 다음 새로운 String 객체를 만들어야 하기 때문이다.</p><h1 id="문자열-연결을-잘못-사용한-예-느리다">문자열 연결을 잘못 사용한 예 - 느리다!</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">statement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numItems(); i++) &#123;</span><br><span class="line">        result += lineForItem(i); <span class="comment">//문자열 연결</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="stringbuilder를-사용하여-문자열을-연결한-예">StringBuilder를 사용하여 문자열을 연결한 예</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">statement2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(numItems() * LINE_WIDTH);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numItems(); i++) &#123;</span><br><span class="line">       sb.append(lineForItem(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>자바 6이후 문자열 연결 성능을 다방면으로 개선 했지만, 두 메서드의 성능 차이는 여전하다.</p><h1 id="string-stringbuffer-stringbuilder의-비교">String, StringBuffer, StringBuilder의 비교</h1><ul><li>String과 StringBuffer는 Java 1.0의 등장과 함께 같이 등장하였다.</li><li>StringBuilder는 조금 뒤인 Java 1.5부터 등장하였다.</li><li>String의 concat연산은 + 기호를 사용하여 concatination을 수행한다.</li><li>StringBuffer와 StringBuilder는 append 메서드를 통해 concatination을 수행한다.</li><li>정확히 말하면 StringBuffer와 StringBuilder는 AbstractStringBuilder를 상속하고 있으며,<br>결국은 같은 append 메서드를 사용한다.</li><li>StringBuffer와 StringBuilder 차이점은 thread-safe에 있다.<ul><li>StringBuffer의 append 메서드에는 <code>syncronized</code> 예약어가 붙어있어 thread-safe하다</li><li>StringBuilder의 append 메서드는 thread-safe 하지 않다.</li><li>따라서 multi-thread 환경에서 문자열 결합을 할 때는 StringBuffer를 사용하는 것이 안전하다.</li><li>단일 thread라면 StringBuilder를 사용하는 것이 StringBuffer보다 성능이 더 좋다.<br>(아무래도 동기화 체크를 안해도 되니 말이다.)</li></ul></li></ul><h2 id="string-string-연산이-느린-이유">String + String 연산이 느린 이유</h2><ul><li>String은 불변 클래스이기 때문에 String + String을 하기 위해서는</li><li>String내의 char[] 혹은 byte[]를 copy한다.</li><li>2개의 array의 length를 더한 값으로 새로운 array를 생성한다.</li><li>array에 기존의 값을 채워넣는다.</li><li>new String(byte[]) 생성자를 통해 새로운 String 객체를 생성한다.</li><li>이런식으로 하면 String + String 연산이 일어날 때마다 String 객체가 생성된다.</li><li>Heap Memory에 String 객체가 많아지면 GC가 돌면서 String 객체를 제거한다.</li><li>GC는 동작 시 stop the world라는 행위를 한다. <strong>(JVM의 작동이 일시적으로 멈춘다.</strong>)</li><li>위와 같은 행위가 계속되면 당연히 느려 질 수 밖에 없다.</li></ul><h2 id="stringbuilderappend-메서드-파헤치기">StringBuilder.append() 메서드 파헤치기</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified string to this character sequence.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The characters of the &#123;<span class="doctag">@code</span> String&#125; argument are appended, in</span></span><br><span class="line"><span class="comment">     * order, increasing the length of this sequence by the length of the</span></span><br><span class="line"><span class="comment">     * argument. If &#123;<span class="doctag">@code</span> str&#125; is &#123;<span class="doctag">@code</span> null&#125;, then the four</span></span><br><span class="line"><span class="comment">     * characters &#123;<span class="doctag">@code</span> "null"&#125; are appended.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Let &lt;i&gt;n&lt;/i&gt; be the length of this character sequence just prior to</span></span><br><span class="line"><span class="comment">     * execution of the &#123;<span class="doctag">@code</span> append&#125; method. Then the character at</span></span><br><span class="line"><span class="comment">     * index &lt;i&gt;k&lt;/i&gt; in the new character sequence is equal to the character</span></span><br><span class="line"><span class="comment">     * at index &lt;i&gt;k&lt;/i&gt; in the old character sequence, if &lt;i&gt;k&lt;/i&gt; is less</span></span><br><span class="line"><span class="comment">     * than &lt;i&gt;n&lt;/i&gt;; otherwise, it is equal to the character at index</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;k-n&lt;/i&gt; in the argument &#123;<span class="doctag">@code</span> str&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   str   a string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a reference to this object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    putStringAt(count, str);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위의 코드는 AbstractStringBuilder의 append 메서드이다.</li><li>새로운 String의 길이 만큼 AbstractStringBuilder의 내의 byte[]의 사이즈를 늘리고 복사한다.</li><li>그 다음 String에 대한 byte[]를 AbstractStringBuilder의 내의 byte[]에 추가한다.</li><li>String + String 연산과의 차이점은 불필요한 String 객체가 발생하지 않는다는 점이다</li></ul><h1 id="string-concatination의-발전">String Concatination의 발전</h1><ul><li>Java String 연산에 대한 성능최적화를 다방면으로 생각하고 있고, Java 9 부터 String의 내부 배열을<br><strong>char[] -&gt; byte[]로 변경</strong>하여 성능을 더 향상 시켰다.</li><li>Java 1.5 버전부터 String + String연산에 대해 <strong>Compile Time에 StringBuilder를 사용하도록 코드를 변경한다.</strong><br>하지만 JDK가 항상 자동으로 바꿔준다는 보장이 없으니 String + String 보다는 StringBuilder를 사용해야 한다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 63. 문자열 연결은 느리니 주의하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/01/effective-java-item63/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 62. 다른 타입이 적절하다면 문자열 사용을 피하라</title>
      <link>https://jaehun2841.github.io/2019/03/01/effective-java-item62/</link>
      <guid>https://jaehun2841.github.io/2019/03/01/effective-java-item62/</guid>
      <pubDate>Fri, 01 Mar 2019 10:53:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;문자열(String)은 텍스트를 표현하도록 설계되었고, 그 일을 아주 멋지게 해낸다.&lt;br&gt;
그런데 문자열은 워낙 흔하고 자바가 또 잘 지원해주어 원래 의도하지 않는 용도로도 쓰이는 경향이 있다.&lt;/p&gt;
&lt;h1
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>문자열(String)은 텍스트를 표현하도록 설계되었고, 그 일을 아주 멋지게 해낸다.<br>그런데 문자열은 워낙 흔하고 자바가 또 잘 지원해주어 원래 의도하지 않는 용도로도 쓰이는 경향이 있다.</p><h1 id="문자열의-안티패턴">문자열의 안티패턴</h1><h2 id="문자열은-다른-값-타입을-대신하기에-적합하지-않다">문자열은 다른 값 타입을 대신하기에 적합하지 않다.</h2><p>많은 사람들이 파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때 주로 문자열을 이용한다.<br>하지만 <strong>입력받을 데이터가 진짜 문자열인 경우에만 문자열을 사용하는 것이 좋다.</strong><br>데이터가 수치형이면 int, long, double등 수치에 대한 타입으로 사용하는 것이 좋다.<br>질문의 답이 예/아니오라면 boolean을 사용하는것이 좋다.</p><p>일반화 하여 얘기하자면,<br><strong>기본 타입이든 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고 없다면 새로 하나 타입을 만드는 것이 좋다.</strong></p><h2 id="문자열은-열거-타입-대신하기에-적합하지-않다">문자열은 열거 타입 대신하기에 적합하지 않다.</h2><p>상수를 열거할 경우에는 문자열 열거 패턴 클래스 보다는 열거 타입(enum)이 훨씬 낫다.</p><h2 id="문자열은-혼합-타입을-대신하기에-적합하지-않다">문자열은 혼합 타입을 대신하기에 적합하지 않다.</h2><p>여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String compoundKey = className + <span class="string">"#"</span> + i.next();</span><br></pre></td></tr></table></figure></p><p>이 방식은 단점이 많다.<br>예를 들어 문자열에 # 문자열이 있는 경우 혼란스러운 결과가 발생한다.<br>각 요소를 개별적으로 접근하기 위해서는 특정 기준을 통해 문자열을 파싱해야해서 느리고, 귀찮고, 오류 가능성도 크다.</p><p>이럴바에는 <strong>차라리 전용 클래스를 새로 만들어서 각 데이터 별로 멤버 변수를 취하는 것이 좋다.</strong></p><h2 id="문자열은-권한을-표현하기에-적합하지-않다">문자열은 권한을 표현하기에 적합하지 않다.</h2><p>권한(capacity)를 문자열로 표현하는 경우가 종종 있다.</p><h3 id="잘못된-예-문자열을-사용하여-권한을-구분하였다">잘못된 예 - 문자열을 사용하여 권한을 구분하였다.</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//객체 생성 불가</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 현 스레드의 값을 키로 구분해 저장한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (키가 가르키는) 현 스레드의 값을 반환한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 방식의 문제점은 스레드 구분용 문자열 키가 global namespace에서 공유된다는 점이다.<br>이 방식이 의도대로 동작하려면 각 클라이언트가 고유한 키를 제공해야 한다.<br>만약 두 클라이언트가 서로 소통하지 못해 같은 키를 쓰기로 결정한다면, 의도치 않게 같은 변수를 공유하게 된다.<br>따라서 클라이언트는 제대로 작동하지도 않고 보안에도 취약하다.</p><p>이런 경우에는 String으로 권한을 구분하는 것이 아니라 별도의 타입을 만들어 해결해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//객체 생성 불가</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">        key() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//위조 불가능한 고유 키를 생성한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Key();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Key key, Object value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">(Key key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 방법은 앞서의 문자열 기반 API의 문제점을 해결해 주지만 개선할 부분이 있다.<br>set/get 메서드는 이제 static 메서드일 이유가 없다. 따라서 Key의 인스턴스 메서드로 변경하는 것이 좋다.<br>그렇게 하면 Key는 더 이상 스레드 지역변수를 구분하기 위한 키가 아니라 그 자체가 스레드 지역변수가 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 API는 get으로 얻은 Object를 실제 타입으로 타입 캐스팅 해야 해서 타입안전하지 않다.<br>하지만 제네릭을 사용한다면 조금 더 타입 안전하게 만들 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="정리">정리</h1><ul><li>더 적합한 데이터 티입이 있거나 새로 작성할 수 있다면, 문자열을 쓰지 말자</li><li>문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고 오류 가능성도 크다.</li><li>문자열을 잘못 사용하는 흔한 예로는 기본 타입, 열거 타입, 혼합 타입이 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 62. 다른 타입이 적절하다면 문자열 사용을 피하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/01/effective-java-item62/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/03/01/effective-jave-item61/</link>
      <guid>https://jaehun2841.github.io/2019/03/01/effective-jave-item61/</guid>
      <pubDate>Fri, 01 Mar 2019 09:27:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바의 데이터 타입은 크게 두 가지로 나눌 수 있다.&lt;br&gt;
&lt;strong&gt;기본 타입 (Primitive type) vs 참조 타입 (Reference Type)&lt;/strong&gt; 으로 구분 할 수 있다.&lt;/p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바의 데이터 타입은 크게 두 가지로 나눌 수 있다.<br><strong>기본 타입 (Primitive type) vs 참조 타입 (Reference Type)</strong> 으로 구분 할 수 있다.</p><h2 id="기본-타입-primitive-type">기본 타입 (Primitive Type)</h2><ul><li>int</li><li>long</li><li>short</li><li>double</li><li>char</li><li>boolean</li></ul><h2 id="참조-타입-reference-type">참조 타입 (Reference Type)</h2><ul><li>String</li><li>Integer</li><li>Long</li><li>Double</li><li>Boolean</li></ul><p>기본 타입에 대응되는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다.</p><h1 id="auto-boxing-vs-auto-unboxing">Auto Boxing vs Auto UnBoxing</h1><p>Java 1.5 부터 기본 타입과 래퍼 타입(Wrapper Type, 참조 타입에 대한 클래스를 래퍼 클래스라고 함)을 자동으로 변환해 주는 기능이 추가되었다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> j = i; <span class="comment">// Auto UnBoxing</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">10</span>;</span><br><span class="line">Integer l = k; <span class="comment">//Auto Boxing</span></span><br></pre></td></tr></table></figure></p><p>이 기능 때문에 개발자는 별도로 Boxing과 UnBoxing을 수행해 주지 않아도 되지만, 그렇다고 두 개가 같은 것은 아니다.<br>기본 타입과 래퍼 타입에는 차이가 있으니 어떤 타입을 사용하는지는 상당히 중요하다.</p><h1 id="기본타입-vs-참조타입">기본타입 vs 참조타입</h1><p>기본 타입과 참조 타입의 차이점은 크게 3가지이다.</p><ul><li><p>기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)란 속성을 갖는다.</p><ul><li><p>기본 타입은 흔히 말하는 리터럴(Literal)이다.</p><blockquote><p>리터럴(Literal)이란?</p><p>소스 코드의 고정된 값을 의미하는 용어이다.상수(Constants) 또는 변수(Variable)에 할당 할 수 있는 값 자체를 일컫는 용어이다.</p></blockquote></li><li><p>기본 타입의 값은 JVM내의 Stack 메모리에 저장된다.</p></li><li><p>참조 타입의 값은 객체 내의 상수에 저장된다. 따라서 JVM 내의 Heap 메모리에 저장된다.</p></li><li><p>따라서 박싱된 타입의 객체는 같은 값이라 하더라도 다른 객체일 경우에는 다르다고 식별이 가능하다.</p></li></ul></li><li><p>기본 타입의 값은 언제나 유효한 값을 가지고 있으나 박싱된 기본타입은 유효하지 않을 수 있다.</p><ul><li>기본타입의 값은 Java의 경우 초기화 되지 않으면 0으로 초기화 된다.</li><li>박싱된 기본 타입의 경우에는 초기화 되지 않으면 null이 될 수 있다.</li></ul></li><li><p>기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.</p><ul><li>박싱된 타입은 heap에 객체를 생성하기 때문에 메모리 사용면에서 더 안좋다.</li><li>기본타입은 변수에 값이 있는 반면, 박싱된 기본 타입은 변수의 객체참조 정보를 바탕으로 heap에서 찾으므로<br>시간적인 측면에서 기본타입보다 값에 접근하는 시간이 더 들게 된다.</li></ul></li></ul><h1 id="잘못-구현된-비교자-예제">잘못 구현된 비교자 예제</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; naturalOrder = (i, j) -&gt; (i &lt; j) ? -<span class="number">1</span> : (i == j ? <span class="number">0</span> : <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><ul><li>위의 코드를 기반으로 Integer비교가 실행되면 같은 값을 비교한다고 해도 1이 나올 수 있다.</li><li>첫번째 i &lt; j 에 대한 연산 시, Integer타입인 i와 j는 기본타입 int로 언박싱된다.</li><li>첫번째 연산이 false이면 두번째 연산 i == j에서도 false가 발생하게 된다.</li><li>이유는, (i, j)의 타입이 Integer로 추론되기 때문에 i == j 연산이 이루어질 때 객체의 동일성검사가 이루어져 false가 발생하기 때문이다. (i와 j는 내부 값은 같지만 서로 다른 객체이기 때문이다.)</li></ul><p><strong>이처럼 같은 객체가 아니라면 박싱된 기본타입에 == 연산자를 이용하여 비교하면 예상과는 다른 결과가 나올 수 있다.</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; naturalOrder = (i, j) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> unBoxi = i;</span><br><span class="line">    <span class="keyword">int</span> unBoxj = j;</span><br><span class="line">    <span class="keyword">return</span> (unBoxi &lt; unBoxj) ? -<span class="number">1</span> : (unBoxi == unBoxj ? <span class="number">0</span> : <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 수정하면 정상적인 결과를 얻을 수 있다.</p><h1 id="갑자기-발생하는-nullpointerexception">갑자기 발생하는 NullPointerException</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unbelievable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Integer i;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">42</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"믿을 수 없군"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 프로그램은 &quot;믿을 수 없군&quot;을 출력하지는 않지만, 전혀 예상하지 못한 결과를 보여준다.<br>i == 42를 검사하는 과정에서 NullPointerException을 던진다.<br>원인은 i가 literal 값인 42와 비교하는 과정에서 i는 Auto UnBoxing을 수행한다.<br>하지만  i는 null이기 때문에 Auto UnBoxing을 수행하는 과정에서 NullPointerException을 발생시키게 된다.</p><p><strong>기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.</strong><br>하지만 박싱된 기본타입이 null인 경우에는 NullPointerException이 발생하니 주의 해야 한다.</p><h1 id="의도하지-않은-auto-boxing으로-인한-성능저하">의도하지 않은 Auto Boxing으로 인한 성능저하</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0L</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">        sum += i; <span class="comment">//sum이 UnBoxing되어 i와 연산되고 연산 후에 AutoBoxing되어 Long타입으로 변환된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 코드는 sum을 Long으로 선언하였기 때문에 엄청난 성능상 안좋은 코드이다.<br>sum += i;를 수행하는 과정에서 <strong>sum이 long타입으로 UnBoxing되고</strong> sum + i 연산이 이루어진다음 <strong>Long타입으로 AutoBoxing되기 때문이다.</strong></p><h1 id="박싱된-기본타입은-언제-사용해야-하는가">박싱된 기본타입은 언제 사용해야 하는가?</h1><ul><li>컬렉션의 원소, 키, 값으로 쓴다.<ul><li>컬렉션은 기본타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본타입을 사용해야 한다.</li></ul></li><li>제네릭(Generics) 타입을 이용하는 경우에도 박싱된 기본타입을 사용한다.<ul><li>제네릭 타입에서는 int, double과 같은 기본타입을 지원하지 않기 때문이다.</li></ul></li><li>리플렉션(Reflection)을 통해 메서드를 호출할 때에도 박싱된 기본타입을 사용한다.</li></ul><h1 id="정리">정리</h1><ul><li>기본 타입과 박싱된 기본 타입을 사용해야 한다면,  가능하면 기본 타입을 사용하는 것이 좋다.</li><li>기본타입은 간단하고 빠르다.</li><li>박싱된 기본 타입을 사용한다면 주의를 기울이자</li><li>AutoBoxing이 기본타입을 변경할 때 번거로움을 줄여주지만 그 위험까지 없애주지는 않는다.<ul><li>박싱된 기본 타입을 == 연산자로 비교한다면 객체의 동일성 비교가 이뤄지는데<br>개발자가 의도한 결과가 나오지 않을 가능성이 크다.</li><li>== 연산에서 기본 타입과 박싱된 기본 타입의 연산이 이루어지면, 박싱된 기본 타입이 UnBoxing되는데<br>박싱된 기본 타입이 null인 경우 NullPointerException이 발생한다.</li></ul></li><li>기본 타입을 Boxing하는 것은 필요없는 객체를 생성하는 부작용이 나올 수 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/03/01/effective-jave-item61/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 60. 정확한 답이 필요하다면 Float와 Double은 피하라</title>
      <link>https://jaehun2841.github.io/2019/02/28/effective-java-item60/</link>
      <guid>https://jaehun2841.github.io/2019/02/28/effective-java-item60/</guid>
      <pubDate>Thu, 28 Feb 2019 10:34:22 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;float와 double 타입은 과학과 공학 계산용으로 설계되었다.&lt;br&gt;
이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 &lt;strong&gt;근사치&lt;/strong&gt; 로 계산하도록 세심하게 설계되었다
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>float와 double 타입은 과학과 공학 계산용으로 설계되었다.<br>이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 <strong>근사치</strong> 로 계산하도록 세심하게 설계되었다.<br>따라서 정확한 결과가 필요할 때에는 사용해선 안된다<br><strong>float와 double 타입은 특히 금융 관련 계산과는 맞지 않는다.</strong><br>0.1 혹은 10의 거듭 제곱 수를 표현할 수 없기 때문이다.</p><h1 id="예시-금융-계산에-부동소수-타입을-사용">예시 - 금융 계산에 부동소수 타입을 사용</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> funds = <span class="number">1.00</span>;</span><br><span class="line">    <span class="keyword">int</span> itemBought = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> price = <span class="number">0.10</span>; funds &gt;= price; price += <span class="number">0.10</span>) &#123;</span><br><span class="line">        funds -= price;</span><br><span class="line">        itemsBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">"개 구입"</span>);</span><br><span class="line">    System.out.println(<span class="string">"잔돈(달러): "</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>프로그램의 실행결과는 사탕 3개를 구입한 후 잔돈은 0.39999999999999달러가 남는다고 나온다.</li><li>잘못된 결과이며, 올바른 결과를 위해서는 <strong>BigDecimal, int, long</strong> 을 사용해야 한다.</li></ul><h2 id="bigdecimal을-사용한-코드-속도가-느리고-쓰기-불편하다">BigDecimal을 사용한 코드 - 속도가 느리고 쓰기 불편하다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BigDecimal TEN_CENTS = <span class="keyword">new</span> BigDecimal(<span class="string">".10"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> itemBought = <span class="number">0</span>;</span><br><span class="line">    BigDecimal funds = <span class="keyword">new</span> BigDecimal(<span class="string">"1.00"</span>);</span><br><span class="line">    <span class="keyword">for</span>(BigDecimal price = TEN_CENT; funds.compareTo(price) &gt;= <span class="number">0</span>; price = price.add(TEN_CENTS)) &#123;</span><br><span class="line">        funds = funds.subtract(price);</span><br><span class="line">        itemsBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">"개 구입"</span>);</span><br><span class="line">    System.out.println(<span class="string">"잔돈(달러): "</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>이 프로그램의 실행결과는 사탕 4개 구입 후 잔돈이 0달러가 남는다. 올바른 답이다.</li><li>BigDecimal에는 2가지 단점이 있다.<ul><li>기본 타입보다 쓰기가 훨씬 불편하고, 느리다. 단발성 계산이라면 문제는 아니지만 쓰기 불편하다</li><li>BigDecimal의 대안으로 int, long을 사용해도 된다. 하지만 소수점을 직접 관리해야 한다.</li></ul></li></ul><h2 id="int를-사용한-코드-cent로-문제를-해결">int를 사용한 코드 - Cent로 문제를 해결</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> itemBought = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> funds = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> price = <span class="number">10</span>; funds &gt;= price; price += <span class="number">10</span>) &#123;</span><br><span class="line">        funds -= price;</span><br><span class="line">        itemBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">"개 구입"</span>);</span><br><span class="line">    System.out.println(<span class="string">"잔돈(달러): "</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>int로 사용하면 BigDecimal 보다는 깔끔하고 정확한 답을 얻을 수 있다.</li></ul><h1 id="정리">정리</h1><ul><li>정확한 답이 필요한 계산에는 float나 double을 피해야한다.</li><li>소수점 추적은 시스템에 맡기고 코딩시의 불편함이나 성능저하가 중요하지 않다면 BigDecimal을 사용하라</li><li>BigDecimal은 8가지 반올림 모드를 제공하므로 반올림을 거의 완벽하게 제어할 수 있다.</li><li>성능이 중요하고 소수점을 직접 추적할 수 있고 숫자가 너무 크지 않다면 int나 long을 사용하라</li><li>숫자를 9자리 10진수로 표현한다면 int를 사용하라</li><li>숫자를 18자리 10진수로 표현할 수 있다면 long을 사용하라</li><li>숫자가 18자리가 넘어가면 BigDecimal을 사용해야 한다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 60. 정확한 답이 필요하다면 float와 double은 피하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/28/effective-java-item60/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 59. 라이브러리를 익히고 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/28/effective-java-item59/</link>
      <guid>https://jaehun2841.github.io/2019/02/28/effective-java-item59/</guid>
      <pubDate>Thu, 28 Feb 2019 10:18:25 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;무작위-정수-만들기&quot;&gt;무작위 정수 만들기&lt;/h1&gt;
&lt;p&gt;무작위 정수를 하나 생성한다고 해보자&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="무작위-정수-만들기">무작위 정수 만들기</h1><p>무작위 정수를 하나 생성한다고 해보자</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">random</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(rnd.nextInt()) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>괜찮아 보이지만 3가지의 문제를 내포하고 있다.</p><ul><li><p>n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다.</p></li><li><p>n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 자주 반환된다.</p></li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span> * (Integer.MAX_VALUE / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(random(n) &lt; n/<span class="number">2</span>) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(low);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>random 메서드가 이상적으로 동작한다면 약 50만개가 출력되어야 하지만, 실제로는 666,666에 가까운 값을 얻는다.<br>무작위로 생성된 수 중에서 2/3 가량이 중간값보다 낮은 쪽으로 쏠린 것이다.</p><ul><li>지정한 범위 바깥의 수가 종종 튀어나올 수 있다. rnd.nextInt()가 반환한 값을 Math.abs를 이용해 음수가 아닌 정수로 매핑하기 때문이다.</li></ul><h1 id="표준-라이브러리를-사용하면-다른-프로그래머들의-경험을-활용할-수-있다">표준 라이브러리를 사용하면 다른 프로그래머들의 경험을 활용할 수 있다.</h1><ul><li>메서드의 동작 방식은 몰라도 알고리즘에 능통한 개발자나, 여러 분야의 전문가가 설계와 구현에 시간을 들여 개발한 것이다.</li><li>버그가 발생되더라도 다음 릴리스에 수정 보완 개선이 될 수 있다.</li><li>표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.</li><li>핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 되고 어플리케이션 기능 개발에 집중할 수 있다.</li><li>따로 노력하지 않아도 릴리즈가 나올 때 마다 성능이 지속해서 개선된다.</li><li>기능이 점점 많아진다. 개발자 커뮤니티에서 나온 이야기를 바탕으로 논의 후 다음 릴리즈에 기능이 추가되곤 한다.</li><li>라이브러리를 사용하면 많은 사람들에게 낯익은 코드가 된다. 다른 개발자들이 유지보수 하기 쉬워지고 재사용성이 높아진다.</li></ul><h1 id="메이저-버전-릴리즈-마다-수많은-기능이-추가된다">메이저 버전 릴리즈 마다 수많은 기능이 추가된다.</h1><ul><li>자바는 메이저 릴리즈마다 새로운 기능을 설명하는 웹페이지를 공시한다.</li><li>한 번쯤은 읽어볼만 하다</li><li>너무 많아서 읽기 힘든 경우에는 java.lang, java.util, java.io와 하위 패키지들에는 익숙해져야 한다.</li><li>컬렉션 프레임워크나 concurrent 패키지는 알아두면 도움이 도니다.</li></ul><h2 id="예시-transferto-메서드를-이용해-url-내용-가져오기">예시 - transferTo 메서드를 이용해 URL 내용 가져오기</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;InputStream in = <span class="keyword">new</span> URL(args[<span class="number">0</span>]).openStream()) &#123;</span><br><span class="line">        in.transferTo(System.out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>java 9 버전 부터 URL정보를 쉽게 출력해 주는 transferTo 메서드를 제공한다.</li></ul><h1 id="정리">정리</h1><ul><li>라이브러리가 전문적인 기능을 제공해 주지 못할수도 있지만, 라이브러리를 일단 사용해보자</li><li>특별한 기능이 아니라면 누군가 라이브러리로 만들어 두었을 가능성이 높다.<br>일단 라이브러리가 있는지 찾아보자</li><li>일반적으로 라이브러리의 코드는 개발자가 작성한 것보다 품질이 좋고 개선의 여지가 있다.</li><li>라이브러리 코드는 주목을 많이 받고 개발자 커뮤니티에서 문제점이 많이 거론되므로 코드 품질이 점차 좋아진다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 59. 라이브러리를 익히고 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/28/effective-java-item59/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 58. 전통적인 for 문보다는 For-Each문을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/02/28/effective-java-item58/</link>
      <guid>https://jaehun2841.github.io/2019/02/28/effective-java-item58/</guid>
      <pubDate>Thu, 28 Feb 2019 09:39:24 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;스트림(Stream)이 제격인 작업이 있고, 반복이 제격인 작업이 있다.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>스트림(Stream)이 제격인 작업이 있고, 반복이 제격인 작업이 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c.iterator(); i.hasNext();) &#123;</span><br><span class="line">    Element e = i.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> z = a[i]; <span class="comment">// a[i]로 무언가를 한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 for문과 같은 관용구들은 while문 보다는 낫지만 가장 탁월한 방법은 아니다.<br><strong>반복자와 인덱스 변수는 모두 코드를 지저분하게 할 뿐 우리에게 필요한 건 원소들 뿐이다.</strong><br>또한 컬렉션이냐 배열이냐에 따라 코드 형태가 달라지기 때문에 주의해야 한다.</p><h1 id="향상된-for문-enhanced-for-statement">향상된 for문 (enhanced for statement)</h1><ul><li>반복자와 인덱스 변수를 사용하지 않으니 코드가 깔끔해지고 오류가 날 일이 없다.</li><li>하나의 관용구로 되어있어서 배열이든 컬렉션이든 코드의 형태가 같다.</li><li>콜론(:)은 <strong>안의(in)</strong> 라고 읽으면 된다. (elements안의 각 원소 e에 대해)</li><li>반복 대상이 컬렉션이든 배열이든 for-each문을 사용해도 속도는 그대로이다.</li><li>for-each 문이 만들어 내는 코드는 사람이 손으로 최적화한 것과 사실상 같다.</li></ul><h1 id="컬렉션이-중첩되는-경우-for-each의-이점이-커진다">컬렉션이 중첩되는 경우 for-each의 이점이 커진다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Suit &#123; CLUB, DIAMOND, HEART, SPADE&#125;</span><br><span class="line"><span class="keyword">enum</span> Rank &#123; ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Collection&lt;Suit&gt; suits = Arrays.asList(Suit.values());</span><br><span class="line"><span class="keyword">static</span> Collection&lt;Rank&gt; ranks = Arrays.asList(Rank.values());</span><br><span class="line"></span><br><span class="line">List&lt;Card&gt; deck = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Suit&gt; i = suits.iterator(); i.hasNext();) &#123;</span><br><span class="line">    <span class="keyword">for</span>(Iterator&lt;Rank&gt; j = ranks.iterator(); j.hasNext();) &#123;</span><br><span class="line">        deck.add(<span class="keyword">new</span> Card(i.next(), j.next()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>deck.add(new Card(i.next(), j.next()));</code> 줄이 오류를 일으킨다.</li><li>원래대로 하면 숫자 1개당 rank가 여러번 불려야 하는데 저러면 숫자 1개에 rank 1개 불려 <code>NoSuchElementException</code> 을 던진다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Suit &#123; CLUB, DIAMOND, HEART, SPADE&#125;</span><br><span class="line"><span class="keyword">enum</span> Rank &#123; ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Collection&lt;Suit&gt; suits = Arrays.asList(Suit.values());</span><br><span class="line"><span class="keyword">static</span> Collection&lt;Rank&gt; ranks = Arrays.asList(Rank.values());</span><br><span class="line"></span><br><span class="line">List&lt;Card&gt; deck = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Suit suit : suits) &#123;</span><br><span class="line">    <span class="keyword">for</span>(Rank rank : ranks) &#123;</span><br><span class="line">        deck.add(<span class="keyword">new</span> Card(suit, rank));   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>위와 같이 for-each를 사용하면 깔끔하고 간단하게 코드를 짤 수 있다.</li></ul><h1 id="for-each를-사용할-수-없는-상황">for-each를 사용할 수 없는 상황</h1><ul><li><strong>파괴적인 필터링(destructive filtering)</strong><ul><li>컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 호출해야 한다.</li><li>Java 8 부터 Collection의 removeIf 메서드를 사용해 컬렉션을 명시적으로 순회하지 않을 수 있다.</li></ul></li><li><strong>변형(transforming)</strong><ul><li>리스트나 배열을 순회하면서 원소 값 일부 혹은 전체를 교체하는 경우에는 인덱스를 사용해야 한다.</li></ul></li><li><strong>병렬 반복(parallel iteration)</strong><ul><li>여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.</li></ul></li></ul><h1 id="정리">정리</h1><ul><li>for문 대신 for-each를 사용할 수 있는 경우는 무조건 사용하자</li><li>전통적인 for문과 비교했을 때, for-each문은 명료하고 유연하고 버그를 예방해 준다.</li><li>for-each문은 컬렉션과 배열은 물론 Iterable 인터페이스를 구현한 객체라면 무엇이든 순회 가능하다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 58. 전통적인 for 문보다는 for-each문을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/28/effective-java-item58/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 57. 지역변수의 범위를 최소화하라</title>
      <link>https://jaehun2841.github.io/2019/02/28/effective-java-item57/</link>
      <guid>https://jaehun2841.github.io/2019/02/28/effective-java-item57/</guid>
      <pubDate>Thu, 28 Feb 2019 09:23:54 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;클래스의 멤버와 접근권한을 최소화하라 (Item 15)&lt;/strong&gt; 와 취지가 비슷한 장이다.&lt;br&gt;
지역변수의 유효범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p><strong>클래스의 멤버와 접근권한을 최소화하라 (Item 15)</strong> 와 취지가 비슷한 장이다.<br>지역변수의 유효범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.</p><h1 id="가장-처음-쓰일-때-선언하라">가장 처음 쓰일 때 선언하라</h1><ul><li>사용하려면 멀었는데 미리 변수부터 선언하는 코드는 어수선하고 가독성이 좋지 못하다.</li><li>막상 쓰일 시점에 되서는 무슨 타입이었는지, 무슨 값으로 초기화 했는지 기억이 나지 않을 경우가 있다.</li><li>변수가 쓰이는 범위보다 너무 앞서 선언하거나, 다 쓴 뒤에도 할당해제가 되지 않고 여전히 살아있게 된다.</li><li>변수의 scope를 제한하지 못하면 예상하지 못한 결과를 초래할 수 있으니 주의해야 한다.</li></ul><h1 id="모든-지역변수는-선언과-동시에-초기화-하라">모든 지역변수는 선언과 동시에 초기화 하라</h1><ul><li><p>초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야한다.</p></li><li><p>try-catch-finally 구문에서는 예외다.</p></li><li><p>변수를 초기화 하는 표현식에서 checked exception을 던질 가능성이 있으면, try 절 안에서 초기화 해야한다.</p></li><li><p>만약, catch나 finally절에서 변수를 이용해야 한다면, try절 바로 앞에 변수를 선언해야 한다.</p></li><li><p>반복문에서는 반복 변수(loop variable)의 범위가 반복문의 몸체, 그리고 for 키워드와 몸체 사이 괄호 안으로 제한된다.</p></li><li><p>반복자 (index)를 사용해야 하는 경우에는 for-each 구문보다 전통적인 for문이 낫다.</p></li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Element e : c) &#123;</span><br><span class="line">    <span class="comment">// e로 무언가를 반복하는 로직을 구성</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c.iterator(); i.hasNext();) &#123;</span><br><span class="line">    Element e = i.next(); <span class="comment">//e와 i로 무언가를 한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="while-문을-사용하는-경우에도-for문을-사용하는-것이-낫다">while 문을 사용하는 경우에도 for문을 사용하는 것이 낫다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Element&gt; i = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext()) &#123;</span><br><span class="line">    doSomeThing(i.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator&lt;Element&gt; i2 = c2.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext()) &#123; </span><br><span class="line">    doSomeThing(i2.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>복붙의 여파로 i2.hasNext()이지만 i.hasNext()를 사용하였다.</li><li>컴파일도 잘되고 실행도 잘되지만, 기대한 결과가 도출되지 않는다.</li><li>for문을 포함한 for-each문을 사용하는 경우에는 이러한 문제를 컴파일 타임에 잡아준다.(반복자의 유효범위가 for문의 종료와 함께 끝나기 때문이다.)</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c.iterator(); i.hasNext();) &#123;</span><br><span class="line">    Element e = i.next();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i2 = c2.iterator(); i.hasNext();) &#123;</span><br><span class="line">    Element e2 = i2.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>두번째 코드의 i.hasNext()에서 i를 찾을 수 없다는 오류를 보여준다.</li></ul><h1 id="메서드를-작게-유지하고-한-가지-기능에-집중하라">메서드를 작게 유지하고 한 가지 기능에 집중하라</h1><ul><li>한 메서드에서 여러 가지 기능을 처리한다면 그중 한 기능과만 관련된 지역변수라도 다른 기능을 수행하는 코드에서 접근할 수 있다.</li><li>단순히 메서드를 기능별로만 쪼개자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 57. 지역변수의 범위를 최소화하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/28/effective-java-item57/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Mongo DB Aggregation Pipeline - SpringBoot에서 사용하기</title>
      <link>https://jaehun2841.github.io/2019/02/24/2019-02-24-mongodb-3/</link>
      <guid>https://jaehun2841.github.io/2019/02/24/2019-02-24-mongodb-3/</guid>
      <pubDate>Sun, 24 Feb 2019 11:29:36 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;springboot에서-mongodb-간단설정하기&quot;&gt;SpringBoot에서 MongoDB 간단설정하기&lt;/h1&gt;
&lt;h2 id=&quot;maven&quot;&gt;Maven&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="springboot에서-mongodb-간단설정하기">SpringBoot에서 MongoDB 간단설정하기</h1><h2 id="maven">Maven</h2><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>Spring-boot-starter-data-mongodb Dependency로 간단하게 mongoldb 관련 모든 라이브러리를 로드 할 수 있습니다.</li></ul><h2 id="applicationyml">application.yml</h2><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    mongodb:</span></span><br><span class="line"><span class="attr">      uri:</span> <span class="attr">mongodb://127.0.0.1:27017/employee-test</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">myUser</span></span><br><span class="line"><span class="attr">      password:</span> <span class="string">myUserIsCarrey</span></span><br></pre></td></tr></table></figure></p><ul><li>SpringBoot에서는 단순하게 application.yml에 connection-uri정보만 있으면 Spring Boot 서버 시작 시<br>MongoDB와 연결할 수 있습니다.</li></ul><h2 id="mongo-db-config">Mongo DB Config</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractMongoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;spring.data.mongodb.uri&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;spring.data.mongodb.username&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> String username;</span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;spring.data.mongodb.password&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MongoClient <span class="title">mongoClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MongoClientURI mongoClientURI = <span class="keyword">new</span> MongoClientURI(<span class="keyword">this</span>.url);</span><br><span class="line">        MongoCredential mongoCredential = </span><br><span class="line">            MongoCredential.createCredential(<span class="keyword">this</span>.username, mongoClientURI.getDatabase(),<span class="keyword">this</span>.password.toCharArray());</span><br><span class="line">        ServerAddress serverAddress = <span class="keyword">new</span> ServerAddress(mongoClientURI.getHosts().get(<span class="number">0</span>));</span><br><span class="line">        MongoClientOptions options = MongoClientOptions.builder().build();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoClient(serverAddress, mongoCredential, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDatabaseName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoClientURI(<span class="keyword">this</span>.url).getDatabase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>MongoDB Client 객체를 생성하는 코드를 추가하였습니다.</li><li>credential을 사용하는 경우 저런식으로 credential 객체를 만들어줘야 합니다.</li><li>그렇지 않으면 <code>Command aggregate failed: not authorized on DB to execute command</code> 에러가 발생하며 Mongo DB 기능을 이용할 수 없습니다.</li></ul><h1 id="예제로-풀어보는-mongo-db-aggregation-pipeline">예제로 풀어보는 Mongo DB Aggregation pipeline</h1><p>예제로 등록한 employee collection은 오라클 DB의 예제 DB인 employee 테이블을 차용하였습니다.</p><h2 id="문제-1">문제 1.</h2><p><strong>20 번 및 30 번 부서에서 근무하는 모든 사원들의 ENAME 집합과 부서번호를 출력하라</strong></p><h3 id="mongo-db-aggregation-pipeline">Mongo DB Aggregation pipeline</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">db.employee.aggregate(</span><br><span class="line">    [ </span><br><span class="line">        &#123; </span><br><span class="line">            $match : &#123; </span><br><span class="line">                deptId : &#123;</span><br><span class="line">                $in: [20, 30]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; </span><br><span class="line">            $group : &#123;</span><br><span class="line">            _id: "$deptId",</span><br><span class="line">                enames: &#123;</span><br><span class="line">                    $addToSet: "$ename"</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            $project : &#123;</span><br><span class="line">                _id : 0,</span><br><span class="line">                deptId : "$_id",</span><br><span class="line">                enames : 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h3 id="spring-data-mongodb를-이용한-java-code">Spring Data MongoDB를 이용한 Java Code</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 20 번 및 30 번 부서에서 근무하는 모든 사원들의 ENAME 집합과 부서번호를 출력하라</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deptNos</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserListByDeptNo&gt; <span class="title">getUserListByDeptNo</span><span class="params">(List&lt;Integer&gt; deptNos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//match</span></span><br><span class="line">        Criteria criteria = <span class="keyword">new</span> Criteria().where(<span class="string">"deptId"</span>).in(deptNos);</span><br><span class="line">        MatchOperation matchOperation = Aggregation.match(criteria);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//group</span></span><br><span class="line">        GroupOperation groupOperation = Aggregation.group(<span class="string">"deptId"</span>)</span><br><span class="line">                                                   .addToSet(<span class="string">"ename"</span>).as(<span class="string">"enames"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//projection</span></span><br><span class="line">        ProjectionOperation projectionOperation = Aggregation.project(<span class="string">"enames"</span>)</span><br><span class="line">                                                             .and(previousOperation()).as(<span class="string">"deptId"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//aggrgation</span></span><br><span class="line">        AggregationResults&lt;UserListByDeptNo&gt; aggregate =</span><br><span class="line">                <span class="keyword">this</span>.mongoTemplate.aggregate(newAggregation(matchOperation, groupOperation, projectionOperation),</span><br><span class="line">                                             Employee.class,</span><br><span class="line">                                             UserListByDeptNo.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> aggregate.getMappedResults();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="문제2">문제2</h2><p><strong>부서별 연봉합계 순위를 랭킹하여라</strong></p><h3 id="mongo-db-aggregation-pipeline">Mongo DB Aggregation pipeline</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">db.employee.aggregate(</span><br><span class="line"> [ </span><br><span class="line">     &#123; </span><br><span class="line">         <span class="attr">"$group"</span> : &#123;</span><br><span class="line">            <span class="attr">"_id"</span> : &#123; <span class="attr">"deptId"</span> : <span class="string">"$deptId"</span> , <span class="attr">"deptName"</span> : <span class="string">"$deptName"</span>&#125;, </span><br><span class="line">            <span class="attr">"totalSal"</span> : &#123; <span class="attr">"$sum"</span> : <span class="string">"$sal"</span>&#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; , </span><br><span class="line">     &#123; <span class="attr">"$sort"</span> : &#123; <span class="attr">"totalSal"</span> : <span class="number">-1</span>&#125;&#125; , </span><br><span class="line">     &#123; </span><br><span class="line">         <span class="attr">"$project"</span> : &#123; </span><br><span class="line">             <span class="attr">"deptId"</span> : <span class="string">"$_id.deptId"</span> , </span><br><span class="line">             <span class="attr">"deptName"</span> : <span class="string">"$_id.deptName"</span> , </span><br><span class="line">             <span class="attr">"totalSal"</span> : <span class="number">1</span></span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="spring-data-mongodb를-이용한-java-code">Spring Data MongoDB를 이용한 Java Code</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;SalRankByDept&gt; <span class="title">getSalRankByDepts</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//Group</span></span><br><span class="line">       GroupOperation groupOperation = Aggregation.group(<span class="string">"deptId"</span>, <span class="string">"deptName"</span>)</span><br><span class="line">               .sum(<span class="string">"sal"</span>).as(<span class="string">"totalSal"</span>);</span><br><span class="line">       <span class="comment">//Sort</span></span><br><span class="line">       SortOperation sortOperation = Aggregation.sort(Sort.Direction.DESC, <span class="string">"totalSal"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//Projection</span></span><br><span class="line">       ProjectionOperation projectionOperation = Aggregation.project(<span class="string">"deptId"</span>, <span class="string">"deptName"</span>,<span class="string">"totalSal"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//aggrgation</span></span><br><span class="line">       AggregationResults&lt;SalRankByDept&gt; aggregate =</span><br><span class="line">               <span class="keyword">this</span>.mongoTemplate.aggregate(newAggregation(groupOperation, sortOperation, projectionOperation),</span><br><span class="line">                       Employee.class,</span><br><span class="line">                       SalRankByDept.class);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> aggregate.getMappedResults();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h1 id="삽질-끝판왕-도전기">삽질 끝판왕 도전기</h1><p>위의 예제 코드 2개를 보면 특이한 점이 한가지 있습니다.<br>바로 Projection Operation 부분이 살짝 다른데요.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//projection</span></span><br><span class="line">ProjectionOperation projectionOperation = Aggregation.project(<span class="string">"enames"</span>).and(previousOperation()).as(<span class="string">"deptId"</span>);</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Projection</span></span><br><span class="line">ProjectionOperation projectionOperation = Aggregation.project(<span class="string">"deptId"</span>, <span class="string">"deptName"</span>,<span class="string">"totalSal"</span>);</span><br></pre></td></tr></table></figure></p><p>위의 코드에서는 grouping key에 대해 조회 할 때</p><p><code>.and(previousOperation()).as(&quot;deptId&quot;)</code> 라고 and 메서드에 <code>previousOperation()</code> 라는 메서드를 적어주었습니다.<br>두번째 코드에서는 그냥 grouping Key를 projection field에 나열하였습니다.</p><p>무슨 차이일까요?</p><ul><li>첫번째 코드는 grouping key가 1개이다.</li><li>두번째 코드는 grouping key가 2개이다.</li></ul><p>위와 같은 차이가 있습니다.</p><p>만약에 1번 코드를 2번처럼 사용한다면</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProjectionOperation projectionOperation = Aggregation.project(<span class="string">"deptId"</span>, <span class="string">"enames"</span>);</span><br></pre></td></tr></table></figure></p><p>이와 같이 사용할 수 있을 것입니다.<br>위의 코드로 수정하고 프로그램을 실행해 보면...</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalArgumentException: Parameter deptId must not be null!</span><br></pre></td></tr></table></figure></p><p>라는 메세지가 나오면서 런타임 예외를 던집니다.뭐 때문에 나는 발생하는 예외 일까요?</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">toDocument</span><span class="params">(AggregationOperationContext context)</span> </span>&#123;</span><br><span class="line">    Document operationObject = <span class="keyword">new</span> Document();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.idFields.exposesNoNonSyntheticFields()) &#123;</span><br><span class="line">        operationObject.put(<span class="string">"_id"</span>, (Object)<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.idFields.exposesSingleNonSyntheticFieldOnly()) &#123;</span><br><span class="line">        FieldReference reference = context.getReference((Field)<span class="keyword">this</span>.idFields.iterator().next());</span><br><span class="line">        operationObject.put(<span class="string">"_id"</span>, reference.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Document inner = <span class="keyword">new</span> Document();</span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.idFields.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            ExposedField field = (ExposedField)var4.next();</span><br><span class="line">            FieldReference reference = context.getReference(field);</span><br><span class="line">            inner.put(field.getName(), reference.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        operationObject.put(<span class="string">"_id"</span>, inner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator var8 = <span class="keyword">this</span>.operations.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">        GroupOperation.Operation operation = (GroupOperation.Operation)var8.next();</span><br><span class="line">        operationObject.putAll(operation.toDocument(context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Document(<span class="string">"$group"</span>, operationObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>원인은 GroupOperation 내부에 있습니다.</strong><br>Aggregation 클래스들의 toDocument 메서드는 MongoDB에 보낼 실제 명령어 구조를 짜는 메서드입니다.</p><ul><li>첫 번째 if 조건인 <code>this.idFields.exposesNoNonSyntheticFields()</code>은 idFields.isEmpty() 인 경우를 체크 합니다.<ul><li>Group key가 없는 경우는 _id 필드가 null이 되어집니다.</li></ul></li><li>두 번째 if 조건인 <code>this.idFields.exposesSingleNonSyntheticFieldOnly()</code> 은 group key가 1개인 경우를 체크 합니다.<ul><li>group key가 1개인 경우에는 group key 필드에 대한 필드명이 <strong>_id</strong> 로 표현되어 다음 파이프라인에서 사용됩니다.</li><li><code>operationObject.put(&quot;_id&quot;, reference.toString());</code> 여기서 _id에 대한 타입은 <strong>String</strong> 으로 결정나기 때문에<br>다음 파이프라인에서 _id.field와 같은 행위를 할 수 없게 됩니다.</li><li>따라서 {_id : &quot;$deptId&quot;}로 BSON이 생성되기 때문에 다음 파이프라인인 Projection에서는 <strong>deptId인 필드는 찾을 수 없게 되는 것입니다.</strong></li></ul></li><li>마지막 else 조건은 group key가 여러 개인 경우에 대해 Document 객체에 key값을 매핑시킵니다.<ul><li>다음 파이프라인에서 _id.field와 같은 형태로 접근이 가능하기 때문에 group key가 여러개 인 경우에는<br>projection operation에서 group key만 써줘도 자연스럽게 표현이 됩니다.</li><li>내부적으로는 <code>{deptId : &quot;$_id.deptId&quot;, deptName: &quot;$_id.deptName&quot;}</code> 과 같은 형태로 사용 됩니다.</li></ul></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/24/2019-02-24-mongodb-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Mongo DB Aggregation Pipeline</title>
      <link>https://jaehun2841.github.io/2019/02/24/2019-02-24-mongodb-2/</link>
      <guid>https://jaehun2841.github.io/2019/02/24/2019-02-24-mongodb-2/</guid>
      <pubDate>Sun, 24 Feb 2019 09:57:08 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;aggregation-pipeline&quot;&gt;Aggregation Pipeline&lt;/h1&gt;
&lt;p&gt;Mongo DB의 Aggregation Framework는 데이터 처리 파이프라인의 개념을 모델로 합니다.&lt;br&gt;
문서는 여러 단계의 파이프라인을
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="aggregation-pipeline">Aggregation Pipeline</h1><p>Mongo DB의 Aggregation Framework는 데이터 처리 파이프라인의 개념을 모델로 합니다.<br>문서는 여러 단계의 파이프라인을 거쳐 변화하고 하나의 문서의 형태로 집계할 수 있습니다.</p><p><strong>파이프라인(pipeline)</strong> 이란, 이전 단계의 연산결과를 다음 단계연산에 이용하는 것을 의미합니다.</p><p><img src="./aggregation-pipeline.svg" alt="aggregation-pipeline"></p><h1 id="stages">Stages</h1><h2 id="stagesdbcollectionaggregate">Stages(db.collection.aggregate)</h2><p>db.collection.aggregate 메서드는 파이프라인 단계를 Array의 형태로 나타냅니다.<br>Document는 파이프라인 Array의 순서대로 가공되며, <code>$out</code> 및 <code>$geoNear</code> 를 제외한 모든 단계는 파이프라인에 여러 번 나타날 수 있습니다.</p><h2 id="match">$Match</h2><ul><li>조건에 만족하는 Document만 Filtering</li></ul><h3 id="입력-형식">입력 형식</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $match: &#123; &lt;query&gt; &#125; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="예제">예제</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"512bc95fe835e68f199c8686"</span>), <span class="attr">"author"</span> : <span class="string">"dave"</span>, <span class="attr">"score"</span> : <span class="number">80</span>, <span class="attr">"views"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"512bc962e835e68f199c8687"</span>), <span class="attr">"author"</span> : <span class="string">"dave"</span>, <span class="attr">"score"</span> : <span class="number">85</span>, <span class="attr">"views"</span> : <span class="number">521</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"55f5a192d4bede9ac365b257"</span>), <span class="attr">"author"</span> : <span class="string">"ahn"</span>, <span class="attr">"score"</span> : <span class="number">60</span>, <span class="attr">"views"</span> : <span class="number">1000</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"55f5a192d4bede9ac365b258"</span>), <span class="attr">"author"</span> : <span class="string">"li"</span>, <span class="attr">"score"</span> : <span class="number">55</span>, <span class="attr">"views"</span> : <span class="number">5000</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"55f5a1d3d4bede9ac365b259"</span>), <span class="attr">"author"</span> : <span class="string">"annT"</span>, <span class="attr">"score"</span> : <span class="number">60</span>, <span class="attr">"views"</span> : <span class="number">50</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"55f5a1d3d4bede9ac365b25a"</span>), <span class="attr">"author"</span> : <span class="string">"li"</span>, <span class="attr">"score"</span> : <span class="number">94</span>, <span class="attr">"views"</span> : <span class="number">999</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"55f5a1d3d4bede9ac365b25b"</span>), <span class="attr">"author"</span> : <span class="string">"ty"</span>, <span class="attr">"score"</span> : <span class="number">95</span>, <span class="attr">"views"</span> : <span class="number">1000</span> &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.articles.aggregate(</span><br><span class="line">    [ &#123; $match : &#123; author : "dave" &#125; &#125; ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h3 id="연산-결과">연산 결과</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"512bc95fe835e68f199c8686"</span>), <span class="attr">"author"</span> : <span class="string">"dave"</span>, <span class="attr">"score"</span> : <span class="number">80</span>, <span class="attr">"views"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : ObjectId(<span class="string">"512bc962e835e68f199c8687"</span>), <span class="attr">"author"</span> : <span class="string">"dave"</span>, <span class="attr">"score"</span> : <span class="number">85</span>, <span class="attr">"views"</span> : <span class="number">521</span> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="group">$Group</h2><ul><li>Document에 대한 Grouping 연산을 수행</li><li>Group에 대한 id를 지정해야하고, 특정 필드에 대한 집계 연산이 가능</li><li>$group은 연산된 Document에 대한 정렬을 지원하지 않음</li></ul><h3 id="입력-형식">입력 형식</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $group: &#123; _id: &lt;expression&gt;, &lt;field1&gt;: &#123; &lt;accumulator1&gt; : &lt;expression1&gt; &#125;, ... &#125; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="accumulator">accumulator</h3><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/addToSet/#grp._S_addToSet" target="_blank" rel="noopener"><code>$addToSet</code></a></td><td>id로 Grouping 한 데이터를 중복되지 않은 Set의 형태로 저장</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/avg/#grp._S_avg" target="_blank" rel="noopener"><code>$avg</code></a></td><td>숫자 값의 평균을 반환. 숫자가 아닌 값을 무시.</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/first/#grp._S_first" target="_blank" rel="noopener"><code>$first</code></a></td><td>각 그룹에 대한 첫 번째 Document의 값을 반환. &lt;br /&gt;Document가 정의된 순서가 있는 경우에만 ordering을 지원</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/last/#grp._S_last" target="_blank" rel="noopener"><code>$last</code></a></td><td>각 그룹에 대한 마지막 Document의 값을 반환. &lt;br /&gt;Document가 정의된 순서가 있는 경우에만 ordering을 지원</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/max/#grp._S_max" target="_blank" rel="noopener"><code>$max</code></a></td><td>각 그룹에서 가장 큰 값을 반환</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/mergeObjects/#exp._S_mergeObjects" target="_blank" rel="noopener"><code>$mergeObjects</code></a></td><td>각 그룹에 대한 입력 Document를 조합하여 작성한 Document를 반환합니다.</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/min/#grp._S_min" target="_blank" rel="noopener"><code>$min</code></a></td><td>각 그룹에서 가장 작은 값을 반환</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/push/#grp._S_push" target="_blank" rel="noopener"><code>$push</code></a></td><td>각 그룹의 필드 값의 배열을 반환</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/stdDevPop/#grp._S_stdDevPop" target="_blank" rel="noopener"><code>$stdDevPop</code></a></td><td>입력 값의 모집단 표준 편차를 반환</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/stdDevSamp/#grp._S_stdDevSamp" target="_blank" rel="noopener"><code>$stdDevSamp</code></a></td><td>입력 값의 샘플 표준 편차를 반환</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/sum/#grp._S_sum" target="_blank" rel="noopener"><code>$sum</code></a></td><td>각 그룹의 숫자형 데이터의 합을 반환. 숫자가 아닌 값은 무시</td></tr></tbody></table><h3 id="예시">예시</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"item"</span> : <span class="string">"abc"</span>, <span class="attr">"price"</span> : <span class="number">10</span>, <span class="attr">"quantity"</span> : <span class="number">2</span>, <span class="attr">"date"</span> : ISODate(<span class="string">"2014-03-01T08:00:00Z"</span>) &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">2</span>, <span class="attr">"item"</span> : <span class="string">"jkl"</span>, <span class="attr">"price"</span> : <span class="number">20</span>, <span class="attr">"quantity"</span> : <span class="number">1</span>, <span class="attr">"date"</span> : ISODate(<span class="string">"2014-03-01T09:00:00Z"</span>) &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">3</span>, <span class="attr">"item"</span> : <span class="string">"xyz"</span>, <span class="attr">"price"</span> : <span class="number">5</span>, <span class="attr">"quantity"</span> : <span class="number">10</span>, <span class="attr">"date"</span> : ISODate(<span class="string">"2014-03-15T09:00:00Z"</span>) &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">4</span>, <span class="attr">"item"</span> : <span class="string">"xyz"</span>, <span class="attr">"price"</span> : <span class="number">5</span>, <span class="attr">"quantity"</span> : <span class="number">20</span>, <span class="attr">"date"</span> : ISODate(<span class="string">"2014-04-04T11:21:39.736Z"</span>) &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">5</span>, <span class="attr">"item"</span> : <span class="string">"abc"</span>, <span class="attr">"price"</span> : <span class="number">10</span>, <span class="attr">"quantity"</span> : <span class="number">10</span>, <span class="attr">"date"</span> : ISODate(<span class="string">"2014-04-04T21:23:13.331Z"</span>) &#125;</span><br></pre></td></tr></table></figure></p><h3 id="연산-년월일을-기준으로-group">연산 - 년/월/일을 기준으로 group</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.sales.aggregate(</span><br><span class="line">   [</span><br><span class="line">      &#123;</span><br><span class="line">        $group : &#123;</span><br><span class="line">           _id : &#123; month: &#123; $month: "$date" &#125;, day: &#123; $dayOfMonth: "$date" &#125;, year: &#123; $year: "$date" &#125; &#125;,</span><br><span class="line">           totalPrice: &#123; $sum: &#123; $multiply: [ "$price", "$quantity" ] &#125; &#125;,</span><br><span class="line">           averageQuantity: &#123; $avg: "$quantity" &#125;,</span><br><span class="line">           count: &#123; $sum: 1 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ul><li>년/월/일을 기준으로 집계</li><li><code>$price</code> x <code>$quantity</code> 를 곱한 값의 합을 <strong>totalPrice</strong> 필드로 지정</li><li><code>$quantity</code> 필드 값의 평균을 <strong>averageQuantity</strong> 필드로 지정</li><li>Group별 데이터의 갯수를 <strong>count</strong> 로 지정</li></ul><h3 id="연산-결과">연산 결과</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="attr">"_id"</span> : &#123; <span class="attr">"month"</span> : <span class="number">3</span>, <span class="attr">"day"</span> : <span class="number">15</span>, <span class="attr">"year"</span> : <span class="number">2014</span> &#125;, </span><br><span class="line">    <span class="attr">"totalPrice"</span> : <span class="number">50</span>, </span><br><span class="line">    <span class="attr">"averageQuantity"</span> : <span class="number">10</span>, </span><br><span class="line">    <span class="attr">"count"</span> : <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line">&#123; </span><br><span class="line">    <span class="attr">"_id"</span> : &#123; <span class="attr">"month"</span> : <span class="number">4</span>, <span class="attr">"day"</span> : <span class="number">4</span>, <span class="attr">"year"</span> : <span class="number">2014</span> &#125;, </span><br><span class="line">    <span class="attr">"totalPrice"</span> : <span class="number">200</span>, </span><br><span class="line">    <span class="attr">"averageQuantity"</span> : <span class="number">15</span>, </span><br><span class="line">    <span class="attr">"count"</span> : <span class="number">2</span> </span><br><span class="line">&#125;</span><br><span class="line">&#123; </span><br><span class="line">    <span class="attr">"_id"</span> : &#123; <span class="attr">"month"</span> : <span class="number">3</span>, <span class="attr">"day"</span> : <span class="number">1</span>, <span class="attr">"year"</span> : <span class="number">2014</span> &#125;, </span><br><span class="line">    <span class="attr">"totalPrice"</span> : <span class="number">40</span>, </span><br><span class="line">    <span class="attr">"averageQuantity"</span> : <span class="number">1.5</span>, </span><br><span class="line">    <span class="attr">"count"</span> : <span class="number">2</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="project">$Project</h2><ul><li>Project에서 지정한 필드 값을 다음 파이프라인 단계로 전달</li><li>RDB의 select 와 같은 역할</li><li>Field : 0 - 해당 필드 안보여줌</li><li>Filed : 1 - 해당 필드는 보여줌</li></ul><h3 id="입력형식">입력형식</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $project: &#123; &lt;specification(s)&gt; &#125; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="예제">예제</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_id"</span> : <span class="number">1</span>,</span><br><span class="line">  title: "abc123",</span><br><span class="line">  isbn: "0001122223334",</span><br><span class="line">  author: &#123; last: "zzz", first: "aaa" &#125;,</span><br><span class="line">  copies: 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>title, author 필드만 표시</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.books.aggregate( [ &#123; $project : &#123; title : 1 , author : 1 &#125; &#125; ] )</span><br></pre></td></tr></table></figure></p><h3 id="연산-결과">연산 결과</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"title"</span> : <span class="string">"abc123"</span>, <span class="attr">"author"</span> : &#123; <span class="attr">"last"</span> : <span class="string">"zzz"</span>, <span class="attr">"first"</span> : <span class="string">"aaa"</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p><h2 id="sort">$Sort</h2><ul><li>정렬 조건에 맞게 파이프라인의 연산결과를 정렬</li><li>ASC : 1, DESC : -1로 표현</li></ul><h3 id="입력-형식">입력 형식</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $sort: &#123; &lt;field1&gt;: &lt;sort order&gt;, &lt;field2&gt;: &lt;sort order&gt; ... &#125; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="예제">예제</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">88</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">2</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">92</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">3</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">97</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">4</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">71</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">5</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">79</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">6</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">83</span> &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.users.aggregate(</span><br><span class="line">   [</span><br><span class="line">     &#123; $sort : &#123; score : -1&#125; &#125;</span><br><span class="line">   ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="연산-결과">연산 결과</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">3</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">97</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">2</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">92</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">88</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">6</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">83</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">5</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">79</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">4</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">71</span> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="skip">$Skip</h2><ul><li>입력한 갯수만큼 차례대로 Document를 skip 한 데이터를 다음 파이프라인으로 전달</li></ul><h3 id="입력-형식">입력 형식</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $skip: &lt;positive integer&gt; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="예제">예제</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate(</span><br><span class="line">    &#123; $skip : 5 &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="sample">$Sample</h2><ul><li>Collection 내에서 입력한 갯수만큼 Random하게 Document 출력</li></ul><h3 id="입력-형식">입력 형식</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $sample: &#123; size: &lt;positive integer&gt; &#125; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="예제">예제</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"name"</span> : <span class="string">"dave123"</span>, <span class="attr">"q1"</span> : <span class="literal">true</span>, <span class="attr">"q2"</span> : <span class="literal">true</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">2</span>, <span class="attr">"name"</span> : <span class="string">"dave2"</span>, <span class="attr">"q1"</span> : <span class="literal">false</span>, <span class="attr">"q2"</span> : <span class="literal">false</span>  &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">3</span>, <span class="attr">"name"</span> : <span class="string">"ahn"</span>, <span class="attr">"q1"</span> : <span class="literal">true</span>, <span class="attr">"q2"</span> : <span class="literal">true</span>  &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">4</span>, <span class="attr">"name"</span> : <span class="string">"li"</span>, <span class="attr">"q1"</span> : <span class="literal">true</span>, <span class="attr">"q2"</span> : <span class="literal">false</span>  &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">5</span>, <span class="attr">"name"</span> : <span class="string">"annT"</span>, <span class="attr">"q1"</span> : <span class="literal">false</span>, <span class="attr">"q2"</span> : <span class="literal">true</span>  &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">6</span>, <span class="attr">"name"</span> : <span class="string">"li"</span>, <span class="attr">"q1"</span> : <span class="literal">true</span>, <span class="attr">"q2"</span> : <span class="literal">true</span>  &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">7</span>, <span class="attr">"name"</span> : <span class="string">"ty"</span>, <span class="attr">"q1"</span> : <span class="literal">false</span>, <span class="attr">"q2"</span> : <span class="literal">true</span>  &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.users.aggregate(</span><br><span class="line">   [ &#123; $sample: &#123; size: 3 &#125; &#125; ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="연산-결과">연산 결과</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">2</span>, <span class="attr">"name"</span> : <span class="string">"dave2"</span>, <span class="attr">"q1"</span> : <span class="literal">false</span>, <span class="attr">"q2"</span> : <span class="literal">false</span>  &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">4</span>, <span class="attr">"name"</span> : <span class="string">"li"</span>, <span class="attr">"q1"</span> : <span class="literal">true</span>, <span class="attr">"q2"</span> : <span class="literal">false</span>  &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">7</span>, <span class="attr">"name"</span> : <span class="string">"ty"</span>, <span class="attr">"q1"</span> : <span class="literal">false</span>, <span class="attr">"q2"</span> : <span class="literal">true</span>  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="count">$Count</h2><ul><li>스테이지에 입력하는 문서 수의 카운트가 포함된 문서를 다음 단계로 전달합니다.</li></ul><h3 id="입력-형식">입력 형식</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $count: &lt;string&gt; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="예시-역사-점수-데이터가-있을때">예시 - 역사 점수 데이터가 있을때</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">88</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">2</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">92</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">3</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">97</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">4</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">71</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">5</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">79</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">6</span>, <span class="attr">"subject"</span> : <span class="string">"History"</span>, <span class="attr">"score"</span> : <span class="number">83</span> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="scores-collection에서-80점-초과인-데이터를-조회하고-그에-대한-count를-계산">scores Collection에서 80점 초과인 데이터를 조회하고 그에 대한 Count를 계산</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.scores.aggregate(</span><br><span class="line">  [</span><br><span class="line">    &#123;</span><br><span class="line">      $match: &#123;</span><br><span class="line">        score: &#123;</span><br><span class="line">          $gt: 80</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      $count: "passing_scores"</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="연산-결과">연산 결과</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"passing_scores"</span> : <span class="number">4</span> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="addfield">$addField</h2><ul><li>Document에 새 필드를 추가합니다.</li><li>$addFields는 Document 및 새로 추가된 필드에서 모든 기존 필드가 포함된 문서를 출력합니다.</li><li>실제 Document의 문서 내용을 바꾸는 것이 아닌 조회를 하는 용도</li></ul><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $addFields: &#123; &lt;newField&gt;: &lt;expression&gt;, ... &#125; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="예시-score라는-collection에-아래와-같은-데이터가-있을때">예시 - score라는 collection에 아래와 같은 데이터가 있을때</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  _id: 1,</span><br><span class="line">  student: "Maya",</span><br><span class="line">  homework: [ 10, 5, 10 ],</span><br><span class="line">  quiz: [ 10, 8 ],</span><br><span class="line">  extraCredit: 0</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  _id: 2,</span><br><span class="line">  student: "Ryan",</span><br><span class="line">  homework: [ 5, 6, 5 ],</span><br><span class="line">  quiz: [ 8, 8 ],</span><br><span class="line">  extraCredit: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="집계-연산을-하여-homework-quiz-필드에-대한-array의-합을-기존-document에-추가">집계 연산을 하여, homework, quiz 필드에 대한 Array의 합을 기존 Document에 추가</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.scores.aggregate( [</span><br><span class="line">   &#123;</span><br><span class="line">     $addFields: &#123;</span><br><span class="line">       totalHomework: &#123; $sum: "$homework" &#125; ,</span><br><span class="line">       totalQuiz: &#123; $sum: "$quiz" &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     $addFields: &#123; totalScore:</span><br><span class="line">       &#123; $add: [ "$totalHomework", "$totalQuiz", "$extraCredit" ] &#125; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">] )</span><br></pre></td></tr></table></figure></p><h3 id="연산-결과">연산 결과</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_id"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"student"</span> : <span class="string">"Maya"</span>,</span><br><span class="line">  <span class="attr">"homework"</span> : [ <span class="number">10</span>, <span class="number">5</span>, <span class="number">10</span> ],</span><br><span class="line">  <span class="attr">"quiz"</span> : [ <span class="number">10</span>, <span class="number">8</span> ],</span><br><span class="line">  <span class="attr">"extraCredit"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"totalHomework"</span> : <span class="number">25</span>,</span><br><span class="line">  <span class="attr">"totalQuiz"</span> : <span class="number">18</span>,</span><br><span class="line">  <span class="attr">"totalScore"</span> : <span class="number">43</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_id"</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"student"</span> : <span class="string">"Ryan"</span>,</span><br><span class="line">  <span class="attr">"homework"</span> : [ <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span> ],</span><br><span class="line">  <span class="attr">"quiz"</span> : [ <span class="number">8</span>, <span class="number">8</span> ],</span><br><span class="line">  <span class="attr">"extraCredit"</span> : <span class="number">8</span>,</span><br><span class="line">  <span class="attr">"totalHomework"</span> : <span class="number">16</span>,</span><br><span class="line">  <span class="attr">"totalQuiz"</span> : <span class="number">16</span>,</span><br><span class="line">  <span class="attr">"totalScore"</span> : <span class="number">40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="limit">$limit</h2><ul><li>파이프라인 연산으로 출력된 Document의 갯수를 제한</li></ul><h3 id="입력-형식">입력 형식</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $limit: &lt;positive integer&gt; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="예제">예제</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate(</span><br><span class="line">    &#123; $limit : 5 &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="unwind">$unwind</h2><ul><li>Document내의 배열 필드를 기반으로 각각의 Document로 분리</li></ul><h3 id="입력-형식">입력 형식</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $unwind:</span><br><span class="line">    &#123;</span><br><span class="line">      path: &lt;field path&gt;,</span><br><span class="line">      includeArrayIndex: &lt;string&gt;,</span><br><span class="line">      preserveNullAndEmptyArrays: &lt;boolean&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>path</code></td><td>string</td><td>배열 필드의 필드 경로.&lt;br /&gt;필드 경로를 지정하려면 <code>$</code> 기호를 사용하여 필드 이름에 접두사를 붙이고 따옴표로 묶습니다. (ex : <code>&quot;$arrayField&quot;</code>)</td></tr><tr><td><code>includeArrayIndex</code></td><td>string</td><td>요소의 배열 index값을 저장할 새 필드의 이름. &lt;br /&gt;이름은 달러 기호 &quot;$&quot;로 시작할 수 없습니다. (필수 아님)</td></tr><tr><td><code>preserveNullAndEmptyArrays</code></td><td>boolean</td><td>만약 true로 설정 시, path Field값이 null, 빈 배열인 경우에 <code>$unwind</code> 연산 결과가 Document에 표시 됨.&lt;br /&gt;만약 false로 설정 시,<code>$unwind</code> 연산 결과가 Document에 표시 되지 않음. (default false) (필수 아님)</td></tr></tbody></table><h3 id="예제-1-기본-예제">예제 1 - 기본 예제</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; "_id" : 1, "item" : "ABC1", sizes: [ "S", "M", "L"] &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.aggregate( [ &#123; $unwind : "$sizes" &#125; ] )</span><br></pre></td></tr></table></figure></p><h3 id="연산-결과-1">연산 결과 1</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"item"</span> : <span class="string">"ABC1"</span>, <span class="attr">"sizes"</span> : <span class="string">"S"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"item"</span> : <span class="string">"ABC1"</span>, <span class="attr">"sizes"</span> : <span class="string">"M"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"item"</span> : <span class="string">"ABC1"</span>, <span class="attr">"sizes"</span> : <span class="string">"L"</span> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="예제-2-includearrayindex-속성을-이용한-index-출력">예제 2 - includeArrayIndex 속성을 이용한 Index 출력</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"item"</span> : <span class="string">"ABC"</span>, <span class="attr">"sizes"</span>: [ <span class="string">"S"</span>, <span class="string">"M"</span>, <span class="string">"L"</span>] &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">2</span>, <span class="attr">"item"</span> : <span class="string">"EFG"</span>, <span class="attr">"sizes"</span> : [ ] &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">3</span>, <span class="attr">"item"</span> : <span class="string">"IJK"</span>, <span class="attr">"sizes"</span>: <span class="string">"M"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">4</span>, <span class="attr">"item"</span> : <span class="string">"LMN"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">5</span>, <span class="attr">"item"</span> : <span class="string">"XYZ"</span>, <span class="attr">"sizes"</span> : <span class="literal">null</span> &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.aggregate( [ </span><br><span class="line">    &#123; $unwind: &#123; path: "$sizes", includeArrayIndex: "arrayIndex" &#125; &#125; </span><br><span class="line">] )</span><br></pre></td></tr></table></figure></p><h3 id="연산-결과-2">연산 결과 2</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"item"</span> : <span class="string">"ABC"</span>, <span class="attr">"sizes"</span> : <span class="string">"S"</span>, <span class="attr">"arrayIndex"</span> : NumberLong(<span class="number">0</span>) &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"item"</span> : <span class="string">"ABC"</span>, <span class="attr">"sizes"</span> : <span class="string">"M"</span>, <span class="attr">"arrayIndex"</span> : NumberLong(<span class="number">1</span>) &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"item"</span> : <span class="string">"ABC"</span>, <span class="attr">"sizes"</span> : <span class="string">"L"</span>, <span class="attr">"arrayIndex"</span> : NumberLong(<span class="number">2</span>) &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">3</span>, <span class="attr">"item"</span> : <span class="string">"IJK"</span>, <span class="attr">"sizes"</span> : <span class="string">"M"</span>, <span class="attr">"arrayIndex"</span> : <span class="literal">null</span> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="예제-3-preservenullandemptyarrays-속성을-이용한-출력">예제 3 - preserveNullAndEmptyArrays 속성을 이용한 출력</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"item"</span> : <span class="string">"ABC"</span>, <span class="attr">"sizes"</span>: [ <span class="string">"S"</span>, <span class="string">"M"</span>, <span class="string">"L"</span>] &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">2</span>, <span class="attr">"item"</span> : <span class="string">"EFG"</span>, <span class="attr">"sizes"</span> : [ ] &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">3</span>, <span class="attr">"item"</span> : <span class="string">"IJK"</span>, <span class="attr">"sizes"</span>: <span class="string">"M"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">4</span>, <span class="attr">"item"</span> : <span class="string">"LMN"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">5</span>, <span class="attr">"item"</span> : <span class="string">"XYZ"</span>, <span class="attr">"sizes"</span> : <span class="literal">null</span> &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.aggregate( [</span><br><span class="line">   &#123; $unwind: &#123; path: "$sizes", preserveNullAndEmptyArrays: true &#125; &#125;</span><br><span class="line">] )</span><br></pre></td></tr></table></figure></p><h3 id="연산-결과-3">연산 결과 3</h3><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"item"</span> : <span class="string">"ABC"</span>, <span class="attr">"sizes"</span> : <span class="string">"S"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"item"</span> : <span class="string">"ABC"</span>, <span class="attr">"sizes"</span> : <span class="string">"M"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">1</span>, <span class="attr">"item"</span> : <span class="string">"ABC"</span>, <span class="attr">"sizes"</span> : <span class="string">"L"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">2</span>, <span class="attr">"item"</span> : <span class="string">"EFG"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">3</span>, <span class="attr">"item"</span> : <span class="string">"IJK"</span>, <span class="attr">"sizes"</span> : <span class="string">"M"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">4</span>, <span class="attr">"item"</span> : <span class="string">"LMN"</span> &#125;</span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>https://docs.mongodb.com/master/core/aggregation-pipeline/</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/24/2019-02-24-mongodb-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라</title>
      <link>https://jaehun2841.github.io/2019/02/24/effective-java-item56/</link>
      <guid>https://jaehun2841.github.io/2019/02/24/effective-java-item56/</guid>
      <pubDate>Sun, 24 Feb 2019 07:55:23 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;API를 쓸모 있게 하려면 잘 작성된 문서도 곁들여야 한다.&lt;br&gt;
전통적으로 API는 사람이 직접 작성하므로 코드가 변경되면 매번 함께 수정해야 하는데,&lt;br&gt;
자바에서는 자바독(JavaDoc)이라는 유틸리티
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>API를 쓸모 있게 하려면 잘 작성된 문서도 곁들여야 한다.<br>전통적으로 API는 사람이 직접 작성하므로 코드가 변경되면 매번 함께 수정해야 하는데,<br>자바에서는 자바독(JavaDoc)이라는 유틸리티가 이 귀찮은 작업을 도와준다.</p><p>문서화 주석을 작성하는 규칙은 공식 언어 명세에 속하진 않지만 자바 프로그래머라면 응당 알아야 하는 업계 표준 API라 할 수 있다.</p><h1 id="모든-공개된-리소스에-주석을-달아야-한다">모든 공개된 리소스에 주석을 달아야 한다.</h1><ul><li>API를 올바로 문서화 하려면 공개된 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야 한다.</li><li>직렬화 할 수 있는 클래스라면 직렬화 형태에 대해서도 적어야 한다.</li><li>문서화 주석이 없다면 JavaDoc도 그저 공개 API 요소들의 선언만 나열해 주는게 전부다.</li><li>문서가 잘 갖춰지지 않은 API는 쓰기 헷갈려서 오류의 원인이 되기 쉽다.</li><li>기본 생성자에는 문서화 주석을 달 방법이 없으니 공개 클래스는 절대 기본 생성자를 사용하면 안된다.</li><li>유지 보수까지 고려한다면 대다수의 공개되지 않은 클래스, 인터페이스, 생성자, 메서드, 필드에도 문서화 주석을 달아야 한다.</li></ul><h1 id="메서드용-문서화-주석에는-규약을-명료하게-기술해야-한다">메서드용 문서화 주석에는 규약을 명료하게 기술해야 한다.</h1><ul><li>메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다.</li><li>메서드가 어떻게 동작하는지를 적는게 아니라 무엇을 하는지 기술해야 한다.<br>(how가 아닌 what을 기술해야한다.)</li><li>클라이언트가 해당 메서드를 호출하기 위한 전제조건(precondition)을 모두 나열해야 한다.</li><li>메서드가 성공적으로 수행된 후에 만족해야 하는 사후조건(postcondition)도 모두 나열해야 한다.</li><li>일반적으로 전제조건은 @throw 태그로 비검사 예외를 선언하여 암시적으로 기술한다.<br>비검사 예외 하나가 전제조건 하나와 연결되는 것이다.</li><li>@param 태그를 이용해 그 조건에 영향받는 매개변수에 기술 할 수도 있다.</li></ul><h1 id="전제조건과-사후조건-뿐만-아니라-부작용도-문서화-하라">전제조건과 사후조건 뿐만 아니라 부작용도 문서화 하라</h1><ul><li><strong>부작용</strong>이란 <strong>사후조건으로 명확히 나타나지는 않지만 시스템의 상태에 따라 어떠한 변화</strong>를 가져오는 것을 의미</li><li>예를들어 메서드에서 백그라운드 스레드를 실행시키는 메서드라면 그 사실을 문서에 밝혀야 한다.</li></ul><h1 id="문서화-태그">문서화 태그</h1><ul><li>@param<ul><li>메서드의 파라미터에 대한 정보</li><li>매개변수가 뜻하는 값을 명사구로 쓴다.</li></ul></li><li>@return<ul><li>메서드의 반환타입이 void가 아니라면 반환 타입을 명시</li><li>반환값이 뜻하는 값을 명사구로 작성</li><li>드물게는 산술표현식으로도 작성하기도 한다.</li></ul></li><li>@throws<ul><li>발생가능성이 있는 모든 예외에 대해 명시</li><li>if로 시작해 해당 예외를 던지를 조건을 설명하는 절이 뒤따른다.</li></ul></li><li>@code<ul><li>태그로 감싼 내용을 코드용 폰트로 렌더링한다.</li><li>태그로 감싼 내용에 포함된 HTML 요소나 다른 JavaDoc 태그를 무시한다.</li><li>@기호에는 무조건 탈출문자를 붙여야 하니 문서화 주석안의 코드에서 annotation을 사용한다면 주의해야한다.</li></ul></li><li>@implSpec<ul><li>자기사용 패턴(self-use pattern)에 대해서도 문서에 남겨 다른 프로그래머에게 그 메서드를 올바르게 재정의 하는 방법을 알려야 한다.</li><li>일반적인 문서화 주석은 해당 메서드와 클라이언트 사이의 관계를 설명</li><li>@implSpec 주석은 해당 메서드와 하위 클래스 사이의 관계를 설명하여, 하위 클래스들이 그 메서드를 상속하거나 super 키워드를 이용해 호출할 때 그 메서드가 어떻게 동작하는지를 명확히 인지하고 사용하게 해야 한다.</li><li>-tag &quot;implSpec:a:Implementation Requirement&quot; 스위치를 키지 않으면 @implSpec 태그를 무시</li></ul></li><li>@literal<ul><li>이 태그는 &lt;, &gt;와 같은 HTML 태그를 무시하게 해준다.</li><li>@code와 비슷하지만, 코드 폰트로 렌더링 하지는 않는다.</li><li>A geometric series converges if {@literal |r| &lt; 1}. 처럼 사용 할 수 있다.</li><li>API 문서에서 가독성을 높이기 위해 사용한다.</li></ul></li></ul><p>관례상 @param, @return, @throws 태그의 설명에는 마침표를 붙이지 않는다.<br>(한글로 작성하는 경우에는 온전한 종결어미로 끝나면 마침표를 붙여주는게 일관돼 보인다.)</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This method is &lt;i&gt;not&lt;/i&gt; guaranteed to run in constant time.</span></span><br><span class="line"><span class="comment">* In some implementations it may run in time proportional to the element position.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment">*         (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 이 리스트에서 지정한 위치의 원소를 반환한다.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;이 메서드는 상수시간에 수행됨을 보장하지 &lt;i&gt;않는다.&lt;/i&gt; </span></span><br><span class="line"><span class="comment">* 구현에 따라 원소의 위치에 비례해 시간이 걸릴 수도 있다.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index 반환할 원소의 인덱스</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 이 리스트에서 지정한 위치의 원소</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IndexOutOfBoundsException index가 범위를 벗어나면,</span></span><br><span class="line"><span class="comment">*         즉, (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;) 이면 발생한다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure></p><h1 id="html-태그의-사용">html 태그의 사용</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This method is &lt;i&gt;not&lt;/i&gt; guaranteed to run in constant time.</span></span><br><span class="line"><span class="comment">* In some implementations it may run in time proportional to the element position.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment">*         (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li>위에서 보면 &lt;p&gt;나 &lt;i&gt;와 같은 html 태그가 사용되었다.</li><li>JavaDoc 유틸리티는 문서화 주석을 HTML로 변환하므로 문서화 주석 안의 HTML 요소들이 최종 HTML문서에 반영된다.</li></ul><h1 id="요약-설명">요약 설명</h1><ul><li><p>각 문서화 주석의 첫 번째 문장은 해당 요소의 요약 설명(Summary description)으로 간주된다.</p></li><li><p><code>Returns the element at the specified position in this list.</code> 와 같은 문장이 이에 속한다.</p></li><li><p>첫 번째 <code>.</code> 기호가 나타나기 전까지의 문장을 첫 번째 문장으로 간주한다.</p></li><li><p>예를들어 &quot;머스터드 대령이나 Mrs. 피콕 같은 용의자.&quot;라고 하면 첫 번째 마침표가 나오는<br>&quot;머스터드 대령이나 Mrs.&quot; 까지만 요약 설명이 된다.</p></li><li><p>위와 같은 예제를 해결하기 위해선 @literal을 사용한다.<br>ex)  머스터드 대령이나 {@literal Mrs.} 피콕 같은 용의자.</p></li><li><p>Java 10부터는 {@summary}라는 요약 설명 전용 태그가 추가되어 한번에 사용 가능하다.<br>{@summary 머스터드 대령이나 Mrs. 피콕 같은 용의자.}</p></li><li><p><strong>요약 설명이란, 문서화 주석의 첫 문장이다.</strong> 라고 말하면 살짝 오해의 소지가 있다.<br>주석 작성 규약에 따르면 요약 설명은 완전한 문장이 되는 경우가 드물기 때문이다.<br>메서드와 생성자의 요약 설명은 해당 메서드와 생성자의 동작을 설명하는 (주어가 없는) 동사구여야 한다.</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList(int initialCapacity): Constructs an empty list with the specified initail capacity</span><br><span class="line">Collection.size(): Returns the number of elements in this collection.</span><br></pre></td></tr></table></figure></p></li><li><p>클래스나 인터페이스, 필드의 요약설명은 대상을 설명하는 명사절이어야 한다.<br>클래스와 인터페이스의 대상은 그 인스턴스이고, 필드의 대상은 필드 자신이다.</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instant: An instantaneous point on the time-line (타임라인상의 특정순간(지점))</span><br><span class="line">Math.PI: The double value that is closer than any other to pi, the ratio of the circumference of a circle to its diamter (원주율(pi)에 가장 가까운 double 값)</span><br></pre></td></tr></table></figure></p></li></ul><h1 id="색인index-기능">색인(Index) 기능</h1><ul><li><p>자바 9부터는 JavaDoc이 생성한 HTML 문서에 대해 검색(색인) 기능이 추가되어 광대한 API 문서를 누비는 일이 수월해짐</p></li><li><p>@index 태그를 사용해 API에서 중요한 용어를 추가로 색인화 할 수 있다.</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This method compiles with the &#123;@index IEEE 754&#125; standard.</span><br></pre></td></tr></table></figure></p></li></ul><h1 id="제네릭-타입이나-제네릭-메서드의-주석">제네릭 타입이나 제네릭 메서드의 주석</h1><ul><li>제네릭 타입이나 제네릭 메서드를 문서화 할 때는 모든 타입 매개변수에 주석을 달아야 한다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * An object that maps keys to values.  A map cannot contain duplicate keys;</span></span><br><span class="line"><span class="comment"> * each key can map to at most one value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &lt;K&gt; the type of keys maintained by this map</span></span><br><span class="line"><span class="comment"> * @param &lt;V&gt; the type of mapped values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 키와 값을 매핑하는 객체, 맵은 키를 중복해서 가질 수 없다.</span></span><br><span class="line"><span class="comment"> * 즉, 키 하나가 가리킬 수 있는 값은 최대 1개다.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &lt;K&gt; 이 맵이 관리하는 키의 타입</span></span><br><span class="line"><span class="comment"> * @param &lt;V&gt; 매핑된 값의 타입</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure></p><h1 id="열거타입에는-상수별로-주석을-달아라">열거타입에는 상수별로 주석을 달아라</h1><ul><li>열거 타입을 문서화할 때는 상수들에도 주석을 달아야 한다.</li><li>열거 타입 자체와 열거 타입의 public 메서드도 물론이다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* An instrument section of a symphony orchestra</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OrchestraSection &#123;</span><br><span class="line">    <span class="comment">/** WoodWinds, such as flute, clarinet and oboe */</span></span><br><span class="line">    WOODWIND,</span><br><span class="line">    <span class="comment">/** Brass instruments, such as french horn and trumper */</span></span><br><span class="line">    BRASS,</span><br><span class="line">    <span class="comment">/** Percussion instruments, such as timpani, cymbals */</span></span><br><span class="line">    PERCUSSION,</span><br><span class="line">    <span class="comment">/** Stringed instruments, such as violin and cello */</span></span><br><span class="line">    STRING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="애너테이션-타입을-문서화-할-때는-멤버에도-주석을-달아라">애너테이션 타입을 문서화 할 때는 멤버에도 주석을 달아라</h1><ul><li>애너테이션 타입을 문서화할 때는 멤버들에도 모두 주석을 달아야 한다.</li><li>애너테이션 타입 자체도 물론이다.</li><li>필드 설명은 명사구로 한다.</li><li>애너테이션 타입의 요약 설명은 프로그램 요소에 이 애너테이션을 단다는 것이 어떤 의미인지를 설명하는 동사구로 한다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates that the annotated method is a test method that </span></span><br><span class="line"><span class="comment"> * must throw the designated exception to pass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTest &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  The exception that the annotated test method must throw</span></span><br><span class="line"><span class="comment">     *  in order to pass. (The test is permitted to throw any subtype</span></span><br><span class="line"><span class="comment">     *  of the type described by this class object.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Throwable&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="패키지를-설명하는-문서화-주석은-package-infojava에-작성한다">패키지를 설명하는 문서화 주석은 package-info.java에 작성한다.</h1><ul><li>패키지를 설명하는 문서화 주석은 package-info.java에 명시한다.</li><li>패키지 선언을 반드시 포함해야 하며 패키지 선언관련 애너테이션을 추가로 포함할 수도 있다.</li><li>모듈 시스템을 사용한다면, module-info.java 파일에 작성하면 된다.</li></ul><h1 id="스레드-안전-수준을-반드시-api-설명에-포함해야-한다">스레드 안전 수준을 반드시 API 설명에 포함해야 한다.</h1><ul><li>클래스 혹은 정적 메서드가 스레드 안전하든 그렇지 않든, 스레드 안전 수준을 반드시 API 설명에 포함해야 한다.</li><li>직렬화할 수 있는 클래스라면 직렬화 형태도 API 설명에 기술해야 한다.</li></ul><h1 id="javadoc은-메서드-주석을-상속-시킬-수-있다">JavaDoc은 메서드 주석을 상속 시킬 수 있다.</h1><ul><li>문서화 주석이 없는 API 요소를 발견하면 JavaDoc이 가장 가까운 문서화 주석을 찾아준다.</li><li>상위 클래스보다 구현한 인터페이스 주석을 더 먼저 찾는다.</li><li>@inheritedDoc 태그를 사용해 상위 타입의 문서화 주석 일부를 상속할 수 있다.</li><li>클래스는 자신이 구현한 인터페이스의 문서화 주석을 재사용할 수 있다.</li></ul><h1 id="정리">정리</h1><ul><li><p>문서화 주석은 API를 문서화 하는 가장 훌륭하고 효과적인 방법이다.</p></li><li><p>공개 API라면 빠짐없이 설명을 달아야 한다.</p></li><li><p>표준 규약을 일관되게 지키자.</p></li><li><p>문서화 주석이외에 HTML 태그를 사용할 수 있다.</p></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/24/effective-java-item56/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 55. 옵셔널 반환은 신중히 하라</title>
      <link>https://jaehun2841.github.io/2019/02/24/effective-java-item55/</link>
      <guid>https://jaehun2841.github.io/2019/02/24/effective-java-item55/</guid>
      <pubDate>Sun, 24 Feb 2019 05:04:21 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;자바 8 전에는  메서드가 특정 조건에서 값을 반환할 수 없을 때 취할 수 있는 선택지가 두 가지 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exception Throw
&lt;ul&gt;
&lt;li&gt;예외는 반드시 예외적인 상황에서만 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>자바 8 전에는  메서드가 특정 조건에서 값을 반환할 수 없을 때 취할 수 있는 선택지가 두 가지 있었다.</p><ul><li>Exception Throw<ul><li>예외는 반드시 예외적인 상황에서만 사용해야 한다.</li><li>예외는 실행 스택을 추적(StackTrace)를 캡처하기 때문에 비용이 비싸다.</li></ul></li><li>Null Return<ul><li>null을 리턴하는 경우에는 NPE(Null Pointer Exception)을 항상 조심해야한다.</li></ul></li></ul><p>자바 8이 등장하면서 Optional이라는 또 하나의 선택지가 추가되었다.</p><h1 id="optional-이란">Optional 이란?</h1><ul><li>Optional이란, 값이 있을 수도 있고 없을 수도 있는 객체이다.  참조 타입의 객체를 한번 감싼 일종의 래퍼 클래스 이다.</li><li>Optional은 원소를 최대 1개 가질 수 있는 불변 Collection이다.</li><li>자바 8 이전의 코드보다 null-safe한 로직을 처리 할 수 있게 해준다.</li><li>Optional을 반환하여 좀 더 로직을 유연하게 작성할 수 있게 해준다.</li></ul><h1 id="optional-메서드">Optional 메서드</h1><ul><li><strong>Optional.empty()</strong><ul><li>내부 값이 비어있는 Optional 객체 반환</li></ul></li><li><strong>Optional.of(T value)</strong><ul><li>내부 값이 value인 Optional 객체 반환</li><li>만약 value가 null인 경우 <code>NullPointerException</code> 발생</li></ul></li><li><strong>Optional.ofNullable(T value)</strong><ul><li>가장 자주 쓰이는 Optional 생성 방법</li><li>value가 null이면, empty Optional을 반환하고, 값이 있으면 Optional.of로 생성</li></ul></li><li><strong>T get()</strong><ul><li>Optional 내의 값을 반환</li><li>만약 Optional 내부 값이 null인 경우 <code>NoSuchElementException</code> 발생</li></ul></li><li><strong>boolean isPresent()</strong><ul><li>Optional 내부 값이 null이면 false, 있으면 true</li><li>Optional 내부에서만 사용해야하는 메서드라고 생각</li></ul></li><li><strong>boolean isEmpty()</strong><ul><li>Optional 내부의 값이 null이면 true, 있으면 false</li><li>isPresent() 메서드의 반대되는 메서드</li></ul></li><li><strong>void ifPresent(Consumer&lt;? super T&gt; consumer)</strong><ul><li>Optional 내부의 값이 있는 경우 consumer 함수를 실행</li></ul></li><li><strong>Optional&lt;T&gt; filter(Predicate&lt;T&gt; predicate)</strong><ul><li>Optional에 filter 조건을 걸어 조건에 맞을 때만 Optional 내부 값이 있음</li><li>조건이 맞지 않으면 Optional.empty를 리턴</li></ul></li><li><strong>Optional&lt;U&gt; map(Funtion&lt;? super T, ? extends U&gt; f)</strong><ul><li>Optional 내부의 값을 Function을 통해 가공</li></ul></li><li><strong>T orElse(T other)</strong><ul><li>Optional 내부의 값이 있는 경우 그 값을 반환</li><li>Optional 내부의 값이 null인 경우 other을 반환</li></ul></li><li><strong>T orElseGet(Supplier&lt;? extends T&gt; supplier)</strong><ul><li>Optional 내부의 값이 있는 경우 그 값을 반환</li><li>Optional 내부의 값이 null인 경우 supplier을 실행한 값을 반환</li></ul></li><li><strong>T orElseThrow()</strong><ul><li>Optional 내부의 값이 있는 경우 그 값을 반환</li><li>Optional 내부의 값이 null인 경우 <code>NoSuchElementException</code> 발생</li></ul></li><li><strong>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</strong><ul><li>Optional 내부의 값이 있는 경우 그 값을 반환</li><li>Optional 내부의 값이 null인 경우 exceptionSupplier을 실행하여 Exception 발생</li></ul></li></ul><h1 id="java8-이전의-코드">Java8 이전의 코드</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">School</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassRoom classRoom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassRoom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String subjectName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>학교, 교실, 선생님, 과목이라는 클래스가 주루룩 있을 때 이 학교의 교실의 선생님의 과목을 반환하는 코드를 작성하면</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">school.getClassRoom().getTeacher().getSubject().getSubjectName();</span><br></pre></td></tr></table></figure></p><p>위와 같은 코드를 작성 할 수 있는데, 위와 같은 코드는 전혀 null-safe 하지 않은 코드가 된다.그렇게 null처리를 추가해보면..</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(school != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ClassRoom classRoom = school.getClassRoom();</span><br><span class="line">    <span class="keyword">if</span>(classRoom != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Teacher teacher = classRoom.getTeacher();</span><br><span class="line">        <span class="keyword">if</span>(teacher != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Subject subject = teacher.getSubject();</span><br><span class="line">            <span class="keyword">if</span>(subject != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String subjectName = subject.getSubjectName();</span><br><span class="line">                <span class="keyword">return</span> subjectName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>대충 위와 같은 if 지옥이 발생하게 된다. 조금 다듬어서..</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(school == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassRoom classRoom = school.getClassRoom();</span><br><span class="line"><span class="keyword">if</span>(classRoom == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Teacher teacher = classRoom.getTeacher();</span><br><span class="line"><span class="keyword">if</span>(teacher == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Subject subject = teacher.getSubject();</span><br><span class="line"><span class="keyword">if</span>(subject == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> subject.getSubjectName();</span><br></pre></td></tr></table></figure></p><p>이정도로 바꿀 수 있겠지만, 만족스러운 코드는 아니다.</p><h1 id="optional을-이용한-코드">Optional을 이용한 코드</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(school).map(School::getClassRoom)    <span class="comment">//Optional&lt;School&gt;</span></span><br><span class="line">                           .map(ClassRoom::getTeacher)   <span class="comment">//Optional&lt;ClassRoom&gt;</span></span><br><span class="line">                           .map(Teacher::getSubject)     <span class="comment">//Optional&lt;Teacher&gt;</span></span><br><span class="line">                           .map(Subject::getSubjectName) <span class="comment">//Optional&lt;Subject&gt;</span></span><br><span class="line">                           .orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><ul><li>map 메서드에서 null인 경우 empty Optional을 반환하기 때문에 NPE가 발생하지 않음</li><li>최후에 orElse 구문에서 Optional 내부의 값이 null인 경우 파라미터로 들어간 null을 반환하기 때문에NPE에 안전하다.</li></ul><h1 id="optional을-활용한-예제">Optional을 활용한 예제</h1><h2 id="optional을-사용하지-않은-예제">Optional을 사용하지 않은 예제</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">E <span class="title">max</span><span class="params">(Collection&lt;E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"빈 컬렉션"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    E result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(E e : c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span> || e.compareTo(result) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = Objects.requiredNonNull(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="optional을-사용한-예제">Optional을 사용한 예제</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">Optional&lt;E&gt; <span class="title">max</span><span class="params">(Collection&lt;E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    E result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(E e : c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span> || e.compareTo(result) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = Objects.requiredNonNull(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Optional.of(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>Optional을 반환하여 client에서 더욱 더 유연하게 로직을 작성할 수 있다.</li><li>Optional.of에 null을 넣으면 <code>NullPointerException</code> 이 발생하니 주의해야 한다.</li><li>Optional을 리턴하는 메서드에서는 null을 리턴해서는 안된다. (Optional의 취지와 맞지 않기 때문)</li></ul><h2 id="stream을-이용한-버전">Stream을 이용한 버전</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">Optional&lt;E&gt; <span class="title">max</span><span class="params">(Collection&lt;E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.stream().max(Comparator.naturalOrder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="왜-optional을-사용해야-하는가">왜 Optional을 사용해야 하는가?</h1><p>기존 로직에서는 null을 반환하거나 예외를 던졌는데, Optional이 등장하고 나서는 Optional을 사용하는 것이 좋다고 한다.<br>그걸 구별하는 기준은 무엇일까?  Optional은 검사 예외와 취지가 비슷하다.<br>즉, 반환값이 있을 수도 있고, 없을 수도 있음을 API 사용자에게 명확히 알려준다.<br>만약 비검사 예외를 던지거나 null을 반환한다면 API 사용자가 그 사실을 인지하지 못해 런타임에서 예상치 못한 장애로 발전할 수 있다.<br>하지만 검사 예외(checked Exception)을 던지면 사용자 코드에서는 try-catch 구문을 통해 예외를 처리하는 로직을 추가해야 한다.<br>비슷하게, 메서드가 Optional을 반환한다면 클라이언트는 값을 받지 못했을 때의 취할 행동을 선택해야 한다.<br>그중 하나는 기본값을 설정하는 것이다.</p><h2 id="optional-활용1-기본값defalut를-정해둘-수-있다">Optional 활용1 - 기본값(defalut)를 정해둘 수 있다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String lastWordInLexicon = max(words).orElse(<span class="string">"단어 없음.."</span>);</span><br></pre></td></tr></table></figure></p><ul><li>실제로 예외를 던진 것이 아니라, empty Optional이 리턴되기 때문에예외 생성 비용이 들지 않는다.</li></ul><h2 id="optional-활용2-원하는-예외를-던질-수-있다">Optional 활용2 - 원하는 예외를 던질 수 있다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toy myToy = max(toys).orElseThrow(TemperTantrumException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></p><ul><li>값이 없는 경우 원하는 예외를 던질 수 있다.</li></ul><h2 id="optional-활용3-항상-값이-채워져-있는-경우">Optional 활용3 - 항상 값이 채워져 있는 경우</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element lastNobleGas = max(Elements.NOBLE_GASES).get();</span><br></pre></td></tr></table></figure></p><ul><li>값이 없는 경우에는 NoSuchElementException이 발생하니 반드시 값이 있는 경우에만 사용해야 한다.</li></ul><h2 id="optional-활용4-기본값을-설정하는-비용이-큰-경우">Optional 활용4 - 기본값을 설정하는 비용이 큰 경우</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = getConnection(datasource).orElseGet(() -&gt; getLocalConnection());</span><br></pre></td></tr></table></figure></p><ul><li>기본값을 설정하는 비용이 아주 커서 부담이 되는 경우 orElseGet을 사용하면,<br>값이 처음 필요할 때 Supplier를 사용해 생성하므로 초기 생성비용을 낮출 수 있다.</li></ul><h1 id="optional-안티-패턴">Optional 안티 패턴</h1><h2 id="collection-stream-배열은-optional로-감싸지-말자">Collection, Stream, 배열은 Optional로 감싸지 말자</h2><p>Optional&lt;List&lt;T&gt;&gt;를 반환하기 보다는 빈 ArrayList를 반환하는 것이 좋다. 그렇게 하면 클라이언트 코드에서 Optional 처리 코드를 넣지 않아도 된다.</p><h2 id="optional을-map의-키나-값으로-사용하지-말자">Optional을 Map의 키나 값으로 사용하지 말자</h2><p>만약 Optional을 Map에서 사용한다면 모호한 상황이 발생한다.</p><ul><li>Key 자체가 없는 경우</li><li>Key는 있지만, 속이 빈 Optional인 경우</li></ul><p>쓸데없이 복잡도만 높아지게 되고 전혀 쓸모없는 짓이니 사용하지 말자.<br>일반화 하자면, <strong>Optional은 Collection의 키, 값, 원소나 배열의 원소로 사용하는게 적절한 상황은 거의 없다.</strong></p><h2 id="ispresent를-사용하지-말자">isPresent()를 사용하지 말자</h2><p>위에서 설명 했듯이 isPresent()는 Optional 객체 내부의 값이 있는경우 true, 없는 경우 false를 반환한다.<br>위의 학교예제를 잠시 따오면..</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(school.isPresent()) &#123;</span><br><span class="line">    Optional&lt;ClassRoom&gt; classRoom = school.getClassRoom();</span><br><span class="line">    <span class="keyword">if</span>(classRoom.isPresent()) &#123;</span><br><span class="line">        Optional&lt;Teacher&gt; teacher = classRoom.getTeacher();</span><br><span class="line">        <span class="keyword">if</span>(teacher.isPresent()) &#123;</span><br><span class="line">            Optional&lt;Subject&gt; subject = teacher.getSubject();</span><br><span class="line">            <span class="keyword">if</span>(subject.isPresent()) &#123;</span><br><span class="line">                String subjectName = subject.getSubjectName();</span><br><span class="line">                <span class="keyword">return</span> subjectName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>이와 같이 사용 될 수 있다.  기존의 if 지옥과 별 다를게 없는 로직이며, Optional의 취지를 제대로 이해하지 못한 로직이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(school).map(School::getClassRoom)    <span class="comment">//Optional&lt;School&gt;</span></span><br><span class="line">                           .map(ClassRoom::getTeacher)   <span class="comment">//Optional&lt;ClassRoom&gt;</span></span><br><span class="line">                           .map(Teacher::getSubject)     <span class="comment">//Optional&lt;Teacher&gt;</span></span><br><span class="line">                           .map(Subject::getSubjectName) <span class="comment">//Optional&lt;Subject&gt;</span></span><br><span class="line">                           .orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><p>반드시 이런식으로 사용하도록 하는 것이 좋겠다.</p><h1 id="추가-내용">추가 내용</h1><ul><li>박싱된 기본타입을 사용할 때에는 OptionalInt, OptionalDouble, OptionalLong을 사용하자<ul><li>박싱된 기본타입을 담는 Optional은 기본타입 보다 무거울 수 밖에 없다.</li><li>따라서 OptionalInt, OptionalDouble, OptionalLong을 사용하는 것이 조금 더 낫다.</li></ul></li><li>값을 반환하지 못할 가능성이 있고, 호출할 때마다 반환값이 없을 가능성을 염두에 둬야 하는 메서드라면<br>Optional을 반환해야 하는 상황일 수 있다.</li><li>Optional을 반환값 이외의 용도로 쓰는 경우는 거의 없다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 55. 옵셔널 반환은 신중히 하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/24/effective-java-item55/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Mongo DB 기본쿼리</title>
      <link>https://jaehun2841.github.io/2019/02/20/2019-02-20-mongodb-1/</link>
      <guid>https://jaehun2841.github.io/2019/02/20/2019-02-20-mongodb-1/</guid>
      <pubDate>Wed, 20 Feb 2019 11:53:04 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;mongodb-crud-operation&quot;&gt;MongoDB CRUD Operation&lt;/h1&gt;
&lt;p&gt;Mongo DB는 Create, Read, Update, Delete Operation을 제공합니다.&lt;/p&gt;
&lt;h2 id=&quot;ddl-sql-
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="mongodb-crud-operation">MongoDB CRUD Operation</h1><p>Mongo DB는 Create, Read, Update, Delete Operation을 제공합니다.</p><h2 id="ddl-sql-vs-mongo-db">DDL SQL vs Mongo DB</h2><p><img src="./create_sql_vs_mongo.png" alt="create_sql_vs_mongo"></p><p><img src="./create_sql_vs_mongo_2.png" alt="create_sql_vs_mongo_2"></p><h1 id="create-operations">Create Operations</h1><p>Create, Insert Operation은 컬렉션(Collection)에 도큐먼트(Documents)를 삽입합니다.<br>만약 컬렉션이 아직 존재하지 않는다면, 도큐먼트 삽입과 동시에 컬렉션이 생성됩니다.</p><p>Mongo DB는 아래와 같은 도큐먼트 삽입을 위한 메서드를 제공합니다.</p><ul><li>db.collection.insertOne() <strong>(collection 자리에 실제 collection명을 기재)</strong></li><li>db.collection.insertMany()</li></ul><p>모든 Mongo DB의 삽입 연산은 단일 컬렉션을 대상으로 하며, 모든 쓰기 작업은 단일 도큐먼트에 대해 원자적입니다.</p><p><img src="./insertOne.svg" alt="insertOne"></p><h2 id="insert-sql-vs-mongo-db-insert">Insert SQL vs Mongo DB Insert</h2><p><img src="./insert_sql_vs_mongo.png" alt="insert_sql_vs_mongo"></p><h1 id="read-operations">Read Operations</h1><p>읽기 작업(Read Operations)는 컬렉션에서 도큐먼트(Documents)를 검색합니다. (컬렉션을 쿼리하여 문서를 조회)<br>Mongo DB는 아래와 같은 도큐먼트 조회를 위한 메서드를 제공합니다.</p><ul><li>db.collection.find() <strong>(collection 자리에 실제 collection명을 기재)</strong></li></ul><p>Mongo DB 쿼리 간 filter와 조건을 통해 특정한 도큐먼트를 조회할 수 있습니다.<br><img src="./read-query.svg" alt="read-query"></p><p>위의 쿼리는 SQL로 표현한다면 아래와 같습니다.</p><p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, address</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">users</span></span><br><span class="line"><span class="keyword">WHERE</span> age &gt; <span class="number">18</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p><h2 id="select-sql-vs-mongo-db-read">Select SQL vs Mongo DB Read</h2><p><img src="./read_sql_vs_mongo.png" alt="read_sql_vs_mongo"></p><p><img src="./read_sql_vs_mongo2.png" alt="read_sql_vs_mongo2"></p><p><img src="./read_sql_vs_mongo3.png" alt="read_sql_vs_mongo3"></p><h1 id="update-operations">Update Operations</h1><p>수정 작업 (Update Operations)은 컬렉션 내에 존재하는 도큐먼트를 수정합니다.<br>Mongo DB는 컬렉션 내의 도큐먼트 수정을 위해 아래와 같은 메서드를 제공합니다.</p><ul><li>db.collection.updateOne() <strong>(collection 자리에 실제 collection명을 기재)</strong></li><li>db.collection.updateMany()</li><li>db.collection.replaceOne()</li></ul><p>Mongo DB에서는 단일 컬렉션을 대상으로 update operation을 지원합니다.<br>Mongo DB 내의 모든 쓰기 작업은 단일 도큐먼트 레벨에서 원자적입니다.</p><p><img src="./update-query.svg" alt="update-query"></p><h2 id="update-sql-vs-mongo-db-update">Update SQL vs Mongo DB Update</h2><p><img src="./update_sql_vs_mongo.png" alt="update_sql_vs_mongo"></p><h1 id="delete-operations">Delete Operations</h1><p>삭제 작업 (Delete Operations)은 컬렉션 내의 도큐먼트를 삭제합니다.<br>Mongo DB는 컬렉션 내의 도큐먼트 삭제를 위해 아래와 같은 메서드를 제공합니다.</p><ul><li>db.collection.deleteOne() <strong>(collection 자리에 실제 collection명을 기재)</strong></li><li>db.collection.deleteMany()</li></ul><p>Mongo DB에서의 삭제 작업은 단일 Collection을 대상으로 합니다.<br>Mongo DB 내의 모든 쓰기 작업은 단일 도큐먼트 레벨에서 원자적입니다.</p><p>특정 filter나 조건을 주어 특정한 도큐먼트를 삭제 할 수 있습니다. (Read Operation과 비슷)</p><p><img src="./delete-query.svg" alt="delete-query"></p><h2 id="delete-sql-vs-mongo-db-delete">Delete SQL vs Mongo DB Delete</h2><p><img src="./delete_sql_vs_mongo.png" alt="delete_sql_vs_mongo"></p><h1 id="spring-data-mongodb를-이용한-crud">Spring Data MongoDB를 이용한 CRUD</h1><p>Spring에서 Mongo DB 연동 시에는 spring-data에서 제공하는 spring-data-mongodb를 이용하는게 가장 편리합니다.</p><h1 id="maven-설정">Maven 설정</h1><h2 id="spring-data-mongodb-dependency-추가">spring-data-mongodb dependency 추가</h2><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="mongo-db-querydsl-dependency-추가">Mongo DB QueryDsl Dependency 추가</h2><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.querydsl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>querydsl-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="document-class-build-plugin-설정">Document class Build Plugin 설정</h2><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysema.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apt-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>jpa-processor<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>process<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>target/generated-sources/java<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">processor</span>&gt;</span>com.querydsl.apt.jpa.JPAAnnotationProcessor<span class="tag">&lt;/<span class="name">processor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>mongodb-processor<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>process<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>target/generated-sources/java<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">processor</span>&gt;</span>org.springframework.data.mongodb.repository.support.MongoAnnotationProcessor<span class="tag">&lt;/<span class="name">processor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="entity-생성">Entity 생성</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> by Carrey on 2019-02-20</span></span><br><span class="line"><span class="comment"> * Employee Test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Document</span>(collection = <span class="string">"employee"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String ename;</span><br><span class="line"><span class="keyword">private</span> String job;</span><br><span class="line"><span class="keyword">private</span> Integer mgrId;</span><br><span class="line">    <span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">private</span> LocalDate hiredate;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> sal;</span><br><span class="line"><span class="keyword">private</span> Long commision;</span><br><span class="line">    <span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">private</span> Integer deptId;</span><br><span class="line"><span class="keyword">private</span> String deptName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(DoubleFunction&lt;Long&gt; raiseFormula)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sal = raiseFormula.apply(<span class="keyword">this</span>.sal);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>@Document</strong> : Class가 Mongo DB Document라는 의미를 지정 (collection 속성에 collection 명 지정)</li><li><strong>@Id</strong> : Document내의 ID지정 (_id 필드에 해당 값이 매핑)<br>(주의! <code>org.springframework.data.annotation.Id</code>를 import 해야함)</li><li>JPA에서는 @Entity 클래스의 ID설정이 무조건 필요했지만, Mongo DB는 선택적으로 @Id지정 가능<br>(@Id를 지정하지 않으면 도큐먼트에 <code>ObjectId라는 키가 자동으로 생성됨</code>)</li><li><strong>@Indexed</strong> : Collection Index를 지정 (단일인덱스 여러개 지정가능)(복합 인덱스도 있으나 일단 기술하지 않음)</li></ul><h2 id="repository-생성">Repository 생성</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> by Carrey on 2019-02-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMongoRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">Employee</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="mongorepositoryltt-idgt에서-제공하는-메서드">MongoRepository&lt;T ,ID&gt;에서 제공하는 메서드</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/** CRUDRepository.saveAll */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">&lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">saveAll</span><span class="params">(Iterable&lt;S&gt; entities)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CRUDRepository.findAll */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CRUDRepository.findAll */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;S extends T&gt; <span class="function">S <span class="title">insert</span><span class="params">(S entity)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">insert</span><span class="params">(Iterable&lt;S&gt; entities)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">&lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; example)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">&lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; example, Sort sort)</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="querydsl을-이용한-read-operations">QueryDsl을 이용한 Read Operations</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeRepository</span> <span class="keyword">extends</span> <span class="title">QuerydslRepositorySupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@link</span> QuerydslRepositorySupport&#125; for the given &#123;<span class="doctag">@link</span> MongoOperations&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> operations must not be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EmployeeRepository</span><span class="params">(MongoOperations operations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(operations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2000$가 넘는 고액 연봉자 조회 쿼리</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getCoreEmployees</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">QEmployee qEmployee = QEmployee.employee;</span><br><span class="line">List&lt;Employee&gt; coreEmployees = from(qEmployee).where(qEmployee.sal.gt(<span class="number">2000L</span>))</span><br><span class="line">      .fetch();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> coreEmployees;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>queryDsl 방식의 장점<ul><li>Spring-data 패키지의 메서드를 그대로 쓰기 때문에 JPA에서 사용하던 쿼리와 똑같다.</li></ul></li><li>queryDsl 방식의 단점<ul><li>@Document class를 mongodb-processor를 이용하여 Q클래스로 만들어야 한다.</li><li>Aggregation pipeline을 지원하지 않는다. (가장 큰 단점)</li></ul></li></ul><h1 id="참고">참고</h1><ul><li>https://docs.mongodb.com/master/crud/</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/20/2019-02-20-mongodb-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 48. 스트림 병렬화는 주의해서 적용하라</title>
      <link>https://jaehun2841.github.io/2019/02/17/effective-java-item48/</link>
      <guid>https://jaehun2841.github.io/2019/02/17/effective-java-item48/</guid>
      <pubDate>Sun, 17 Feb 2019 07:34:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;주류 언어 중, 동시성 프로그래밍 측면에서는 항상 자바는 앞서왔다.&lt;br&gt;
처음 릴리즈된 1996년부터 스레드, 동기화, wait/notify를 지원했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바 5부터는 동시성 컬렉션인 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>주류 언어 중, 동시성 프로그래밍 측면에서는 항상 자바는 앞서왔다.<br>처음 릴리즈된 1996년부터 스레드, 동기화, wait/notify를 지원했다.</p><ul><li>자바 5부터는 동시성 컬렉션인 java.util.concurrent 라이브러리와 실행자(Excutor) 프레임워크를 지원했다.</li><li>자바 7부터는 고성능 병렬 분해(parallel decom-position) 프레임워크인 fork-join 패키지를 추가했다.<br>(Fork-join pool에 대한 설명은 https://okky.kr/article/345720 여기 참고)</li><li>자바 8부터는 parallel 메서드만 한 번 호출하면 파이프라인을 병렬 실행할 수 있는 Stream을 지원했다.</li></ul><p>자바로 동시성 프로그램을 작성하기가 점점 쉬워지고 있지만, 이를 올바르고 빠르게 작성하는 일은 어렵다.<br>동시성 프로그래밍을 할 때는 안전성(safety)과 응답 가능(liveness) 상태를 유지하기 애써야 한다.<br>병렬 스트림 파이프라인 프로그래밍에서도 다를 바 없다.</p><h1 id="파이프라인-병렬화가-불가능-한-경우-성능-개선이-되지-않는다">파이프라인 병렬화가 불가능 한 경우 성능 개선이 되지 않는다.</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MersenPrimeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        primes().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))</span><br><span class="line">                .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                .limit(<span class="number">20</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"running time : "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        primes().parallel().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))</span><br><span class="line">                .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                .limit(<span class="number">20</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"running time : "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;BigInteger&gt; <span class="title">primes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(TWO, BigInteger::nextProbablePrime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>스트림을 이용한 처음 20개의 메르센 소수를 생성하는 프로그램이다.<br>이 프로그램을 실행 시켜보니 test1은 8.2초 정도의 수행시간을 보여줬다test2는 stream의 성능을 향상시켜보고자 parallel()을 호출했다.<br>하지만 메르센 소수의 값이 프린트 되지 않았고, 강제로 중지 하기 전까지 계속 돌고 있었다.<br>아무것도 안된 원인은 stream 라이브러리가 이 파이프라인을 병렬화 하는 방법을 찾아내지 못했기 때문이다.</p><ul><li>데이터 소스가 Stream.iterate인 경우</li><li>중간 연산으로 limit()를 사용하는 경우위 두 가지 경우에는 파이프라인 병렬화로 성능 향상을 기대하기 어렵다.<br>뿐만 아니라 파이프라인 병렬화는 limit를 다룰 때 <strong>CPU 코어가 남는다면, 원소를 몇 개 더 처리한 후 제한된 개수 이후의 결과를 버려도 아무런 해가 없다고 가정한다.</strong></li></ul><p>따라서 스트림 파이프라인을 마구잡이로 병렬화 해선 안된다. 성능이 오히려 더 나빠질 수 있다.</p><h1 id="언제-병렬화를-사용하나">언제 병렬화를 사용하나?</h1><ul><li><p>ArrayList</p></li><li><p>HashMap</p></li><li><p>HashSet</p></li><li><p>ConcurrentHashMap</p></li><li><p>배열(Array)</p></li><li><p>int/long 범위</p></li></ul><p>스트림의 데이터 소스가 위와 같은 클래스의 인스턴스 일 때 병렬화의 효과가 가장 좋다.<br>위 자료구조들은 모두 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어 다수의 스레드에 분배하기에 좋다.<br>나누는 작업은 <strong>Spliterator</strong>가 담당하며, Spliterator 객체는 Stream, Iterable의 spliterator() 메서드로 얻어올 수 있다.</p><p>또한 위의 자료구조는 <strong>참조 지역성(locality of reference)</strong> 이 높아 성능이 좋다.</p><h1 id="참조-지역성-locality-of-reference">참조 지역성 (Locality of Reference)</h1><p><img src="./locality.PNG" alt="locality"></p><p>만일 캐시(Cache)가 어떤 별도의 알고리즘 없이 중간 매개체로만 사용된다면,<br>CPU가 Cache에서 데이터를 읽고 쓰는 속도나 메인 메모리에서 읽고 쓰는 속도나 마찬가지가 될 것이다.</p><p>캐시 메모리가 제 역할을 하는 것은 데이터의 지역성(locality)를 이용하기 때문.<br>데이터의 지역성은 다음의 세가지로 분류</p><ul><li>공간적 지역성 (partial locality)<ul><li>메인메모리에서 CPU가 요청한 주소지점의 데이터에 인접한 주소들이 앞으로 참조될 확률이 높음을 의미</li><li>이웃한 원소들의 참조가 메모리에 연속적으로 저장되어 있어 다음 참조에 대한 접근 속도가 빠르게 함</li></ul></li><li>시간적 지역성 (temporal locality)<ul><li>한번 참조되었던 데이터는 후에 다시 참조될 가능성이 높음을 의미</li></ul></li><li>순차적 지역성 (sequential locality)<ul><li>따로 분기가 없는 한 데이터가 기억장치에 저장된 순서대로 인출되고 실행될 가능성이 높음을 의미 (FIFO)</li></ul></li></ul><h1 id="스트림-파이프라인의-종단-연산">스트림 파이프라인의 종단 연산</h1><p>스트림 파이프라인의 종단연산의 동작방식 역시 병렬 수행 효율에 영향을 준다.<br>종단 연산 중 병렬화에 가장 적합한 것은 축소(reduction)이다.<br>축소는 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업이다.<br>예를 들면 min, max, sum, count 같이 완성된 형태로 제공되는 메서드가 있다.<br>anyMatch, allMatch, noneMatch처럼 조건에 맞음년 바로 반환되는 메서드도 병렬화에 적합하다.</p><p>반면, 가변 축소(Mutable Reduction)을 수행하는 Stream의 collect 메서드는 병렬화에 적합하지 않다.컬렉션들을 합치는 부담이 크기 때문이다.</p><h1 id="병렬화에-대해-잘모르면-안하는게-낫다">병렬화에 대해 잘모르면 안하는게 낫다</h1><p>스트림을 잘못 병렬화하면 (응답 불가를 포함해) 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.<br>(결과가 잘못되거나 오동작하는 것은 <strong>안전 실패(safety failure)</strong> 이라 한다.)<br>안전 실패는 병렬화한 파이프라인이 사용하는 mappers, filters 혹은 프로그래머가 제공한 다른 함수 객체가 명시한대로 동작하지 않을 때 발생할 수 있다.</p><p>Stream 명세는 이때 사용되는 함수 객체에 관한 엄중한 규약을 정의해놨다.</p><h2 id="stream-명세는-함수-객체에-대한-규약">Stream 명세는 함수 객체에 대한 규약</h2><ol><li>Stream의 reduce 연산에 건네지는 accumulator(누적기)와 combiner(결합기) 함수는 반드시 <strong>결합법칙</strong>을 만족해야 한다.<br>(결합 법칙 : (a op b) op c = a op (b op c))</li><li>간섭받지 않아야 한다 (non-interfering) - 파이프라인이 수행되는 동안 <strong>데이터소스가 변경되지 않아야한다.</strong></li><li>상태를 갖지 않아야 한다 (stateless)위의 요구사항을 지키지 못하더라도 순차적으로 실행하면 올바른 결과를 얻을 수 있다.<br>하지만 병렬로 수행하면 기대한 결과가 나오지 않을 수 있고, 실패할 수 있으니 주의해야 한다.</li></ol><h1 id="스트림-병렬화는-오직-성능-최적화-수단임을-기억하라">스트림 병렬화는 오직 성능 최적화 수단임을 기억하라</h1><p>다른 최적화와 마찬가지로 변경 전후로 반드시 성능테스트를 진행하여 병렬화를 사용할 가치가 있는지 확인해야 한다.<br>이상적으로는 운영 시스템과 같은 환경에서 테스트하는 것이 좋다.<br>보통은 병렬 스트림 파이프라인도 공통의 포크-조인 풀에서 수행되므로 (같은 스레드 풀을 사용)<br>잘못된 파이프라인 하나가 다른 부분의 성능에까지 악영향을 줄 수 있음을 유념하자<br>조건이 잘 갖춰지면 parallel 메서드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 볼 수 있다.</p><h1 id="스트림-파이프라인-병렬화가-효과적인-예">스트림 파이프라인 병렬화가 효과적인 예</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pi</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">2</span>, n)</span><br><span class="line">                     .mapToObj(BigInteger::valueOf)</span><br><span class="line">                     .filter(i -&gt; i.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                     .count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pi</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">2</span>, n)</span><br><span class="line">                     .parallel()</span><br><span class="line">                     .mapToObj(BigInteger::valueOf)</span><br><span class="line">                     .filter(i -&gt; i.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                     .count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>𝛑(n) : n 보다 작거나 같은 소수의 개수를 계산하는 함수</li><li>책에서는 위의 함수를 실행하는데 31초, 아래 parallel()이 추가된 함수를 실행하는데 9.2초가 걸렸다고 한다.</li></ul><h1 id="random한-수의-경우">Random한 수의 경우</h1><p>무작위 수들로 이뤄진 스트림을 병렬화하려거든 ThreadLocalRandom(혹은 Random) 보다는<br>SplittableRandom 인스턴스를 이용하자. SplittableRandom은 정확히 이럴 때 쓰고자 설계된 것이라<br>병렬화 하면 성능이 선형으로 증가한다. 한편 ThreadLocalRandom은 단일 스레드에서 사용하고자 만들어 졌다.<br>병렬로 사용하는 경우에는 SplittableRandom &gt; SplittableRandom 성능을 보인다.</p><p>그냥 Random의 경우에는 모든 연산을 동기화하기 때문에 병렬 처리하면 최악의 성능을 보일 것이다.</p><h1 id="요약">요약</h1><ul><li>계산도 올바로 수행하고 성능도 빨라질거라는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말자</li><li>스트림 병렬화를 잘못하면 프로그램이 오동작하거나 성능이 급격히 떨어질 수 있다.</li><li>병렬화를 할 경우에는 성능테스트를 반드시 진행하고, 결과가 정확한지 확인해야 한다.</li><li>계산도 정확하고 성능도 좋아졌음이 확실할 때, 그럴 때만 병렬화 버전을 운영 코드에 반영하라</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 48. 스트림 병렬화는 주의해서 적용하라</li><li><a href="https://okky.kr/article/345720" target="_blank" rel="noopener">Thread pool과 ForkJoinPool</a></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/02/17/effective-java-item48/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
