<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Carrey`s 기술블로그</title>
    <link>https://jaehun2841.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 28 Jan 2019 12:46:13 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라</title>
      <link>https://jaehun2841.github.io/2019/01/28/effective-java-item32/</link>
      <guid>https://jaehun2841.github.io/2019/01/28/effective-java-item32/</guid>
      <pubDate>Mon, 28 Jan 2019 10:27:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;가변인수(varargs) 메서드와 제네릭은 Java 5버전에 함께 추가되었다.&lt;br&gt;
서로 잘 어우러지리라 생각하겠지만, 그렇지 않다. 가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>가변인수(varargs) 메서드와 제네릭은 Java 5버전에 함께 추가되었다.<br>서로 잘 어우러지리라 생각하겠지만, 그렇지 않다. 가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는데, 구현방식에 헛점이 있다.<br>가변인수 메서드를 호출하면, 가변인수를 담기 위한 배열이 자동으로 하나 만들어진다.<br>그 결과 varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생한다.</p><p>실제화 불가 타입은 런타임에는 컴파일타임보다 타입관련 정보를 적게 담고 있다<code>(소거)</code></p><h1 id="제네릭과-varargs를-혼용하면-타입-안정성이-깨진다">제네릭과 varargs를 혼용하면 타입 안정성이 깨진다.</h1><p>매개변수화 타입(Parameterize Type (예 List&lt;String&gt;))의 변수가 타입이 다른 객체를 참조하면 <strong>힙 오염</strong>이 발생한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dangerous</span><span class="params">(List&lt;String&gt;... stringLists)</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; intList = List.of(<span class="number">42</span>);</span><br><span class="line">  <span class="comment">//varargs는 내부적으로 배열이고</span></span><br><span class="line">  <span class="comment">//배열은 공변이기 때문에 List&lt;String&gt;타입은 Object의 하위클래스로 인식되어</span></span><br><span class="line">  <span class="comment">//Object[]에 참조 될 수 있다.</span></span><br><span class="line">  Object[] objects = stringLists;</span><br><span class="line">  Object[<span class="number">0</span>] = intList; <span class="comment">//힙 오염 발생</span></span><br><span class="line">  String s = stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// ClassCastException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드를 한줄한줄 분석해보자</p><ol><li>List&lt;String&gt; varargs형태의 파라미터를 받는 메서드이다.</li><li>List&lt;Integer&gt; 제네릭타입 객체를 생성하여 42라는 값을 추가하였다.</li><li>varargs는 내부적으로 배열이고, 배열은 공변이기 때문에 List&lt;String&gt;[] -&gt; Object[]에 참조될 수 있다.</li><li>Object[0] = intList 초기화<br>(내부적으로는 List&lt;String&gt; 타입이지만, 런타임에는 제네릭 타입이 소거되므로 같은 List로만 인식되어 할당이 가능하다. <strong>힙 오염 발생</strong>)</li><li>stringList[0]을 하면 List가 나오고 List의 0번째 인덱스 위치의 객체를 호출해 눈에 보이지 않는 String으로 형변환한다.<br>-&gt; 여기서 ClassCastException이 발생</li></ol><p>이처럼 타입안정성이 깨지기 때문에 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다.<br>(실제로 실무에서는 저런 경우는 거의 없다. 웬만하면 varargs 형태로 받아와서 그대로 사용하기 때문)</p><h1 id="safevarargs">@SafeVarargs</h1><p>자바 7 전에는 제네릭 가변인수 메서드의 작성자가 호출자 쪽에서 발생하는 경고에 대해서 해줄 수 있는 일이 없었다.<br>사용자는 이 경고를 그냥 무시하거나, 사용하는 메서드에서 @SupprssWarning(&quot;unchecked&quot;) annotation을 달아 경고를 숨겨야 했다.<br>자바 7부터 @SafeVarargs annotation이 추가되어 제네릭 가변인수 메서드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있게 되었다.</p><p>단, @SafeVarargs annotation은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치이므로<br>반드시 메서드가 타입 안전한 경우에만 이 annotation을 붙이는 것이 좋다.</p><h2 id="어떤게-타입-안전할까">어떤게 타입 안전할까?</h2><ul><li>가변인수 메서드를 호출하면 varargs 매개변수를 담는 제네릭 배열이 만들어 진다.</li><li>메서드 내에서 이 배열에 아무것도 저장하지 않고, 배열의 참조가 밖으로 노출되지 않는다면 타입 안전하다.</li><li>순수하게 메서드의 생산자 역할만 충실히 하면 메서드는 안전하다.</li></ul><h2 id="자신의-제네릭-매개변수-배열의-참조를-노출하는-것은-위험하다">자신의 제네릭 매개변수 배열의 참조를 노출하는 것은 위험하다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T[] toArray(T... args) &#123;</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T[] pickTwo(T a, T b, T c) &#123;</span><br><span class="line">  <span class="keyword">switch</span>(ThreadLocalRandom.current().nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> toArray(a, b);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> toArray(b, c);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> toArray(c, a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> AssertiionError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  String[] attributes = pickTwo(<span class="string">"좋은"</span>, <span class="string">"빠른"</span>, <span class="string">"저렴한"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>아무 문제가 없는 메서드이니 별다른 문제없이 컴파일 된다.<br>하지만 실행하면 ClassCastException을 던진다.<br>어디서 발생하는 에러일까?</p><p>정답은 바로 String[] attributes = pickTwo(); 메서드에서 보이지 않는 형변환 시 발생한다.</p><p>실제로는 아래와 같다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] attributes = (String[]) pickTwo(<span class="string">"좋은"</span>, <span class="string">"빠른"</span>, <span class="string">"저렴한"</span>);</span><br></pre></td></tr></table></figure></p><p>Object[]는 String[]의 상위타입이 아니므로 형변환할 수 없다.<br>이 예시는 <strong>제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다.</strong> 를 다시금 알려주는 예제이다.</p><p>단 예외가 두 가지 있다.</p><ul><li>@SafeVarargs로 선언된 타입 안전성이 보장된 또 다른 varargs 메서드에 넘기는 것은 안전하다.</li><li>배열 내용의 일부 함수를 호출만 하는 (varargs를 받지않는) 일반 메서드에 넘기는 것도 안전하다.</li></ul><h1 id="제네릭-varargs-매개변수를-안전하게-사용하는-메서드">제네릭 varargs 매개변수를 안전하게 사용하는 메서드</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">flatten</span><span class="params">(List&lt;? extends T&gt;... lists)</span> </span>&#123;</span><br><span class="line">  List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span>(List&lt;? extends T&gt; list : lists) &#123;</span><br><span class="line">    result.addAll(list);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 메서드는 안전하다.<br>varargs 배열을 직접 노출 시키지 않고, T타입의 제네릭 타입을 사용하였기 때문에 ClassCastException 또한 발생할 일이 없다.<br>안전한 varargs 메서드에는 @SafeVarargs annotation을 달아서 컴파일러 경고를 없애는 것이 좋다.</p><h1 id="제네릭-varargs-매개변수를-list로-대체하라">제네릭 varargs 매개변수를 List로 대체하라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">flatten</span><span class="params">(List&lt;List&lt;? extends T&gt;&gt; lists)</span> </span>&#123;</span><br><span class="line">  List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (List&lt;? extends T&gt; list : lists) &#123;</span><br><span class="line">    result.addAll(list);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 방식의 장점은 이 메서드의 타입 안전성을 검증할 수 있다는 점이다.<br>@SafeVarargs를 달지 않아도 되며 실수로 안전하다고 판단할 걱정도 없다.<br>단점은 클라이언트 코드가 살짝 지저분해지고, 속도가 약간 느려질 수 있다는 점이다.</p><h1 id="정리">정리</h1><ul><li>varargs 매개변수는 단순히 파라미터를 받아와 메서드의 생산자(T 타입의 객체를 제공하는 용도)로만 사용하자</li><li>varargs는 read-only라고 생각하고, 아무런 데이터를 저장하지 말자</li><li>varargs 배열을 외부에 리턴하거나 노출하지 말자.<br>웬만하면 다시 컬렉션(List)에 담아 리턴하는 안전한 방식을 취하자</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/28/effective-java-item32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 31. 한정적 와일드 카드(Bounded Wildcard Type)를 사용해 API 유연성을 높여라</title>
      <link>https://jaehun2841.github.io/2019/01/26/effective-java-item31/</link>
      <guid>https://jaehun2841.github.io/2019/01/26/effective-java-item31/</guid>
      <pubDate>Sat, 26 Jan 2019 12:16:50 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Generic에서 매개변수화 타입(Parameterize Type - List&amp;lt;String&amp;gt;)는 불공변이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;공변 vs 불공변
Java에서 배열은 공변(varian
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Generic에서 매개변수화 타입(Parameterize Type - List&lt;String&gt;)는 불공변이다.</p><blockquote><p>공변 vs 불공변Java에서 배열은 공변(variant), Generic은 불공변(invariant)이라 한다.<br>배열의 경우 Object[]과 String[] 간에는 부모-자식 클래스 관계가 성립한다. 이를 공변이라한다.<br>하지만 Generic에서는 List&lt;Object&gt;와 List&lt;String&gt;은 부모-자식 관계가 성립하지 않는다 이를 불공변이라한다.</p></blockquote><p>즉, List&lt;String&gt;은 String타입의 문자열만 넣을 수 있지만, List&lt;Object&gt;는 문자열이건, 숫자건 다 넣을 수 있으므로, 부모클래스에서 가능한 일은 자식클래스에서도 가능해야 한다는 <strong>리스코프 치환원칙</strong>에 위배된다.</p><p>하지만 때로는 불공변 방식보다 유연한 무언가가 필요하다.</p><h1 id="생산자producer-와일드카드-적용">생산자(producer) 와일드카드 적용</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; integers = List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">numberStack.pushAll(integers);</span><br></pre></td></tr></table></figure></p><p>Integer는 Number의 하위타입이기 때문에 잘 동작할 것 같지만, 실제로는 컴파일 시에 오류가 발생한다.</p><p>Parameterize Type이 불공변이기 때문에 Iterator&lt;Number&gt;와 Iterator&lt;Integer&gt;는 부모-자식 관계가 아니다.<br>그렇기 때문에 addAll 메서드의 파라미터로 사용할 수 없는 것이다.</p><p>이런 경우 생산자(producer) 파라미터에 와일드카드 타입을 적용하여 유연하게 만들 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterator&lt;? extends E&gt; iterator)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (E e : iterator) &#123;</span><br><span class="line">    push(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>생산자(producer) 파라미터란, 파라미터로 제공되어 메서드 내에서 사용 될 객체를 공급해 주는 파라미터이다.</p><p><code>&lt;? extends E&gt;</code> 형태로 사용하는 경우 E 타입의 하위타입만 파라미터로 올 수 있게 제약을 거는 것이다.<br><code>모든 타입은 자기 자신의 하위타입이다!</code> 라는 규칙이 있으므로 자기 자신에 대한 타입도 들어올 수 있다.</p><h1 id="소비자consumer-와일드카드-적용">소비자(consumer) 와일드카드 적용</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;E&gt; dst)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!isEmpty()) &#123;</span><br><span class="line">    dst.add(pop());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Collection&lt;Object&gt; objects = List.of(<span class="number">1</span>, <span class="string">"String"</span>);</span><br><span class="line">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure></p><p>컴파일 하게되면 Collection&lt;Object&gt;는 Collection&lt;Number&gt;의 하위타입이 아니다라는 오류가 나온다.<br>이를 해결하기 위해서는 super를 이용해 와일드카드를 작성해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; dst)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!isEmpty()) &#123;</span><br><span class="line">    dst.add(pop());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>소비자(consumer) 파라미터란, 메서드에 제공되어 메서드 내에서 제공되는 객체를 자기 자신이 사용하는 파라미터를 의미한다.</p><h1 id="pecsproducer-extends-consumer-super">PECS(Producer-Extends, Consumer-Super)</h1><p>다음 공식을 외워 어떤 와일드 카드 타입을 쓸지 기억하자</p><ul><li>생산자(producer) - Generic 클래스 내에 타입 파라미터를 이용해 객체를 제공하는 것<ul><li>&lt;? extends E&gt;를 사용하여 유연성을 높일 수 있다.</li></ul></li><li>소비자(consumer) - Generic 클래스 내의 자원을 사용하는 객체를 파라미터로 전달하는 것<ul><li>&lt;? super E&gt;를 사용하여 유연성을 높일 수 있다.</li><li>Comparable, Comparator는 소비자로 사용된다.</li></ul></li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; integers = Set.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Set&lt;Double&gt; doubles = Set.of(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line">Set&lt;Number&gt; numbers = union(integers, doubles);</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</span><br><span class="line">  Set&lt;E&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  set.addAll(integers);</span><br><span class="line">  set.addAll(doubles);</span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 메서드가 만들어지면 타입이 맞지 않는다고 컴파일 오류가 나게 된다.<br>Set&lt;E&gt;은 불공변이기 때문에 Set&lt;Integer&gt;와 Set&lt;Double&gt;은 Set&lt;Number&gt;의 하위타입이 아니기 떄문이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2)</span> </span>&#123;</span><br><span class="line">  Set&lt;E&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  set.addAll(integers);</span><br><span class="line">  set.addAll(doubles);</span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 변경하면 컴파일 오류도 해결되고 잘 실행 된다.이렇게 공통 API를 작성할 때는 와일드 카드를 적절하게 쓰도록 하자.<br>클래스 사용자가 와일드카드 타입을 신경써야 한다면, 그 API에 문제가 있을 가능성이 크다.</p><h2 id="java7에서는">Java7에서는...</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);</span><br></pre></td></tr></table></figure></p><p>위와 같은 형태로 명시적으로 타입인수를 사용해야 한다.<br>타입추론능력이 부족하기 때문이다.</p><h1 id="심화-comparable">심화 - Comparable</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">E <span class="title">max</span><span class="params">(List&lt;E&gt; list)</span></span></span><br></pre></td></tr></table></figure></p><p>와일드카드를 통해 좀 더 다듬은 모습이다.<br><strong>주의: Comparable을 구현한 클래스만 파라미터로 올 수 있다</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function">E <span class="title">ma</span><span class="params">(List&lt;? extends E&gt; list)</span> </span>&#123;</span><br><span class="line">           list.sort(Comparator.reverseOrder());</span><br><span class="line">           <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><ul><li>일반적으로는 Comparable&lt;E&gt;보단 Comparable&lt;? super E&gt;를 사용하는게 낫다. (대부분 소비자로 사용)</li></ul><h1 id="심화2-와일드카드를-적절히-사용하라">심화2 - 와일드카드를 적절히 사용하라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure></p><p>리스트 내의 특정 인자들의 위치를 뒤바꿔주는 메서드이다.<br>어느 메서드가 더 좋을까?</p><p>기본적으로는 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하는 것이 좋다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드는 list.get하는 부분에서 컴파일 오류가 난다.비한정적 와일드카드를 사용하고 있기 때문에 list.set을 하는 경우에는 null밖에 넣을 수가 없다.<br>이런 경우 도우미 메서드를 따로 이용한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 경우에는 List&lt;E&gt;의 리턴타입이 항상 E인 것을 알기 때문에<br>런타임 시, 타입안정성을 보장 할 수 있고 set하는 경우에도 E 타입을 set할 것을 알기 때문에 컴파일 오류 없이 작동 한다.</p><h1 id="정리">정리</h1><p>조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다.<br>그러나 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해야 한다.<br>PECS 공식을 기억하여 생산자에는 extends, 소비자에는 super를 사용하자.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 31. 한정적 와일드 카드(bounded wildcard type)를 사용해 API 유연성을 높여라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/26/effective-java-item31/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 17. 변경 가능성을 최소화하라</title>
      <link>https://jaehun2841.github.io/2019/01/20/effective-java-item17/</link>
      <guid>https://jaehun2841.github.io/2019/01/20/effective-java-item17/</guid>
      <pubDate>Sun, 20 Jan 2019 08:53:58 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;불변-클래스immutable-class란&quot;&gt;불변 클래스(immutable class)란?&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다.&lt;/li&gt;
&lt;li&gt;불변 클래스의 인스턴스는 객체가 생성되는 시점에 초
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="불변-클래스immutable-class란">불변 클래스(immutable class)란?</h1><ul><li>인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다.</li><li>불변 클래스의 인스턴스는 객체가 생성되는 시점에 초기화되고 소멸이 될 때까지 값이 변경되지 않는다.</li><li>불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉽다.</li><li>값이 변경되지 않으니 오류가 발생할 일도 적고 안전하다.</li></ul><h1 id="불변-클래스를-만들기-위한-5가지-조건">불변 클래스를 만들기 위한 5가지 조건</h1><h2 id="객체의-상태를-변경하는-메서드변경자를-제공하지-않는다">객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.</h2><ul><li>쉽게 말해 setter나, 필드 정보를 변경하는 메서드를 제공하지 않는다.</li></ul><h2 id="클래스를-확장-할-수-없도록-한다">클래스를 확장 할 수 없도록 한다.</h2><ul><li>클래스를 final로 선언한다.</li><li>모든 생성자는 private으로 만들고 생성자 정적 팩터리 메서드를 제공한다.</li><li>정적 팩터리 메서드는 유연성을 제공한다.</li><li>다음 릴리즈에서 Boolean처럼 <code>캐싱</code>을 이용해 성능을 끌어올릴 수도 있다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class="line"><span class="meta">@AllArgsConstructor</span>(access = AccessLevel.PRIVATE, staticName=<span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="모든-필드를-final로-선언한다">모든 필드를 final로 선언한다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span>(access = AccessLevel.PRIVATE, staticName=<span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>필드에 대해 수정을 막겠다는 설계자의 의도를 보여준다. - final클래스는 생성자에서 딱 <code>1회 초기화</code> 할 수 있기 때문이다.</li><li>인스턴스에 대한 동기화(syncronized)처리 없이도 다른 스레드에서 문제없이 처리 된다.</li></ul><h2 id="모든-필드를-private로-선언한다">모든 필드를 private로 선언한다.</h2><ul><li>필드가 참조하는 가변 객체를 클라이언트에서 직접 접근하여 수정하는 일을 막는다.</li><li>public final로만 처리해도 되지만, 그 안의 내용을 바꿀 수 있고 다 릴리즈에서 내부 표현을 변경하지 못하므로 사용하지 않는게 좋다.</li></ul><h2 id="자신객체-이외에는-내부의-가변-컴포넌트에-접근-할-수-없도록-한다">자신(객체) 이외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.</h2><ul><li>클라이언트에서 인스턴스 내에 가변 객체의 참조를 얻을 수 없게 해야한다. - Collection에 대한 getter를 제공하면 안된다!</li><li>생성자, 접근자(getter), readObject 메서드에서 모두 <code>방어적 복사</code>를 수행해야 한다.</li></ul><h1 id="함수형-프로그래밍">함수형 프로그래밍</h1><ul><li>피연산자에 함수를 적용해 결과를 반환하는 프로그래밍 기법</li><li>피연산자에 대해 연산하지만 피연산자는 값이 변하지 않음(캡처 - 피연산자는 사실상 final)</li><li>코드의 불변이 영역이 되는 비율이 높아져 안전하다.</li></ul><h1 id="불변-객체의-장점">불변 객체의 장점</h1><ul><li>불변 객체는 생성 시점부터 소멸될 때 까지 변하지 않는다. - 서비스 로직에 더 안전하다.</li><li>불변 객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요가 없다. - 스레드에 따라 값이 변하지 않기 때문이다.</li><li>불변 객체는 안심하고 공유 할 수 있다. - 불변 클래스라면 최대한 재사용 하라 (캐싱)</li><li>불변 객체는 방어적 복사본이 필요없다 - 바뀌지 않으므로 방어할 일이 없다.</li><li>불변 객체는 clone메서드를 제공하지 않는게 좋다. - 의미가 없다.</li><li>불변 객체를 key로 하면 이점이 많다.<ul><li>Map의 key</li><li>Set의 원소</li></ul></li><li>불변 객체는 그 자체로 실패 원자성을 제공한다.<ul><li>메서드에서 예외가 발생하더라도 객체의 변경내용이 없다.</li></ul></li><li>불변 객체끼리는 자유롭게 내부 데이터를 공유 할 수 있다.<ul><li>BigInteger 클래스에서 mag는 크기를 나타내는 배열</li><li>signum은 부호를 나타내는 int 필드</li><li>mag는 배열이지만 불변이므로 방어적 복사본을 만들지 않고 원래 객체의 mag를 써도 된다.</li></ul></li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a BigInteger whose value is &#123;<span class="doctag">@code</span> (-this)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> -this&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(<span class="keyword">this</span>.mag, -<span class="keyword">this</span>.signum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>불변 객체는 값이 다르면 반드시 독립된 객체로 만들어야 한다.</li></ul><h1 id="요약">요약</h1><ul><li>접근자(getter)를 제공한다고 습관처럼 수정자(setter)를 만들지 말자<ul><li>꼭 필요한 경우가 아니라면 클래스는 불변이어야 한다.</li><li>장점이 훨씬많고, 단점이라면 잠재적 성능저하 뿐이다.</li></ul></li><li>불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한 줄이자<ul><li>객체가 가질 수 있는 상태를 제한하면, 예외를 예측하기 쉽고, 오류가 생길 가능성이 줄어든다.</li><li>꼭 변경할 필드가 아닌 필드는 final로 선언하자 - 웬만하면 final로 해야한다.</li></ul></li><li>생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.<ul><li>확실한 이유가 없다면, 생성자와 정적팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안된다.</li><li>특히! 객체를 재활용할 목적으로 상태를 다시 초기화 하는 메서드도 안된다.</li><li>복잡성만 커지고 성능 이점은 거의 없다.</li></ul></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 17. 변경 가능성을 최소화하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/20/effective-java-item17/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/01/20/effective-java-item16/</link>
      <guid>https://jaehun2841.github.io/2019/01/20/effective-java-item16/</guid>
      <pubDate>Sun, 20 Jan 2019 08:53:54 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;퇴보한-클래스&quot;&gt;퇴보한 클래스&lt;/h1&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="퇴보한-클래스">퇴보한 클래스</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> x;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이런 클래스는 데이터 필드에 직접 접근하여 수정이 가능하다. 따라서 캡슐화의 이점을 제공하지 못한다.</p><ul><li>API를 수정하지 않고는 내부 표현을 바꿀 수 없다.</li><li>불변식을 보장할 수 없다.</li><li>외부에서 필드에 접근할 때 부수 작업을 수행 할 수도 없다.(예를들면, x값 조회 시, Comma case로 리턴하는 식의?)</li></ul><h1 id="흔하게-만드는-캡슐레이션">흔하게 만드는 캡슐레이션</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">this</span>.x = x; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">this</span>.y = y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>public 클래스라면 반드시 이정도의 접근자와 수정자를 만드는 정도는 해야된다.</li><li>클래스 내부 표현 방식을 언제든지 바꿀 수 있는 유연성을 제공해야 한다.</li><li>package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다해도 문제가 없다.<ul><li>같은 패키지안에서 특정이유 때문에 사용하던가, 톱레벨 클래스에서만 접근 할 것이기 때문이다.</li></ul></li></ul><h1 id="요약">요약</h1><ul><li>public 클래스는 절대 가변 필드를 노출해선 안된다.</li><li>불변 필드라면 노출해도 덜위험 하지만 그래도 하지 말아라.</li><li>package-private 클래스, 톱 레벨 클래스에서는 노출하는 편이 나을 수도 있다. (글쎄..?)</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/20/effective-java-item16/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 15. 클래스와 멤버의 접근 권한을 최소화하라</title>
      <link>https://jaehun2841.github.io/2019/01/19/effective-java-item15/</link>
      <guid>https://jaehun2841.github.io/2019/01/19/effective-java-item15/</guid>
      <pubDate>Sat, 19 Jan 2019 12:54:32 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;잘 설계된 컴포넌트는 클래스는 모든 내부구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리 해놨다.&lt;br&gt;
오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.&lt;br&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>잘 설계된 컴포넌트는 클래스는 모든 내부구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리 해놨다.<br>오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.<br>정보은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.</p><h1 id="정보-은닉의-장점">정보 은닉의 장점</h1><h2 id="시스템-개발-속도를-높인다">시스템 개발 속도를 높인다.</h2><p>여러가지 컴포넌트를 병렬로 개발할 수 있기 때문이다.예를 들어, 회원탈퇴 기능을 개발한다고 해보자</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithdrawalService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">withdrawalMember</span><span class="params">(Member member)</span></span>;</span><br><span class="line">  <span class="function">List&lt;Member&gt; <span class="title">getMembers</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">WithdrawalProcessType <span class="title">getProcessType</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="title">startProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Member&gt; members = getMembers();</span><br><span class="line">    members.stream().foreach(<span class="keyword">this</span>::withdrawalMember);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이러한 회원탈퇴 로직에 대한 인터페이스를 제공하고,일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴등의 로직이 상이하여 Service를 별도로 구현한다고하는 경우 Interface 스펙에 맞추어 여러 개발자가 개발할 수 있기 때문이다.</p><h2 id="시스템-관리-비용을-낮춘다">시스템 관리 비용을 낮춘다.</h2><p>각 컴포넌트를 빨리 파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.<br>위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 로직에 변경이 생긴 경우<br><code>WithdrawalService</code> interface를 구현한 비회원 탈퇴 서비스를 만들면 되기 때문이다.</p><h2 id="성능-최적화에-도움을-준다">성능 최적화에 도움을 준다.</h2><p>완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있다.<br>위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 중 비회원 탈퇴에 대해 처리대상이 많아 startProcess 메서드를 확장하여 내부적으로 withdrawalMember 메서드를 사용하지 않고 회원 리스트에 대해 쿼리를 이용해 Insert~ Select로 한방에 처리 할 수도 있다.</p><h2 id="소프트웨어-재사용성을-높인다">소프트웨어 재사용성을 높인다.</h2><p>외부에 의존하지 않고, 독자적으로 동작할 수 있는 컴포넌트라면, 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크다.<br>예를들면 알림톡 서버 API를 호출 할 수 있는 인터페이스가 있는 경우 그 인터페이스를 그대로 사용할 수 있다.</p><h2 id="큰-시스템을-제작하는-난이도를-낮춰준다">큰 시스템을 제작하는 난이도를 낮춰준다.</h2><p>시스템 전체가 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있다.<br>쉬운 예로 Mockito를 이용한 TestCase 작성이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(MockitoJUnitRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithdrawalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWithdrawalService</span> <span class="keyword">implements</span> <span class="title">WithdrawalService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">withdrawalMember</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">getMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> TestWithdrawalService testWithdrawalService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMocks</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 회원탈퇴_테스트() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        doReturn(Arrays.asList(<span class="keyword">new</span> Member(<span class="string">"Carrey"</span>))).when(testWithdrawalService).getMembers();</span><br><span class="line">        doCallRealMethod().when(testWithdrawalService).startProcess();</span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        String result = testWithdrawalService.startProcess();</span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        assertThat(result, is(<span class="string">"FINISHED"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="java의-접근제한자">Java의 접근제한자</h1><ul><li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li><li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 할 수 있다.</li><li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li><li>public: 모든 곳에서 접근 할 수 있다.</li></ul><h1 id="모든-클래스와-멤버의-접근성을-가능한-좁혀야-한다">모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.</h1><p>소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다.</p><h2 id="클래스-레벨-접근제한자">클래스 레벨 접근제한자</h2><p>톱레벨 수준(파일명 = 클래스명)이 같은 수준에서의 접근제한자는 public과 package-private만 사용 할 수 있다.</p><ul><li>public으로 선언하는 경우 공개 API로 사용 - 하위호환을 평생 신경써야 한다.</li><li>package-private로 사용하는 경우 해당 패키지 안에서만 사용 가능 - 다음 릴리즈에 내부로직을 변경해도 괜찮다.</li></ul><h2 id="이너클래스-사용하기">이너클래스 사용하기</h2><ul><li>한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 사용하는 클래스 안에 private static으로 중첩해보자</li><li>public일 필요가 없는 클래스의 접근 수준을 package-private로 해보자 - 다른 패키지에서 사용하지 못하게 막아야 한다.</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Shop&gt; shops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Shop&gt; shops;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String owner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="private과-package-private은-해당-클래스의-구현에-해당하므로-공개-api에-영향을-주지-않는다">private과 package-private은 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다.</h2><ul><li>일단 처음에는 모든 멤버는 private으로 만들어야 한다.</li><li>같은 패키지에서 접근해야 하는 멤버가 있는 경우 package-private로 변경</li><li>단, Serialize를 구현한 클래스의 경우 공개 API에 의도치 않게 공개 될 수도 있다.</li><li>필드의 접근 권한을 package-private에서 protected로 바꾸는 순간 필드에 접근 할 수 있는 대상 범위가 늘어나니 주의해야 한다.</li></ul><h2 id="메서드를-재정의-할-경우에는-접근-수준을-상위-클래스에서보다-좁게-설정-할-수-없다">메서드를 재정의 할 경우에는 접근 수준을 상위 클래스에서보다 좁게 설정 할 수 없다.</h2><ul><li>상위 클래스에서 접근제한자가 protected인데 하위클래스에서 갑자기 package-private이나 private로 변경할 수 없다.</li><li>상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환원칙)을 위반하기 때문이다.</li><li>단 인터페이스를 구현하는 경우에는 클래스의 메서드는 모두 public으로 해야 한다.</li></ul><h2 id="코드를-테스트-하려는-목적으로-클래스-인터페이스를-접근-범위를-넓히는-것을-주의하라">코드를 테스트 하려는 목적으로 클래스, 인터페이스를 접근 범위를 넓히는 것을 주의하라</h2><p>public 클래스의 private -&gt; package-private으로 바꾸는거는 괜찮다. 하지만 그이상의 경우 공개 API에 문제가 될 수 있다.</p><h1 id="public-클래스의-인스턴스-필드는-되도록-public이-아니어야-한다">public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.</h1><p>필드가 가변객체를 참조하거나(Collections이나 배열), final이 아닌 인스턴스 필드를 public으로 선언하면 <strong>불변식을 보장할 수 없다.</strong><br>public 가변 필드를 갖는 클래스는 일반적으로 thread safe 하지않다.<br>내부 구현을 바꾸고 싶어도 public 필드를 없애는 방식으로는 리팩터링이 불가하다.</p><p>하지만 상수라면 관례대로 public static final 필드로 공개해도 좋다.<br>필드 명 네이밍은 관례 상 <code>대문자 + _(언더바)</code>로 구성한다.그리고 반드시 불변 객체를 참조하도록 한다.<br>불변성이 깨지는 순간 어마무시한 일이 일어난다.</p><h1 id="클래스에서-public-static-final-배열-필드를-두지말아라">클래스에서 public static final 배열 필드를 두지말아라</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123;...&#125;;</span><br></pre></td></tr></table></figure></p><p>이런 경우 VALUES에 대한 참조를 변경할 수는 없지만, 배열내의 내용을 변경하는 것은 가능하다.</p><h2 id="해결책1-thing-배열을-private로-만들고-public-불변-리스트를-추가한다">해결책1. Thing 배열을 private로 만들고 public 불변 리스트를 추가한다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 해결책2. Thing 배열을 private로 만들고 public 메서드를 추가한다.</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">  <span class="keyword">return</span> PRIVATE_VALUES.clone(); <span class="comment">//방어적 복사본</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="java-9에-추가된-modules-project-jigsaw">Java 9에 추가된 Modules (Project Jigsaw)</h1><p>Java9 부터는 Module시스템이라는 개념이 도입 되었다.</p><p>패키지는 클래스의 묶음인 것 처럼, 모듈(Modules)은 패키지의 묶음이다.모듈은 관례 상, 자신이 속하는 패키지 중 공개(export) 할 것을 선언한다.<br>관례상 <strong>module-info.java</strong> 에 선언한다.모듈을 정의하기 위해 3가지 정보를 작성해야 한다.</p><ol><li>module 명 - module 명칭</li><li>공개할 package (export)</li></ol><ul><li>공개한 package의 public type에 접근제한자만 외부에서 접근할 수 있다.</li><li>만약 export에 적지 않은 패키지의 클래스 중 public 접근제한자가 있어도 접근을 할 수 없다.</li></ul><ol start="3"><li>module내 package의 클래스를 사용하기 위해 종속되는 package (require)</li></ol><ul><li>다른 모듈의 대한 require를 작성하면 다른 모듈에서 export하는 클래스의 public type에 접근이 가능하다</li></ul><h2 id="java-8에서-접근-제한자">Java 8에서 접근 제한자</h2><ul><li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li><li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li><li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li><li>public: 모든 곳에서 접근할 수 있다.</li></ul><h2 id="java-9부터의-접근-제한자">Java 9부터의 접근 제한자</h2><ul><li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.</li><li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li><li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li><li>모듈 내부의 public: 모듈 내부의 모든 곳에서 접근할 수 있다.</li><li>required의 public: 모듈에 종속하는 모듈의 모든 패키지 내의 클래스에 접근할 수 있다.</li><li>export public: module-info.java에서 제공하는 모든 public에 접근할 수 있다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 15. 클래스와 멤버의 접근 권한을 최소화하라</li><li>https://infoscis.github.io/2017/03/24/First-steps-with-java9-and-jigsaw-part-1/</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/19/effective-java-item15/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 14. Comparable을 구현할지 고려하라</title>
      <link>https://jaehun2841.github.io/2019/01/13/effective-java-item14/</link>
      <guid>https://jaehun2841.github.io/2019/01/13/effective-java-item14/</guid>
      <pubDate>Sun, 13 Jan 2019 10:26:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Comparable을 구현하는 이유는 클래스의 인스턴스들간의 Ordering을 목적으로 구현하는 클래스이다.&lt;br&gt;
따라서 Comparable을 구현한 클래스에 대한 배열은 다음처럼 손쉽게 정렬 할 수 있다.&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Comparable을 구현하는 이유는 클래스의 인스턴스들간의 Ordering을 목적으로 구현하는 클래스이다.<br>따라서 Comparable을 구현한 클래스에 대한 배열은 다음처럼 손쉽게 정렬 할 수 있다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(arr);</span><br></pre></td></tr></table></figure></p><p>사실상 자바 플랫폼 라이브러리의 모든 값 클래스와 열거타입은 Compareable을 구현했다.<br>알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면, 반드시 Comparable 인터페이스를 구현하자</p><h1 id="compareto-메서드-규약">compareTo 메서드 규약</h1><p>이 객체와 주어진 객체의 순서를 비교한다.<br>이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 리턴한다.<br>이 객체와 비교할 수 없는 타입이 주어지면 ClassCaseException을 던진다.</p><h2 id="대칭성">대칭성</h2><ul><li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == (y.compareTo(x)) * (-1)을 만족해야 한다.</li><li>따라서 x.compareTo(y)가 예외를 던지는 경우, y.compareTo(x)도 예외를 던져야 한다.</li></ul><h2 id="추이성">추이성</h2><ul><li>Comparable을 구현한 클래스는 모든 x, y, z에 대해 x.compareTo(y) &gt; 0 이고 y.compareTo(z)이면, x.compareTo(z)를 만족해야 한다.</li></ul><h2 id="반사성">반사성</h2><ul><li>Comparable을 구현한 클래스 z는 x.compareTo(y) == 0 이면, sgn(x.compareTo(z)) == sgn(y.compareTo(z))를 만족해야 한다.</li></ul><h2 id="equals">equals</h2><ul><li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) == 0 이면, x.equals(y)를 만족하는 것이 좋다. (권고사항은 아니다.)<br>이 권고를 지키지 않으려면, <code>주의: 이 클래스의 순서는 equals 메서드와 일관되지 않다.</code>라고 명시해 주자.</li></ul><h1 id="equals와-compareto-차이점">equals와 compareTo 차이점</h1><p>compareTo 규약 4번째의 예시로 BigDecimal 클래스가 있다.<br>new Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)이 있다고 할 때 두 객체를 HashSet&lt;Decimal&gt;에 담게 되면 size는 2개가 된다.<br>하지만 TreeSet&lt;Decimal&gt;에 담게 되면 size는 1개가 된다.</p><p>왜 이런 결과가 나올까?<br>HashSet에서는 equals를 기반으로 비교하기 때문에 new Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)은 서로 다른 객체이다. 그렇기 때문에 size가 2개가 된다.<br>하지만 TreeSet에서는 객체에 대한 동치성 비교를 compareTo로 하기 때문에 new Decimal(&quot;1.0&quot;)과 new Decimal(&quot;1.00&quot;)의 compareTo는 0을 리턴한다.<br>따라서 같은 객체로 인식하여 size가 1개가 된다.</p><h1 id="compareto-안티패턴">compareTo 안티패턴</h1><p>compareTo 메서드에서 관계연산자 (<code>&lt;</code> 와 <code>&gt;</code>)를 사용하지 말아야 한다.<br>대신 Type.compare(T t1, T t2)를 사용하여 비교하는 것이 좋다.</p><p>안티 패턴 코드<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; y ? <span class="number">1</span> : (x == y) ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>hashcode의 차를 이용한 비교는 안된다. (추이성에 위배된다.)</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">  (Object o1, Object o2) -&gt; o1.hashCode() - o2.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드 처럼 실행하면, 정수 overflow를 일으키거나 IEEE754 부동소수점 계산방식에 따른 오류를 발생 시킬 수 있다.<br>따라서 아래 코드로 고쳐서 사용하는 것이 좋다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">  (Object o1, Object o2) -&gt; Integer.compare(o1.hashCode(), o2.hashCode())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());</span><br></pre></td></tr></table></figure></p><h1 id="사용-예제">사용 예제</h1><h2 id="기본-타입-필드가-여러-개-일때-비교자">기본 타입 필드가 여러 개 일때 비교자</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PhoneNumber pn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = Short.compare(<span class="keyword">this</span>.areaCode, pn.areaCode);</span><br><span class="line">  <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">    result = Short.compare(<span class="keyword">this</span>.prefix, pn.prefix);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">      result = Short.compare(<span class="keyword">this</span>.line</span><br><span class="line">      Num, pn.lineNum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>필드의 정렬 우선순위를 정해 같은 값이 있을 때 마다 조건을 추가한다.</p><h2 id="비교자-생성-메서드를-이용한-비교자">비교자 생성 메서드를 이용한 비교자</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR </span><br><span class="line">                        = comparingInt((PhoneNumber pn) -&gt; pn.areaCode)  </span><br><span class="line">                                      .thenComparingInt(pn -&gt; pn.prefix)  </span><br><span class="line">                                      .thenComparingInt(pn -&gt; pn.lineNum)</span><br></pre></td></tr></table></figure></p><p>comparingInt라는 static 메서드를 import하여 사용하고, 2번째 조건 부터 thenComparingInt를 사용하여 비교자를 추가 할 수 있다.<br>최초 사용 시, PhoneNumber pn을 사용하여 람다식에서 타입을 추론 할 수 있도록 코드를 추가 하였다.<br>thenComparingInt부터는 자바 컴파일러가 충분히 타입을 추론 할 수 있으므로 명시적으로 지정하지 않았다.<br>Long타입과 Double타입에 대해서는 각각 comparingLong, thenComparingLong과 comparingDouble, thenComparingDouble이 별도로 있다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 14. Comparable을 구현할지 고려하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/13/effective-java-item14/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Shallow Copy와 Deep Copy</title>
      <link>https://jaehun2841.github.io/2019/01/13/java-object-copy/</link>
      <guid>https://jaehun2841.github.io/2019/01/13/java-object-copy/</guid>
      <pubDate>Sun, 13 Jan 2019 09:59:09 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;객체의-복사copy&quot;&gt;객체의 복사(Copy)&lt;/h1&gt;
&lt;p&gt;객체 지향 프로그래밍에서 객체를 복사하는 방법은 크게 두가지로 나뉜다.&lt;br&gt;
얇은 복사(Shallow Copy)와 깊은 복사(Deep Copy)가 있다.&lt;br&gt;
두가지 개념 모
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="객체의-복사copy">객체의 복사(Copy)</h1><p>객체 지향 프로그래밍에서 객체를 복사하는 방법은 크게 두가지로 나뉜다.<br>얇은 복사(Shallow Copy)와 깊은 복사(Deep Copy)가 있다.<br>두가지 개념 모두 원본 객체를 바탕으로 새로운 객체를 만들어 낸다는 점에서는 같지만 미묘한 차이가 있다.</p><p>설명을 진행하기 전에 아래와 같은 Interface를 구현한 객체에 대해 copy가 진행된다고 가정하겠다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Copyable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function">T <span class="title">shallowCopy</span><span class="params">(T t)</span></span>;</span><br><span class="line">   <span class="function">T <span class="title">deepCopy</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="./clone.jpg" alt="clone"></p><h1 id="shallow-copy">Shallow Copy</h1><p>Shallow copy란 원본 객체를 바탕으로 새로운 객체를 생성한 뒤, 내부 필드의 참조에 대해서는 원본 객체와 같은 필드의 참조를 바라보는 형태이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">implements</span> <span class="title">Copyable</span>&lt;<span class="title">Menu</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> Recipe recipe;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Menu <span class="title">shallowCopy</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    Menu copyMenu = <span class="keyword">new</span> Menu(menu.getName(), menu.getPrice(), menu.getRecipe());</span><br><span class="line">    <span class="keyword">return</span> copyMenu;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>불변 객체에 대해서는 같은 객체를 공유한다는 점에서 메모리에 대한 비용을 아낄 수 있다는 장점이 있고, deep copy보다는 빠르다.</p><p>하지만, 가변 객체에 대해서는 원본 객체의 Recipe 객체가 변경되는 경우 의도치 않게 복사한 Recipe도 변경되는 경우가 발생한다.<br>이런 경우에는 Deep Copy를 통해 완전히 분리를 시켜줘야 한다.</p><h1 id="deep-copy">Deep Copy</h1><p>Deep Copy 원본 객체의 타입을 바탕으로 새로운 객체를 생성한 뒤, 내부 필드가 참조하는 객체에 대해서도 새로운 객체를 만들어 주는 방식이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">implements</span> <span class="title">Copyable</span>&lt;<span class="title">Menu</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> Recipe recipe;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Menu <span class="title">deepCopy</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    Menu copyMenu = <span class="keyword">new</span> Menu();</span><br><span class="line">    copyMenu.setName(<span class="keyword">new</span> String(menu.getName));</span><br><span class="line">    copyMenu.setPrice(menu.getPrice());</span><br><span class="line">    copyMenu.setRecipe(Recipe.deepCopy(menu.getRecipe));</span><br><span class="line">    <span class="keyword">return</span> copyMenu;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 필드에 대해 원본객체와 같은 reference를 사용하는 것이 아닌 필드의 reference에 대해서도 새로운 객체를 생성하여 복사하는 방식이다.</p><p>이런 경우 가변객체에 대한 변경에는 안전하다는 장점이 있다.<br>서로 다른 객체를 다루기 떄문에 안전하다.</p><p>하지만 객체 생성 비용이 shallow copy보다 비싸고 상대적으로 느리며,copy하는 객체 수가 많을 수록 메모리를 많이 점유하게 된다는 단점이 있다.</p>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/13/java-object-copy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 13. Clone 재정의는 주의해서 진행하라</title>
      <link>https://jaehun2841.github.io/2019/01/13/effective-java-item13/</link>
      <guid>https://jaehun2841.github.io/2019/01/13/effective-java-item13/</guid>
      <pubDate>Sun, 13 Jan 2019 07:31:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Cloneable은 복제해도 되는 인터페이스 임을 명시하는 용도의 믹스인 인터페이스이다.&lt;br&gt;
하지만 아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone메서드가 선언된 곳이 Cloneab
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Cloneable은 복제해도 되는 인터페이스 임을 명시하는 용도의 믹스인 인터페이스이다.<br>하지만 아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라는데 있다. 그래서 Cloneable을 구현하는 것만으로는 외부에서 clone 메서드를 호출 할 수 없다.</p><h1 id="cloneable-인터페이스는-무슨일을-할까">Cloneable 인터페이스는 무슨일을 할까?</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to</span></span><br><span class="line"><span class="comment"> * indicate to the &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; method that it</span></span><br><span class="line"><span class="comment"> * is legal for that method to make a</span></span><br><span class="line"><span class="comment"> * field-for-field copy of instances of that class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Invoking Object's clone method on an instance that does not implement the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, classes that implement this interface should override</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Object.clone&#125; (which is protected) with a public method.</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; for details on overriding this</span></span><br><span class="line"><span class="comment"> * method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &#123;<span class="doctag">@code</span> clone&#125; method.</span></span><br><span class="line"><span class="comment"> * Therefore, it is not possible to clone an object merely by virtue of the</span></span><br><span class="line"><span class="comment"> * fact that it implements this interface.  Even if the clone method is invoked</span></span><br><span class="line"><span class="comment"> * reflectively, there is no guarantee that it will succeed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#clone()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>자바의 Cloneable 인터페이스를 보면 아무런 메서드도 없다.<br>아무것도 없지만, 사실은 Object의 clone메서드의 동작방식을 결정한다.<br>Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면, 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면, <code>ClassNotSupportedException</code>을 던진다.</p><h1 id="object-클래스의-clone-규약">Object 클래스의 clone 규약</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns a copy of this object.  The precise meaning</span></span><br><span class="line"><span class="comment"> * of "copy" may depend on the class of the object. The general</span></span><br><span class="line"><span class="comment"> * intent is that, for any object &#123;<span class="doctag">@code</span> x&#125;, the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be true, and that the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, but these are not absolute requirements.</span></span><br><span class="line"><span class="comment"> * While it is typically the case that:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the returned object should be obtained by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> super.clone&#125;.  If a class and all of its superclasses (except</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Object&#125;) obey this convention, it will be the case that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> x.clone().getClass() == x.getClass()&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment"> * of this object (which is being cloned).  To achieve this independence,</span></span><br><span class="line"><span class="comment"> * it may be necessary to modify one or more fields of the object returned</span></span><br><span class="line"><span class="comment"> * by &#123;<span class="doctag">@code</span> super.clone&#125; before returning it.  Typically, this means</span></span><br><span class="line"><span class="comment"> * copying any mutable objects that comprise the internal "deep structure"</span></span><br><span class="line"><span class="comment"> * of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment"> * objects with references to the copies.  If a class contains only</span></span><br><span class="line"><span class="comment"> * primitive fields or references to immutable objects, then it is usually</span></span><br><span class="line"><span class="comment"> * the case that no fields in the object returned by &#123;<span class="doctag">@code</span> super.clone&#125;</span></span><br><span class="line"><span class="comment"> * need to be modified.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The method &#123;<span class="doctag">@code</span> clone&#125; for class &#123;<span class="doctag">@code</span> Object&#125; performs a</span></span><br><span class="line"><span class="comment"> * specific cloning operation. First, if the class of this object does</span></span><br><span class="line"><span class="comment"> * not implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125;, then a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> CloneNotSupportedException&#125; is thrown. Note that all arrays</span></span><br><span class="line"><span class="comment"> * are considered to implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125; and that</span></span><br><span class="line"><span class="comment"> * the return type of the &#123;<span class="doctag">@code</span> clone&#125; method of an array type &#123;<span class="doctag">@code</span> T[]&#125;</span></span><br><span class="line"><span class="comment"> * is &#123;<span class="doctag">@code</span> T[]&#125; where T is any reference or primitive type.</span></span><br><span class="line"><span class="comment"> * Otherwise, this method creates a new instance of the class of this</span></span><br><span class="line"><span class="comment"> * object and initializes all its fields with exactly the contents of</span></span><br><span class="line"><span class="comment"> * the corresponding fields of this object, as if by assignment; the</span></span><br><span class="line"><span class="comment"> * contents of the fields are not themselves cloned. Thus, this method</span></span><br><span class="line"><span class="comment"> * performs a "shallow copy" of this object, not a "deep copy" operation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The class &#123;<span class="doctag">@code</span> Object&#125; does not itself implement the interface</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Cloneable&#125;, so calling the &#123;<span class="doctag">@code</span> clone&#125; method on an object</span></span><br><span class="line"><span class="comment"> * whose class is &#123;<span class="doctag">@code</span> Object&#125; will result in throwing an</span></span><br><span class="line"><span class="comment"> * exception at run time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>     a clone of this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  CloneNotSupportedException  if the object's class does not</span></span><br><span class="line"><span class="comment"> *               support the &#123;<span class="doctag">@code</span> Cloneable&#125; interface. Subclasses</span></span><br><span class="line"><span class="comment"> *               that override the &#123;<span class="doctag">@code</span> clone&#125; method can also</span></span><br><span class="line"><span class="comment"> *               throw this exception to indicate that an instance cannot</span></span><br><span class="line"><span class="comment"> *               be cloned.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Cloneable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p><p>Object에 명시된 clone 규약이 주석으로 쓰여져 있다.</p><ul><li>x.clone() != x은 참이다.<br>복사한 객체와 원본 객체는 서로 다른 객체이다.</li><li>x.clone() .getClass() == x.getClass()은 일반적으로 참이다.하지만 반드시 만족해야 하는 것은 아니다.</li><li>x.clone.equals(x) 은 참이다.<br>복사한 객체와 원본객체는 논리적 동치성이 같다.</li><li>x.clone().getClass() == x.getClass()은 참이다.<br>관례상, 이 방법으로 반환된 객체는 독립성이 있어야 한다.<br>이를 만족하려면 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.</li><li>Cloneable을 구현하지 않은 클래스의 경우, CloneNotSupportedException이 throw된다.</li><li>모든 Array는 Cloneable을 구현하도록 고려되었다. clone 메서드는 T[]를 리턴하도록 설계</li><li>T는 기본타입 또는 참조타입으로 설계</li><li>기본적으로 Object.clone은 clone대상 클래스에 대해 새로운 객체를 new로 생성</li><li>모든 필드들에 대해 초기화를 진행</li><li>하지만 필드에 대한 객체를 다시 생성하지 않는 Shallow copy 방식으로 수행한다 (deep copy아님)</li><li>클래스에 대한 복제본을 원하지 않는 경우 clone메서드를 재정의하여 CloneNotSupportedException을 throw하도록 함</li></ul><h1 id="clone-메서드-재정의-시-주의할-점">clone 메서드 재정의 시, 주의할 점</h1><h2 id="기본적인-clone메서드-재정의">기본적인 clone메서드 재정의</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PhoneNumber <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (PhoneNumber) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ClassNotSupportedException e) &#123;</span><br><span class="line">      <span class="comment">//아무처리를 하지 않거나, RuntimeException으로 감싸는 것이 사용하기 편하다.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>super.clone()을 실행하면 PhoneNumber에 대한 완벽한 복제가 이루어진다.</li><li>super.clone()의 리턴 타입은 Object이지만, 자바의 공변 반환타이핑 기능을 통해 PhoneNumber 타입으로 캐스팅하여 리턴하는 것이 가능하다.<br>(추천하는 기능)</li><li>try-catch 부분으로 감싼것은 super.clone() 메서드에서 ClassNotSupportedException이라는 checked exception을 리턴하기 떄문에 처리 해주었다.<ul><li>하지만 PhoneNumber가 Cloneable을 구현하기 떄문에 절대 실패하지 않는다.<br>따라서 이부분은 RuntimeException으로 처리하거나, 아무것도 설정하지 않아야 한다.</li></ul></li></ul><h2 id="가변-상태를-갖는-필드에-대한-복제">가변 상태를 갖는 필드에 대한 복제</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object[] elements;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Stack <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Stack result = (Stack) <span class="keyword">super</span>.clone();</span><br><span class="line">      result.elements = </span><br><span class="line">    &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 클래스가 단순히 clone메서드를 이용해 super.clone()만 실행하게 된다면,<br>new Stack()을 통해 새로운 객체가 생성되고 필드모두 원본 객체와 동일하게 초기화가 될 것이다.<br>하지만, 위에서 얘기한 Object의 clone 기본규약에는 Deep copy가 아닌 Shallow Copy를 이용해 초기화를 진행한다고 적혀있다.<br>따라서 배열과 같은 가변필드는 원본 필드와 객체를 공유하게 된다.</p><p>Clone메서드는 사실상 생성자와 같은 효과를 낸다.<br>즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.<br>그렇기 때문에 제대로 복제하기 위해서는, elements라는 배열을 똑같이 복사해서 만들어줘야 한다.</p><h2 id="배열-복사">배열 복사</h2><p>배열을 복제하는 방법 중 가장 권장하는 방법은array.clone()을 이용해 복사하는 방법이다.<br>사실, 배열은 clone기능을 가장 제대로 사용하는 유일한 예이다.</p><p>하지만, array 필드가 final이 적용되어 있다면 array.clone()을 통한 초기화는 할 수 없다. (final이기 떄문에 객체 생성 이후 초기화 불가)<br><strong>Cloneable 아키텍처는 가변객체를 참조하는 필드는 final로 선언하라 라는 일반 용법과 충돌한다.</strong><br>그래서 복제 할 수 있는 클래스를 만들기 위해 일부 필드에서 final 한정자를 제거해야 할 수도 있다.</p><h2 id="stack-overflow-문제">Stack overflow 문제</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Entry[] buckets = ...;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object key;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry next;</span><br><span class="line"></span><br><span class="line">    Entry(Object key, Object value, Entry next) &#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HashTable <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      HashTable result = (HashTable) <span class="keyword">super</span>.clone();</span><br><span class="line">      result.buckets = buckets.clone();</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Assertion();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>복제본은 자신만의 버킷 배열은 갖지만, 배열내의 Entry는 원본과 같은 연결리스트를 참조하여, 불변성이 꺠지게 된다.</p><p>그래서 HashTable.Entry 클래스는 내부적으로 deep copy를 지원하도록 보강되었다. 연결리스트에 대한 next를 복제할 때 재귀적으로 clone을 호출하도록 되어있는데, 재귀 호출 떄문에 연결리스트의 size만큼 스택프레임을 소비하여, 리스트가 길면 stackoverflow에러를 발생시킬 위험이 있다.<br>이 문제를 해결하기 위해서는 재귀 호출을 통한 deepcopy대신 반복자를 써서 순회하는 방법으로 수정해야 한다.</p><h2 id="안전하지만-느린-copy">안전하지만 느린 copy</h2><p>HashTable을 예로 들면, buckets필드를 새로운 배열로 초기화 한다음 원본테이블의 있는 버킷의 내용을 put(key, value) 메서드를 호출해<br>새로 버킷을 만드는 방법이 있다.<br>이 방법은 안전하긴 하지만, low level에서 작동하는 copy보다는 느리다.</p><h2 id="생성자-내에서는-재정의-될-수-있는-메서드를-호출-하지-말자">생성자 내에서는 재정의 될 수 있는 메서드를 호출 하지 말자</h2><p>만약 clone이 하위 클래스에서 재정의한 메서드를 호출하면, 하위 클래스는 복사과정에서 자신의 상태를 교정할 기회를 잃게되어<br>원본과 복제본의 상태가 달라질 수 있다.</p><h2 id="classnotsupportedexception">ClassNotSupportedException</h2><p>Object의 clone메서드는 CloneNotSupportedException을 던진다고 선언했지만 재정의한 메서드는 그렇지 않다.<br>public인 clone 메서드에서는 throws절을 없애던가, RuntimeException으로 throws 해야한다.<br>그렇지 않으면 clone 메서드를 호출 할 떄마다, 예외처리를 해야 해서 사용하기가 불편하다.</p><p>하위 클래스에서 Clone을 방지하기 위해 동작하지 않게 만들수도 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="스레드-안전성을-고려한다면-적절히-동기화해야-한다">스레드 안전성을 고려한다면 적절히 동기화해야 한다.</h2><p>스레드 안정성을 고려한다면 clone 메서드에 대해 적절히 동기화 처리 해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object result = <span class="keyword">super</span>.clone();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="복사-생성자와-복사-팩터리-메서드">복사 생성자와 복사 팩터리 메서드</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Yum</span><span class="params">(Yum yum)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Yum <span class="title">newInstance</span><span class="params">(Yum yum)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>복사 생성자와 복사 팩터리 메서드는 Cloneable/clone 방식보다 나은 면이 많다.</p><ul><li>언어 모순적이고 위험한 객체 생성 메커니즘을 사용하지 않는다. (super.clone())</li><li>clone 규약에 기대지 않는다.</li><li>정상적인 final필드 용법과도 충돌하지 않는다.</li><li>불필요한 check exception 처리가 필요없다.</li><li>형변환도 필요없다.</li><li>복사 생성자와 복사 팩터리는 인터페이스 타입의 인스턴스를 인수로 받을 수 있다.</li></ul><h1 id="deep-copy-vs-shallow-copy">Deep copy vs Shallow copy</h1><p><a href="http://localhost:4000/2019/01/13/java-object-copy" target="_blank" rel="noopener">Shallow Copy와 Deep Copy</a> - 이 포스팅을 참고하자</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 13. clone 재정의는 주의해서 진행하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/13/effective-java-item13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 12. toString을 항상 재정의하라</title>
      <link>https://jaehun2841.github.io/2019/01/13/effective-java-item12/</link>
      <guid>https://jaehun2841.github.io/2019/01/13/effective-java-item12/</guid>
      <pubDate>Sun, 13 Jan 2019 05:59:25 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Object의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.&lt;br&gt;
이 메서드는 &lt;code&gt;PhoneNumber@adbbd&lt;/code&gt;처럼 단순히 &lt;stron
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Object의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.<br>이 메서드는 <code>PhoneNumber@adbbd</code>처럼 단순히 <strong>클래스이름@16진수로_표현한_해시코드</strong>를 반환할 뿐이다.<br>toString의 일반 규약에 따르면, <code>간결하면서 사람이 읽기 쉬운 형태의 유익한 정보</code>를 반환해야 한다.<br>toString의 규악은 <code>모든 하위클래스에서 이 메서드를 재정의하라</code>라고 하고 있다.</p><h1 id="tostring을-재정의-해야하는-이유">toString을 재정의 해야하는 이유</h1><ul><li>toString을 잘 구현한 클래스는 사용하기 편하고, 그 클래스에 대해 디버깅 하기 쉽다.<ul><li>map객체를 출력하는 경우 <code>{Jenny=PhoneNumber@addbb}</code> 보다는 <code>{Jenney=707-867-5308}</code>이라는 메세지가 가독서이 좋다.</li></ul></li><li>실전에서는 toString메서드를 재작성 할 때, 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.</li><li>toString을 구현할 때면 반환값의 포맷을 문서화 할 지 정해야 한다.<ul><li>포맷을 명시하면, 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다.</li><li>포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</li><li>단, 포맷을 한번 명시하면, 평생 그 포맷에 얽매이게 된다.</li><li>포맷을 명시하지 않는다면 다음 릴리즈에 포맷을 변경할 수 있는 유연성을 더 가져갈 수 있다.</li></ul></li><li>포맷을 명시하든 아니든, 개발자의 의도는 명확히 밝혀야 한다.</li><li>toString이 반환한 값에 대해 포함된 정보를 얻어올 수 있는 API를 제공하자<ul><li>toString에 있는 getter를 제공하지 않는다면, 클라이언트에서 toString을 파싱하여 사용할 지도 모른다.</li></ul></li></ul><h2 id="포맷을-명시하기로-했으면-명시한-포맷에-맞는-문자열과-객체를-상호전환-할-수-있는-정적-팩터리나-생성자를-함께-제공하면-좋다">포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> toString테스트() &#123;</span><br><span class="line">        String phoneNumber = <span class="string">"707-908-9999"</span>;</span><br><span class="line">        assertEquals(PhoneNumber.parse(phoneNumber), <span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">908</span>, <span class="number">9999</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>(expected = UnknownFormatConversionException.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 파싱문자열_오류_테스트() &#123;</span><br><span class="line">        String phoneNumber = <span class="string">"707-908"</span>;</span><br><span class="line">        assertEquals(PhoneNumber.parse(phoneNumber), <span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">908</span>, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer areaCode;</span><br><span class="line">        <span class="keyword">private</span> Integer prefix;</span><br><span class="line">        <span class="keyword">private</span> Integer lineNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern phoneNumberPattern = Pattern.compile(<span class="string">"^\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;4&#125;$"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PhoneNumber pn = (PhoneNumber) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.areaCode.equals(pn.areaCode)</span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.prefix.equals(pn.prefix)</span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.lineNum.equals(pn.lineNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result = Integer.hashCode(areaCode);</span><br><span class="line">            result = <span class="number">31</span> * result + Integer.hashCode(prefix);</span><br><span class="line">            result = <span class="number">31</span> * result + Integer.hashCode(lineNum);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">"%03d-%03d-%04d"</span>, areaCode, prefix, lineNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PhoneNumber <span class="title">parse</span><span class="params">(String phoneNumber)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!phoneNumberPattern.matcher(phoneNumber).find()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnknownFormatConversionException(phoneNumber + <span class="string">" cannot be parsed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] numbers = phoneNumber.split(<span class="string">"-"</span>);</span><br><span class="line">            <span class="keyword">return</span> PhoneNumber.builder()</span><br><span class="line">                    .areaCode(Integer.parseInt(numbers[<span class="number">0</span>]))</span><br><span class="line">                    .prefix(Integer.parseInt(numbers[<span class="number">1</span>]))</span><br><span class="line">                    .lineNum(Integer.parseInt(numbers[<span class="number">2</span>]))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="tostring을-따로-재정의-안해도-되는-경우">toString을 따로 재정의 안해도 되는 경우</h1><ul><li>정적 Utils 클래스는 따로 재정의 하지 않아도 된다.(객체의 상태(state)를 가지는 클래스가 아니기 떄문)</li><li>enum 타입 또한 이미 완벽한 toString을 제공한다.</li><li>대다수의 컬렉션 구현체는 추상 컬렉션 클래스(AbstractMap, AbstractSet등)의 toString 메서드를 상속하여 쓴다.</li><li>라이브러리를 통해 자동생성하자<ul><li>구글의 @Autovalue</li><li>Lombok의 @ToString</li><li>위의 라이브러리들을 이용해 자동생성하는 편이 더 간편하다.</li></ul></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 12. toString을 항상 재정의하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/13/effective-java-item12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 11. Equals를 재정의하려거든 Hashcode도 재정의하라</title>
      <link>https://jaehun2841.github.io/2019/01/12/effective-java-item11/</link>
      <guid>https://jaehun2841.github.io/2019/01/12/effective-java-item11/</guid>
      <pubDate>Sat, 12 Jan 2019 13:22:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;equals를 재정의한 클래스에서는 hashcode도 재정의 해야한다.&lt;/code&gt;&lt;br&gt;
그렇지 않으면 hash를 사용하는 HashMap, HashSet과 같은 컬렉션의 원소로 사용될 때 문제가 발
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p><code>equals를 재정의한 클래스에서는 hashcode도 재정의 해야한다.</code><br>그렇지 않으면 hash를 사용하는 HashMap, HashSet과 같은 컬렉션의 원소로 사용될 때 문제가 발생할 것이다.</p><p>이번 글을 읽기 전에 아래 글을 먼저 읽어 해시, 해시테이블에 대한 용어를 먼저 익히는 것이 도움이 될 것 같다.</p><ul><li><a href="http://bcho.tistory.com/1072" target="_blank" rel="noopener">해쉬 테이블의 이해와 구현 (Hashtable) - 조대협의 블로그</a></li><li><a href="https://d2.naver.com/helloworld/831311" target="_blank" rel="noopener">Java HashMap은 어떻게 동작하는가? - Naver D2</a></li></ul><h1 id="hashcode의-규약">hashcode의 규약</h1><ul><li>equals비교에 사용되는 정보가 변경되지 않았다면, 객체의 hashcode 메서드는 몇번을 호출해도 항상 일관된 값을 반환해야 한다.<br>(단, Application을 다시 실행한다면 값이 달라져도 상관없다. (메모리 소가 달라지기 때문))</li><li>equals메서드 통해 두 개의 객체가 같다고 판단했다면, 두 객체는 똑같은 hashcode 값을 반환해야 한다.</li><li>equals메서드가 두 개의 객체를 다르다고 판단했다 하더라도, 두 객체의 hashcode가 서로 다른 값을 가질 필요는 없다. (Hash Collision)<br>단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.</li></ul><h1 id="equals-메서드는-재정의했지만-hashcode를-재정의하지-않은-경우">equals 메서드는 재정의했지만, hashcode를 재정의하지 않은 경우</h1><p>hashcode의 규약 2번째 조건을 위반하는 행위이다.<br>Effective Java 11장에서 설명하는 PhoneNumber 클래스를 생성해 테스트 해 보았다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashCodeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hashcode_재정의() &#123;</span><br><span class="line">        HashMap&lt;ExtendedPhoneNumber, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>), <span class="string">"제니"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Instance 1 hashcode : "</span> + <span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        System.out.println(<span class="string">"Instance 2 hashcode : "</span> + <span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        Assert.assertEquals(map.get(<span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>)), <span class="string">"제니"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hashcode_재정의안함() &#123;</span><br><span class="line">        HashMap&lt;PhoneNumber, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>), <span class="string">"제니"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Instance 1 hashcode : "</span> + <span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        System.out.println(<span class="string">"Instance 2 hashcode : "</span> + <span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        Assert.assertNotEquals(map.get(<span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>)), <span class="string">"제니"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> firstNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> secondNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> thirdNumber;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PhoneNumber p = (PhoneNumber) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.firstNumber == p.firstNumber &amp;&amp;</span><br><span class="line">                    <span class="keyword">this</span>.secondNumber == p.secondNumber &amp;&amp;</span><br><span class="line">                    <span class="keyword">this</span>.thirdNumber == p.thirdNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedPhoneNumber</span> <span class="keyword">extends</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExtendedPhoneNumber</span><span class="params">(<span class="keyword">int</span> firstNumber, <span class="keyword">int</span> secondNumber, <span class="keyword">int</span> thirdNumber)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(firstNumber, secondNumber, thirdNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">int</span> hashcode = Integer.hashCode(firstNumber);</span><br><span class="line">            hashcode = c * hashcode + Integer.hashCode(secondNumber);</span><br><span class="line">            hashcode = c * hashcode + Integer.hashCode(thirdNumber);</span><br><span class="line">            <span class="keyword">return</span> hashcode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="test1-hashcode를-재정의-하지-않은-경우">Test.1 hashcode를 재정의 하지 않은 경우</h2><p>PhoneNumber 클래스에서는 객체 동치성 체크를 위해 equals메서드를 재정의했다. <strong>하지만 hashcode 메서드는 재정의 하지 않았다.</strong>new를 통해 새로운 객체를 만들 때마다 늘 다른 hashcode를 리턴하여, 실제 HashMap에 key로 PhoneNumber클래스를 삽입하더라도<br>hashcode가 다르기 때문에 다른 버킷에가서 데이터를 조회 하려고해서 결과적으로 null이 나와 기댓값인 <code>&quot;제니&quot;</code>를 만족하지 못했다.</p><p>실제 로그를 찍어보니<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instance 1 hashcode : 1686369710</span><br><span class="line">Instance 2 hashcode : 194706439</span><br></pre></td></tr></table></figure></p><p>두 개의 다른 객체에 대해 다른 hashcode를 리턴하고 있었다.</p><h2 id="test2-hashcode를-재정의-한-경우">Test.2 hashcode를 재정의 한 경우</h2><p>ExtendPhoneNumber 클래스에서는 PhoneNumber를 상속 받은 뒤, hashCode 메서드를 재정의하였다.<br>(equals메서드는 PhoneNumber의 equals를 그대로 사용하였다.)</p><p>실제 로그를 찍어보니<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instance 1 hashcode : 711611</span><br><span class="line">Instance 2 hashcode : 711611</span><br></pre></td></tr></table></figure></p><p>두 개의 ExtendPhoneNumber 객체에 대해 같은 hashcode를 리턴하고 있었다.<br>그렇기 때문에 HashMap에 삽입한 ExtendPhoneNumber 객체에 대해 new ExtendPhoneNumber()로 조회를 하니 같은 hashCode의 버킷을 조회하여<br><code>&quot;제니&quot;</code>라는 데이터를 얻어올 수 있었다.</p><h1 id="최악의-hashcode-구현">최악의 hashcode 구현</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하니 적법한 해시코드 처럼 보인다.<br>하지만, 모든 객체에 대해 똑같은 해시코드를 반환하니 모든 객체가 같은 해시테이블 버킷에 담겨 연결리스트(Linked List)처럼 동작하게 된다.<br>평균 수행시간이 O(1)에서 O(n)으로 느려져서, 성능이 매우 낮아질 뿐더러 버킷에 대한 overflow가 발생하는 경우 데이터가 누락될 수도 있다.</p><h2 id="hashcode가-같으면-hashmap에서-어떻게-동작할까">hashcode가 같으면 HashMap에서 어떻게 동작할까?</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashCodeTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hashcode_재정의() &#123;</span><br><span class="line">        HashMap&lt;ExtendedPhoneNumber, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>), <span class="string">"제니"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Instance 1 hashcode : "</span> + <span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        System.out.println(<span class="string">"Instance 2 hashcode : "</span> + <span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5301</span>).hashCode());</span><br><span class="line">        <span class="comment">//다른 객체를 넣어 데이터를 조회해 보았다.</span></span><br><span class="line">        Assert.assertEquals(map.get(<span class="keyword">new</span> ExtendedPhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5301</span>)), <span class="string">"제니"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> firstNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> secondNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> thirdNumber;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PhoneNumber p = (PhoneNumber) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.firstNumber == p.firstNumber &amp;&amp;</span><br><span class="line">                    <span class="keyword">this</span>.secondNumber == p.secondNumber &amp;&amp;</span><br><span class="line">                    <span class="keyword">this</span>.thirdNumber == p.thirdNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedPhoneNumber</span> <span class="keyword">extends</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExtendedPhoneNumber</span><span class="params">(<span class="keyword">int</span> firstNumber, <span class="keyword">int</span> secondNumber, <span class="keyword">int</span> thirdNumber)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(firstNumber, secondNumber, thirdNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Instance 1 hashcode : 42</span><br><span class="line">Instance 2 hashcode : 42</span><br><span class="line"></span><br><span class="line">java.lang.AssertionError: </span><br><span class="line">Expected :null</span><br><span class="line">Actual   :제니</span><br><span class="line"> &lt;Click to see difference&gt;</span><br></pre></td></tr></table></figure></p><p>이 결과로 보아하니, hashcode가 같으면 같은 버킷에 LinkedList로 저장되면서 객체에 대해 equals 체크를 통해 데이터를 조회하는 것으로 판단 된다.</p><blockquote><p>설사 두 인스턴스가 같은 버킷에 담았더라도, hashmap.get메서드는 null을 반환한다.<br>만약 hashcode가 다른경우에는 동치성비교를 실행하지 않도록 최적화 되어있기 때문이다.<br>hashcode가 같더라도 동치성비교(equals)를 실행하여 객체에 대한 값(value)를 조회한다.</p></blockquote><h1 id="좋은-해시-함수-만들기">좋은 해시 함수 만들기</h1><p>좋은 해시 함수는 서로 다른 인스턴스에 대해 다른 해시코드를 반환한다.<br>이게 바로 hashcode의 세번째 규약이 요구하는 속성이다.<br>이상적인 해시 함수는 주어진 (서로 다른) 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">31</span>;</span><br><span class="line">    <span class="comment">//1. int변수 result를 선언한 후 첫번째 핵심 필드에 대한 hashcode로 초기화 한다.</span></span><br><span class="line">    <span class="keyword">int</span> result = Integer.hashCode(firstNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 기본타입 필드라면 Type.hashCode()를 실행한다</span></span><br><span class="line">    <span class="comment">//Type은 기본타입의 Boxing 클래스이다.</span></span><br><span class="line">    result = c * result + Integer.hashCode(secondNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 참조타입이라면 참조타입에 대한 hashcode 함수를 호출 한다.</span></span><br><span class="line">    <span class="comment">//4. 값이 null이면 0을 더해 준다.</span></span><br><span class="line">    result = c * result + address == <span class="keyword">null</span> ? <span class="number">0</span> : address.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 필드가 배열이라면 핵심 원소를 각각 필드처럼 다룬다.</span></span><br><span class="line">    <span class="keyword">for</span> (String elem : arr) &#123;</span><br><span class="line">      result = c * result + elem == <span class="keyword">null</span> ? <span class="number">0</span> : elem.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 배열의 모든 원소가 핵심필드이면 Arrays.hashCode를 이용한다.</span></span><br><span class="line">    result = c * result + Arrays.hashCode(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. result = 31 * result + c 형태로 초기화 하여 </span></span><br><span class="line">    <span class="comment">//result를 리턴한다.</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>hashcode를 다 구현했다면, 이 메서드가 동치인 인스턴스에 대해 똑같은 해시코드를 반환할지 TestCase를 작성해보자</li><li>파생필드는 hashcode 계산에서 제외해도 된다.</li><li>equals 비교에 사용되지 않는 필드는 반드시 제외한다.</li><li>31 * result를 곱하는 순서에 따라 result 값이 달라진다.</li><li>곱할 숫자를 31로 지정하는 이유는 31이 홀수 이면서 소수(prime)이기 때문이다. 2를 곱하는 것은 shift연산과 같은 결과를 내기 떄문에 추천하지 않는다.</li><li>31을 이용하면 (i &lt;&lt; 5) - i와 같이 최적화 할 수 있다.</li></ul><h1 id="hashcode를-편하게-만들어-주는-모듈">hashcode를 편하게 만들어 주는 모듈</h1><ul><li>Objects.hash()<ul><li>내부적으로 AutoBoxing이 일어나 성능이 떨어진다.</li></ul></li><li>Lombok의 @EqualsAndHashCode</li><li>Google의 @AutoValue</li></ul><h1 id="hashcode를-재정의-할-때-주의-할-점">hashcode를 재정의 할 때 주의 할 점!</h1><ul><li>불변 객체에 대해서는 hashcode 생성비용이 많이 든다면, hashcode를 캐싱하는 것도 고려하자<ul><li>스레드 안전성까지 고려해야 한다.</li></ul></li><li>성능을 높인답시고 hashcode를 계산할 떄 핵심필드를 생략해서는 안된다.<ul><li>속도는 빨라지겠지만, hash품질이 나빠져 해시테이블 성능을 떨어뜨릴 수 있다 (Hashing Collision)</li></ul></li><li>hashcode 생성규칙을 API사용자에게 공표하지 말자<ul><li>그래야 클라이언트가 hashcode값에 의지한 코드를 짜지 않는다.</li><li>다음 릴리즈 시, 성능을 개선할 여지가 있다.</li></ul></li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 11. equals를 재정의하려거든 hashcode도 재정의하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/12/effective-java-item11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 10. Equals는 일반 규약을 지켜 재정의하라</title>
      <link>https://jaehun2841.github.io/2019/01/10/effective-java-item10/</link>
      <guid>https://jaehun2841.github.io/2019/01/10/effective-java-item10/</guid>
      <pubDate>Thu, 10 Jan 2019 12:14:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;equals 메서드는 Object 클래스에 구현된 메서드로 객체 내의 정보들에 대한 동등성(equality) 비교를 목적으로 하는 메서드이다.&lt;br&gt;
equals 메서드를 잘못 작성하게 되면 의도하지 않는 결과
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>equals 메서드는 Object 클래스에 구현된 메서드로 객체 내의 정보들에 대한 동등성(equality) 비교를 목적으로 하는 메서드이다.<br>equals 메서드를 잘못 작성하게 되면 의도하지 않는 결과들이 초래되므로 웬만하면 변경하지 않는 것이 좋다.</p><h1 id="equals를-재정의-하지-않아도-되는-경우">equals를 재정의 하지 않아도 되는 경우</h1><ul><li>각 인스턴스가 본질적으로 고유 한 경우 - 값이 아닌 동작을 표현하는 클래스의 경우 (Thread가 좋은 예이다.)</li><li>인스턴스의 논리적 동치성 (Logical Equality)를 검사할 일이 없는 경우 - <code>java.utils.regex.Pattern</code>의 equals는 내부의 정규표현식이 같은지를 검사하는 메서드이다.</li><li>상위 클래스에서 재정의한 equals가 하위 클래스에서도 적용 되는 경우 - Set, Map, List의 경우 Abstract(Type)의 equals를 쓴다.</li><li>클래스가 private이거나, package-private여서 equals를 호출할 일이 없는 경우</li><li>싱글턴을 보장하는 클래스(인스턴스 통제 클래스, Enum (열거타입)) 인 경우 - 객체 간 동등성, 동일성이 보장된다.</li></ul><h1 id="equals를-재정의-하는-경우-지켜야-할-규약">equals를 재정의 하는 경우 지켜야 할 규약</h1><p>equals를 재정의 해야 하는 경우는 객체 동일성(식별성(Object Identity))를 확인해야 하는 경우가 아니라<br>논리적 동치성(동등성(Logical equality))를 비교 하도록 재정의 되지 않았을 경우이다.</p><h2 id="반사성reflexivity">반사성(reflexivity)</h2><p><strong>null이 아닌 모든 참조 값 x에 대해 x.equals(x)를 만족해야한다.</strong><br>단순히 말하면 객체는 자기 자신과 비교했을 때 같아야 한다는 뜻이다.<br>이 조건을 만족하지 않는 예를 찾기가 더 어렵다.<br>만약 x.equals(x)가 성립하지 않는 객체라면, 컬렉션에서 contain 메서드를 사용하는 경우 방금 넣은 객체도 찾을 수 없을 것이다.</p><h2 id="대칭성-symmetry">대칭성 (symmetry)</h2><p><strong>null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true이면, y.equals(x)가 true를 만족해야 한다.</strong></p><p>예시 코드를 보면<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveString</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String s;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CaseInsensitiveString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s = Objects.requireNonNull(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> CaseInsensitiveString) &#123;</span><br><span class="line">      <span class="keyword">return</span> s.equalsIgnoreCase(((CaseInsensitiveString) o).s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> String) &#123; <span class="comment">//한 방향으로만 작동!!</span></span><br><span class="line">      <span class="keyword">return</span> s.equalsIgnoreCase((String) o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 클래스를 기반으로<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CaseInsensitiveString caseInsensitiveString = <span class="keyword">new</span> CaseInsensitiveString(<span class="string">"Test"</span>);</span><br><span class="line">String test = <span class="string">"test"</span>;</span><br><span class="line">System.out.println(caseInsensitiveString.equals(test)); <span class="comment">//true</span></span><br><span class="line">System.out.println(test.equals(caseInsensitiveString)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p><p>위의 코드를 실행하게 되면, x.equals(y)가 true일 때, y.equals(x)가 false이므로 <code>대칭성</code>이 깨지는 코드가 된다.<br>String 클래스에서는 CaseInsensitiveString의 존재를 모르기 때문에 false가 날 수 밖에 없는 상황이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CaseInsensitiveString&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> CaseInsensitiveString(<span class="string">"Test"</span>));</span><br><span class="line">System.out.println(list.contain(<span class="string">"test"</span>)); <span class="comment">//false or true</span></span><br></pre></td></tr></table></figure></p><p>위의 예제의 경우는 JDK버전에 따라 다를 수 있다. x.equals(y)로 비교할 수 도 있고, y.equals(x)로 비교될 수 있기 때문이다.</p><p>위의 내용을 수정한다면, String과의 비교는 포기해야 한다.<br>같은 CaseInsensitiveString 타입인 경우에만 비교하도록 한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o <span class="keyword">instanceof</span> CaseInsensitiveString &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="추이성-transitivity">추이성 (transitivity)</h2><p><strong>null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y)가 true이고, y.equals(z)가 true이면 x.equals(z)도 true가 되야 한다는 조건이다.</strong></p><p>Point클래스와 ColorPoint 클래스를 가지고 예시를 들어보겠다.<br>(ColorPoint는 Point클래스를 확장(extends)한 클래스이다.)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint a = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line">Point b = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">ColorPoint c = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</span><br></pre></td></tr></table></figure></p><p>위와 같은 인스턴스 a, b, c가 있다.이 때, a.equals(b)와 b.equals(c) 일 때, a.equals(c)가 되는 과정을 살펴 보자</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Point p = (Point) o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x == p.x &amp;&amp; <span class="keyword">this</span>.y == p.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="대칭성이-위배되는-case">대칭성이 위배되는 case</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; <span class="keyword">this</span>.color == ((ColorPoint) o).color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 처럼 ColorPoint 클래스의 equals 메서드를 재정의 했다면...<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint a = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line">Point b = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//false</span></span><br><span class="line">System.out.println(b.equals(a)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><ol><li><p><code>a.equals(b)</code>를 보면 a는 ColorPoint이기 떄문에 ColorPoint 클래스에서 재정의 된 equals 메서드를 타게 된다.<br>이렇게 되면 첫번째 if 조건에서 걸리게 된다. b는 Point이지만 ColorPoint는 아니기 떄문이다.<br>따라서 <code>a.equals(b)</code>는 <code>false</code>가 된다.</p></li><li><p><code>b.equals(a)</code>를 보면 b는 Point클래스이기 떄문에 Point클래스의 equals메서드를 타게 된다.<br>이렇게 되면 ColorPoint는 Point클래스를 상속하고 있기 때문에 첫번째 if조건을 통과하게 되고,<br>int x, int y값을 기준으로만 비교하기 떄문에 값이 참이 된다.<br>따라서 <code>b.equals(a)</code>는 <code>true</code>가 된다.</p></li></ol><p>위의 예시는 equals 정의 규약 중 하나인 대칭성을 위반하고 있으므로 다시 작성해야 한다.</p><h3 id="추이성이-위반되는-case">추이성이 위반되는 case</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.</span></span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> o.equals(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//o가 ColorPoint이면 색상까지 비교한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; <span class="keyword">this</span>.color == ((ColorPoint) o).color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 처럼 ColorPoint 클래스의 equals메서드를 다시 재정의 했다면..<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint a = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line">Point b = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">ColorPoint c = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</span><br><span class="line"></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//true</span></span><br><span class="line">System.out.println(b.equals(c)); <span class="comment">//true</span></span><br><span class="line">System.out.println(a.equals(c)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p><ol><li><code>a.equals(b)</code>를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.<br>b가 Point인 경우이기 때문에 2번쨰 if 절을 타게 되어 Point의 x, y정보만 비교하게 되므로 결과는 <code>true</code>이다.</li><li><code>b.equals(c)</code>를 보면 b는 Point클래스의 인스턴스이므로 Point클래스의 equals 메서드를 실행하게 된다.<br>Point의 x, y정보만 비교하게 되므로 결과는 <code>true</code>이다.</li><li><code>a.equals(c)</code>를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.<br>하지만, c가 ColorPoint클래스의 인스턴스이므로 x, y값 뿐만아니라 color까지 비교하게되어 결과는 <code>false</code>이다.</li></ol><p>이렇게 a.equals(b)는 <code>true</code>를 만족하고 b.equals(c)는 <code>true</code>를 만족하지만 a.equals(c)는 <code>false</code>가 되므로<br>위의 코드는 equals 정의 규약 중 <code>추이성</code>을 위반하는 코드가 된다.</p><h3 id="무한-재귀-infinite-recursion이-발생하는-case">무한 재귀 (Infinite Recursion)이 발생하는 case</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmellPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Smell smell;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.</span></span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> SmellPoint)) <span class="keyword">return</span> o.equals(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//o가 ColorPoint이면 색상까지 비교한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; <span class="keyword">this</span>.smell == ((SmellPoint) o).smell;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 처럼 Point를 상속받는 SmellPoint라는 클래스도 추가되었다고 가정해보자</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point cp = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line">Point sp = <span class="keyword">new</span> SmellPoint(<span class="number">1</span>, <span class="number">2</span>, Smell.SWEET);</span><br><span class="line"></span><br><span class="line">System.out.println(cp.equals(sp));  <span class="comment">//?</span></span><br></pre></td></tr></table></figure></p><p>위와 같이 ColorPoint와 SmellPoint에 대해 equals비교를 한다고 하면 어떻게 될까??<br>이렇게 되면 두번째 if절에서 무한재귀(Infinite Recursion)이 발생하게 된다.</p><p>무슨 의미인지 자세히 설명하면, cp는 ColorPoint 클래스의 인스턴스이기 때문에<br><code>cp.equals(sp)</code> 코드는 ColorPoint 클래스의 재정의 된 equals 메서드를 타게 된다.<br>이렇게 되면 두번째 if에서 걸리게 된다. 왜냐하면 o는 <strong>SmellPoint</strong> 타입이기 때문에 <code>!(o instanceof ColorPoint)</code> 이 조건식이 true가 된다.<br>그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 o는 SmellPoint 클래스의 인스턴스이기 때문에<br>SmellPoint 클래스의 재정의된 equals메서드를 타게 된다.</p><p>다시 SmellPoint클래스의 입장에서 보게되면 두번째 if에서 걸리게 된다.<br>여기서 o는 ColorPoint타입이기 때문에 <code>!(o instanceof ColorPoint)</code> 이 조건식이 true가 된다.<br>그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 다시 ColorPoint 클래스의 재정의된 equals메서드를 타게 된다.</p><p>이런 작업이 계속 재귀적으로 호출 되면서, 결국은 StackOverflowError를 내며 프로그램이 죽는 참사를 맞이 하게 될 것이다.</p><h3 id="리스코프-치환-원칙-solid">리스코프 치환 원칙 (SOLID)</h3><p>SOLID원칙 중 3번째인 리스코프 치횐 원칙이란?</p><blockquote><p>자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.</p></blockquote><p>쉽게 말해서, 자식클래스에서 부모클래스의 기능을 수행하지 못하는 건 리스코프 치환원칙에 위배된다고 볼 수 있다.</p><p>위에서 equals 재정의에 실패해서 다시 또 변경하였다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Point&gt; unitCircle = Set.of(<span class="keyword">new</span> Point(<span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">   <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">   <span class="keyword">new</span> Point(-<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">   <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onUnitCircle</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unitCircle.contains(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o == <span class="keyword">null</span> || o.getClass() != <span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point p = (Point) o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x == p.x &amp;&amp; <span class="keyword">this</span>.y = p.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이번에는 주어진 점이 반지름이 1인 원안에 포함되는지에 대한 여부를 판단하는 로직이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint cp = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">0</span>, Color.RED);</span><br><span class="line">System.out.println(Point.onUnitCircle(cp)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p><p>ColorPoint는 Point를 상속한 클래스이다.<br>실제 oint.onUnitCircle 메서드의 contains 메서드에서 Set내의 element들에 대한 equals 비교가 일어나게 된다.<br>하지만 equals 메서드 첫번째 if문에서 걸리게 된다.<br>ColorPoint 객체가 파라미터로 전달되어 null은 아니지만,<br>두번째 조건식인 o.getClass()에서 <code>ColorPoint.class</code>가 도출되고 this.getClass()에서는 <code>Point.class</code>가 도출되게 된다.</p><p>위 조건식 때문에 ColorPoint 클래스는 Point클래스로서 equals메서드 내에서 활용되지 못했기 때문에<br>위 코드는 리스코프 치환원칙에 위배되는 코드로 전락해 버렸다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(o == <span class="keyword">null</span> || !(o <span class="keyword">instanceof</span> Point)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Point p = (Point) o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x == p.x &amp;&amp; <span class="keyword">this</span>.y = p.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>차라리 이런식으로 instanceof를 사용했다면 좋았을 것이다.</p><h2 id="상속-대신-컴포지션composition을-사용하라">상속 대신 컴포지션(Composition)을 사용하라</h2><p>구체클래스의 하위클래스에서 값을 추가할 방법은 없지만, 우회방법이 있다.<br>상속 대신에 Point 변수를 갖도록 Composition(구성)을 이용하는 방법이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ColorPoint &#123;</span><br><span class="line">  <span class="keyword">private</span> Point point;</span><br><span class="line">  <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.point = <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    <span class="keyword">this</span>.color = Objects.requireNonNull(color);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Point <span class="title">asPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.point;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ColorPoint cp = (ColorPoint) o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.point.equals(cp) &amp;&amp; <span class="keyword">this</span>.color.equals(cp.color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이와 같이 컴포지션을 이용하면 상속에 때문에 발생하는 대칭성, 추이성, 리스코프 치환원칙에 위배되지 않는 코드를 작성할 수 있다.</p><h2 id="일관성-consistency">일관성 (consistency)</h2><p><strong>null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.</strong><br>두 객체가 같다면 수정되지 않는 한 영원히 같아야 함을 의미한다.<br>가변객체는 비교시점에 따라 서로 달라질 수 있지만 불변객체라면 한번 다르면 끝까지 달라야 한다. (그래서 불변객체로 만드는 것이 나을때가 많다)</p><p>하지만, 클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들어서는 안된다.<br><code>java.net.URL</code> 클래스는 URL과 매핑된 host의 IP주소를 이용해 비교한다.<br>당장 우리회사 서버만 봐도 L4스위치가 적용되있기 때문에 로드밸런싱이 되어 같은 도메인주소라도 그떄그떄 나오는 IP정보가 다르다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL url1 = <span class="keyword">new</span> URL(<span class="string">"www.site-name.co.kr"</span>);</span><br><span class="line">URL url2 = <span class="keyword">new</span> URL(<span class="string">"www.site-name.co.kr"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(url1.equals(url2)); <span class="comment">//?</span></span><br></pre></td></tr></table></figure></p><p>실제 url1이 10.0.0.1 이라는 IP가 나왔다면<br>url2의 경우 10.0.0.1이 나올수도 있고, 같은 대역에 있는 10.0.0.2가 나올 수도 있다.<br>그렇기 떄문에 equals의 결과가 가변적이기 떄문에 다른 자원의 개입으로 인해 equals의 일관성이 깨지게 된다.</p><p>그렇게 때문에 항상 equals를 사용할 때는 메모리에 존재하는 객체만을 사용한 결정적(deterministic) 계산만 수행해야 한다.</p><h2 id="not-null">not null</h2><p><strong>null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다</strong>기본적으로 x.equals(null)이 true가 되는 일은 생각하기 어렵다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//불필요</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x == o.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하지만 equals를 재정의 할 때 이러한 코드를 작성하기 쉽다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> MyClass)) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//묵시적 null검사</span></span><br><span class="line">  MyClass clazz = (MyClass) o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x == clazz.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이런식으로 instanceof 키워드를 통해 묵시적 null 체크를 하는 방법이 좋다.</p><h1 id="요약-정리">요약 정리</h1><h2 id="equals-구현-절차">equals 구현 절차</h2><ul><li><code>==</code> 연산자를 사용해 입력된 파라미터와 자기자신이 같은 객체인지 검사한다. (동일성 검사 - Object Identity)<ul><li>성능 향상을 위한 코드</li><li>equals가 복잡할 때 같은 참조를 가진 객체에 대한 비교를 안하기 위함</li></ul></li><li><code>instanceof</code> 연산자로 파라미터의 타입이 올바른지 체크<ul><li>묵시적 null체크 용도로도 사용</li><li>equals중에서는 같은 interface를 구현한 클래스끼리도 비교하는 경우가 있다.</li></ul></li><li>입력을 올바른 타입으로 형변환한다.<ul><li>Object타입의 파라미터를 비교하고자 하는 타입으로 형변환한다.</li><li>앞서 <code>instanceof</code> 연산을 수행했기 때문에 100% 성공한다.</li></ul></li><li>파라미터 Object 객체와 자기자신의 대응되는 핵심필드들이 모두 일치하는지 확인한다.<ul><li>하나라도 다르면 false를 리턴</li><li>만약 interface기반의 비교가 필요하다면 필드정보를 가져오는 메서드가 interface에 정의되어있어야하고,<br>구현체 클래스에서는 메서드를 재정의 해야한다.</li></ul></li><li>float, double을 제외한 기본타입은 <code>==</code>을 통해 비교</li><li>참조(reference) 타입은 equals를 통해 비교</li><li>float, double은 Float.compare(float, float)와 Double.compare(double, double)로 비교한다.<ul><li>Float.Nan, -0.0f등을 비교하기 위함이다.</li><li>이 메서드들은 float -&gt; Float, double -&gt; Double로 변환하는 오토박싱 기능이 수반되므로 성능상 좋지 못하다.</li></ul></li><li>배열의 모든 원소가 핵심 필드라면 Arrays.equals를 사용하자</li><li>null이 의심되는 필드는 Objects.equals(obj, obj)를 이용해 NullPointerException을 예방하자</li><li>성능을 올리고자 한다면<ul><li>다를 확률이 높은 필드부터 비교한다.</li><li>비교하는 비용(시간복잡도)이 적은 비교를 먼저 수행</li></ul></li></ul><h1 id="주의사항">주의사항</h1><ul><li>equals를 재정의 했다면, 대칭성, 추이성, 일관성에 대한 체크를 꼭 하자 (테스트 케이스 작성 요망)</li><li>equals를 작성할 때는 hashcode도 반드시 재정의하자 (Item.11)</li><li>너무 복잡하게 해결하려 들지 말자</li><li>equals의 파라미터는 Object이외의 타입으로 선언하지 말자 (컴파일 에러 발생)</li><li>구글에서 만든 @AutoValue을 이용해서 equals와 hashcode를 자동으로 재정의해보자 (Lombok의 @EqualsAndHashCode도 있다.)</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 10. equals는 일반 규약을 지켜 재정의하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/10/effective-java-item10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 9. Try-Finally 보다는 Try-With-Resources를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/01/08/effective-java-item9/</link>
      <guid>https://jaehun2841.github.io/2019/01/08/effective-java-item9/</guid>
      <pubDate>Tue, 08 Jan 2019 07:30:31 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Java 라이브러리 중에는 close메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, Connection등이 있다.&lt;br&gt;
자원 닫기는 클라이언트가 놓치기 쉽기 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Java 라이브러리 중에는 close메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, Connection등이 있다.<br>자원 닫기는 클라이언트가 놓치기 쉽기 때문에 예측할 수 없는 성능 문제로 이어지기도 한다.</p><p>나의 경우에도 신입 때 JDBC로 개발을 해야 했던 적이 있었는데,<br>DB의 max-connection이 10이어서 11번째 호출 시 부터는 JDBCException이 발생하는 오류를 겪은 적이 있다.<br>알고 보니 하나의 메서드에서 Connection 객체에 대한 참조를 해제 하지 않아 계속 Connection을 물고 있는 상황이었다.<br>Spring을 사용하면서는 Mybatis나 JPA같은 프레임웍 내에서 자원에 대한 관리를 해주기 때문에 이런 일을 만날 일은 없게 되었다.</p><p>하지만 예전처럼 JDBC를 사용하거나, IO관련 작업을 할 때는 반드시 close를 통해 자원에 대한 해제가 필요하다.<br>이전에는 finallizer를 통해 했다고는 아는데 이전 장에서 봤듯이 안 쓰는것이 좋다.<br>그리고 try-catch-finally 구문을 통해 Exception이 발생하더라도, finally 절에서 close를 호출 하도록 했는데, 코드가 복잡해 지고, finally 절 내에서 Exception이 발생하는 경우도 있기 때문에 이를 방지하기 위해 더 더러운 코드를 생산하는 일이 적지 않았다.</p><p>옛날에 자주 사용해 본 아주아주 슬픈 코드이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCExam</span> </span>&#123;</span><br><span class="line">  Connection connection;</span><br><span class="line">  Statement statement;</span><br><span class="line">  ResultSet resultSet;</span><br><span class="line"></span><br><span class="line">  String driverName = <span class="string">"oracle.jdbc.driver.OracleDriver"</span>;</span><br><span class="line">  String url = <span class="string">"oracle:thin:localhost:1521:ORCL"</span>;</span><br><span class="line">  String user = <span class="string">"scott"</span>;</span><br><span class="line">  String password = <span class="string">"tiger"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JDBCExam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Class.forName(driverName);</span><br><span class="line">          connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">"[로드 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">"[연결 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  connection.close();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  statement.close();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  resultSet.close();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">              System.out.println(<span class="string">"[닫기 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="autocloseable">AutoCloseable</h1><p>JDK 1.7 부터 try-with-resources 구문이 추가 되었고, <code>AutoCloseable</code> 인터페이스가 추가되었다. 이 인터페이스가 나오고 부터 Java의 close를 지원하는 클래스에서 AutoCloseable을 구현하도록 변경되었다.</p><h1 id="try-with-resources">try-with-resources</h1><p>try 절에 AutoCloseable을 구현한 클래스에 대한 인스턴스를 선언하게 되면 try절이 종료되는 시점에 AutoCloseable 인터페이스의 close() 메서드를 자동으로 호출 한다. 그렇기 때문에 이전처럼 finally 구문에서 별도로 자원에 대한 해제를 하지 않아도 된다.</p><p>위의 예시코드를 try-with-resources 구문으로 바꿔보았다.<br>위의 코드보다는 한층 깔끔해 짐을 볼 수 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String driverName = <span class="string">"oracle.jdbc.driver.OracleDriver"</span>;</span><br><span class="line">    String url = <span class="string">"oracle:thin:localhost:1521:ORCL"</span>;</span><br><span class="line">    String user = <span class="string">"scott"</span>;</span><br><span class="line">    String password = <span class="string">"tiger"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDBCExam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">             Statement statement = connection.prepareStatement(<span class="string">"select * from member"</span>);</span><br><span class="line">             ResultSet resultSet = statement.getResultSet();</span><br><span class="line">             )&#123;</span><br><span class="line">            Class.forName(driverName);</span><br><span class="line">            String name = resultSet.getString(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"회원명 : "</span> + name);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"[로드 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"[연결 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 9. try-finally 보다는 try-with-resources를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/08/effective-java-item9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 8. Finalizer와 Cleaner 사용은 피하라</title>
      <link>https://jaehun2841.github.io/2019/01/08/effective-java-item8/</link>
      <guid>https://jaehun2841.github.io/2019/01/08/effective-java-item8/</guid>
      <pubDate>Mon, 07 Jan 2019 15:32:01 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Java에서는 2가지의 객체 소멸자를 제공한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;finalzier&lt;/li&gt;
&lt;li&gt;cleaner&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 2가지 객체 소멸자는 JVM내의 GC가 작동할 때 실행되는 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Java에서는 2가지의 객체 소멸자를 제공한다.</p><ul><li>finalzier</li><li>cleaner</li></ul><p>이 2가지 객체 소멸자는 JVM내의 GC가 작동할 때 실행되는 구문이다.<br>기본적으로 이 2가지 구문은 <strong>사용하지 말아야 한다.</strong><br>현재 Java 9 버전 부터는 Object 클래스에 대한 finalizer를 <code>Deprecated</code> 처리하였다.<br>아래에 사용하지 말아햐 하는 이유를 하나씩 보도록 하겠다.</p><h1 id="finalizer와-cleaner를-사용하지-말아야-하는-이유">finalizer와 cleaner를 사용하지 말아야 하는 이유</h1><h2 id="실행을-보장할-수-없다">실행을 보장할 수 없다.</h2><p>finalizer에 특정 로직을 삽입하는 경우 실행을 보장 할 수 없다.<br>기본적으로 GC가 발생할 때 실행되는 로직이지만, Java Application이 죽는다던지의 이유로 finalizer 실행이 되지 않을 수 있다.<br>그렇기 때문에 제 때 실행되어야 하거나, 뭔가 상태를 수정하는 행위를 절대적으로 하면은 안된다.</p><h2 id="느리다">느리다.</h2><p>Effective Java 책의 예제에서는 AutoCloseable과 finalizer의 성능비교를 한 문단이 있다.<br>Autocloseable을 사용한 GC 수행시간은 12ns였지만, finalizer를 사용한 GC 수행 시간은 550ns가 걸렸다고 한다.<br>finalizer가 가비지 컬렉터의 효율을 떨어뜨리기 때문이다.</p><h2 id="시스템-전체-장애를-유발-할-수-있다">시스템 전체 장애를 유발 할 수 있다.</h2><p>Java API 문서 상에서는 GC가 UnReachable 상태의 객체를 가비지 컬렉션 할 때 finalizer가 호출된다고 명시하고 있다.<br>하지만 finalizer가 실행되는 시점은 GC 발생 시 즉각적으로 이루어지는게 아니다.<br>finalizer queue에 삽입되어 순차적으로 finalizer를 실행하게 된다.<br>그렇기 때문에 finalizer메소드 실행이 느린 경우 객체 소멸이 느려지므로  <code>Out of Memory</code>와 같은 오류를 발생 시킬 가능성이 높아지게 된다.</p><h2 id="finalizer-공격에-취약하다">finalizer 공격에 취약하다.</h2><p>위에 적은 것 처럼 finalizer 메소드 실행시간이 오래 걸리게 만들면 시스템에 심각한 장애를 유발할 수 있다.<br>finalizer 메서드를 override해서 악의적으로 느리게 할 수 있기 떄문에 finalizer를 사용해야 하는 경우라면<br>메소드에 <code>final</code> 키워드를 붙여서 상속하지 못하도록 해야한다.</p><h1 id="그럼-finalizer나-cleaner는-어디서-쓰나">그럼 finalizer나 cleaner는 어디서 쓰나?</h1><ul><li>개발자가 객체의 close를 호출하지 않는 경우 -&gt; 자원 해제를 안하느니 느리더라도 하는게 낫다.<br>(이 경우는 동의 못하겠다. 개발자가 close를 시켜야 한다.)</li><li>native peer와 연결된 객체<ul><li>native peer는 자바 객체가 아니기 떄문에 가비지 컬렉터의 관리 대상이 아니다.<br>그렇기 때문에 native peer가 회수 될때 finalizer 메서드를 실행해 자원을 해제 할 수 있다.</li></ul></li></ul><h1 id="finalizer-기능이-필요한-경우에는-어떻게">finalizer 기능이 필요한 경우에는 어떻게?</h1><p>Autocloseable Interface를 사용하여 close를 호출시키도록 하자.<br>다음장의 try-catch-resource 구문에서 설명하도록 하겠다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 8. finalizer와 cleaner 사용은 피하라</li><li><a href="http://www.yunsobi.com/blog/entry/finalize-%EB%A9%94%EC%86%8C%EB%93%9C%EC%9D%98-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EC%9D%84-%EC%9E%90%EC%A0%9C%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0" target="_blank" rel="noopener">finalize 메소드의 오버라이딩을 자제해야 하는 이유.</a></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/08/effective-java-item8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 7. 다 쓴 객체는 참조를 해제하라</title>
      <link>https://jaehun2841.github.io/2019/01/07/effective-java-item7/</link>
      <guid>https://jaehun2841.github.io/2019/01/07/effective-java-item7/</guid>
      <pubDate>Mon, 07 Jan 2019 13:21:26 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Java의 장점 중 하나는 가비지 컬렉션을 지원하는 언어라는 점이다.&lt;br&gt;
C, C++ 처럼 개발자가 메모리를 직접 할당하고 해제하는 방식이 아니기 때문에 Java에서는 메모리 관리가 굉장히 편하다는 장점이 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Java의 장점 중 하나는 가비지 컬렉션을 지원하는 언어라는 점이다.<br>C, C++ 처럼 개발자가 메모리를 직접 할당하고 해제하는 방식이 아니기 때문에 Java에서는 메모리 관리가 굉장히 편하다는 장점이 있다.</p><p>하지만 <code>아예 신경을 안써도 되는 것은 아니다.</code><br>가비지 컬렉션을 통해 소멸 대상이 되는 객체가 되기 위해서는 어떠한 reference 변수에서 가르키지 않아야 한다.<br>다 쓴 객체에 대한 참조를 해제하지 않으면 가비지 컬렉션의 대상이 되지 않아 계속 메모리가 할당 되는 <strong>메모리 누수</strong> 현상이 발생 된다.</p><p>가비지 컬렉션을 지원하는 언어에서는 메모리 누수를 찾기가 까다롭다<br>객체 참조(reference)를 하나 살려두면, 가비지 컬렉터는 그 객체 뿐만 아니라 그 객체 내에서 참조하고 있는 객체까지 회수 할 수 없다.</p><p>이로 인해 잠재적으로 성능에 악영향을 줄 수 있다.</p><h1 id="가비지-컬렉션의-소멸-대상이-되기-위해서는">가비지 컬렉션의 소멸 대상이 되기 위해서는...</h1><h2 id="직접-할당-해제">직접 할당 해제</h2><ul><li>이 방법은 굉장히 단순하다.<br>말 그대로 객체 참조 변수를 null로 초기화 한다.<br>그렇게 되면 실제 heap 메모리에 존재하는 객체는 어떠한 참조(reference)도 가지지 않기 때문에<code>가비지 컬렉션의 소멸 대상</code>이 된다.</li><li>하지만 바람직한 방법은 아니다. 반드시 필요한 경우에만 사용 할 수 있도록 하는 것이 좋다.<br>(소스코드가 드러워짐 -_-)</li><li>클래스 내에서 메모리를 관리 하는 객체(Stack 같은...)라면 이 방법을 통해 다 쓴 객체는 할당을 해제 하는 것이 옳다.</li></ul><h2 id="scope를-통한-자동-할당-해제">Scope를 통한 자동 할당 해제</h2><ul><li>보통은 변수 선언<code>(대게 지역변수)</code>과 동시에 초기화를 사용한다.<br>그 변수에 대한 scope가 종료되는 순간 reference가 해제되어 가비지 컬렉션의 대상이 된다.</li><li>try~catch와 같은 구문에서는 catch 구문에서 try내에서 사용하는 변수를 참조하지 못하므로try~catch 변수 초기화를 하기 어렵다.<br>그렇게 때문에 finally 구문에서 변수에 대한 참조를 해제한다.</li></ul><h1 id="메모리-누수를-일으키는-주범">메모리 누수를 일으키는 주범</h1><ul><li>첫번째는 위에서 설명한 class내에서 instance에 대한 참조(reference)를 관리하는 객체이다.</li><li>두번째는 Map과 같은 캐시</li><li>세번째는 리스너(Listener) 혹은 콜백(Callback)</li></ul><p>Map과 같은 캐시에 객체참조를 넣어두고 사용이 끝났는데도 초기화를 안시켜주는 경우 메모리 누수가 발생한다.<br>엔트리가 살아있는 동안만 캐시를 사용하려면 <code>WeakHashMap</code>을 사용하자.<br>WeakHashMap을 이해하려면 Java의 Reference를 좀 알아야 한다.</p><h2 id="java-reference">Java Reference</h2><p>Java에는 4가지의 Reference가 있다.</p><ul><li><p>Strong Reference</p><ul><li>우리가 흔히 사용하는 reference</li><li>String str = new String(&quot;abc&quot;); 와 같은 형태</li><li>Strong Reference는 GC의 대상이 되지 않는다.</li><li>Strong Reference관계의 객체가 GC가 되기 위해선 null로 초기화해<br>객체에 대한 Reachability상태를 UnReachable 상태로 만들어 줘야 한다.</li></ul></li><li><p>Soft Reference</p><ul><li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference만 있는 상태</li><li>SoftReference&lt;Class&gt; ref = new SoftReference&lt;&gt;(new String(&quot;abc&quot;));와 같은 형태로 사용</li><li>Soft Reference는 대게 GC대상이 아니다가 <code>out of memory에러</code>가 나기 직전까지 가면<br>Soft Reference 관계에 있는 객체들은 GC대상이 된다.</li></ul></li><li><p>Weak Reference</p><ul><li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference가 없고 Weak Reference만 있는 상태</li><li>WeakReference&lt;Class&gt; ref = new WeakReference&lt;Class&gt;(new String(&quot;abc&quot;)); 와 같은 형태로 사용</li><li>WeakReference는 GC가 발생 할 때마다 대상이 된다.</li></ul></li><li><p>Phantomly Reference</p><ul><li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference와 Weak Referencerk 모두가 해당되지 않는 객체</li><li>finalize 되었지만 메모리가 아직 회수 되지 않은 객체</li><li>아직 잘 이해가... 안됨</li></ul></li></ul><h2 id="weakhashmap">WeakHashMap</h2><p>Weak Reference를 이용한 HashMap<br>아래의 예제코드를 보자<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassWeakHashMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Referred</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Good bye cruel world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * GC를 발생 시켜 메모리를 회수하는 코드</span></span><br><span class="line"><span class="comment">    * System.gc()가 잘 동작할지는 모르겠다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Suggesting collection"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"Sleeping"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Creating weak references"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is now a weak reference. </span></span><br><span class="line">        <span class="comment">// The object will be collected only if no strong references. </span></span><br><span class="line">        Referred strong = <span class="keyword">new</span> Referred(); <span class="comment">//Strong Reference로 하나 추가</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Weak Reference를 이용한 WeakHashMap에 엔트리를 추가하여</span></span><br><span class="line">        <span class="comment">//Weak Reference 추가</span></span><br><span class="line">        Map&lt;Referred, String&gt; metadata = <span class="keyword">new</span> WeakHashMap&lt;Referred, String&gt;();</span><br><span class="line">        metadata.put(strong, <span class="string">"WeakHashMap's make my world go around"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attempt to claim a suggested reference. </span></span><br><span class="line">        ClassWeakHashMap.collect();</span><br><span class="line">        <span class="comment">//여기서는 gc가 발생해도 GC대상이 아니게 된다.</span></span><br><span class="line">        <span class="comment">//strong이라는 변수를 통해 Strong Reference를 가지므로 GC 대상이 아니다.</span></span><br><span class="line">        System.out.println(<span class="string">"Still has metadata entry? "</span> + (metadata.size() == <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"Removing reference"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The object may be collected. </span></span><br><span class="line">        <span class="comment">//Strong Reference를 끊었다.</span></span><br><span class="line">        strong = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//여기서는 Weak Reference만 남아 있기 때문에 GC대상이 된다.</span></span><br><span class="line">        ClassWeakHashMap.collect();</span><br><span class="line">        System.out.println(<span class="string">"Still has metadata entry? "</span> + (metadata.size() == <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Weak Reference를 가지고 있으면 GC가 발생되기 전까지 객체에 접근이 가능하기 때문에 메모리 누수의 입장으로 볼 때 유리한 것 같다.<br>한번 캐싱하고 사용하고 버리는 대상에 좋은 방법이다.</p><p>하지만 static한 Map을 사용하는 경우에는 비추이다.<br>언제 GC가 일어날지 모를 뿐더러.. 갑자기 데이터가 사라져 자칫 하면 장애가 발생 할 수 있으니,특별한 경우에만 WeakHashMap을 사용해야 한다.</p><h2 id="리스너-혹은-콜백">리스너 혹은 콜백</h2><p>리스너와 콜백은 root set에 대한 직접 참조가 아닌 객체에서 참조를 가지고 있다.<br>그렇기 때문에 리스너와 콜백을 사용하는 객체가 unreachable 상태가 되지 않는 이상 메모리에서 GC대상이 되지 않는다.<br>이 경우 weak reference를 이용하면 리스너와 콜백을 사용하고, GC 작동 시에 메모리 해제를 시킬 수 있어, 메모리 누수에 도움이 된다.</p><h1 id="추가적으로">추가적으로..</h1><p>메모리 누수는 겉으로 잘 드러나지 않아 수년 간 잠복하는 사례가 있다고 한다.<br>이런 누수는 철저한 코드리뷰나 힙 프로파일링 도구를 통해 디버깅을 동원해야 발견할 수 있으므로,<br>평소에 코드를 작성할 때 메모리 누수에 대한 부분을 신경을 써주는 것이 중요하다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 7. 다 쓴 객체는 참조를 해제하라</li><li>https://d2.naver.com/helloworld/329631</li><li>https://tourspace.tistory.com/42</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/07/effective-java-item7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 6. 불필요한 객체 생성을 피하라</title>
      <link>https://jaehun2841.github.io/2019/01/07/effective-java-item6/</link>
      <guid>https://jaehun2841.github.io/2019/01/07/effective-java-item6/</guid>
      <pubDate>Mon, 07 Jan 2019 12:33:11 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;똑같은 기능의 객체를 매번 생성하기 보다는 객체 하나는 재사용하는 편이 나을 때가 많다. (아니 거의 무조건 재사용 할 수 있으면 하는 게 좋다.)&lt;br&gt;
재사용은 빠르고 세련되며, 특히 불변 객체는 언제든지 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>똑같은 기능의 객체를 매번 생성하기 보다는 객체 하나는 재사용하는 편이 나을 때가 많다. (아니 거의 무조건 재사용 할 수 있으면 하는 게 좋다.)<br>재사용은 빠르고 세련되며, 특히 불변 객체는 언제든지 안전하게 재사용 할 수 있다.</p><h1 id="아주-안-좋은-객체-생성의-예">아주 안 좋은 객체 생성의 예</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure></p><p>이러한 코드는 매번 새로운 String 객체를 생성하게 된다.</p><h1 id="string-constant-pool">String Constant pool</h1><p>위의 코드를 조금 더 보완하면 아래 코드 처럼 사용할 수 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure></p><p>Java JVM에는 String Constant pool 이라는 것이 있다.<br>(Java 7 버전을 기점으로 Perm영역 -&gt; Heap 영역으로 변경되었다.)<br>위 처럼 쓰는 방식을 String 리터럴 방식이라 한다.</p><p>String 리터럴을 사용할 경우 기본적으로 String 내장 메서드인 intern()이라는 메서드를 호출하게 된다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"Hello"</span>; <span class="comment">// 1</span></span><br><span class="line">String b = <span class="string">"Hello"</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><ol><li><p>최초로 Hello라는 String 리터럴을 사용하였기 때문에 intern() 메서드가 호출된다.<br>--&gt; String Constant pool에서 해당 문자열을 검색하였지만 존재 하지 않기 때문에 String Constant pool에 넣고 새로운 주소값을 반환한다.</p></li><li><p>두번째로 Hello라는 String 리터럴을 사용하였기 때문에 마찬가지로 intern() 메서드가 호출된다.<br>--&gt; String Constant pool에서 해당 문자열을 검색하니 기존에 등록된 주소 값이 반환된다.</p></li></ol><p>실질적으로 a와 b는 같은 주소값을 가지게 된다.</p><p>그렇기 때문에<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(a == b);      <span class="comment">//true</span></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>위의 코드를 실행해 보면 객체의 동등성 비교와 동일성 비교에서 모두 true가 나온다.</p><ul><li>동등성(equality) : 두 객체의 내용이 같은지 비교</li><li>동일성(identity) : 두 객체가 같은 객체인지 hashcode를 비교</li></ul><p>그렇기 때문에 String을 사용할 경우에는 new를 이용한 객체 생성 방식보다 String 리터럴을 사용하는 방식이 더 좋다. (같은 객체를 재사용 하기 때문)</p><blockquote><p>그렇다고 실제 코드에서 String 리터럴을 사용했다고 <code>==</code> 을 이용한 동일성 비교는 하지말자.<br>상당히 위험한 코드이고, 다른 결과를 초래 할 가능성이 매우 높다.</p></blockquote><h1 id="boolean의-예시">Boolean의 예시</h1><p>Boolean의 경우 new Boolean(true)보다 Boolean.valueOf를 사용하는 것이 더 좋다.</p><p>Boolean 클래스를 보면..<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                                      <span class="title">Comparable</span>&lt;<span class="title">Boolean</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment">     * value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment">     * value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of the Boolean.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3665804199014368530L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span>(since=<span class="string">"9"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span>(since=<span class="string">"9"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parseBoolean(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">parseBoolean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"true"</span>.equalsIgnoreCase(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">booleanValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>new Boolean의 경우 그때그때 새로운 객체를 생성하게 된다.<br>(로컬 컴퓨터에는 OpenJDK 11이 설치되어있는데 Java 9 버전 부터 Boolean 생성자는 Deprecated 처리 되었다.)</p><p>하지만, Boolean.valueOf 라는 정적 메서드는 TRUE, FLASE라는 정적 필드에 이미 생성한 인스턴스를 사용하고 있기 때문에<br>객체를 추가적으로 생성하지 않아 성능상 이점이 있기 때문이다.</p><h1 id="auto-boxing을-주의하라">Auto Boxing을 주의하라!</h1><p>오토박싱은 Java 5 부터 나온 기능이다.<br>primitive 타입과 Class 타입을 자동으로 변환해 주는 기능이다.<br>이 기능에 대해 간과하게 되면 쓸 데 없는 객체를 많이 만들어 낼 수 있다.</p><p>책에 소개 된 예제를 잠깐 돌아보면..<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Long sum = <span class="number">0L</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">    sum += i; <span class="comment">//i에 대해 Auto Boxing이 일어나고 있다.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>i가 더해질 때 마다 AutoBoxing이 발생하게 된다.<br>sum 변수를 쓸데 없이 long으로 선언해서 Long객체가 2^32개 만큼 쓸데 없이 생성 되었다. (책에는 231개라고 나와있는데 오타일 거라 생각한다.)<br>sum을 long으로만 바꿔줘도 불필요한 객체가 생성되는 일은 없을 것이며, 성능도 더 빨라지게 된다. (책에서는 6.3초 -&gt; 0.59초로 성능 향상을 보았다고 한다.)</p><h1 id="나만의-객체-pool을-만들지-말자">나만의 객체 Pool을 만들지 말자</h1><p>객체를 생성하는 비용이 많이 드는 객체라면 미리 pool을 생성하여 사용하면 좋다.<br>JDBC에서 사용하는 Connection pool은 생성비용이 높기 때문에 재사용성을 높이기 위해 pool을 사용하는 것이 좋다.<br>하지만 일반적으로 개인이 만든 pool은 코드를 헷갈리게 하고 성능을 떨어뜨린다.<br>(요즘 GC는 최적화가 잘되서, pool을 만드는 것보다 그냥 객체를 생성하는게 더 빠르다고 한다.)</p><h1 id="예외는-있다">예외는 있다.</h1><p>방어적 복사본을 만들어야 하는 경우가 있다.<br>불변 객체를 유지하기 위해 객체를 수정할 때 마다 새로운 객체를 만들어서 데이터를 수정하는 방식인데, 얼핏 보면 쓸 떼 없는 객체를 생성하는 것 처럼 보인다.<br>하지만 객체를 좀 더 만드는 피해보다, 객체가 재사용 되면서 불변성이 깨져 버그가 발생하는 피해가 더 크다는 사실을 명심해야 한다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 6. 불필요한 객체 생성을 피하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/07/effective-java-item6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/01/07/effective-java-item5/</link>
      <guid>https://jaehun2841.github.io/2019/01/07/effective-java-item5/</guid>
      <pubDate>Mon, 07 Jan 2019 12:03:48 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 방식이나, 싱글턴 방식이 적합하지 않다.&lt;br&gt;
자원에 따라 동작이 달라진다면, 자원의 수만큼 인스턴스를 만들어 동작하게 하는 것이 좋다.&lt;br&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 방식이나, 싱글턴 방식이 적합하지 않다.<br>자원에 따라 동작이 달라진다면, 자원의 수만큼 인스턴스를 만들어 동작하게 하는 것이 좋다.<br>이를 <code>의존 객체 주입</code>이라고 하는데 Spring과 같은 프레임워크에서 DI의 개념으로 많이 쓰이고 있다.</p><p>의존 객체 주입은 생성자, 정적팩터리, 빌더 혹은 Setter를 이용해서 자원을 넘겨 줄 수 있다.</p><h1 id="팩터리-메서드-패턴-사용하여-자원-넘겨주기">팩터리 메서드 패턴 사용하여 자원 넘겨주기</h1><p>자바8에서는 Supplier&lt;T&gt; 인터페이스가 팩터리를 표현한 완벽한 예다.<br>Supplier&lt;T&gt;를 입력으로 받는 메서드는 일반적으로 한정적 와일드 카드 타입을 사용해 팩터리의 타입 매개변수를 제한한다.</p><p>아래의 예제처럼 사용한다.타일들을 이용해 모자이크를 만드는 예제이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mosaic <span class="title">create</span><span class="params">(Supplier&lt;? extends Tile&gt; tileFactory)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><h1 id="요약">요약</h1><ul><li>클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸 클래스는 사용하지 말자!</li><li>필요한 자원 또는 팩터리를 생성자나 빌더를 통해 의존 객체를 주입하도록 하자</li><li>의존 객체 주입은 유연성, 재사용성, 테스트 용이성을 높여 줄 것이다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/07/effective-java-item5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 4. 인스턴스화를 막으려거든 Private 생성자를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/01/07/effective-java-item4/</link>
      <guid>https://jaehun2841.github.io/2019/01/07/effective-java-item4/</guid>
      <pubDate>Mon, 07 Jan 2019 11:44:23 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;단순히 static 메서드와 static 필드만을 담은 클래스를 만들고 싶을 때가 있다.&lt;br&gt;
보통 Utils 클래스를 정의할 떄 이런식으로 많이 사용하는데, 이러한 클래스는 인스턴스를 만들어서 사용하고자 만
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>단순히 static 메서드와 static 필드만을 담은 클래스를 만들고 싶을 때가 있다.<br>보통 Utils 클래스를 정의할 떄 이런식으로 많이 사용하는데, 이러한 클래스는 인스턴스를 만들어서 사용하고자 만든 목적이 아니기 때문에 인스턴스화를 막아야 한다.<br>생성자를 하나도 명시 하지 않으면 Java에서는 매개변수가 없는 default 생성자를 만들어 준다.</p><h1 id="추상-클래스로-만들면">추상 클래스로 만들면?</h1><p>추상 클래스로 만드는 것으로는 인스턴스 화를 막을 수 없다.<br>단순히 상속을 통해 인스턴스를 만들 수 있기 때문이다. 오히려 abstract 클래스는 하위클래스를 만들어서 사용하라는 뉘앙스가 더 강하다.</p><h1 id="private-생성자를-만들자">private 생성자를 만들자</h1><p>private 생성자를 만드는 것 만으로도 인스턴스화를 막을 수 있다.외부에서 new 키워드를 통해 인스턴스를 만들 수 없기 때문이다.</p><p>이중 보안을 하자면..<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Utils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이런 식으로 Error를 발생 시켜주자.</p><p>평소 코딩할 때는 Lombok을 이용해서 깔끔하게 등록해 주는 것도 방법이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utils</span>() </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 4. 인스턴스화를 막으려거든 private 생성자를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/07/effective-java-item4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 3. Private 생성자나 열거 타입으로 싱글턴임을 보증하라</title>
      <link>https://jaehun2841.github.io/2019/01/07/effective-java-item3/</link>
      <guid>https://jaehun2841.github.io/2019/01/07/effective-java-item3/</guid>
      <pubDate>Mon, 07 Jan 2019 10:34:19 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;싱글턴이란&quot;&gt;싱글턴이란?&lt;/h1&gt;
&lt;p&gt;싱글턴 객체란 Application내에서 단 1개의 인스턴스만 생성할 수 있는 클래스를 의미한다.&lt;br&gt;
시스템에서 유일성을 보장하기 위해 1개만 만들어야 하는 경우도 있고, 시스템 구조 상 1개 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="싱글턴이란">싱글턴이란?</h1><p>싱글턴 객체란 Application내에서 단 1개의 인스턴스만 생성할 수 있는 클래스를 의미한다.<br>시스템에서 유일성을 보장하기 위해 1개만 만들어야 하는 경우도 있고, 시스템 구조 상 1개 이상이 되면 개념적으로 맞지 않는 상황도 있기 때문이다.</p><h1 id="싱글턴을-만드는-방법">싱글턴을 만드는 방법</h1><h2 id="private-생성자-static-객체">private 생성자 + static 객체</h2><p>private 생성자를 통해 내부에서만 객체를 생성 할 수 있도록 하고,public static final 키워드를 이용해 static 변수로 1개의 인스턴스만 제공하는 방식이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>사용자가 Elvis 객체를 클라이언트에서 사용하기 위해서는<br>외부로 노출 된 생성자가 없기 때문에 Elvis.INSTANCE의 형태로 사용해야만 한다.<br>최초로 INSTANCE 변수가 초기화 될 때 private 생성자를 통해 단 한번 인스턴스가 생성되게 된다.</p><blockquote><p>하지만, Java의 Reflection기능을 이용하여, AccessibleObject.setAccessible(true)를 이용하면 private 생성자를 호출 할 수 있다.<br>(이런 부분은 논외로 한다.)  여차하면 두번째 호출 부터 Exception을 발생 시켜 싱글턴을 보장할 수 있도록 방어로직을 심을 수 있다.</p></blockquote><h2 id="정적-팩터리-메서드">정적 팩터리 메서드</h2><p>위의 private 생성자 + static 객체에서 조금 진화된 형태가 클래스에서 정적 팩터리 메서드를 제공하는 case이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p>지금은 싱글턴 객체를 리턴하는 정적 메서드이지만, 향후 필요에 따라 변경될 수 있는 확장성을 가지고 있다.특정 파라미터나, 특정 스레드에는 다른 인스턴스를 리턴한다던지에 대해 확장과 변경에 열려 있는 장점이 있다.</p></li><li><p>원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.</p></li><li><p>정적 팩터리 메서드의 참조를 공급자(Supplier)로 만들 수 있다.</p></li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Supplier&lt;Elvis&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="열거-타입enum을-이용한-싱글턴-객체-생성">열거 타입(Enum)을 이용한 싱글턴 객체 생성</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1번째 예시와 비슷하지만 가장 안전하고 좋은 방법이다.복잡한 직렬화 상황이나, 리플렉션 공격에도 안전하다.<br>단, 만들려는 싱글턴이 Enum이외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다.<br>(열거 타입이 다른 인터페이스를 구현하도록 하는 건 가능.)</p><h1 id="싱글턴-객체의-직렬화">싱글턴 객체의 직렬화</h1><p>싱글턴 클래스를 직렬화 하기 위해서는 Serializable을 구현한다고 선언하는 것 만으로는 부족하다.<br>모든 인스턴스 필드에 transient 예약어를 붙여 직렬화를 막은 다음 readResolve 메서드를 제공해야 한다.<br>이렇게 하지 않으면 역직렬화 시점에 새로운 인스턴스가 생성 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//역직렬화가 되어 새로운 인스턴스가 생성되더라도, </span></span><br><span class="line">  <span class="comment">//클래스간 공유 변수인 static 변수를 이용하면 싱글턴을 보장 할 수 있다.</span></span><br><span class="line">  <span class="comment">// 새로운 인스턴스는 GC에 의해 UnReachable 형태로 판별되어 제거된다.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/07/effective-java-item3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라</title>
      <link>https://jaehun2841.github.io/2019/01/06/effective-java-item2/</link>
      <guid>https://jaehun2841.github.io/2019/01/06/effective-java-item2/</guid>
      <pubDate>Sun, 06 Jan 2019 10:40:34 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;정적 팩터리 메서드 팩터리와 생성자에는 똑같은 제약이 하나 있다.&lt;br&gt;
선택적 매개변수가 많을 경우에 적절하게 대응하기 어렵다는 점이다.&lt;br&gt;
매개변수가 3~4개까지는 어떻게 해보겠지만 엄청 많은 경우에는 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>정적 팩터리 메서드 팩터리와 생성자에는 똑같은 제약이 하나 있다.<br>선택적 매개변수가 많을 경우에 적절하게 대응하기 어렵다는 점이다.<br>매개변수가 3~4개까지는 어떻게 해보겠지만 엄청 많은 경우에는 생성자를 이용해 객체를 생성하는 과정부터가 곤욕이다.</p><p>아래의 예시를 보자<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat, <span class="keyword">int</span> sodium, <span class="keyword">int</span> carbonhydrate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">    <span class="keyword">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">    <span class="keyword">this</span>.calories = calories;          <span class="comment">//선택</span></span><br><span class="line">    <span class="keyword">this</span>.fat = fat;                    <span class="comment">//선택</span></span><br><span class="line">    <span class="keyword">this</span>.sodium = sodium;              <span class="comment">//선택</span></span><br><span class="line">    <span class="keyword">this</span>.carbohydrate = carbohydrate;  <span class="comment">//선택</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>매개변수가 int만 6개로 이루어져 있다.<br>그리고 default value가 정해져 있지 않기 때문에, servingSize 같은 변수는 정의하기 싫으면 0으로 해야할 지, 아니면 최소값이 있을지 알기가 어렵다.<br>그리고 매개변수 선언 순서가 바뀌면 의도하지 않은 객체가 생성되기 때문에 코딩 할 때 매우 주의를 요해야 한다.</p><h1 id="점층적-생성자-패턴">점층적 생성자 패턴</h1><p>위와 같은 문제를 조금이나마 해결해 보려는 노력이 점층적 생성자 패턴이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">    <span class="keyword">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(servingSize, servings);</span><br><span class="line">     <span class="keyword">this</span>.calories = calories;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(servingSize, servings, calories);</span><br><span class="line">     <span class="keyword">this</span>.fat = fat;     </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat, <span class="keyword">int</span> sodium, <span class="keyword">int</span> carbonhydrate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">    <span class="keyword">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">    <span class="keyword">this</span>.calories = calories;          <span class="comment">//선택</span></span><br><span class="line">    <span class="keyword">this</span>.fat = fat;                    <span class="comment">//선택</span></span><br><span class="line">    <span class="keyword">this</span>.sodium = sodium;              <span class="comment">//선택</span></span><br><span class="line">    <span class="keyword">this</span>.carbohydrate = carbohydrate;  <span class="comment">//선택</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이것도 선택사항에 대해 하나의 방법으로 작용할 수 있지만, 코드가 길어지고 가독성이 떨어지게 된다.<br>실제로 매개변수의 위치에 따라 의도하지 않은 객체가 생성될 수 있기 때문에 주의를 요해야 하는 코드이다.</p><h1 id="java-beans-패턴">Java Beans 패턴</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize = -<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServingSize</span><span class="params">(<span class="keyword">int</span> servingSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServings</span><span class="params">(<span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.servings = servings;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCalories</span><span class="params">(<span class="keyword">int</span> calories)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.calories = calories;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFat</span><span class="params">(<span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fat = fat;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSodium</span><span class="params">(<span class="keyword">int</span> sodium)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sodium = sodium;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCarboHydrate</span><span class="params">(<span class="keyword">int</span> carbohydrate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NutritionFacts nutritionFacts = <span class="keyword">new</span> NutritionFacts();</span><br><span class="line"></span><br><span class="line">nutritionFacts.setServingSize(<span class="number">240</span>);</span><br><span class="line">nutritionFacts.setServings(<span class="number">8</span>);</span><br><span class="line">nutritionFacts.setCalories(<span class="number">100</span>);</span><br><span class="line">nutritionFacts.setFat(<span class="number">20</span>);</span><br><span class="line">nutritionFacts.setSodium(<span class="number">35</span>);</span><br><span class="line">nutritionFacts.setCarboHydrate(<span class="number">27</span>);</span><br></pre></td></tr></table></figure></p><p>자바 빈즈 패턴에서는 객체 하나를 만드느느데 메서드를 여러개 호출 해야한다.  객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.<br>또한 객체의 불변셩이 깨지게 되어 코드에서 버그를 생성할 수 있다.</p><h1 id="builder-패턴">Builder 패턴</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">      <span class="keyword">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> calories)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.calories = calories;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fat = fat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> sodium)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sodium = sodium;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> carbohydrate)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat, <span class="keyword">int</span> sodium, <span class="keyword">int</span> carbonhydrate)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">      <span class="keyword">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">      <span class="keyword">this</span>.calories = calories;          <span class="comment">//선택</span></span><br><span class="line">      <span class="keyword">this</span>.fat = fat;                    <span class="comment">//선택</span></span><br><span class="line">      <span class="keyword">this</span>.sodium = sodium;              <span class="comment">//선택</span></span><br><span class="line">      <span class="keyword">this</span>.carbohydrate = carbohydrate;  <span class="comment">//선택</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts nutritionFacts = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">240</span>, <span class="number">8</span>)</span><br><span class="line">                                                  .calories(<span class="number">100</span>).sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build()</span><br></pre></td></tr></table></figure></p><p>빌더 패턴은 (파이썬과 스칼라에 있는) 명명된 선택적 매개변수를 흉내낸 것이다.<br>이런 식으로 하면 Java Beans 패턴의 set 역할을 해주면서 build()를 호출 하는 시점에 변수를 freezing 시켜 불변식을 유지 할 수 있다.하지만 시간이 지날 수록 매개 변수가 늘어날 가능성이 있음을 항상 주의 해야 한다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/06/effective-java-item2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라</title>
      <link>https://jaehun2841.github.io/2019/01/06/effective-java-item1/</link>
      <guid>https://jaehun2841.github.io/2019/01/06/effective-java-item1/</guid>
      <pubDate>Sun, 06 Jan 2019 08:42:25 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;개발자가 클래스의 인스턴스를 생성하는 방법은 new 키워드를 통한 생성자 호출이다.&lt;br&gt;
이외에도 생성자와 별도로 정적 팩터리 메서드를 이용해서 메서드 내부에서 생성자나, 이미 생성된 인스턴스를 반환하여 클라
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>개발자가 클래스의 인스턴스를 생성하는 방법은 new 키워드를 통한 생성자 호출이다.<br>이외에도 생성자와 별도로 정적 팩터리 메서드를 이용해서 메서드 내부에서 생성자나, 이미 생성된 인스턴스를 반환하여 클라이언트 코드에서 인스턴스를 사용 할 수 있다.</p><h1 id="정적static-팩터리-메서드가-좋은-점">정적(Static) 팩터리 메서드가 좋은 점</h1><h2 id="이름을-가질-수-있다">이름을 가질 수 있다.</h2><p>생성자의 파라미터 시그니처만으로는 어떤 객체를 반환 할 지에 대한 특성을 이해하기 어렵다.<br>하지만, 정적 팩터리 메서드의 경우는 메서드 이름으로 충분히 유추 할 수 있기 때문에 가독성이 좋아진다.</p><h2 id="호출-될-때-마다-인스턴스를-생성하지-않아도-된다">호출 될 때 마다 인스턴스를 생성하지 않아도 된다.</h2><p>new를 통해 인스턴스를 생성하게 되면, 불필요한 중복 객체를 생성할 가능성이 많이진다.<br>하나의 객체를 이용해 캐싱하고 쓰는 경우 정적 팩터리 메서드를 사용하는 게 장점이 될 수 있다.</p><p>대표적으로 Boolean에 대한 예시가 있다.<br>매번 new Boolean(false)처럼 사용을 하면 사용할 때 마다 중복되는 Boolean 객체를 생성하게 된다.</p><p>하지만 대충 이런식으로 정적 팩터리 메서드를 제공하는 경우<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Boolean&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FLASE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean.TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? TRUE : FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>쓸 데 없는 boolean 객체를 만들지 않아도 되기 때문에 메모리 관리 측면에서 유리하다.<br>또한 객체를 싱글턴(singleton)으로 제공할 수 있고, 인스턴스화 불가로 만들 수 도 있다.</p><blockquote><p>반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제 할 수 있다.<br>이런 클래스를 <strong>인스턴스 통제(instance-controlled) 클래스</strong>라 한다.</p></blockquote><h2 id="반환타입의-하위타입-객체child를-반환-할-수-있다">반환타입의 하위타입 객체(Child)를 반환 할 수 있다.</h2><p>인터페이스를 사용해 하위타입 객체를 반환 할 수 있다. 인터페이스 기반 프레임워크의 핵심 기술이라고 볼 수 있다.<br>SpringFramework를 사용하는 경우에도 유용하게 사용 할 수 있다.<br>아래와 같은 예시 코드를 보자</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PaymentService kakaoPaymentService;</span><br><span class="line"><span class="keyword">private</span> PaymentService naverPaymentService;</span><br><span class="line"><span class="keyword">private</span> PaymentService paycoPaymentService;</span><br><span class="line"><span class="keyword">private</span> PaymentService rocketPaymentService;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaymentService <span class="title">getType</span><span class="params">(PaymentType payentType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> KAKAO: <span class="keyword">return</span> kakaoPaymentService;</span><br><span class="line">  <span class="keyword">case</span> NAVER: <span class="keyword">return</span> naverPaymentService;</span><br><span class="line">  <span class="keyword">case</span> PAYCO: <span class="keyword">return</span> paycoPaymentService;</span><br><span class="line">  <span class="keyword">case</span> ROCKET: <span class="keyword">return</span> rocketPaymentService;</span><br><span class="line">  <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>외부 결제 모듈을 사용한다고 가정 했을 때 이런식으로 Interface를 통한 하위타입 객체를 제공할 수 있다.</p><h2 id="입력-매개변수에-따라-매번-다른-클래스의-객체를-반환-할-수-있다">입력 매개변수에 따라 매번 다른 클래스의 객체를 반환 할 수 있다.</h2><p>EnumSet 클래스는 public 생성자 없이 오직 정적 팩터리 메서드만 제공한다.<br>OpenJDK에서는 원소가 64개 이하이면 원소들을 long변수 하나로 관리하는 RegularEnumSet의 인스턴스를 리턴하고,<br>65개 이상이면 long배열로 관리하는 JumboEnumSet의 인스턴스를 반환한다.</p><p>클라이언트는 EnumSet 객체이면 되기 때문에 무슨객체가 리턴되든 알 필요가 없다.</p><h2 id="정적-팩터리-메서드를-작성하는-시점에는-반환할-객체의-클래스가-존재하지-않아도-된다">정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.</h2><p>이러한 유연함은 Service Provider 프레임워크의 근간이 된다.대표적인 예로 JDBC가 있다.</p><ol><li>DriverManager.registerDriver() 메서드로 각 DBMS별 Driver를 설정한다. (제공자 등록 API)</li><li>DriverManager.getConnection() 메서드로 DB 커넥션 객체를 받는다. (service access API)</li><li>Connection Interface는 DBMS 별로 동작을 구현하여 사용할 수 있다. (service Interface)</li></ol><p>위와 같이 동작하게 된다면 차후에 다른 DBMS가 나오더라도 같은 Interface를 사용하여 기존과 동일하게 사용이 가능하다.</p><h1 id="정적static-팩터리-메서드의-단점">정적(Static) 팩터리 메서드의 단점</h1><h2 id="상속을-하려면-publicprotected-생성자가-필요하다">상속을 하려면 public/protected 생성자가 필요하다.</h2><p>상속을 하기 위해서는 public/protected 생성자가 필요하니, 정적 팩터리 메서드만 제공하면 하위클래스를 만들 수가 없다.</p><blockquote><p>컬렉션 프레임 워크의 유틸리티 구현 클래스는 private 생성자만 제공하므로 상속이 불가하다.<br>이러한 제약은 상속보다 컴포지션을 사용하도록 유도되어 오히려 더 장점으로 작용한다.</p></blockquote><h2 id="정적-팩터리-메서드는-개발자가-찾기-어렵다">정적 팩터리 메서드는 개발자가 찾기 어렵다.</h2><p>생성자 처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화 할 방법을 찾아야 한다.</p><h1 id="정적static-팩터리-메서드-명명-규칙">정적(static) 팩터리 메서드 명명 규칙</h1><ul><li>from - 매개변수를 하나만 받아서 해당 타입의 인스턴스를 반환하는 메서드<ul><li>예시) Date date = Date.from(dateStr);</li></ul></li><li>of - 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드<ul><li>예시) Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</li></ul></li><li>valueOf - from과 of의 더 자세한 버전<ul><li>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</li></ul></li><li>instance(getInstance) - 매개변수를 받는다면, 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지 않는다.<ul><li>StackWalker luke = StackWalker.getInstance(options);</li></ul></li><li>create(newInstance) - instance/getInstance와 같지만, 매번 새로운 인스턴스를 반환함을 보장한다.</li><li>get(Type) - getInstance와 맥락은 같으나 특정 Type을 반환할 때 사용<ul><li>Steak steak = Food.getSteak(Meet.BEEF);</li></ul></li><li>new(Type) - newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스의 팩터리 메서드를 정의 할 때 사용<ul><li>Steak steak = Food.newSteak(Meet.BEEF);</li></ul></li><li>(Type) - getType, newType의 같결한 버전<ul><li>Steak steak = Food.steak(Meet.BEEF);</li></ul></li></ul><h1 id="요약">요약</h1><p>정적 팩터리 메서드는 각각의 쓰임새가 있으니, 장단점을 잘 인식하고 쓰는게 좋다.<br>대부분의 경우가 정적 팩터리 메서드로 인스턴스를 생성하는게 유리하니 무작정 public 생성자만 사용하는 습관은 고치는게 좋다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/06/effective-java-item1/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
