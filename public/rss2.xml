<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Carrey`s 기술블로그</title>
    <link>https://jaehun2841.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 07 Jan 2019 13:32:09 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Item 9. Try-Finally 보다는 Try-With-Resources를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/01/08/effective-java-item9/</link>
      <guid>https://jaehun2841.github.io/2019/01/08/effective-java-item9/</guid>
      <pubDate>Tue, 08 Jan 2019 07:30:31 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Java 라이브러리 중에는 close메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, Connection등이 있다.&lt;br&gt;
자원 닫기는 클라이언트가 놓치기 쉽기 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Java 라이브러리 중에는 close메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, Connection등이 있다.<br>자원 닫기는 클라이언트가 놓치기 쉽기 때문에 예측할 수 없는 성능 문제로 이어지기도 한다.</p><p>나의 경우에도 신입 때 JDBC로 개발을 해야 했던 적이 있었는데,<br>DB의 max-connection이 10이어서 11번째 호출 시 부터는 JDBCException이 발생하는 오류를 겪은 적이 있다.<br>알고 보니 하나의 메서드에서 Connection 객체에 대한 참조를 해제 하지 않아 계속 Connection을 물고 있는 상황이었다.<br>Spring을 사용하면서는 Mybatis나 JPA같은 프레임웍 내에서 자원에 대한 관리를 해주기 때문에 이런 일을 만날 일은 없게 되었다.</p><p>하지만 예전처럼 JDBC를 사용하거나, IO관련 작업을 할 때는 반드시 close를 통해 자원에 대한 해제가 필요하다.<br>이전에는 finallizer를 통해 했다고는 아는데 이전 장에서 봤듯이 안 쓰는것이 좋다.<br>그리고 try-catch-finally 구문을 통해 Exception이 발생하더라도, finally 절에서 close를 호출 하도록 했는데, 코드가 복잡해 지고, finally 절 내에서 Exception이 발생하는 경우도 있기 때문에 이를 방지하기 위해 더 더러운 코드를 생산하는 일이 적지 않았다.</p><p>옛날에 자주 사용해 본 아주아주 슬픈 코드이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCExam</span> </span>&#123;</span><br><span class="line">  Connection connection;</span><br><span class="line">  Statement statement;</span><br><span class="line">  ResultSet resultSet;</span><br><span class="line"></span><br><span class="line">  String driverName = <span class="string">"oracle.jdbc.driver.OracleDriver"</span>;</span><br><span class="line">  String url = <span class="string">"oracle:thin:localhost:1521:ORCL"</span>;</span><br><span class="line">  String user = <span class="string">"scott"</span>;</span><br><span class="line">  String password = <span class="string">"tiger"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JDBCExam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Class.forName(driverName);</span><br><span class="line">          connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">"[로드 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">"[연결 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  connection.close();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  statement.close();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  resultSet.close();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">              System.out.println(<span class="string">"[닫기 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="autocloseable">AutoCloseable</h1><p>JDK 1.7 부터 try-with-resources 구문이 추가 되었고, <code>AutoCloseable</code> 인터페이스가 추가되었다. 이 인터페이스가 나오고 부터 Java의 close를 지원하는 클래스에서 AutoCloseable을 구현하도록 변경되었다.</p><h1 id="try-with-resources">try-with-resources</h1><p>try 절에 AutoCloseable을 구현한 클래스에 대한 인스턴스를 선언하게 되면 try절이 종료되는 시점에 AutoCloseable 인터페이스의 close() 메서드를 자동으로 호출 한다. 그렇기 때문에 이전처럼 finally 구문에서 별도로 자원에 대한 해제를 하지 않아도 된다.</p><p>위의 예시코드를 try-with-resources 구문으로 바꿔보았다.<br>위의 코드보다는 한층 깔끔해 짐을 볼 수 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String driverName = <span class="string">"oracle.jdbc.driver.OracleDriver"</span>;</span><br><span class="line">    String url = <span class="string">"oracle:thin:localhost:1521:ORCL"</span>;</span><br><span class="line">    String user = <span class="string">"scott"</span>;</span><br><span class="line">    String password = <span class="string">"tiger"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDBCExam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">             Statement statement = connection.prepareStatement(<span class="string">"select * from member"</span>);</span><br><span class="line">             ResultSet resultSet = statement.getResultSet();</span><br><span class="line">             )&#123;</span><br><span class="line">            Class.forName(driverName);</span><br><span class="line">            String name = resultSet.getString(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"회원명 : "</span> + name);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"[로드 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"[연결 오류]\n"</span> + e.getStackTrace());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 9. try-finally 보다는 try-with-resources를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/08/effective-java-item9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 8. Finalizer와 Cleaner 사용은 피하라</title>
      <link>https://jaehun2841.github.io/2019/01/08/effective-java-item8/</link>
      <guid>https://jaehun2841.github.io/2019/01/08/effective-java-item8/</guid>
      <pubDate>Mon, 07 Jan 2019 15:32:01 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Java에서는 2가지의 객체 소멸자를 제공한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;finalzier&lt;/li&gt;
&lt;li&gt;cleaner&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 2가지 객체 소멸자는 JVM내의 GC가 작동할 때 실행되는 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Java에서는 2가지의 객체 소멸자를 제공한다.</p><ul><li>finalzier</li><li>cleaner</li></ul><p>이 2가지 객체 소멸자는 JVM내의 GC가 작동할 때 실행되는 구문이다.<br>기본적으로 이 2가지 구문은 <strong>사용하지 말아야 한다.</strong><br>현재 Java 9 버전 부터는 Object 클래스에 대한 finalizer를 <code>Deprecated</code> 처리하였다.<br>아래에 사용하지 말아햐 하는 이유를 하나씩 보도록 하겠다.</p><h1 id="finalizer와-cleaner를-사용하지-말아야-하는-이유">finalizer와 cleaner를 사용하지 말아야 하는 이유</h1><h2 id="실행을-보장할-수-없다">실행을 보장할 수 없다.</h2><p>finalizer에 특정 로직을 삽입하는 경우 실행을 보장 할 수 없다.<br>기본적으로 GC가 발생할 때 실행되는 로직이지만, Java Application이 죽는다던지의 이유로 finalizer 실행이 되지 않을 수 있다.<br>그렇기 때문에 제 때 실행되어야 하거나, 뭔가 상태를 수정하는 행위를 절대적으로 하면은 안된다.</p><h2 id="느리다">느리다.</h2><p>Effective Java 책의 예제에서는 AutoCloseable과 finalizer의 성능비교를 한 문단이 있다.<br>Autocloseable을 사용한 GC 수행시간은 12ns였지만, finalizer를 사용한 GC 수행 시간은 550ns가 걸렸다고 한다.<br>finalizer가 가비지 컬렉터의 효율을 떨어뜨리기 때문이다.</p><h2 id="시스템-전체-장애를-유발-할-수-있다">시스템 전체 장애를 유발 할 수 있다.</h2><p>Java API 문서 상에서는 GC가 UnReachable 상태의 객체를 가비지 컬렉션 할 때 finalizer가 호출된다고 명시하고 있다.<br>하지만 finalizer가 실행되는 시점은 GC 발생 시 즉각적으로 이루어지는게 아니다.<br>finalizer queue에 삽입되어 순차적으로 finalizer를 실행하게 된다.<br>그렇기 때문에 finalizer메소드 실행이 느린 경우 객체 소멸이 느려지므로  <code>Out of Memory</code>와 같은 오류를 발생 시킬 가능성이 높아지게 된다.</p><h2 id="finalizer-공격에-취약하다">finalizer 공격에 취약하다.</h2><p>위에 적은 것 처럼 finalizer 메소드 실행시간이 오래 걸리게 만들면 시스템에 심각한 장애를 유발할 수 있다.<br>finalizer 메서드를 override해서 악의적으로 느리게 할 수 있기 떄문에 finalizer를 사용해야 하는 경우라면<br>메소드에 <code>final</code> 키워드를 붙여서 상속하지 못하도록 해야한다.</p><h1 id="그럼-finalizer나-cleaner는-어디서-쓰나">그럼 finalizer나 cleaner는 어디서 쓰나?</h1><ul><li>개발자가 객체의 close를 호출하지 않는 경우 -&gt; 자원 해제를 안하느니 느리더라도 하는게 낫다.<br>(이 경우는 동의 못하겠다. 개발자가 close를 시켜야 한다.)</li><li>native peer와 연결된 객체<ul><li>native peer는 자바 객체가 아니기 떄문에 가비지 컬렉터의 관리 대상이 아니다.<br>그렇기 때문에 native peer가 회수 될때 finalizer 메서드를 실행해 자원을 해제 할 수 있다.</li></ul></li></ul><h1 id="finalizer-기능이-필요한-경우에는-어떻게">finalizer 기능이 필요한 경우에는 어떻게?</h1><p>Autocloseable Interface를 사용하여 close를 호출시키도록 하자.<br>다음장의 try-catch-resource 구문에서 설명하도록 하겠다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 8. finalizer와 cleaner 사용은 피하라</li><li><a href="http://www.yunsobi.com/blog/entry/finalize-%EB%A9%94%EC%86%8C%EB%93%9C%EC%9D%98-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EC%9D%84-%EC%9E%90%EC%A0%9C%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0" target="_blank" rel="noopener">finalize 메소드의 오버라이딩을 자제해야 하는 이유.</a></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/08/effective-java-item8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 7. 다 쓴 객체는 참조를 해제하라</title>
      <link>https://jaehun2841.github.io/2019/01/07/effective-java-item7/</link>
      <guid>https://jaehun2841.github.io/2019/01/07/effective-java-item7/</guid>
      <pubDate>Mon, 07 Jan 2019 13:21:26 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;Java의 장점 중 하나는 가비지 컬렉션을 지원하는 언어라는 점이다.&lt;br&gt;
C, C++ 처럼 개발자가 메모리를 직접 할당하고 해제하는 방식이 아니기 때문에 Java에서는 메모리 관리가 굉장히 편하다는 장점이 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>Java의 장점 중 하나는 가비지 컬렉션을 지원하는 언어라는 점이다.<br>C, C++ 처럼 개발자가 메모리를 직접 할당하고 해제하는 방식이 아니기 때문에 Java에서는 메모리 관리가 굉장히 편하다는 장점이 있다.</p><p>하지만 <code>아예 신경을 안써도 되는 것은 아니다.</code><br>가비지 컬렉션을 통해 소멸 대상이 되는 객체가 되기 위해서는 어떠한 reference 변수에서 가르키지 않아야 한다.<br>다 쓴 객체에 대한 참조를 해제하지 않으면 가비지 컬렉션의 대상이 되지 않아 계속 메모리가 할당 되는 <strong>메모리 누수</strong> 현상이 발생 된다.</p><p>가비지 컬렉션을 지원하는 언어에서는 메모리 누수를 찾기가 까다롭다<br>객체 참조(reference)를 하나 살려두면, 가비지 컬렉터는 그 객체 뿐만 아니라 그 객체 내에서 참조하고 있는 객체까지 회수 할 수 없다.</p><p>이로 인해 잠재적으로 성능에 악영향을 줄 수 있다.</p><h1 id="가비지-컬렉션의-소멸-대상이-되기-위해서는">가비지 컬렉션의 소멸 대상이 되기 위해서는...</h1><h2 id="직접-할당-해제">직접 할당 해제</h2><ul><li>이 방법은 굉장히 단순하다.<br>말 그대로 객체 참조 변수를 null로 초기화 한다.<br>그렇게 되면 실제 heap 메모리에 존재하는 객체는 어떠한 참조(reference)도 가지지 않기 때문에<code>가비지 컬렉션의 소멸 대상</code>이 된다.</li><li>하지만 바람직한 방법은 아니다. 반드시 필요한 경우에만 사용 할 수 있도록 하는 것이 좋다.<br>(소스코드가 드러워짐 -_-)</li><li>클래스 내에서 메모리를 관리 하는 객체(Stack 같은...)라면 이 방법을 통해 다 쓴 객체는 할당을 해제 하는 것이 옳다.</li></ul><h2 id="scope를-통한-자동-할당-해제">Scope를 통한 자동 할당 해제</h2><ul><li>보통은 변수 선언<code>(대게 지역변수)</code>과 동시에 초기화를 사용한다.<br>그 변수에 대한 scope가 종료되는 순간 reference가 해제되어 가비지 컬렉션의 대상이 된다.</li><li>try~catch와 같은 구문에서는 catch 구문에서 try내에서 사용하는 변수를 참조하지 못하므로try~catch 변수 초기화를 하기 어렵다.<br>그렇게 때문에 finally 구문에서 변수에 대한 참조를 해제한다.</li></ul><h1 id="메모리-누수를-일으키는-주범">메모리 누수를 일으키는 주범</h1><ul><li>첫번째는 위에서 설명한 class내에서 instance에 대한 참조(reference)를 관리하는 객체이다.</li><li>두번째는 Map과 같은 캐시</li><li>세번째는 리스너(Listener) 혹은 콜백(Callback)</li></ul><p>Map과 같은 캐시에 객체참조를 넣어두고 사용이 끝났는데도 초기화를 안시켜주는 경우 메모리 누수가 발생한다.<br>엔트리가 살아있는 동안만 캐시를 사용하려면 <code>WeakHashMap</code>을 사용하자.<br>WeakHashMap을 이해하려면 Java의 Reference를 좀 알아야 한다.</p><h2 id="java-reference">Java Reference</h2><p>Java에는 4가지의 Reference가 있다.</p><ul><li><p>Strong Reference</p><ul><li>우리가 흔히 사용하는 reference</li><li>String str = new String(&quot;abc&quot;); 와 같은 형태</li><li>Strong Reference는 GC의 대상이 되지 않는다.</li><li>Strong Reference관계의 객체가 GC가 되기 위해선 null로 초기화해<br>객체에 대한 Reachability상태를 UnReachable 상태로 만들어 줘야 한다.</li></ul></li><li><p>Soft Reference</p><ul><li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference만 있는 상태</li><li>SoftReference&lt;Class&gt; ref = new SoftReference&lt;&gt;(new String(&quot;abc&quot;));와 같은 형태로 사용</li><li>Soft Reference는 대게 GC대상이 아니다가 <code>out of memory에러</code>가 나기 직전까지 가면<br>Soft Reference 관계에 있는 객체들은 GC대상이 된다.</li></ul></li><li><p>Weak Reference</p><ul><li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference가 없고 Weak Reference만 있는 상태</li><li>WeakReference&lt;Class&gt; ref = new WeakReference&lt;Class&gt;(new String(&quot;abc&quot;)); 와 같은 형태로 사용</li><li>WeakReference는 GC가 발생 할 때마다 대상이 된다.</li></ul></li><li><p>Phantomly Reference</p><ul><li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference와 Weak Referencerk 모두가 해당되지 않는 객체</li><li>finalize 되었지만 메모리가 아직 회수 되지 않은 객체</li><li>아직 잘 이해가... 안됨</li></ul></li></ul><h2 id="weakhashmap">WeakHashMap</h2><p>Weak Reference를 이용한 HashMap<br>아래의 예제코드를 보자<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassWeakHashMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Referred</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Good bye cruel world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * GC를 발생 시켜 메모리를 회수하는 코드</span></span><br><span class="line"><span class="comment">    * System.gc()가 잘 동작할지는 모르겠다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Suggesting collection"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"Sleeping"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Creating weak references"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is now a weak reference. </span></span><br><span class="line">        <span class="comment">// The object will be collected only if no strong references. </span></span><br><span class="line">        Referred strong = <span class="keyword">new</span> Referred(); <span class="comment">//Strong Reference로 하나 추가</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Weak Reference를 이용한 WeakHashMap에 엔트리를 추가하여</span></span><br><span class="line">        <span class="comment">//Weak Reference 추가</span></span><br><span class="line">        Map&lt;Referred, String&gt; metadata = <span class="keyword">new</span> WeakHashMap&lt;Referred, String&gt;();</span><br><span class="line">        metadata.put(strong, <span class="string">"WeakHashMap's make my world go around"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attempt to claim a suggested reference. </span></span><br><span class="line">        ClassWeakHashMap.collect();</span><br><span class="line">        <span class="comment">//여기서는 gc가 발생해도 GC대상이 아니게 된다.</span></span><br><span class="line">        <span class="comment">//strong이라는 변수를 통해 Strong Reference를 가지므로 GC 대상이 아니다.</span></span><br><span class="line">        System.out.println(<span class="string">"Still has metadata entry? "</span> + (metadata.size() == <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"Removing reference"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The object may be collected. </span></span><br><span class="line">        <span class="comment">//Strong Reference를 끊었다.</span></span><br><span class="line">        strong = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//여기서는 Weak Reference만 남아 있기 때문에 GC대상이 된다.</span></span><br><span class="line">        ClassWeakHashMap.collect();</span><br><span class="line">        System.out.println(<span class="string">"Still has metadata entry? "</span> + (metadata.size() == <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Weak Reference를 가지고 있으면 GC가 발생되기 전까지 객체에 접근이 가능하기 때문에 메모리 누수의 입장으로 볼 때 유리한 것 같다.<br>한번 캐싱하고 사용하고 버리는 대상에 좋은 방법이다.</p><p>하지만 static한 Map을 사용하는 경우에는 비추이다.<br>언제 GC가 일어날지 모를 뿐더러.. 갑자기 데이터가 사라져 자칫 하면 장애가 발생 할 수 있으니,특별한 경우에만 WeakHashMap을 사용해야 한다.</p><h2 id="리스너-혹은-콜백">리스너 혹은 콜백</h2><p>리스너와 콜백은 root set에 대한 직접 참조가 아닌 객체에서 참조를 가지고 있다.<br>그렇기 때문에 리스너와 콜백을 사용하는 객체가 unreachable 상태가 되지 않는 이상 메모리에서 GC대상이 되지 않는다.<br>이 경우 weak reference를 이용하면 리스너와 콜백을 사용하고, GC 작동 시에 메모리 해제를 시킬 수 있어, 메모리 누수에 도움이 된다.</p><h1 id="추가적으로">추가적으로..</h1><p>메모리 누수는 겉으로 잘 드러나지 않아 수년 간 잠복하는 사례가 있다고 한다.<br>이런 누수는 철저한 코드리뷰나 힙 프로파일링 도구를 통해 디버깅을 동원해야 발견할 수 있으므로,<br>평소에 코드를 작성할 때 메모리 누수에 대한 부분을 신경을 써주는 것이 중요하다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 7. 다 쓴 객체는 참조를 해제하라</li><li>https://d2.naver.com/helloworld/329631</li><li>https://tourspace.tistory.com/42</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/07/effective-java-item7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 6. 불필요한 객체 생성을 피하라</title>
      <link>https://jaehun2841.github.io/2019/01/07/effective-java-item6/</link>
      <guid>https://jaehun2841.github.io/2019/01/07/effective-java-item6/</guid>
      <pubDate>Mon, 07 Jan 2019 12:33:11 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;똑같은 기능의 객체를 매번 생성하기 보다는 객체 하나는 재사용하는 편이 나을 때가 많다. (아니 거의 무조건 재사용 할 수 있으면 하는 게 좋다.)&lt;br&gt;
재사용은 빠르고 세련되며, 특히 불변 객체는 언제든지 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>똑같은 기능의 객체를 매번 생성하기 보다는 객체 하나는 재사용하는 편이 나을 때가 많다. (아니 거의 무조건 재사용 할 수 있으면 하는 게 좋다.)<br>재사용은 빠르고 세련되며, 특히 불변 객체는 언제든지 안전하게 재사용 할 수 있다.</p><h1 id="아주-안-좋은-객체-생성의-예">아주 안 좋은 객체 생성의 예</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure></p><p>이러한 코드는 매번 새로운 String 객체를 생성하게 된다.</p><h1 id="string-constant-pool">String Constant pool</h1><p>위의 코드를 조금 더 보완하면 아래 코드 처럼 사용할 수 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure></p><p>Java JVM에는 String Constant pool 이라는 것이 있다.<br>(Java 7 버전을 기점으로 Perm영역 -&gt; Heap 영역으로 변경되었다.)<br>위 처럼 쓰는 방식을 String 리터럴 방식이라 한다.</p><p>String 리터럴을 사용할 경우 기본적으로 String 내장 메서드인 intern()이라는 메서드를 호출하게 된다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"Hello"</span>; <span class="comment">// 1</span></span><br><span class="line">String b = <span class="string">"Hello"</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><ol><li><p>최초로 Hello라는 String 리터럴을 사용하였기 때문에 intern() 메서드가 호출된다.<br>--&gt; String Constant pool에서 해당 문자열을 검색하였지만 존재 하지 않기 때문에 String Constant pool에 넣고 새로운 주소값을 반환한다.</p></li><li><p>두번째로 Hello라는 String 리터럴을 사용하였기 때문에 마찬가지로 intern() 메서드가 호출된다.<br>--&gt; String Constant pool에서 해당 문자열을 검색하니 기존에 등록된 주소 값이 반환된다.</p></li></ol><p>실질적으로 a와 b는 같은 주소값을 가지게 된다.</p><p>그렇기 때문에<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(a == b);      <span class="comment">//true</span></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>위의 코드를 실행해 보면 객체의 동등성 비교와 동일성 비교에서 모두 true가 나온다.</p><ul><li>동등성(equality) : 두 객체의 내용이 같은지 비교</li><li>동일성(identity) : 두 객체가 같은 객체인지 hashcode를 비교</li></ul><p>그렇기 때문에 String을 사용할 경우에는 new를 이용한 객체 생성 방식보다 String 리터럴을 사용하는 방식이 더 좋다. (같은 객체를 재사용 하기 때문)</p><blockquote><p>그렇다고 실제 코드에서 String 리터럴을 사용했다고 <code>==</code> 을 이용한 동일성 비교는 하지말자.<br>상당히 위험한 코드이고, 다른 결과를 초래 할 가능성이 매우 높다.</p></blockquote><h1 id="boolean의-예시">Boolean의 예시</h1><p>Boolean의 경우 new Boolean(true)보다 Boolean.valueOf를 사용하는 것이 더 좋다.</p><p>Boolean 클래스를 보면..<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                                      <span class="title">Comparable</span>&lt;<span class="title">Boolean</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment">     * value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment">     * value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of the Boolean.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3665804199014368530L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span>(since=<span class="string">"9"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span>(since=<span class="string">"9"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parseBoolean(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">parseBoolean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"true"</span>.equalsIgnoreCase(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">booleanValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>new Boolean의 경우 그때그때 새로운 객체를 생성하게 된다.<br>(로컬 컴퓨터에는 OpenJDK 11이 설치되어있는데 Java 9 버전 부터 Boolean 생성자는 Deprecated 처리 되었다.)</p><p>하지만, Boolean.valueOf 라는 정적 메서드는 TRUE, FLASE라는 정적 필드에 이미 생성한 인스턴스를 사용하고 있기 때문에<br>객체를 추가적으로 생성하지 않아 성능상 이점이 있기 때문이다.</p><h1 id="auto-boxing을-주의하라">Auto Boxing을 주의하라!</h1><p>오토박싱은 Java 5 부터 나온 기능이다.<br>primitive 타입과 Class 타입을 자동으로 변환해 주는 기능이다.<br>이 기능에 대해 간과하게 되면 쓸 데 없는 객체를 많이 만들어 낼 수 있다.</p><p>책에 소개 된 예제를 잠깐 돌아보면..<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Long sum = <span class="number">0L</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">    sum += i; <span class="comment">//i에 대해 Auto Boxing이 일어나고 있다.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>i가 더해질 때 마다 AutoBoxing이 발생하게 된다.<br>sum 변수를 쓸데 없이 long으로 선언해서 Long객체가 2^32개 만큼 쓸데 없이 생성 되었다. (책에는 231개라고 나와있는데 오타일 거라 생각한다.)<br>sum을 long으로만 바꿔줘도 불필요한 객체가 생성되는 일은 없을 것이며, 성능도 더 빨라지게 된다. (책에서는 6.3초 -&gt; 0.59초로 성능 향상을 보았다고 한다.)</p><h1 id="나만의-객체-pool을-만들지-말자">나만의 객체 Pool을 만들지 말자</h1><p>객체를 생성하는 비용이 많이 드는 객체라면 미리 pool을 생성하여 사용하면 좋다.<br>JDBC에서 사용하는 Connection pool은 생성비용이 높기 때문에 재사용성을 높이기 위해 pool을 사용하는 것이 좋다.<br>하지만 일반적으로 개인이 만든 pool은 코드를 헷갈리게 하고 성능을 떨어뜨린다.<br>(요즘 GC는 최적화가 잘되서, pool을 만드는 것보다 그냥 객체를 생성하는게 더 빠르다고 한다.)</p><h1 id="예외는-있다">예외는 있다.</h1><p>방어적 복사본을 만들어야 하는 경우가 있다.<br>불변 객체를 유지하기 위해 객체를 수정할 때 마다 새로운 객체를 만들어서 데이터를 수정하는 방식인데, 얼핏 보면 쓸 떼 없는 객체를 생성하는 것 처럼 보인다.<br>하지만 객체를 좀 더 만드는 피해보다, 객체가 재사용 되면서 불변성이 깨져 버그가 발생하는 피해가 더 크다는 사실을 명심해야 한다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 6. 불필요한 객체 생성을 피하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/07/effective-java-item6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</title>
      <link>https://jaehun2841.github.io/2019/01/07/effective-java-item5/</link>
      <guid>https://jaehun2841.github.io/2019/01/07/effective-java-item5/</guid>
      <pubDate>Mon, 07 Jan 2019 12:03:48 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 방식이나, 싱글턴 방식이 적합하지 않다.&lt;br&gt;
자원에 따라 동작이 달라진다면, 자원의 수만큼 인스턴스를 만들어 동작하게 하는 것이 좋다.&lt;br&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 방식이나, 싱글턴 방식이 적합하지 않다.<br>자원에 따라 동작이 달라진다면, 자원의 수만큼 인스턴스를 만들어 동작하게 하는 것이 좋다.<br>이를 <code>의존 객체 주입</code>이라고 하는데 Spring과 같은 프레임워크에서 DI의 개념으로 많이 쓰이고 있다.</p><p>의존 객체 주입은 생성자, 정적팩터리, 빌더 혹은 Setter를 이용해서 자원을 넘겨 줄 수 있다.</p><h1 id="팩터리-메서드-패턴-사용하여-자원-넘겨주기">팩터리 메서드 패턴 사용하여 자원 넘겨주기</h1><p>자바8에서는 Supplier&lt;T&gt; 인터페이스가 팩터리를 표현한 완벽한 예다.<br>Supplier&lt;T&gt;를 입력으로 받는 메서드는 일반적으로 한정적 와일드 카드 타입을 사용해 팩터리의 타입 매개변수를 제한한다.</p><p>아래의 예제처럼 사용한다.타일들을 이용해 모자이크를 만드는 예제이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mosaic <span class="title">create</span><span class="params">(Supplier&lt;? extends Tile&gt; tileFactory)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><h1 id="요약">요약</h1><ul><li>클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸 클래스는 사용하지 말자!</li><li>필요한 자원 또는 팩터리를 생성자나 빌더를 통해 의존 객체를 주입하도록 하자</li><li>의존 객체 주입은 유연성, 재사용성, 테스트 용이성을 높여 줄 것이다.</li></ul><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/07/effective-java-item5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 4. 인스턴스화를 막으려거든 Private 생성자를 사용하라</title>
      <link>https://jaehun2841.github.io/2019/01/07/effective-java-item4/</link>
      <guid>https://jaehun2841.github.io/2019/01/07/effective-java-item4/</guid>
      <pubDate>Mon, 07 Jan 2019 11:44:23 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;단순히 static 메서드와 static 필드만을 담은 클래스를 만들고 싶을 때가 있다.&lt;br&gt;
보통 Utils 클래스를 정의할 떄 이런식으로 많이 사용하는데, 이러한 클래스는 인스턴스를 만들어서 사용하고자 만
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>단순히 static 메서드와 static 필드만을 담은 클래스를 만들고 싶을 때가 있다.<br>보통 Utils 클래스를 정의할 떄 이런식으로 많이 사용하는데, 이러한 클래스는 인스턴스를 만들어서 사용하고자 만든 목적이 아니기 때문에 인스턴스화를 막아야 한다.<br>생성자를 하나도 명시 하지 않으면 Java에서는 매개변수가 없는 default 생성자를 만들어 준다.</p><h1 id="추상-클래스로-만들면">추상 클래스로 만들면?</h1><p>추상 클래스로 만드는 것으로는 인스턴스 화를 막을 수 없다.<br>단순히 상속을 통해 인스턴스를 만들 수 있기 때문이다. 오히려 abstract 클래스는 하위클래스를 만들어서 사용하라는 뉘앙스가 더 강하다.</p><h1 id="private-생성자를-만들자">private 생성자를 만들자</h1><p>private 생성자를 만드는 것 만으로도 인스턴스화를 막을 수 있다.외부에서 new 키워드를 통해 인스턴스를 만들 수 없기 때문이다.</p><p>이중 보안을 하자면..<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Utils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이런 식으로 Error를 발생 시켜주자.</p><p>평소 코딩할 때는 Lombok을 이용해서 깔끔하게 등록해 주는 것도 방법이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utils</span>() </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 4. 인스턴스화를 막으려거든 private 생성자를 사용하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/07/effective-java-item4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 3. Private 생성자나 열거 타입으로 싱글턴임을 보증하라</title>
      <link>https://jaehun2841.github.io/2019/01/07/effective-java-item3/</link>
      <guid>https://jaehun2841.github.io/2019/01/07/effective-java-item3/</guid>
      <pubDate>Mon, 07 Jan 2019 10:34:19 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;싱글턴이란&quot;&gt;싱글턴이란?&lt;/h1&gt;
&lt;p&gt;싱글턴 객체란 Application내에서 단 1개의 인스턴스만 생성할 수 있는 클래스를 의미한다.&lt;br&gt;
시스템에서 유일성을 보장하기 위해 1개만 만들어야 하는 경우도 있고, 시스템 구조 상 1개 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="싱글턴이란">싱글턴이란?</h1><p>싱글턴 객체란 Application내에서 단 1개의 인스턴스만 생성할 수 있는 클래스를 의미한다.<br>시스템에서 유일성을 보장하기 위해 1개만 만들어야 하는 경우도 있고, 시스템 구조 상 1개 이상이 되면 개념적으로 맞지 않는 상황도 있기 때문이다.</p><h1 id="싱글턴을-만드는-방법">싱글턴을 만드는 방법</h1><h2 id="private-생성자-static-객체">private 생성자 + static 객체</h2><p>private 생성자를 통해 내부에서만 객체를 생성 할 수 있도록 하고,public static final 키워드를 이용해 static 변수로 1개의 인스턴스만 제공하는 방식이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>사용자가 Elvis 객체를 클라이언트에서 사용하기 위해서는<br>외부로 노출 된 생성자가 없기 때문에 Elvis.INSTANCE의 형태로 사용해야만 한다.<br>최초로 INSTANCE 변수가 초기화 될 때 private 생성자를 통해 단 한번 인스턴스가 생성되게 된다.</p><blockquote><p>하지만, Java의 Reflection기능을 이용하여, AccessibleObject.setAccessible(true)를 이용하면 private 생성자를 호출 할 수 있다.<br>(이런 부분은 논외로 한다.)  여차하면 두번째 호출 부터 Exception을 발생 시켜 싱글턴을 보장할 수 있도록 방어로직을 심을 수 있다.</p></blockquote><h2 id="정적-팩터리-메서드">정적 팩터리 메서드</h2><p>위의 private 생성자 + static 객체에서 조금 진화된 형태가 클래스에서 정적 팩터리 메서드를 제공하는 case이다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p>지금은 싱글턴 객체를 리턴하는 정적 메서드이지만, 향후 필요에 따라 변경될 수 있는 확장성을 가지고 있다.특정 파라미터나, 특정 스레드에는 다른 인스턴스를 리턴한다던지에 대해 확장과 변경에 열려 있는 장점이 있다.</p></li><li><p>원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.</p></li><li><p>정적 팩터리 메서드의 참조를 공급자(Supplier)로 만들 수 있다.</p></li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Supplier&lt;Elvis&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="열거-타입enum을-이용한-싱글턴-객체-생성">열거 타입(Enum)을 이용한 싱글턴 객체 생성</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1번째 예시와 비슷하지만 가장 안전하고 좋은 방법이다.복잡한 직렬화 상황이나, 리플렉션 공격에도 안전하다.<br>단, 만들려는 싱글턴이 Enum이외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다.<br>(열거 타입이 다른 인터페이스를 구현하도록 하는 건 가능.)</p><h1 id="싱글턴-객체의-직렬화">싱글턴 객체의 직렬화</h1><p>싱글턴 클래스를 직렬화 하기 위해서는 Serializable을 구현한다고 선언하는 것 만으로는 부족하다.<br>모든 인스턴스 필드에 transient 예약어를 붙여 직렬화를 막은 다음 readResolve 메서드를 제공해야 한다.<br>이렇게 하지 않으면 역직렬화 시점에 새로운 인스턴스가 생성 된다.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//역직렬화가 되어 새로운 인스턴스가 생성되더라도, </span></span><br><span class="line">  <span class="comment">//클래스간 공유 변수인 static 변수를 이용하면 싱글턴을 보장 할 수 있다.</span></span><br><span class="line">  <span class="comment">// 새로운 인스턴스는 GC에 의해 UnReachable 형태로 판별되어 제거된다.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/07/effective-java-item3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라</title>
      <link>https://jaehun2841.github.io/2019/01/06/effective-java-item2/</link>
      <guid>https://jaehun2841.github.io/2019/01/06/effective-java-item2/</guid>
      <pubDate>Sun, 06 Jan 2019 10:40:34 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;정적 팩터리 메서드 팩터리와 생성자에는 똑같은 제약이 하나 있다.&lt;br&gt;
선택적 매개변수가 많을 경우에 적절하게 대응하기 어렵다는 점이다.&lt;br&gt;
매개변수가 3~4개까지는 어떻게 해보겠지만 엄청 많은 경우에는 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>정적 팩터리 메서드 팩터리와 생성자에는 똑같은 제약이 하나 있다.<br>선택적 매개변수가 많을 경우에 적절하게 대응하기 어렵다는 점이다.<br>매개변수가 3~4개까지는 어떻게 해보겠지만 엄청 많은 경우에는 생성자를 이용해 객체를 생성하는 과정부터가 곤욕이다.</p><p>아래의 예시를 보자<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat, <span class="keyword">int</span> sodium, <span class="keyword">int</span> carbonhydrate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">    <span class="keyword">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">    <span class="keyword">this</span>.calories = calories;          <span class="comment">//선택</span></span><br><span class="line">    <span class="keyword">this</span>.fat = fat;                    <span class="comment">//선택</span></span><br><span class="line">    <span class="keyword">this</span>.sodium = sodium;              <span class="comment">//선택</span></span><br><span class="line">    <span class="keyword">this</span>.carbohydrate = carbohydrate;  <span class="comment">//선택</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>매개변수가 int만 6개로 이루어져 있다.<br>그리고 default value가 정해져 있지 않기 때문에, servingSize 같은 변수는 정의하기 싫으면 0으로 해야할 지, 아니면 최소값이 있을지 알기가 어렵다.<br>그리고 매개변수 선언 순서가 바뀌면 의도하지 않은 객체가 생성되기 때문에 코딩 할 때 매우 주의를 요해야 한다.</p><h1 id="점층적-생성자-패턴">점층적 생성자 패턴</h1><p>위와 같은 문제를 조금이나마 해결해 보려는 노력이 점층적 생성자 패턴이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">    <span class="keyword">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(servingSize, servings);</span><br><span class="line">     <span class="keyword">this</span>.calories = calories;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(servingSize, servings, calories);</span><br><span class="line">     <span class="keyword">this</span>.fat = fat;     </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat, <span class="keyword">int</span> sodium, <span class="keyword">int</span> carbonhydrate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">    <span class="keyword">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">    <span class="keyword">this</span>.calories = calories;          <span class="comment">//선택</span></span><br><span class="line">    <span class="keyword">this</span>.fat = fat;                    <span class="comment">//선택</span></span><br><span class="line">    <span class="keyword">this</span>.sodium = sodium;              <span class="comment">//선택</span></span><br><span class="line">    <span class="keyword">this</span>.carbohydrate = carbohydrate;  <span class="comment">//선택</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이것도 선택사항에 대해 하나의 방법으로 작용할 수 있지만, 코드가 길어지고 가독성이 떨어지게 된다.<br>실제로 매개변수의 위치에 따라 의도하지 않은 객체가 생성될 수 있기 때문에 주의를 요해야 하는 코드이다.</p><h1 id="java-beans-패턴">Java Beans 패턴</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize = -<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServingSize</span><span class="params">(<span class="keyword">int</span> servingSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServings</span><span class="params">(<span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.servings = servings;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCalories</span><span class="params">(<span class="keyword">int</span> calories)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.calories = calories;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFat</span><span class="params">(<span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fat = fat;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSodium</span><span class="params">(<span class="keyword">int</span> sodium)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sodium = sodium;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCarboHydrate</span><span class="params">(<span class="keyword">int</span> carbohydrate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NutritionFacts nutritionFacts = <span class="keyword">new</span> NutritionFacts();</span><br><span class="line"></span><br><span class="line">nutritionFacts.setServingSize(<span class="number">240</span>);</span><br><span class="line">nutritionFacts.setServings(<span class="number">8</span>);</span><br><span class="line">nutritionFacts.setCalories(<span class="number">100</span>);</span><br><span class="line">nutritionFacts.setFat(<span class="number">20</span>);</span><br><span class="line">nutritionFacts.setSodium(<span class="number">35</span>);</span><br><span class="line">nutritionFacts.setCarboHydrate(<span class="number">27</span>);</span><br></pre></td></tr></table></figure></p><p>자바 빈즈 패턴에서는 객체 하나를 만드느느데 메서드를 여러개 호출 해야한다.  객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.<br>또한 객체의 불변셩이 깨지게 되어 코드에서 버그를 생성할 수 있다.</p><h1 id="builder-패턴">Builder 패턴</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">      <span class="keyword">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> calories)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.calories = calories;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fat = fat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> sodium)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sodium = sodium;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> carbohydrate)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat, <span class="keyword">int</span> sodium, <span class="keyword">int</span> carbonhydrate)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">      <span class="keyword">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">      <span class="keyword">this</span>.calories = calories;          <span class="comment">//선택</span></span><br><span class="line">      <span class="keyword">this</span>.fat = fat;                    <span class="comment">//선택</span></span><br><span class="line">      <span class="keyword">this</span>.sodium = sodium;              <span class="comment">//선택</span></span><br><span class="line">      <span class="keyword">this</span>.carbohydrate = carbohydrate;  <span class="comment">//선택</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts nutritionFacts = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">240</span>, <span class="number">8</span>)</span><br><span class="line">                                                  .calories(<span class="number">100</span>).sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build()</span><br></pre></td></tr></table></figure></p><p>빌더 패턴은 (파이썬과 스칼라에 있는) 명명된 선택적 매개변수를 흉내낸 것이다.<br>이런 식으로 하면 Java Beans 패턴의 set 역할을 해주면서 build()를 호출 하는 시점에 변수를 freezing 시켜 불변식을 유지 할 수 있다.하지만 시간이 지날 수록 매개 변수가 늘어날 가능성이 있음을 항상 주의 해야 한다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/06/effective-java-item2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라</title>
      <link>https://jaehun2841.github.io/2019/01/06/effective-java-item1/</link>
      <guid>https://jaehun2841.github.io/2019/01/06/effective-java-item1/</guid>
      <pubDate>Sun, 06 Jan 2019 08:42:25 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;서론&quot;&gt;서론&lt;/h1&gt;
&lt;p&gt;개발자가 클래스의 인스턴스를 생성하는 방법은 new 키워드를 통한 생성자 호출이다.&lt;br&gt;
이외에도 생성자와 별도로 정적 팩터리 메서드를 이용해서 메서드 내부에서 생성자나, 이미 생성된 인스턴스를 반환하여 클라
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="서론">서론</h1><p>개발자가 클래스의 인스턴스를 생성하는 방법은 new 키워드를 통한 생성자 호출이다.<br>이외에도 생성자와 별도로 정적 팩터리 메서드를 이용해서 메서드 내부에서 생성자나, 이미 생성된 인스턴스를 반환하여 클라이언트 코드에서 인스턴스를 사용 할 수 있다.</p><h1 id="정적static-팩터리-메서드가-좋은-점">정적(Static) 팩터리 메서드가 좋은 점</h1><h2 id="이름을-가질-수-있다">이름을 가질 수 있다.</h2><p>생성자의 파라미터 시그니처만으로는 어떤 객체를 반환 할 지에 대한 특성을 이해하기 어렵다.<br>하지만, 정적 팩터리 메서드의 경우는 메서드 이름으로 충분히 유추 할 수 있기 때문에 가독성이 좋아진다.</p><h2 id="호출-될-때-마다-인스턴스를-생성하지-않아도-된다">호출 될 때 마다 인스턴스를 생성하지 않아도 된다.</h2><p>new를 통해 인스턴스를 생성하게 되면, 불필요한 중복 객체를 생성할 가능성이 많이진다.<br>하나의 객체를 이용해 캐싱하고 쓰는 경우 정적 팩터리 메서드를 사용하는 게 장점이 될 수 있다.</p><p>대표적으로 Boolean에 대한 예시가 있다.<br>매번 new Boolean(false)처럼 사용을 하면 사용할 때 마다 중복되는 Boolean 객체를 생성하게 된다.</p><p>하지만 대충 이런식으로 정적 팩터리 메서드를 제공하는 경우<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Boolean&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FLASE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean.TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? TRUE : FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>쓸 데 없는 boolean 객체를 만들지 않아도 되기 때문에 메모리 관리 측면에서 유리하다.<br>또한 객체를 싱글턴(singleton)으로 제공할 수 있고, 인스턴스화 불가로 만들 수 도 있다.</p><blockquote><p>반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제 할 수 있다.<br>이런 클래스를 <strong>인스턴스 통제(instance-controlled) 클래스</strong>라 한다.</p></blockquote><h2 id="반환타입의-하위타입-객체child를-반환-할-수-있다">반환타입의 하위타입 객체(Child)를 반환 할 수 있다.</h2><p>인터페이스를 사용해 하위타입 객체를 반환 할 수 있다. 인터페이스 기반 프레임워크의 핵심 기술이라고 볼 수 있다.<br>SpringFramework를 사용하는 경우에도 유용하게 사용 할 수 있다.<br>아래와 같은 예시 코드를 보자</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PaymentService kakaoPaymentService;</span><br><span class="line"><span class="keyword">private</span> PaymentService naverPaymentService;</span><br><span class="line"><span class="keyword">private</span> PaymentService paycoPaymentService;</span><br><span class="line"><span class="keyword">private</span> PaymentService rocketPaymentService;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaymentService <span class="title">getType</span><span class="params">(PaymentType payentType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> KAKAO: <span class="keyword">return</span> kakaoPaymentService;</span><br><span class="line">  <span class="keyword">case</span> NAVER: <span class="keyword">return</span> naverPaymentService;</span><br><span class="line">  <span class="keyword">case</span> PAYCO: <span class="keyword">return</span> paycoPaymentService;</span><br><span class="line">  <span class="keyword">case</span> ROCKET: <span class="keyword">return</span> rocketPaymentService;</span><br><span class="line">  <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>외부 결제 모듈을 사용한다고 가정 했을 때 이런식으로 Interface를 통한 하위타입 객체를 제공할 수 있다.</p><h2 id="입력-매개변수에-따라-매번-다른-클래스의-객체를-반환-할-수-있다">입력 매개변수에 따라 매번 다른 클래스의 객체를 반환 할 수 있다.</h2><p>EnumSet 클래스는 public 생성자 없이 오직 정적 팩터리 메서드만 제공한다.<br>OpenJDK에서는 원소가 64개 이하이면 원소들을 long변수 하나로 관리하는 RegularEnumSet의 인스턴스를 리턴하고,<br>65개 이상이면 long배열로 관리하는 JumboEnumSet의 인스턴스를 반환한다.</p><p>클라이언트는 EnumSet 객체이면 되기 때문에 무슨객체가 리턴되든 알 필요가 없다.</p><h2 id="정적-팩터리-메서드를-작성하는-시점에는-반환할-객체의-클래스가-존재하지-않아도-된다">정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.</h2><p>이러한 유연함은 Service Provider 프레임워크의 근간이 된다.대표적인 예로 JDBC가 있다.</p><ol><li>DriverManager.registerDriver() 메서드로 각 DBMS별 Driver를 설정한다. (제공자 등록 API)</li><li>DriverManager.getConnection() 메서드로 DB 커넥션 객체를 받는다. (service access API)</li><li>Connection Interface는 DBMS 별로 동작을 구현하여 사용할 수 있다. (service Interface)</li></ol><p>위와 같이 동작하게 된다면 차후에 다른 DBMS가 나오더라도 같은 Interface를 사용하여 기존과 동일하게 사용이 가능하다.</p><h1 id="정적static-팩터리-메서드의-단점">정적(Static) 팩터리 메서드의 단점</h1><h2 id="상속을-하려면-publicprotected-생성자가-필요하다">상속을 하려면 public/protected 생성자가 필요하다.</h2><p>상속을 하기 위해서는 public/protected 생성자가 필요하니, 정적 팩터리 메서드만 제공하면 하위클래스를 만들 수가 없다.</p><blockquote><p>컬렉션 프레임 워크의 유틸리티 구현 클래스는 private 생성자만 제공하므로 상속이 불가하다.<br>이러한 제약은 상속보다 컴포지션을 사용하도록 유도되어 오히려 더 장점으로 작용한다.</p></blockquote><h2 id="정적-팩터리-메서드는-개발자가-찾기-어렵다">정적 팩터리 메서드는 개발자가 찾기 어렵다.</h2><p>생성자 처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화 할 방법을 찾아야 한다.</p><h1 id="정적static-팩터리-메서드-명명-규칙">정적(static) 팩터리 메서드 명명 규칙</h1><ul><li>from - 매개변수를 하나만 받아서 해당 타입의 인스턴스를 반환하는 메서드<ul><li>예시) Date date = Date.from(dateStr);</li></ul></li><li>of - 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드<ul><li>예시) Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</li></ul></li><li>valueOf - from과 of의 더 자세한 버전<ul><li>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</li></ul></li><li>instance(getInstance) - 매개변수를 받는다면, 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지 않는다.<ul><li>StackWalker luke = StackWalker.getInstance(options);</li></ul></li><li>create(newInstance) - instance/getInstance와 같지만, 매번 새로운 인스턴스를 반환함을 보장한다.</li><li>get(Type) - getInstance와 맥락은 같으나 특정 Type을 반환할 때 사용<ul><li>Steak steak = Food.getSteak(Meet.BEEF);</li></ul></li><li>new(Type) - newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스의 팩터리 메서드를 정의 할 때 사용<ul><li>Steak steak = Food.newSteak(Meet.BEEF);</li></ul></li><li>(Type) - getType, newType의 같결한 버전<ul><li>Steak steak = Food.steak(Meet.BEEF);</li></ul></li></ul><h1 id="요약">요약</h1><p>정적 팩터리 메서드는 각각의 쓰임새가 있으니, 장단점을 잘 인식하고 쓰는게 좋다.<br>대부분의 경우가 정적 팩터리 메서드로 인스턴스를 생성하는게 유리하니 무작정 public 생성자만 사용하는 습관은 고치는게 좋다.</p><h1 id="참고">참고</h1><ul><li>Effective Java 3rd Edition - Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2019/01/06/effective-java-item1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Mybatis 조회 시, All Element Are Null 이슈</title>
      <link>https://jaehun2841.github.io/2018/12/30/2018-12-30-mybatis-returnInstanceForEmptyRow/</link>
      <guid>https://jaehun2841.github.io/2018/12/30/2018-12-30-mybatis-returnInstanceForEmptyRow/</guid>
      <pubDate>Sun, 30 Dec 2018 05:55:24 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;들어가며&quot;&gt;들어가며&lt;/h1&gt;
&lt;p&gt;사내 시스템 운영 중, SMS를 전송해 주는 부분에서 장애가 발생 하였다.&lt;br&gt;
어디에선가 NullPointer Exception이 발생하고 있었다. stacktrace기준으로 추적해 보니,
Mybat
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="들어가며">들어가며</h1><p>사내 시스템 운영 중, SMS를 전송해 주는 부분에서 장애가 발생 하였다.<br>어디에선가 NullPointer Exception이 발생하고 있었다. stacktrace기준으로 추적해 보니,Mybatis를 통해 데이터를 조회 한다음 데이터를 가공하는 과정에서 NullPointerException이 발생하고 있었다.<br>일단 디버깅 이전에 코드를 봤다. 아무리 생각해도 null이 발생하지 않을 것 같았다.</p><p>실제 코드를 돌려보았다.<img src="./all_element_are_null.png" alt="all_elememt_are_null 에러"></p><p>이 메세지는 무엇?<br>구글에 검색해 보니 List내의 모든 Element의 reference가 null인 것이었다.<br>그래서 size는 있지만, 가르키는 instance가 없기 때문에 Nullpointer Exception이 발생하고 있었다.</p><p>일단은 조회된 모든 컬럼이 null이면 mybatis에는 null을 리턴해 주는건가? 라는 심증만 가지고절대 null이 될 수 없는 id 컬럼을 조회컬럼에 추가해 주었다.<br>(쿼리내에 outer join의 여파로 null만 나오는 쿼리였다.)<br>일단은 id 컬럼을 추가 해주니, 정상적으로 id만 값이 있고 다른 property는 모두 null인 객체가 생성되었다.<br>일단 이렇게 이슈를 종료하고자 했지만, 너무 찝찝했다</p><p>아니 왜? 모든 컬럼이 null이면 왜 객체 생성을 안하지? 우리가 원하는건 null이 아닐텐데...<br>하물며 이런상황에 앞서 조회된 내용에 대해 null 체크를 할 생각을 하니 끔찍했다.</p><p>분명 설정이 있으리라 생각하고 mybatis 사이트를 뒤져보았다.뒤져보니 요런게 있었다.</p><h2 id="returninstanceforemptyrow">returnInstanceForEmptyRow</h2><blockquote><p>MyBatis, by default, returns null when all the columns of a returned row are NULL. When this setting is enabled, MyBatis returns an empty instance instead. Note that it is also applied to nested results (i.e. collectioin and association). Since: 3.4.2</p></blockquote><p>한 마디로 mybatis option중에는 <code>returnInstanceForEmptyRow</code> 이란 옵션이 있는데, 모든 컬럼이 null이면 row를 null로 리턴해 준단다. (이런 ㅡㅡ)<br>근데 설정 옵션이 true이면 null 대신에 모든 값이 null인 인스턴스를 반환해주고 false이면 null을 반환해 준다고 한다.<br>하지만 default옵션이 false이기 때문에 아무 설정도 안한 회사소스에서는 당연히 null이 리턴되게 된다.<br><code>이 옵션은 mybatis 3.4.2부터 지원한다</code> (회사에서는 mybatis/3.4.2이상 버전을 사용하고 있다.)</p><h1 id="test-코드">Test 코드</h1><p>테스트 환경은 아래와 같이 설정해 보았다</p><ul><li>Spring Boot</li><li>Mybatis</li><li>H2DB</li></ul><h2 id="환경-설정">환경 설정</h2><p>pom.xml<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyBatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>application.properties<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#Datasource</span><br><span class="line">spring.datasource.url=jdbc:h2:mem:test</span><br><span class="line">spring.datasource.initialization-mode=always</span><br><span class="line">spring.datasource.username=sa</span><br><span class="line">spring.datasource.password=</span><br><span class="line">spring.datasource.driver-class-name=org.h2.Driver</span><br><span class="line"></span><br><span class="line">#h2 setting</span><br><span class="line">spring.h2.console.enabled=true</span><br><span class="line">spring.h2.console.path=/h2-console</span><br><span class="line"></span><br><span class="line"># Mybatis Setting</span><br><span class="line">mybatis.mapper-locations=classpath*:mapper/**/*SqlMap.xml</span><br><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br><span class="line">mybatis.configuration.return-instance-for-empty-row=false</span><br></pre></td></tr></table></figure></p><p>schema.sql<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INTEGER</span> AUTO_INCREMENT primary <span class="keyword">key</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    description <span class="built_in">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>data.sql<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span>(<span class="keyword">id</span>, <span class="keyword">name</span>, description) <span class="keyword">values</span> (<span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p><p>TestRepository.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;TestDTO&gt; <span class="title">getTestAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TestSqlMap.xml<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.springstudy.demo6.TestRepository"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTestAll"</span> <span class="attr">resultType</span>=<span class="string">"com.example.springstudy.demo6.TestDTO"</span>&gt;</span></span><br><span class="line">        select name, description from test</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>MybatisConfig.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.example.springstudy.demo6"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="test-case">Test Case</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactoryBean sqlSessionFactoryBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestConfiguration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">                    .setType(EmbeddedDatabaseType.H2)</span><br><span class="line">                    .addDefaultScripts()</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">            sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">            sqlSessionFactoryBean.getObject()</span><br><span class="line">                     .getConfiguration()</span><br><span class="line">                                 .setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">                                 </span><br><span class="line">            sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> ClassPathResource[]&#123;<span class="keyword">new</span> ClassPathResource(<span class="string">"mapper/TestSqlMap.xml"</span>)&#125;);</span><br><span class="line">            <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * returnInstanceForEmptyRow 설정이 false일때,</span></span><br><span class="line"><span class="comment">     * 모든 컬럼의 데이터가 null인 경우, List내의 항목이 null이 되는 경우 테스트</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">all_element_null_test_returnInstanceForEmptyRow_false</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        sqlSessionFactoryBean.getObject()</span><br><span class="line">                             .getConfiguration()</span><br><span class="line">                             .setReturnInstanceForEmptyRow(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;TestDTO&gt; tests = sqlSessionFactoryBean.getObject()</span><br><span class="line">                .openSession()</span><br><span class="line">                .getMapper(TestRepository.class)</span><br><span class="line">                .getTestAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//모든 항목이 null인 경우, List내의 Element가 null이 되므로 제거 된다</span></span><br><span class="line">        tests.removeIf(Objects::isNull);</span><br><span class="line">        assertThat(tests).isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * returnInstanceForEmptyRow 설정이 true일때,</span></span><br><span class="line"><span class="comment">     * 모든 컬럼의 데이터가 null인 경우, 모든 property가 null인 인스턴스가 생성되는지에 대한 테스트</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">all_element_null_test_returnInstanceForEmptyRow_true</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        sqlSessionFactoryBean.getObject()</span><br><span class="line">                             .getConfiguration()</span><br><span class="line">                             .setReturnInstanceForEmptyRow(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;TestDTO&gt; tests = sqlSessionFactoryBean.getObject()</span><br><span class="line">                .openSession()</span><br><span class="line">                .getMapper(TestRepository.class)</span><br><span class="line">                .getTestAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//모든 항목이 null인 경우, List내의 Element가 Empty 인스턴스를 가르키므로</span></span><br><span class="line">        <span class="comment">//제거되지 않는다.</span></span><br><span class="line">        tests.removeIf(Objects::isNull);</span><br><span class="line">        assertThat(tests).isNotEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>테스트 코드 실행 결과 returnInstanceForEmptyRow = true로 설정 할 경우, empty 객체가 나와 내가 생각한 대로 사용할 수 있게 되었다.</p><h1 id="returninstanceforemptyrow-옵션-설정-방법">returnInstanceForEmptyRow 옵션 설정 방법</h1><h2 id="mybatisconfigxml">mybatisConfig.xml</h2><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"returnInstanceForEmptyRow"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configurtion</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="applicationproperties">application.properties</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.configuration.return-instance-for-empty-row=true</span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>http://www.mybatis.org/mybatis-3/configuration.html</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/30/2018-12-30-mybatis-returnInstanceForEmptyRow/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2018년 회고</title>
      <link>https://jaehun2841.github.io/2018/12/16/2018-12-16-remind/</link>
      <guid>https://jaehun2841.github.io/2018/12/16/2018-12-16-remind/</guid>
      <pubDate>Sun, 16 Dec 2018 06:59:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;새-직장으로-이직&quot;&gt;새 직장으로 이직&lt;/h1&gt;
&lt;p&gt;2017년 8월 중순 중소 SI업체를 용기있게(?) 뛰쳐나왔다.
그 곳에서는 오직 나 한명으로 여러 프로젝트를 돌리고 있었고, 같이 일할 선임개발자도 없었기 때문에
굉장히 나름대로 스트
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="새-직장으로-이직">새 직장으로 이직</h1><p>2017년 8월 중순 중소 SI업체를 용기있게(?) 뛰쳐나왔다.그 곳에서는 오직 나 한명으로 여러 프로젝트를 돌리고 있었고, 같이 일할 선임개발자도 없었기 때문에굉장히 나름대로 스트레스를 받고 있었다.그리고 모든 프로젝트가 나에게 의존적이었기 때문에 관리해야 할 사이트도 많았고..매일매일 프로젝트 했던 사이트들에 대한 유지보수 전화를 받아가며, 신규 프로젝트를 진행하고 있었다.이렇게 개발자로서 소모되어 가고 있다는 생각이 들어 과감하게 퇴사를 하게되었다. 다음에는 어느정도 조직이 구성되어있고 내가 조직원으로서 일할 수 있는 직장을 찾아야겠다! 라는 생각을 하게되었다.이직하고자 하는 회사의 조건은 이렇다.</p><ol><li>개발자 한명이 기획, 개발, 유지보수, 영업을 담당하는 작은회사는 가지 않겠다.</li><li>더 이상 SI는 하지 않겠다. (지방 출장이 잦고, 프로젝트 단위로 사업이 돌아가는 곳은 가지 않겠다.)</li><li>근무지 한 곳에서만 근무 할 수 있는 환경 (예전에는 지방을 여기저기 많이 다녔다.)</li><li>시니어 개발자와 주니어 개발자 층이 어느정도 있고, 같이 의논하며 개발할 수 있는 환경</li><li>Spring 4 / Java 1.8 이상을 사용하여 개발하는 조직</li><li>내가 더 발전할 수 있는 조직</li><li>연봉도 많이 올려주면 좋고~! ^^</li></ol><p>하지만 생각보다 이직은 쉽지 않았다. (특히나 선퇴사 후이직 이어서.. 11월쯤에는 굉장히 쫄렸다.)일단 서비스 회사로 이직을 목표로 잡았지만, 기존의 했던 업무가 제조업이나 MES관련 개발을 주로 했었기 때문에 서비스 회사에서는 대부분의 서류 낙방을 경험했다. (이력서를 처음 써봐서 정말 못써서 그럴 수도 있겠지만.)서류 한 군데만 붙어라... 면접은 완전 잘 볼 자신있다!라는 생각으로 서류만 2개월 이상 쓰다보니 10월쯤에는 서류 합격하는 회사가 몇 군데 있었다. 서류합격 메일을 받았을 때 기분이란....크 면접일자가 정해지고, 인터넷에 돌아다니는 예상 면접질문을 바탕으로 하나하나 정리를 하였다. 대게 기술질문은 그 테두리 안에서 나온다는 것이 여러사람들의 의견이었다.그리고 9월쯤엔 대기업 신입공채를 준비했어서, 오랜만에 컴퓨터 이론을 한번 정리 했었는데 이 부분이 정말 도움이 많이 되었다. 자주 안보는 만큼 지금도 기억에서 많이 사라졌는데, 가끔씩 리마인드를 해주는 것이 좋겠다.</p><p>면접은 두 군데정도 봤는데 둘 다 자신감있게 봤었다.아무래도 SI하면서 고객사 상대로 발표도 하고 회의도 자주 하다보니, 남들이랑 대화하고 그런거는 긴장되지 않았다.그렇기 때문에 면접을 보면서 긴장을 덜하고 면접장에서 어필할 수 있었던 것 같다.결국 최종적으로 한 곳의 회사만 합격을 하였는데, 그 곳이 NHN티켓링크이다.최종합격 후 천만다행이라는 생각이 들었고, 2018년 1월 초에 입사를 하게 되었다.</p><h1 id="우리-팀의-개발문화">우리 팀의 개발문화</h1><p>예전 SI할 때는 혼자서 사이트를 다 만들어야 했기 때문에, 프론트엔드도 하고 백엔드도하고, 서버설치 등을 혼자 다했다. 하지만 여기와서는 인프라 관련해서는 시스템팀이 별도로 있었고, DBA팀도 별도로 있었다. 내가 할 업무는 티켓링크 백엔드 개발과 약간의 간단한 프론트엔드 작업만 하면되었다.기획팀도 별도로 나뉘어져 있다보니, 내가 직접 기획서를 쓰지 않아도 되고 개발에만 집중 할 수 있다는 환경이 참 좋았다.</p><h2 id="git-flow를-사용한-브랜치-전략">git flow를 사용한 브랜치 전략</h2><p>SI할때는 SVN만 사용해봤는데 그냥 master에 커밋치던 나에게는 신세계였다. 뭔가 구글링하면서 지나쳤던 얘기들을 실천하고 있는 조직이라는 생각이 들었다.git도 처음 사용해 봤는데, SVN보다 더 유연하고 좋다는 생각이 들었다. (특히 브랜치를 왔다갔다 하면서 작업할 수 있는 점이 좋았던 것 같다.)</p><h2 id="pull-request-코드리뷰">Pull Request + 코드리뷰</h2><p>두 번째로는 Pull Request를 올려서 코드리뷰를 강제화 하도록 하는 문화이다.첫 업무를 받아서 PR을 올렸을 때는 Conversation이 50개 이상이 달려서 코드리뷰를 엄청나게 받았다.뭔가 탈탈 털렸다라는 느낌도 받았고, 앞으로 공부해야 할 게 많구나라는 생각이 들었다.한 가지 아쉬운점은... <code>코드리뷰를 하는 사람만 한다.</code> 다른사람들도 적극적으로 해주면 좋을텐데..라는 생각이 들었다.처음에는 나도 다른사람의 코드를 리뷰해줘야지! 라는 생각으로 코드리뷰에 참여하려고 했지만.. 한마디도 달 수 없었다. 그때 딱 드는 생각이, <strong>&quot;내가 아는게 없어서 코드리뷰를 해줄 수가 없구나.. 코드리뷰에 한마디라도 할 수 있도록 공부하자&quot;</strong> 라는 생각을 하게 되었다.돌이켜보면 나는 여태까지 <code>&quot;공부하지 않는 개발자&quot;</code>였다.팀원들을 보면 아침에 일찍와서 책을보는 분도 계셨고, 따로 스터디모임을 하시는 분도 계셨다.입사초기에 나는 살 좀 빼야지.. 라는 생각으로 아침운동을 다녀서 아침에 일찍 공부하기는 힘들었다. 그래서 주로 퇴근 후나 주말에 내가 하고자 하는 공부를 하였다. 그리고 꼭 공부한 내용은 블로그를 작성해서 남겨야겠다고 생각했다.공부는 조금조금씩 계속 했지만, 본격적으로 블로그를 설치하고 시작한 것은 7월 정도인 것 같다.현재 4년차에 Spring기반으로 개발을 계속 해왔다고는 하지만 Spring의 기본을 공부해본적이 없었다.여태까지는 그냥 <code>이렇게 하면 이렇게 되네~</code> 방식의 개발을 해와서, 뭐가 안되면 원인 파악하기가 무척이나 어려웠다.그래서 처음에는 <strong>Spring core</strong>에 대한 공부를 시작했다. 토비의 Spring 책도 사고, 회사 소스에 적용된 기술들을 하나하나 파보기 시작했다. 하나하나 익히고 나니 너무 유용한 기술들이 많이 있었고, 개발할 때 직접 써먹으면서 실전 응용력을 키울 수 있었던 것 같다.</p><h2 id="주간-기술공유">주간 기술공유</h2><p>세 번째는 매주 목요일 기술공유 시간을 짧게 갖는다.팀원 한 명씩 돌아가면서 신기술에 대한 공유나 코드리뷰등을 하는 시간이다. 이런 걸 해보지 않아서 처음에는 무슨 내용을 공유하지?라는 걱정이 앞섰는데, 다행히도 공유 순서가 가까워지면 항상 공유 할 내용이 있었다. 그리고 내 순서가 아니어도 최대한 공유를 하려고 노력했다. (순서가 아니어도 또 해도 된다. 하지만 내 순번에는 또 공유를 해야한다. ㅎㅎ) 최대한 공유를 많이 하려고 노력했고, 기술공유 준비를 하면서 내가 했던 일들이나 기술에 대해 다시 한번 정리하는 시간이 되어 개인적으로 기술에 대한 기억을 오랫동안 보존할 수 있는 방법이었다.또 다른사람의 기술공유를 들었다가 내가 필요할 때 써먹거나, 미처 몰랐던 내용들도 있어서 개발팀 문화 중에 나름 유의미한 시간이라고 생각하고 있다.</p><h1 id="블로그-시작">블로그 시작</h1><p>올해 목표 중 하나가 블로그에 공부한 내용에 대한 글을 꾸준히 작성하는 것이었다.블로그는 7월쯤에 만들어서 꾸준히 작성하려고 노력하고 있다.</p><p>현재까지 수를 보니..</p><ul><li>7월 - 5개</li><li>8월 - 6개</li><li>9월 - 3개</li><li>10월 - 2개</li><li>11월 - 7개</li><li>12월 - 8개</li></ul><p>정도 해서 총 31개의 포스팅을 작성했다. 시리즈 물로 된 글도 많았고, 회사에서 사용한 기술들을 다시 좀 다듬어서 기록으로 남긴 것들도 있다. (회사 업무내용을 최대한 제외하려 한게 참 힘들었다ㅜㅜ)처음에는 블로그도 안써봐서 글 쓰는데 시간도 오래걸리고 뭐 어떻게 써야하나...라는 생각으로 다른 블로그들을 참고하며 많이 썼던것 같다. 그리고 하나 쓰는데 시간도 꽤 오래 걸린것 같다.한 30개의 글을 써보니 대충 블로그 쓰는 법도 감이 왔다.</p><ul><li>일단 내가 100% 이해하지 못한 상황에서 글을 쓸 수 없다.</li><li>처음에는 블로그 포스팅 수를 늘리고 싶어서 무조건 post부터 생성하고 봤는데, 글의 진도가 나가지 않았다.</li><li>블로그를 빠르고 쉽게 작성하기 위해서는 목차를 먼저 잡고 그에 대한 지식을 채운 다음에 각 섹션별로 담아내고자 하는 내용을 짧게 정리했다.</li><li>예제가 필요한 경우 미리 예제에 대한 실습을 마쳐 놓아야 한다.<ul><li>그때그때 예제코드 작성하면 시간이 오래걸리고, 내가 무슨 글을 쓰던 중이었는지 까먹게 된다.</li></ul></li></ul><p>블로그를 쓰다보니 지식에 대한 인덱스도 나름 생기고, 나중에 기억 안나도 예제코드를 찾아볼 수 있어서 좋았다.앞으로도 계속 블로그를 작성할 예정인데, 제발 귀찮아지지만 않았으면 좋겠다..!</p><h1 id="회사-업무">회사 업무</h1><h2 id="1~2월에는-회사-적응도-하고-바로-또-업무를-할당-받았다">1~2월에는 회사 적응도 하고, 바로 또 업무를 할당 받았다.</h2><p>나의 첫 업무는 티켓링크 카카오톡 알림톡 연동이었다. 기존에는 SMS/MMS만 사용했는데, 카카오톡 알림톡을 지원하도록 하는 업무였다. 지금 생각해보면 업무는 단순했다. 카카오톡 API를 연동 인터페이스만 구현해주면 되는 것이었는데, 외부 API 연동을 처음 해보는터라 시간도 오래걸리고, 회사 소스를 파악하면서 해야해서 1달이상의 시간이 걸렸던 것 같다.기존 코드의 리팩토링도 해가면서 해서, 나름 재미있게 개발을 했던 첫 업무였다.</p><h2 id="3~4월에는-캡차-시스템-개발을-진행했다">3~4월에는 캡차 시스템 개발을 진행했다.</h2><p>티켓시스템에는 사람들이 좌석을 빨리 차지하기 위해 매크로를 많이 쓴다.최근에는 뉴스기사에도 아이돌 콘서트니, 인기 공연에 대해 매크로를 돌려서 빠르게 예매한 다음에 몇배의 가격으로 불려서 암표를 파는 사람이 많다는 기사가 나왔다. 최소한이라도 예방하기 위해 티켓링크에서는 캡차 도입을 고민하고 있었다. 구글의 리캡차나 국내의 캡차 솔루션을 도입하자라는 의견도 나왔고, 직접 구축하는 것이 좋다!라는 의견이 나오고 있을때쯤 집에서 한번 오픈소스를 이용해서 간단하게 캡차를 만들어보았다. 어렵지 않게 예시를 만들수 있었고, 다음날 바로 팀장님께 보여드렸다. 그렇게 캡차 개발은 내 업무가 되었다^^나름 보안과 성능을 생각하며, 이미지 캐싱등의 작업을 하였다. 그리고 캡차를 사용하기 위해서는 Global캐시 Store가 하나는 필요했다. 이로인해 팀에서 NoSQL 도입을 생각하게 되었다.캡차 개발 완료 후 nGrinder를 통해 성능테스트로 진행하였는데 15,000 TPS정도의 높은 성능이 나와서 나름 만족하고 있었다.(하지만 아직 회사에서 인기 공연이나 예매에 사용을 안해서.. 아쉬웠다.)</p><h2 id="redis-도입">Redis 도입</h2><p>캡차 사용을 위해 Redis를 도입하게 되었다. 원래 사용하는 NoSQL이 있지만, 추가적으로 NoSQL서버를 자체 구축할 예정이었다. (이유는 따로 적지 않겠다.) 여러가지 NoSQL이 물망에 올랐다. Redis, Arcus등 여러가지 Key-value store가 거론되었지만, 내 욕심 상 Redis를 해보고 싶었다. (아무래도 Key-value store 1순위인 Redis를 써보고 싶었다.)Redis를 도입하면서 단순하게 서버에 Redis만 설치해서 쓰고 싶지는 않았다. 인프라 시스템은 항상 scale out을 고려해야 했기 때문에, 주변에서 Docker를 이용해서 설치 해보라는 얘기가 나왔다.Docker는 난생 처음 들어보는 거였는데.. Docker에 대한 삽질을 어마무시하게 하면서 거의 3주만에 Redis 설치와 Cluster 설치까지 완료했다. 이 기회를 가지면서 Redis에 대한 전반적인 이해가 생기게 되었고, 나름 삽질을 거치면서 Docker라는 시스템도 어느정도 이해하게 되었다. (다시는 까먹지 않게 팀내에서도 3일에 걸쳐 공유를 하고 11부작 정도로 블로그도 작성해 두었다^^)</p><h2 id="결제시스템-개편">결제시스템 개편</h2><p>어쩌다보니 내가 티켓링크 결제 시스템 '부'가 되어서 티켓링크 결제시스템 개편 업무를 많이 했다.Payco결제, IC카드결제, 네이버페이 연동등을 경험하며, 외부 빌링업체의 결제 프로세스를 경험 할 수 있던 기회였다.네이버페이는 거의 처음부터 만들게 되었는데, Web에서의 결제, App에서의 결제를 모두 봐야 해서 꽤 고생했던 기억이 있다. 하지만 결제관련 Flow는 어느정도 알게 되었던 업무였다.</p><h2 id="msa시도-해보기">MSA시도 해보기</h2><p>티켓링크 시스템은 Monolothic 시스템 구조를 가지고 있다. 그렇기 때문에 빌드시간도 만만치않게 걸리고 배포하려고 해도 사이드 이펙트가 발생할 확률이 높다. 그렇기 때문에 올해 말부터 하나씩 하나씩 쪼개는 작업을 진행하고 있다. MSA까지는 아니어도 점진적으로 모듈을 분리하여, 빌드 시간을 단축 시키고, 시스템 안정성을 높이기 위함에 있다.이 부분에 대해서는 나도 의견을 많이 내고 시니어 개발자분들도 관심있게 보는 부분이어서, 내년에 더 활발하게 작업이 진행 될 것 같다.</p><h1 id="내년에는">내년에는..</h1><p>내년 공부의 시작은 개발 필독 서적을 몇가지 읽어보려고 한다.</p><ul><li>clean code</li><li>TDD 개발 방법론</li><li>Effective Java 3rd Edition(2rd Edition은 한번봤는데, Java8에 대한 내용이 추가되었다고 하니 한번더 봐야겠다.)</li><li>Java ORM 표준 JPA프로그래밍</li><li>현재 MyBatis기반으로 시스템이 구성되어있는데, 새로 만드는 시스템은 무조건 JPA를 도입하자고 얘기가 나오고 있다. 이전 회사에서 JPA사용경험이 있어서 나도 JPA도입을 대찬성하고 있는데, 더 지식을 쌓고 개발할 필요성을 느끼고 있다. 그래서 이 책을 아마 1순위로 공부하지 않을까.. 싶다.</li></ul><p>회사 업무에서는 주니어 개발자이지만, 목소리를 내보려 노력하고 있다.팀에서도 그런 분위기를 조성하려하고 있는 것 같고, 내 의견이 묵살되더라도 생각이라도 해보고, 다른사람의 의견과 비교할 수 있기 때문에 적극적으로 목소리를 내보고자 한다.</p><h1 id="마무리">마무리..</h1><p>올해 회고를 쭉 작성해보니 생각보다 많은 일을 했다는 생각이 든다. 그리고 그 과정 속에서 한단계 더 성장한 개발자가 되었다고 나름 생각하고 만족하고 있다. 회고를 쓰면서 회사 얘기가 조금 나와서.. 글을 좀 수정해야 할 경우가 생길 수도 있지만.. 딱히 그럴만한 내용은 없다고 생각이 든다.앞으로는 1년 단위로 회고를 작성하여 한번씩 되돌아보고 추억할 수 있는 시간이 되면 좋겠다.</p>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/16/2018-12-16-remind/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (11) Redis-Cli Docker로 사용하기</title>
      <link>https://jaehun2841.github.io/2018/12/07/2018-12-07-docker-11/</link>
      <guid>https://jaehun2841.github.io/2018/12/07/2018-12-07-docker-11/</guid>
      <pubDate>Fri, 07 Dec 2018 12:08:14 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;들어가며&quot;&gt;들어가며&lt;/h1&gt;
&lt;p&gt;Redis를 운영하다 보면 redis-cli를 주로 사용하게 되는데
항상 docker exec 명령을 통해 docker container 내의 redis-cli를 사용하여 불편한 점이 많았습니다.&lt;/p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="들어가며">들어가며</h1><p>Redis를 운영하다 보면 redis-cli를 주로 사용하게 되는데항상 docker exec 명령을 통해 docker container 내의 redis-cli를 사용하여 불편한 점이 많았습니다.</p><p>찾아보니 간단하게 Docker로 Redis-cli를 사용할 방법이 있어 기록을 남기게 되었습니다.</p><h1 id="docker로-redis-cli-접속하기">Docker로 Redis-cli 접속하기</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it \                                  </span><br><span class="line">                --rm \ </span><br><span class="line">                --net host \ </span><br><span class="line">                redis:5.0.0-alpine redis-cli \</span><br><span class="line">                -a <span class="string">"&lt;password&gt;"</span> \</span><br><span class="line">                -p &lt;port&gt;</span><br></pre></td></tr></table></figure></p><ul><li>it 옵션 : container와 conversation이 가능한 옵션</li><li>rm옵션 : container가 종료되면 container를 삭제</li><li>net옵션 : network 옵션</li><li>redis:5.0.0-alpine redis-cli : redis:5.0.0-alpine이미지의 redis-cli를 사용</li><li>a 옵션 : redis에서 requirepass를 사용하는 경우 password를 적어준다.</li><li>p 옵션 : 접속 port</li><li>h 옵션 : 접속하고자 하는 host (옵션 안주면 127.0.0.1로 접속한다)</li></ul><h1 id="docker-redis-cli로-cluster-설정하기">Docker Redis-cli로 cluster 설정하기</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it \                                  </span><br><span class="line">                --rm \ </span><br><span class="line">                --net host \ </span><br><span class="line">                redis:5.0.0-alpine redis-cli \</span><br><span class="line">                -a <span class="string">"&lt;password&gt;"</span></span><br><span class="line">                --cluster create host:port host:port host:port  \  //master host&amp;port</span><br><span class="line">                 host:port host:port host:port \ //slave host&amp;port</span><br><span class="line">                --cluster-replicas 1</span><br></pre></td></tr></table></figure></p><ul><li>--cluster : cluster mode 명령어 수행</li><li>create : cluster 생성 명령</li><li>--cluster-replicas 1 : Redis Replication 명령, Master node 1개당 Slave node 1개를 의미</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/07/2018-12-07-docker-11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (10) Redis Cluster Mode 설정하기</title>
      <link>https://jaehun2841.github.io/2018/12/03/2018-12-03-docker-10/</link>
      <guid>https://jaehun2841.github.io/2018/12/03/2018-12-03-docker-10/</guid>
      <pubDate>Mon, 03 Dec 2018 06:54:18 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;들어가며&quot;&gt;들어가며&lt;/h1&gt;
&lt;p&gt;이전 장 까지 했던 Redis 구조는 &lt;code&gt;Redis Replication + Redis Sentinel&lt;/code&gt;을 이용한 failover 기능을 구성하고 있었습니다. Spring Applica
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="들어가며">들어가며</h1><p>이전 장 까지 했던 Redis 구조는 <code>Redis Replication + Redis Sentinel</code>을 이용한 failover 기능을 구성하고 있었습니다. Spring Application에서 Jedis를 이용하여 Application sharding을 구성하여 사용을 하였습니다. 이렇게 Redis를 잘 사용하나 싶었지만, 최근 Spring Cache Abstraction에 대해 공부했었고, Redis Replication + Sharding + Failover를 사용하면서 <strong>Spring-Data-Redis를 사용할 방법이 없을까?</strong> 라는 생각을 하게 되었습니다.</p><p>맨 처음에 회사에서 Spring + Redis연동을 할 때 당연히 Spring-Data-Redis를 염두하고 시작을 했었지만, 어느 블로그에서 <strong>Spring-Data-Redis는 Sharding을 지원하지 않는다!</strong> 라는 절망적인 얘기를 보고 여태까지 Docker를 이용해 설치한 방식에서 Jedis를 이용한 Sharding을 이용하고 있었습니다.</p><p>그 이후, Redis 관련 문서를 쭉 보던 중.. Redis 공식 홈페이지에서 <code>Redis Cluster Mode</code>에 대한 내용을 보게 되었습니다.그 내용을 요약하자면</p><ul><li>Redis3 버전 부터 Redis는 <code>Cluster Mode</code>를 지원한다.</li><li>Cluster Mode에서는 Redis Sentinel의 도움없이 <code>Cluster 자체적으로 Failover를 진행</code>한다.</li><li>Cluster Mode에서는 Master-Slave 노드 구조를 가질 수 있고, <code>노드 간 Replication을 지원</code>한다.</li><li>Cluster Mode에서는 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행<code>Auto Sharding을 지원</code>한다 (이야!!!!!!!!!!!!)</li><li>Application Sharding이 필요없기 때문에, <code>Spring-Data-Redis 사용이 가능하다.</code>(사실은 이 목적 때문에 Cluster Mode 설치를 해보게 되었습니다.)</li></ul><h1 id="기존에-설치한-redis-구조와-다른-점은">기존에 설치한 Redis 구조와 다른 점은?</h1><h2 id="이전-장까지-설치-했던-redis-구조">이전 장까지 설치 했던 Redis 구조</h2><p><img src="./Redis-Cluster-archi.PNG" alt="Redis-Cluster-archi"></p><ul><li>Master - Slave -Slave 구조</li><li>Redis Sentinel을 이용한 Master 감시 + Fail over 기능 지원</li><li>HAProxy를 이용한 Master / Slave 접근 Port 분리</li></ul><h2 id="새롭게-구성한-redis-cluster">새롭게 구성한 Redis Cluster</h2><p><img src="./new-redis-cluster.PNG" alt="new-redis-cluster"></p><ul><li><p>HAProxy는 5000번 포트만 사용하도록 축소 5001~5005는 불필요하기 때문</p><ul><li>앞으로는 무조건 Master에만 통신</li><li>어떤 Node와 통신하여 데이터를 set하거나 get 할 수 있음 (Cluster Mode 지원)</li><li>어떤 Node에 set하더라도 자동으로 Sharding</li></ul></li><li><p>감시자 역할의 Sentinel 제거</p><ul><li>Cluster Mode에서는 Redis Node끼리 감시하며 Fail over가 가능합니다.</li></ul></li><li><p>Slave 갯수도 한개로 축소</p></li></ul><h1 id="cluster-mode에서-지원하는-기능">Cluster Mode에서 지원하는 기능</h1><h2 id="fail-over">Fail Over</h2><p><img src="./new-redis-cluster2.PNG" alt="new-redis-cluster2"></p><ul><li>Redis Cluster Mode에서는 기존의 Sentinel을 별도로 설치하여 감시자 역할을 하는 것에서 벗어나 Cluster 자체적으로 Node들을 감시하고 Failover를 수행 할 수 있습니다.</li><li>Redis Cluster Mode를 사용하기 위해서는 각 Redis Node 별로 2개의 port가 열려 있어야 합니다.<ul><li>6379, 6380 default - Redis 서버 접속 포트</li><li>16379, 16380 default  <code>(접속 포트 + 10000)</code> - Redis Cluster Bus</li></ul></li><li>Cluster Bus를 이용해 Redis Cluster는 각 노드를 감시하고 서버 다운 시 또는 Connection 유실 시 Fail over를 수행합니다.</li><li>Cluster Bus는 노드 간 데이터 교환에 대해 다른 바이너리 프로토콜을 사용합니다.</li><li>이 프로토콜은 대역폭과 처리 시간을 적게 사용하여 노드 간에 정보를 교환하는 데 더 적합합니다.</li></ul><h2 id="auto-sharding">Auto Sharding</h2><ul><li>Redis Cluster Mode에서는 자동으로 Cluster Node에 대한 자동 샤딩을 제공합니다.</li><li>Redis Cluster에는 16384개의 slot이 있으며, slot에 대한 구간 별로 샤딩이 가능합니다.</li><li>slot을 계산하기 위해 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행합니다.<ul><li>[0-5500] 까지는 1번 Redis Node에 저장</li><li>[5501-11000] 까지는 2번 Redis Node에 저장</li><li>[11001-16384] 까지는 3번 Redis Node에 저장</li><li>Redis Node가 scale out 되는 경우 Master Node 수를 나눈 만큼 대역이 할당</li></ul></li></ul><h2 id="redis-cli를-이용한-cluster-명령">Redis-cli를 이용한 cluster 명령</h2><p>Redis 5버전에 포함된 redis-cli 버전 부터 cluster 옵션이 추가 되었습니다.Redis 4버전 이하에 대해서는 별도로 Ruby 기반의 프로그램을 설치해야 되서 번거로워서, Redis 5버전으로 설치를 해보았습니다. (성능도 더 좋을라나?ㅎ)</p><h3 id="redis-cluster-생성">Redis Cluster 생성</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.137.101:6379 192.168.137.102:6379 192.168.137.103:6379 \</span><br><span class="line">192.168.137.102:6380 192.168.137.103:6380 192.168.137.101:6380 \</span><br><span class="line">--cluster-replicas 1</span><br></pre></td></tr></table></figure></p><ul><li>Redis Cluster를 생성하기 위해서는 Master Node가 최소 3개 이상 필요합니다.</li><li>맨 처음 등록하는 3개의 노드가 Master Node</li><li><code>--cluster-replicas 1</code> 의 의미는 각 Slave Node가 1개임을 의미합니다.</li><li>6개의 노드가 등록 되었다면 처음 3개는 Master, 뒤의 3개는 Slave가 됩니다</li><li>Slave는 선언된 순서 대로 Master의 Slave로 등록 됩니다<ul><li>192.168.137.101:6379 -&gt; 192.168.137.102:6380</li><li>192.168.137.102:6379 -&gt; 192.168.137.103:6380</li><li>192.168.137.103:6379 -&gt; 192.168.137.101:6380</li></ul></li></ul><p><img src="./cluster-setting.PNG" alt="cluster-setting"></p><p><img src="./cluster-setting2.PNG" alt="cluster-setting2"></p><p>redis-cli에 접속하여 cluster nodes 명령어로 cluster를 구성하는 nodes에 대한 정보를 조회해 보았습니다.</p><p><img src="./cluster-nodes.png" alt="cluster-nodes"></p><h3 id="redis-node-add-remove">Redis Node ADD / REMOVE</h3><p>새로운 노드를 추가하는 과정은 기본적으로 2가지입니다.</p><ul><li>새로운 Master를 추가하는 경우</li><li>새로운 Slave를 추가하는 경우</li></ul><h3 id="master-추가">Master 추가</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.137.104:6379 192.168.137.101:6379</span><br></pre></td></tr></table></figure></p><ul><li>위 명령은 cluster에 새로운 노드를 추가하는 명령어입니다.</li><li>192.168.137.101:6379 구성 된 Cluster에 192.168.137.104:6379 추가한다는 명령어입니다.</li><li>cluster를 지정할 때는 master node를 아무거나 지정하면 됩니다. (192.168.137.101~103:6379)</li><li>여기까지 했을 때는 Cluster에 일원이 되어 Cluster로 묶여는지나, <code>실제로 데이터는 저장 되지 않습니다.</code></li><li>hash slot이 할당 되지 않았기 때문에 데이터는 저장되지 않습니다.</li><li><code>re-sharding</code>을 통해 slot의 대역을 할당 받아야 합니다.</li></ul><h3 id="slave-추가">Slave 추가</h3><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave</span><br></pre></td></tr></table></figure></p><ul><li>위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.</li><li>이 경우에는 새롭게 추가된 노드를 <code>복제본의 수가 적은 마스터</code> 나 임의의 마스터에 대한 Slave로 추가됩니다.</li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave\</span><br><span class="line">--cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e1</span><br></pre></td></tr></table></figure></p><ul><li>위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.</li><li>이 경우에는 master node를 지정하기 때문에 특정 master-id에 해당하는 master node의 slave로 추가됩니다.</li></ul><h2 id="node-제거">Node 제거</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node 192.168.137.101:6379 `&lt;node-id&gt;`</span><br><span class="line">redis-cli --cluster del-node 192.168.137.101:6379</span><br><span class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br></pre></td></tr></table></figure></p><ul><li>위 명령은 Redis Cluster의 node를 제거하는 명령어입니다.</li><li>Redis Cluster에 포함된 아무 node를 적어준다 <code>192.168.137.101:6379 는 Redis Cluster 노드 중 하나</code></li><li>node-id는 삭제하고자 하는 node의 id입니다.</li><li>node-id는 cluster nodes 명령어를 통해 검색하여 적어줍니다.</li><li>Slave는 막 지울 수 있습니다!</li><li>하지만 <strong>Master는 노드에 저장된 내용이 하나도 없어야 삭제가 가능합니다.</strong></li><li>지울 수 있는 대안으로는 수동으로 failover를 하여 slave로 만든 다음에 삭제를 하는 방법이 있습니다.</li></ul><h3 id="re-sharding">Re-sharding</h3><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 192.168.137.101:6379</span><br></pre></td></tr></table></figure></p><ul><li>위 명령은 현재 cluster에 대한 reshard를 수행하는 명령어입니다.</li><li>cluster내의 master node 아무거나 써주면 자동으로 cluster node를 스캔하여 reshard를 수행합니다.</li><li>resharding 중에도 무중단으로 redis를 사용할 수 있습니다.</li><li>하지만 resharding을 <strong>수행하는 key에 대해서는 lock이 걸립니다.</strong></li><li>만약 resharding 대상이 많은 경우에는 redis 서버가 중지되었다가 다시 시작 될 수 있습니다.</li></ul><h1 id="redis-설치">Redis 설치</h1><h2 id="docker-설정하기">Docker 설정하기</h2><h3 id="docker-composeyml">docker-compose.yml</h3><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">   redis-master:</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">redis:5.0-alpine</span></span><br><span class="line"><span class="attr">      build:</span></span><br><span class="line"><span class="attr">         context:</span> <span class="string">..</span></span><br><span class="line"><span class="attr">         dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">      network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">      environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REQUIREPASS=&lt;password&gt;</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTPORT=6379</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"../../new_redis-data/redis1:/data"</span></span><br><span class="line"><span class="attr">      restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">   redis-slave:</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">redis:5.0-alpine</span></span><br><span class="line"><span class="attr">      build:</span></span><br><span class="line"><span class="attr">         context:</span> <span class="string">..</span></span><br><span class="line"><span class="attr">         dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">      network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">      environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REQUIREPASS=&lt;password&gt;</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTPORT=6380</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"../../new_redis-data/redis2:/data"</span></span><br><span class="line"><span class="attr">      restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure></p><ul><li>redis-cli의 cluster option을 사용하기 위해 redis:5.0-alpine 버전을 사용하였습니다.</li><li>redis:5.0.0이 RELEASE 버전이지만, Dockerfile에서 sed 명령어 사용 시, <code>Permission denied</code>가 발생하는 버그가 있습니다.</li><li>network_mode 는 <code>host</code>로 설정. <code>Docker Redis는 NAT에 대한 지원을 하지 않습니다.</code></li><li>외부 볼륨 연동을 위해 ../../new_redis-data/master 폴더와 docker container 내의 /data 폴더를 연동하였습니다.</li><li>container down 시 항상 재시작 하도록 restart policy를 always로 설정 하였습니다.</li></ul><h3 id="docker-entrypointsh">docker-entrypoint.sh</h3><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment">## from redis-5</span></span><br><span class="line">sed -i <span class="string">"s/bind 127.0.0.1/bind <span class="variable">$CLIENTHOST</span> 127.0.0.1/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">sed -i <span class="string">"s/port 6379/port <span class="variable">$CLIENTPORT</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">sed -i <span class="string">"s/# requirepass foobared/requirepass <span class="variable">$REQUIREPASS</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">sed -i <span class="string">"s/# masterauth &lt;master-password&gt;/masterauth <span class="variable">$REQUIREPASS</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">sed -i <span class="string">"s/# cluster-enabled yes/cluster-enabled yes/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">sed -i <span class="string">"s/# cluster-config-file nodes-6379.conf/cluster-config-file nodes.conf/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">sed -i <span class="string">"s/# cluster-node-timeout 15000/cluster-node-timeout 5000/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;1#-&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ] || [ <span class="string">"<span class="variable">$&#123;1%.conf&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">set</span> -- redis-server <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'redis-server'</span> -a <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></span><br><span class="line">chown -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure></p><ul><li>sed명령어를 통해 container내의 redis.conf파일을 치환<code>치환자에 대한 설정은 docker-compose.yml &gt; environment에 등록</code><ul><li>bind 옵션에 대해 CLINET IP를 설정</li><li>port도 기본 6379 port에서 6379, 6380으로 치환하였습니다.</li><li>requirepass도 설정</li><li>masterauth도 requirepass와 동일하게 설정</li><li>cluster-mode를 사용하기 위해 <code>cluster-enable yes</code>로 설정</li><li>cluster에 대한 로그를 볼 수 있도록 <code>cluster-config-file nodes.conf</code> conf 파일 지정 (여기에 로그 생성)</li><li>cluster failover를 위해 <code>cluster-node-timeout</code>을 5초로 지정</li></ul></li></ul><h1 id="failover-test">Failover Test</h1><p>테스트를 위해 192.168.137.101:6379 (master1)에 대한 docker container를 죽여보았습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 030bb02a246e</span><br></pre></td></tr></table></figure></p><p><img src="./master-down.png" alt="master-down"></p><ul><li>docker ps -a 명령으로 볼 때 192.168.137.101:6379 (master1)에 대한 docker container가 다운!!</li></ul><p><img src="./failover-1.png" alt="failover-1"></p><ul><li><p>5초 정도 지나니 무슨 로그가 올라왔습니다. epoch vote라는 로그를 보아하니 새로운 마스터를 선출하였습니다.</p></li><li><p>redis-cli를 통해 <code>cluster nodes</code>를 검색해 보니 <code>192.168.137.101:6379 (master1)</code>의 slave였던 <code>192.168.137.103:6380 (slave1)</code> 가 새로운 master로 promote 되었습니다.</p></li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 030bb02a246e</span><br></pre></td></tr></table></figure></p><ul><li>docker start 명령으로 다시 container를 살려보았습니다.</li></ul><p><img src="./failover2.png" alt="failover2"></p><ul><li>기존의 master는 slave로 편입되어 정상적인 cluster가 작동하고 있습니다.</li></ul><h1 id="sharding-test">Sharding Test</h1><p><img src="./cluster-keys-command.PNG" alt="cluster-keys-command"></p><ul><li>redis-cli를 통해 foo1~foo10까지 key를 만들어 set해 보았습니다.</li><li>set할때 마다 16384 modules 연산을 통해 slot별로 sharding이 되는 모습입니다.</li><li>각 redis-cli에서 keys * 명령을 통해 조회 해보면 고르게 sharding이 되어있음을 확인 할 수 있습니다.</li></ul><h1 id="node-addremove">Node ADD/REMOVE</h1><p><img src="./cluster-add.PNG" alt="cluster-add"></p><ul><li>신규 Master node (192.168.137.104:6379)를 새로이 추가해 보았습니다.</li></ul><p><img src="./cluster-add-node-slave.PNG" alt="cluster-add-node-slave"><img src="./slave-add-result.png" alt="slave-add-result"></p><ul><li>신규 Slave node (192.168.137.104:6380)를 새로이 추가해 보았습니다.</li><li>신규 Master node (192.168.137.104:6379)의 slave로 추가해보았다.</li><li>정상적으로 모두 등록 되었다.</li></ul><p><img src="./slave-del.png" alt="slave-del"></p><ul><li>slave를 삭제해 보았습니다.</li></ul><p><img src="./slave-del-result.png" alt="slave-del-result"></p><ul><li>slave가 정상적으로 삭제 되었습니다.</li></ul><p><img src="./master-del-fail.png" alt="master-del-fail"></p><ul><li>master 삭제를 시도해 보았습니다.</li><li>slot이 비어있지 않아 삭제가 불가능 했습니다.</li><li>이런 경우 reshard를 통해 slot을 비워준뒤에 삭제 해야합니다.</li></ul><p><img src="./sub-reshard.PNG" alt="sub-reshard"></p><ul><li>reshard 명령을 다시 실행 합니다.</li><li><code>What is the receiving node ID?</code> 라는 질문에 192.168.137.101:6379 node-id를 지정합니다.</li><li><code>Source node</code> 항목에는 우리가 삭제할 192.168.137.104:6379 node-id를 지정합니다.</li><li><code>source node</code> 두번째 항목에는 done을 입력하여 Source node 항목을 모두 입력하였음을 선언해 줍니다.</li></ul><p><img src="./master-del-success.png" alt="master-del-success"></p><ul><li>다시 master를 삭제하니 정상적으로 삭제가 됩니다.</li></ul><h1 id="re-sharding-test">Re-Sharding Test</h1><p><img src="./reshard-test-1-3831920.PNG" alt="reshard-test-1"></p><ul><li>새롭게 추가한 노드에 reshard를 해보았습니다.</li><li>4000개정도를 새로이 옮긴다고 조건을 주고 Resharding을 실행 해보았습니다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br></pre></td></tr></table></figure></li></ul><p><img src="./reshard-test-2-3832564.PNG" alt="reshard-test-2"></p><p><img src="./reshard-test-3.PNG" alt="reshard-test-3"></p><ul><li>정상적으로 resharding이 되어 데이터가 4개의 node에 고르게 분포 되었습니다.</li></ul><h1 id="참고">참고</h1><ul><li>https://redis.io/topics/cluster-tutorial</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/03/2018-12-03-docker-10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (9) Redis-Stats을 이용한 모니터링</title>
      <link>https://jaehun2841.github.io/2018/12/03/2018-12-03-redis-stats/</link>
      <guid>https://jaehun2841.github.io/2018/12/03/2018-12-03-redis-stats/</guid>
      <pubDate>Mon, 03 Dec 2018 06:04:50 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;redis-stats&quot;&gt;Redis-stats&lt;/h1&gt;
&lt;p&gt;Redis-stat은 대표적인 &lt;code&gt;오픈소스 Redis 모니터링 도구&lt;/code&gt;입니다.&lt;/p&gt;
&lt;p&gt;Ruby 기반으로 동작하는 프로그램이며, Ruby만 설치되어 있다면 설
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="redis-stats">Redis-stats</h1><p>Redis-stat은 대표적인 <code>오픈소스 Redis 모니터링 도구</code>입니다.</p><p>Ruby 기반으로 동작하는 프로그램이며, Ruby만 설치되어 있다면 설치가 간편하고 Web 또는 Console로 Redis 서버를 모니터링 할 수 있습니다.비슷한 모니터링 도구로 Redmon, RedisLive등이 있지만.. Redis 4이상 버전을 아직 지원하지 않아서 Redis-stat으로 설치 해보게 되었습니다.</p><h1 id="redis-stats-설치하기">Redis-stats 설치하기</h1><h2 id="install-dependency">Install Dependency</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc-c++ patch readline readline-devel zlib zlib-devel openssl-devel make</span><br><span class="line">yum install -y bzip2 autoconf automake libtool bison iconv-devel sqlite-devel libyaml-devel libffi-devel</span><br></pre></td></tr></table></figure></p><h2 id="install-rvm-ruby-version-manager">Install RVM (Ruby Version Manager)</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://rvm.io/mpapis.asc | gpg --import</span><br><span class="line">curl -L get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure></p><h2 id="setup-rvm-environment">Setup RVM Environment</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile.d/rvm.sh</span><br><span class="line">rvm reload</span><br></pre></td></tr></table></figure></p><h2 id="install-ruby-233">Install Ruby 2.3.3</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm install 2.3.3</span><br></pre></td></tr></table></figure></p><h2 id="set-default-ruby-version">Set Default Ruby Version</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rvm list</span><br><span class="line">rvm use 2.3.3 --default</span><br></pre></td></tr></table></figure></p><h2 id="setup-redis-stat">Setup Redis-stat</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install redis-stat</span><br></pre></td></tr></table></figure></p><h1 id="redis-stat-실행하기">Redis-stat 실행하기</h1><p>Redis-stat은 Web에서 조회하는 방법과 Console에서 조회하는 방법이 있습니다.두 가지 형태의 모니터링 방법과 속성에 대해 알아보겠습니다.</p><h2 id="redis-stat-옵션">Redis-stat 옵션</h2><table><thead><tr><th><strong>명령어</strong></th><th><strong>설명</strong></th><th><strong>비고</strong></th></tr></thead><tbody><tr><td>redis-stat 1</td><td>localhost:6379 1초 간격으로 조회</td><td></td></tr><tr><td>redis-stat 1 10</td><td>localhost:6379 1초 간격으로 10회 조회</td><td></td></tr><tr><td>redis-stat --verbose</td><td>localhost:6379 2초 간격으로 보여주기</td><td></td></tr><tr><td>redis-stat 192.168.0.2:6379 192.168.0.2:6380 5</td><td>192.168.0.2:6379 192.168.0.2:6380서버를 5초 간격으로 보여주기</td><td></td></tr><tr><td>redis-stat --csv=/temp/redis-log.csv</td><td>csv파일 남기기</td><td></td></tr><tr><td>redis-stat --daemon --server 8888</td><td>daemon 모드로 실행 port 8888번으로 접속 시, Web Monitoring mode로 작동</td><td>daemon과 server는 반드시 같이 사용해야하는 옵션</td></tr><tr><td>redis-stat -a (--auth) password</td><td>-a 또는 --auth 옵션을 통해 requirepass 비밀번호 설정</td><td></td></tr></tbody></table><h2 id="redis-stat-console-monitoring">Redis-stat (Console Monitoring)</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#192.168.137.101 서버의 6379~6381 포트 정보를 조회</span></span><br><span class="line">redis-stat 1 -a password1234 \</span><br><span class="line">192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381</span><br></pre></td></tr></table></figure></p><p><img src="./redis-stat-1.PNG" alt="redis-stat-1"></p><h2 id="redis-stat-web-monitoring">Redis-stat (Web Monitoring)</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># CentOs 방화벽 포트 open</span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-port 8888/tcp</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"> </span><br><span class="line"><span class="comment">#192.168.137.101 서버의 6379~6381 포트 정보를 조회</span></span><br><span class="line">redis-stat 1 -a &lt;requirepass&gt; \</span><br><span class="line">192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381 \</span><br><span class="line">--daemon --server=8888</span><br></pre></td></tr></table></figure></p><h2 id="1921681371048888-서버로-접속">192.168.137.104:8888 서버로 접속</h2><p><img src="./redis-stat-web.PNG" alt="redis-stat-web"></p><p><img src="./redis-stat-web2.PNG" alt="redis-stat-web2"></p><h1 id="아쉬운-점">아쉬운 점</h1><ol><li>그 당시의 모니터링만 가능하다. (별도 저장소가 없기 때문) -&gt; 이전 로그를 보기 위해선 CSV 파일을 남기는 것이 최선</li><li>보고자 하는 정보가 적다. 기본적으로 메모리 사용량, Client 수 Key Size정도는 제공을 하지만 다른 툴에서는 더 많은 정보가 제공되는 것 같다.</li></ol><h1 id="참고">참고</h1><ul><li><a href="https://github.com/junegunn/redis-stat" target="_blank" rel="noopener">https://github.com/junegunn/redis-stat</a></li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/03/2018-12-03-redis-stats/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (8) HAProxy를 이용한 분산처리 환경 구축하기</title>
      <link>https://jaehun2841.github.io/2018/12/02/2018-12-02-docker-8/</link>
      <guid>https://jaehun2841.github.io/2018/12/02/2018-12-02-docker-8/</guid>
      <pubDate>Sun, 02 Dec 2018 11:32:11 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;haproxy란&quot;&gt;HAProxy란?&lt;/h1&gt;
&lt;p&gt;HAProxy는 기존의 하드웨어 스위치(L4/L7)을 대체하는 소프트웨어 로드밸런서입니다.
로드 밸런싱이란 부하 분산을 위해서 가상IP를 통해 여러서버에 접속하도록 트래픽을 분배해 주는 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="haproxy란">HAProxy란?</h1><p>HAProxy는 기존의 하드웨어 스위치(L4/L7)을 대체하는 소프트웨어 로드밸런서입니다.로드 밸런싱이란 부하 분산을 위해서 가상IP를 통해 여러서버에 접속하도록 트래픽을 분배해 주는 기능을 의미합니다.</p><h1 id="redis-cluster에-haproxy가-필요한-이유">Redis-Cluster에 HAProxy가 필요한 이유</h1><p>Redis Cluster에서는 Failover가 일어날 수 있습니다.</p><p>처음에 1번이 Master였다가, 2번이 Master가 되고, 3번이 Master가 될 수 있습니다.하지만 Redis Cluster를 사용하는 Application에서 항상 바뀌는 Master의 포트정보를 찾는것은 매우 비용을 낭비하는 행위라 볼 수 있습니다.</p><p>따라서 HAProxy에서 Health check를 하면서 실시간으로 Master를 찾아 신호를 보내줄 수 있기 때문에 HAProxy를 Redis-Cluster에 접목하였습니다.</p><h1 id="다시-한번-보는-redis-cluster-구성도">다시 한번 보는 Redis Cluster 구성도</h1><p><img src="./Redis-Cluster-archi.PNG" alt="Redis-Cluster-archi"></p><p>HAProxy Port를 6개를 지정합니다. (각각 1개는 Master Port, Slave Port라고 가정하고 (1(master)+1(slave)) x 3 (서버대수))</p><p>5000, 5002, 5004번 Port는 각 서버의 Master Redis를 체크합니다.따라서 5000, 5002, 5004으로 들어온 요청은 각각의 서버의 Master Redis에 전달 됩니다.</p><p>다음으로 5001, 5003, 5005번 Port는 각 서버의 Slave Redis를 체크합니다.따라서 5001, 5003, 5005으로 들어온 요청은 각각의 서버의 Slave Redis들에게 전달됩니다. (HAProxy에는 여러 서버에 대한 분배방식을 설정 할 수 있는데 고루게 요청할 수 있도록 RoundRobin 방식으로 설정하였습니다)</p><h1 id="haproxy-설치방법">HAProxy 설치방법</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 관련 모듈을 yum으로 설치한다.</span></span><br><span class="line">yum install gcc gcc-c++ pcre-devel openssl-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># wget명령어도 haproxy 다운로드</span></span><br><span class="line">wget http://www.haproxy.org/download/1.8/src/haproxy-1.8.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 압축을 풀어준다.</span></span><br><span class="line">tar zxvf haproxy-1.8.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 디렉토리 이동</span></span><br><span class="line"><span class="built_in">cd</span> haproxy-1.8.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># c파일을 컴파일 해준다. https 사용이 필요한 경우 USE_OPENSSL=1 설정 추가</span></span><br><span class="line">make TARGET=linux2628 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># /usr/local/haproxy 디렉토리에 설치</span></span><br><span class="line">make PREFIX=/usr/<span class="built_in">local</span>/haproxy DESTDIR= install</span><br></pre></td></tr></table></figure></p><h1 id="haproxycfg-파일-작성">haproxy.cfg 파일 작성</h1><p>haproxy.cfg 파일을 작성 할 때는 크게 2가지 관점으로 작성합니다.</p><ul><li>frontend : haproxy에서 사용할 포트 설정, 포트로 신호가 왔을 시 실행할 backend 연결</li><li>backend : frontend로 부터 온 신호를 바탕으로 연결가능한 서버에 트래픽을 분배</li></ul><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">global</span><br><span class="line">  <span class="built_in">log</span> 127.0.0.1 local0</span><br><span class="line">  <span class="built_in">log</span> 127.0.0.1 local1 notice</span><br><span class="line"> </span><br><span class="line">defaults REDIS</span><br><span class="line">mode tcp</span><br><span class="line">timeout connect 4s</span><br><span class="line">timeout server 15s</span><br><span class="line">timeout client 15s</span><br><span class="line"><span class="comment"># timeout tunnel 365d</span></span><br><span class="line"> </span><br><span class="line">frontend front_redis_master1</span><br><span class="line"> <span class="built_in">bind</span> *:5000 name redis                 <span class="comment">#5000번 포트에 대한 bind 정보입니다.</span></span><br><span class="line"> default_backend back_redis_master1     <span class="comment">#5000번 포트로 신호가 들어오면 backend를 실행</span></span><br><span class="line"> </span><br><span class="line">backend back_redis_master1</span><br><span class="line"> option tcp-check                       <span class="comment">#tcp-check를 통해 접근가능한 서버 필터링</span></span><br><span class="line"> tcp-check send AUTH\ password1234\r\n  <span class="comment">#비밀번호 password1234를 입력하고 Redis 서버에 접속합니다.</span></span><br><span class="line"> tcp-check expect string +OK            <span class="comment">#OK가 왔는지?</span></span><br><span class="line"> tcp-check send PING\r\n                <span class="comment">#PING을 날려 신호를 점검합니다.</span></span><br><span class="line"> tcp-check expect string +PONG          <span class="comment">#PONG이라는 응답이 왔는지?</span></span><br><span class="line"> tcp-check send info\ replication\r\n   <span class="comment">#info replication 명령을 날려 Redis에 대한 정보를 받아옵니다.</span></span><br><span class="line"> tcp-check expect string role:master    <span class="comment">#role이 master인지 확인 합니다.</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">#repl_backlog_active의 값이 1인지 확인합니다 </span></span><br><span class="line"> <span class="comment">#이 조건을 추가한 이유는 Failover간 잠시의 시간동안 Master가 2대가 되는데 그것을 방지 하기 위함입니다.</span></span><br><span class="line"> <span class="comment">#(진짜 Master Redis에만 1, slave는 0)</span></span><br><span class="line"> tcp-check expect string repl_backlog_active:1 </span><br><span class="line"> tcp-check send QUIT\r\n                <span class="comment">#QUIT 명령을 전송</span></span><br><span class="line"> tcp-check expect string +OK</span><br><span class="line"> server redis1 192.168.137.101:6379 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis2 192.168.137.101:6380 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis3 192.168.137.101:6381 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> </span><br><span class="line">frontend front_redis_slave1</span><br><span class="line"><span class="built_in">bind</span> *:5001 name redis                <span class="comment">#5001번 포트에 대한 bind 정보입니다.</span></span><br><span class="line">default_backend back_redis_slave1</span><br><span class="line"> </span><br><span class="line">backend back_redis_slave1</span><br><span class="line"> balance roundrobin                   <span class="comment">#라운드 로빈 방식으로 분배</span></span><br><span class="line"> option tcp-check</span><br><span class="line"> tcp-check send AUTH\ password1234\r\n        </span><br><span class="line"> tcp-check expect string +OK</span><br><span class="line"> tcp-check send PING\r\n              </span><br><span class="line"> tcp-check expect string +PONG</span><br><span class="line"> tcp-check send info\ replication\r\n </span><br><span class="line"> tcp-check expect string role:slave   <span class="comment">#role key가 slave인지 확인 합니다.</span></span><br><span class="line"> tcp-check send QUIT\r\n</span><br><span class="line"> tcp-check expect string +OK</span><br><span class="line"> server redis1 192.168.137.101:6379 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis2 192.168.137.101:6380 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis3 192.168.137.101:6381 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#Listen on all IP's on port 9000 //9000 포트로 접근 시, Web Console에 진입할 수 있습니다. </span></span><br><span class="line">listen stats</span><br><span class="line">   <span class="built_in">bind</span> 0.0.0.0:9000 </span><br><span class="line">   mode http</span><br><span class="line">   balance</span><br><span class="line">   timeout client 5000</span><br><span class="line">   timeout connect 4000</span><br><span class="line">   timeout server 30000</span><br><span class="line"> </span><br><span class="line">   <span class="comment">#This is the virtual URL to access the stats page</span></span><br><span class="line">   stats uri /haproxy_stats //URL주소는 ip:9000/haproxy_stats입니다.</span><br><span class="line">   <span class="comment">#Authentication realm. This can be set to anything. Escape space characters with a backslash.</span></span><br><span class="line">   stats realm HAProxy\ Statistics</span><br><span class="line"> </span><br><span class="line">   <span class="comment">#The user/pass you want to use. Change this password!</span></span><br><span class="line">   stats auth admin:1234 <span class="comment">#Web Console에 접근하는 계정/암호 설정</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">#This allows you to take down and bring up back end servers.</span></span><br><span class="line">   <span class="comment">#This will produce an error on older versions of HAProxy.</span></span><br><span class="line">   stats admin <span class="keyword">if</span> TRUE</span><br></pre></td></tr></table></figure></p><p>위의 내용에서는 일단 하나의 Master-Slave에 대한 설정값만 있습니다.여태까지 설치 내용에서는 Master-Slave 구성이 3세트이기 때문에 실제 haproxy.cfg를 작성 할 경우에는5002~5005번 포트를 사용하는 설정에 대해서도 추가해야 합니다.</p><h1 id="haproxy-web-console-확인하기">HAProxy Web Console 확인하기</h1><p><img src="./haproxy1.PNG" alt="haproxy1"></p><p><strong>haproxy-server-ip:9000</strong> 으로 접속하였습니다현재 192.168.137.101 서버에는 6379, 6380, 6381 포트를 사용하는 Redis 노드가 3개가 동작하고 있습니다.현재 master 역할을 수행하는 것은 6380 포트를 사용하는 redis2 노드입니다.따라서 <strong>haproxy-server-ip:5000</strong> 으로 접속하게 되면 redis2 노드에 신호가 분배되어 Redis master서버에 대한 명령을 실행 할 수 있습니다.</p><p>현재 slave 역할을 수행하는 것은 6379, 6381포트를 사용하는 redis1, redis3노드 입니다.따라서 <strong>haproxy-server-ip:5001</strong>으로 접속하게 되면 RoundRobin 방식으로 redis1, redis3 노드에 신호가 분배되어 Redis slave 서버에 대한 명령을 실행 할 수 있습니다</p><blockquote><p><strong>HAProxy를 구성한 이유</strong></p><p>Application에서 Redis를 사용하면서, Master에만 데이터를 입력하고, Slave에서만 데이터를 조회하려는 행위를 많이 하게 됩니다. 아무래도 Redis서버에 대한 부하를 줄여주고자 이러한 행위를 하게 되는데, Haproxy를 설정 해 두면, Application Server에서 failover로 인해 변하는 master/slave 포트에 대한 걱정을 할 필요가 없습니다.HAProxy에서 알아서 tcp-check를 통해 master/slave를 정해주기 때문입니다.</p></blockquote><h1 id="failover-test">Failover Test</h1><p>Sentinel 테스트와 동일하게 Master를 죽여보도록 하겠습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;master-node-id&gt;</span><br></pre></td></tr></table></figure></p><p><img src="./haproxy2.PNG" alt="haproxy2"></p><p>Master node를 죽이니, 5000번 포트에서는 더이상 master로 갈 수 있는 서버가 없다고 나옵니다.(<strong>이 때 순단을 최소화 하려면 failover 시간과, HAProxy tcp-check 시간을 최소로 줄여야 합니다.</strong>)</p><p><img src="./haproxy3.PNG" alt="haproxy3"></p><p>잠시 시간이 지나고 Redis Failover가 진행됩니다. 진행이 완료되면, HAProxy에서도 tcp-check가 이루어집니다.</p><p><img src="./haproxy4.PNG" alt="haproxy4"></p><p>tcp-check가 끝나고 redis1 노드가 master로 선출되어, 5000번 포트로 접근 시, redis1 노드로 분산되게 됩니다.</p><p>다시, 죽었던 redis2 노드를 살려보겠습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;redis2_node_id&gt;</span><br></pre></td></tr></table></figure></p><p><img src="./haproxy5.PNG" alt="haproxy5"></p><p>redis2 노드가 다시 살아나고, sentinel에서도 role-change 작업이 이루어집니다.곧이어, HAProxy에서도 tcp-check를 통해 redis2노드가 slave가 되었음을 확인하고 5001 포트에서 분배가능한 서버로 분류됩니다.</p><p><img src="./haproxy6.PNG" alt="haproxy6"></p><p>이와 같이 Application Server에서는 무조건 master port는 5000번, slave port는 5001번 이라고만 알고 있으면 Redis서버에서 failover가 진행되더라도, 설정을 바꿀 필요없이 사용이 가능합니다.</p><h1 id="참고">참고</h1><ul><li>http://blog.whitelife.co.kr/321</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/02/2018-12-02-docker-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (7) Docker를 이용한 Redis Sentinel 설치하기</title>
      <link>https://jaehun2841.github.io/2018/12/02/2018-12-02-docker-7/</link>
      <guid>https://jaehun2841.github.io/2018/12/02/2018-12-02-docker-7/</guid>
      <pubDate>Sun, 02 Dec 2018 06:46:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;redis-sentinel이란&quot;&gt;Redis Sentinel이란?&lt;/h1&gt;
&lt;p&gt;Redis Cluster 운영환경에서 Master-Slave 관계를 가진 Redis가 있습니다.
시스템 오류나 알수 없는 원인으로 인해 Master Redis
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="redis-sentinel이란">Redis Sentinel이란?</h1><p>Redis Cluster 운영환경에서 Master-Slave 관계를 가진 Redis가 있습니다.시스템 오류나 알수 없는 원인으로 인해 Master Redis가 down되어 연결이 중단 되면, 사용자나 Application에서는 Redis Master를 통해 데이터를 등록 할 수 없게 됩니다.이런 경우 Slave Redis를 Master Redis로 승격시켜 시스템이 정상적으로 운영 될 수 있도록 해야 합니다.</p><p>이 때 사용하는 게 Redis Sentinel입니다.Sentinel은 Master Redis의 상태를 감시합니다. 그러다가 Master Redis가 Down이 되어버리면, Sentinel들은 Slave Redis들 중에 어떤 Redis 서버를 Master로 승격시킬지 투표하게 됩니다.Slave Redis 중 Sentinel의 투표를 더 많이 받은 Redis Server가 Master Redis로 승격됩니다.이후 장애를 해결한 원래 Master Redis는 재시작 시, 현재 Master Redis의 Slave Redis로 시작되게 됩니다.</p><p>이와같이, Redis Sentinel은 Redis Cluster 환경에서의 Failover를 자동으로 해주는 Redis의 한 Mode입니다.</p><h1 id="role-change-원리">Role Change 원리</h1><p><img src="./Redis-failover-1.PNG" alt="Redis-failover-1"></p><p>위의 상황은 6379 포트를 사용하는 Master Redis가 Down된 상황입니다.Sentinel들은 일제히 Master Redis를 감시하다가 Down된 상황을 인지하고2번째 그림처럼 Slave Redis들 중 어떤 Redis 서버를 Master Redis로 승격할 지 투표로 정하게 됩니다.여기서 중요한 건 Redis Sentinel의 노드 갯수는 <code>항상 홀수로 설정</code>해야 합니다. (짝수 인 경우 1:1, 2:2 상황이 되어 어떤 Redis Server를 승격 시킬지 알 수 없기 때문입니다.)위의 예제에서는 15485 번 포트를 사용하는 Slave Redis가 2대1로 선택되었습니다.Sentinel은 바로 redis.conf 파일을 조작하여 Slave Redis를 Master Redis로 변경합니다.그리고 자기 자신의 sentinel.conf 정보를 조작하여 감시하는 Redis 서버 정보를 update 합니다.이후 Down되었던 기존의 Master Redis의 장애가 처리되어 Restart되는 경우를 보도록 하겠습니다.</p><p><img src="./Redis-failover-2.PNG" alt="Redis-failover-2"></p><p>Sentinel은 Down되었던 Master 정보를 메모리에 저장하고 있습니다.이후 Down되었던 Master Redis가 장애를 처리하고 다시 시작 되는 경우, Master Redis의 redis.conf 파일을 조작하여현재 Master Redis의 Slave로 설정합니다.</p><blockquote><p>이 경우 Sentinel의 설정 값이 따라 다르지만,일시적으로 Master Redis가 2대가 됩니다.만약에 Down 되었다가 Restart된 Redis에 Data가 저장되는 경우, Slave Redis로 전환되면서 Master의 rdb파일을 바탕으로 Data를 Update하기 때문에 데이터가 사라지는 상황이 오게 됩니다.따라서 Down 되었다가 살아나는 Redis에 접근 하지 못하도록 막아야 합니다.</p></blockquote><h1 id="redis-sentinel-설치하기">Redis Sentinel 설치하기</h1><p>Docker, Docker-Compose, git은 Redis Cluster를 설치하며 설치 했다고 가정하겠습니다.</p><h2 id="redis-sentinel-파일-다운로드">Redis Sentinel 파일 다운로드</h2><p>기존에 github에 올려둔 Sentienel 설정파일을 다운로드 합니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkdir -p /home/redis/redis-sentinel <span class="comment">#Redis-sentinel home 생성</span></span><br><span class="line"><span class="built_in">cd</span> /home/redis</span><br><span class="line">mkdir -p ./sentinel-data/sentinel1   <span class="comment">#외부 log파일 볼륨 설정</span></span><br><span class="line">mkdir -p ./sentinel-data/sentinel2</span><br><span class="line">mkdir -p ./sentinel-data/sentinel3</span><br><span class="line"> </span><br><span class="line">git init</span><br><span class="line">git remote add origin <span class="string">"https://github.com/jaehun2841/redis-sentinel-on-docker.git"</span></span><br><span class="line">git pull origin master <span class="comment">#github에서 sentinel 설정 파일 다운로드</span></span><br></pre></td></tr></table></figure></p><h2 id="redis-sentinel-build">Redis sentinel Build</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/redis/redis-sentinel</span><br><span class="line">docker-compose -f conf/sentinel-docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure></p><h1 id="redis-sentinel-생성을-위한-docker-composeyml파일">Redis Sentinel 생성을 위한 docker-compose.yml파일</h1><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">  redis-sentinel1:</span>                        <span class="comment">#Sentinel Container명</span></span><br><span class="line"><span class="attr">     image:</span> <span class="string">lgatica/redis-sentinel:4.0.2</span>  <span class="comment">#redis-sentinel 이미지를 바탕으로 빌드합니다.</span></span><br><span class="line"><span class="attr">     build:</span></span><br><span class="line"><span class="attr">       context:</span> <span class="string">..</span>                        <span class="comment">#Dockerfile context 설정</span></span><br><span class="line"><span class="attr">       dockerfile:</span> <span class="string">Dockerfile</span>             <span class="comment">#Dockerfile명 설정 (Default는 Dockerfile로 된 파일명을 찾습니다.)</span></span><br><span class="line"><span class="attr">     network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">     environment:</span>                         <span class="comment">#Container에서 사용할 환경 변수 설정</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTPORT=26379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERPORT=6379</span>                   <span class="comment">#Sentinel의 mymaster port를 적어줍니다.</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">QUORUM=2</span>                          <span class="comment">#QUORUM 값은 Sentinel들이 투표했을때 득표수가 2 이상인 Redis에 대해 Master로 승격할 수 있도록 하는 조건 값입니다.</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DOWN_AFTER_MILLISEC=3000</span>          <span class="comment">#Redis master node down 후 3초 이후 failover 시작</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">FAILOVER_TIMEOUT=3000</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line"><span class="attr">     volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"../../sentinel-data/sentinel1:/redis"</span>  <span class="comment">#Container 외부 볼륨 설정</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span>                         <span class="comment">#restart policy Container가 중지되거나 down되는 경우 무조건 다시 시작합니다.</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">  redis-sentinel2:</span></span><br><span class="line"><span class="attr">     image:</span> <span class="string">lgatica/redis-sentinel:4.0.2</span></span><br><span class="line"><span class="attr">     build:</span></span><br><span class="line"><span class="attr">       context:</span> <span class="string">..</span></span><br><span class="line"><span class="attr">       dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">     network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTPORT=26380</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">QUORUM=2</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DOWN_AFTER_MILLISEC=3000</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">FAILOVER_TIMEOUT=3000</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line"><span class="attr">     volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"../../sentinel-data/sentinel2:/redis"</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">  redis-sentinel3:</span></span><br><span class="line"><span class="attr">     image:</span> <span class="string">lgatica/redis-sentinel:4.0.2</span></span><br><span class="line"><span class="attr">     build:</span></span><br><span class="line"><span class="attr">       context:</span> <span class="string">..</span></span><br><span class="line"><span class="attr">       dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">     network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTPORT=26381</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">QUORUM=2</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DOWN_AFTER_MILLISEC=3000</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">FAILOVER_TIMEOUT=3000</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line"><span class="attr">     volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"../../sentinel-data/sentinel3:/redis"</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure></p><h1 id="redis-sentinel-이미지-생성을-위한-dockerfile-작성">Redis Sentinel 이미지 생성을 위한 Dockerfile 작성</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#redis-sentinel 이미지 기반으로 빌드합니다.</span></span><br><span class="line">FROM lgatica/redis-sentinel:4.0.2   </span><br><span class="line"> </span><br><span class="line">MAINTAINER Carrey </span><br><span class="line"> </span><br><span class="line"><span class="comment">## Copy Redis File</span></span><br><span class="line"><span class="comment">## 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 한다.</span></span><br><span class="line"><span class="comment"># 기존 container의 sentinel-entrypoint.sh 삭제합니다.</span></span><br><span class="line">RUN rm -rf /usr/<span class="built_in">local</span>/bin/sentinel-entrypoint.sh         </span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel 설정이 담긴 sentinel.conf 파일 복사합니다.</span></span><br><span class="line">ADD sentinel.conf /usr/<span class="built_in">local</span>/bin/sentinel.conf                          </span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel container 시작 시, 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.</span></span><br><span class="line">ADD sentinel-entrypoint.sh /usr/<span class="built_in">local</span>/bin/sentinel-entrypoint.sh         </span><br><span class="line"> </span><br><span class="line"><span class="comment">## change access authority</span></span><br><span class="line"><span class="comment"># 복사한 파일에 대한 권한을 변경합니다. (Permission Denied 문제)</span></span><br><span class="line">RUN chmod 755 /usr/<span class="built_in">local</span>/bin/sentinel.conf                               </span><br><span class="line">RUN chmod 755 /usr/<span class="built_in">local</span>/bin/sentinel-entrypoint.sh</span><br><span class="line">RUN chown redis:redis /usr/<span class="built_in">local</span>/bin/sentinel.conf</span><br><span class="line">RUN chown redis:redis /usr/<span class="built_in">local</span>/bin/sentinel-entrypoint.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Redis Container에 대한 Port를 지정합니다. (host 모드이기 때문에 외부 노출)</span></span><br><span class="line">EXPOSE <span class="variable">$CLIENTPORT</span>                                    </span><br><span class="line"></span><br><span class="line"><span class="comment"># Container가 생성, 시작하는 시점에 실행됩니다.</span></span><br><span class="line">ENTRYPOINT [<span class="string">"/usr/local/bin/sentinel-entrypoint.sh"</span>]        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Container 빌드가 완료되고 Sentinel Server를 실행시킵니다. </span></span><br><span class="line"><span class="comment"># conf 파일 뿐만 아니라 --sentinel 옵션을 추가하여 Redis가 Sentinel 모드로 실행 되도록 합니다.</span></span><br><span class="line"><span class="comment"># Sentinel 또한 Redis Server이지만, Sentinel 설정을 하여 실행 시키는 것 뿐입니다.</span></span><br><span class="line">CMD [ <span class="string">"redis-server"</span>,<span class="string">"/usr/local/bin/sentinel.conf"</span>, <span class="string">"--sentinel"</span> ]</span><br></pre></td></tr></table></figure></p><h1 id="redis-sentinel-설정">Redis Sentinel 설정</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"> </span><br><span class="line"><span class="comment"># bind 127.0.0.1 문자열을 각 이미지에서 설정한 $CLIENTHOST 값으로 변경합니다. </span></span><br><span class="line"><span class="comment"># $CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.</span></span><br><span class="line">sed -i <span class="string">"s/bind 127.0.0.1/bind <span class="variable">$CLIENTHOST</span>/g"</span> /usr/<span class="built_in">local</span>/bin/sentinel.conf      </span><br><span class="line">         </span><br><span class="line"><span class="comment"># port 6379 문자열을 각 이미지에서 설정한 $CLIENTPORT 값으로 변경합니다. </span></span><br><span class="line"><span class="comment"># Sentinel 이미지 별로 port다르게 설정</span></span><br><span class="line">sed -i <span class="string">"s/port 6379/port <span class="variable">$CLIENTPORT</span>/g"</span> /usr/<span class="built_in">local</span>/bin/sentinel.conf  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># sentinel에 대한 mymaster를 설정하는 부분입니다. </span></span><br><span class="line"><span class="comment"># 실제 Master Redis의 ip와 port를 설정하고 QUORUM 값을 설정합니다.</span></span><br><span class="line"><span class="comment"># QUORUM 값은 Slave-&gt;Master Role Change 시, slave redis가 받아야 하는 최소 투표 수 입니다.</span></span><br><span class="line">sed -i <span class="string">"s/sentinel monitor mymaster 127.0.0.1 6379 2/sentinel monitor mymaster <span class="variable">$MASTERHOST</span> <span class="variable">$MASTERPORT</span> <span class="variable">$QUORUM</span>/g"</span> /usr/<span class="built_in">local</span>/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Redis server가 다운되고 후처리 실행 시간 까지 걸리는 시간을 지정합니다. </span></span><br><span class="line"><span class="comment"># ex)3000 -&gt; 3000 밀리세컨드 -&gt; 3초</span></span><br><span class="line">sed -i <span class="string">"s/sentinel down-after-milliseconds mymaster 30000/sentinel down-after-milliseconds mymaster <span class="variable">$DOWN_AFTER_MILLISEC</span>/g"</span> /usr/<span class="built_in">local</span>/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Redis failover timeout 시간을 설정 합니다.</span></span><br><span class="line">sed -i <span class="string">"s/sentinel failover-timeout mymaster 180000/sentinel failover-timeout mymaster <span class="variable">$FAILOVER_TIMEOUT</span>/g"</span> /usr/<span class="built_in">local</span>/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># sentinel이 master redis에 접근할 때 인증하는 비밀번호를 설정합니다.</span></span><br><span class="line">sed -i <span class="string">"s/# sentinel auth-pass mymaster MySUPER--secret-0123passw0rd/sentinel auth-pass mymaster <span class="variable">$REQUIREPASS</span>/g"</span> /usr/<span class="built_in">local</span>/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;1#-&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ] || [ <span class="string">"<span class="variable">$&#123;1%.conf&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">set</span> -- redis-server <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'redis-server'</span> -a <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure></p><h1 id="redis-sentinel-실행-결과">Redis Sentinel 실행 결과</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f conf/sentinel-docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure></p><p><img src="./redis-sentinel-log.PNG" alt="redis-sentinel-log"></p><p>sentinel 1~3 까지의 로그를 모아보았습니다.테스트용 port인 (6379~6381) 에 대한 master/slave 정보를 가지고 있는것을 볼수 있습니다.</p><p>로그처럼</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel2_1  | 1:X 02 Dec 10:06:24.082 # +monitor master mymaster 192.168.137.101 6379 quorum 2</span><br></pre></td></tr></table></figure></p><p>sentinel이 자신의 마스터에 대한 정보를 가지고 모니터 하며 quorum 2를 가지고 있는 것을 볼 수 있습니다.</p><h1 id="failover-test">Failover Test</h1><p>자, Failover를 구성 했으니 실제로 Master를 한번 죽여보도록 해보겠습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;master_node_id&gt; <span class="comment"># Redis Master Container를 중지</span></span><br></pre></td></tr></table></figure></p><p><img src="./redis-failover-log.PNG" alt="redis-failover-log"></p><p>맨 처음 로그를 살펴보면 각 sentinel 노드에서 sdown 시그널을 발생시키고 있습니다.</p><p>중간정도 줄을 보면</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+odown master mymaster 192.168.137.101 6379 <span class="comment">#quorum 3/2</span></span><br></pre></td></tr></table></figure></p><p>라는 로그가 나오게 되는데 3개의 sentinel에서 모두 sdown으로 인지하게 되는것입니다.3/2의 뜻은  2개 노드에서 sdown이 발생 했을 때, odown 판정을 내린다는 다수결 투표 숫자입니다.그런데 3개의 노드가 모두 투표를 하여 과반수 이상이 되었으므로 192.168.137.101 6379인 Redis 노드는 odown상태가 되었습니다.</p><p>그 바로 다음 줄 부터 failover 작업이 시작됩니다.위의 예제에서는 6380 포트를 사용하는 redis노드가 새로운 마스터로 선출 되었습니다.따라서 6380 포트를 사용하는 redis노드는 master로 role-change가 되면서 master 노드로써 역할을 수행하게 됩니다.</p><p>이렇게 Redis Sentinel을 이용하여 master node를 감시하며, 장애 상황에 대한 failover를 지원하고 있습니다.</p><h2 id="sdown-vs-odown">sdown vs odown</h2><p>Sentinel에서 down을 판단하는 방법은 <code>sdown</code>과 <code>odown</code>으로 이루어집니다.failover 시 Master가 죽었다는 걸 판단하기 위해서는 <code>다수결의 원칙</code>이 적용됩니다. (그래서 Sentinel노드 갯수를 홀수로 설정하는 이유입니다.)</p><p>먼저, Master가 죽게 되면 Sentinel은 자신이 감시하고 있는 Master가 죽었다고 sdown 시그널을 표현합니다 (<code>Subjective Down</code> 이라 합니다.)sdown은 단지 Master와 Sentinel 자기 자신이 연결이 되지 않음을 의미합니다.</p><p>위에서 보듯이 Master가 죽었으니 다른 Sentinel들도 연결이 끊어졌다고 sdown 시그널을 보냅니다.그렇게 되면 다수결에 원칙에 따라 quorum값 만큼의 sdown이 발생하면 sentinel은 odown 시그널을 보냅니다. (<code>Objective Down</code>이라 합니다.)</p><p>odown은 다수결에 의해서 명시적으로 Master가 Down되었다고 선포하는 것과 같습니다.그렇게 되면 Sentinel들은 다음 Master를 선출하기 위해 남아있는 Slave Redis들에게 투표를 하게 됩니다.다수결의 원칙으로 더 많은 투표수를 받은 Slave가 Master로 선출되게 됩니다.</p><h2 id="중단되었던-6379-포트를-사용하는-redis-노드가-살아나면">중단되었던 6379 포트를 사용하는 Redis 노드가 살아나면?</h2><p>아까 stop했던 container를 다시 살려보겠습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;redis1_node_id&gt;</span><br></pre></td></tr></table></figure></p><p><img src="./redis-failover-3-3748019.PNG" alt="redis-failover-3"></p><p>3번째 줄부터 보시면, sentinel에서 <code>-sdown</code> 로그를 찍어주고 있습니다.sentinel에서 연결되지 않았던 6379번 노드에 대해 정상적으로 커넥션이 맺어지고 있기 때문입니다.중간 줄 부터 보게 되면다른 sentinel 노드에서도 <code>-sdown</code> 로그를 찍어주며 6379번 노드에 대한 부활을 알려주고 있습니다.</p><p>그런 다음에 <code>+convert-to-slave</code> 로그를 보면, 기존의 6379번 노드는 원래 master role을 수행 하던 Redis 노드였습니다.하지만 현재 sentinel에 대한 mymaster는 6380번 노드이기 때문에 6379번 노드는 master role을 수행 할 수 없습니다.</p><p>따라서  <code>+role-change</code> 명령을 통해  기존에 master role -&gt; slave role로 변경되어야 합니다.그리고 현재 master role 권한이 있는 6380번 노드의 slave으로 편입되게 됩니다.redis-cli를 통해 6379번 노드에 접속하여 <code>info replication</code> 명령을 날려보았습니다.</p><p><img src="./redis-failover-4.PNG" alt="redis-failover-4"></p><p>현재 role은 <code>slave</code> 이며, 6380번 노드를 master로 설정하고 있습니다.</p><blockquote><p><strong>왜 기존의 master가 살아나면, slave로 전환하여 사용해야 할까?</strong></p><p>이유는 간단합니다.Redis Master-Slave간 데이터 Replication을 이해 하면 쉽게 이해 할 수 있습니다Redis의 데이터 Replication은 dump.rdb파일을 통해 이루어지는데,master노드 만 dump.rdb파일에 데이터를 write 할 수 있습니다.slave노드에서는 dump.rdb파일을 읽어서 데이터 replication을 하게 되는데,만약 기존의 master의 role이 유지된다면, dump.rdb파일을 조작하여 기존의 master가 다운된 시간 동안들어온 데이터가 삭제될 수 있습니다.그렇게 때문에 데이터 정합성을 위해 기존의 master는 slave로 role이 전환되어야 합니다.</p></blockquote>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/02/2018-12-02-docker-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (6) Docker를 이용한 Redis Cluster 설치하기</title>
      <link>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-6/</link>
      <guid>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-6/</guid>
      <pubDate>Sat, 01 Dec 2018 08:53:04 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;redis-cluster-구성도&quot;&gt;Redis Cluster 구성도&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;./Redis-Cluster-archi.PNG&quot; alt=&quot;Redis-Cluster-archi&quot;&gt;&lt;/p&gt;
&lt;p&gt;간단하게 정리하면.&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="redis-cluster-구성도">Redis Cluster 구성도</h1><p><img src="./Redis-Cluster-archi.PNG" alt="Redis-Cluster-archi"></p><p>간단하게 정리하면.</p><ul><li>각 서버 별로 Redis 3대를 설치. Master 1개, Slave 2개로 구성하여 Replication을 지원할 수 있도록 Cluster를 구성하였습니다.</li><li>각 서버 별로 Sentinel 3대를 설치. 양대비 원리에 맞추어 홀수개로 설정 하였습니다.</li><li>각각의 서버의 Sentinel 3대가 서버의 Master Redis를 감시합니다. (Failover 대기)</li><li>Redis Cluster를 서버 3대에 설치. Data Sharding을 하기 위해 저장소를 3개로 분리하였습니다.</li><li>HAProxy로 분산 처리 구축. 5000, 5002, 5004번 포트는 각 서버의 Master Redis를 바라봅니다.</li><li>5001, 5003, 5005번 포트는 각 서버의 Slave Redis 2대씩 바라봅니다.</li></ul><p>지금부터 Redis Cluster를 어떻게 설치 하였는지 설치 과정에 대해 알아보도록 하겠습니다.</p><h1 id="docker를-이용한-redis-cluster-설치">Docker를 이용한 Redis Cluster 설치</h1><p>Redis-Cluster를 설치하는 순서는 아래와 같습니다. (CentOS 7기준으로 설치 하였습니다.)</p><ul><li>Git 설치 (미리 올려둔 Docker file들을 다운받기 위함)</li><li>Docker 설치</li><li>Docker-Compose 설치</li><li>Docker Build</li></ul><h2 id="git-설치-docker-file-다운로드">Git 설치 + Docker file 다운로드</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git설치</span></span><br><span class="line">yum -y install git</span><br><span class="line">git --version <span class="comment"># git 버전 확인</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#Redis-Cluster 디렉터리 생성</span></span><br><span class="line">mkdir -p /home/redis/redis-cluster</span><br><span class="line"> </span><br><span class="line"><span class="comment">#Redis-Cluster-Home 이동</span></span><br><span class="line"><span class="built_in">cd</span> /home/redis/redis-cluster</span><br><span class="line"> </span><br><span class="line"><span class="comment">#아래 디렉터리들은 각 Redis Container의 외부볼륨으로 설정하기 위해 생성하였습니다.</span></span><br><span class="line"><span class="comment">#==&gt; Container 외부 볼륨을 설정해야 Redis Container가 삭제되더라도 Data가 보존됩니다.</span></span><br><span class="line"><span class="comment">#===&gt; dump.rdb 파일이 생성되는 장소</span></span><br><span class="line">mkdir -p ./redis-data/redis1</span><br><span class="line">mkdir -p ./redis-data/redis2</span><br><span class="line">mkdir -p ./redis-data/redis3</span><br><span class="line"> </span><br><span class="line"><span class="comment">#Docker file Download</span></span><br><span class="line"><span class="comment">#설치파일을 다운받습니다.</span></span><br><span class="line">git init</span><br><span class="line">git remote add origin <span class="string">"https://github.com/jaehun2841/redis-cluster-on-docker.git"</span></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p><h2 id="docker-설치">Docker 설치</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker 설치</span></span><br><span class="line">curl -fsSL https://get.docker.com/ | sh</span><br><span class="line"> </span><br><span class="line"><span class="comment">#docker 설치 후 docker 시작</span></span><br><span class="line">service docker start</span><br></pre></td></tr></table></figure></p><p>Docker를 yum으로도 설치가 가능하지만 버전이 낮아 Docker-compose를 설치 할 수 없습니다.차후에 update까지 필요하니 위 url에서 제공하는 shell script를 실행하여 설치하도록 합니다.<strong>※ 위 Script는 sudo 명령 또는 root 권한을 필요로 합니다.</strong></p><p>Docker 설치 내용은 2장에서 기술한 내용을 참고하시길 바랍니다.</p><h2 id="docker-compose-설치">Docker-Compose 설치</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker 공식 github에서 다운로드</span></span><br><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></p><p>Docker-Compose 설치 내용은 4장에서 기술한 내용을 참고하시길 바랍니다.</p><h2 id="docker-build">Docker build</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cluster home 이동</span></span><br><span class="line"><span class="built_in">cd</span> /home/redis/redis-cluster</span><br><span class="line"> </span><br><span class="line"><span class="comment">#docker build</span></span><br><span class="line">docker-compose -f conf/docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure></p><ul><li>-f 옵션으로 docker-compose.yml 파일을 설정합니다.(docker-compose.yml 파일은 github redis-cluster 설치파일을 받을때 다운 받았습니다. )</li><li>up 명령으로 docker container를 실행합니다.</li><li>--build 옵션으로 build후 container를 실행합니다.</li><li>-d 옵션으로 background로 실행되도록 합니다.(-d 옵션을 빼면 redis의 로그가....나오며 exit하는 순간 container가 stop됩니다.)</li></ul><h1 id="redis-cluster를-빌드하기-위한-docker-composeyml-파일">Redis Cluster를 빌드하기 위한 docker-compose.yml 파일</h1><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-master:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="attr">redis:5.0-alpine</span>   <span class="comment"># image 옵션으로 redis공식이미지를 기반으로 생성합니다.</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span>             <span class="comment"># build file에 대한 context를 지정</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span>  <span class="comment">#dockerfile명을 지정합니다. (Default는 "Dockerfile" 파일명을 가진 파일을 실행합니다.)</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">"host"</span>      <span class="comment"># Image가 Container가 되었을때 network모드를 host모드로 설정합니다 (docker0 인터페이스를 사용하지 않고 Host OS의 eth0 인터페이스 사용)</span></span><br><span class="line">     <span class="attr">environment:</span>              <span class="comment"># Container 내부에서 사용 할 환경변수를 설정합니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=</span></span><br><span class="line">     <span class="attr">volumes:</span>  <span class="comment"># Host OS의 디렉터리와 Container내의 디렉터리와 연동합니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"../redis-data/redis1:/data"</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-slave1:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="attr">redis:5.0-alpine</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"../redis-data/redis2:/data"</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-slave2:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="attr">redis:5.0-alpine</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6381</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span> </span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"../redis-data/redis3:/data"</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Redis Container의 Network모드가 Host인 이유</strong>Redis 공식 홈페이지의 cluster-tutorial에서 발췌한 내용입니다.</p><blockquote><p>Redis Cluster and Docker</p><p>Currently Redis Cluster does not support NATted environments and in general environments where IP addresses or TCP ports are remapped.Docker uses a technique called port mapping: programs running inside Docker containers may be exposed with a different port compared to the one the program believes to be using.This is useful in order to run multiple containers using the same ports, at the same time, in the same server.<code>In order to make Docker compatible with Redis Cluster you need to use the host networking mode of Docker.</code> Please check the --net=host option in the Docker documentation for more information.</p></blockquote><p>Redis Cluster에서는 NAT환경과 IP주소 또는 TCP포트가 재 매핑되는 환경을 지원하지 않는다고 합니다.따라서 Docker에서 Redis Cluster를 호환되게 하기 위해서는 Host 모드로 사용할 것을 권고하고 있습니다.</p></blockquote><h1 id="redis-container-생성을-위한-dockerfile-작성">Redis Container 생성을 위한 Dockerfile 작성</h1><p>Docker-Compose build를 사용하면서 Dockerfile에는 Redis Container를 구성하는 공통적인 로직을 담았습니다.주로 내부에서 file을 생성하거나 Host OS의 파일을 Container가 생성하는 시점에 복사하기 위한 로직이 주로 들어있습니다.그리고 접근권한이 막혀 파일이 실행되지 않는 문제를 해결하기 위해 접근권한을 변경하였습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FROM redis:5.0-alpine //redis 이미지를 기반으로 빌드됨을 의미합니다.</span><br><span class="line"> </span><br><span class="line">MAINTAINER Carrey (jaehun2841@gmail.com)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Copy Redis File</span></span><br><span class="line"><span class="comment"># 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 합니다.</span></span><br><span class="line"><span class="comment"># 기존의 docker-entryporint.sh 파일을 삭제합니다.</span></span><br><span class="line">RUN rm -rf /usr/<span class="built_in">local</span>/bin/docker-entrypoint.sh  </span><br><span class="line"><span class="comment"># 공통적으로 적용할 redis.conf 파일을 복사합니다.</span></span><br><span class="line">ADD redis.conf /usr/<span class="built_in">local</span>/bin/redis.conf    </span><br><span class="line"><span class="comment"># Container가 생성, 시작하는 시점에 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.</span></span><br><span class="line">ADD docker-entrypoint.sh /usr/<span class="built_in">local</span>/bin        </span><br><span class="line"> </span><br><span class="line"><span class="comment">## change access authority</span></span><br><span class="line">RUN chmod 755 /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">RUN chmod 755 /usr/<span class="built_in">local</span>/bin/docker-entrypoint.sh</span><br><span class="line"> </span><br><span class="line">RUN chown redis:redis /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">RUN chown redis:redis /usr/<span class="built_in">local</span>/bin/docker-entrypoint.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#Redis Container에 대한 Port를 지정합니다. (내부포트이며 외부노출은 안됨)</span></span><br><span class="line">EXPOSE <span class="variable">$CLIENTPORT</span> <span class="comment">#CLIENTPORT에 대한 값은 docker-compose.yml에 정의되어 있습니다.          </span></span><br><span class="line"><span class="comment"># Container가 생성, 시작하는 시점에 실행됩니다.</span></span><br><span class="line">ENTRYPOINT [<span class="string">"/usr/local/bin/docker-entrypoint.sh"</span>] </span><br><span class="line"><span class="comment"># Container 빌드가 완료되고 Redis Server를 실행시킵니다.</span></span><br><span class="line">CMD [ <span class="string">"redis-server"</span>,<span class="string">"/usr/local/bin/redis.conf"</span> ]</span><br></pre></td></tr></table></figure></p><h1 id="redis-cluster-설정">Redis Cluster 설정</h1><p>Redis Cluster에 대한 Replication 설정에 대해 알아보겠습니다.</p><p>설정 방법은 redis.conf 파일을 각 Container로 복사하여 공통적인 설정을 하였습니다.각 redis.conf 파일에 대한 변경사항은 <code>docker-entrypoint.sh</code> 파일을 통해 redis.conf 파일 정보를 replace하였습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"> </span><br><span class="line"><span class="comment">## from redis-5.0</span></span><br><span class="line"><span class="comment"># Redis서버에 접근가능한 Host를 설정합니다.</span></span><br><span class="line">sed -i <span class="string">"s/bind 127.0.0.1/bind <span class="variable">$CLIENTHOST</span> 127.0.0.1/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">### redis port inside redis.conf</span></span><br><span class="line"><span class="comment">#redis.conf 파일의 port 6379 문자열을 port $CLINETPORT로 변경합니다. </span></span><br><span class="line"><span class="comment">#($CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.)</span></span><br><span class="line">sed -i <span class="string">"s/port 6379/port <span class="variable">$CLIENTPORT</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf </span><br><span class="line"></span><br><span class="line"><span class="comment"># requirepass foobared 문자열을 requirepass $REQUIREPASS로 변경하였습니다. </span></span><br><span class="line"><span class="comment">#(Redis 접속 시 비밀번호를 설정하였습니다.)</span></span><br><span class="line">sed -i <span class="string">"s/# requirepass foobared/requirepass <span class="variable">$REQUIREPASS</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf          </span><br><span class="line">sed -i <span class="string">"s/# masterauth &lt;master-password&gt;/masterauth <span class="variable">$REQUIREPASS</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf   </span><br><span class="line"></span><br><span class="line"><span class="comment">### slaveof &lt;masterip&gt; &lt;masterport&gt; =&gt; slaveof $MASTERHOST $MASTERPORT</span></span><br><span class="line"><span class="comment"># $MASTERPORT가 공백이 아닌 Container에 대해 slaveof 설정을 통해 Master-Slave 설정을 합니다.</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$MASTERPORT</span>"</span> != <span class="string">""</span> ];<span class="keyword">then</span></span><br><span class="line">    sed -i <span class="string">"s/# slaveof &lt;masterip&gt; &lt;masterport&gt;/slaveof <span class="variable">$MASTERHOST</span> <span class="variable">$MASTERPORT</span>/g"</span> /usr/<span class="built_in">local</span>/bin/redis.conf  </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;1#-&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ] || [ <span class="string">"<span class="variable">$&#123;1%.conf&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">set</span> -- redis-server <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'redis-server'</span> -a <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure></p><h1 id="redis-cluster-실행-결과">Redis Cluster 실행 결과</h1><p>Redis.log<img src="./redis-replication-3746317.PNG" alt="redis-replication"></p><p>로그에서 0 clients connected (2 slaves) 라는 로그가 보입니다.Redis에 접속한 클라이언트 수는 0 client이며2개의 slave redis와 연결하고 있습니다.</p><p>중간부분 로그에서 로그를 보면 slave로 설정한 Redis와 연동이 되는 것을 확인 할 수 있습니다.</p><p>redis-cli &gt; info replication<img src="./redis-replication2-3746337.PNG" alt="redis-replication2"></p><p>redis-cli에서 info replication 명령을 실행하였을 때, 조회되는 내용입니다.slave0, slave1에 대한 참조를 가지고 있는 것을 확인 할 수 있습니다.</p><h1 id="참고">참고</h1><ul><li>https://redis.io/topics/cluster-tutorial</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (5) Docker Network구조</title>
      <link>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-5/</link>
      <guid>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-5/</guid>
      <pubDate>Sat, 01 Dec 2018 08:25:03 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;docker-network-모드&quot;&gt;Docker Network 모드&lt;/h1&gt;
&lt;p&gt;Docker에서 제공하는 Network 모드는 총 4개 입니다.
(추가적으로 2개의 모드가 더 있습니다. Overlay, Macvlan 모드가 있지만 Doc
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="docker-network-모드">Docker Network 모드</h1><p>Docker에서 제공하는 Network 모드는 총 4개 입니다.(추가적으로 2개의 모드가 더 있습니다. Overlay, Macvlan 모드가 있지만 Docker Swarm과 관련된 내용이므로 이번 장에서는 기술 하지 않겠습니다.)</p><ul><li>Bridge 모드</li><li>Container 모드 (이것도 Bridge 모드의 일종)</li><li>Host 모드</li><li>none 모드</li></ul><p>이번 장에서는 위 Network 모드에 대해 알아보도록 하겠습니다.</p><h1 id="bridge-모드">Bridge 모드</h1><p>Docker에서 network 설정을 별도로 하지 않으면 Default로 작용하는 모드입니다.Docker가 설치되면 docker0라는 네트워크 인터페이스가 생성됩니다. (Virtual Interface)</p><p><img src="./docker-bridge-mode.png" alt="docker-bridge-mode"></p><p>위는 docker0 인터페이스를 바탕으로 각 Container와 Bridge 형식으로 엮어진 모습입니다.</p><p><img src="./docker-bridge-2.PNG" alt="docker-bridge-2"></p><p>Host OS에서 network interface를 검색해 보면 docker0라는 virtual interface를 확인할 수 있습니다.</p><blockquote><p><strong>docker0 interface의 특징</strong></p><ul><li>IP는 자동으로 172.17.0.1로 설정</li><li>IP는 DHCP로 할당받는 것이 아닌 Docker 내부로직에 의해 결정</li><li>docker0는 virtual ethernet bridge</li><li>L2 통신 기반</li></ul></blockquote><p><code>&quot;docker bridge 모드는 같은 host 내에서만 사용 가능하다.&quot;</code> 라는 제약이 있다.즉, 다른 host(다른서버)와의 docker와는 통신이 불가능합니다.왜냐하면 다른 서버가 docker0 인터페이스의 외부에 있기 때문에 그렇습니다.</p><h1 id="docker0-interface와-container의-연결-방식">docker0 interface와 Container의 연결 방식</h1><p><img src="./docker0-interface.PNG" alt="docker0-interface"></p><p>위 이미지를 보면, 현재 Docker를 이용하여 redis와 nginx를 설치한 상태입니다.두 번째 명령을 보면 brctl명령으로 docker0 interface에 연결된 interfaces가 2개 보입니다.</p><ul><li>veth062947b</li><li>veth3b5bdll</li></ul><p>container 2개가 bridge 방식으로 연결 되어 있기 때문에 veth~하는 interface가 생성되어있습니다.위에 그림에서 보듯이 veth와 각 container 내부의 eth0 interface와 연결되어 있습니다.</p><p><img src="./ip.PNG" alt="ip"></p><p>Redis Container에 대해 docker inspect 명령을 날려보았습니다.네트워크 설정 부분이 아래에 나오는데 Network 부분을 보시면 Gateway는 172.17.0.1이라 되어 있습니다.이 ip 주소는 docker0 interface의 ip주소입니다.따라서 docker0의 bridge로 연결되어 172.17.0.2라는 내부 ip를 가진 Container로 생성된 것입니다.</p><h1 id="container-모드-이것도-bridge-모드의-일부">Container 모드 (이것도 Bridge 모드의 일부)</h1><p>Container 모드는 다른 Container의 네트워크 리소스를 같이 쓰는? 개념입니다.</p><p>먼저 httpd를 설치하고..그다음에 redis를 설치하여 httpd의 container 정보를 가지고 net설정을 해주었습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d httpd</span><br><span class="line">docker run -d --net=container:(httpd의 containerId) redis</span><br></pre></td></tr></table></figure></p><p><img src="./httpd.PNG" alt="httpd"></p><p>위 이미지(httpd에 대한 정보)를 보면 docker0 interface를 이용하고 bridge 모드로 설정되어 있습니다.</p><p><img src="./redis1.PNG" alt="redis1"></p><p>하지만, Redis의 Network 정보를 보면 텅텅 비어있습니다.이는 docker0 interface를 통해 네트워크 설정이 bind 되지 않았다는 의미입니다.</p><p>약간 위로 올려보면</p><p><img src="./redis2.PNG" alt="redis2"></p><p>NetworkMode에 httpd의 container 자원을 사용하여 접근하는 것을 알 수 있습니다.다른 docker image 중 내부 명령어로 ip addr을 지원하는 image가 있다면</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> &lt;container ID&gt; ip addr show</span><br></pre></td></tr></table></figure></p><p>위 명령을 통해 Mac Address가 Container자원을 할당한 Container의 Mac Address와 같음을 알 수 있습니다.</p><h1 id="host-모드">Host 모드</h1><p>Host 모드는 docker0 interface를 사용하지 않고 Host OS의 네트워크 자원을 사용합니다.bridge 형식으로 사용하지 않기 때문에 brctl show docker0 명령으로 검색해도 interfaces에 나타나지 않습니다.<strong>Bridge를 쓰지 않기 때문에 Container에서 <code>Port를 노출하지 않는 경우 사용할 수가 없는 점</code>을 유의 해야 합니다.</strong>(Redis Cluster를 구성 할 때에도 Redis에서는 Cluster모드 구현 시, docker bridge mode를 지원하지 않기 때문에 host로 설정했었습니다.)</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=host -p <span class="string">"6515"</span> <span class="comment">#이렇게 옵션을 추가해주면 됩니다. (port는 문자열로!)</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#또는 docker-compose.yml 파일에서</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">  network_mode:</span> <span class="string">host</span> <span class="comment">#이 처럼 표기하시면 됩니다.</span></span><br></pre></td></tr></table></figure></p><h1 id="none-모드">none 모드</h1><p>--net=none 옵션으로 Container 생성 시, 격리된 네트워크 영역을 갖기는 하지만 network 인터페이스가 없는 Container가 생성 됩니다.</p><p>아래의 코드로 테스트를 해보았습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=none -d httpd</span><br><span class="line">docker <span class="built_in">exec</span> httpd ip addr show</span><br></pre></td></tr></table></figure></p><p><img src="./none.PNG" alt="none"></p><p>검색되는 내부 네트워크 인터페이스가 없습니다.</p><blockquote><p><strong>none으로 처리하는 이유</strong>network mode를 none으로 하는 경우는 보통 사용자 정의 interface를 사용할 때 입니다.network 환경을 깔끔하게 만든 다음에 사용자 정의 interface를 적용하기 위함입니다.</p></blockquote><h1 id="참고">참고</h1><ul><li>http://bluese05.tistory.com/38</li><li>https://docs.docker.com/network/network-tutorial-standalone/#use-the-default-bridge-network</li><li>https://docs.docker.com/network/network-tutorial-host/</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (4) Docker-Compose 설치 및 사용방법</title>
      <link>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-4/</link>
      <guid>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-4/</guid>
      <pubDate>Sat, 01 Dec 2018 07:44:03 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;docker-compose-이란&quot;&gt;Docker-Compose 이란?&lt;/h1&gt;
&lt;p&gt;기존에는 Docker를 이용해서 1개의 이미지를 바탕으로 하나의 소프트웨어에 대한 컨테이너를 만들 수 있었습니다.
하지만 목표는 Web Server도 설치
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="docker-compose-이란">Docker-Compose 이란?</h1><p>기존에는 Docker를 이용해서 1개의 이미지를 바탕으로 하나의 소프트웨어에 대한 컨테이너를 만들 수 있었습니다.하지만 목표는 Web Server도 설치하고, DB도 설치하고, IDE도 설치해서 한 세트로 배포를 해주고 싶은데... 지금까지 배운 방법으로는 Docker image를 내가 필요한 것만큼 다운받아서 Container를 생성해야 합니다.</p><p>이때 필요한 개념이 Docker-Compose입니다.Docker-Compose는 사용자에게 한번에 여러가지 소프트웨어에 대한 이미지 정보를 담아 빌드 할 수 있습니다.사용자는 Docker-Compose로 만든 파일을 다운받아 이미지 내에 포함된 소프트웨어에 대한 Container를 한번에 만들 수 있습니다.</p><h1 id="docker-compose-설치">Docker-Compose 설치</h1><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker 공식 github에서 다운로드</span></span><br><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></p><p>다운로드 받은 docker-compose 파일을 실행 가능한 파일로 만듭니다.(보통의 리눅스 실행파일 path는 <code>/usr/local/bin</code>입니다. <strong>OS별로 다를 수 있습니다.</strong>)</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></p><h1 id="docker-composeyml">Docker-compose.yml</h1><p>Docker-compose.yml 파일은 생성하고자 하는 Container들의 image 정보들을 담고 있는 설정 파일입니다.여기에 설치하고자 하는 소프트웨어들의 빌드정보를 지정 할 수 있습니다.또한 Docker에서 사용한 설정정보를 기술 할 수 있어 사용자는 파일을 받아 별도의 옵션 없이 Container만 생성하면 됩니다.</p><h1 id="docker-composeyml에서-자주-사용하는-options">Docker-Compose.yml에서 자주 사용하는 options</h1><h2 id="build">build</h2><p>build는 해당 이미지가 빌드 될 때 사용 할 Dockerfile을 지정할 수 있는 options입니다.</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1:</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">redis:5.0-alpine</span></span><br><span class="line"><span class="attr">     build:</span></span><br><span class="line"><span class="attr">       context:</span> <span class="string">..</span></span><br><span class="line"><span class="attr">       dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">       args:</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">buildno</span> <span class="string">:</span> <span class="number">1</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">username</span> <span class="string">:</span> <span class="string">carrey</span></span><br></pre></td></tr></table></figure></p><ul><li><p>context : dockerfile의 위치를 지정합니다. Default는 현재위치 (./) 입니다.</p></li><li><p>dockerfile : dockerfile명을 지정합니다 Default는 Dockerfile 입니다.</p></li><li><p>args : Dockerfile내에서 사용할 Arguments를 설정합니다.</p></li></ul><h2 id="command">command</h2><p>command는 Dockerfile에서 CMD역할을 했던 명령을 <code>Override</code>합니다.(Dockerfile과 같이 사용하는 경우 Dockerfile의 CMD명령이 아닌 <code>Docker-compose의 command명령이 실행</code>)</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1:</span></span><br><span class="line">  <span class="string">command</span> <span class="string">:</span> <span class="string">startup.sh</span> <span class="bullet">-p</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure></p><h2 id="depends_on">depends_on</h2><p>Docker-compose 내의 이미지가 2개 이상인 경우 실행 의존성을 줄 수 있습니다.예를들어 DB가 먼저 실행된 다음에 WAS가 실행되어야 하는 경우 Docker-Compose에서는 depend_on 설정에 따라 다른 이미지를 먼저 빌드 합니다.</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    depends_on:</span> <span class="string">//web</span> <span class="string">이미지에</span> <span class="string">대한</span> <span class="string">Container는</span> <span class="string">redis와</span> <span class="string">db가</span> <span class="string">생성되고</span> <span class="string">시작되기</span> <span class="string">전에는</span> <span class="string">빌드되지</span> <span class="string">않습니다.</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">db</span>       </span><br><span class="line"><span class="bullet">      -</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure></p><h2 id="entrypoint">entrypoint</h2><p>Container가 run 또는 start 시, entrypoint 로직을 실행 합니다.entrypoint와 Dockerfile이 함께 사용되는 경우, <code>Dockerfile의 ENTRYPOINT설정은 무시됩니다.</code></p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">redis1</span> <span class="string">:</span> </span><br><span class="line"><span class="attr">image:</span> <span class="attr">redis:5.0-alpine</span></span><br><span class="line"><span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure></p><h2 id="env_file">env_file</h2><p>Env 파일을 Container 내부에 import 하는 경우에 사용합니다.</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ubuntu:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line">    <span class="string">env_file</span> <span class="string">:</span> <span class="string">../env/environments.env</span></span><br></pre></td></tr></table></figure></p><h2 id="environment">environment</h2><p>Container 내부에서 사용할 환경 변수를 등록합니다.</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1:</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REQUIREPASS=1234</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTHOST=192.168.130.93</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">CLIENTPORT=6380</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERHOST=192.168.130.93</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MASTERPORT=6379</span></span><br></pre></td></tr></table></figure></p><h2 id="expose">expose</h2><p>Container내의 내부 포트만 설정 (외부 노출은되지 않습니다.)link된 Container끼리는 expose에 설정된 포트로 통신이 가능</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line"><span class="attr">expose:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"3000"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"8000"</span></span><br></pre></td></tr></table></figure></p><h2 id="ports">ports</h2><p>Host OS 포트와 Container 내부포트 매핑 (포트포워딩)Host OS 포트를 사용할 수 있으므로 외부접속이 가능</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tomcat:</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"80:8080"</span>  <span class="comment"># &lt;Host OS포트&gt; : &lt;컨테이너 내부포트&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">#Short Syntax --&gt; 권장하는 방식</span></span><br><span class="line"><span class="attr">ubuntu:</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"3000"</span>        <span class="comment">#이 구문은 "3000:3000" 과 동일</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"3000-3005"</span>   <span class="comment">#이 구문은 "3000-3005:3000-3005"와 동일</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"8000:8000"</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"9090-9091:8080-8081"</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"49100:22"</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"127.0.0.1:8001:8001"</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"127.0.0.1:5000-5010:5000-5010"</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"6060:6060/udp"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#Long Syntax --&gt; 권장하지 않는 방식</span></span><br><span class="line"><span class="attr">tomcat2:</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">target</span> <span class="string">:</span> <span class="number">8080</span> <span class="comment">#Container 내부포트</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">published</span> <span class="string">:</span> <span class="number">80</span> <span class="comment"># 외부 OS 포트</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">protocol</span> <span class="string">:</span> <span class="string">tcp</span> <span class="comment"># tcp 또는 udp</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">mode</span> <span class="string">:</span> <span class="string">host</span> <span class="comment">#host: 각각의 Container 노드와 1:1로 매핑</span></span><br></pre></td></tr></table></figure></p><blockquote><p>포트 매핑 시 주의 할 점Host : Container 형식으로 포트를 매핑하면 YAML이 xx:yy 형식은 구문 분석시에 default를 60으로 주기 때문에 60번 이하 포트에 대해서 잘못된 결과가 초래될 수 있음.(8000 : 22 와 같이 숫자만 적는 경우 문제가 발생)따라서, <code>포트 매핑은 항상 문자열로 적어야 합니다.</code>( &quot;8000 : 22&quot;와 같이 문자열로 선언해야 안전합니다. ) ==&gt; 60번 이하 포트를 쓰지말라는 소리가 아님.</p></blockquote><h2 id="image">image</h2><p>어떤 image를 바탕으로 생성할 것인지 지정합니다.</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span> </span><br><span class="line"><span class="attr">      image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">ubuntu:</span> </span><br><span class="line"><span class="attr">      image:</span> <span class="attr">ubuntu:14.04</span></span><br></pre></td></tr></table></figure></p><h2 id="link">link</h2><ul><li>다른 Container와 연결하기 위해 설정합니다.</li><li>외부 Port노출이 안되어도 Expose명령으로 노출된 Port로 연결</li><li>network_mode가 <code>host인 경우 사용할 수 없습니다.</code> (host인 경우 Host OS의 port를 직접 사용하기 때문)</li><li>서비스 이름:Alias 형태로 선언하거나 서비스 이름만 지정합니다.</li></ul><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line"><span class="attr">  link:</span></span><br><span class="line"><span class="attr">    - db:</span><span class="string">mycontainerdb-alias</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">db:</span> </span><br><span class="line"><span class="attr">  image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">redis:</span> </span><br><span class="line"><span class="attr">  image:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure></p><h2 id="network_mode">network_mode</h2><p>Docker network policy 설정 (다음 장에 상세 설명하겠습니다.)</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">"bridge"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"none"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"service:[service name]"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"container:[container name/id]"</span></span><br></pre></td></tr></table></figure></p><blockquote><p>Docker Swarm을 사용하는 경우 network_mode 옵션은 무시됩니다.</p></blockquote><h2 id="volumes">volumes</h2><ul><li>Host OS의 디렉터리 경로를 Container 내부의 디렉터리에 Mount 합니다. (쉽게 말해서 디렉토리가 연동됩니다.)</li><li>docker run -v 또는 --volume과 같습니다.</li><li>Dockerfile의 VOLUME[] 과 같습니다.</li><li>docker-compose.yml의 volumes에는 상대경로를 지정할 수 있습니다.</li><li>호스트:컨테이너:권한 순으로 작성하여 읽기/쓰기 권한 설정을 할 수 있습니다. (Default는 rw)<ul><li>ro : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수만 있음. Container에서 파일에 대한 수정이 불가능합니다.</li><li>rw : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수 있고, Container에서 파일 수정이 가능하고, Host OS 디렉토리에 반영이 됩니다.</li></ul></li></ul><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span> </span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">/usr/local/redis/data:/data</span> <span class="comment"># &lt;Host OS 디렉터리 경로&gt; : &lt;Container 내부 data 경로&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">/usr/local/redis/data:/data:ro</span> <span class="comment">#ReadOnly </span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">/usr/local/redis/data:/data:rw</span> <span class="comment">#ReadWrite</span></span><br></pre></td></tr></table></figure></p><h2 id="restart">restart</h2><p>Container 재 시작에 대한 policy를 설정합니다.</p><ul><li>no : 문제가 발생하여 Container가 중지된 경우 재시작 하지 않음 (default)</li><li>always : 어떠한 문제로 Container가 중지되는 경우 무조건 재시작</li><li>on-failure : Container의 exit code 0 이 아닌 경우 재시작</li><li>unless-stopped : 명시적으로 중지되거나, Docker 자체가 중지되는 경우 재시작</li></ul><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="literal">no</span>            </span><br><span class="line"><span class="attr">restart:</span> <span class="string">always</span>          </span><br><span class="line"><span class="attr">restart:</span> <span class="string">on-failure</span>      </span><br><span class="line"><span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>https://docs.docker.com/compose/compose-file/</li><li>http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/</li><li>https://www.joinc.co.kr/w/man/12/docker/Guide/DataWithContainer</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker기반 Redis 구축하기 - (3) Dockerfile</title>
      <link>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-3/</link>
      <guid>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-3/</guid>
      <pubDate>Sat, 01 Dec 2018 06:44:03 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;dockerfile-이란&quot;&gt;Dockerfile 이란?&lt;/h1&gt;
&lt;p&gt;이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="dockerfile-이란">Dockerfile 이란?</h1><p>이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소프트웨어에 대한 공식이미지도 있지만, Docker Hub 사용자들이 공식이미지를 바탕으로 커스터마이징하여 배포한 이미지도 등록되어 있습니다.</p><p>어떻게 이미지를 빌드하고 배포 할 수 있었을까요? <strong>Dockerfile을 이용한 이미지 빌드를 이용하면 가능합니다.</strong></p><p>Dockerfile은 이미지를 바탕으로 몇가지 명령을 실행 할 수 있는 로직을 담은 파일입니다.Dockerfile을 통해 더 유연하게 이미지에 대한 설정을 변경할 수 있고, 그 설정을 이미지에 담아 배포 할 수 있습니다.</p><p>물론 Docker run 구문에서 options을 사용하여 같은 기능을 하도록 구현 할 수 있지만, Dockerfile로 작성하게 되면 향후 유지보수가 쉬워지고 run 구문에 대한 options을 전부 기억하지 않아도 되는 장점이 있습니다.</p><p>이번 장에서는 Dockerfile을 작성하는 명령어를 위주로 알아보겠으며, 간단한 예제 Dockerfile을 보도록 하겠습니다.</p><h1 id="dockerfile-사용방법">Dockerfile 사용방법</h1><p>Dockerfile을 이용한 docker build</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dockerfile이 위치한 directory의 dockerfile을 가지고 build합니다.</span></span><br><span class="line">docker build -f /path/to/dockerfile</span><br></pre></td></tr></table></figure></p><h1 id="dockerfile을-구성하는-핵심-명령어">Dockerfile을 구성하는 핵심 명령어</h1><h2 id="from-dockerfile의-시작">From - Dockerfile의 시작</h2><p>From 명령어는 어떤 이미지를 바탕으로 container를 빌드 할 것인지 명시합니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis:5.0-alpine 이미지를 바탕으로 빌드</span></span><br><span class="line">From redis:5.0-alpine</span><br></pre></td></tr></table></figure></p><h2 id="cmd-dockerfile의-끝">CMD - Dockerfile의 끝</h2><ul><li>CMD명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li><li>보통은 해당 프로그램을 실행시키는 명령을 사용합니다. ( ex&gt; startup.sh)</li><li>CMD 명령은 Dockerfile에서 <code>단 한번만 사용</code>할 수 있습니다.</li></ul><p>명령어 예제</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 일반적인 실행 방법</span></span><br><span class="line">CMD [<span class="string">"execute.sh"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># Entrypoint 실행을 위한 Default Parameter - Entrypoint를 위한 파라미터를 제공</span></span><br><span class="line">CMD [<span class="string">"param1"</span>, <span class="string">"param2"</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># shell form</span></span><br><span class="line">CMD execute.sh param1 param2</span><br></pre></td></tr></table></figure></p><blockquote><p>CMD 구문 사용 시, 주의사항!</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker build -f ./dockerfile <span class="built_in">test</span></span><br><span class="line">&gt; <span class="comment"># Container 생성 시, docker run [이미지] [실행파일 또는 명령] 입니다.</span></span><br><span class="line">&gt; docker run <span class="built_in">test</span> <span class="built_in">echo</span> <span class="string">"test!"</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>위 예시 처럼 run 명령 시, 이미지 명 뒤에 <code>실행파일이나 명령어</code>가 오게되면 CMD에 설정된 명령은 <code>무시</code>되고 docker run 구문에서 사용된 명령이 <strong>CMD 대신 실행</strong>됩니다.</p></blockquote><h2 id="entrypoint">ENTRYPOINT</h2><ul><li>ENTRYPOINT명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li><li>보통 스크립트를 실행하거나, 실행명령을 수행하게 됩니다.</li><li>ENTRYPOINT명령은 Dockerfile에서 <code>단 한번만 사용가능</code> 합니다.</li><li>기본적으로 FROM에서 설정한 이미지의 /bin/sh 파일을 기반으로 실행되며, 이미지에 /bin/sh 파일이 없는 경우 실행이 불가능 합니다.</li></ul><p>ENTRYPOINT 사용 예시<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">"docker-entrypoint.sh"</span>]</span><br><span class="line">ENTRYPOINT [<span class="string">"docker-entrypoint.sh"</span>, <span class="string">"--param1=true"</span>, <span class="string">"--param2=1"</span>]</span><br></pre></td></tr></table></figure></p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#run 명령의 options으로 구현한 방식</span></span><br><span class="line"><span class="comment">#이러한 방식으로도 사용할 수 있지만, 추천하지 않는 안티패턴입니다.</span></span><br><span class="line">docker run --entrypoint=<span class="string">"docker-entrypoint.sh"</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><h1 id="dockerfile에서-자주-사용하는-명령어">Dockerfile에서 자주 사용하는 명령어</h1><h2 id="add-파일을-container에-추가">ADD - 파일을 Container에 추가</h2><ul><li>Container 내부에 Host OS의 파일을 추가하려고 할 때 사용합니다.</li><li>ADD &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li><li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li><li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li><li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li><li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li><li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀어서 Container에 추가됩니다.(Container에 압축 해제 된 파일들이 추가됨)</li><li>인터넷에 있는 파일 URL은 압축만 해제된 뒤, tar파일만 추가됩니다.</li><li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li><li>ADD로 추가되는 파일은 root root 기존 권한을 따릅니다 (단, URL로 추가된 파일의 경우 600)</li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADD ../file.sh /home/file.sh (x) <span class="comment">#상위 디렉터리 사용x</span></span><br><span class="line">ADD /home/user/file.sh /home/file.sh(x) <span class="comment">#절대경로 사용x</span></span><br><span class="line">ADD file.sh ../../file.sh (x) <span class="comment">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class="line"> </span><br><span class="line">ADD file.sh /home/file.sh (O) <span class="comment">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class="line">ADD *.sh /home (O) <span class="comment"># 와일드카드를 이용하여 복사 가능</span></span><br><span class="line">ADD compress.tar.gz / <span class="comment"># Container / 경로에 compress.tar파일의 풀어진 형태로 파일 추가</span></span><br><span class="line">ADD http://file.co.kr/file/1234.tar.gz / <span class="comment"># Container 내부의 / 경로에 1234.tar.gz 파일 추가</span></span><br></pre></td></tr></table></figure></p><h2 id="copy-파일을-container로-복사">COPY - 파일을 Container로 복사</h2><ul><li>ADD의 기능과 거의 유사합니다.</li><li>COPY &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li><li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li><li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li><li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li><li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li><li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀지않고 그대로 복사됩니다. <strong>(ADD와 차이점)</strong></li><li>인터넷에 있는 파일 URL은 사용 불가. <strong>(ADD와 차이점)</strong></li><li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li><li>COPY로 추가되는 파일은 root root 기존 권한을 따릅니다</li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">COPY ../file.sh /home/file.sh (x) <span class="comment">#상위 디렉터리 사용x</span></span><br><span class="line">COPY /home/user/file.sh /home/file.sh(x) <span class="comment">#절대경로 사용x</span></span><br><span class="line">COPY file.sh ../../file.sh (x) <span class="comment">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class="line"> </span><br><span class="line">COPY file.sh /home/file.sh (O) <span class="comment">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class="line">COPY *.sh /home (O) <span class="comment"># 와일드카드를 이용하여 복사 가능</span></span><br><span class="line">COPY compress.tar.gz / (O)<span class="comment"># Container / 경로에 compress.tar파일이 복사</span></span><br><span class="line">COPY http://file.co.kr/file/1234.tar.gz / (X) <span class="comment"># COPY는 인터넷 파일URL 사용 불가</span></span><br></pre></td></tr></table></figure></p><h2 id="run-container-내부에서-명령-실행">RUN - Container 내부에서 명령 실행</h2><ul><li>기본적으로 /bin/sh 파일로 실행됩니다.</li><li>Window의 경우 cmd 기반 명령을 수행합니다.</li></ul><p>Dockerfile 내 RUN 명령어 사용법<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># software 설치 명령 실행 (예시의 경우 yum이 Container내부에 설치되어야 합니다.)</span></span><br><span class="line">RUN yum -y install software  </span><br><span class="line"><span class="comment"># /usr/local/redis directory 생성</span></span><br><span class="line">RUN mkdir -p /usr/<span class="built_in">local</span>/redis </span><br><span class="line"><span class="comment"># execute.sh 파일 실행 </span></span><br><span class="line">RUN [<span class="string">"execute.sh"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]</span><br></pre></td></tr></table></figure></p><p>명령어의 길이가 긴 경우 \ 문자를 사용하여 append 가능합니다</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN yum -y install software \</span><br><span class="line">         <span class="built_in">echo</span> <span class="string">"install software"</span> \</span><br><span class="line">         mkdir -p /usr/<span class="built_in">local</span>/redis</span><br></pre></td></tr></table></figure></p><h2 id="env-container-내부에서-사용할-환경-변수-추가">ENV - Container 내부에서 사용할 환경 변수 추가</h2><p>Container는 Host OS와 독립된 공간이기 때문에 Container 내부에서 사용 할 환경변수를 추가할 수 있습니다.</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV LOCAL_PORT 80</span><br><span class="line">ENV REDIS_HOME /usr/<span class="built_in">local</span>/bin/redis</span><br></pre></td></tr></table></figure></p><h2 id="expose-container의-port-설정">EXPOSE - Container의 Port 설정</h2><ul><li>Host OS - Container와 통신할 포트를 설정</li><li>EXPOSE는 Host OS와 연결만 할 뿐 외부에 노출 되지는 않습니다.</li><li>포트를 노출 하기 위해서는 docker run -p 또는 -P 옵션 사용해야 합니다.</li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 80   <span class="comment">#Container 내의 Web Server Port 노출</span></span><br><span class="line">EXPOSE 6379 <span class="comment">#Container 내의 Redis Server Port 노출</span></span><br><span class="line"> </span><br><span class="line">EXPOSE 80 6379 <span class="comment">#포트 여러개 노출</span></span><br></pre></td></tr></table></figure></p><h2 id="volume-외부-볼륨-설정">VOLUME - 외부 볼륨 설정</h2><ul><li>Container 내부의 Directory와 Host OS의 Directory를 동기화 시키는 설정</li><li>log파일이나 설정파일은 보통 Container 내부에만 있는데 이를 Host OS에 동기화 하여 파일에 대한 접근이 가능하게 한다.</li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile volume 설정</span></span><br><span class="line">VOLUME [<span class="string">"/data"</span>, <span class="string">"/var/log"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker run 사용 시, volumn 설정</span></span><br><span class="line"><span class="comment"># -v 옵션을 사용하여 설정 -v &lt;host 디렉터리&gt;:&lt;컨테이너 디렉터리&gt;</span></span><br><span class="line">docker run -v /host/os/data:/container/data app</span><br></pre></td></tr></table></figure></p><h2 id="workdir-container의-work-directory-설정">WORKDIR - Container의 Work Directory 설정</h2><ul><li>RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉터리</li><li>중간에 Directory가 변경되는 경우 바꿀수 있다.</li><li>리눅스의 cd 명령어와 비슷하다.</li></ul><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /usr/<span class="built_in">local</span>/bin</span><br><span class="line">ADD redis.conf /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line"> </span><br><span class="line">WORKDIR /usr/<span class="built_in">local</span></span><br><span class="line">ADD redis.log /usr/<span class="built_in">local</span>/redis.log</span><br><span class="line"></span><br><span class="line">WORKDIR var</span><br><span class="line">WORKDIR lib</span><br><span class="line">RUN touch file.sh <span class="comment"># /var/lib/file.sh 생성</span></span><br></pre></td></tr></table></figure></p><h1 id="참고">참고</h1><ul><li>http://pyrasis.com/book/DockerForTheReallyImpatient</li><li>https://docs.docker.com/engine/reference/builder</li></ul>]]></content:encoded>
      
      <comments>https://jaehun2841.github.io/2018/12/01/2018-12-01-docker-3/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
