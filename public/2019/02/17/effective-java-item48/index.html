<!DOCTYPE html><html lang="lang"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Item 48. 스트림 병렬화는 주의해서 적용하라"><meta name="keywords" content="Effective-Java"><meta name="author" content="Carrey,undefined"><meta name="copyright" content="Carrey"><title>Item 48. 스트림 병렬화는 주의해서 적용하라 | Carrey`s 기술블로그</title><link rel="shortcut icon" href="../../../../my-favicon.ico"><link rel="stylesheet" href="../../../../css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#서론"><span class="toc-number">1.</span> <span class="toc-text">서론</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#파이프라인-병렬화가-불가능-한-경우-성능-개선이-되지-않는다"><span class="toc-number">2.</span> <span class="toc-text">파이프라인 병렬화가 불가능 한 경우 성능 개선이 되지 않는다.</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#언제-병렬화를-사용하나"><span class="toc-number">3.</span> <span class="toc-text">언제 병렬화를 사용하나?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#참조-지역성-locality-of-reference"><span class="toc-number">4.</span> <span class="toc-text">참조 지역성 (Locality of Reference)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#스트림-파이프라인의-종단-연산"><span class="toc-number">5.</span> <span class="toc-text">스트림 파이프라인의 종단 연산</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#병렬화에-대해-잘모르면-안하는게-낫다"><span class="toc-number">6.</span> <span class="toc-text">병렬화에 대해 잘모르면 안하는게 낫다</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stream-명세는-함수-객체에-대한-규약"><span class="toc-number">6.1.</span> <span class="toc-text">Stream 명세는 함수 객체에 대한 규약</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#스트림-병렬화는-오직-성능-최적화-수단임을-기억하라"><span class="toc-number">7.</span> <span class="toc-text">스트림 병렬화는 오직 성능 최적화 수단임을 기억하라</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#스트림-파이프라인-병렬화가-효과적인-예"><span class="toc-number">8.</span> <span class="toc-text">스트림 파이프라인 병렬화가 효과적인 예</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#random한-수의-경우"><span class="toc-number">9.</span> <span class="toc-text">Random한 수의 경우</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#요약"><span class="toc-number">10.</span> <span class="toc-text">요약</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#참고"><span class="toc-number">11.</span> <span class="toc-text">참고</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300"></div><div class="author-info__name text-center">Carrey</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="../../../../archives"><span class="pull-left">Articles</span><span class="pull-right">65</span></a><a class="author-info-articles__tags article-meta" href="../../../../tags"><span class="pull-left">Tags</span><span class="pull-right">14</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container" style="background-image: url(true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="../../../../index.html">Carrey`s 기술블로그</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Item 48. 스트림 병렬화는 주의해서 적용하라</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-02-17</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="서론">서론</h1>
<p>주류 언어 중, 동시성 프로그래밍 측면에서는 항상 자바는 앞서왔다.<br>
처음 릴리즈된 1996년부터 스레드, 동기화, wait/notify를 지원했다.</p>
<ul>
<li>자바 5부터는 동시성 컬렉션인 java.util.concurrent 라이브러리와 실행자(Excutor) 프레임워크를 지원했다.</li>
<li>자바 7부터는 고성능 병렬 분해(parallel decom-position) 프레임워크인 fork-join 패키지를 추가했다.<br>
(Fork-join pool에 대한 설명은 https://okky.kr/article/345720 여기 참고)</li>
<li>자바 8부터는 parallel 메서드만 한 번 호출하면 파이프라인을 병렬 실행할 수 있는 Stream을 지원했다.</li>
</ul>
<p>자바로 동시성 프로그램을 작성하기가 점점 쉬워지고 있지만, 이를 올바르고 빠르게 작성하는 일은 어렵다.<br>
동시성 프로그래밍을 할 때는 안전성(safety)과 응답 가능(liveness) 상태를 유지하기 애써야 한다.<br>
병렬 스트림 파이프라인 프로그래밍에서도 다를 바 없다.</p>
<h1 id="파이프라인-병렬화가-불가능-한-경우-성능-개선이-되지-않는다">파이프라인 병렬화가 불가능 한 경우 성능 개선이 되지 않는다.</h1>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MersenPrimeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        primes().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))</span><br><span class="line">                .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                .limit(<span class="number">20</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"running time : "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        primes().parallel().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))</span><br><span class="line">                .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                .limit(<span class="number">20</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"running time : "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;BigInteger&gt; <span class="title">primes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(TWO, BigInteger::nextProbablePrime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>스트림을 이용한 처음 20개의 메르센 소수를 생성하는 프로그램이다.<br>
이 프로그램을 실행 시켜보니 test1은 8.2초 정도의 수행시간을 보여줬다
test2는 stream의 성능을 향상시켜보고자 parallel()을 호출했다.<br>
하지만 메르센 소수의 값이 프린트 되지 않았고, 강제로 중지 하기 전까지 계속 돌고 있었다.<br>
아무것도 안된 원인은 stream 라이브러리가 이 파이프라인을 병렬화 하는 방법을 찾아내지 못했기 때문이다.</p>
<ul>
<li>데이터 소스가 Stream.iterate인 경우</li>
<li>중간 연산으로 limit()를 사용하는 경우
위 두 가지 경우에는 파이프라인 병렬화로 성능 향상을 기대하기 어렵다.<br>
뿐만 아니라 파이프라인 병렬화는 limit를 다룰 때 <strong>CPU 코어가 남는다면, 원소를 몇 개 더 처리한 후 제한된 개수 이후의 결과를 버려도 아무런 해가 없다고 가정한다.</strong></li>
</ul>
<p>따라서 스트림 파이프라인을 마구잡이로 병렬화 해선 안된다. 성능이 오히려 더 나빠질 수 있다.</p>
<h1 id="언제-병렬화를-사용하나">언제 병렬화를 사용하나?</h1>
<ul>
<li>
<p>ArrayList</p>
</li>
<li>
<p>HashMap</p>
</li>
<li>
<p>HashSet</p>
</li>
<li>
<p>ConcurrentHashMap</p>
</li>
<li>
<p>배열(Array)</p>
</li>
<li>
<p>int/long 범위</p>
</li>
</ul>
<p>스트림의 데이터 소스가 위와 같은 클래스의 인스턴스 일 때 병렬화의 효과가 가장 좋다.<br>
위 자료구조들은 모두 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어 다수의 스레드에 분배하기에 좋다.<br>
나누는 작업은 <strong>Spliterator</strong>가 담당하며, Spliterator 객체는 Stream, Iterable의 spliterator() 메서드로 얻어올 수 있다.</p>
<p>또한 위의 자료구조는 <strong>참조 지역성(locality of reference)</strong> 이 높아 성능이 좋다.</p>
<h1 id="참조-지역성-locality-of-reference">참조 지역성 (Locality of Reference)</h1>
<p><img src="./locality.PNG" alt="locality"></p>
<p>만일 캐시(Cache)가 어떤 별도의 알고리즘 없이 중간 매개체로만 사용된다면,<br>
CPU가 Cache에서 데이터를 읽고 쓰는 속도나 메인 메모리에서 읽고 쓰는 속도나 마찬가지가 될 것이다.</p>
<p>캐시 메모리가 제 역할을 하는 것은 데이터의 지역성(locality)를 이용하기 때문.<br>
데이터의 지역성은 다음의 세가지로 분류</p>
<ul>
<li>공간적 지역성 (partial locality)
<ul>
<li>메인메모리에서 CPU가 요청한 주소지점의 데이터에 인접한 주소들이 앞으로 참조될 확률이 높음을 의미</li>
<li>이웃한 원소들의 참조가 메모리에 연속적으로 저장되어 있어 다음 참조에 대한 접근 속도가 빠르게 함</li>
</ul>
</li>
<li>시간적 지역성 (temporal locality)
<ul>
<li>한번 참조되었던 데이터는 후에 다시 참조될 가능성이 높음을 의미</li>
</ul>
</li>
<li>순차적 지역성 (sequential locality)
<ul>
<li>따로 분기가 없는 한 데이터가 기억장치에 저장된 순서대로 인출되고 실행될 가능성이 높음을 의미 (FIFO)</li>
</ul>
</li>
</ul>
<h1 id="스트림-파이프라인의-종단-연산">스트림 파이프라인의 종단 연산</h1>
<p>스트림 파이프라인의 종단연산의 동작방식 역시 병렬 수행 효율에 영향을 준다.<br>
종단 연산 중 병렬화에 가장 적합한 것은 축소(reduction)이다.<br>
축소는 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업이다.<br>
예를 들면 min, max, sum, count 같이 완성된 형태로 제공되는 메서드가 있다.<br>
anyMatch, allMatch, noneMatch처럼 조건에 맞음년 바로 반환되는 메서드도 병렬화에 적합하다.</p>
<p>반면, 가변 축소(Mutable Reduction)을 수행하는 Stream의 collect 메서드는 병렬화에 적합하지 않다.
컬렉션들을 합치는 부담이 크기 때문이다.</p>
<h1 id="병렬화에-대해-잘모르면-안하는게-낫다">병렬화에 대해 잘모르면 안하는게 낫다</h1>
<p>스트림을 잘못 병렬화하면 (응답 불가를 포함해) 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.<br>
(결과가 잘못되거나 오동작하는 것은 <strong>안전 실패(safety failure)</strong> 이라 한다.)<br>
안전 실패는 병렬화한 파이프라인이 사용하는 mappers, filters 혹은 프로그래머가 제공한 다른 함수 객체가 명시한대로 동작하지 않을 때 발생할 수 있다.</p>
<p>Stream 명세는 이때 사용되는 함수 객체에 관한 엄중한 규약을 정의해놨다.</p>
<h2 id="stream-명세는-함수-객체에-대한-규약">Stream 명세는 함수 객체에 대한 규약</h2>
<ol>
<li>Stream의 reduce 연산에 건네지는 accumulator(누적기)와 combiner(결합기) 함수는 반드시 <strong>결합법칙</strong>을 만족해야 한다.<br>
(결합 법칙 : (a op b) op c = a op (b op c))</li>
<li>간섭받지 않아야 한다 (non-interfering) - 파이프라인이 수행되는 동안 <strong>데이터소스가 변경되지 않아야한다.</strong></li>
<li>상태를 갖지 않아야 한다 (stateless)
위의 요구사항을 지키지 못하더라도 순차적으로 실행하면 올바른 결과를 얻을 수 있다.<br>
하지만 병렬로 수행하면 기대한 결과가 나오지 않을 수 있고, 실패할 수 있으니 주의해야 한다.</li>
</ol>
<h1 id="스트림-병렬화는-오직-성능-최적화-수단임을-기억하라">스트림 병렬화는 오직 성능 최적화 수단임을 기억하라</h1>
<p>다른 최적화와 마찬가지로 변경 전후로 반드시 성능테스트를 진행하여 병렬화를 사용할 가치가 있는지 확인해야 한다.<br>
이상적으로는 운영 시스템과 같은 환경에서 테스트하는 것이 좋다.<br>
보통은 병렬 스트림 파이프라인도 공통의 포크-조인 풀에서 수행되므로 (같은 스레드 풀을 사용)<br>
잘못된 파이프라인 하나가 다른 부분의 성능에까지 악영향을 줄 수 있음을 유념하자<br>
조건이 잘 갖춰지면 parallel 메서드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 볼 수 있다.</p>
<h1 id="스트림-파이프라인-병렬화가-효과적인-예">스트림 파이프라인 병렬화가 효과적인 예</h1>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pi</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">2</span>, n)</span><br><span class="line">                     .mapToObj(BigInteger::valueOf)</span><br><span class="line">                     .filter(i -&gt; i.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                     .count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pi</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">2</span>, n)</span><br><span class="line">                     .parallel()</span><br><span class="line">                     .mapToObj(BigInteger::valueOf)</span><br><span class="line">                     .filter(i -&gt; i.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                     .count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>𝛑(n) : n 보다 작거나 같은 소수의 개수를 계산하는 함수</li>
<li>책에서는 위의 함수를 실행하는데 31초, 아래 parallel()이 추가된 함수를 실행하는데 9.2초가 걸렸다고 한다.</li>
</ul>
<h1 id="random한-수의-경우">Random한 수의 경우</h1>
<p>무작위 수들로 이뤄진 스트림을 병렬화하려거든 ThreadLocalRandom(혹은 Random) 보다는<br>
SplittableRandom 인스턴스를 이용하자. SplittableRandom은 정확히 이럴 때 쓰고자 설계된 것이라<br>
병렬화 하면 성능이 선형으로 증가한다. 한편 ThreadLocalRandom은 단일 스레드에서 사용하고자 만들어 졌다.<br>
병렬로 사용하는 경우에는 SplittableRandom &gt; SplittableRandom 성능을 보인다.</p>
<p>그냥 Random의 경우에는 모든 연산을 동기화하기 때문에 병렬 처리하면 최악의 성능을 보일 것이다.</p>
<h1 id="요약">요약</h1>
<ul>
<li>계산도 올바로 수행하고 성능도 빨라질거라는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말자</li>
<li>스트림 병렬화를 잘못하면 프로그램이 오동작하거나 성능이 급격히 떨어질 수 있다.</li>
<li>병렬화를 할 경우에는 성능테스트를 반드시 진행하고, 결과가 정확한지 확인해야 한다.</li>
<li>계산도 정확하고 성능도 좋아졌음이 확실할 때, 그럴 때만 병렬화 버전을 운영 코드에 반영하라</li>
</ul>
<h1 id="참고">참고</h1>
<ul>
<li>Effective Java 3rd Edition - Item 48. 스트림 병렬화는 주의해서 적용하라</li>
<li><a href="https://okky.kr/article/345720" target="_blank" rel="noopener">Thread pool과 ForkJoinPool</a></li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="../../../../tags/Effective-Java/">Effective-Java</a></div><nav id="pagination"><div class="next-post pull-right"><a href="../../16/effective-java-item47/"><span>Item 47. 반환 타입으로는 스트림보다 컬렉션이 낫다</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://jaehun2841.github.io/2019/02/17/effective-java-item48/';
  this.page.identifier = '2019/02/17/effective-java-item48/';
  this.page.title = 'Item 48. 스트림 병렬화는 주의해서 적용하라';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'Carrey' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Carrey</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="../../../../js/third-party/anime.min.js"></script><script src="../../../../js/third-party/jquery.min.js"></script><script src="../../../../js/third-party/jquery.fancybox.min.js"></script><script src="../../../../js/third-party/velocity.min.js"></script><script src="../../../../js/third-party/velocity.ui.min.js"></script><script src="../../../../js/utils.js?version=1.5.6"></script><script src="../../../../js/fancybox.js?version=1.5.6"></script><script src="../../../../js/sidebar.js?version=1.5.6"></script><script src="../../../../js/copy.js?version=1.5.6"></script><script src="../../../../js/fireworks.js?version=1.5.6"></script><script src="../../../../js/transition.js?version=1.5.6"></script><script src="../../../../js/scroll.js?version=1.5.6"></script><script src="../../../../js/head.js?version=1.5.6"></script></body></html>