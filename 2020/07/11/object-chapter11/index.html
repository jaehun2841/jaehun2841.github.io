<!DOCTYPE html><html lang="lang"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Objects Study - Chapter11. 합성과 유연한 설계"><meta name="keywords" content="Object-Study"><meta name="author" content="Carrey"><meta name="copyright" content="Carrey"><title>Objects Study - Chapter11. 합성과 유연한 설계 | Carrey`s 기술블로그</title><link rel="shortcut icon" href="../../../../melody-favicon.ico"><link rel="stylesheet" href="../../../../css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="rss2.xml" title="Carrey`s 기술블로그" type="application/rss+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%83%81%EC%86%8D%EA%B3%BC-%ED%95%A9%EC%84%B1"><span class="toc-number">1.</span> <span class="toc-text">상속과 합성</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%83%81%EC%86%8D%EC%9D%84-%ED%95%A9%EC%84%B1%EC%9C%BC%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0"><span class="toc-number">2.</span> <span class="toc-text">상속을 합성으로 변경하기</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%83%81%EC%86%8D%EB%AC%B8%EC%A0%9C"><span class="toc-number">2.1.</span> <span class="toc-text">불필요한 인터페이스 상속문제</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EC%9D%98-%EC%98%A4%EC%9E%91%EC%9A%A9-%EB%AC%B8%EC%A0%9C-InstrumentedHashSet"><span class="toc-number">2.2.</span> <span class="toc-text">메서드 오버라이딩의 오작용 문제: InstrumentedHashSet</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%83%81%EC%86%8D%EC%9C%BC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EC%A1%B0%ED%95%A9%EC%9D%98-%ED%8F%AD%EB%B0%9C%EC%A0%81%EC%9D%B8-%EC%A6%9D%EA%B0%80"><span class="toc-number">3.</span> <span class="toc-text">상속으로 인한 조합의 폭발적인 증가</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%95%A9%EC%84%B1-%EA%B4%80%EA%B3%84%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0"><span class="toc-number">4.</span> <span class="toc-text">합성 관계로 변경하기</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EB%AF%B9%EC%8A%A4%EC%9D%B8"><span class="toc-number">5.</span> <span class="toc-text">믹스인</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%AF%B9%EC%8A%A4%EC%9D%B8%EC%9D%80-%EC%83%81%EC%86%8D%EA%B3%BC%EB%8A%94-%EB%8B%A4%EB%A5%B4%EB%8B%A4"><span class="toc-number">5.1.</span> <span class="toc-text">믹스인은 상속과는 다르다</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%8A%B8-trait"><span class="toc-number">5.2.</span> <span class="toc-text">트레이트(trait)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%8A%B8%EC%9D%98-%EC%84%A0%ED%98%95%ED%99%94"><span class="toc-number">5.3.</span> <span class="toc-text">트레이트의 선형화</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%AF%B9%EC%8A%A4%EC%9D%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8D%94%EB%9D%BC%EB%8F%84-%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%8F%AD%EB%B0%9C%EC%9D%B4-%EB%82%A8%EC%95%84%EC%9E%88%EB%8A%94-%EA%B2%83%EC%9D%B8%EA%B0%80"><span class="toc-number">5.4.</span> <span class="toc-text">믹스인을 사용하더라도 클래스 폭발이 남아있는 것인가?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%8C%93%EC%9D%84-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%B3%80%EA%B2%BD"><span class="toc-number">6.</span> <span class="toc-text">쌓을 수 있는 변경</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0"><span class="toc-number">7.</span> <span class="toc-text">참고</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300"></div><div class="author-info__name text-center">Carrey</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="../../../../archives"><span class="pull-left">Articles</span><span class="pull-right">115</span></a><a class="author-info-articles__tags article-meta" href="../../../../tags"><span class="pull-left">Tags</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="../../../../index.html">Carrey`s 기술블로그</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Objects Study - Chapter11. 합성과 유연한 설계</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-11</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="상속과-합성"><a href="#상속과-합성" class="headerlink" title="상속과 합성"></a>상속과 합성</h1><p>상속과 합성은 객체지향 프로그래밍에서 가장 널리 사용되는 코드 재사용 기법이다.  </p>
<ul>
<li>상속<ul>
<li>부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용한다</li>
<li>컴파일 타임 의존성을 가진다 (정적인 관계)</li>
<li>is-a 관계</li>
<li>부모 클래스의 내부 구현에 대해 상세히 알아야하기 때문에 자식 클래스와 부모 클래스 사이의 결합도가 높아진다.</li>
<li>부모 클래스에 구현된 코드를 재사용한다</li>
</ul>
</li>
<li>합성<ul>
<li>전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다</li>
<li>런타임 의존성을 가진다 (동적인 관계) </li>
<li>has-a 관계</li>
<li>클래스와 클래스간의 퍼블릭 인터페이스에 의존하여 결합도가 낮다.</li>
<li>내부 구현의 변경의 영향이 최소화 된다</li>
<li>객체의 퍼블릭 인터페이스를 재사용한다</li>
</ul>
</li>
</ul>
<p>코드 작성 시점에 결정된 상속 관계는 런타임에 변경이 불가하지만 합성 관계는 실행 시점에 동적으로 변경할 수 있기 때문에<br>상속 대신 합성을 사용하면 변경하기 쉽고 유연한 설계를 얻을 수 있다.</p>
<blockquote>
<p><strong>화이트박스 재사용 (white-box reuse)</strong><br>상속으로 인한 재사용을 일컫는다. 상속을 받으면 부모 클래스의 내부가 자식 클래스에 공개되기 때문에 화이트 박스인 셈이다.</p>
</blockquote>
<blockquote>
<p><strong>블랙박스 재사용 (black-box reuse)</strong><br>합성으로 인한 재사용을 일컫는다. 합성 시에는 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문이다.</p>
</blockquote>
<h1 id="상속을-합성으로-변경하기"><a href="#상속을-합성으로-변경하기" class="headerlink" title="상속을 합성으로 변경하기"></a>상속을 합성으로 변경하기</h1><p>코드의 재사용을 위해 상속을 남용하는 경우 발생하는 문제점은 아래와 같다.</p>
<ul>
<li>불필요한 인터페이스 상속문제</li>
<li>메서드 오버라이딩 오작용 문제</li>
<li>부모 클래스와 자식 클래스의 동시 수정 문제</li>
</ul>
<p>합성을 사용하면 상속이 초래하는 문제점을 해결할 수 있다.<br>상속을 합성으로 바꾸는 방법은 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.</p>
<h2 id="불필요한-인터페이스-상속문제"><a href="#불필요한-인터페이스-상속문제" class="headerlink" title="불필요한 인터페이스 상속문제"></a>불필요한 인터페이스 상속문제</h2><p>상속을 이용한 Stack에서는 부모클래스에서 제공하는 퍼블릭 인터페이스 때문에 Stack의 규칙을 위반할 수 있다.<br>Vector는 임의의 위치(index)에서 요소를 조회하고, 추가하고, 삭제할 수 있는 get, add, remove 오퍼레이션을 제공한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;1st&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;2nd&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;3rd&quot;</span>);</span><br><span class="line">stack.add(<span class="number">0</span>, <span class="string">&quot;4th&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;4th&quot;</span>, stack.pop()); <span class="comment">//에러</span></span><br></pre></td></tr></table></figure>



<p>기존 상속을 이용하던 Stack을 합성으로 바꿔보았다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span>&lt;E&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Vector&lt;E&gt; elements = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">push</span><span class="params">(E item)</span> &#123;</span><br><span class="line">    elements.add(item);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(elements.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements.remove(elements.size()-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 Vector의 퍼블릭 인터페이스는 Stack에 포함되지 않는다.<br>클라이언트는 더 이상 임의의 위치에 요소를 추가하거나 삭제할 수 없다.  따라서 Stack의 규칙을 깰 수 있는 요소가 없게 된다.</p>
<h2 id="메서드-오버라이딩의-오작용-문제-InstrumentedHashSet"><a href="#메서드-오버라이딩의-오작용-문제-InstrumentedHashSet" class="headerlink" title="메서드 오버라이딩의 오작용 문제: InstrumentedHashSet"></a>메서드 오버라이딩의 오작용 문제: InstrumentedHashSet</h2><p>상속을 이용한 기존 InstrumentedHashSet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentedHashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">addCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    addCount += c.size();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.addAll(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>기존에 상속을 이용하던 InstrumentedHashSet을 합성으로 바꿔보았다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentedHashSet</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">addCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> Set&lt;E&gt; set;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">InstrumentedHashSet</span><span class="params">(Set&lt;E&gt; set)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.set = set;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addCount++;</span><br><span class="line">    <span class="keyword">return</span> set.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    addCount += c.size();</span><br><span class="line">    <span class="keyword">return</span> set.addAll(c);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAddCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addCount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 과정까지는 위의 Stack의 예제와 같다.<br>하지만 InstrumentedHashSet은 기존의 HashSet의 퍼블릭 인터페이스까지 제공을 해야한다.</p>
<p>이를 해결하기 위해 아래와 같이 코드를 작성하였다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentedHashSet</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">addCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> Set&lt;E&gt; set;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">InstrumentedHashSet</span><span class="params">(Set&lt;E&gt; set)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.set = set;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addCount++;</span><br><span class="line">    <span class="keyword">return</span> set.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    addCount += c.size();</span><br><span class="line">    <span class="keyword">return</span> set.addAll(c);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAddCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addCount;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E e)</span> &#123;<span class="keyword">return</span> set.remove(e);&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.clear();&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(E e)</span> &#123;<span class="keyword">return</span> set.equals(e);&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.hashCode();&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.spliterator();&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.isEmpty(e);&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span> &#123;<span class="keyword">return</span> set.contains(e);&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.iterator();&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> E[] toArray(E e) &#123;<span class="keyword">return</span> set.remove(e);&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>포워딩 메서드(forwarding method)</strong></p>
<p>위와 같이 오퍼레이션을 오버라이딩한 인스턴스 메서드에서 내부의 HashSet 인스턴스에게 동일한 메서드 호출을 그대로 전달하는 것을 알 수 있다.<br>이를 <strong>포워딩(forwarding)</strong> 이라 부르고 동일한 메서드를 호출하기 위해 추가된 메서드를 <strong>포워딩 메서드(forwarding method)</strong> 라고 부른다.<br>포워딩은 기존 클래스의 인터페이스를 그대로 외부에 제공하면서 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 사용하는 유용한 기법이다.</p>
</blockquote>
<h1 id="상속으로-인한-조합의-폭발적인-증가"><a href="#상속으로-인한-조합의-폭발적인-증가" class="headerlink" title="상속으로 인한 조합의 폭발적인 증가"></a>상속으로 인한 조합의 폭발적인 증가</h1><p>상속으로 인해 결합도가 높아지면 코드를 수정하는 데 필요한 작업의 양이 과도하게 증가할 수 있다.<br>일반적으로 작은 기능들을 조합해서 더 큰 기능을 수행하는 객체를 만들어야 하는 경우이다.</p>
<ul>
<li>하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.</li>
<li>단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.</li>
</ul>
<p><img src="./class_explosion.jpg" alt="class explosion"></p>
<p>위의 이미지와 같이 상속의 남용으로 모든 케이스에 대한 조합을 클래스로 표현하는 경우를 가리켜 클래스 폭발(class explosion)이라 한다.  또는 조합의 폭발이라 한다.<br>클래스 폭발 문제는 자식 클래스가 부모 클래스의 구현에 강하게 결합되도록 강요하는 상속의 근본적인 한계로 인해 발생하는 문제다.<br>클래스 폭발 문제는 새로운 기능을 추가하는 경우에는 많은 코드를 변경해야 할 뿐만 아니라 기능을 추가하는 경우에도 기하급수적으로 클래스가 생성될 수 있다.</p>
<h1 id="합성-관계로-변경하기"><a href="#합성-관계로-변경하기" class="headerlink" title="합성 관계로 변경하기"></a>합성 관계로 변경하기</h1><p>상속 관계는 컴파일타임에 결정되고 고정되기 때문에 코드를 실행하는 도중에는 변경할 수 없다.<br>따라서 여러 기능을 조합해야하는 설계에 상속을 이용하면 모든 조합 가능한 경우별로 클래스를 추가해야한다.</p>
<p>하지만 합성을 사용하면 컴파일 관계를 런타임 관계로 변경함으로써 이 문제를 해결한다.<br>합성을 사용하면 구현이 아닌 퍼블릭 인터페이스에 대해서만 의존할 수 있기 때문에 런타임에 객체의 관계를 변경할 수 있다.</p>
<p>따라서 합성을 사용하면 구현 시점에 관계를 고정시킬 필요가 없으며 실행 시점에 정책들의 관계를 유연하게 변경할 수 있다.<br>컴파일 의존성에 속박되지 않고 다양한 방식의 런타임 의존성을 구성할 수 있다는 것이 합성이 제공하는 가장 커다란 장점이다.</p>
<p>위의 상속관계로 나온 case를 합성을 사용하면 아래와 같이 사용할 수 있다.</p>
<p><img src="./composition.jpg" alt="composition"></p>
<p><img src="./composition2.jpg" alt="composition2"></p>
<h1 id="믹스인"><a href="#믹스인" class="headerlink" title="믹스인"></a>믹스인</h1><p>믹스인(mixin)은 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법을 가리키는 용어다.<br>합성이 실행 시점에 객체를 조합하는 재사용 방법이라면 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법이다.  </p>
<h2 id="믹스인은-상속과는-다르다"><a href="#믹스인은-상속과는-다르다" class="headerlink" title="믹스인은 상속과는 다르다"></a>믹스인은 상속과는 다르다</h2><p>믹스인이 상속이 유사한 것 처럼 보이겠지만 사실은 다르다.<br>상속의 결과로 부모 클래스의 코드를 재사용한다는 사실은 맞지만 상속의 목적은 자식 클래스를 부모 클래스와 동일한 개념적인 범주로 묶어 is-a 관계를 만들기 위한 것이다.<br>반면 믹스인은 말 그래로 코드를 다른 코드 안에 섞어 넣기 위한 방법이다.   </p>
<p>상속이 클래스와 클래스 사이의 관계를 고정시키는 데 비해 믹스인은 유연하게 관계를 재구성 할 수 있다.<br>믹스인은 코드 재사용에 특화된 방법이면서도 상속과 같은 결합도 문제를 초래하지 않는다.</p>
<blockquote>
<p><strong>믹스인의 유래</strong></p>
<p>믹스인은 Flavors라는 언어에서 처음으로 도입됐고 이후 Flavors의 특징을 흡수한 CLOS(Common Lisp Object System)에 의해 대중화됐다.  </p>
</blockquote>
<h2 id="트레이트-trait"><a href="#트레이트-trait" class="headerlink" title="트레이트(trait)"></a>트레이트(trait)</h2><p>스칼라 언어에서 제공하는 믹스인 기법이다.<br>간단하게 설명하면 trait는 <strong>super</strong> 라는 코드가 부모클래스 하나를 고정하지 않는다.<br>super는 런타임에 달라질 수 있으며 실제로 trait가 믹스인 되는 시점에 결정된다. (실행시점에 결정)  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RateDiscountablePolicy</span> <span class="keyword">extends</span> <span class="title">BasicRatePolicy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> discountAmount: <span class="type">Money</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">calculateFee</span></span>(phone: <span class="type">Phone</span>): <span class="type">Money</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> fee = <span class="keyword">super</span>.calculateFee(phone)</span><br><span class="line">    fee - discountAmount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 예제에서 super는 BasicRatePolicy의 클래스 어떤 것이든 될 수 있다.<br>BasicRatePolicy 클래스이든, BasicRatePolicy를 상속한 자식 클래스이든 trait에 대한 코드를 믹스인 할 수 있다.</p>
<h2 id="트레이트의-선형화"><a href="#트레이트의-선형화" class="headerlink" title="트레이트의 선형화"></a>트레이트의 선형화</h2><p>스칼라는 특정 클래스에 믹스인한 클래스와 트레이트를 선형화해서 어떤 메서드를 호출할 지 결정한다.<br>클래스의 인스턴스를 생성할 때 스칼라는 클래스 자신과 조상 클래스, 트레이트를 일렬로 나열해서 순서를 정한다.<br>그리고 실행 중인 메서드 내부에서 super 호출을 하면 다음 단계에 위치한 클래스나 트레이트의 메서드가 호출된다.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RateDiscountableAndTaxableRegularPolicy</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">  amount: <span class="type">Money</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  seconds: <span class="type">Duration</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  val taxRate: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">RegularPolicy</span>(amount, seconds)</span><br><span class="line"><span class="keyword">with</span> <span class="type">TaxablePolicy</span></span><br><span class="line"><span class="keyword">with</span> <span class="type">RateDiscountablePolicy</span></span><br></pre></td></tr></table></figure>

<p>위와 같은 클래스에서는 아래와 같이 선형화 된다.</p>
<p><img src="./trait_serialization.jpg" alt="trait serialization"></p>
<p>만약 RateDiscountableAndTaxableRegularPolicy 인스턴스가 calculateFee 메시지를 수신했다고 가정하면 RateDiscountableAndTaxableRegularPolicy에는 calculateFee 메서드가 없기 때문에 다음 단계에 위치한 RateDiscountablePolicy에서 calculateFee 메서드가 존재하는지 찾는다.<br>RateDiscountablePolicy에서 calculateFee를 찾으면 실행한다.<br>RateDiscountablePolicy에서 또 super.calculateFee를 호출하기 때문에 위의 단계인 TaxablePolicy의 calculateFee 메서드를 찾는다.<br>이렇게 올라가다 보면 BasicRatePolicy의 기본요금부터 재귀호출 되듯이 코드가 실행되며 내려오기 때문에 금액 계산이 순차적으로 된다.</p>
<p>만약 RateDiscountablePolicy와 TaxablePolicy의 순서를 바꾸고 싶다면</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RateDiscountableAndTaxableRegularPolicy</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">  amount: <span class="type">Money</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  seconds: <span class="type">Duration</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  val taxRate: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">RegularPolicy</span>(amount, seconds)</span><br><span class="line"><span class="keyword">with</span> <span class="type">RateDiscountablePolicy</span></span><br><span class="line"><span class="keyword">with</span> <span class="type">TaxablePolicy</span></span><br></pre></td></tr></table></figure>
<p>아래와 같이 코드를 변경하여 선형화된 순서를 바꿀 수 있다.</p>
<h2 id="믹스인을-사용하더라도-클래스-폭발이-남아있는-것인가"><a href="#믹스인을-사용하더라도-클래스-폭발이-남아있는-것인가" class="headerlink" title="믹스인을 사용하더라도 클래스 폭발이 남아있는 것인가?"></a>믹스인을 사용하더라도 클래스 폭발이 남아있는 것인가?</h2><p>믹스인을 사용하더라도 상속에서 클래스의 숫자가 기하급수적으로 늘어나는 클래스 폭발 문제는 여전히 남아있는게 아니냐고 반문할 수 있다.<br>클래스 폭발 문제의 단점은 클래스가 늘어난다는 것이 아니라 클래스가 늘어날수록 중복 코드도 함께 기하급수적으로 늘어난다는 점이다.<br>믹스인은 이런 문제가 발생하지 않는다.</p>
<p>또 클래스를 만들지 않고도 믹스인을 사용할 수 있다. </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">RegularPolicy</span>(<span class="type">Money</span>(<span class="number">100</span>), <span class="type">Duration</span>.ofSecond(<span class="number">10</span>))</span><br><span class="line">  <span class="keyword">with</span> <span class="type">RateDiscountablePolicy</span></span><br><span class="line">  <span class="keyword">with</span> <span class="type">TaxablePolicy</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> discountAmount = <span class="type">Money</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">val</span> taxRate = <span class="number">0.02</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>하지만 코드 여러 곳에서 동일한 트레이트를 믹스인해서 사용해야 한다면 명시적으로 클래스를 정의하는게 좋다.</p>
<h1 id="쌓을-수-있는-변경"><a href="#쌓을-수-있는-변경" class="headerlink" title="쌓을 수 있는 변경"></a>쌓을 수 있는 변경</h1><p>믹스인은 상속 계층 안에서 확장한 클래스보다 더 하위에 위치하게 된다.<br>다시 말해 믹스인은 대상 클래스의 자식 클래스처럼 사용될 용도로 만들어 지는 것이다.  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RateDiscountableAndTaxableRegularPolicy</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">  amount: <span class="type">Money</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  seconds: <span class="type">Duration</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  val taxRate: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">RegularPolicy</span>(amount, seconds)</span><br><span class="line"><span class="keyword">with</span> <span class="type">RateDiscountablePolicy</span></span><br><span class="line"><span class="keyword">with</span> <span class="type">TaxablePolicy</span></span><br></pre></td></tr></table></figure>
<p>위의 코드 처럼 trait를 믹스인한 with 구문은 항상 extends 구문 뒤에 나온다.</p>
<p>믹스인을 사용하면 특정한 클래스에 대한 변경 또는 확장을 독립적으로 구현한 후 필요한 시점에 차례대로 추가할 수 있다.<br>믹스인의 이러한 특징을 <strong>쌓을 수 있는 변경(stackable modification)</strong> 이라고 부른다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - chapter11. 합성과 유연한 설계</li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="../../../../tags/Object-Study/">Object-Study</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="../../12/object-chapter12/"><i class="fa fa-chevron-left">  </i><span>Objects Study - Chapter12. 다형성</span></a></div><div class="next-post pull-right"><a href="../../05/object-chapter10/"><span>Objects Study - Chapter10. 유연한 설계</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://jaehun2841.github.io/2020/07/11/object-chapter11/';
  this.page.identifier = '2020/07/11/object-chapter11/';
  this.page.title = 'Objects Study - Chapter11. 합성과 유연한 설계';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'Carrey' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Carrey</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="../../../../js/utils.js?version=1.9.0"></script><script src="../../../../js/fancybox.js?version=1.9.0"></script><script src="../../../../js/sidebar.js?version=1.9.0"></script><script src="../../../../js/copy.js?version=1.9.0"></script><script src="../../../../js/fireworks.js?version=1.9.0"></script><script src="../../../../js/transition.js?version=1.9.0"></script><script src="../../../../js/scroll.js?version=1.9.0"></script><script src="../../../../js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>