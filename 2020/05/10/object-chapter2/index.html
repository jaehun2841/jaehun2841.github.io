<!DOCTYPE html><html lang="lang"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Objects Study - Chapter2. 객체지향 프로그래밍"><meta name="keywords" content="Object-Study"><meta name="author" content="Carrey"><meta name="copyright" content="Carrey"><title>Objects Study - Chapter2. 객체지향 프로그래밍 | Carrey`s 기술블로그</title><link rel="shortcut icon" href="../../../../melody-favicon.ico"><link rel="stylesheet" href="../../../../css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="rss2.xml" title="Carrey`s 기술블로그" type="application/rss+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%84-%EC%84%A4%EA%B3%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95"><span class="toc-number">1.</span> <span class="toc-text">객체지향을 설계하는 방법</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EB%8F%84%EB%A9%94%EC%9D%B8-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EB%94%B0%EB%A5%B4%EB%8A%94-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EA%B5%AC%EC%A1%B0"><span class="toc-number">2.</span> <span class="toc-text">도메인 구조를 따르는 프로그램 구조</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%EC%84%A4%EA%B3%84%ED%95%A0-%EB%95%8C%EB%8A%94-%EB%82%B4%EB%B6%80%EC%99%80-%EC%99%B8%EB%B6%80%EB%A1%9C-%EB%82%98%EB%88%88%EB%8B%A4"><span class="toc-number">3.</span> <span class="toc-text">클래스를 설계할 때는 내부와 외부로 나눈다.</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%83%81%ED%98%B8-%ED%98%91%EB%A0%A5%ED%95%98%EB%8A%94-%EC%A1%B4%EC%9E%AC%EB%93%A4%EC%9D%B4%EB%8B%A4"><span class="toc-number">4.</span> <span class="toc-text">객체는 상호 협력하는 존재들이다.</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%98%91%EB%A0%A5"><span class="toc-number">4.1.</span> <span class="toc-text">객체의 협력</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%83%81%EC%86%8D"><span class="toc-number">5.</span> <span class="toc-text">상속</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%83%81%EC%86%8D%EC%9D%98-%EB%8B%A8%EC%A0%90"><span class="toc-number">6.</span> <span class="toc-text">상속의 단점</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%95%A9%EC%84%B1-composition"><span class="toc-number">7.</span> <span class="toc-text">합성 (composition)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EB%8B%A4%ED%98%95%EC%84%B1"><span class="toc-number">8.</span> <span class="toc-text">다형성</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EB%8B%A4%ED%98%95%EC%84%B1%EC%9D%98-Trade-off"><span class="toc-number">9.</span> <span class="toc-text">다형성의 Trade off</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%B6%94%EC%83%81%ED%99%94%EC%9D%98-%ED%9E%98"><span class="toc-number">10.</span> <span class="toc-text">추상화의 힘</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0"><span class="toc-number">11.</span> <span class="toc-text">참고</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300"></div><div class="author-info__name text-center">Carrey</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="../../../../archives"><span class="pull-left">Articles</span><span class="pull-right">115</span></a><a class="author-info-articles__tags article-meta" href="../../../../tags"><span class="pull-left">Tags</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="../../../../index.html">Carrey`s 기술블로그</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Objects Study - Chapter2. 객체지향 프로그래밍</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-10</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="객체지향을-설계하는-방법"><a href="#객체지향을-설계하는-방법" class="headerlink" title="객체지향을 설계하는 방법"></a>객체지향을 설계하는 방법</h1><ul>
<li>클래스가 아닌 실제 working하는 instance(객체)에 초점을 둔다.</li>
<li>클래스는 객체들의 특징을 추상화 한 것</li>
<li>클래스 -&gt; 객체가 아닌 객체들을 정의하고 객체들의 특징을 기반으로 클래스를 정의한다.</li>
<li>객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다.</li>
<li>객체는 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 구성원의 일원으로 봐야한다.<ul>
<li>객체를 협력하는 공동체의 일원으로 바라보게 되면 설계를 유연하고 확장 가능하게 만든다.</li>
</ul>
</li>
</ul>
<p>따라서 객체를 나열 -&gt; 타입으로 분류 -&gt; 클래스 작성 하는 순서를 따르는 것이 좋다.</p>
<h1 id="도메인-구조를-따르는-프로그램-구조"><a href="#도메인-구조를-따르는-프로그램-구조" class="headerlink" title="도메인 구조를 따르는 프로그램 구조"></a>도메인 구조를 따르는 프로그램 구조</h1><p>도메인이란? 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야<br>도메인 개념을 구현하기 위해 클래스를 사용<br>클래스 이름은 도메인 개념과 동일하거나 최대한 유사하게 짓는다.</p>
<h1 id="클래스를-설계할-때는-내부와-외부로-나눈다"><a href="#클래스를-설계할-때는-내부와-외부로-나눈다" class="headerlink" title="클래스를 설계할 때는 내부와 외부로 나눈다."></a>클래스를 설계할 때는 내부와 외부로 나눈다.</h1><ul>
<li>내부는 private, 외부에 공개할 것은 public으로 만든다.</li>
<li>경계의 명확성이 객체의 자율성을 보장한다.</li>
<li>클래스를 사용하는 입장에서는 public으로 공개된 인터페이스만 알면 된다. (내부의 구현에 대해서는 알 필요가 없다.)</li>
<li>클래스를 만들고 수정하는 입장에서는 private으로 된 부분은 클래스 외부에서 참조 하지 않으니 마음대로 구현을 변경해도 된다.</li>
<li>이러한 내&#x2F;외부의 경계를 잘 나눠야 하는 이유는 변경을 관리 하기 위해서이다.<ul>
<li>변경될 가능성이 있는 세부적인 구현 내용을 private 영역에 감춤으로써 변경으로 인한 혼란을 최소화 할 수 있다.</li>
</ul>
</li>
</ul>
<h1 id="객체는-상호-협력하는-존재들이다"><a href="#객체는-상호-협력하는-존재들이다" class="headerlink" title="객체는 상호 협력하는 존재들이다."></a>객체는 상호 협력하는 존재들이다.</h1><ul>
<li>객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청할 수 있다.</li>
<li>요청 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답한다.</li>
</ul>
<h2 id="객체의-협력"><a href="#객체의-협력" class="headerlink" title="객체의 협력"></a>객체의 협력</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> b: B</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.method() <span class="comment">// 의존성을 가지는 B 클래스의 method 라는 메세지를 전송할 수 있다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">()</span></span> &#123; </span><br><span class="line">    doAction() </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메세지를 전송(send a message) 하는 것 뿐이다.<br>(의역하자면 다른 객체가 가지고 있는 공개된 인터페이스의 method signature를 호출한다.)</li>
<li>메세지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메세지를 처리할 방법을 결정한다.<br> 수신된 메세지를 처리하기 위한 자신만의 방법을 메서드(method)라고 부른다.<br>(의역하자면 요청 받은 클래스의 인터페이스를 구현한 mehtod body 부분을 메서드라고 하는 것 같다.)</li>
<li>메세지와 메서드의 구분에서부터 다형성(polymorphism)의 개념이 출발한다.<br>(메세지 : method signature, 메서드 : 실제 method 구현부)</li>
</ul>
<h1 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h1><ul>
<li>상속은 객체 지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.</li>
<li>자식 클래스는 부모 클래스가 수신할 수 있는 모든 메세지를 수신할 수 있다.<br>그렇기 때문에 자식 클래스는 부모 클래스와 동일한 Type으로 볼 수 있다.</li>
<li>상속은 부모 클래스의 코드를 기반으로 전혀 수정하지 않거나 일부분을 추가&#x2F;수정 하여 새로운 클래스를 만들 수 있다. (코드의 재사용)<ul>
<li>부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 차이에 의한 프로그래밍 (programming by difference)라 한다.</li>
</ul>
</li>
<li>자식 클래스가 부모 클래스를 대신하는 것을 업 캐스팅(up casting)이라 한다.</li>
</ul>
<h1 id="상속의-단점"><a href="#상속의-단점" class="headerlink" title="상속의 단점"></a>상속의 단점</h1><ul>
<li>상속은 캡슐화를 위반한다.<ul>
<li>상속을 이용하기 위해선 부모 클래스의 내부 구조를 잘 알고 있어야 한다.</li>
<li>부모 클래스의 구현이 자식 클래스에 노출 되기 때문에 캡슐화가 약화된다.+</li>
<li>캡슐화는 자식 클래스와 부모 클래스의 강결합을 만들어 부모 클래스가 변경되야 하는 경우 자식 클래스도 함께 변경되게 된다.</li>
<li>상속을 과도하게 사용하면 코드를 변경하기 어렵게 된다.</li>
</ul>
</li>
<li>설계를 유연하게 하지 못한다.<ul>
<li>부모 클래스와 자식 클래스의 관계를 컴파일 타임에 결정한다.</li>
</ul>
</li>
</ul>
<h1 id="합성-composition"><a href="#합성-composition" class="headerlink" title="합성 (composition)"></a>합성 (composition)</h1><ul>
<li>인터페이스에 정의된 메세지를 통해서만 코드를 재사용하는 방법을 <strong>합성</strong>이라 한다.</li>
<li>인터페이스에 정의된 메세지를 통해서만 재사용이 가능하기 때문에 구현을 캡슐화 하기 용이하다</li>
<li>의존하는 인스턴스를 교체하는 것이 비교적 쉬워 설계를 유연하게 만든다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeDiscountPolicy</span><span class="params">(DiscountPolicy discountPolicy)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Movie</span> <span class="variable">avartar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="keyword">new</span> <span class="title class_">AmountDiscount</span>());</span><br><span class="line">avartar.changeDiscountPolicy(<span class="keyword">new</span> <span class="title class_">PercentDiscountPolicy</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h1><ul>
<li>동일한 메세지를 수신할 수 있지만, 어떤 메서드가 실행될 지는 수신하는 클래스에 따라 달라진다.<br>(인터페이스의 메서드를 호출할 수 있지만 메서드의 실행은 인터페이스를 구현한 클래스에 따라 달라진다.)</li>
<li>실행되는 메서드는 Runtime에 결정된다.  <ul>
<li>이를 Lazy Binding 또는 Dynamic Binding이라 한다.</li>
</ul>
</li>
</ul>
<h1 id="다형성의-Trade-off"><a href="#다형성의-Trade-off" class="headerlink" title="다형성의 Trade off"></a>다형성의 Trade off</h1><ul>
<li>다형성을 사용하게 되면 코드의 의존성과 Runtime의 의존성이 서로 다를 수 있다.  <ul>
<li>어떤 클래스를 주입하느냐에 따라 의존성이 달라진다.</li>
<li>하지만 코드 상으로는 인터페이스 &#x2F; 추상클래스에 대한 의존성만 가지고 있다.</li>
</ul>
</li>
<li>확장 가능한 객체 지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다.</li>
<li>코드의 의존성과 실행시점의 의존성이 다르면 코드를 이해하기 어렵고 디버깅을 어렵게 만든다.</li>
</ul>
<h1 id="추상화의-힘"><a href="#추상화의-힘" class="headerlink" title="추상화의 힘"></a>추상화의 힘</h1><ul>
<li>추상화 계층만 따로 떼어 놓고 보면 요구사항의 정책을 높은 수준에서 서술할 수 있다.<br>(뒤에 자세한 구현부는 모르겠지만 전체적인 틀을 잡기 편하다)</li>
<li>추상화를 이용하면 설계가 조금 더 유연해 진다.</li>
<li>Runtime에 주입되는 코드는 추상화를 이용해서 정의한 상위의 흐름을 따라가게 된다.</li>
<li>디자인 패턴(design pattern)이나 프레임워크(framework) 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 매커니즘을 활용하고 있다.</li>
<li>추상화를 이용하여 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.</li>
<li>유연성이 필요한 곳에 추상화를 사용하라</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - 객체지향 프로그래밍</li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="../../../../tags/Object-Study/">Object-Study</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="../object-chapter3/"><i class="fa fa-chevron-left">  </i><span>Objects Study - Chapter3. 역할, 책임, 협력</span></a></div><div class="next-post pull-right"><a href="../../09/object-chapter1/"><span>Objects Study - Chapter1. 객체, 설계</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://jaehun2841.github.io/2020/05/10/object-chapter2/';
  this.page.identifier = '2020/05/10/object-chapter2/';
  this.page.title = 'Objects Study - Chapter2. 객체지향 프로그래밍';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'Carrey' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Carrey</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="../../../../js/utils.js?version=1.9.0"></script><script src="../../../../js/fancybox.js?version=1.9.0"></script><script src="../../../../js/sidebar.js?version=1.9.0"></script><script src="../../../../js/copy.js?version=1.9.0"></script><script src="../../../../js/fireworks.js?version=1.9.0"></script><script src="../../../../js/transition.js?version=1.9.0"></script><script src="../../../../js/scroll.js?version=1.9.0"></script><script src="../../../../js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>