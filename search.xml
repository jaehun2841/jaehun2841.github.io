<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring Cloud Config 주기적으로 Polling 하기</title>
      <link href="/2022/03/10/2022-03-11-spring-cloud-config-polling/"/>
      <url>/2022/03/10/2022-03-11-spring-cloud-config-polling/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>해당 글에서 사용한 예제의 버전 정보는 아래와 같습니다</p><ul><li>kotlin 1.6.0</li><li>Spring Boot 2.6.3</li><li>Spring Cloud Dependencies 2021.0.1</li></ul><p>Spring Cloud Config 관련 글은 총 4개의 글로 작성되었습니다.</p><ul><li><a href="../2022-03-11-spring-cloud-config">Spring Cloud Config 시작하기</a></li><li><a href="../2022-03-11-spring-cloud-bus">Spring Cloud Bus 시작하기</a></li><li><a href="../2022-03-11-spring-cloud-config-monitor">Spring Cloud Config Monitor 시작하기</a></li><li><strong>Spring Cloud Config 주기적으로 Polling 하기</strong></li></ul><h1 id="ConfigClientWatch-살펴보기"><a href="#ConfigClientWatch-살펴보기" class="headerlink" title="ConfigClientWatch 살펴보기"></a>ConfigClientWatch 살펴보기</h1><p><img src="./spring-cloud-configclientwatch.jpg"></p><ul><li>이 글에서는 주기적으로 config server에서 설정 정보를 가져와 반영하는 방법을 설명합니다.</li><li>Spring Cloud Config 공식 문서에도 보이지 않는 히든(?) 기능 입니다.</li><li>Spring Cloud Config Client 코드를 보다가 발견한 기능입니다.</li><li>처음 이 기능을 발견했을 때는 주기적으로 config server에서 설정 정보를 불러와 변경 사항이 있는 경우 context refresh를 트리거 하는 컴포넌트라고 생각했습니다.</li></ul><p><img src="config-client-watch-code.png"></p><h1 id="설정하기"><a href="#설정하기" class="headerlink" title="설정하기"></a>설정하기</h1><p>아래와 같이 설정 후, ConfigClientWatch를 실행해 보았습니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">import:</span> <span class="string">&quot;optional:configserver:http://localhost:8080&quot;</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment"># 추가된 기능</span></span><br><span class="line">      <span class="attr">watch:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> </span><br><span class="line">        <span class="attr">initialDelay:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">jaehun-microservice-router</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">true</span> </span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="number">1000</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1.1</span></span><br><span class="line">      <span class="attr">request-connect-timeout:</span> <span class="number">2000</span></span><br><span class="line">      <span class="attr">request-read-timeout:</span> <span class="number">10000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>spring.cloud.config.watch.enabled=true</code><ul><li>ConfigClientWatch를 사용합니다.</li><li>이 설정값이 true이어야 ConfigClientWatch bean이 생성됩니다.</li></ul></li><li><code>spring.cloud.config.watch.initialDelay=5000</code><ul><li>클라이언트 애플리케이션이 실행되고 첫번째 polling을 시작하기 전까지 대기 시간 입니다.</li><li>단위는 ms(밀리세컨드) 입니다.</li><li>기본값은 18000ms (&#x3D;3분)입니다.</li></ul></li><li><code>spring.cloud.config.watch.delay=10000</code><ul><li>ConfigClientWatch의 polling 주기 입니다.</li><li>단위는 ms(밀리세컨드) 입니다.</li><li>기본값은 500ms 입니다.</li></ul></li></ul><h2 id="Spring-Scheduler를-사용하는-모듈입니다"><a href="#Spring-Scheduler를-사용하는-모듈입니다" class="headerlink" title="Spring Scheduler를 사용하는 모듈입니다."></a>Spring Scheduler를 사용하는 모듈입니다.</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientApplication</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  runApplication&lt;ClientApplication&gt;(*args) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>스케줄러 bean이 등록될 수 있도록 <code>@EnableScheduling</code> 어노테이션을 선언해 줍니다.</li></ul><h1 id="그러나-context-refresh는-발생하지-않았다"><a href="#그러나-context-refresh는-발생하지-않았다" class="headerlink" title="그러나 context refresh는 발생하지 않았다."></a>그러나 context refresh는 발생하지 않았다.</h1><p><img src="./debug-state.png"></p><ul><li>config server에서 값을 변경하더라도  newState와 oldState의 값은 항상 null이었습니다.</li><li>따라서 stateChanged라는 메서드가 무조건 false로 떨어져 context refresh가 발생하지 않았습니다.</li></ul><h1 id="그럼-config-client-state값은-언제-바뀌는가"><a href="#그럼-config-client-state값은-언제-바뀌는가" class="headerlink" title="그럼 config.client.state값은 언제 바뀌는가?"></a>그럼 config.client.state값은 언제 바뀌는가?</h1><p><img src="how-to-state.png"></p><ul><li>config.client.state라는 문자열을 검색하니 <code>ConfigServicePropertySourceLocator</code> 라는 클래스에서 putValue 하는 코드가 보입니다</li><li><code>ConfigServicePropertySourceLocator</code> 의 locate 메서드는 getEnvironment라는 메서드를 통해 config server api를 호출하여 설정 정보를 불러 옵니다.</li><li>이후 설정 정보에 getState한 값을 config.client.state 프로퍼티에 바인딩 해줍니다.</li></ul><h1 id="API-응답-값-중에-state-값이-있었나요"><a href="#API-응답-값-중에-state-값이-있었나요" class="headerlink" title="API 응답 값 중에 state 값이 있었나요?"></a>API 응답 값 중에 state 값이 있었나요?</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request GET <span class="string">&#x27;http://config-server/jaehun-microservice-router/local/master&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;prod&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;propertySources&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router-prod&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;routing.weight.A&quot;</span><span class="punctuation">:</span> <span class="string">&quot;51&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;\routing.weight.B&quot;</span><span class="punctuation">:</span> <span class="string">&quot;49&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>위의 API를 호출하여 message-platform-router에 대한 설정 정보를 요청했고, 요청 응답에는 version과 state라는 프로퍼티가 있습니다.</li><li>이 프로퍼티를 사용하면 <code>ConfigServicePropertySourceLocator</code> 를 이용해서 config.client.state라는 프로퍼티에 값을 변경할 수 있겠다고 생각했습니다.</li></ul><h1 id="config-server에서-state-값은-어떻게-내려줄-수-있는가"><a href="#config-server에서-state-값은-어떻게-내려줄-수-있는가" class="headerlink" title="config server에서 state 값은 어떻게 내려줄 수 있는가?"></a>config server에서 state 값은 어떻게 내려줄 수 있는가?</h1><p><img src="where-is-stae.png"></p><p>찾아보니 <strong>결과적으로는 state란 필드는 vault, native backend에서만 사용하는 것으로 확인하였습니다.</strong><br>하지만 저는 JDBC Backend를 사용하기 때문에 결과적으로는 state 값을 이용하긴 어려웠습니다.</p><h1 id="그래도-사용해보고-싶었습니다-안되면-되게하라-ㅠㅠ"><a href="#그래도-사용해보고-싶었습니다-안되면-되게하라-ㅠㅠ" class="headerlink" title="그래도 사용해보고 싶었습니다. (안되면 되게하라 ㅠㅠ)"></a>그래도 사용해보고 싶었습니다. (안되면 되게하라 ㅠㅠ)</h1><p>StateSupportJdbcEnvironmentRepository라는 커스텀한 클래스를 생성하였습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateSupportJdbcEnvironmentRepository</span></span>(</span><br><span class="line">    <span class="meta">@Value(<span class="string">&quot;\$&#123;spring.cloud.config.server.jdbc.last-modified-timestamp-sql&#125;&quot;</span>)</span> <span class="keyword">private</span> <span class="keyword">val</span> findLastModifiedTimestampSql: String,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> jdbcTemplate: JdbcTemplate,</span><br><span class="line">    properties: JdbcEnvironmentProperties</span><br><span class="line">) : JdbcEnvironmentRepository(jdbcTemplate, properties, PropertiesResultSetExtractor()) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findOne</span><span class="params">(application: <span class="type">String</span>?, profile: <span class="type">String</span>?, label: <span class="type">String</span>?, includeOrigin: <span class="type">Boolean</span>)</span></span>: Environment &#123;</span><br><span class="line">        <span class="keyword">val</span> environment = <span class="keyword">super</span>.findOne(application, profile, label, includeOrigin).apply &#123;</span><br><span class="line">            state = findLastModifiedTimestamp(application, profile, label)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> environment</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findLastModifiedTimestamp</span><span class="params">(application: <span class="type">String</span>?, profile: <span class="type">String</span>?, label: <span class="type">String</span>?)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> applicationCriteria = application ?: <span class="string">&quot;application&quot;</span></span><br><span class="line">        <span class="keyword">val</span> profileCriteria = profile ?: <span class="string">&quot;default&quot;</span></span><br><span class="line">        <span class="keyword">val</span> labelCriteria = label ?: <span class="string">&quot;master&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(findLastModifiedTimestampSql, String::<span class="keyword">class</span>.java, applicationCriteria, profileCriteria, labelCriteria)</span><br><span class="line">            ?: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>JdbcEnvironmentRepository를 상속하여 StateSupportJdbcEnvironmentRepository 라는 클래스를 만들었습니다.</li><li>super.findOne() 메서드를 호출하여 JdbcEnvironmentRepository에서 제공하는 기능을 그대로 사용하고 state 값만 채워주는 형태로 만들었습니다.</li><li>state는 db 내의 configuration 정보의 마지막 수정일자를 기준으로 state를 설정하도록 하였습니다.</li></ul><h2 id="application-yml-client-편집"><a href="#application-yml-client-편집" class="headerlink" title="application.yml (client) 편집"></a>application.yml (client) 편집</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">jdbc:</span>  </span><br><span class="line">          <span class="attr">last-modified-timestamp-sql:</span> <span class="string">select</span> <span class="string">unix_timestamp(max(modified_at))</span> <span class="string">from</span> <span class="string">remote_configurations</span> <span class="string">where</span> <span class="string">application</span> <span class="string">=</span> <span class="string">?</span> <span class="string">and</span> <span class="string">profile</span> <span class="string">=</span> <span class="string">?</span> <span class="string">and</span> <span class="string">label</span> <span class="string">=</span> <span class="string">?</span></span><br><span class="line">          <span class="attr">sql:</span> <span class="string">select</span> <span class="string">prop_key,</span> <span class="string">prop_value</span> <span class="string">from</span> <span class="string">remote_configurations</span> <span class="string">where</span> <span class="string">application=?</span> <span class="string">and</span> <span class="string">profile=?</span> <span class="string">and</span> <span class="string">label=?</span></span><br><span class="line">          <span class="attr">order:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">false</span> <span class="comment"># 중요!</span></span><br><span class="line">      <span class="attr">default-application-name:</span> <span class="string">application</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">monitor:</span></span><br><span class="line">        <span class="attr">endpoint:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/api/v1/remote-configurations</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:6028/config-server</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.mariadb.jdbc.Driver</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jdbc</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">local</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>중요한 부분을 몇가지 설명하겠습니다.</p><ul><li><code>spring.cloud.config.server.jdbc.last-modified-timestamp-sql</code><ul><li>조회하고자 하는 설정 정보의 요소 중 가장 최신일자의 timestamp를 state 값으로 사용하기 위해 작성한 쿼리 입니다</li><li>설정 정보를 변경하면 modified_at 정보가 수정되므로 변경된 state를 API 응답값으로 내려줍니다.</li><li>클라이언트에서는 state 값이 변경됨을 인지하고 context refresh를 트리거 합니다.</li></ul></li><li><code>spring.cloud.config.server.jdbc.enabled=false</code><ul><li>enabled 옵션을 false로 해야 Spring Cloud Config에서 제공하는 JdbcRepository에 대한 Auto Configuration을 설정을 off 할 수 있습니다</li><li>우리가 작성한 StateSupportJdbcEnvironmentRepository를 Spring Cloud Config 코드에서 사용하기 위한 설정입니다.</li></ul></li></ul><h2 id="여기까지-config-server를-변경하고-다시-설정-정보를-조회해-보았습니다"><a href="#여기까지-config-server를-변경하고-다시-설정-정보를-조회해-보았습니다" class="headerlink" title="여기까지 config server를 변경하고 다시 설정 정보를 조회해 보았습니다"></a>여기까지 config server를 변경하고 다시 설정 정보를 조회해 보았습니다</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request GET <span class="string">&#x27;http://config-server/jaehun-microservice-router/prod/master&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;jaehun-microservice-router&quot;</span>,</span><br><span class="line">    <span class="string">&quot;profiles&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;prod&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;label&quot;</span>: <span class="string">&quot;master&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: null,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;1646663800.373522&quot;</span>,</span><br><span class="line">    <span class="string">&quot;propertySources&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;jaehun-microservice-router-prod&quot;</span>,</span><br><span class="line">            <span class="string">&quot;source&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;routing.weight.A&quot;</span>: <span class="string">&quot;51&quot;</span>,</span><br><span class="line">                <span class="string">&quot;routing.weight.B&quot;</span>: <span class="string">&quot;49&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>이제는 state에 가장 최신 수정시각에 대한 timestamp 정보가 나오는 것을 확인할 수 있습니다.</li></ul><h1 id="주의-사항"><a href="#주의-사항" class="headerlink" title="주의 사항!!"></a>주의 사항!!</h1><p><img src="./caption.png"></p><ul><li>CompositeEnvironmentRepository에서는 backend repository가 1개인 경우에만 state 정보는 set 해줍니다.</li><li>아래와 같이 backend 설정이 2개 이상 들어가는 경우에는 state를 사용할 수 없습니다.</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jdbc</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">local</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="클라이언트에서-ConfigClientWatch를-기반으로-CustomConfigClientWatch-생성하기"><a href="#클라이언트에서-ConfigClientWatch를-기반으로-CustomConfigClientWatch-생성하기" class="headerlink" title="클라이언트에서 ConfigClientWatch를 기반으로 CustomConfigClientWatch 생성하기"></a>클라이언트에서 ConfigClientWatch를 기반으로 CustomConfigClientWatch 생성하기</h1><p>spring cloud config에서 제공하는 ConfigClientWatch는 스케줄링 주기 마다 config server에 설정 정보를 요청하는 코드가 없습니다.</p><p>따라서 아래와 같이 코드를 수정하여 CustomConfigClientWatch 클래스를 생성했습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomConfigClientWatch</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> contextRefresher: ContextRefresher,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> servicePropertySourceLocator: ConfigServicePropertySourceLocator</span><br><span class="line">) : Closeable, EnvironmentAware &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> running = AtomicBoolean(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> environment: Environment? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    running.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    running.compareAndSet(<span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setEnvironment</span><span class="params">(environment: <span class="type">Environment</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.environment = environment</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Scheduled(</span></span><br><span class="line"><span class="meta">    initialDelayString = <span class="string">&quot;\$&#123;spring.cloud.config.watch.initialDelay:180000&#125;&quot;</span>,</span></span><br><span class="line"><span class="meta">    fixedDelayString = <span class="string">&quot;\$&#123;spring.cloud.config.watch.delay:500&#125;&quot;</span></span></span><br><span class="line"><span class="meta">  )</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">watchConfigServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (running.<span class="keyword">get</span>()) &#123;</span><br><span class="line">      <span class="keyword">val</span> newState = fetchState(environment)</span><br><span class="line">      <span class="keyword">val</span> oldState = ConfigClientStateHolder.getState()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// only refresh if state has changed</span></span><br><span class="line">      <span class="keyword">if</span> (stateChanged(oldState, newState)) &#123;</span><br><span class="line">        ConfigClientStateHolder.setState(newState)</span><br><span class="line">        <span class="keyword">this</span>.contextRefresher.refresh()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchState</span><span class="params">(environment: <span class="type">Environment</span>?)</span></span>: String? &#123;</span><br><span class="line">    <span class="comment">// ConfigServicePropertySourceLocator를 통해 config server에서 설정 정보를 불러옵니다.</span></span><br><span class="line">    <span class="keyword">val</span> remoteConfigurationProperties = servicePropertySourceLocator.locate(environment)</span><br><span class="line">    <span class="keyword">return</span> remoteConfigurationProperties.getProperty(CONFIG_CLIENT_STATE_KEY)?.toString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">stateChanged</span><span class="params">(oldState: <span class="type">String</span>?, newState: <span class="type">String</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !newState.isNullOrBlank() &amp;&amp; oldState != newState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> CONFIG_CLIENT_STATE_KEY = <span class="string">&quot;config.client.state&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>val newState = fetchState(environment)</code> 코드를 수정해 스케줄링 주기 마다 config server로 부터 설정을 불러오도록 합니다.</li><li>servicePropertySourceLocator.locate 로직에 의해 config server에서 받은 응답 중 state 값을 config.client.state 프로퍼티에 바인딩 합니다.</li><li>config server에서 설정 정보가 변경된 경우 현재 메모리에 저장된 oldState와 비교하여 다른 경우 context refresh를 호출합니다.</li></ul><h1 id="application-yml-client-설정-수정하기"><a href="#application-yml-client-설정-수정하기" class="headerlink" title="application.yml (client) 설정 수정하기"></a>application.yml (client) 설정 수정하기</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">import:</span> <span class="string">&quot;optional:configserver:http://localhost:8080&quot;</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment"># 추가된 기능</span></span><br><span class="line">      <span class="attr">watch:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span> <span class="comment"># spring cloud config에서 제공하는 ConfigClientWatch 사용x </span></span><br><span class="line">        <span class="attr">initialDelay:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">aehun-microservice-router</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">true</span> </span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="number">1000</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1.1</span></span><br><span class="line">      <span class="attr">request-connect-timeout:</span> <span class="number">2000</span></span><br><span class="line">      <span class="attr">request-read-timeout:</span> <span class="number">10000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>spring.cloud.config.watch.enabled=false</code><ul><li>위의 설정을 통해 명시적으로 spring cloud config에서 제공하는 ConfigClientWatch 사용하지 않도록 설정했습니다.</li></ul></li></ul><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>spring cloud config에서 제공하는 ConfigClientWatch라는 기능을 사용하고자 했으나, vault, native backend에서만 지원하였습니다.</li><li>JDBC Backend를 사용하기 때문에 Config Server에서 state 정보를 넣어 줄 수 있는 StateSupportJdbcEnvironmentRepository를 생성하였습니다..</li><li>state 정보는 값이 변경되면 갱신됨을 알리기 위해 쿼리된 결과의 modified_at 정보 중 가장 최신 값을 사용하였습니다.</li><li>클라이언트에서는 CustomConfigClientWatch를 생성하고 ConfigServicePropertySourceLocator를 통해 주기적으로 config server의 설정 값을 불러오도록 코드를 수정하였습니다.</li><li>주기적으로 불러오는 config server의 state 값을 확인하고 메모리 상의 state와 다른 경우 context refresher가 동작하도록 하였습니다.</li><li>위와 같은 설정을 통해 JDBC Backend를 사용하면서도 주기적으로 클라이언트에서 config server의 설정 정보를 가져와 property 정보를 변경할 수 있었습니다.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Config Monitor 시작하기</title>
      <link href="/2022/03/10/2022-03-11-spring-cloud-config-monitor/"/>
      <url>/2022/03/10/2022-03-11-spring-cloud-config-monitor/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>해당 글에서 사용한 예제의 버전 정보는 아래와 같습니다</p><ul><li>kotlin 1.6.0</li><li>Spring Boot 2.6.3</li><li>Spring Cloud Dependencies 2021.0.1</li></ul><p>Spring Cloud Config 관련 글은 총 4개의 글로 작성되었습니다.</p><ul><li><a href="../2022-03-11-spring-cloud-config">Spring Cloud Config 시작하기</a></li><li><a href="../2022-03-11-spring-cloud-bus">Spring Cloud Bus 시작하기</a></li><li><strong>Spring Cloud Config Monitor 시작하기</strong></li><li><a href="../2022-03-11-spring-cloud-config-polling">Spring Cloud Config 주기적으로 Polling 하기</a></li></ul><h1 id="Spring-Cloud-Config-Monitor"><a href="#Spring-Cloud-Config-Monitor" class="headerlink" title="Spring Cloud Config Monitor"></a>Spring Cloud Config Monitor</h1><p><img src="./spring-cloud-monitor.jpg"></p><ul><li><code>spring-cloud-config-monitor</code> 를 dependency에 추가하고 spring cloud bus를 활성화 하면<br><code>/monitor</code> endpoint가 활성화 됩니다.</li><li>&#x2F;monitor 엔드포인트를 통해 갱신된 client에 대한 이벤트를 전파할 수 있습니다.</li><li>특정 클라이언트에만 이벤트 갱신 요청을 보낼 수 있습니다.</li></ul><h1 id="설정하기"><a href="#설정하기" class="headerlink" title="설정하기"></a>설정하기</h1><h2 id="1-build-gradle"><a href="#1-build-gradle" class="headerlink" title="1. build.gradle"></a>1. build.gradle</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies <span class="punctuation">&#123;</span></span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.cloud:spring-cloud-config-server&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.boot:spring-boot-starter-jdbc&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.cloud:spring-cloud-config-monitor&quot;</span>)</span><br><span class="line">  implementation(<span class="string">&quot;org.springframework.cloud:spring-cloud-starter-bus-kafka&quot;</span>)</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>config-server 애플리케이션에 spring-cloud-config-monitor 의존성을 추가합니다.</li></ul><h2 id="2-application-yml"><a href="#2-application-yml" class="headerlink" title="2. application.yml"></a>2. application.yml</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">bus:</span></span><br><span class="line">      <span class="attr">destination:</span> <span class="string">jaehun-platform.prod.event.config-event.json</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment"># 추가된 부분</span></span><br><span class="line">      <span class="attr">monitor:</span></span><br><span class="line">        <span class="attr">endpoint:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/api/v1/remote-configurations</span> </span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">jdbc:</span></span><br><span class="line">          <span class="attr">sql:</span> <span class="string">select</span> <span class="string">prop_key,</span> <span class="string">prop_value</span> <span class="string">from</span> <span class="string">remote_configurations</span> <span class="string">where</span> <span class="string">application=?</span> <span class="string">and</span> <span class="string">profile=?</span> <span class="string">and</span> <span class="string">label=?</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/config-server</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">&lt;database-username&gt;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&lt;database-password&gt;</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.mariadb.jdbc.Driver</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jdbc</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">local</span></span><br><span class="line">  <span class="comment"># 추가된 부분</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="string">http://localhost:9092</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>spring cloud config monitor의 기본 endpoint는 &#x2F;monitor 입니다.<ul><li>하지만 다른 엔드포인트와 헷갈리지 않도록 <code>spring.cloud.config.monitor.endpoint.path</code>를 추가하여 prefix를 선언하여 사용합니다.</li><li>위의 설정대로 하면 monitor 엔드포인트는 <code>/api/v1/remote-configurations/monitor</code> 가 됩니다</li></ul></li></ul><h2 id="monitor-엔드포인트는-어떻게-생겼을까"><a href="#monitor-엔드포인트는-어떻게-생겼을까" class="headerlink" title="monitor 엔드포인트는 어떻게 생겼을까?"></a>monitor 엔드포인트는 어떻게 생겼을까?</h2><p><img src="./monitor-endpoint.png"></p><ul><li>PropertyPathEndpoint라는 클래스에서 endpoint를 제공합니다.</li><li>notifyByPath라는 메서드에서 &#x2F;monitor에 대한 요청을 처리합니다.</li></ul><h2 id="monitor-endpoint를-요청해봅시다"><a href="#monitor-endpoint를-요청해봅시다" class="headerlink" title="monitor endpoint를 요청해봅시다."></a>monitor endpoint를 요청해봅시다.</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request POST <span class="string">&#x27;http://config-server/api/v1/remote-configurations/monitor&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>단순하게 config server에 POST 메서드로 <code>/api/v1/remote-configurations/monitor</code> 엔드포인트를 요청했습니다.</li></ul><p>하지만 kafka topic에 아무것도 퍼블리싱된 이벤트가 없습니다 왜그럴까요?</p><h2 id="notifyByPath-코드에-집중해-봅시다"><a href="#notifyByPath-코드에-집중해-봅시다" class="headerlink" title="notifyByPath 코드에 집중해 봅시다."></a>notifyByPath 코드에 집중해 봅시다.</h2><p><img src="./notifyByPath.png"></p><p><span style="color:green;background:black"><b>초록색</b></span> → <span style="color:yellow;background:black"><b>노란색</b></span> → <span style="color:red;background:black"><b>빨간색</b></span> 박스 순으로 보겠습니다.</p><ul><li>초록색 박스를 보면 우리가 생각하는 RefreshRemoteApplicationEvent를 발행합니다.<ul><li>이 이벤트가 각 클라이언트에 전파되어 context refresh를 트리거 해줍니다.</li><li>하지만 이벤트를 발행하려면 service라는 String 값이 필요한 것 같습니다.</li></ul></li><li>노란색 박스를 보면 notification이라는 객체에서 path를 추출하여 service를 생성하고 있습니다.</li><li>빨간색 박스를 보면 extrator라는 객체를 이용하여 header와 request body 내용을 토대로 notification을 생성합니다.</li></ul><p>자 그럼 extractor는 뭘까요?</p><h1 id="PropertyPathNotificationExtractor를-주목해-봅시다"><a href="#PropertyPathNotificationExtractor를-주목해-봅시다" class="headerlink" title="PropertyPathNotificationExtractor를 주목해 봅시다."></a>PropertyPathNotificationExtractor를 주목해 봅시다.</h1><p><img src="./PropertyPathNotificationExtractor.png"></p><ul><li>주석에는 request와 headers를 통해 notifiation을 제공한다고 되어 있네요</li></ul><p><img src="./PropertyPathNotificationExtractor2.png"></p><ul><li>notifyByPath에 디버그를 걸어보면 extrator는 CompositePropertyPathNotification이라는 타입의 객체 입니다.</li><li>클래스명에서 유추할 수 있듯이 PropertyPathNotificationExtractor에 대한 구현체가 List 형태로 있습니다.</li><li>보아하니 github, gitlab, gitee, bit bucket등에 대한 다양한 webhook 요청에 대해 처리하는 구현체로 보입니다.</li></ul><p>우리는 직접 endpoint를 호출하려고 하기 때문에 2번째 객체인 SimplePropertyPathNotificationExtractor를 통해 path를 지정해 보겠습니다.</p><h2 id="SimplePropertyPathNotificationExtractor-살펴보기"><a href="#SimplePropertyPathNotificationExtractor-살펴보기" class="headerlink" title="SimplePropertyPathNotificationExtractor 살펴보기"></a>SimplePropertyPathNotificationExtractor 살펴보기</h2><p><img src="./SimplePropertyPathNotificationExtractor.png"></p><ul><li>SimplePropertyPathNotificationExtractor는 request body에 있는 path라는 프로퍼티를 읽습니다.</li><li>path에 대한 타입이 String 인 경우에는 단일 값만 <code>PropertyPathNotification</code> 으로 리턴합니다.</li><li>path에 대한 타입이 Collection인 경우에는 Collection을 담아 <code>PropertyPathNotification</code> 으로 리턴합니다.</li></ul><h2 id="다시-요청하기"><a href="#다시-요청하기" class="headerlink" title="다시 요청하기"></a>다시 요청하기</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request POST <span class="string">&#x27;http://config-server/api/v1/remote-configurations/monitor&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;path&quot; : [</span></span><br><span class="line"><span class="string">        &quot;**&quot;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>path를 <code>**</code> 으로 요청하여 모든 클라이언트에게 이벤트를 전파 시켜 보겠습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;RefreshRemoteApplicationEvent&quot;</span>,</span><br><span class="line">        <span class="string">&quot;timestamp&quot;</span>: 1646660036164,</span><br><span class="line">        <span class="string">&quot;originService&quot;</span>: <span class="string">&quot;jaehun-microservice-admin:0:config-server&quot;</span>,</span><br><span class="line">        <span class="string">&quot;destinationService&quot;</span>: <span class="string">&quot;**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;11fd441b-1840-44c0-be7a-f63acc0a55e5&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;AckRemoteApplicationEvent&quot;</span>,</span><br><span class="line">        <span class="string">&quot;timestamp&quot;</span>: 1646660037787,</span><br><span class="line">        <span class="string">&quot;originService&quot;</span>: <span class="string">&quot;jaehun-microservice-admin:0:config-server&quot;</span>,</span><br><span class="line">        <span class="string">&quot;destinationService&quot;</span>: <span class="string">&quot;**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;6d11a58d-ed98-4725-b388-9854239f65fe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ackId&quot;</span>: <span class="string">&quot;11fd441b-1840-44c0-be7a-f63acc0a55e5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ackDestinationService&quot;</span>: <span class="string">&quot;**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;event&quot;</span>: <span class="string">&quot;org.springframework.cloud.bus.event.RefreshRemoteApplicationEvent&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;AckRemoteApplicationEvent&quot;</span>,</span><br><span class="line">        <span class="string">&quot;timestamp&quot;</span>: 1646660038649,</span><br><span class="line">        <span class="string">&quot;originService&quot;</span>: <span class="string">&quot;jaehun-microservice-router:8082:client1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;destinationService&quot;</span>: <span class="string">&quot;**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;861376bf-c221-4222-9f96-7c03bd546cb7&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ackId&quot;</span>: <span class="string">&quot;11fd441b-1840-44c0-be7a-f63acc0a55e5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ackDestinationService&quot;</span>: <span class="string">&quot;**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;event&quot;</span>: <span class="string">&quot;org.springframework.cloud.bus.event.RefreshRemoteApplicationEvent&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;AckRemoteApplicationEvent&quot;</span>,</span><br><span class="line">        <span class="string">&quot;timestamp&quot;</span>: 1646660038652,</span><br><span class="line">        <span class="string">&quot;originService&quot;</span>: <span class="string">&quot;jaehun-microservice-router:8083:client2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;destinationService&quot;</span>: <span class="string">&quot;**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;e416ee3e-bfc3-4caa-9135-dd6736f10e87&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ackId&quot;</span>: <span class="string">&quot;11fd441b-1840-44c0-be7a-f63acc0a55e5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ackDestinationService&quot;</span>: <span class="string">&quot;**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;event&quot;</span>: <span class="string">&quot;org.springframework.cloud.bus.event.RefreshRemoteApplicationEvent&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>config-server가 &#x2F;monitor 엔드포인트를 통해 RefreshRemoteApplicationEvent를 kafka에 퍼블리싱 했습니다.</li><li>위에서 부터 순서대로 config-server, client1, client2에서 이벤트를 수신했다고 ack를 퍼블리싱 합니다.</li><li>확인 하니 모든 클라이언트에서 context refresh가 발생함을 확인했습니다.</li></ul><h1 id="특정-클라이언트에만-이벤트-발행하기"><a href="#특정-클라이언트에만-이벤트-발행하기" class="headerlink" title="특정 클라이언트에만 이벤트 발행하기"></a>특정 클라이언트에만 이벤트 발행하기</h1><p>하나의 설정이 변경되었을 때 모든 클라이언트에 대해 context refresh가 발생한다면 상당히 비효율적 입니다.<br>변경이 발생한 프로퍼티의 대상 클라이언트에만 context refresh가 발생하도록 해보겠습니다.</p><p>만약 변경이 발생한 프로퍼티의 application이 jaehun-microservice-router 인 경우 아래와 같이 path 부분에 파라미터를 설정합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request POST <span class="string">&#x27;http://config-server/api/v1/remote-configurations/monitor&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;path&quot; : [</span></span><br><span class="line"><span class="string">        &quot;jaehun-microservice-router:**&quot;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RefreshRemoteApplicationEvent&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1646661367607</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-admin:0:config-server&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;destinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun:microservice-router:**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9517ae59-00d6-4911-945d-0ca34f84c2e9&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RefreshRemoteApplicationEvent&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1646661367611</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-admin:0:config-server&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;destinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice:router:**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;e5db510b-9b49-4aa5-b94e-935ba4658b40&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RefreshRemoteApplicationEvent&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1646661367612</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-admin:0:config-server&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;destinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-platform-router:**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;14c184ec-5700-491e-88b0-8f6282657473&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AckRemoteApplicationEvent&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1646661367828</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router:8082:client1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;destinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;846110db-fd9c-4c70-8b11-9a4f89a018f4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;14c184ec-5700-491e-88b0-8f6282657473&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackDestinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router:**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.cloud.bus.event.RefreshRemoteApplicationEvent&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AckRemoteApplicationEvent&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1646661367848</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router:8083:client2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;destinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;e942b045-a126-4c57-b7e8-54bf327d307f&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;14c184ec-5700-491e-88b0-8f6282657473&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackDestinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router:**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.cloud.bus.event.RefreshRemoteApplicationEvent&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>RefreshRemoteApplicationEvent가 3번 발생하였습니다.<ul><li>jaehun:microservice-router:**</li><li>jaehun-microservice:router:**</li><li>jaehun-microservice-router:**</li></ul></li><li>이유는 위의 노란색 박스 코드에서 guessServiceName이라는 함수 실행 시 대시(-)를 구분자로 하여 모든 케이스에 대한 서비스를 추출하기 때문입니다.<ul><li>따라서 가급적 application name에 대시를 넣지 않는게 좋습니다.</li></ul></li></ul><p>ack 이벤트를 보겠습니다.</p><ul><li>ack 응답을 준 애플리케이션은 2개 입니다.<ul><li>originServicer가 <code>jaehun-microservice-router</code> 로 시작하는 애플리케이션 2개 입니다.</li></ul></li><li>따라서 전체 클라이언트가 아닌 jaehun-microservice-router 애플리케이션에만 context refresh가 일어나는 것을 확인할 수 있습니다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://docs.spring.io/spring-cloud-config/docs/3.0.3/reference/html/">https://docs.spring.io/spring-cloud-config/docs/3.0.3/reference/html/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Bus 시작하기</title>
      <link href="/2022/03/10/2022-03-11-spring-cloud-bus/"/>
      <url>/2022/03/10/2022-03-11-spring-cloud-bus/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>해당 글에서 사용한 예제의 버전 정보는 아래와 같습니다</p><ul><li>kotlin 1.6.0</li><li>Spring Boot 2.6.3</li><li>Spring Cloud Dependencies 2021.0.1</li></ul><p>Spring Cloud Config 관련 글은 총 4개의 글로 작성되었습니다.</p><ul><li><a href="../2022-03-11-spring-cloud-config">Spring Cloud Config 시작하기</a></li><li><strong>Spring Cloud Bus 시작하기</strong></li><li><a href="../2022-03-11-spring-cloud-config-monitor">Spring Cloud Config Monitor 시작하기</a></li><li><a href="../2022-03-11-spring-cloud-config-polling">Spring Cloud Config 주기적으로 Polling 하기</a></li></ul><h1 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h1><p><img src="./spring-cloud-bus.png"></p><ul><li>하나의 클라이언트에서 context refresh가 발생하게 되면 Message Broker를 통해 이벤트를 다른 클라이언트에 전파합니다.</li><li>이벤트를 수신한 다른 클라이언트도 context refresh를 수행하게 되어 모든 클라이언트에 대해 context refresh가 일어나게 됩니다.</li><li>Spring cloud config bus는 AMQP를 사용하여 Message Broker를 통해 이벤트를 fan-out 합니다.<br>kafka, rabbitmq와 같은 Message Broker를 지원합니다.</li></ul><h1 id="설정하기"><a href="#설정하기" class="headerlink" title="설정하기"></a>설정하기</h1><h2 id="1-build-gradle"><a href="#1-build-gradle" class="headerlink" title="1. build.gradle"></a>1. build.gradle</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation(<span class="string">&quot;org.springframework.cloud:spring-cloud-starter-bus-kafka&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>spring-cloud-starter-bus-kafka<ul><li>kafka를 이용해 spring cloud bus를 사용하기 위해 추가합니다.</li><li>config client, server에 모두 추가합니다.</li></ul></li></ul><h2 id="2-application-yml-config-server"><a href="#2-application-yml-config-server" class="headerlink" title="2. application.yml (config-server)"></a>2. application.yml (config-server)</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># 추가된 부분</span></span><br><span class="line">    <span class="attr">bus:</span></span><br><span class="line">      <span class="attr">destination:</span> <span class="string">jaehun-platform.prod.event.config-event.json</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">jdbc:</span></span><br><span class="line">          <span class="attr">sql:</span> <span class="string">select</span> <span class="string">prop_key,</span> <span class="string">prop_value</span> <span class="string">from</span> <span class="string">remote_configurations</span> <span class="string">where</span> <span class="string">application=?</span> <span class="string">and</span> <span class="string">profile=?</span> <span class="string">and</span> <span class="string">label=?</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/config-server</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">&lt;database-username&gt;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&lt;database-password&gt;</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.mariadb.jdbc.Driver</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jdbc</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">local</span></span><br><span class="line">  <span class="comment"># 추가된 부분</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="string">http://localhost:9092</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>spring.cloud.bus.destination</code><ul><li>이벤트를 전파 할 kafka topic을 지정합니다.</li></ul></li><li><code>spring.kafka.bootstrap-servers</code><ul><li>이벤트를 전파 할 카프카 클러스터 주소를 지정합니다.</li></ul></li></ul><h2 id="3-application-yml-client"><a href="#3-application-yml-client" class="headerlink" title="3. application.yml (client)"></a>3. application.yml (client)</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;refresh, busrefresh&quot;</span> <span class="comment"># 추가된 부분</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">import:</span> <span class="string">&quot;optional:configserver:http://localhost:8080&quot;</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">jaehun-microservice-router</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">true</span> </span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="number">1000</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1.1</span></span><br><span class="line">      <span class="attr">request-connect-timeout:</span> <span class="number">2000</span></span><br><span class="line">      <span class="attr">request-read-timeout:</span> <span class="number">10000</span></span><br><span class="line">    <span class="comment"># 추가된 부분</span></span><br><span class="line">    <span class="attr">bus:</span></span><br><span class="line">      <span class="attr">destination:</span> <span class="string">jaehun-platform.prod.event.config-event.json</span></span><br><span class="line"> <span class="attr">kafka:</span></span><br><span class="line">   <span class="attr">bootstrap-servers:</span> <span class="string">http://localhost:9092</span></span><br></pre></td></tr></table></figure><ul><li><code>management.endpoints.web.exposure.include=refresh, busrefresh</code><ul><li>busrefresh 엔드포인트를 노출하기 위해 추가하였습니다.</li><li>spring boot 2.4 미만 버전에서는 bus-refresh 엔드포인트를 사용합니다.</li></ul></li><li><code>spring.cloud.bus.destination</code><ul><li>이벤트를 전파 받을 kafka topic을 지정합니다.</li></ul></li><li><code>spring.kafka.bootstrap-servers</code><ul><li>이벤트를 전파 받을 카프카 클러스터 주소를 지정합니다.</li></ul></li></ul><h1 id="하나의-클라이언트에-context-refresh를-해보겠습니다"><a href="#하나의-클라이언트에-context-refresh를-해보겠습니다" class="headerlink" title="하나의 클라이언트에 context refresh를 해보겠습니다"></a>하나의 클라이언트에 context refresh를 해보겠습니다</h1><p>호기롭게 <code>POST http://client1/actuator/refresh</code> API를 호출 해보았습니다.<br>1번 클라이언트는 잘 갱신이 되었습니다.<br>그러나…. 2번 클라이언트은 갱신이 안되었고, kafka topic에도 아무런 이벤트가 발생하지 않았습니다.</p><p>무슨 이유일까요?</p><p><code>POST http://client1/actuator/refresh</code> 도 클라이언트에 대한 context refresh를 수행해 주지만,<br>RefreshRemoteApplicationEvent를 Message Broker에 퍼블리싱 하지 않습니다.<br>그렇기 때문에 다른 클라이언트는 설정이 갱신이 되지 않았던 것입니다.</p><h2 id="다시-클라이언트에-context-refresh를-해보겠습니다"><a href="#다시-클라이언트에-context-refresh를-해보겠습니다" class="headerlink" title="다시! 클라이언트에 context refresh를 해보겠습니다."></a>다시! 클라이언트에 context refresh를 해보겠습니다.</h2><p>이번엔 <code>POST /actuator/busrefresh</code> 라는 API를 호출해 보았습니다.<br>이번에도 클라이언트1은 갱신이 잘됐습니다.<br>아까와는 다르게 클라이언트1만 갱신했는데 클라이언트2도 갱신이 되었습니다!<br>kafka topic을 컨슘해보니 처음보는 데이터가 들어와 있습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RefreshRemoteApplicationEvent&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1646330617969</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router:8082:client1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;destinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;89a4d1b7-308d-4915-bcd4-a839eb273db8&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AckRemoteApplicationEvent&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1646330618104</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router:8082:client1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;destinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7a0fa52e-b00a-4bba-b8b1-40be1e33d05e&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;89a4d1b7-308d-4915-bcd4-a839eb273db8&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackDestinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.cloud.bus.event.RefreshRemoteApplicationEvent&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AckRemoteApplicationEvent&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1646330618180</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-admin:0:config-server&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;destinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fbd9eba6-f0af-461a-8f99-fe5cb218a125&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;89a4d1b7-308d-4915-bcd4-a839eb273db8&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackDestinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.cloud.bus.event.RefreshRemoteApplicationEvent&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AckRemoteApplicationEvent&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1646330618343</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router:8083:client2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;destinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8958eee4-8c58-4a01-ae36-8be09e66c60b&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;89a4d1b7-308d-4915-bcd4-a839eb273db8&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackDestinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.cloud.bus.event.RefreshRemoteApplicationEvent&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>첫번째 데이터는 클라이언트1에서 <code>RefreshRemoteApplicationEvent</code> 를 publish 했습니다.</li><li>두번째 데이터는 클라이언트1에서 RefreshRemoteApplicationEvent를 수신했다고 ack 이벤트를 publish 해주었습니다.</li><li>세번째 데이터는 config-server에서도 RefreshRemoteApplicationEvent를 수신했다고 ack 이벤트를 publish 해주었습니다.</li><li>네번째 데이터는 클라이언트2에서 RefreshRemoteApplicationEvent를 수신했다고 ack 이벤트를 publish 해주었습니다.</li></ul><p>이렇게 클라이언트1에만 갱신 요청을 해도 kafka로 연결된 모든 클라이언트에 이벤트가 전송되었고 ack 응답까지 kafka로 발행해 주었습니다.</p><p>여기서 이상한 점은 config-server도 ack를 하였다는 것인데요.<br>config-server는 RefreshRemoteApplicationEvent를 수신해도 클라이언트가 아니기 때문에 context refresh를 수행하지 않습니다.<br>config-server에는 이벤트를 적용하지 않는 방법은 없을까요?</p><h1 id="특정-애플리케이션만-갱신하기"><a href="#특정-애플리케이션만-갱신하기" class="headerlink" title="특정 애플리케이션만 갱신하기"></a>특정 애플리케이션만 갱신하기</h1><p>busrefresh 엔드포인트는 기본 &#x2F;busrefresh 엔드포인트를 제공할 뿐만 아니라 destination 정보를 싣을 수 있는 엔드포인트를 제공합니다.</p><p><img src="./busrefresh.png"></p><ul><li>바로 &#x2F;actuator&#x2F;busrefresh&#x2F;<destination> 엔드포인트입니다.</li><li>이 엔드포인트는 아래처럼 사용할 수 있습니다.<ul><li><code>/actuator/busrefresh/jaehun-microservice-router:8080:client1</code><ul><li>정확히 originService명이 jaehun-microservice-router:8080:client1 인 클라이언트에서만 갱신이 일어나도록 합니다.</li></ul></li><li><code>/actuator/busrefresh/jaehun-microservice-router:8080</code><ul><li>originService명이 jaehun-microservice-router:8080:* 인 모든 클라이언트에서 갱신이 일어나도록 합니다.</li></ul></li><li><code>/actuator/busrefresh/jaehun-microservice-router</code><ul><li>originService명이 jaehun-microservice-router:** 인 모든 클라이언트에서 갱신이 일어나도록 합니다.</li></ul></li></ul></li></ul><h2 id="한번-x2F-actuator-x2F-busrefresh-x2F-jaehun-microservice-router를-호출해-보겠습니다"><a href="#한번-x2F-actuator-x2F-busrefresh-x2F-jaehun-microservice-router를-호출해-보겠습니다" class="headerlink" title="한번 &#x2F;actuator&#x2F;busrefresh&#x2F;jaehun-microservice-router를 호출해 보겠습니다"></a>한번 &#x2F;actuator&#x2F;busrefresh&#x2F;jaehun-microservice-router를 호출해 보겠습니다</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RefreshRemoteApplicationEvent&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1646331274095</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router:8082:client1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;destinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router:**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4cb61bac-25d1-43a8-bbba-54abdeaa7c91&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AckRemoteApplicationEvent&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1646331276053</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router:8083:client2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;destinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0dea6ac2-466e-454f-9967-d1dc38efd77d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4cb61bac-25d1-43a8-bbba-54abdeaa7c91&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackDestinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router:**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.cloud.bus.event.RefreshRemoteApplicationEvent&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AckRemoteApplicationEvent&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1646331277227</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router:8082:client1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;destinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dde95a89-0e35-4c33-a1eb-08574520e606&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4cb61bac-25d1-43a8-bbba-54abdeaa7c91&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ackDestinationService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jaehun-microservice-router:**&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.cloud.bus.event.RefreshRemoteApplicationEvent&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>destination이 jaehun-microservice-router로 시작하는 클라이언트에서만 ack 응답이 온 것을 확인할 수 있습니다.</li><li>내부적으로 destination name에 대한 regex 매칭을 통해 이름 형식이 맞는 지 확인 후 context refresh를 실행하게 됩니다.</li></ul><h1 id="질문-있어요"><a href="#질문-있어요" class="headerlink" title="질문 있어요~!"></a>질문 있어요~!</h1><h2 id="destination-service의-이름은-어떻게-지어지나요"><a href="#destination-service의-이름은-어떻게-지어지나요" class="headerlink" title="destination service의 이름은 어떻게 지어지나요?"></a>destination service의 이름은 어떻게 지어지나요?</h2><p>spring cloud bus를 사용하는 클라이언트의 destination 이름은 아래의 링크를 확인 부탁 드립니다.</p><p><a href="https://docs.spring.io/spring-cloud-bus/docs/current/reference/html/#addressing-an-instance">https://docs.spring.io/spring-cloud-bus/docs/current/reference/html/#addressing-an-instance</a></p><p>요약하자면..</p><p><code>&#123;spring.application.name&#125;:&#123;server.port&#125;:&#123;vcap.application.instance_id&#125;</code> 의 형태로 지어 집니다.</p><ul><li><code>vcap.application.instance_id</code> 환경 변수가 없는 경우 랜덤한 문자열이 들어갑니다.</li></ul><h1 id="Spring-Cloud-Bus의-기능을-살펴보았습니다"><a href="#Spring-Cloud-Bus의-기능을-살펴보았습니다" class="headerlink" title="Spring Cloud Bus의 기능을 살펴보았습니다."></a>Spring Cloud Bus의 기능을 살펴보았습니다.</h1><p><img src="./programmer-chaos.jpg"></p><p>근데 말이죠…<br>클라이언트 모듈에 대한 host와 endpoint를 따로 관리하지 않고 있기 때문에<br>프로퍼티 정보 갱신 후 클라이언트 1개에 &#x2F;actuator&#x2F;busrefresh를 호출하기가 어렵습니다.<br>어떻게 하면 좋을까요?</p><p>이런 고통과 고민을 덜어주기 위해 다음 글에서는 Spring Cloud Config Monitor라는 기능을 소개합니다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://docs.spring.io/spring-cloud-bus/docs/current/reference/html/">https://docs.spring.io/spring-cloud-bus/docs/current/reference/html/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> Spring Cloud Config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Config 시작하기</title>
      <link href="/2022/03/10/2022-03-11-spring-cloud-config/"/>
      <url>/2022/03/10/2022-03-11-spring-cloud-config/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>해당 글에서 사용한 예제의 버전 정보는 아래와 같습니다</p><ul><li>kotlin 1.6.0</li><li>Spring Boot 2.6.3</li><li>Spring Cloud Dependencies 2021.0.1</li></ul><p>Spring Cloud Config 관련 글은 총 4개의 글로 작성되었습니다.</p><ul><li><strong>Spring Cloud Config 시작하기</strong></li><li><a href="../2022-03-11-spring-cloud-bus">Spring Cloud Bus 시작하기</a></li><li><a href="../2022-03-11-spring-cloud-config-monitor">Spring Cloud Config Monitor 시작하기</a></li><li><a href="../2022-03-11-spring-cloud-config-polling">Spring Cloud Config 주기적으로 Polling 하기</a></li></ul><h1 id="Spring-Cloud-Config란"><a href="#Spring-Cloud-Config란" class="headerlink" title="Spring Cloud Config란"></a>Spring Cloud Config란</h1><p>Spring Cloud Config는 분산 시스템에서 remote configuration을 제공합니다.</p><p>Config Server-Client의 구조로 이루어져 있습니다. </p><p><img src="./spring-cloud-config1.png"></p><h1 id="Spring-Cloud-Config-Server"><a href="#Spring-Cloud-Config-Server" class="headerlink" title="Spring Cloud Config Server"></a>Spring Cloud Config Server</h1><p>Config Server는 remote configuration을 HTTP API로 제공합니다.</p><h2 id="Spring-Cloud-Config에서-지원하는-Backend-저장소"><a href="#Spring-Cloud-Config에서-지원하는-Backend-저장소" class="headerlink" title="Spring Cloud Config에서 지원하는 Backend 저장소"></a>Spring Cloud Config에서 지원하는 Backend 저장소</h2><p>spring cloud config에서는 Backend 저장소로 다양한 시스템을 지원합니다.</p><ul><li>git (가장 많이 사용되는 repository 입니다.)</li><li>File System</li><li>Vault</li><li>JDBC (이번 프로젝트에서는 시스템에서 설정을 용이하게 변경하기 위해 JDBC를 사용했습니다)</li><li>Redis</li><li>AWS S3</li><li>CrudHub</li></ul><h2 id="설정-방법"><a href="#설정-방법" class="headerlink" title="설정 방법"></a>설정 방법</h2><h3 id="1-build-gradle-의존성-추가"><a href="#1-build-gradle-의존성-추가" class="headerlink" title="1. build.gradle 의존성 추가"></a>1. build.gradle 의존성 추가</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.cloud:spring-cloud-starter-config&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.cloud:spring-cloud-config-server&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.boot:spring-boot-starter-jdbc&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>spring-cloud-starter-config, spring-cloud-config-server<ul><li>spring cloud config server 구현을 위해 의존성을 추가합니다.</li></ul></li><li>spring-boot-starter-jdbc<ul><li>JDBC Backend 사용을 위해 의존성을 추가합니다.</li></ul></li></ul><h3 id="2-코드-구성"><a href="#2-코드-구성" class="headerlink" title="2. 코드 구성"></a>2. 코드 구성</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;ConfigServerApplication&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@EnableConfigServer</code> 어노테이션을 선언하여 Config Server 기능이 동작하도록 합니다.</li></ul><h3 id="3-Properties-Table-추가"><a href="#3-Properties-Table-추가" class="headerlink" title="3. Properties Table 추가"></a>3. Properties Table 추가</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> remote_configurations</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">integer</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    application <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    profile     <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    label       <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    prop_key    <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    prop_value  <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    created_at  datetime(<span class="number">6</span>) <span class="keyword">default</span> now(<span class="number">6</span>),</span><br><span class="line">    modified_at datetime(<span class="number">6</span>) <span class="keyword">default</span> now(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">primary</span> key (id)</span><br><span class="line">) engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><ul><li>application: 프로퍼티가 적용될 application의 이름입니다. (ex. jaehun-config-admin)</li><li>profile: 프로퍼티가 적용될 profile 입니다 (ex. dev, beta, prod)</li><li>label: 프로퍼티를 적용한 label 입니다.  기본값은 master입니다.</li><li>prop_key: 프로퍼티 key 입니다.</li><li>prop_value: 프로퍼티 value 입니다.</li><li>created_at: 프로퍼티의 생성 시각입니다.</li><li>modified_at: 프로퍼티의 수정 시각입니다.</li></ul><h3 id="4-application-yml-설정"><a href="#4-application-yml-설정" class="headerlink" title="4. application.yml 설정"></a>4. application.yml 설정</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">jdbc:</span></span><br><span class="line">          <span class="attr">sql:</span> <span class="string">select</span> <span class="string">prop_key,</span> <span class="string">prop_value</span> <span class="string">from</span> <span class="string">remote_configurations</span> <span class="string">where</span> <span class="string">application=?</span> <span class="string">and</span> <span class="string">profile=?</span> <span class="string">and</span> <span class="string">label=?</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/config-server</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">&lt;database-username&gt;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&lt;database-password&gt;</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.mariadb.jdbc.Driver</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jdbc</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">local</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>spring.cloud.config.enabled=true</code> : remote configuration을 사용합니다.</li><li><code>spring.cloud.config.server.jdbc.enabled=true</code> : spring cloud config server에서 jdbc backend를 사용합니다.</li><li><code>spring.cloud.config.server.jdbc.sql</code> : config 조회 요청 시,  application, profile, label을 파라미터로 수행하는 쿼리입니다.<ul><li>이 쿼리의 실행 결과로 나온 프로퍼티가 client에 전달됩니다.</li></ul></li><li><code>spring.datasource.*</code> : remote configuration에 대한 Datasource를 정의합니다.</li><li><code>spring.profiles.active=jdbc</code> JDBC Backend를 사용하기 위해 active profiles에 추가합니다.</li></ul><h2 id="Config-Server에서-어떤-API로-configuration-properties를-조회하나요"><a href="#Config-Server에서-어떤-API로-configuration-properties를-조회하나요" class="headerlink" title="Config Server에서 어떤 API로 configuration properties를 조회하나요?"></a>Config Server에서 어떤 API로 configuration properties를 조회하나요?</h2><p><code>spring-cloud-config-server</code> 의존성을 추가하게 되면 <code>EnvironmentController</code> 가 생성되어 properties 조회를 위한 API를 제공합니다. (이외에도 더 많습니다)</p><p><img src="./EnvironmentController.png"></p><ul><li>대표적으로 사용하는 API는 <code>/&#123;application-name&#125;/&#123;profile&#125;/&#123;label&#125;</code> 로 이루어진 API를 사용합니다. (ex. GET http:&#x2F;&#x2F;<config-server-url>&#x2F;jaehun-microservice-router&#x2F;prod&#x2F;master)</li><li>위의 endpoint로 요청하게 되면 내부적으로 backend 저장소에 저장된 application, profile, label에 부합하는 설정 값을 리턴하게 됩니다.</li></ul><h3 id="리턴되는-정보-예시"><a href="#리턴되는-정보-예시" class="headerlink" title="리턴되는 정보 예시"></a>리턴되는 정보 예시</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request GET <span class="string">&#x27;http://config-server/jaehun-microservice-router/prod/master&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;jaehun-microservice-router&quot;</span>,</span><br><span class="line">    <span class="string">&quot;profiles&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;prod&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;label&quot;</span>: <span class="string">&quot;master&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: null,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: null,</span><br><span class="line">    <span class="string">&quot;propertySources&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;jaehun-microservice-router-prod&quot;</span>,</span><br><span class="line">            <span class="string">&quot;source&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;routing.weight.A&quot;</span>: <span class="string">&quot;51&quot;</span>,</span><br><span class="line">                <span class="string">&quot;routing.weight.B&quot;</span>: <span class="string">&quot;49&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>클라이언트에서는 리턴되는 프로퍼티 정보를 기반으로 context를 refresh 합니다.</li><li>이때 <code>@RefreshScope</code> 로 빈 스코프가 정의된 bean에 대해 조회한 프로퍼티로 바인딩 합니다.</li></ul><h1 id="Spring-Cloud-Config-Client"><a href="#Spring-Cloud-Config-Client" class="headerlink" title="Spring Cloud Config Client"></a>Spring Cloud Config Client</h1><p>클라이언트가 되는 Spring Boot 애플리케이션은 Spring Cloud Config Server에서 제공하는 properties를 즉시 사용할 수 있습니다.</p><h2 id="설정-방법-1"><a href="#설정-방법-1" class="headerlink" title="설정 방법"></a>설정 방법</h2><h3 id="1-build-gradle-의존성-추가-1"><a href="#1-build-gradle-의존성-추가-1" class="headerlink" title="1. build.gradle 의존성 추가"></a>1. build.gradle 의존성 추가</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.cloud:spring-cloud-starter-config&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.cloud:spring-cloud-config-client&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.boot:spring-boot-starter-actuator&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.boot:spring-boot-starter-aop&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>spring-cloud-starter-config, spring-cloud-config-client<ul><li>spring cloud config client 구성을 위해 의존성을 추가 합니다.</li></ul></li><li>spring-boot-starter-actuator<ul><li><code>/actuator/refresh</code> 를 호출 하여 context refresh를 하기 위해 추가합니다.</li></ul></li><li>spring-boot-starter-aop<ul><li>client 설정 중 retry 옵션을 사용하기 위해 추가합니다.</li></ul></li></ul><h3 id="2-application-yml-설정-spring-boot-2-4-이상-버전"><a href="#2-application-yml-설정-spring-boot-2-4-이상-버전" class="headerlink" title="2. application.yml 설정 (spring boot 2.4 이상 버전)"></a>2. application.yml 설정 (spring boot 2.4 이상 버전)</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;refresh&quot;</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">import:</span> <span class="string">&quot;optional:configserver:http://localhost:8080&quot;</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">jaehun-microservice-router</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">true</span> </span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="number">1000</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1.1</span></span><br><span class="line">      <span class="attr">request-connect-timeout:</span> <span class="number">2000</span></span><br><span class="line">      <span class="attr">request-read-timeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><ul><li><code>management.endpoints.web.exposure.include=refresh</code><ul><li>&#x2F;actuator&#x2F;refresh endpoint를 노출 시켜, 클라이언트의 context refresh를 실행시키도록 합니다.</li><li>context refresh가 실행되면 config server로 부터 현재 프로퍼티 정보를 받아옵니다.</li></ul></li><li><code>spring.config.import=optional:configserver:http://localhost:8080</code><ul><li>spring boot 2.4 이상 버전부터 지원하는 설정입니다.</li><li>2.3 이하 버전에서는 bootstrap.yml 파일에 spring.cloud.config 설정을 작성해야 합니다.</li><li>configserver에 대한 host 정보를 설정합니다.<ul><li>default는 <a href="http://localhost:8888입니다">http://localhost:8888입니다</a>.</li></ul></li><li>optional을 제거하고 <code>configserver:http://localhost:8080</code> 으로 설정 시, config server에 연결할 수 없는 경우 애플리케이션 구동에 실패합니다.</li></ul></li><li><code>spring.cloud.config.name=jaehun-microservice-router</code><ul><li>현재 애플리케이션의 application-name을 지정합니다.</li><li>이 값은 기본으로 <a href="http://spring.application.name/">spring.application.name</a> 프로퍼티 값을 사용합니다.</li><li>이 값으로 config server에 조회할 application-name으로 사용합니다.</li></ul></li><li><code>spring.cloud.config.fail-fase=true</code><ul><li>config-server에 연결할 수 없는 경우 애플리케이션 구동에 실패합니다.</li><li><code>configserver:http://localhost:8080</code> 와 비슷한 설정입니다.</li><li>retry 옵션을 사용하고자 하는 경우에 반드시 선언되어야 합니다.</li></ul></li><li><code>spring.cloud.config.retry.*</code><ul><li>config server에 연결 실패하거나 응답 에러가 발생하는 경우 재시도하는 정책입니다.</li><li><code>initial-interval</code> : config server api 요청 실패 후 다음 retry 요청을 위한 internal 입니다. 단위는 ms(밀리세컨드)입니다.</li><li><code>max-attempts</code> : 최대로 retry하는 횟수 입니다.</li><li><code>multiplier</code>: 한번 retry 할 때마다 interval 시간의 지연율을 곱합니다<ul><li>initial-interval: 1000 경우 2번째 retry는 1100ms 이후 실행합니다.</li></ul></li></ul></li><li><code>spring.cloud.config.request-connect-timeout</code><ul><li>config server 요청 시 사용하는 connection timeout 값입니다.</li><li>단위는 ms(밀리세컨드)</li><li>기본값은 10초 입니다.</li></ul></li><li><code>spring.cloud.config.request-read-timeout</code><ul><li>config server 요청 시 사용하는 read timeout 값입니다.</li><li>단위는 ms(밀리세컨드)</li><li>기본값은 185초 입니다.</li></ul></li></ul><h2 id="어떻게-런타임에-프로퍼티를-갱신하나요"><a href="#어떻게-런타임에-프로퍼티를-갱신하나요" class="headerlink" title="어떻게 런타임에 프로퍼티를 갱신하나요?"></a>어떻게 런타임에 프로퍼티를 갱신하나요?</h2><p>클라이언트에 POST &#x2F;actuator&#x2F;refresh API를 요청해 프로퍼티를 config server에서 불러와 갱신합니다.</p><h2 id="모든-Bean을-다시-만드나요"><a href="#모든-Bean을-다시-만드나요" class="headerlink" title="모든 Bean을 다시 만드나요?"></a>모든 Bean을 다시 만드나요?</h2><p>Bean Scope가 <code>@RefreshScope</code> 로 선언된 Bean에 대해서만 다시 생성합니다.</p><ul><li>Bean 내에 선언된 <code>@Value</code> 어노테이션을 사용한 프로퍼티의 값을 갱신 합니다.</li><li><code>@ConfigurationProperties</code> bean을 갱신합니다.</li><li>단! remote property를 기반으로<code>@ConditionalOnProperty</code>는 사용할 수 없습니다.<ul><li>라이프사이클이 달라 적용되지 않습니다.</li></ul></li></ul><h3 id="사용-예제"><a href="#사용-예제" class="headerlink" title="사용 예제"></a>사용 예제</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeightedRoutingPolicy</span></span>(</span><br><span class="line">  <span class="meta">@Value(<span class="string">&quot;\$&#123;routing.weight.A&#125;&quot;</span>)</span> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> routingWeightForA: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="meta">@Value(<span class="string">&quot;\$&#123;routing.weight.B&#125;&quot;</span>)</span> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> routingWeightForB: <span class="built_in">Int</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="질문-있어요"><a href="#질문-있어요" class="headerlink" title="질문 있어요~!"></a>질문 있어요~!</h1><h2 id="RefreshScope가-선언된-bean을-사용하는-bean도-재생성-되나요"><a href="#RefreshScope가-선언된-bean을-사용하는-bean도-재생성-되나요" class="headerlink" title="@RefreshScope가 선언된 bean을 사용하는 bean도 재생성 되나요?"></a>@RefreshScope가 선언된 bean을 사용하는 bean도 재생성 되나요?</h2><p><img src="./No.png"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanA도 재생성될까? =&gt; No!!</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanA</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> beanB BeanB</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanB</span></span>(</span><br><span class="line">  <span class="meta">@Value(<span class="string">&quot;\$&#123;custom.remote-config.value&#125;&quot;</span>)</span> <span class="keyword">val</span> customRemoteConfigValue: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>아닙니다~! @RefreshScope가 선언된 bean은 기본 생성 전략이 lazy-loading입니다.<br>따라서 최초 사용하는 시점에 initializing이 이루어집니다.</p><p>그렇기 때문에 @RefreshScope가 선언된 bean을 사용하는 bean은 재생성 되지 않습니다!<br>@RefreshScope가 선언된 bean이 재생성되고 최초로 사용할 때 initializing 되게 됩니다</p><h1 id="Spring-Cloud-Config의-기본적인-기능을-살펴보았습니다"><a href="#Spring-Cloud-Config의-기본적인-기능을-살펴보았습니다" class="headerlink" title="Spring Cloud Config의 기본적인 기능을 살펴보았습니다"></a>Spring Cloud Config의 기본적인 기능을 살펴보았습니다</h1><p><img src="./programmer-chaos.jpg"></p><p>근데말이죠…</p><p>클라이언트 모듈을 여러 대 운영하면 일일이 &#x2F;actuator&#x2F;refresh를 호출해야 할까요? </p><p>이런 고통과 고민을 덜어주기 위해 다음 글에서는 Spring Cloud Bus라는 기능을 소개합니다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://docs.spring.io/spring-cloud-config/docs/3.0.3/reference/html/">https://docs.spring.io/spring-cloud-config/docs/3.0.3/reference/html/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> Spring Cloud Config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring JPA Batch Insert 과연 생각대로 동작할까?</title>
      <link href="/2020/11/22/2020-11-22-spring-data-jpa-batch-insert/"/>
      <url>/2020/11/22/2020-11-22-spring-data-jpa-batch-insert/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>Spring JPA를 사용하며 대량으로 insert 시, 1건씩 insert 되기에 성능이 너무 안나온다고 생각을 하고 있었습니다.<br>그래서 초반에는 bulk insert와 같은 키워드로 검색을 해보니 Hibernate Batch Insert라는 내용이 있어<br>그대로 설정을 해보았으나 1건씩 insert 되기는 마찬가지였습니다.  </p><p>다른 사람들이 작성한 블로그를 읽어보면 뭔가 되는듯 한데, 나만 안되는 건가? 라는 생각이 들었고<br>끝내 원하던 방법을 찾아 그 내용을 공유하는 글을 작성하게 되었습니다. </p><p>예제 코드는 아래 github에 있습니다.<br><a href="https://github.com/jaehun2841/spring-jpa-batch-insert-test">https://github.com/jaehun2841/spring-jpa-batch-insert-test</a></p><h1 id="Batch-Insert-왜-insert-하나에-안합쳐져"><a href="#Batch-Insert-왜-insert-하나에-안합쳐져" class="headerlink" title="Batch Insert? 왜 insert 하나에 안합쳐져?"></a>Batch Insert? 왜 insert 하나에 안합쳐져?</h1><p>대부분 Insert 구문은 아래와 같이 사용됩니다</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;e8e6255c-bd9b-4310-af8b-72ab1ce31259&#x27;</span>, <span class="number">620000</span>);</span><br></pre></td></tr></table></figure><p>우리는 모두 많은 데이터를 입력할 시, 아래와 방법처럼 insert 구문을 실행하지 않고</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6c5fe953-ec38-4b26-b2f7-29a389cb8c03&#x27;</span>, <span class="number">619988</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;1959cb84-1dd5-42cc-95c1-8fd501881f1f&#x27;</span>, <span class="number">619989</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;daf8073e-78ea-435c-ac36-ac0796c4c283&#x27;</span>, <span class="number">619990</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;b98761f6-5f0b-448c-8f7f-aeffc22032d6&#x27;</span>, <span class="number">619991</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9a740e9c-2249-4c05-9349-9118c5825755&#x27;</span>, <span class="number">619992</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;d1b0e19c-9002-40d9-a43c-ae5e7293a7f4&#x27;</span>, <span class="number">619993</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;5ac02554-a877-4d1e-93b1-3f15bb58261c&#x27;</span>, <span class="number">619994</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;36673f68-3c56-4be6-8e09-3d970d5f361e&#x27;</span>, <span class="number">619995</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9d64f853-bd04-4ace-ba14-acc072f19729&#x27;</span>, <span class="number">619996</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;37190885-c1e7-4417-b545-f78130854acf&#x27;</span>, <span class="number">619997</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;fa7dc828-8aeb-45f1-9e80-8843890fd527&#x27;</span>, <span class="number">619998</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6e860c36-00f5-4349-952c-f7c09dfcc263&#x27;</span>, <span class="number">619999</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;e8e6255c-bd9b-4310-af8b-72ab1ce31259&#x27;</span>, <span class="number">620000</span>);</span><br></pre></td></tr></table></figure><p>이와 같이 멀티라인 insert가 효율이 더 좋음을 알고 있기에, 이러한 방법을 사용할 것입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> </span><br><span class="line">(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6c5fe953-ec38-4b26-b2f7-29a389cb8c03&#x27;</span>, <span class="number">619988</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;1959cb84-1dd5-42cc-95c1-8fd501881f1f&#x27;</span>, <span class="number">619989</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;daf8073e-78ea-435c-ac36-ac0796c4c283&#x27;</span>, <span class="number">619990</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;b98761f6-5f0b-448c-8f7f-aeffc22032d6&#x27;</span>, <span class="number">619991</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9a740e9c-2249-4c05-9349-9118c5825755&#x27;</span>, <span class="number">619992</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;d1b0e19c-9002-40d9-a43c-ae5e7293a7f4&#x27;</span>, <span class="number">619993</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;5ac02554-a877-4d1e-93b1-3f15bb58261c&#x27;</span>, <span class="number">619994</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;36673f68-3c56-4be6-8e09-3d970d5f361e&#x27;</span>, <span class="number">619995</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9d64f853-bd04-4ace-ba14-acc072f19729&#x27;</span>, <span class="number">619996</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;37190885-c1e7-4417-b545-f78130854acf&#x27;</span>, <span class="number">619997</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;fa7dc828-8aeb-45f1-9e80-8843890fd527&#x27;</span>, <span class="number">619998</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6e860c36-00f5-4349-952c-f7c09dfcc263&#x27;</span>, <span class="number">619999</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;e8e6255c-bd9b-4310-af8b-72ab1ce31259&#x27;</span>, <span class="number">620000</span>);</span><br></pre></td></tr></table></figure><p>처음에 Hibernate에서 제공하는 batch insert가 이와 같은 기능인 줄 <strong>착각</strong> 하여 이런 기능을 제공하지 않는 줄 알았습니다.</p><h1 id="JDBC-Batching"><a href="#JDBC-Batching" class="headerlink" title="JDBC Batching"></a>JDBC Batching</h1><p><a href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#batch-jdbcbatch">batch-jdbcbatch</a> 이 글에는 JDBC에서 제공하는 batch 처리 옵션을 알려주고 있습니다.  </p><blockquote><p>JDBC offers support for batching together SQL statements that can be represented as a single PreparedStatement. Implementation wise this generally means that drivers will send the batched operation to the server in one call, which can save on network calls to the database. Hibernate can leverage JDBC batching. The following settings control this behavior.</p></blockquote><p>번역기를 통해 번역해보면..</p><blockquote><p>JDBC는 단일 PreparedStatement로 표현 될 수있는 SQL 문을 일괄 처리 할 수 있도록 지원합니다.<br>구현 측면에서 이것은 일반적으로 드라이버가 한 번의 호출로 일괄 처리 된 작업을 서버로 전송하여 데이터베이스에 대한 네트워크 호출을 절약 할 수 있음을 의미합니다.<br>Hibernate는 JDBC 일괄 처리를 활용할 수 있습니다. </p></blockquote><p>다시 한번 의역해보면..</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6c5fe953-ec38-4b26-b2f7-29a389cb8c03&#x27;</span>, <span class="number">619988</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;1959cb84-1dd5-42cc-95c1-8fd501881f1f&#x27;</span>, <span class="number">619989</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;daf8073e-78ea-435c-ac36-ac0796c4c283&#x27;</span>, <span class="number">619990</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;b98761f6-5f0b-448c-8f7f-aeffc22032d6&#x27;</span>, <span class="number">619991</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9a740e9c-2249-4c05-9349-9118c5825755&#x27;</span>, <span class="number">619992</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;d1b0e19c-9002-40d9-a43c-ae5e7293a7f4&#x27;</span>, <span class="number">619993</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;5ac02554-a877-4d1e-93b1-3f15bb58261c&#x27;</span>, <span class="number">619994</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;36673f68-3c56-4be6-8e09-3d970d5f361e&#x27;</span>, <span class="number">619995</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9d64f853-bd04-4ace-ba14-acc072f19729&#x27;</span>, <span class="number">619996</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;37190885-c1e7-4417-b545-f78130854acf&#x27;</span>, <span class="number">619997</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;fa7dc828-8aeb-45f1-9e80-8843890fd527&#x27;</span>, <span class="number">619998</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6e860c36-00f5-4349-952c-f7c09dfcc263&#x27;</span>, <span class="number">619999</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;e8e6255c-bd9b-4310-af8b-72ab1ce31259&#x27;</span>, <span class="number">620000</span>);</span><br></pre></td></tr></table></figure><p>이 SQL문을 그냥 한번에 실행해 주는 역할 정도만 한다는 의미입니다. (생각했던 multi-row insert가 아닌)</p><h2 id="JDBC-Options"><a href="#JDBC-Options" class="headerlink" title="JDBC Options"></a>JDBC Options</h2><h3 id="hibernate-jdbc-batch-size"><a href="#hibernate-jdbc-batch-size" class="headerlink" title="hibernate.jdbc.batch_size"></a>hibernate.jdbc.batch_size</h3><p>이 옵션은 몇개의 statement 즉, 하나의 sql이 쌓이면 DB서버로 요청할 지 정하는 단위입니다.<br>예를들어 10으로 정하면</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;b98761f6-5f0b-448c-8f7f-aeffc22032d6&#x27;</span>, <span class="number">619991</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9a740e9c-2249-4c05-9349-9118c5825755&#x27;</span>, <span class="number">619992</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;d1b0e19c-9002-40d9-a43c-ae5e7293a7f4&#x27;</span>, <span class="number">619993</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;5ac02554-a877-4d1e-93b1-3f15bb58261c&#x27;</span>, <span class="number">619994</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;36673f68-3c56-4be6-8e09-3d970d5f361e&#x27;</span>, <span class="number">619995</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9d64f853-bd04-4ace-ba14-acc072f19729&#x27;</span>, <span class="number">619996</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;37190885-c1e7-4417-b545-f78130854acf&#x27;</span>, <span class="number">619997</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;fa7dc828-8aeb-45f1-9e80-8843890fd527&#x27;</span>, <span class="number">619998</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6e860c36-00f5-4349-952c-f7c09dfcc263&#x27;</span>, <span class="number">619999</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;e8e6255c-bd9b-4310-af8b-72ab1ce31259&#x27;</span>, <span class="number">620000</span>);</span><br></pre></td></tr></table></figure><p>이와 같이 sql이 10개가 내부 큐에 쌓이면 전송하는 방식입니다.</p><h3 id="hibernate-order-inserts-hibernate-order-updates"><a href="#hibernate-order-inserts-hibernate-order-updates" class="headerlink" title="hibernate.order_inserts, hibernate.order_updates"></a>hibernate.order_inserts, hibernate.order_updates</h3><p>아래와 같은 경우에는 batch insert가 적용되지 않습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeInserts</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">  List&lt;Child&gt; childList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">    <span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parent</span>(...);</span><br><span class="line">    <span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(...);</span><br><span class="line">  </span><br><span class="line">    child.setParent(parent);</span><br><span class="line">    childList.add(child);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  childRepository.saveAll(childList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>내부적으로 parent가 insert되고 child가 insert가 되기 때문에 쓰기지연 SQL 저장소에는 이런식으로 구성이 되어 batch insert가 실행되지 않습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">6</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">7</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">9</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">9</span>, <span class="number">9</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">10</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>하지만 <code>hibernate.order_inserts = true</code> 가 적용되면 각각의 insert 구문이 정렬되어 batch insert가 가능해집니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">6</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">7</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">9</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">9</span>, <span class="number">9</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h1 id="rewrite-옵션"><a href="#rewrite-옵션" class="headerlink" title="rewrite 옵션"></a>rewrite 옵션</h1><p>정말로 multi-row insert가 지원이 안되나? 하고 찾아보니 jdbc.batch_size 옵션을 사용하면 내부적으로 <code>addBatch()</code> 메서드를 통해 batch로 처리하지만<br>multi-row는 지원되지 않았습니다.  </p><p>원하는 multi-row insert를 하기 위해선 jdbcUrl에 아래와 같은 옵션이 추가되어야 합니다.</p><ul><li><strong>MySQL</strong>  : jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jpa-test?useSSL&#x3D;false&amp; <strong>rewriteBatchedStatements&#x3D;true</strong></li><li><strong>PostgreSQL</strong> : jdbc:postgresql:&#x2F;&#x2F;localhost:5432&#x2F;jpa-test?useSSL&#x3D;false&amp; <strong>rewriteBatchedInserts&#x3D;true</strong></li></ul><p>이 옵션을 추가하면,  connector 레벨에서 insert 구문을 재작성(rewrite) 하게 되어 아래와 같은 형태로 SQL이 재작성됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> </span><br><span class="line">(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6c5fe953-ec38-4b26-b2f7-29a389cb8c03&#x27;</span>, <span class="number">619988</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;1959cb84-1dd5-42cc-95c1-8fd501881f1f&#x27;</span>, <span class="number">619989</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;daf8073e-78ea-435c-ac36-ac0796c4c283&#x27;</span>, <span class="number">619990</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;b98761f6-5f0b-448c-8f7f-aeffc22032d6&#x27;</span>, <span class="number">619991</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9a740e9c-2249-4c05-9349-9118c5825755&#x27;</span>, <span class="number">619992</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;d1b0e19c-9002-40d9-a43c-ae5e7293a7f4&#x27;</span>, <span class="number">619993</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;5ac02554-a877-4d1e-93b1-3f15bb58261c&#x27;</span>, <span class="number">619994</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;36673f68-3c56-4be6-8e09-3d970d5f361e&#x27;</span>, <span class="number">619995</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9d64f853-bd04-4ace-ba14-acc072f19729&#x27;</span>, <span class="number">619996</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;37190885-c1e7-4417-b545-f78130854acf&#x27;</span>, <span class="number">619997</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;fa7dc828-8aeb-45f1-9e80-8843890fd527&#x27;</span>, <span class="number">619998</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6e860c36-00f5-4349-952c-f7c09dfcc263&#x27;</span>, <span class="number">619999</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;e8e6255c-bd9b-4310-af8b-72ab1ce31259&#x27;</span>, <span class="number">620000</span>);</span><br></pre></td></tr></table></figure><h1 id="주의할-점"><a href="#주의할-점" class="headerlink" title="주의할 점"></a>주의할 점</h1><h2 id="JPA에서-ID-채번-방식을-GenerateType-IDENDITY-사용-시-batch-insert를-할-수-없다"><a href="#JPA에서-ID-채번-방식을-GenerateType-IDENDITY-사용-시-batch-insert를-할-수-없다" class="headerlink" title="JPA에서 ID 채번 방식을 GenerateType.IDENDITY 사용 시 batch insert를 할 수 없다"></a>JPA에서 ID 채번 방식을 GenerateType.IDENDITY 사용 시 batch insert를 할 수 없다</h2><blockquote><p>Hibernate disables insert batching at the JDBC level transparently if you use an identity identifier generator.</p></blockquote><p>Entity의 Id 채번방식을 GenerateType.IDENDITY을 사용하는 경우에는 batch insert가 적용되지 않습니다. (JDBC 레벨에서 차단)<br>실제 insert 시, <code>select last_insert_id()</code> 쿼리를 실행하여 다음에 insert할 ID를 채번해오기 때문에 batch insert를 막는듯 합니다.</p><p><strong>따라서 batch insert를 사용하기 위해선 ID 채번방식을 GenerateType.SEQUENCE나 GenerateType.TABLE을 사용해야 합니다.</strong></p><h2 id="MySQL의-경우-max-allowed-packet-값을-고려해서-써야한다"><a href="#MySQL의-경우-max-allowed-packet-값을-고려해서-써야한다" class="headerlink" title="MySQL의 경우 max_allowed_packet 값을 고려해서 써야한다."></a>MySQL의 경우 max_allowed_packet 값을 고려해서 써야한다.</h2><p>MySQL의 경우  max_allowed_packet이라는 설정값이 있습니다.<br>이 설정값은 DB server로 보낼 수 있는 최대 요청 packet size입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_allowed_packet&#x27;</span></span><br></pre></td></tr></table></figure><p>위 SQL을 통해 확인 할 수 있으며, 기본적으로  4MB로 설정되어있습니다. </p><p>multi-row insert를 하는 경우 row수가 많아지면 max_allowed_packet size를 넘을 수 있기 때문에 적절한 batch_size를 고려해야 합니다.</p><h1 id="SequenceGenerator의-채번-방식을-변경해서-사용하라"><a href="#SequenceGenerator의-채번-방식을-변경해서-사용하라" class="headerlink" title="SequenceGenerator의 채번 방식을 변경해서 사용하라"></a>SequenceGenerator의 채번 방식을 변경해서 사용하라</h1><p>MySQL에서 SequenceGenerator의 동작방식은 아래와 같습니다.</p><ol><li><code>hibernate_sequence</code> 테이블에서 현재 sequence 값 조회 (select next_val from hibernate_sequence)</li><li><code>hibernate_sequence</code> 테이블 update (update hibernate_sequence set next_val + 1 where next_val &#x3D; ?)</li><li>Entity 객체에 ID를 부여해서 insert</li></ol><p>이와 같이 사용하는 경우 1개의 ID를 채번하는데 사용되는 query가 2개입니다.  따라서 batch insert를 하더라도 큰 성능 향상을 기대하기 어렵습니다.</p><p>이 경우 SequenceGenerator의 optimizer를 변경하여 사용하면 큰 성능 향상을 볼 수 있습니다.  </p><p>아래 글을 참고하면 hibernate id generator에 대한 optimizer 설명을 볼 수 있습니다.</p><ul><li><p><a href="https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators-optimizer">identifires-generator-optimizer</a></p></li><li><p><a href="https://woowabros.github.io/experience/2020/02/06/hikaricp-avoid-dead-lock-2.html">HikariCP Dead lock에서 벗어나기 (실전편)</a></p></li></ul><p>여기서는 간단하게 <code>pooled-lo</code> optimizer를 사용하도록 한 예시를 제공합니다.</p><p><img src="./PooledLoOptimizer.png" alt="PooledLoOptimizer"></p><p>한번에 일정 범위만큼 채번을 하여 메모리에 저장하여 사용하는 방식입니다.<br>ex) 한번에 1000개만큼 채번 후 <code>(update hibernate_sequence set next_val + 1000 where next_val = ?) </code> 1000개 ID를 메모리에 할당 후 사용</p><p>위와 같은 optimizer를 사용하면 1000개의 entity를 insert하는데 1번의 hibernate_sequence에 대한 쿼리가 실행되어 매우 효율적으로 ID채번이 가능합니다.</p><h1 id="pooled-lo-optimizer를-적용한-코드"><a href="#pooled-lo-optimizer를-적용한-코드" class="headerlink" title="pooled-lo optimizer를 적용한 코드"></a>pooled-lo optimizer를 적용한 코드</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestData</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO, generator = &quot;test-sequence-generator&quot;)</span></span><br><span class="line">    <span class="meta">@GenericGenerator(</span></span><br><span class="line"><span class="meta">            name = &quot;test-sequence-generator&quot;,</span></span><br><span class="line"><span class="meta">            strategy = &quot;sequence&quot;,</span></span><br><span class="line"><span class="meta">            parameters = &#123;</span></span><br><span class="line"><span class="meta">                    @Parameter(name = SequenceStyleGenerator.SEQUENCE_PARAM, value = SequenceStyleGenerator.DEF_SEQUENCE_NAME),</span></span><br><span class="line"><span class="meta">                    @Parameter(name = SequenceStyleGenerator.INITIAL_PARAM, value = &quot;1&quot;),</span></span><br><span class="line"><span class="meta">                    @Parameter(name = SequenceStyleGenerator.INCREMENT_PARAM, value = &quot;1000&quot;),</span></span><br><span class="line"><span class="meta">                    @Parameter(name = AvailableSettings.PREFERRED_POOLED_OPTIMIZER, value = &quot;pooled-lo&quot;)</span></span><br><span class="line"><span class="meta">            &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Column(name = &quot;uuid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line">    <span class="meta">@Column(name = &quot;created_at&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TestData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = <span class="number">0L</span>;</span><br><span class="line">        <span class="built_in">this</span>.uuid = UUID.randomUUID().toString();</span><br><span class="line">        <span class="built_in">this</span>.createdAt = LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestData <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestData</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="성능-비교"><a href="#성능-비교" class="headerlink" title="성능 비교"></a>성능 비교</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EntityScan</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaBatchTestApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestDataRepository testDataRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(JpaBatchTestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        List&lt;TestData&gt; testDataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            testDataList.add(TestData.create());</span><br><span class="line">        &#125;</span><br><span class="line">        testDataRepository.saveAll(testDataList);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="type">long</span> <span class="variable">totalTimeMillis</span> <span class="operator">=</span> stopWatch.getTotalTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;total time : &quot;</span> + totalTimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>위 코드에 대해 3가지 방식의 설정으로 실행시간을 비교해 보았습니다. (총 10만건 insert)</p><ul><li>jdbc.batch_size 설정x + rewriteBatchedStatements &#x3D; false<ul><li>소요시간: 138,136ms (약 2분)</li></ul></li><li>jdbc.batch_size &#x3D; 20000 + rewriteBatchedStatements &#x3D; false<ul><li>소요시간: 52,710ms (약 52초)</li></ul></li><li>jdbc.batch_size &#x3D; 20000 + rewriteBatchedStatements &#x3D; true<ul><li>소요시간: 4,667ms (약 4초)</li></ul></li></ul><p>+추가) saveAll이 아닌 단건 save의 경우에는?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        List&lt;TestData&gt; testDataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">          testDataRepository.save(TestData.create());</span><br><span class="line">        &#125;</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="type">long</span> <span class="variable">totalTimeMillis</span> <span class="operator">=</span> stopWatch.getTotalTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;total time : &quot;</span> + totalTimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>위의 코드의 경우에는 소요시간이 <code>555,435ms</code> 만큼 소요 되었습니다.</p><p>위 성능테스트 비교 결과 <code>jdbc.batch_size + rewriteBatchedStatements = true</code>하는 옵션이 어마어마한 성능차이를 보여줌을 확인하였습니다.</p><h1 id="application-yml-설정-코드"><a href="#application-yml-설정-코드" class="headerlink" title="application.yml 설정 코드"></a>application.yml 설정 코드</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/jpa-test?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.mariadb.jdbc.Driver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">jpa-test-hikari-pool</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">jdbc-url:</span> <span class="string">$&#123;spring.datasource.url&#125;</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">$&#123;spring.datasource.username&#125;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">$&#123;spring.datasource.password&#125;</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">$&#123;spring.datasource.driver-class-name&#125;</span></span><br><span class="line">      <span class="attr">data-source-properties:</span></span><br><span class="line">        <span class="attr">rewriteBatchedStatements:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">hibernate:</span></span><br><span class="line">        <span class="attr">format_sql:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">order_inserts:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">order_updates:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">jdbc:</span></span><br><span class="line">          <span class="attr">batch_size:</span> <span class="number">20000</span></span><br><span class="line">        <span class="attr">dialect:</span> <span class="string">org.hibernate.dialect.MySQL57InnoDBDialect</span></span><br><span class="line">    <span class="attr">generate-ddl:</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>HikariCP를 이용하는 경우 <code>spring.datasource.hikari.data-source-properties</code>에 queryString으로 들어갈 properties를 작성할 수 있습니다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://www.baeldung.com/jpa-hibernate-batch-insert-update">https://www.baeldung.com/jpa-hibernate-batch-insert-update</a></li><li><a href="http://blog.plura.io/?p=4493">http://blog.plura.io/?p=4493</a></li><li><a href="https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html">https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html</a></li><li><a href="https://medium.com/@jerolba/persisting-fast-in-database-jdbc-76912ec2ef42">https://medium.com/@jerolba/persisting-fast-in-database-jdbc-76912ec2ef42</a></li><li><a href="https://github.com/brettwooldridge/HikariCP/issues/758">https://github.com/brettwooldridge/HikariCP/issues/758</a></li><li><a href="https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators-optimizer">https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators-optimizer</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> JPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Batch에서 Chunk 작업이 길어지는 경우 주의할 점</title>
      <link href="/2020/08/08/2020-08-08-spring-batch-db-connection-issue/"/>
      <url>/2020/08/08/2020-08-08-spring-batch-db-connection-issue/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>Spring Batch 실행 중 아래와 같은 에러 메세지를 확인 하는 경우 이 글에서 설명하는 case일 수 있습니다.</p><ul><li>Caused by: java.io.EOFException: unexpected end of stream, read 0 bytes from 4 (socket was closed by server)</li><li>org.springframework.transaction.TransactionSystemException: Could not roll back JPA transaction; nested exception is org.hibernate.TransactionException: Unable to rollback against JDBC Connection</li><li>Caused by: org.springframework.dao.DataAccessResourceFailureException: PreparedStatementCallback; SQL [UPDATE BATCH_STEP_EXECUTION_CONTEXT SET SHORT_CONTEXT &#x3D; ?, SERIALIZED_CONTEXT &#x3D; ? WHERE STEP_EXECUTION_ID &#x3D; ?]; (conn&#x3D;376) unexpected end of stream, read 0 bytes from 4 (socket was closed by server); nested exception is java.sql.SQLNonTransientConnectionException: (conn&#x3D;376) unexpected end of stream, read 0 bytes from 4 (socket was closed by server)</li><li>org.springframework.batch.core.step.FatalStepExecutionException: JobRepository failure forcing rollback</li></ul><h1 id="상황"><a href="#상황" class="headerlink" title="상황"></a>상황</h1><p>Spring Batch Application을 이용하여 월 단위 데이터 rolling 중 위와 같은 에러메세지를 내며 간헐적으로 배치가 실패하는 case를 발견하였습니다.<br>배치가 실패하는 원인은 chunk 단위로 작업 시, 작업이 길어지는 경우 배치가 실패하는 현상을 발견하였고 아래 항목에 대한 상관관계가 있음을 발견하였습니다.</p><ul><li>mysql wait_timeout </li><li>chunk 단위의 작업시간</li></ul><p>제가 겪은 case는 chunk단위로 DB를 조회하여 데이터를 rolling하는 작업이었는데 마지막 Page에 대해 조회할 때 slow query가 발생하여<br>chunk의 작업시간이 mysql wait_timeout 시간이 넘어가는 case였습니다.<br>그렇기 때문에 로그로 확인해봐도 마지막 chunk 작업 시, error가 발생하여 배치작업이 실패하는 것을 확인할 수 있었습니다.</p><h1 id="Spring-Batch가-하고-있는-일"><a href="#Spring-Batch가-하고-있는-일" class="headerlink" title="Spring Batch가 하고 있는 일"></a>Spring Batch가 하고 있는 일</h1><p>이 글의 내용을 정확히 이해하기 위해서는 Spring Batch라는 framework에서 내부적으로 하는 일을 알아야 합니다.<br>Spring Batch는 배치의 실행 결과 &#x2F; parameter에 대한 meta 정보를 RDB내의 테이블에 내부적으로 저장하고 있습니다.</p><ul><li>BATCH_JOB_EXECUTION</li><li>BATCH_JOB_EXECUTION_CONTEXT</li><li>BATCH_JOB_EXECUTION_PARAM</li><li>BATCH_JOB_EXECUTION_SEQ</li><li>BATCH_JOB_INSTANCE</li><li>BATCH_JOB_SEQ</li><li>BATCH_STEP_EXECUTION</li><li>BATCH_STEP_EXECUTION_CONTEXT</li><li>BATCH_STEP_EXECUTION_SEQ</li></ul><p>이 중에서도 이 글에서 집중해서 봐야할 테이블은 <strong>BATCH_STEP_EXECUTION</strong> 입니다.<br>이 테이블은 STEP 실행에 대한 상태를 담고 있습니다.  </p><p>chunk기반 STEP의 경우 chunk 단위 작업이 종료될 때 마다 commit_count, read_count와 같은 상태를 업데이트하고 있습니다.  </p><h1 id="Hikari-CP-max-life-time과-MySQL-wait-timeout의-관계"><a href="#Hikari-CP-max-life-time과-MySQL-wait-timeout의-관계" class="headerlink" title="Hikari CP max life time과 MySQL wait_timeout의 관계"></a>Hikari CP max life time과 MySQL wait_timeout의 관계</h1><p><a href="https://jaehun2841.github.io/2020/01/08/2020-01-08-hikari-pool-validate-connection">HikariCP Failed to Validate Connection Warning 이야기</a><br>위 글에 maxLifeTime과 wait_timeout에 대한 자세한 설명이 있으니 참고 부탁드립니다.</p><p>간략하게 설명하면</p><ul><li><strong>HikariCP maxLifeTime</strong>: Connection Pool레벨에서 maxLifeTime이 지나도록 idle 상태인 connection 객체를 pool에서 제거합니다.<br>(GC에 의해 제거 됨)</li><li><strong>MySQL wait_timeout</strong>: MySQL DBMS에서 wait_timeout 시간이 지나도록 사용하지 않은 Connection에 대해 Connection 연결을 해제합니다.<ul><li>사용하지 않았다는 의미는 Connection을 이용하여 어떠한 Query도 실행하지 않았음을 의미합니다.</li></ul></li></ul><p>JDBC4를 지원하는 드라이버에서는 더 이상 SELECT 1과 같은 validateQuery를 이용하여 Connection을 갱신하지 않습니다.<br><strong>따라서 클라이언트의 Connection Pool에서 Connection 객체를 취득하였더라도 어떠한 작업도 하지 않는다면 DBMS입장에서는 아무런 Action도 없는 상태와 마찬가지 입니다.</strong></p><h1 id="Connection-객체의-내부"><a href="#Connection-객체의-내부" class="headerlink" title="Connection 객체의 내부"></a>Connection 객체의 내부</h1><p>JDBC 표준으로 만들어진 Connection 클래스 내부에는 DBMS와 TCP socket을 이용하여 연결을 맺을 수 있도록 되어있습니다.<br>기본적으로 Connection 객체 한 개당 1 socket 연결이라고 생각하면 쉽습니다.<br>따라서 Connection 객체가 생길때 마다 MySQL에서 show processlist 명령어를 쳐보면 현재 연결된 session의 정보를 확인할 수 있습니다.</p><p>예를들어 Connection Pool 갯수가 10개라면 MySQL에도 똑같이 10개의 session이 맺어진 것을 확인할 수 있습니다.<br><strong>따라서 이 socket이 실제로 DBMS로 Query를 전송하는 통로 역할을 한다고 볼 수 있습니다.</strong></p><p><img src="./Connection.png" alt="Connection 객체의 내부"></p><h1 id="상황-재현"><a href="#상황-재현" class="headerlink" title="상황 재현"></a>상황 재현</h1><p>상황을 재현하기 위한 조건은 아래와 같이 설정하였습니다.</p><ul><li>mysql의 global wait_timeout을 30초로 설정<ul><li>set GLOBAL wait_timeout &#x3D; 30;</li></ul></li><li>HikariCP의 maxLifeTimeout을 29초로 설정<ul><li>spring.datasource.hikari.max-lifetime &#x3D; 29000</li></ul></li><li>HikariCP의 maximum-pool-size를 3개로 설정<ul><li>spring.datasource.hikari.maximum-pool-size &#x3D; 3</li></ul></li><li>chunk 단위의 작업시간을 약 50초 정도로 설정<ul><li>sleep 명령어를 통해 50초의 Delay를 설정해보았습니다.</li></ul></li></ul><h2 id="테스트를-위한-간략한-코드"><a href="#테스트를-위한-간략한-코드" class="headerlink" title="테스트를 위한 간략한 코드"></a>테스트를 위한 간략한 코드</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestJobConfiguration</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> jobBuilderFactory: JobBuilderFactory,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> stepBuilderFactory: StepBuilderFactory</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">testJob</span><span class="params">()</span></span>: Job &#123;</span><br><span class="line">    <span class="keyword">return</span> jobBuilderFactory.<span class="keyword">get</span>(<span class="string">&quot;testJob&quot;</span>)</span><br><span class="line">      .start(testStep())</span><br><span class="line">      .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">testStep</span><span class="params">()</span></span>: Step &#123;</span><br><span class="line">    <span class="keyword">val</span> testList = (<span class="number">1.</span><span class="number">.100_000</span>).map &#123; it &#125;.toList()</span><br><span class="line">    <span class="keyword">return</span> stepBuilderFactory.<span class="keyword">get</span>(<span class="string">&quot;testStep&quot;</span>)</span><br><span class="line">      .chunk&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;(<span class="number">100</span>)</span><br><span class="line">      .reader(DelayedItemReader(testList))</span><br><span class="line">      .writer &#123;</span><br><span class="line">        it.forEach &#123; int -&gt;</span><br><span class="line">          print(<span class="string">&quot;<span class="variable">$int</span> &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      .build()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayedItemReader</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">  items: List&lt;T&gt;</span><br><span class="line">) : ItemReader&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> list: MutableList&lt;T&gt; = items.toMutableList()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    Thread.sleep(<span class="number">500</span>)</span><br><span class="line">    <span class="keyword">return</span> list.removeAt(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드에서는 chunk단위가 100개 이며, item 하나를 read하는데 500ms가 소요됩니다.<br>따라서 chunk size만큼 읽는데 총 50초가 소요됩니다.</p><h1 id="Transaction-단위-x3D-chunk-단위"><a href="#Transaction-단위-x3D-chunk-단위" class="headerlink" title="Transaction 단위 &#x3D; chunk 단위"></a>Transaction 단위 &#x3D; chunk 단위</h1><p>Spring Batch Framework에서는 chunk 기반 Step에 대해 chunk단위로 Transaction을 보장합니다.  </p><p>TaskletStep 내의 doExecute 메서드 내부를 보면 TransactionTemplate을 기반으로 chunk를 실행합니다.</p><p><img src="./doInChunkContext.png" alt="doInChunkContext"></p><p>아래 코드에서 transactionManager.getTransaction을 통해 transaction을 하나 생성하게되고<br>이 과정에서 HikariPool에서 Connection 객체를 하나 받아옵니다.</p><p><img src="./execute_getTransaction.png" alt="execute_getTransaction"></p><h1 id="그렇다면-왜-Connection으로-인한-오류가-발생할까요"><a href="#그렇다면-왜-Connection으로-인한-오류가-발생할까요" class="headerlink" title="그렇다면 왜 Connection으로 인한 오류가 발생할까요?"></a>그렇다면 왜 Connection으로 인한 오류가 발생할까요?</h1><h2 id="chunk-시작-시-Transaction-생성으로-인한-Connection-취득"><a href="#chunk-시작-시-Transaction-생성으로-인한-Connection-취득" class="headerlink" title="chunk 시작 시 Transaction 생성으로 인한 Connection 취득"></a>chunk 시작 시 Transaction 생성으로 인한 Connection 취득</h2><p><img src="./getConnection.png" alt="getConnection"></p><ol><li><p>chunk 단위에 대한 작업 시작 시, transaction 생성으로 인해 Hikari Pool에서 connection을 취득합니다.</p></li><li><p>Hikari Pool 내부에서는 Active Connection으로 인식하며, 이 Connection은 max-lifetime 시간이 지나도 pool에서 제거되지 않습니다.<br>(이미 사용중이라고 인식하는 Connection이기 때문입니다.)</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-08-08 15:09:10.481 DEBUG 81263 --- [ool housekeeper] com.zaxxer.hikari.pool.HikariPool :  </span><br><span class="line">spring-batch-meta-connection-pool - Pool stats (total=3, active=1, idle=2, waiting=0)</span><br></pre></td></tr></table></figure><h2 id="wait-timeout-시간이-지나고-session-제거"><a href="#wait-timeout-시간이-지나고-session-제거" class="headerlink" title="wait_timeout 시간이 지나고 session 제거"></a>wait_timeout 시간이 지나고 session 제거</h2><p><img src="./session-remove.png" alt="session-remove"></p><ol><li>item read 과정에서 50초동안 meta DB Connection을 사용하여 Query를 실행하지 않으므로 DBMS 입장에서는 connection이 유휴상태입니다.</li><li>따라서 wait_timeout 시간인 30초가 경과하면 DBMS에서 session 연결을 제거합니다.</li><li>이렇게 되면 <strong>Hikari Connection 객체는 유지되지만 내부 socket 연결은 끊어진 상태라고 볼 수 있습니다.</strong></li></ol><h2 id="chunk-작업-이후-meta-DB-update-query-실행"><a href="#chunk-작업-이후-meta-DB-update-query-실행" class="headerlink" title="chunk 작업 이후 meta DB update query 실행"></a>chunk 작업 이후 meta DB update query 실행</h2><p><img src="./update-query.png" alt="update-query"></p><ol><li>50초가 지나고 chunk에 대한 작업이 완료되어 meta db에 있는 <strong>BATCH_STEP_EXECUTION</strong> 테이블에 step 실행 결과를 update 하고자 query를 전송합니다.</li><li>하지만 Connection 내의 socket을 사용하려고 하는 순간 이미 socket 연결이 끊어졌기 때문에 쿼리를 DBMS에 실행할 수 없게 됩니다.</li><li>따라서 예외가 발생하게 되며 rollback을 수행하려합니다.</li><li>하지만 이미 socket이 끊어졌기 때문에 rollback 명령어도 전송하지 못하고 아래의 에러를 내며 batch가 종료됩니다.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.batch.core.step.FatalStepExecutionException: JobRepository failure forcing rollback</span><br><span class="line"></span><br><span class="line">Caused by: org.springframework.dao.DataAccessResourceFailureException: PreparedStatementCallback; SQL [UPDATE BATCH_STEP_EXECUTION_CONTEXT SET SHORT_CONTEXT = ?, SERIALIZED_CONTEXT = ? WHERE STEP_EXECUTION_ID = ?]; (conn=376) unexpected end of stream, read 0 bytes from 4 (socket was closed by server); nested exception is java.sql.SQLNonTransientConnectionException: (conn=376) unexpected end of stream, read 0 bytes from 4 (socket was closed by server)</span><br><span class="line"></span><br><span class="line">Caused by: java.io.EOFException: unexpected end of stream, read 0 bytes from 4 (socket was closed by server)</span><br><span class="line">at org.mariadb.jdbc.internal.io.input.StandardPacketInputStream.getPacketArray(StandardPacketInputStream.java:249) ~[mariadb-java-</span><br><span class="line"></span><br><span class="line">org.springframework.transaction.TransactionSystemException: Could not roll back JPA transaction; nested exception is org.hibernate.TransactionException: Unable to rollback against JDBC Connection</span><br><span class="line"></span><br><span class="line">Caused by: org.hibernate.TransactionException: Unable to rollback against JDBC Connection</span><br><span class="line">at </span><br><span class="line"></span><br><span class="line">Caused by: java.sql.SQLException: Connection is closed</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>Spring Batch를 사용하다 보면 chunk 단위로 작업을 쪼개서 하는 행위를 많이 하게 됩니다.<br>위와 같은 에러로 인한 배치 실패를 경험하지 않기 위해서는 chunk의 작업 수행 시간이 wait_timeout 시간보다 반드시 적게 걸려야 한다는 점을 유의해야할 합니다.</p><p>chunk의 작업 시간에 영향을 미치는 것은 아래와 같습니다.</p><ul><li>read 지연</li><li>process 지연</li><li>write 지연</li></ul><p>특히 read 시, slow query와 같은 이슈가 발생할 가능성이 있습니다. 저 또한 그랬고요<br>위의 예시가 많은 분들의 도움이 되길 바랍니다.</p><p>테스트 한 코드는 아래 repository를 참고 부탁드립니다.<br><a href="https://github.com/jaehun2841/spring-batch-connection-close-issue">https://github.com/jaehun2841/spring-batch-connection-close-issue</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot </tag>
            
            <tag> Hikari CP </tag>
            
            <tag> Spring Batch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter15. 디자인 패턴과 프레임워크</title>
      <link href="/2020/07/25/object-chapter15/"/>
      <url>/2020/07/25/object-chapter15/</url>
      
        <content type="html"><![CDATA[<h1 id="디자인-패턴"><a href="#디자인-패턴" class="headerlink" title="디자인 패턴"></a>디자인 패턴</h1><p>애플리케이션을 설계하다 보면 어떤 요구사항을 해결하기 위해 과거에 경험했던 유사한 해결방법을 다시금 사용하는 경우가 있다.<br>소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결방법을 <strong>디자인 패턴</strong> 이라고 부른다. </p><p>디자인 패턴은 특정한 변경을 일관성 있게 다룰 수 있는 <strong>협력 템플릿</strong> 을 제공한다</p><h1 id="프레임워크"><a href="#프레임워크" class="headerlink" title="프레임워크"></a>프레임워크</h1><p>설계와 코드를 함께 재사용하기 위한 것을 <strong>프레임워크</strong> 라고 부른다.<br>프레임워크는 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.<br>프레임워크에서 제공하는 아키텍처가 적합하다면 다양한 환경에서 테스트를 거친 견고한 구현 코드를 쉽고 빠르게 재사용할 수 있다.<br>프레임워크는 각 애플리케이션의 요구에 따라 적절하게 커스터마이징할 수 있는 확장 포인트를 제공한다</p><p>프레임워크는 일관성 있게 다룰 수 있는 <strong>확장 가능한 코드 템플릿</strong> 을 제공한다.</p><h1 id="소프트웨어-패턴"><a href="#소프트웨어-패턴" class="headerlink" title="소프트웨어 패턴"></a>소프트웨어 패턴</h1><p>패턴이랑 무엇인가를 논의할 때면 반복적으로 언급되는 몇 가지 핵심적인 특징이 있다.</p><ul><li>패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.</li><li>패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다.</li><li>패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.</li><li>패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.</li></ul><blockquote><p>마틴 파울러의 &lt;Analysis Pattern&gt;</p><p>패턴 정의는 하나의 실무 컨텍스트에서 유용하게 사용해왔고 다른 실무 컨텍스트에서도 유용할 것이라고 예상되는 아이디어다<br>아이디어라는 용어를 사용하는 이유는 어떤 것도 패턴이 될 수 있기 때문이다.<br>협력하는 객체그룹이 될 수도 있고, 프로젝트의 조직 원리가 될 수도 있다.<br>실무 컨텍스트라는 용어는 패턴이 실제 프로젝트의 실무 경험에서 비록됐다는 사실을 반영한다.</p></blockquote><p>패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 <strong>아이디어</strong> 이다.<br>일반적으로 패턴으로 인정하기 위해서는 최소 3가지의 서로 다른 시스템에 특별한 문제 없이 적용할 수 있고, 유용한 경우에만 패턴으로 간주할 수 있다.</p><h2 id="패턴은-경험의-산물이다"><a href="#패턴은-경험의-산물이다" class="headerlink" title="패턴은 경험의 산물이다."></a>패턴은 경험의 산물이다.</h2><p>패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점이다.  </p><p>패턴은 경험의 산물이다.<br>따라서 실무 경험이 적은 초보자라고 하더라고 패턴을 익히고 반복적으로 적용하는 과정 속에서 유연하고 품질 높은 소프트웨어를 개발하는 방법을 익힐 수 있게 된다.</p><h2 id="패턴의-이름은-높은-수준의-대화를-가능하게-한다"><a href="#패턴의-이름은-높은-수준의-대화를-가능하게-한다" class="headerlink" title="패턴의 이름은 높은 수준의 대화를 가능하게 한다."></a>패턴의 이름은 높은 수준의 대화를 가능하게 한다.</h2><p>패턴을 모르는 사람은 아래 처럼 말 뜻을 풀어서 어렵고 길게 말한다<br><strong>“인터페이스를 하나 추가하고 이 인터페이스를 구체화하는 클래스를 만들고 생성자나 setter 메서드를 통해 runtime에 알고리즘을 바꿀 수 있게 하자”</strong> </p><p>패턴을 아는 사람은<br><strong>“STRATEGY 패턴 적용하시죠”</strong> 라고 간단하고 명확하게 말할 수 있기 때문이다.</p><h1 id="패턴-분류"><a href="#패턴-분류" class="headerlink" title="패턴 분류"></a>패턴 분류</h1><p>패턴을 분류하는 가장 일반적인 방법은 패턴의 범위나 적용 단계에 따라 4가지로 분류된다.</p><ul><li>디자인 패턴(Design Pattern)<ul><li>특정 상황 내에서 일반적인 설계 문제를 해결하며 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다</li><li>특정한 설계문제를 해결하는 것을 목적으로 함</li><li>프로그래밍 언어나 패러다임에 독립적이다</li></ul></li><li>아키텍처 패턴 (Architecture Pattern)<ul><li>소프트웨어의 전체적인 구조를 결정하기 위해 사용</li><li>미리 정의된 서브시스템들을 제공하고 서브시스템들의 책임, 관계를 조직화하는 규칙과 가이드를 제공한다</li></ul></li><li>분석 패턴(Analysis Pattern)<ul><li>도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다</li><li>업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합</li></ul></li><li>이디엄(Idiom)<ul><li>특정 프로그래밍 언어에만 국한된 패턴이다</li><li>주어진 언어의 기능&#x2F;특성을 이용해 컴포넌트 간의 특정 측면을 구현하는 방법을 서술<ul><li>C++에서는 객체가 스스로 자신을 참조하는 객체들의 개수를 카운트 해서 더 이상 자신이 참조되지 않으면 스스로를 삭제하는 COUNT POINTER라는 이디엄이 있다.</li><li>하지만 JVM기반의 언어에서는 참조 되지 않은 객체들은 가비지 컬렉터에 의해 자동으로 삭제되기에 COUNT POINTER 이디엄은 유용하지 않다.</li></ul></li></ul></li></ul><h1 id="자주-쓰이는-디자인-패턴"><a href="#자주-쓰이는-디자인-패턴" class="headerlink" title="자주 쓰이는 디자인 패턴"></a>자주 쓰이는 디자인 패턴</h1><p>패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.<br>패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공한다</p><h2 id="STRATEGY-Pattern"><a href="#STRATEGY-Pattern" class="headerlink" title="STRATEGY Pattern"></a>STRATEGY Pattern</h2><p>STRATEGY Pattern은 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공한다</p><ul><li>로직내의 변하지 않는 부분을 추상화 하여 추상클래스나 인터페이스로 분리한다</li><li>구체적인 내용은 구체 클래스를 구현하여 메세지를 정의한다</li></ul><p><img src="./pay.png" alt="STRATEGY Pattern"></p><h2 id="BRIDGE-Pattern"><a href="#BRIDGE-Pattern" class="headerlink" title="BRIDGE Pattern"></a>BRIDGE Pattern</h2><p>BRIDGE Pattern은 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해하여<br>설계를 확장 가능하게 만든다.</p><p><img src="./BRIDGE_Pattern.png" alt="BRIDGE Pattern"></p><h2 id="COMPOSITE-Pattern"><a href="#COMPOSITE-Pattern" class="headerlink" title="COMPOSITE Pattern"></a>COMPOSITE Pattern</h2><p>COMPOSITE Pattern은 객체들을 트리구조로 구성하여 그릇 객체와 내용물 객체를 동일하게 취급할 수 있도록 만들기 위한 패턴</p><p><img src="./COMPOSITE_Pattern.jpeg" alt="COMPOSITE Pattern"></p><h2 id="TEMPLATE-METHOD-Pattern"><a href="#TEMPLATE-METHOD-Pattern" class="headerlink" title="TEMPLATE METHOD Pattern"></a>TEMPLATE METHOD Pattern</h2><p>TEMPLATE METHOD Pattern은 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 내용은 자식 클래스에서 정의하게 함으로써 변경을 캡슐화할 수 있는 디자인 패턴이다</p><p><img src="./TEMPLATE_METHOD_Pattern.jpeg" alt="TEMPLATE METHOD Pattern"></p><ul><li><p>calculateFee 메서드에서 추상 메서드인 calculateDiscountAmount() 메서드를 호출한다</p></li><li><p>추상 메서드 calculateDiscountAmount는 하위 클래스인 AmountDiscoutMovie, PercentDiscoutMovie 에서 직접 구현한다</p></li><li><p>그렇게 하면 calculateFee 메서드는 변경없이 사용할 수 있고 calculateDiscountAmount 메서드를 통해 기능을 확장할 수 있다.</p></li></ul><h2 id="DECORATOR-Pattern"><a href="#DECORATOR-Pattern" class="headerlink" title="DECORATOR Pattern"></a>DECORATOR Pattern</h2><p>DECORATOR Pattern은 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 이용한다.</p><p><img src="./DECORATOR_Pattern.jpeg" alt="DECORATOR Pattern"></p><ul><li>BasicRatePolicy는 실제 역할을하는 ConcreteComponent이다</li><li>AdditionalRatePolicy는 요건들을 더 추가할 수 있는 Decorator이다</li></ul><h1 id="코드-재사용과-설계-재사용"><a href="#코드-재사용과-설계-재사용" class="headerlink" title="코드 재사용과 설계 재사용"></a>코드 재사용과 설계 재사용</h1><p>코드 재사용, 설계 재사용 한쪽만 남용하는 방법은 좋지 않다.<br>가장 이상적인 재사용 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것이다.  </p><p>프레임워크란 </p><ul><li>추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계</li><li>애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 application skeleton  <strong>(설계와 코드 재사용)</strong></li></ul><p>프레임워크는 코드를 재사용함으로써 설계 아이디어를 재사용한다.<br>프레임워크는 애플리케이션의 아키텍처를 제공하며 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함한다.<br>애플리케이션을 확장할 수 있도록 부분적으로 구현된 추상 클래스와 인터페이스 집합뿐만 아니라 추가적인 작업 없이도 재사용 가능한 다양한 종류의 컴포넌트도 함께 제공한다</p><h1 id="제어-역전-원리"><a href="#제어-역전-원리" class="headerlink" title="제어 역전 원리"></a>제어 역전 원리</h1><p>의존성 역전 원리는 전통적인 설계 방법과 객체지향을 구분하는 가장 핵심적인 원리다.<br>의존성 역전 원리에 따라 구축되지 않은 시스템은 협력 흐름을 재사용할 수도 없으며 변경에 유연하게 대처할 수도 없다.<br>시스템이 진화하는 방향에는 항상 의존성 역전 원리를 따르는 설계가 존재해야 한다.<br>만약 요구사항이 빠르게 진화하는 코드에서 의존성 역전 원리가 적절하게 지켜지지 않고 있다면 그곳에는 변경을 적절하게 수용할 수 없는 하향식 코드만 남을 뿐이다.</p><p>프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다<br>그리고 이렇게 <strong>완성되지 않은 채로 남겨진 동작을 훅(Hook)</strong> 이라고 부른다<br>훅은 프레임워크 코드에서 호출하는 프레임워크의 특정 부분이다. 재정의된 훅은 제어 역전 원리에 따라 프레임워크가 원하는 시점에 호출 된다.</p><p><strong>여기서 협력을 제어하는 것은 프레임워크이다.</strong><br>이 말 자체가 제어 역전 원리이다.<br>전통적인 방식에서는 개발자가 개발한 코드를 실행하기 위해서는 개발자가 직접 객체를 생성해서 메시지를 객체에 날려야 했다.<br>하지만 <strong>프레임워크에서는 프레임워크 내의 코드가 개발자가 개발한 코드를 실행한다.</strong></p><p>이러한 제어의 역전이 프레임워크의 핵심 개념이자 코드의 재사용을 가능하게 하는 힘이다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter15. 디자인 패턴과 프레임워크</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter13. 서브클래싱과 서브타이핑</title>
      <link href="/2020/07/18/object-chapter13/"/>
      <url>/2020/07/18/object-chapter13/</url>
      
        <content type="html"><![CDATA[<h1 id="상속의-용도"><a href="#상속의-용도" class="headerlink" title="상속의 용도"></a>상속의 용도</h1><ul><li>타입 계층 구현 : 부모클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다.<ul><li>부모 클래스는 자식 클래스의 <strong>일반화(generalization)</strong></li><li>자식 클래스는 부모 클래스의 <strong>특수화(specialization)</strong></li></ul></li><li>코드 재사용<ul><li>간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있다.</li><li>재사용을 위해 상속을 사용하는 경우 부모 클래스와 자식 클래스가 강하게 결합되어 변경이 어렵다.</li></ul></li></ul><p>상속을 사용하는 이유는 객체의 <strong>행동</strong> 을 기반으로 하는 타입 계층을 구현해야 한다.<br>타입 사이의 관계를 고려하지 않은 채 단순히 코드를 재사용하기 위해 상속을 사용해서는 안된다.</p><h1 id="객체지향-프로그래밍-vs-객체기반-프로그래밍"><a href="#객체지향-프로그래밍-vs-객체기반-프로그래밍" class="headerlink" title="객체지향 프로그래밍 vs 객체기반 프로그래밍"></a>객체지향 프로그래밍 vs 객체기반 프로그래밍</h1><ul><li>객체기반 프로그래밍(Object-Based Programming)<ul><li>상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식</li><li>상속과 다형성은 지원하지 않는다</li><li>초기 버전의 비쥬얼 베이직은 객체라는 개념은 존재하지만 클래스 사이의 상속과 다형성은 존재x</li><li>클래스를 사용하지 않고 객체만 사용하는 프로그래밍 방식</li></ul></li><li>객체지향 프로그래밍(Object-Oriented Programming)<ul><li>객체기반 프로그래밍의 한 종류</li><li>상속과 다형성을 지원</li><li>Java, C++, 루비, C#등의 언어는 상속과 다형성 지원’</li><li>클래스를 사용하는 프로그래밍 방식</li></ul></li></ul><h1 id="타입"><a href="#타입" class="headerlink" title="타입"></a>타입</h1><p>객체지향 프로그래밍에서 타입의 의미를 이해하려면 두 가지 관점의 타입을 이해할 필요가 있다</p><ul><li>프로그래밍 언어 관점의 타입</li><li>개념 관점의 타입</li></ul><h2 id="개념-관점의-타입"><a href="#개념-관점의-타입" class="headerlink" title="개념 관점의 타입"></a>개념 관점의 타입</h2><p>개념 관점에서 타입이란 우리가 인지하는 세상의 사물의 종류를 의미한다.  </p><ul><li><strong>타입</strong> : 객체들에 적용하는 개념이나 아이디어<ul><li>타입은 사물을 분류하기 위한 틀로 사용된다.  </li><li>예를 들어 자바, 루비, 자바스크립트, C를 프로그래밍 언어라고 부를 때 우리는 이것들을 프로그래밍 언어라는 타입으로 분류하고 있는 것이다.</li></ul></li><li><strong>인스턴스</strong> : 어떤 대상이 타입으로 분류될 때의 대상을 가리켜 인스턴스라고 부른다.</li><li><strong>객체</strong> : 일반적으로 타입의 인스턴스를 가리켜 객체라고 부른다.</li><li><strong>심볼</strong> : 타입에 이름을 붙인 것.</li><li><strong>내연(intension)</strong> : 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동<ul><li>예를 들어 프로그래밍 언어의 정의인 <strong>컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합</strong> 이 바로 내연이다.</li></ul></li><li><strong>외연(extension)</strong> : 타입에 속하는 객체들의 집합<ul><li>예를들어 프로그래밍 언어 타입의 경우에는 자바, 루비, 자바스크립트, C가 속한 집합이 외연을 구성한다.</li></ul></li></ul><h2 id="프로그래밍-언어-관점의-타입"><a href="#프로그래밍-언어-관점의-타입" class="headerlink" title="프로그래밍 언어 관점의 타입"></a>프로그래밍 언어 관점의 타입</h2><p>프로그래밍 언어 관점에서의 타입은 연속적인 비트의 의미와 제약을 부여하기 위해 사용된다.<br>비트에 담긴 데이터를 문자열로 다룰지 정수로 다룰지는 전적으로 데이터를 사용하는 애플리케이션에 의해 결정된다.<br>따라서 프로그래밍 언어의 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 가리킨다.</p><p>프로그래밍 언어에서 타입은 두 가지 목적을 위해 사용된다.</p><h3 id="타입에-수행될-수-있는-유효한-오퍼레이션의-집합을-정의한다"><a href="#타입에-수행될-수-있는-유효한-오퍼레이션의-집합을-정의한다" class="headerlink" title="타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다"></a>타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다</h3><ul><li>자바에서 ‘+’ 연산자는 <strong>원시형 숫자 타입이나 문자열 타입의 객체에서는 사용할 수 있지만</strong> 다른 클래스의 인스턴스에 대해서는 사용할 수 없다. </li><li>C++ &#x2F; C# 에서는 연산자 오버로딩을 통해 ‘+’ 연산자 사용이 가능하다</li><li>모든 객체지향 언어들은 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한함으로써 프로그래머의 실수를 막아준다.</li></ul><h3 id="타입에-수행되는-오퍼레이션에-대해-미리-약속된-문맥을-제공한다"><a href="#타입에-수행되는-오퍼레이션에-대해-미리-약속된-문맥을-제공한다" class="headerlink" title="타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다"></a>타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다</h3><ul><li><p>정수 a + b는 a와 b를 더한다. 문자열 a + b는 a와 b에 대해 문자열을 합친다 -&gt; 즉, a 와 b에 부여된 타입이 ‘+’ 연산자의 문맥을 정의</p></li><li><p>new 연산자는 타입에 정의된 크기만큼 저장 공간을 할당하고 생성된 객체를 초기화하기 위해 타입의 생성자를 자동으로 호출한다<br>이 경우 객체를 생성하는 방법에 대한 문맥을 결정하는 것은 바로 객체의 타입이다.</p></li></ul><h2 id="객체지향-패러다임에서-바라-보는-프로그래밍-언어-관점의-타입"><a href="#객체지향-패러다임에서-바라-보는-프로그래밍-언어-관점의-타입" class="headerlink" title="객체지향 패러다임에서 바라 보는 프로그래밍 언어 관점의 타입"></a>객체지향 패러다임에서 바라 보는 프로그래밍 언어 관점의 타입</h2><p>프로그래밍 언어 관점에서의 타입은 호출 가능한 오퍼레이션의 집합을 정의한다.<br><strong>객체지향 프로그래밍에서 오퍼레이션 &#x3D; 객체가 수신할 수 있는 메시지</strong> 이다</p><p>객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의하는 것이다.<br><strong>객체가 수신할 수 있는 메시지 &#x3D; 객체의 퍼블릭 인터페이스</strong> 이다</p><p>따라서 객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다</p><h2 id="객체지향-패러다임에서-바라-보는-개념-관점의-타입"><a href="#객체지향-패러다임에서-바라-보는-개념-관점의-타입" class="headerlink" title="객체지향 패러다임에서 바라 보는 개념 관점의 타입"></a>객체지향 패러다임에서 바라 보는 개념 관점의 타입</h2><p>개념 관점에서 타입은 공통의 특성을 가진 객체들을 분류하기 위한 기준이다.<br>객체의 퍼블릭 인터페이스가 타입을 결정한다.  따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.<br><strong>객체들이 동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르면, 서로 다른 타입으로 분류된다.</strong></p><h1 id="타입-사이의-포함관계"><a href="#타입-사이의-포함관계" class="headerlink" title="타입 사이의 포함관계"></a>타입 사이의 포함관계</h1><p>수학에서 집합은 다른 집합을 포함할 수 있다.<br>타입 역시 객체들의 집합이기 때문에 다른 타입을 포함하는 것이 가능하다<br>타입 안에 포함된 객체들은 좀 더 상세한 기준으로 묶어 새로운 타입을 정의하면 이 새로운 타입은 자연스럽게 기존 타입의 부분 집합이 된다.</p><p><img src="./programming-type-instance.jpeg" alt="programming-type-instance"><br>예를 들면 자바, 루비, C++과 같은 프로그래밍 언어들은 <strong>프로그래밍 언어</strong> 라는 타입으로 묶을 수 있다.</p><p><img src="./classified-instance.jpeg" alt="classified-instance"></p><p>집합의 원소들을 상세한 기준으로 분류할 수 있다. </p><ul><li>객체지향 언어</li><li>클래스기반 언어 : 자바, C++, 루비 </li><li>프로토타입 기반 언어: 자바스크립트, 셀프</li><li>절차적 언어: C, 파스칼</li></ul><p>프로그래밍 언어 타입은 <strong>객체지향 언어</strong> 타입과 <strong>절차적 언어</strong> 로 분류할 수 있다.<br>나아가 객체지향 언어타입의 자바와 루비는 <strong>클래스 기반 언어</strong> 자바스크립트는 <strong>프로토타입 기반 언어</strong> 로 분류할 수 있다.  </p><p>타입이 다른 타입에 포함될 수 있기 때문에 동일한 인스턴스가 하나 이상의 타입으로 분류되는 것도 가능하다<br>자바는 <strong>프로그래밍 언어</strong> 인 동시에 <strong>객체지향 언어</strong> 에 속하며 더 세부적으로 <strong>클래스 기반 언어</strong> 타입에 속한다</p><p>다른 타입을 포함하는 타입은 포함되는 타입보다 좀 더 일반화된 의미를 표현할 수 있다.<br><strong>프로그래밍 언어</strong> 타입은 <strong>객체지향 언어</strong> 타입보다 더 일반적이고 <strong>객체지향 언어</strong> 타입은 <strong>클래스 기반 언어</strong> 보다 더 일반적이다.</p><p>포함하는 타입은 외연 관점에서는 더 크고 내연 관점에서는 더 일반적이다.<br>포함되는 타입은 외원 관점에서는 더 작고 내연 관점에서는 더 특수하다.<br>이것은 포함 관계로 연결된 타입 사이에 개념적으로 <strong>일반화(generalization)와 특수화(specialization)</strong> 관계가 존재한다는 것을 의미한다.</p><h2 id="타입-계층"><a href="#타입-계층" class="headerlink" title="타입 계층"></a>타입 계층</h2><p><img src="./type-tree.jpeg" alt="type-tree"></p><p>타입 계층을 표현할 때는 더 일반적인 타입을 위쪽에 더 특수한 타입을 아래쪽에 배치하는 것이 관례다.  </p><ul><li><p><strong>슈퍼타입(supertype)</strong> : 타입계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입</p><ul><li>프로그래밍 언어 타입은 객체지향 언어, 절차적 언어의 슈퍼타입이다.</li></ul></li><li><p><strong>서브타입(subtype)</strong> : 타입계층을 구성하는 두 타입 간의 관계에서 더 특수한 타입</p></li></ul><h2 id="내연과-외연-관점에서의-일반화와-특수화"><a href="#내연과-외연-관점에서의-일반화와-특수화" class="headerlink" title="내연과 외연 관점에서의 일반화와 특수화"></a>내연과 외연 관점에서의 일반화와 특수화</h2><ul><li>내연 관점<ul><li>일반화 : 어떤 타입의 정의를 좀 더 보편적이고 추상적으로 만드는 과정</li><li>특수화 : 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정</li></ul></li><li>외연 관점<ul><li>일반화 : 특수한 타입의 인스턴스 집합을 표현하는 슈퍼셋(superset)</li><li>특수화 : 일반적인 타입의 인스턴스 집합에 포함된 서브셋(subset)</li></ul></li></ul><blockquote><p>일반화는 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 행위의 결과<br>특수화는 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 행위의 결과</p></blockquote><ul><li>슈퍼타입(superset)<ul><li>집합이 다른 집합의 모든 멤버를 포함한다</li><li>타입 정의가 다른 타입보다 좀 더 일반적이다</li></ul></li><li>서브타입(subset)<ul><li>집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다</li><li>타입 정의가 다른 타입보다 좀 더 구체적이다</li></ul></li></ul><h1 id="객체지향-프로그래밍과-타입-계층"><a href="#객체지향-프로그래밍과-타입-계층" class="headerlink" title="객체지향 프로그래밍과 타입 계층"></a>객체지향 프로그래밍과 타입 계층</h1><p>객체의 타입을 결정하는 것은 퍼블릭 인터페이스다<br>일반적인 타입이란 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.  </p><p>퍼블릭 인터페이스의 관점에서 슈퍼타입과 서브타입을 다음과 같이 정의할 수 있다. </p><ul><li><p><strong>슈퍼타입</strong> 이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화 시켜 상대적으로 범용적이고 <strong>넓은 의미</strong> 로 정의한 것이다.</p></li><li><p><strong>서브타입</strong> 이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화 시켜 상대적으로 범용적이고 <strong>좁은 의미</strong> 로 정의한 것이다.</p></li></ul><h1 id="서브클래싱과-서브타이핑"><a href="#서브클래싱과-서브타이핑" class="headerlink" title="서브클래싱과 서브타이핑"></a>서브클래싱과 서브타이핑</h1><p>객체지향 프로그래밍 언어에서 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것이다.<br>그리고 타입 계층을 구현하는 일반적인 방법은 상속을 이용하는 것이다.  </p><ul><li>슈퍼타입 : 부모 클래스</li><li>서브타입 : 자식 클래스</li></ul><h2 id="언제-상속을-사용해야-하는가"><a href="#언제-상속을-사용해야-하는가" class="headerlink" title="언제 상속을 사용해야 하는가?"></a>언제 상속을 사용해야 하는가?</h2><p>아래 질문에 모두 yes라고 답할 수 있을때만 상속을 사용한다</p><ul><li>상속관계가 is-a 관계를 모델링하는가?<ul><li>일반적으로 <strong>자식 클래스 is 부모 클래스</strong> 라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.</li></ul></li><li>클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?<ul><li>상속 계층을 사용하는 클라이언트 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다.</li><li>이를 자식 클래스와 부모 클래스 사이의 <strong>행동 호환성</strong> 이라 부른다.</li></ul></li></ul><p>중요한 점은 <strong>클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?</strong> 이 질문에 포커스를 맞춰야 한다.<br>클라이언트 관점에서 두 클래스에 대해 기대하는 <strong>행동</strong> 이 다르라면 is-a 관계가 성립하더라도 상속을 사용해서는 안된다.</p><h2 id="is-a-관계"><a href="#is-a-관계" class="headerlink" title="is-a 관계"></a>is-a 관계</h2><p>두 클래스가 어휘적으로 <strong>is-a</strong> 관계를 모델링할 경우에만 상속을 사용해야 한다<br>하지만 is-a 관계가 직관적이고 명확하지는 않다  </p><p>다음의 예는 is-a 관계가 직관적이지 않음을 보여주는 예시이다</p><ul><li>펭귄은 새다</li><li>새는 날 수 있다</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;....&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Penguin</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>펭귄은 분명 새지만 날 수 없는 새이다. 하지만 코드에서는 <strong>펭귄은 새이고 날 수 있다</strong> 라고 표현되고 있다.<br>이 예는 어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다는 사실을 잘 보여준다.<br>어휘적으로는 펭귄은 새지만 만약 새의 정의에 날 수 있다는 행동이 포함된다면 펭귄은 새의 서브타입이 될 수 없다.  </p><p>타입 계층의 의미는 <strong>행동</strong> 이라는 문맥에 따라 달라질 수 있다.<br>따라서 슈퍼타입과 서브타입 관계에서는 is-a보다 행동 호환성이 더 중요하다</p><h2 id="행동-호환성"><a href="#행동-호환성" class="headerlink" title="행동 호환성"></a>행동 호환성</h2><p>타입 사이에 개념적으로 어떤 연관성이 있다고 하더라도 행동에 연관성이 없다면 is-a 관계를 사용하지 말아야 한다.<br>결론은 두 타입 사이에 행동이 호환되는 경우에만 타입 계층으로 묶어야 한다.  </p><p>행동의 호환 여부를 판단하는 기준은 <strong>클라이언트 관점</strong> 이다.<br>클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.<br>하지만 클라이언트가 두 타입이 동일하게 행동하지 않을 것이라고 기대한다면 두 타입을 타입 계층으로 묶어서는 안된다.</p><h2 id="인터페이스-분리-원칙-ISP"><a href="#인터페이스-분리-원칙-ISP" class="headerlink" title="인터페이스 분리 원칙 (ISP)"></a>인터페이스 분리 원칙 (ISP)</h2><p>클라이언트에 따라 인터페이스를 분리하면 변경에 대한 영향을 더 세밀하게 제어할 수 있다.<br>대부분의 경우 인터페이스는 <strong>클라이언트의 요구가 바뀜에 따라 변경된다</strong><br>클라이언트에 따라 인터페이스를 분리하면 각 클라이언트의 요구가 바뀌더라도 영향의 파급효과를 효과적으로 제어할 수 있게 된다.  </p><p>이처럼 <strong>인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어</strong> 하는 설계 원칙을<br><strong>인터페이스 분리 원칙(Interface Segregation Principle, ISP)</strong> 라고 한다.</p><p><strong>비대한 인터페이스</strong></p><ul><li>비대한 인터페이스를 가지는 클래스는 응집성이 없는 인터페이스를 가지는 클래스이다.  </li><li>이런 클래스의 인터페이스는 메서드의 그룹으로 분해될 수 있고, 각 그룹은 각기 다른 클라이언트 집합을 지원한다.</li></ul><p><strong>비대한 클래스</strong> </p><ul><li>클라이언트 사이에 이상하고 해로운 결합이 생기게 만든다</li><li>클라이언트가 비대한 클래스에 변경을 가하면 나머지 모든 클래스가 영향을 받는다</li></ul><p><strong>비대한 인터페이스의 단점 해결하기</strong></p><ul><li>클라이언트는 자신이 실제로 호출하는 메서드에만 의존해야 한다.</li><li>비대한 클래스의 인터페이스를 여러개로 분리함으로써 해결할 수 있다.</li><li>호출되지 않는 메서드에 대한 클라이언트의 의존성을 끊고 클라이언트가 서로에 대해 독립적이 되게 만들 수 있다.</li></ul><h1 id="서브클래싱과-서브-타이핑"><a href="#서브클래싱과-서브-타이핑" class="headerlink" title="서브클래싱과 서브 타이핑"></a>서브클래싱과 서브 타이핑</h1><ul><li><strong>서브클래싱(subclassing)</strong> : 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우<ul><li>자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.</li><li>구현상속(implementation inheritance) 또는 클래스 상속 (class inheritance)이라고 부른다</li></ul></li><li><strong>서브타이핑(subtyping)</strong> : 타입 계층을 구성하기 위해 상속을 사용하는 경우<ul><li>자식클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.</li><li>서브타이핑을 인터페이스 상속 (interface inheritance) 이라고 한다</li><li>서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다</li><li>행동 호환성을 만족 시켜야 한다.</li></ul></li></ul><p>슈퍼타입과 서브타입 사이의 관계에서 가장 중요한 것은 <strong>퍼블릭 인터페이스</strong> 이다.<br>슈퍼타입 인스턴스를 요구하는 모든 곳에서 서브타입의 인스턴스를 대신 사용하기 위해 만족해야 하는 최소한의 조건은 서브타입의 퍼블릭 인터페이스가 슈퍼 타입에서 정의한 퍼블릭 인터페이스와 동일하거나 더 많은 오퍼레이션을 포함해야 한다.<br>따라서 개념적으로 서브타입이 슈퍼타입의 퍼블릭 인터페이스를 상속받는 것 처럼 보이게 된다.</p><h1 id="리스코프-치환-원칙"><a href="#리스코프-치환-원칙" class="headerlink" title="리스코프 치환 원칙"></a>리스코프 치환 원칙</h1><p>바바라 리스코프는 올바른 상속 관계의 특징을 정의하기 위해 <strong>리스코프 치환 원칙(Liskov Substitution Principle, LSP)</strong> 을 발표했다.<br>상속 관계로 연결한 두 클래스가 서브타이핑 관계를 만족시키기 위해서는 다음의 조건을 만족해야 한다.</p><blockquote><p>S형의 각 객체 o1에 대해 T형의 객체 o2가 하나 있고,<br>T에 의해 정의된 모든 프로그램 P에서 T가 S로 치환될 때 P의 동작이 변하지 않으면 S는 T의 서브타입이다.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S o1 = new S();</span><br><span class="line">T o2 = new T();</span><br><span class="line"> </span><br><span class="line">P(o1); //정상</span><br><span class="line">P(o2); //정상 </span><br></pre></td></tr></table></figure><p>리스코프 치환 원칙을 정리하면 <strong>서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다</strong><br>클라이언트가 차이점을 인식하지 못한 채 파생 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다는 것이다.<br>리스코프 치환 원칙은 <strong>행동 호환성</strong>을 설계 원칙으로 정리한 것이다.</p><p>따라서 <strong>행동호환성을 유지함으로써 부모 클래스를 대체할 수 있도록 구현된 상속 관계</strong>만을 서브타이핑이라고 해야한다.<br>Stack과 Vector는 리스코프 치환 원칙을 위반하는 전형적인 예이다. </p><h2 id="Stack과-Vector"><a href="#Stack과-Vector" class="headerlink" title="Stack과 Vector"></a>Stack과 Vector</h2><p>클라이언트가 부모 클래스인 Vector에 대해 기대하는 행동을 Stack에서는 기대할 수 없기 때문에 행동 호환성을 만족 시키지 않는다.<br>Vector와 Stack는 Vector의 코드를 재사용하는 목적만으로 상속을 사용했기 때문에 서브클래싱 관계이다.</p><p>리스코프 치환 원칙을 위반하는 가장 큰 이유는 상속으로 인해 Stack에 포함돼서는 안 되는 Vector의 퍼블릭 인터페이스가 Stack의 퍼블릭 인터페이스에 포함됐기 때문이다.<br>Vector를 사용하는 클라이언트의 관점에서 Stack의 행동은 Vector의 행동과 호환되지 않는다.</p><h2 id="클라이언트가-보기에는"><a href="#클라이언트가-보기에는" class="headerlink" title="클라이언트가 보기에는.."></a>클라이언트가 보기에는..</h2><p>상속이 적합한지를 판단하기 위해 두 가지 질문을 다시 한번 보면</p><ul><li>(클라이언트 입장에서) 상속관계가 is-a 관계를 모델링하는가?</li><li>클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?</li></ul><p>is-a 관계는 객체지향에서 중요한 것은 객체의 속성이 아니라 객체의 행동이라는 점을 강조한다.<br>일반적으로 클라이언트를 고려하지 않은 채 개념과 속성의 측면에서 상속 관계를 정할 경우 리스코프 치환 원칙을 위반하는 서브클래싱에 이르게 될 확률이 높다.</p><p>결론적으로 상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계다.<br>서브클래싱을 구현하기 위해 상속을 사용했다면 is-a 관계라고 할 수 없다.</p><h2 id="유연한-설계의-기반"><a href="#유연한-설계의-기반" class="headerlink" title="유연한 설계의 기반"></a>유연한 설계의 기반</h2><p>리스코프 치환 원칙은 클라이언트가 어떤 자식 클래스와도 안정적으로 협력할 수 있는 상속 구조를 구현할 수 있는 가이드라인을 제공한다.<br>새로운 자식 클래스를 추가하더라도 클라이언트 입장에서 동일하게 행동하기만 한다면 클라이언트를 수정하지 않고도 상속 계층을 확장할 수 있다.<br>다시 말해서 클라이언트의 입장에서 퍼블릭 인터페이스와 행동 방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게 된다는 것이다. </p><p>자식 클래스가 클라이언트 관점에서 부모 클래스를 대체할 수 있다면<br>기능 확장을 위해 자식 클래스를 추가하더라도 코드를 수정할 필요가 없어진다.<br>따라서 리스코프 치환 원칙은 <strong>개방-폐쇄 원칙</strong>을 만족하는 설계를 위한 전제 조건이다.</p><h1 id="계약에-의한-설계와-서브타이핑"><a href="#계약에-의한-설계와-서브타이핑" class="headerlink" title="계약에 의한 설계와 서브타이핑"></a>계약에 의한 설계와 서브타이핑</h1><p>클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것을 <strong>계약에 의한 설계 (Design By Contract, DBC)</strong> 라고 부른다. </p><p>계약에 의한 설계는 사전조건, 사후조건, 클래스 불변식 세 가지 요소로 구성된다.</p><ul><li><strong>사전조건(precondition)</strong> : 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 조건</li><li><strong>사후조건(postcondition)</strong> : 메서드가 실행된 후에 클라이언트에게 보장해야 하는 조건</li><li><strong>클래스 불변식(class invariant)</strong> : 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 조건</li></ul><p>리스코프 치환 원칙은 어떤 타입이 서브타입이 되기 위해서는 슈퍼타입의 인스턴스와 협력하는 클라이언트 관점에서<br>서브타입의 인스턴스가 슈퍼타입을 대체하더라도 협력에 지장이 없어야 한다는 것을 의미한다<br>따라서 계약에 의한 설계를 사용하면 리스코프 치환 원칙이 강제하는 조건을 계약의 개념을 이용해 좀 더 명확하게 설명할 수 있다.</p><blockquote><p><strong>리스코프 치환 원칙과 계약에 의한 설계</strong></p><p>서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 <strong>계약</strong> 을 준수해야한다.</p></blockquote><h2 id="서브타입과-계약"><a href="#서브타입과-계약" class="headerlink" title="서브타입과 계약"></a>서브타입과 계약</h2><p>계약의 관점에서 상속이 초래하는 가장 큰 문제는 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 수 있다는 것이다.</p><p>계약의 관점에서 볼때 아래의 규칙을 지켜야 한다.</p><ul><li>서브타입에서 더 강력한 사전조건을 정의할 수 없다.<ul><li>사전에 슈퍼타입에서 계약한 행동을 위반한다.</li><li>예시) <ul><li>슈퍼타입 메서드의 파라미터는 정수만 들어올 수 있다.</li><li>서브타입 메서드의 파라미터는 양수만 들어올 수 있다. (더 강한 사전조건) <ul><li>슈퍼타입에서는 음수도 들어올 수 있어서 <strong>행동 호환성</strong> 이 맞지 않는다.</li></ul></li></ul></li></ul></li><li>서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.<ul><li>예시)<ul><li>슈퍼타입 메서드의 파라미터는 양수만 들어올 수 있다.</li><li>서브타입 메서드의 파라미터는 정수만 들어올 수 있다. (더 약한 사전조건) <ul><li>슈퍼타입을 사용하는 클라이언트는 어차피 양수만 넣을 것이다.</li></ul></li></ul></li></ul></li><li>서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.<ul><li>예시)<ul><li>슈퍼타입 메서드의 반환 값은 0보다 큰 값이다.</li><li>서브타입 메서드의 반환 값은 1000보다 큰 값이다. (더 강한 사후조건) <ul><li>슈퍼타입을 사용하는 클라이언트는 어차피 0보다 큰 값이면 된다</li></ul></li></ul></li></ul></li><li>서브타입에 더 약한 사후조건을 정의할 수 없다.<ul><li>예시)<ul><li>슈퍼타입 메서드의 반환 값은 1000보다 큰 값이다.</li><li>서브타입 메서드의 반환 값은 0보다 큰 값이다. (더 약한 사후조건) <ul><li>슈퍼타입을 사용하는 클라이언트는 1000보다 큰 값을 기대하기 때문에 <strong>행동 호환성</strong> 이 맞지 않는다.</li></ul></li></ul></li></ul></li></ul><p>위처럼 서브타이핑을 위해 상속을 사용하는 경우 슈퍼타입에서 클라이언트와 맺고 있는 계약에 대해 고민해야 한다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter13. 서브클래싱과 서브타이핑</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter12. 다형성</title>
      <link href="/2020/07/12/object-chapter12/"/>
      <url>/2020/07/12/object-chapter12/</url>
      
        <content type="html"><![CDATA[<h1 id="상속의-오해와-진실"><a href="#상속의-오해와-진실" class="headerlink" title="상속의 오해와 진실"></a>상속의 오해와 진실</h1><p>코드 재사용을 목적으로 상속을 사용하면 변경하기 어렵고 유연하지 못한 설계에 이를 확률이 높아진다.<br>상속의 목적은 코드 재사용이 아니다.<br><strong>상속은 타입 계층을 구조화하기 위해 사용해야 한다.</strong><br>타입 계층은 객체지향 프로그래밍의 중요한 특성 중의 하나인 다형성의 기반을 제공한다. </p><p>객체지향 패러다임이 주목받기 시작하던 초기에 상속은 타입 계층과 다형성을 구현할 수 있는 거의 유일한 방법이었다.<br>하지만 최근의 언어들은 상속 이외에도 다형성을 구현할 수 있는 다양한 방법들을 제공하고 있다.<br>따라서 상속의 중요성이 이전에 비해 많이 낮아졌다.</p><h1 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h1><p><strong>다형성(Polymorphism)</strong> 이라는 단어는 ploy(많은) + morph(형태)의 합성어로 많은 형태를 가질 수 있는 능력을 의미한다.<br>다형성을 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력으로 정의된다.<br>다형성은 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법이다. </p><h2 id="여러가지-다형성"><a href="#여러가지-다형성" class="headerlink" title="여러가지 다형성"></a>여러가지 다형성</h2><p>객체지향 프로그래밍에서 사용되는 다형성은 그림과 같이 나눌 수 있다.</p><p><img src="./polymorphism.jpeg" alt="polymorphism"></p><ul><li><strong>강제 다형성</strong> : 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식을 가리킨다.<ul><li>예) 플러스 연산자 : 숫자 연산에서는 덧셈, 문자열 연산에서는 연결 연산자로 동작한다.</li><li>일반적으로 오버로딩 다형성과 강제 다형성을 함께 사용하면 모호해질 수 있는데 실제로 어떤 메서드가 호출될지를 판단하기가 어려워지기 때문이다.</li></ul></li><li><strong>오버로딩 다형성</strong> : 일반적으로 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우를 가리킨다<ul><li>유사한 역할을 하는 메서드이지만 시그니처가 다른 경우 사용한다.</li></ul></li><li><strong>매개변수 다형성</strong> : <strong>제네릭 프로그래밍</strong> 과 관련이 깊다. 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식<ul><li>예) 자바의 List 인터페이스는 컬렉션에 보관할 요소를 임의의 타입 T로 지정하고 있다. 실제 인스턴스를 생성하는 시점에 T를 구체적인 타입으로 지정할 수 있게 한다.<br>List 인터페이스는 다양한 타입의 요소를 다루기 위해 동일한 오퍼레이션을 사용할 수 있다.</li></ul></li><li><strong>포함 다형성</strong> : 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력을 의미<ul><li>다른 말로 <strong>서브타입(Subtype) 다형성</strong> 이라고도 부른다.</li><li>일반적인 다형성을 얘기할 때 포함 다형성을 얘기한다.</li></ul></li></ul><h1 id="상속의-양면성"><a href="#상속의-양면성" class="headerlink" title="상속의 양면성"></a>상속의 양면성</h1><p>객체지향 패러다임의 근간을 이루는 아이디어는 데이터와 행동을 객체라고 불리는 하나의 실행 단위 안으로 통합하는 것이다.<br>따라서 객체지향 프로그램을 작성하기 위해서는 항상 데이터와 행동이라는 두 가지 관점을 함께 고려해야 한다.</p><h2 id="데이터-관점의-상속"><a href="#데이터-관점의-상속" class="headerlink" title="데이터 관점의 상속"></a>데이터 관점의 상속</h2><p>상속을 이용하면 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함 시킬 수 있다.<br>Lecture와 GradeLecture 두 가지 클래스가 있고, GradeLecture는 Lecture를 상속하고 있다고 하자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lecture</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> pass;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Integer&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Lecture</span><span class="params">(String title, <span class="type">int</span> pass, List&lt;Integer&gt; scores)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.title = title;</span><br><span class="line">    <span class="built_in">this</span>.pass = pass;</span><br><span class="line">    <span class="built_in">this</span>.scores = scores;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeLecture</span> <span class="keyword">extends</span> <span class="title class_">Lecture</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Grade&gt; grades;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Lecture</span><span class="params">(String title, <span class="type">int</span> pass, List&lt;Grade&gt; grades, List&lt;Integer&gt; scores)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.title = title;</span><br><span class="line">    <span class="built_in">this</span>.pass = pass;</span><br><span class="line">    <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    <span class="built_in">this</span>.scores = scores;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lecture</span> <span class="variable">lecture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GradeLecture</span>(</span><br><span class="line">  <span class="string">&quot;객체지향 프로그래밍&quot;</span>,</span><br><span class="line">  <span class="number">70</span>,</span><br><span class="line">  Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Grade</span>(<span class="string">&quot;A&quot;</span>, <span class="number">100</span>, <span class="number">95</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Grade</span>(<span class="string">&quot;B&quot;</span>, <span class="number">94</span>, <span class="number">80</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Grade</span>(<span class="string">&quot;C&quot;</span>, <span class="number">79</span>, <span class="number">70</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Grade</span>(<span class="string">&quot;D&quot;</span>, <span class="number">69</span>, <span class="number">50</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Grade</span>(<span class="string">&quot;F&quot;</span>, <span class="number">49</span>, <span class="number">0</span>),</span><br><span class="line">  ),</span><br><span class="line">  Arrays.asList(<span class="number">81</span>, <span class="number">95</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">45</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>실제 메모리 상의 GradeLecture의 인스턴스는 아래 그림과 같이 표현할 수 있다.<br>상속을 인스턴스 관점에서 바라볼 때는 개념적으로 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스가 포함되는 것으로 생각하는 것이 유용하다.<br>인스턴스를 참조하는 lecture는 GradeLecture의 인스턴스를 가리키기 때문에 특별한 방법을 사용하지 않으면 GradeLecture 안에 포함된 Lecture의 인스턴스에 직접 접근할 수 없다.</p><p><img src="./data_class.jpeg" alt="data_class"></p><p>위와 같이 자식 클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 내부에 포함하게 된다.</p><h2 id="행동-관점의-상속"><a href="#행동-관점의-상속" class="headerlink" title="행동 관점의 상속"></a>행동 관점의 상속</h2><p>상속을 이용하면 부모 클래스에서 정의한 일부 메서드를 자식 클래스에 포함 시킬 수 있다.<br>부모 클래스에 정의된 어떤 메서드가 자식 클래스에 포함될지는 언어의 종류와 각 언어에서 제공하는 접근 제어자의 의미에 따라 다르지만<br><strong>공통적으로 부모 클래스의 모든 퍼블릭 메서드는 자식 클래스의 퍼블릭 인터페이스에 포함된다.</strong><br>따라서 외부의 객체가 부모 클래스의 인스턴스에게 전송할 수 있는 모든 메세지는 자식 클래스의 인스턴스에도 전송할 수 있다.</p><p>부모 클래스의 퍼블릭 인터페이스가 자식 클래스의 퍼블릭 인터페이스에 합쳐지만 실제로 코드가 복사되어 합쳐지는 것은 아니다.<br>런타임에 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 이 메서드를 부모 클래스 안에서 탐색하기 때문이다.</p><h2 id="메서드는-인스턴스-간-공유가-가능하다"><a href="#메서드는-인스턴스-간-공유가-가능하다" class="headerlink" title="메서드는 인스턴스 간 공유가 가능하다"></a>메서드는 인스턴스 간 공유가 가능하다</h2><p>객체의 경우에는 서로 다른 상태를 저장할 수 있도록 각 인스턴스별로 독립적인 메모리를 할당받아야 한다.<br>하지만 메서드의 경우에는 동일한 클래스의 인스턴스끼리 공유가 가능하기 때문에 클래스는 한 번만 메모리에 로드하고<br>각 인스턴스별로 클래스를 가리키는 포인터를 갖게 하는 것이 경제적이다.</p><p>아래와 그림과 같이 표현할 수 있다.</p><p><img src="./class_instance.jpg" alt="class_instance"></p><p>Lecture 객체에 대한 인스턴스는 메모리에 2개가 생성되었지만 실제 메서드를 실행할 때는 class 포인터를 이용하여 클래스에 접근한다.<br>부모 클래스에 접근하기 위해서는 parent 포인터를 이용하여 접근하는 것을 볼 수 있다.</p><p>따라서 각 객체에서 class 포인터와 parent 포인터를 조합하면 현재 인스턴스의 클래스에서 최상위 부모 클래스에 이르기 까지<br>모든 부모 클래스에 접근하는 것이 가능하다.</p><h1 id="업캐스팅과-동적-바인딩"><a href="#업캐스팅과-동적-바인딩" class="headerlink" title="업캐스팅과 동적 바인딩"></a>업캐스팅과 동적 바인딩</h1><p>코드 안에서 선언된 참조 타입과 무관하게 실제로 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 달라질 수 있는 것은<br>업캐스팅과 동적 바인딩이라는 메커니즘이 작용하기 때문이다.  </p><ul><li>업캐스팅: 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다.</li><li>동적 바인딩: 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다.<br>객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에 결정하기 때문이다.</li></ul><blockquote><p>개방-폐쇄 원칙과 의존성 역전 원칙</p><p>업캐스팅과 동적 메서드 탐색은 코드를 변경하지 않고도 기능을 추가할 수 있게 해주며 이것은 개방-폐쇄 원칙의 의도와도 일치한다.<br>개방-폐쇄 원칙은 유연하고 확장 가능한 코드를 만들기 위해 의존관계를 구조화하는 방법을 설명한다.<br>업캐스팅과 동적 메서드 탐색은 상속을 이용해 개방-폐쇄 원칙을 따르는 코드를 작성할 때 하부에서 동작하는 기술적인 내부 메커니즘을 설명한다.<br>개방-폐쇄 원칙이 목적이라면 업캐스팅과 동적 메서드 탐색은 목적에 이르는 방법이다.</p></blockquote><h2 id="업캐스팅"><a href="#업캐스팅" class="headerlink" title="업캐스팅"></a>업캐스팅</h2><p>상속을 이용하면 부모 클래스의 퍼블릭 인터페이스가 자식 클래스의 퍼블릭 인터페이스에 합쳐지기 때문에 부모 클래스의 인스턴스에게 전송할 수 있는 메시지를 자식 클래스의 인스턴스에게 전송할 수 있다.<br>부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용하더라도 메시지를 처리하는 데는 아무런 문제가 없다.<br>컴파일러는 명시적인 타입 변환 없이도 자식 클래스가 부모 클래스를 대체할 수 있게 허용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lecture</span> <span class="variable">lecture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GradeLecture</span>();</span><br></pre></td></tr></table></figure><p>부모 클래스 타입으로 선언된 파라미터에 자식 클래스 인스턴스를 전달하는 것도 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Professor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Professor</span><span class="params">(String name, Lecture lecture)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Professor</span> <span class="variable">professor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Professor</span>(<span class="string">&quot;교수님&quot;</span>, <span class="keyword">new</span> <span class="title class_">GradeLecture</span>());</span><br></pre></td></tr></table></figure><p>반대로 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해서는 명시적인 타입 캐스팅이 필요하다.<br>이를 <strong>다운캐스팅(downcasting)</strong> 이라고 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lecture</span> <span class="variable">lecture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GradeLecture</span>();</span><br><span class="line"><span class="type">GradeLecture</span> <span class="variable">gradeLecture</span> <span class="operator">=</span> (GradeLecture) lecture;</span><br></pre></td></tr></table></figure><p><img src="./up-down_casting.jpeg" alt="up-down_casting"></p><h2 id="동적-바인딩"><a href="#동적-바인딩" class="headerlink" title="동적 바인딩"></a>동적 바인딩</h2><p>전통적인 언어에서 함수를 실행하는 방법은 함수를 호출하는 것이다.<br>객체지향 언어에서 메서드를 실행하는 방법은 메시지를 전송하는 것이다.<br>이 두가지의 메커니즘은 완전히 다르다. </p><ul><li>함수 호출 <ul><li>코드를 작성하는 시점에 호출될 코드가 결정된다.</li><li>컴파일 타임에 호출할 함수를 결정하는 방식을</li></ul></li></ul><p><strong>정적 바인딩(static binding), 초기 바인딩(early binding), 컴파일타임 바인딩(compile-time binding)</strong> 이라고 부른다.</p><ul><li>메서드 호출<ul><li>메시지를 수신했을 때 실행될 메서드가 런타임에 결정된다. </li><li>실행될 메서드를 런타임에 결정하는 방식을 <strong>동적 바인딩(dynamic binding), 지연 바인딩(late binding)</strong> 이라고 부른다.</li><li>실행 시점에 어떤 클래스의 인스턴스에 메시지를 전달하는지 알아야 실제 실행되는 메서드를 알 수 있다.</li></ul></li></ul><h1 id="동적-메서드-탐색과-다형성"><a href="#동적-메서드-탐색과-다형성" class="headerlink" title="동적 메서드 탐색과 다형성"></a>동적 메서드 탐색과 다형성</h1><p>객체지향 시스템은 다음 규칙에 따라 실행할 메서드를 선택한다. </p><ul><li>메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한다.<ul><li>존재하면 메서드를 실행하고 탐색을 종료한다.</li></ul></li><li>메서드를 찾이 못했다면, 부모 클래스에서 메서드 탐색을 계속한다.<ul><li>메서드를 찾을 때까지 상속 계층을 따라 올라가며 계속된다.</li></ul></li><li>상속 계층의 최상위 클래스에 이르렀지만 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색을 중단한다.</li></ul><h2 id="self-참조-self-reference"><a href="#self-참조-self-reference" class="headerlink" title="self 참조 (self reference)"></a>self 참조 (self reference)</h2><p>메시지 탐색과 관련해서 이해해야할 중요한 변수로 <strong>self 참조 (self reference)</strong> 라는 변수이다.<br>self 변수는 아래와 같이 동작한다.</p><ul><li>객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 후 메시지를 수신한 객체를 가리키도록 설정한다. </li><li>동적 메서드 탐색은 self가 가리키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로 이뤄진다.</li><li>메서드 탐색이 종료되는 순간 self 참조는 자동으로 소멸된다.</li><li>자바에서는 self 참조를 this라고 부른다.</li></ul><h2 id="동적-메서드-탐색하기"><a href="#동적-메서드-탐색하기" class="headerlink" title="동적 메서드 탐색하기"></a>동적 메서드 탐색하기</h2><p>self 참조를 통해 상속계층을 따라 동적으로 메서드 탐색이 이루어진다. </p><p><img src="./method_find.jpeg" alt="method_find"></p><p>메서드 탐색은 자식 클래스에서 부모 클래스의 방향으로 진행된다.<br>따라서 항상 자식 클래스의 메서드가 부모 클래스의 메서드보다 먼저 탐색되기 때문에 자식 클래스에 선언된 메서드가<br>부모 클래스의 메서드보다 더 높은 우선 순위를 가진다.</p><p>동적 메서드 탐색은 두 가지 원리로 구성된다.</p><ul><li><strong>자동적인 메시지 위임</strong> : 자식 클래스는 자신이 이해할 수 없는 메시지를 전송받은 경우 자동으로 상속 계층을 따라 부모 클래스에게 처리를 위임한다.</li><li><strong>메서드를 탐색하기 위해 동적인 문맥을 사용</strong> : 메시지를 수신했을 때 실제로 어떤 메서드를 실행할지는 런타임에 이뤄지며 self 참조를 이용해서 결정한다.<br>(self가 가리키는 인스턴스를 기준으로 탐색을 시작한다.)</li></ul><p>메시지가 처리되는 문맥을 이해하기 위해서는 정적인 코드를 분석하는 것만으로는 충분하지 않다.<br>런타임에 실제로 메시지를 수신한 객체가 어떤 타입인지를 추적해야 한다.<br>이 객체의 타입에 따라 메서드를 탐색하는 문맥이 동적으로 결정되며, 여기서 가장 중요한 역할을 하는 것이 바로 self 참조다.</p><h2 id="자동적인-메시지-위임"><a href="#자동적인-메시지-위임" class="headerlink" title="자동적인 메시지 위임"></a>자동적인 메시지 위임</h2><p>상속을 이용할 경우 메시지를 처리할 방법을 알지 못할 경우 메시지에 대한 처리를 부모 클래스에 위임한다.<br>적절한 메서드를 <strong>찾을 때까지</strong> 상속 계층을 따라 부모 클래스로 처리가 위임된다.<br>상속을 이용할 경우 프로그래머가 메시지 위임과 관련된 코드를 명시적으로 작성할 필요가 없다. <strong>메시지는 상속 계층을 따라 자동적으로 위임된다.</strong></p><p>자식 클래스 -&gt; 부모 클래스의 방향으로 메시지 처리가 위임되기 때문에 자식 클래스에서 어떤 메서드를 구현하고 있느냐에 따라 부모 클래스에 구현된 메서드의 운명이 결정된다.</p><h2 id="동적인-문맥"><a href="#동적인-문맥" class="headerlink" title="동적인 문맥"></a>동적인 문맥</h2><p>상속을 이용하면 메시지를 수신한 객체가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 동적으로 바뀐다는 것이다.<br>이 동적인 문맥을 결정하는 것은 바로 메시지를 수신한 객체를 가리키는 self 참조다.</p><p>동일한 코드라고 하더라도 self 참조가 가리키는 객체가 무엇인지에 따라 메서드 탐색을 위한 상속 계층의 범위가 동적으로 변한다.<br>따라서 self 참조가 가리키는 객체의 타입을 변경함으로써 객체가 실행될 문맥을 동적으로 바꿀 수 있다.</p><h2 id="self가-self에게"><a href="#self가-self에게" class="headerlink" title="self가 self에게"></a>self가 self에게</h2><p>self 참조가 동적인 문맥을 결정한다는 사실은 종종 어떤 메서드가 실행될지를 예상하기 어렵게 만든다.<br>대표적인 경우가 <strong>자신에게 다시 메시지를 전송하는 self 전송이다</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lecture</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">stats</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;Title: %s. Evaluation Method: %s&quot;</span>, title, getEvaluationMethod());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getEvaluationMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Pass or Fail&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stats() 메서드에서 getEvaluationMethod() 메시지를 전송하였다.<br>현재 클래스의 메서드를 호출 하는 것이 아닌 현재 객체에게 getEvaluationMethod를 전송하는 것이다.<br><strong>즉 self 참조가 가리키는 객체에게 getEvaluationMethod 메시지를 전송한 것이다.</strong></p><p>self 전송을 이해하기 위해서는 self 참조가 가리키는 바로 그 객체에서부터 메시지 탐색을 다시 시작한다는 사실이다.</p><p><img src="./self.jpeg" alt="self"></p><h1 id="이해할-수-없는-메시지"><a href="#이해할-수-없는-메시지" class="headerlink" title="이해할 수 없는 메시지"></a>이해할 수 없는 메시지</h1><p>클래스는 자신이 처리할 수 없는 메시지를 수신하면 부모 클래스로 처리를 위임한다.<br>이해할 수 없는 메시지를 처리하는 방법은 정적 언어인지, 동적 언어인지에 따라 달라진다.</p><h2 id="정적-타입-언어와-이해할-수-없는-메시지"><a href="#정적-타입-언어와-이해할-수-없는-메시지" class="headerlink" title="정적 타입 언어와 이해할 수 없는 메시지"></a>정적 타입 언어와 이해할 수 없는 메시지</h2><p>정적 타입 언어에서는 <strong>코드를 컴파일할 때</strong> 상속 계층 안의 클래스들이 메시지를 이해할 수 있는지 여부를 판단한다.<br>따라서 상속 계층 전체를 탐색한 후에도 메시지를 처리할 수 있는 메서드를 발견하지 못했다면 컴파일 에러를 발생시킨다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lecture</span> <span class="variable">lecture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GradeLecture</span>();</span><br><span class="line">lecture.unknownMessage(); <span class="comment">//컴파일 에러!</span></span><br></pre></td></tr></table></figure><p>이 경우 상속 계층을 따라 <code>unknownMessage</code>를 처리할 수 있는 메서드가 존재하는 지 검색한다.<br>만약 최상위 클래스까지 탐색을 했는데 <code>unknownMessage</code>를 이해할 수 없다면 더 이상 부모 클래스가 존재하지 않기 때문에 컴파일 에러를 발생시켜 메시지를 처리할 수 없다는 사실을 프로그래머에게 알린다. </p><h2 id="동적-타입-언어와-이해할-수-없는-메세지"><a href="#동적-타입-언어와-이해할-수-없는-메세지" class="headerlink" title="동적 타입 언어와 이해할 수 없는 메세지"></a>동적 타입 언어와 이해할 수 없는 메세지</h2><p>동적 타입에서도 메시지를 수신한 객체의 클래스로 부터 부모 클래스의 방향으로 메서드를 탐색한다.<br>동적 타입 언어에서는 컴파일 단계가 존재하지 않기 때문에 실제로 코드를 실행해보기 전에는 메시지 처리 가능 여부를 판단할 수 없다.</p><p>몇 가지 동적 타입 언어는 최상위 클래스까지 메서드를 탐색한 후에 메서드를 처리할 수 없다는 사실을 발견하면 self 참조가 가리키는 현재 객체에게 메시지를 이해할 수 없다는 메시지를 전송한다.  </p><ul><li>스몰토크 : doesNotUnderstand 메시지를 전송한다</li><li>루비 : method_missing 메시지를 전송한다</li></ul><p>이해할 수 없는 메시지를 처리할 수 있는 동적 타입 언어는 좀 더 순수한 관점에서 객체지향 패러다임을 구현한다고 볼 수 있다.<br>협력을 위해 메시지를 전송하는 객체는 메시지를 수신한 객체의 내부 구현에 대해 알지 못한다.<br>단지 객체가 메시지를 처리할 수 있다고 믿고 메시지를 전송할 뿐이다.</p><p>동적 타입 언어는 이해할 수 없는 메시지를 처리할 수 있는 능력을 가짐으로써 메시지가 선언된 인터페이스와 메서드가 정의된 구현을 분리할 수 있다.<br>하지만 동적 타입 언어의 이러한 동적인 특성과 유연성은 코드를 이해하고 수정하기 어렵게 만든다.<br>정적 타입 언어에는 이런 유연성은 부족하지만 컴파일타임에 확인되고 이해할 수 없는 메시지는 컴파일에러로 이어져 좀 더 안정적이다.</p><h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><p>자식 클래스에서 부모 클래스의 구현을 재사용해야 하는 경우가 있다.<br>대부분의 객체지향 언어들은 자식 클래스에서 부모 클래스의 인스턴스 변수나 메서드에 접근하기 위해 사용할 수 있는 super 참조라는 내부 변수를 제공한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeLecture</span> <span class="keyword">extends</span> <span class="title class_">Lecture</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">evaluate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.evaluate() + <span class="string">&quot;, &quot;</span> + gradesStatistics();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormattedGradeLecture</span> <span class="keyword">extends</span> <span class="title class_">GradeLecture</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FormattedGradeLecture</span><span class="params">(String name, <span class="type">int</span> pass, List&lt;Grade&gt; grades, List&lt;Integer&gt; scores)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, pass, grades, scores);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">formatAverage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;Avg: %1.1f&quot;</span>, <span class="built_in">super</span>.average());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./super_find.jpeg" alt="super_find"></p><p>super 참조의 정확한 의도는 <strong>지금 self 참조가 가리키는 클래스의 부모 클래스에서 부터 메서드 탐색을 시작하세요</strong> 이다.<br>만약 부모 클래스에서 원하는 메서드를 찾지 못한다면 더 상위의 부모 클래스로 이동하면서 메서드가 존재하는지 검사한다.</p><p>이것은 super 참조를 통해 실행하고자 하는 메서드가 반드시 부모 클래스에 위치하지 않아도 되는 유연성을 제공한다.<br>그 메서드가 조상 클래스 어딘가에 있기만 하면 성공적으로 탐색될 것이기 때문이다.</p><p>이 처럼 super 참조를 통해 메시지를 전송하는 것을 <strong>super 전송(super send)</strong> 이라고 부른다.</p><blockquote><p>super 전송과 동적 바인딩</p><p>상속에서 super가 컴파일 시점에 미리 결정된다고 설명했지만 super를 런타임에 결정하는 경우도 있다.<br>믹스인을 사용하는 경우에는 런타임에 동적으로 결정된다.<br>스칼라의 traits는 super의 대상을 믹스인 되는 순서에 따라 동적으로 결정한다.<br>따라서 사용하는 언어의 특성에 따라 컴파일 시점이 아닌 실행 시점에 super의 대상이 결정될 수도 있다는 점을 기억해야 한다.</p></blockquote><h1 id="위임과-self"><a href="#위임과-self" class="headerlink" title="위임과 self"></a>위임과 self</h1><p>상속을 이용하면 자식 클래스에서 메시지를 처리하지 못하는 경우 상속 계층에 따라 메시지를 위임한다.<br>이 경우 self참조는 무엇을 가리키는가?<br>메시지를 위임하더라도 self는 맨 처음 메시지를 수신한 객체를 가리킨다.</p><p><img src="./delegate.jpeg" alt="delegate"></p><h1 id="프로토타입-기반의-객체지향-언어"><a href="#프로토타입-기반의-객체지향-언어" class="headerlink" title="프로토타입 기반의 객체지향 언어"></a>프로토타입 기반의 객체지향 언어</h1><p>다른 언어에서는 클래스가 아닌 객체를 이용해서도 상속을 흉내내고 있다.<br>클래스가 존재하지 않고 오직 객체만 존재하는 프로토타입 기반의 객체지향 언어에서 상속을 구현하는 유일한 방법은 객체 사이의 위임을 이용하는 것이다.<br>클래스 기반의 객체지향 언어들이 상속을 이용해 클래스 사이에 self 참조를 자동으로 전달하는 것처럼 프로토타입 기반의 객체지향 언어들 역시 위임을 이용해 객체 사이에 self 참조를 자동으로 전달한다.</p><p>현재 가장 널리 사용되는 프로토타입 기반의 객체지향 언어는 <strong>자바스크립트</strong> 이다.<br>자바스크립트의 모든 객체들은 다른 객체를 가리키는 용도로 사용되는 <code>prototype</code> 이라는 이름의 링크를 가진다.  </p><p><code>prototype</code>은 언어 차원에서 제공되기 때문에 self 참조를 직접 전달하거나 메세지 포워딩을 번거롭게 구현하지 않아도 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Lecture</span>(<span class="params">name, scores</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">scores</span> = scores;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Lecture</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">stats</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;, Evaludation Method: &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">getEvaluationMethod</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Lecture</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getEvaluationMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Pass or Fail&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자바스크립트의 인스턴스는 메시지를 수신하면 먼저 메시지를 수신한 객체의 prototype 안에서 메시지에 응답할 적절한 메서드가 있는지 검사한다.<br>만약 메서드가 존재하지 않는다면 prototype이 가리키는 객체를 따라 메시지 처리를 자동적으로 위임한다.<br>자바스크립트에서는 prototype 체인으로 연결된 객체 사이에 메시지를 위임함으로써 상속을 구현할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GradeLecture</span>(<span class="params">name, canceled, scores</span>) &#123;</span><br><span class="line">  <span class="title class_">Lecture</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, scores);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">canceled</span> = canceled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">GradeLecture</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Lecture</span>();</span><br><span class="line"><span class="title class_">GradeLecture</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">GradeLecture</span>;</span><br><span class="line"><span class="title class_">GradeLecture</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getEvaludationMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Grade&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드에서는 GradeLecture의 prototype에 Lecture 인스턴스를 할당했다.<br>이 과정을 통해 GradeLecture를 이용해 생성된 모든 객체들이 prototype을 통해 Lecture에 정의된 모든 속성과 함수에 접근할 수 있게 된다.</p><p>이제 메시지를 전송하면 prototype으로 연결된 객체 사이의 경로를 통해 객체 사이의 메서드 탐색이 자동으로 이뤄진다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> grade_lecture = <span class="keyword">new</span> <span class="title class_">GradeLecture</span>(<span class="string">&quot;OOP&quot;</span>, <span class="literal">false</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">grade_lecture.<span class="title function_">stats</span>();</span><br></pre></td></tr></table></figure><p><img src="./prototype_chain.jpeg" alt="prototype_chain"></p><p>자바스크립트에서는 클래스가 존재하지 않기 때문에 오직 객체들 사이의 메시지 위임만을 이용해 다형성을 구현한다.<br>이것은 객체지향 패러다임에서 클래스가 필수 요소가 아니라는 점을 잘 보여준다.<br>또한 상속 이외의 방법으로도 다형성을 구현할 수 있다는 사실을 잘 보여준다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter12. 다형성</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter11. 합성과 유연한 설계</title>
      <link href="/2020/07/11/object-chapter11/"/>
      <url>/2020/07/11/object-chapter11/</url>
      
        <content type="html"><![CDATA[<h1 id="상속과-합성"><a href="#상속과-합성" class="headerlink" title="상속과 합성"></a>상속과 합성</h1><p>상속과 합성은 객체지향 프로그래밍에서 가장 널리 사용되는 코드 재사용 기법이다.  </p><ul><li>상속<ul><li>부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용한다</li><li>컴파일 타임 의존성을 가진다 (정적인 관계)</li><li>is-a 관계</li><li>부모 클래스의 내부 구현에 대해 상세히 알아야하기 때문에 자식 클래스와 부모 클래스 사이의 결합도가 높아진다.</li><li>부모 클래스에 구현된 코드를 재사용한다</li></ul></li><li>합성<ul><li>전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다</li><li>런타임 의존성을 가진다 (동적인 관계) </li><li>has-a 관계</li><li>클래스와 클래스간의 퍼블릭 인터페이스에 의존하여 결합도가 낮다.</li><li>내부 구현의 변경의 영향이 최소화 된다</li><li>객체의 퍼블릭 인터페이스를 재사용한다</li></ul></li></ul><p>코드 작성 시점에 결정된 상속 관계는 런타임에 변경이 불가하지만 합성 관계는 실행 시점에 동적으로 변경할 수 있기 때문에<br>상속 대신 합성을 사용하면 변경하기 쉽고 유연한 설계를 얻을 수 있다.</p><blockquote><p><strong>화이트박스 재사용 (white-box reuse)</strong><br>상속으로 인한 재사용을 일컫는다. 상속을 받으면 부모 클래스의 내부가 자식 클래스에 공개되기 때문에 화이트 박스인 셈이다.</p></blockquote><blockquote><p><strong>블랙박스 재사용 (black-box reuse)</strong><br>합성으로 인한 재사용을 일컫는다. 합성 시에는 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문이다.</p></blockquote><h1 id="상속을-합성으로-변경하기"><a href="#상속을-합성으로-변경하기" class="headerlink" title="상속을 합성으로 변경하기"></a>상속을 합성으로 변경하기</h1><p>코드의 재사용을 위해 상속을 남용하는 경우 발생하는 문제점은 아래와 같다.</p><ul><li>불필요한 인터페이스 상속문제</li><li>메서드 오버라이딩 오작용 문제</li><li>부모 클래스와 자식 클래스의 동시 수정 문제</li></ul><p>합성을 사용하면 상속이 초래하는 문제점을 해결할 수 있다.<br>상속을 합성으로 바꾸는 방법은 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.</p><h2 id="불필요한-인터페이스-상속문제"><a href="#불필요한-인터페이스-상속문제" class="headerlink" title="불필요한 인터페이스 상속문제"></a>불필요한 인터페이스 상속문제</h2><p>상속을 이용한 Stack에서는 부모클래스에서 제공하는 퍼블릭 인터페이스 때문에 Stack의 규칙을 위반할 수 있다.<br>Vector는 임의의 위치(index)에서 요소를 조회하고, 추가하고, 삭제할 수 있는 get, add, remove 오퍼레이션을 제공한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;1st&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;2nd&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;3rd&quot;</span>);</span><br><span class="line">stack.add(<span class="number">0</span>, <span class="string">&quot;4th&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;4th&quot;</span>, stack.pop()); <span class="comment">//에러</span></span><br></pre></td></tr></table></figure><p>기존 상속을 이용하던 Stack을 합성으로 바꿔보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span>&lt;E&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Vector&lt;E&gt; elements = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">push</span><span class="params">(E item)</span> &#123;</span><br><span class="line">    elements.add(item);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(elements.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements.remove(elements.size()-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 Vector의 퍼블릭 인터페이스는 Stack에 포함되지 않는다.<br>클라이언트는 더 이상 임의의 위치에 요소를 추가하거나 삭제할 수 없다.  따라서 Stack의 규칙을 깰 수 있는 요소가 없게 된다.</p><h2 id="메서드-오버라이딩의-오작용-문제-InstrumentedHashSet"><a href="#메서드-오버라이딩의-오작용-문제-InstrumentedHashSet" class="headerlink" title="메서드 오버라이딩의 오작용 문제: InstrumentedHashSet"></a>메서드 오버라이딩의 오작용 문제: InstrumentedHashSet</h2><p>상속을 이용한 기존 InstrumentedHashSet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentedHashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">addCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    addCount += c.size();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.addAll(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기존에 상속을 이용하던 InstrumentedHashSet을 합성으로 바꿔보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentedHashSet</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">addCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> Set&lt;E&gt; set;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">InstrumentedHashSet</span><span class="params">(Set&lt;E&gt; set)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.set = set;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addCount++;</span><br><span class="line">    <span class="keyword">return</span> set.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    addCount += c.size();</span><br><span class="line">    <span class="keyword">return</span> set.addAll(c);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAddCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addCount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 과정까지는 위의 Stack의 예제와 같다.<br>하지만 InstrumentedHashSet은 기존의 HashSet의 퍼블릭 인터페이스까지 제공을 해야한다.</p><p>이를 해결하기 위해 아래와 같이 코드를 작성하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentedHashSet</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">addCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> Set&lt;E&gt; set;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">InstrumentedHashSet</span><span class="params">(Set&lt;E&gt; set)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.set = set;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addCount++;</span><br><span class="line">    <span class="keyword">return</span> set.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    addCount += c.size();</span><br><span class="line">    <span class="keyword">return</span> set.addAll(c);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAddCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addCount;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E e)</span> &#123;<span class="keyword">return</span> set.remove(e);&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.clear();&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(E e)</span> &#123;<span class="keyword">return</span> set.equals(e);&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.hashCode();&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.spliterator();&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.isEmpty(e);&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span> &#123;<span class="keyword">return</span> set.contains(e);&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.iterator();&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> E[] toArray(E e) &#123;<span class="keyword">return</span> set.remove(e);&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>포워딩 메서드(forwarding method)</strong></p><p>위와 같이 오퍼레이션을 오버라이딩한 인스턴스 메서드에서 내부의 HashSet 인스턴스에게 동일한 메서드 호출을 그대로 전달하는 것을 알 수 있다.<br>이를 <strong>포워딩(forwarding)</strong> 이라 부르고 동일한 메서드를 호출하기 위해 추가된 메서드를 <strong>포워딩 메서드(forwarding method)</strong> 라고 부른다.<br>포워딩은 기존 클래스의 인터페이스를 그대로 외부에 제공하면서 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 사용하는 유용한 기법이다.</p></blockquote><h1 id="상속으로-인한-조합의-폭발적인-증가"><a href="#상속으로-인한-조합의-폭발적인-증가" class="headerlink" title="상속으로 인한 조합의 폭발적인 증가"></a>상속으로 인한 조합의 폭발적인 증가</h1><p>상속으로 인해 결합도가 높아지면 코드를 수정하는 데 필요한 작업의 양이 과도하게 증가할 수 있다.<br>일반적으로 작은 기능들을 조합해서 더 큰 기능을 수행하는 객체를 만들어야 하는 경우이다.</p><ul><li>하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.</li><li>단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.</li></ul><p><img src="./class_explosion.jpg" alt="class explosion"></p><p>위의 이미지와 같이 상속의 남용으로 모든 케이스에 대한 조합을 클래스로 표현하는 경우를 가리켜 클래스 폭발(class explosion)이라 한다.  또는 조합의 폭발이라 한다.<br>클래스 폭발 문제는 자식 클래스가 부모 클래스의 구현에 강하게 결합되도록 강요하는 상속의 근본적인 한계로 인해 발생하는 문제다.<br>클래스 폭발 문제는 새로운 기능을 추가하는 경우에는 많은 코드를 변경해야 할 뿐만 아니라 기능을 추가하는 경우에도 기하급수적으로 클래스가 생성될 수 있다.</p><h1 id="합성-관계로-변경하기"><a href="#합성-관계로-변경하기" class="headerlink" title="합성 관계로 변경하기"></a>합성 관계로 변경하기</h1><p>상속 관계는 컴파일타임에 결정되고 고정되기 때문에 코드를 실행하는 도중에는 변경할 수 없다.<br>따라서 여러 기능을 조합해야하는 설계에 상속을 이용하면 모든 조합 가능한 경우별로 클래스를 추가해야한다.</p><p>하지만 합성을 사용하면 컴파일 관계를 런타임 관계로 변경함으로써 이 문제를 해결한다.<br>합성을 사용하면 구현이 아닌 퍼블릭 인터페이스에 대해서만 의존할 수 있기 때문에 런타임에 객체의 관계를 변경할 수 있다.</p><p>따라서 합성을 사용하면 구현 시점에 관계를 고정시킬 필요가 없으며 실행 시점에 정책들의 관계를 유연하게 변경할 수 있다.<br>컴파일 의존성에 속박되지 않고 다양한 방식의 런타임 의존성을 구성할 수 있다는 것이 합성이 제공하는 가장 커다란 장점이다.</p><p>위의 상속관계로 나온 case를 합성을 사용하면 아래와 같이 사용할 수 있다.</p><p><img src="./composition.jpg" alt="composition"></p><p><img src="./composition2.jpg" alt="composition2"></p><h1 id="믹스인"><a href="#믹스인" class="headerlink" title="믹스인"></a>믹스인</h1><p>믹스인(mixin)은 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법을 가리키는 용어다.<br>합성이 실행 시점에 객체를 조합하는 재사용 방법이라면 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법이다.  </p><h2 id="믹스인은-상속과는-다르다"><a href="#믹스인은-상속과는-다르다" class="headerlink" title="믹스인은 상속과는 다르다"></a>믹스인은 상속과는 다르다</h2><p>믹스인이 상속이 유사한 것 처럼 보이겠지만 사실은 다르다.<br>상속의 결과로 부모 클래스의 코드를 재사용한다는 사실은 맞지만 상속의 목적은 자식 클래스를 부모 클래스와 동일한 개념적인 범주로 묶어 is-a 관계를 만들기 위한 것이다.<br>반면 믹스인은 말 그래로 코드를 다른 코드 안에 섞어 넣기 위한 방법이다.   </p><p>상속이 클래스와 클래스 사이의 관계를 고정시키는 데 비해 믹스인은 유연하게 관계를 재구성 할 수 있다.<br>믹스인은 코드 재사용에 특화된 방법이면서도 상속과 같은 결합도 문제를 초래하지 않는다.</p><blockquote><p><strong>믹스인의 유래</strong></p><p>믹스인은 Flavors라는 언어에서 처음으로 도입됐고 이후 Flavors의 특징을 흡수한 CLOS(Common Lisp Object System)에 의해 대중화됐다.  </p></blockquote><h2 id="트레이트-trait"><a href="#트레이트-trait" class="headerlink" title="트레이트(trait)"></a>트레이트(trait)</h2><p>스칼라 언어에서 제공하는 믹스인 기법이다.<br>간단하게 설명하면 trait는 <strong>super</strong> 라는 코드가 부모클래스 하나를 고정하지 않는다.<br>super는 런타임에 달라질 수 있으며 실제로 trait가 믹스인 되는 시점에 결정된다. (실행시점에 결정)  </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RateDiscountablePolicy</span> <span class="keyword">extends</span> <span class="title">BasicRatePolicy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> discountAmount: <span class="type">Money</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">calculateFee</span></span>(phone: <span class="type">Phone</span>): <span class="type">Money</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> fee = <span class="keyword">super</span>.calculateFee(phone)</span><br><span class="line">    fee - discountAmount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제에서 super는 BasicRatePolicy의 클래스 어떤 것이든 될 수 있다.<br>BasicRatePolicy 클래스이든, BasicRatePolicy를 상속한 자식 클래스이든 trait에 대한 코드를 믹스인 할 수 있다.</p><h2 id="트레이트의-선형화"><a href="#트레이트의-선형화" class="headerlink" title="트레이트의 선형화"></a>트레이트의 선형화</h2><p>스칼라는 특정 클래스에 믹스인한 클래스와 트레이트를 선형화해서 어떤 메서드를 호출할 지 결정한다.<br>클래스의 인스턴스를 생성할 때 스칼라는 클래스 자신과 조상 클래스, 트레이트를 일렬로 나열해서 순서를 정한다.<br>그리고 실행 중인 메서드 내부에서 super 호출을 하면 다음 단계에 위치한 클래스나 트레이트의 메서드가 호출된다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RateDiscountableAndTaxableRegularPolicy</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">  amount: <span class="type">Money</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  seconds: <span class="type">Duration</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  val taxRate: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">RegularPolicy</span>(amount, seconds)</span><br><span class="line"><span class="keyword">with</span> <span class="type">TaxablePolicy</span></span><br><span class="line"><span class="keyword">with</span> <span class="type">RateDiscountablePolicy</span></span><br></pre></td></tr></table></figure><p>위와 같은 클래스에서는 아래와 같이 선형화 된다.</p><p><img src="./trait_serialization.jpg" alt="trait serialization"></p><p>만약 RateDiscountableAndTaxableRegularPolicy 인스턴스가 calculateFee 메시지를 수신했다고 가정하면 RateDiscountableAndTaxableRegularPolicy에는 calculateFee 메서드가 없기 때문에 다음 단계에 위치한 RateDiscountablePolicy에서 calculateFee 메서드가 존재하는지 찾는다.<br>RateDiscountablePolicy에서 calculateFee를 찾으면 실행한다.<br>RateDiscountablePolicy에서 또 super.calculateFee를 호출하기 때문에 위의 단계인 TaxablePolicy의 calculateFee 메서드를 찾는다.<br>이렇게 올라가다 보면 BasicRatePolicy의 기본요금부터 재귀호출 되듯이 코드가 실행되며 내려오기 때문에 금액 계산이 순차적으로 된다.</p><p>만약 RateDiscountablePolicy와 TaxablePolicy의 순서를 바꾸고 싶다면</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RateDiscountableAndTaxableRegularPolicy</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">  amount: <span class="type">Money</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  seconds: <span class="type">Duration</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  val taxRate: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">RegularPolicy</span>(amount, seconds)</span><br><span class="line"><span class="keyword">with</span> <span class="type">RateDiscountablePolicy</span></span><br><span class="line"><span class="keyword">with</span> <span class="type">TaxablePolicy</span></span><br></pre></td></tr></table></figure><p>아래와 같이 코드를 변경하여 선형화된 순서를 바꿀 수 있다.</p><h2 id="믹스인을-사용하더라도-클래스-폭발이-남아있는-것인가"><a href="#믹스인을-사용하더라도-클래스-폭발이-남아있는-것인가" class="headerlink" title="믹스인을 사용하더라도 클래스 폭발이 남아있는 것인가?"></a>믹스인을 사용하더라도 클래스 폭발이 남아있는 것인가?</h2><p>믹스인을 사용하더라도 상속에서 클래스의 숫자가 기하급수적으로 늘어나는 클래스 폭발 문제는 여전히 남아있는게 아니냐고 반문할 수 있다.<br>클래스 폭발 문제의 단점은 클래스가 늘어난다는 것이 아니라 클래스가 늘어날수록 중복 코드도 함께 기하급수적으로 늘어난다는 점이다.<br>믹스인은 이런 문제가 발생하지 않는다.</p><p>또 클래스를 만들지 않고도 믹스인을 사용할 수 있다. </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">RegularPolicy</span>(<span class="type">Money</span>(<span class="number">100</span>), <span class="type">Duration</span>.ofSecond(<span class="number">10</span>))</span><br><span class="line">  <span class="keyword">with</span> <span class="type">RateDiscountablePolicy</span></span><br><span class="line">  <span class="keyword">with</span> <span class="type">TaxablePolicy</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> discountAmount = <span class="type">Money</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">val</span> taxRate = <span class="number">0.02</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>하지만 코드 여러 곳에서 동일한 트레이트를 믹스인해서 사용해야 한다면 명시적으로 클래스를 정의하는게 좋다.</p><h1 id="쌓을-수-있는-변경"><a href="#쌓을-수-있는-변경" class="headerlink" title="쌓을 수 있는 변경"></a>쌓을 수 있는 변경</h1><p>믹스인은 상속 계층 안에서 확장한 클래스보다 더 하위에 위치하게 된다.<br>다시 말해 믹스인은 대상 클래스의 자식 클래스처럼 사용될 용도로 만들어 지는 것이다.  </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RateDiscountableAndTaxableRegularPolicy</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">  amount: <span class="type">Money</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  seconds: <span class="type">Duration</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  val taxRate: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">RegularPolicy</span>(amount, seconds)</span><br><span class="line"><span class="keyword">with</span> <span class="type">RateDiscountablePolicy</span></span><br><span class="line"><span class="keyword">with</span> <span class="type">TaxablePolicy</span></span><br></pre></td></tr></table></figure><p>위의 코드 처럼 trait를 믹스인한 with 구문은 항상 extends 구문 뒤에 나온다.</p><p>믹스인을 사용하면 특정한 클래스에 대한 변경 또는 확장을 독립적으로 구현한 후 필요한 시점에 차례대로 추가할 수 있다.<br>믹스인의 이러한 특징을 <strong>쌓을 수 있는 변경(stackable modification)</strong> 이라고 부른다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter11. 합성과 유연한 설계</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter10. 유연한 설계</title>
      <link href="/2020/07/05/object-chapter10/"/>
      <url>/2020/07/05/object-chapter10/</url>
      
        <content type="html"><![CDATA[<h1 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h1><p>객체지향 프로그래밍의 장점 중 하나는 코드를 재사용하기가 용이하다는 점이다.<br>전통적인 패러다임에서는 코드를 복사 후 붙여넣기 하고 수정하여 코드를 재사용하였다.<br>객체지향에서는 코드를 재사용하기 위해 새로운 코드를 추가한다.<br>재사용 관점에서 상속이란 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현 기법이다.</p><h1 id="상속과-중복-코드"><a href="#상속과-중복-코드" class="headerlink" title="상속과 중복 코드"></a>상속과 중복 코드</h1><p>객체지향 프로그래밍을 배울때 부터 기본적으로 중복 코드는 제거해야한다고 배우고 시작한다.<br>그렇기 때문에 습관적으로 중복코드가 보이면 하나로 합치는 작업을 하게된다.  </p><p>상속을 이용해 코드를 재사용하기 위해서는 부모 클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야 한다.<br>이것은 자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 한다는 것을 의미한다.<br>따라서 상속은 결합도를 높이며, 이 높은 결합도로 인해 코드를 수정하기 어렵게 만든다.</p><blockquote><p>상속을 위한 경고1<br>자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다.<br>super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.</p></blockquote><h2 id="Dry-원칙"><a href="#Dry-원칙" class="headerlink" title="Dry 원칙"></a>Dry 원칙</h2><p>신뢰할 수 있고 수정하기 쉬운 소프트웨어를 만드는 효과적인 방법 중 하나는 중복을 제거하는 것이다.<br>따라서 프로그래머들은 DRY 원칙을 따라야 한다.<br>Dry 원칙이란, <strong>반복하지 마라</strong> 라는 뜻의 Don’t Refeat Yourself의 첫 글자를 모아 만든 용어로 동일한 지식을 중복하지 말라는 것이다.<br>Dry 원칙은 한 번, 단 한번 (Once and Only Once) 원칙 또는 단일 지점 제어 (Single-Point Control) 원칙이라고 부른다.<br>원칙의 이름이 무엇이건, 코드 안에 중복이 존재해서는 안 된다는 것이다.  </p><h2 id="중복을-제거해야하는-이유"><a href="#중복을-제거해야하는-이유" class="headerlink" title="중복을 제거해야하는 이유"></a>중복을 제거해야하는 이유</h2><p><strong>중복 코드는 변경을 방해한다.</strong> 이것이 중복 코드를 제거해야 하는 가장 큰 이유다.<br>중복 코드가 가지는 가장 큰 문제는 코드를 수정하는 데 필요한 노력을 몇 배로 증가시킨다는 것이다.  </p><ul><li>우선 어떤 코드가 중복 코드인지 찾아야 한다</li><li>중복 코드를 찾았으면 모든 코드를 일관되게 수정해야 한다. </li><li>모든 중복 코드를 개별적으로 테스트 해서 동일한 결과가 나오는지 확인해야 한다.<br>이런 작업들 때문에 중복 코드는 수정과 테스트에 드는 비용을 증가시킬뿐만 아니라 개발자를 힘들게 만든다.</li></ul><h2 id="어떤-코드가-중복-코드인가"><a href="#어떤-코드가-중복-코드인가" class="headerlink" title="어떤 코드가 중복 코드인가?"></a>어떤 코드가 중복 코드인가?</h2><p>중복 여부를 판단하는 기준은 변경이다.<br>요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복이다. (함께 수정할 필요가 없다면 중복이 아니다.)<br>중복 코드를 결정하는 기준은 코드의 모양이 아니다. (유사하다는 것은 단지 중복의 징후일 뿐이다.)</p><h1 id="취약한-기반-클래스-문제"><a href="#취약한-기반-클래스-문제" class="headerlink" title="취약한 기반 클래스 문제"></a>취약한 기반 클래스 문제</h1><p>자식 클래스는 부모 클래스의 불필요한 세부사항에 엮이게 된다.<br>부모 클래스의 작은 변경에도 자식 클래스는 컴파일 오류와 실행 에러라는 고통에 시달려야 할 수도 있다.<br>이처럼 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상을 <strong>취약한 기반 클래스 문제</strong> 라고 부른다.<br>상속을 사용한다면 피할 수 없는 객체지향 프로그래밍의 근본적인 취약성이다.</p><h2 id="높은-결합도"><a href="#높은-결합도" class="headerlink" title="높은 결합도"></a>높은 결합도</h2><p>취약한 기반 클래스 문제는 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리키는 용어다.<br>상속 관계를 추가할수록 전체 시스템의 결합도가 높아진다는 사실을 알고 있어야 한다.<br>상속은 자식 클래스를 점진적으로 추가해서 기능을 확장하는 데는 용이하지만 높은 결합도로 인해 부모 클래스를 점진적으로 개선하는 것은 어렵게 만든다.</p><h2 id="캡슐화-약화"><a href="#캡슐화-약화" class="headerlink" title="캡슐화 약화"></a>캡슐화 약화</h2><p>취약한 기반 클래스 문제는 캡슐화를 약화시키고 결합도를 높인다.<br>상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다.<br>객체를 사용하는 이유는 구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화할 수 있기 때문이다.<br>캡슐화는 변경에 의한 파급효과를 제어할 수 있기 때문에 가치가 있다.<br>객체는 변경될지도 모르는 불안정한 요소를 캡슐화함으로써 파급효과를 걱정하지 않고도 자유롭게 내부를 변경할 수 있다.</p><p>상속을 이용하면 부모 클래스의 퍼블릭 인터페이스가 아닌 구현을 변경하더라도 자식 클래스가 영향을 받기 쉬워진다.<br>상속 계층의 상위에 위치한 클래스에 가해지는 작은 변경만으로도 상속 계층에 속한 모든 자손들이 급격하게 요동칠 수 있다.  </p><h1 id="불필요한-인터페이스-상속-문제"><a href="#불필요한-인터페이스-상속-문제" class="headerlink" title="불필요한 인터페이스 상속 문제"></a>불필요한 인터페이스 상속 문제</h1><p>자바 초기 버전에서 상속을 잘못 사용한 대표적인 사례는 두 가지가 있다.</p><ul><li>java.util.Properties</li><li>java.util.Stack</li></ul><p>위의 두 클래스의 공통점은 부모 클래스에서 상속받은 메서드를 사용할 경우 자식 클래스의 규칙이 위반될 수 있다는 것이다.</p><h2 id="Stack의-문제점"><a href="#Stack의-문제점" class="headerlink" title="Stack의 문제점"></a>Stack의 문제점</h2><p>Stack은 가장 나중에 추가된 요소가 가장 먼저 추출되는 (Last In First Out, LIFO) 자료 구조인 스택을 구현한 클래스다.<br>Vector는 임의의 위치에서 요소를 추출하고 삽입할 수 있는 리스트 자료 구조의 구현체로서 java.util.List의 초기버전이라고 할 수 있다.<br>자바의 초기 컬렉션 프레임워크 개발자들은 요소의 추가, 삭제 오퍼레이션을 제공하는 Vector를 재사용하기 위해 Stack을 Vector의 자식 클래스로 구현했다.</p><p><img src="./Stack.jpg" alt="Stack"></p><p>그림 10.1의 퍼블릭 인터페이스를 살펴보면 이 상속 관계가 가지는 문제점을 잘 알 수 있다.<br>Vector는 임의의 위치(index)에서 요소를 조회하고, 추가하고, 삭제할 수 있는 get, add, remove 오퍼레이션을 제공한다.<br>이에 비해 Stack은 맨 마지막 위치에서만 요소를 추가하거나 제거할 수 있는 push, pop 오퍼레이션을 제공한다.<br>Stack은 Vector를 상속받기 때문에 Stack의 퍼블릭 인터페이스에 Vector의 퍼블릭 인터페이스가 합쳐진다.<br>따라서 Stack에게 상속된 Vector의 퍼블릭 인터페이스를 이용하면 임의의 위치에서 요소를 추가하거나 삭제할 수 있다.<br>따라서 맨 마지막 위치에서만 요소를 추가하거나 제거할 수 있도록 허용하는 Stack의 규칙을 쉽게 위반할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;1st&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;2nd&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;3rd&quot;</span>);</span><br><span class="line">stack.add(<span class="number">0</span>, <span class="string">&quot;4th&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;4th&quot;</span>, stack.pop()); <span class="comment">//에러</span></span><br></pre></td></tr></table></figure><p>위 코드에서 Stack에 마지막으로 추가한 값은 <strong>4th</strong>이지만 pop 메서드의 반환값은 <strong>3rd</strong>이다.<br>그 이유는 Vector의 add 메서드를 이용해서 스택의 맨 앞에 <strong>4th</strong>를 추가했기 때문이다.</p><p>Stack의 예는 퍼블릭 인터페이스에 대한 고려 없이 단순히 코드 재사용을 위해 상속을 이용하는 것이 얼마나 위험한지를 잘 보여준다.<br>객체지향의 핵심은 객체들의 협력이다.<br>단순히 코드를 재사용하기 위해 오퍼레이션이 인터페이스에 스며들도록 방치해서는 안 된다.</p><blockquote><p>상속을 위한 경고2<br>상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.</p></blockquote><h1 id="메서드-오버라이딩의-부작용-문제"><a href="#메서드-오버라이딩의-부작용-문제" class="headerlink" title="메서드 오버라이딩의 부작용 문제"></a>메서드 오버라이딩의 부작용 문제</h1><p>이펙티브 자바에서 HashSet의 구현에 강하게 결합된 InstrumentedHashSet 클래스를 소개한다.<br>InstrumentedHashSet은 HashSet의 내부에 저장된 요소의 수를 셀 수 있는 기능을 추가한 클래스로서 HashSet의 자식 클래스로 구현돼 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentedHashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">addCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    addCount += c.size();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.addAll(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 아래의 코드를 실행했을때 결과를 예측해보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InstrumentedHashSet&lt;String&gt; languages = <span class="keyword">new</span> <span class="title class_">InstrumentedHashSet</span>&lt;&gt;();</span><br><span class="line">languages.addAll(Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Ruby&quot;</span>, <span class="string">&quot;Scala&quot;</span>));</span><br></pre></td></tr></table></figure><p>눈에 보이는 코드만 보면 결과는 <strong>3</strong> 이라고 예상된다.<br>하지만 실제 결과는 <strong>6</strong>이다.  왜 6이 리턴되었을까?</p><p>사실은 HashSet의 addAll 메서드에서 add 메서드를 호출하기 때문이다.<br>부모클래스의 구현을 자세히 알지 못한 채 사용했기 때문에 예상과 다르게 동작한 것이다.   </p><p>이 문제를 해결하기 위해 InstrumentedHashSet 클래스의 addAll 메서드를 제거할 수 있다.<br>이러면 컬렉션을 파라미터로 전달하는 경우에는 자동으로 HashSet의 addAll 메서드가 호출되고 내부적으로 추가하려는 각 요소에 대해 InstrumentedHashSet의 add 메서드가 호출되어 예상했던 결과가 나올 것이다.<br>이 방법 또한 문제가 될 수 있는데 나중에 HashSet의 addAll 메서드가 add 메시지를 전송하지 않도록 수정된다면 addAll 메서드를 이용해 추가되는 요소들에 대한 카운트가 누락될 것이기 때문이다.</p><p>이를 해결하기 위한 가장 좋은 방법은 addAll 메서드를 오버라이딩하고 추가되는 각 요소에 대해 한번씩 add 메세지를 호출하는 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentedHashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">      <span class="keyword">if</span>(add(e)) &#123;</span><br><span class="line">        modified = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 위의 방법도 문제가 없는 것은 아니다.<br>바로 오버라이딩 된 addAll 메서드의 구현이 HashSet의 것과 동일하다는 것이다.<br>즉, 미래에 발생할지 모르는 위험을 방지하기 위해 코드를 중복시킨 것이다. </p><blockquote><p>상속을 위한 경고3<br>자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.</p></blockquote><p>이펙티브 자바에서는 <strong>상속을 할 경우에는 상속을 위해 클래스를 설계하고 문서화해야 하며, 그렇지 않은 경우에는 상속을 금지해야 한다고 한다.</strong>  </p><h1 id="부모-클래스와-자식-클래스의-동시-수정-문제"><a href="#부모-클래스와-자식-클래스의-동시-수정-문제" class="headerlink" title="부모 클래스와 자식 클래스의 동시 수정 문제"></a>부모 클래스와 자식 클래스의 동시 수정 문제</h1><p>자식 클래스가 부모 클래스의 메서드를 오버라이딩하거나 불필요한 인터페이스를 상속받지 않았음에도<br>부모 클래스를 수정할 때 자식 클래스를 함께 수정해야 할 수도 있다는 사실을 잘 보여준다.<br>상속을 사용하면 자식 클래스가 부모 클래스의 구현에 강하게 결합되기 때문에 이 문제를 피하기는 어렵다.  </p><p>부모 클래스와 자식 클래스 간의 결합도가 높기 때문에 코드를 함께 수정해야 하는 상황 역시 빈번하게 발생할 수 밖에 없는 것이다.  </p><blockquote><p>서브클래스는 올바른 기능을 위해 슈퍼클래스의 세부적인 구현에 의존한다.<br>슈퍼클래스의 구현은 릴리스를 거치면서 변경될 수 있고, 그에 따라 서브클래스의 코드를 변경하지 않더라도 깨질 수 있다.<br>결과적으로, 슈퍼클래스의 작성자가 확장될 목적으로 특별히 그 클래스를 설계하지 않았다면 서브클래스는 슈퍼클래스와 보조를 맞춰서 진화해야 한다.</p></blockquote><blockquote><p>상속을 위한 경고 4<br>클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없다.</p></blockquote><h1 id="추상화에-의존된-코드를-작성하라"><a href="#추상화에-의존된-코드를-작성하라" class="headerlink" title="추상화에 의존된 코드를 작성하라"></a>추상화에 의존된 코드를 작성하라</h1><p>자식 클래스는 부모 클래스에 강하게 결합되기 때문에 부모 클래스가 변경될 경우 함께 변경될 가능성이 높다.<br>이 문제를 해결하는 가장 일반적인 방법은 자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 만드는 것이다.<br>정확하게 말해서 부모 클래스와 자식 클래스 모두 추상화에 의존하도록 수정해야 한다.  </p><p>코드 중복을 제거하기 위해 상속을 도입할 때 따르는 두 가지 원칙이 있다.  </p><ul><li><strong>두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라.</strong> 메세드 추출을 통해 동일한 형태로 보이도록 만들 수 있다.<br>흔히 말하는 <strong>“변하는 것으로 부터 변하지 않는 것을 분리하라” “변하는 부분을 찾고 이를 캡슐화하라”</strong> 라는 조언을 메서드 수준에서 적용한 것이다.</li><li><strong>부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라.</strong><br>부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.</li></ul><h1 id="추상화가-핵심이다"><a href="#추상화가-핵심이다" class="headerlink" title="추상화가 핵심이다"></a>추상화가 핵심이다</h1><p><strong>추상화의 장점</strong></p><ul><li>공통 코드를 이동시킨 후에 각 클래스는 서로 다른 변경의 이유를 가진다는 것에 주목하라.<br>이런 클래스는 단일 책임의 원칙을 준수하기 때문에 응집도가 높다.  </li><li>부모 클래스 역시 자신의 내부에 구현된 추상 메서드를 호출 하기 때문에 추상화에 의존한다고 말할 수 있다.  </li><li>새로운 자식 클래스를 추가하기 쉬운 구조가 된다.  추상 클래스 내의 추상 메서드만 구현하면 되기 때문이다.  </li><li>새로운 자식 클래스가 추가되도 다른 클래스를 수정할 필요가 없다<br>현재의 설계는 확장에는 열려 있고 수정에는 닫혀 있기 때문에 개방-폐쇄 원칙 역시 준수한다.</li></ul><h1 id="차이에-의한-프로그래밍"><a href="#차이에-의한-프로그래밍" class="headerlink" title="차이에 의한 프로그래밍"></a>차이에 의한 프로그래밍</h1><p>상속을 사용하면 이미 존재하는 클래스의 코드를 기반으로 다른 부분을 구현함으로써 새로운 기능을 쉽고 빠르게 추가할 수 있다.<br>상속이 강력한 이유는 익숙한 개념을 이용해서 새로운 개념을 쉽고 빠르게 추가할 수 있기 때문이다.  </p><p>이처럼 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법을 <strong>차이에 의한 프로그래밍(programming by difference)</strong> 이라고 부른다.</p><p>차이에 의한 프로그래밍의 목표는 중복 코드를 제거하고 코드를 재사용하는 것이다.<br>사실 중복 제거와 코드 재사용은 동일한 행동을 가리키는 서로 다른 단어다.<br>중복을 제거하기 위해서는 코드를 재사용 가능한 단위로 분해하고 재구성해야 한다.<br>코드를 재사용하기 위해서는 중복 코드를 제거해서 하나의 모듈로 모아야 한다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter10. 유연한 설계</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter9. 유연한 설계</title>
      <link href="/2020/06/14/object-chapter9/"/>
      <url>/2020/06/14/object-chapter9/</url>
      
        <content type="html"><![CDATA[<h1 id="개방-폐쇄-원칙"><a href="#개방-폐쇄-원칙" class="headerlink" title="개방-폐쇄 원칙"></a>개방-폐쇄 원칙</h1><p>개방폐쇄의 원칙(OCP, Open-Closed Principle)은 다음과 같이 설명된다.</p><blockquote><p>소프트웨어 개채(클래스, 모듈, 함수 등등)는 <strong>확장</strong>에 대해 열려 있어야 하고, <strong>수정</strong>에 대해서는 닫혀 있어야 한다.</p></blockquote><p>여기서의 키워드는 확장과 수정이다.</p><ul><li>확장에 대해 열려있다 - 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 동작을 추가해서 애플리케이션의 기능을 확장할 수 있다.</li><li>수정에 대해 닫혀있다 - 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.</li></ul><h2 id="컴파일타임-의존성을-고정시키고-런타임-의존성을-변경하라"><a href="#컴파일타임-의존성을-고정시키고-런타임-의존성을-변경하라" class="headerlink" title="컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라"></a>컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라</h2><p>사실 개방-폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 이야기다.  </p><ul><li>런타임 의존성 - 실행 시에 협력에 참여하는 객체들 사이의 관계다.  </li><li>컴파일타임 의존성 - 코드에서 드러나는 클래스들 사이의 관계다.</li></ul><p><img src="./diff-dependencies.jpg" alt="compile-time-dependency vs run-time-dependency"></p><p>위의 코드에서는 개방-폐쇄 정책을 이미 따르고 있다.<br>만약 복합 할인 정책이 추가되는 경우 기존의 코드는 수정하지 않고 <code>OpverlappedDiscountPolicy</code> 만 추가하여 기능을 <strong>확장</strong> 할 수 있다<br>따라서 <strong>확장</strong>에 대해 열려 있어야 하고, <strong>수정</strong>에 대해서는 닫혀있다.</p><p><img src="./open-closed-dependency.jpg" alt="open-closed dependency"></p><h2 id="추상화가-핵심이다"><a href="#추상화가-핵심이다" class="headerlink" title="추상화가 핵심이다."></a>추상화가 핵심이다.</h2><p>개방-폐쇄 원칙의 핵심은 <strong>추상화에 의존하는 것</strong>이다.  여기서 <code>추상화</code> 와 <code>의존</code> 이라는 두 개념 모두가 중요하다.</p><p>추상화란 <strong>핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법</strong>이다.<br>추상화 과정을 거치면 문맥이 바뀌더라도 <strong>변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략된다.</strong><br>추상화를 사용하면 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.</p><p>따라서 추상화 부분은 수정에 닫혀 있다. (공통적인 부분은 변하지 않는다)<br><strong>추상화를 통해 생략된 부분은 확장의 여지를 남긴다.</strong> 이것이 추상화가 개방-폐쇄 원칙을 가능하게 만드는 이유다.</p><p>하지만 단순히 어떤 개념을 추상화했다고 해서 수정에 대해 닫혀 있는 설게를 만들 수 있는 것은 아니다.<br>개방-폐쇄 원칙에서 폐쇄를 가능하게 하는 것은 의존성의 방향이다.<br>수정에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Money <span class="title function_">calculateMovieFee</span><span class="params">(Screening screening)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fee.minus(discountPolicy.calculateDiscountAmount(screening));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제에서는 Movie 클래스는 안정적인 DiscountPolicy에 대해서만 의존한다.<br>따라서 할인정책이 수정되더도 calculateMovieFee 메서드는 수정하지 않고 DiscountPolicy 객체만 변경하면 되기 때문에<br><strong>수정</strong> 에 닫혀 있고 <strong>확장</strong> 에 열려 있는 구조가 된다.</p><h1 id="생성-사용-분리"><a href="#생성-사용-분리" class="headerlink" title="생성 사용 분리"></a>생성 사용 분리</h1><p>결합도가 높아질수록 개방-폐쇄 원칙을 따르는 구조를 설계하기가 어려워진다. 알아야 하는 지식이 많으면 결합도도 높아진다.<br>특히 객체 생성에 대한 지식은 과도한 결합도를 초래하는 경향이 있다.</p><p>객체의 타입과 생성자에 전달해야 하는 인자에 대한 과도한 지식은 코드를 특정한 컨텍스트에 강하게 결합시킨다.<br>컨텍스트를 바꾸기 위한 유일한 방법은 코드 안에 명시돼 있는 컨텍스트에 대한 정보를 직접 수정하는 것 뿐이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String title, Duration runningTime, Money fee)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = <span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Money <span class="title function_">calculateMovieFee</span><span class="params">(Screening screening)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fee.minus(discountPolicy.calculateDiscountAmount(screening));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>위의 코드에서 <code>AmountDiscountPolicy</code> 를 <code>PercentDiscountPolicy</code> 로 변경하는 방법은 직접 코드를 수정하는 방법 뿐이다.<br>이것은 동작을 추가하거나 변경하기 위해 기존의 코드를 수정하도록 만들기 때문에 개방-폐쇄 원칙을 위반한다.</p><p>따라서 유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 두 가지 책임을 서로 다른 객체로 분리해야 한다.<br>하나는 <strong>생성하는 것</strong>, 하나는 <strong>객체를 사용하는 것</strong> 이다.<br>한 마디로 말해서 객체에 대한 생성과 사용을 분리(seperation use from creation) 해야 한다.</p><p>사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법은 객체를 생성할 책임을 클라이언트로 옮기는 것이다.<br>다시 말하면 Movie의 클라이언트가 적절한 DiscountPolicy 인스턴스를 생성한 후, Movie에게 전달하는 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Money <span class="title function_">getAvatarFee</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Movie</span> <span class="variable">avatar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>), <span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br><span class="line">    <span class="keyword">return</span> avartar.getFee();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>현재 컨텍스트에 관한 결정권을 가지고 있는 클라이언트로 컨텍스트에 대한 지식을 옮김으로써 Movie는 특정한 클라이언트에 결합되지 않고 독립적일 수 있다.</p><h2 id="Factory-추가하기"><a href="#Factory-추가하기" class="headerlink" title="Factory 추가하기"></a>Factory 추가하기</h2><p>생성 책임을 Client로 옮긴 배경에는 Movie는 특정 컨텍스트에 묶여서는 안 되지만 Client는 묶여도 상관이 없다는 전제가 깔려있다.<br>하지만 Movie를 사용하는 Client도 특정한 컨텐스트에 묶이지 않기를 바란다고 가정해보자.</p><p>Client의 코드를 다시 보면 Movie의 인스턴스를 생성하는 동시에 getFee 메세지도 함께 전송한다는 것을 알 수 있다.<br>Client 역시 생성과 사용의 책임을 함께 지니고 있는 것이다.</p><p>이 경우에는 객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가하고 Client는 이 객체를 사용하도록 만들 수 있다.<br>이처럼 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 FACTORY라고 부른다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Movie <span class="title function_">createAvartarMovie</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>), <span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Factory factory;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Client</span><span class="params">(Factory factory)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.factory = factory;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Money <span class="title function_">getAvatarFee</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Movie</span> <span class="variable">avatar</span> <span class="operator">=</span> factory.createAvartarMovie();</span><br><span class="line">    <span class="keyword">return</span> avartar.getFee();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제는 Client는 Factory를 사용하여 생성된 Movie의 인스턴스를 반환받아 사용하기만 하면 된다.</p><p>factory를 사용하면 Movie와 AmountDiscountPolicy를 생성하는 책임을 모두 FACTORY로 이동할 수 있다.<br>이제 Client에는 사용과 관련된 책임만 남게 되는데 하나는 FACTORY를 통해 생성된 Movie 객체를 얻기 위한 것이고<br>다른 하나는 Movie를 통해 가격을 계산하기 위한 것이다.<br>Client는 오직 사용과 관련된 책임만 지고 생성과 관련된 어떤 지식도 가지지 않을 수 있다.</p><p><img src="./factory.jpg" alt="factory"></p><h2 id="순수한-가공물에게-책임-할당하기"><a href="#순수한-가공물에게-책임-할당하기" class="headerlink" title="순수한 가공물에게 책임 할당하기"></a>순수한 가공물에게 책임 할당하기</h2><p>책임 할당의 가장 기본이 되는 원칙은 책임을 수행하는 데 필요한 정보를 가장 많이 알고 있는 INFORMATION EXPERT에게 책임을 할당하는 것이다.<br>어떤 책임을 할당하고 싶다면 제일 먼저 도메인 모델 안의 개념 중에서 적절한 후보가 존재하는지 찾아봐야 한다. </p><p>하지만 방금전에 추가한 Factory는 도메인 모델에 속하지 않는다.<br>Factory를 추가한 이유는 순수하게 기술적인 결정이다. 전체적으로 결합도를 낮추고 재사용성을 높이기 위해 도메인 개념에게 할당돼 있던 객체 생성 책임을<br>도메인 개념과는 아무런 상관이 없는 가공의 객체로 이동시킨 것이다.</p><h2 id="표면적-분해-vs-행위적-분해"><a href="#표면적-분해-vs-행위적-분해" class="headerlink" title="표면적 분해 vs 행위적 분해"></a>표면적 분해 vs 행위적 분해</h2><ul><li>표면적 분해 - 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것<ul><li>도메인 모델에 담겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목적으로 한다.</li><li>객체지향 설계를 위한 가장 기본적인 접근법</li></ul></li><li>행위적 분해 - 도메인 개념을 표현한 객체가 아닌 설계자가 편의를 위해 임의로 만든 객체를 이용해 시스템을 분해하는 것<ul><li>도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로는 부족한 경우 발생</li><li>데이터베이스 접근을 위한 객체와 같이 도메인 개념들을 초월하는 기계적인 개념이 필요한 경우도 있다. (DAO와 같은.)</li><li>책임을 할당하기 위해 창조죄는 도메인과 무관한 인공적인 객체를  PURE FABRICATION(순수한 가공물)이라 한다.</li><li>어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재 하지 않는 경우 PURE FABRICATION을 생성하고<br>이 객체에게 책임을 할당하면 된다.</li><li>객체지향 어플리케이션에서는 도메인 개념을 반영하는 객체들 보다 인공적으로 창조한 객체들이 더 많은 비중을 차지한다.</li></ul></li></ul><blockquote><p>PURE FABRICATION 패턴</p><p>객체지향 설게는 문제 도메인 상의 개념을 소프트웨어 객체로 구현하고 책임을 할당한다. 하지만 만약 도메인 객체에 책임을 할당할 경우<br>HIGH COHESION, LOW COUPLING, 재사용성 등의 목적을 위반한다면 어떻게 해야 하는가?  </p><p>문제 도메인 개념을 표현하지 않는, 인위적으로 또는 편의상 만든 클래스에 매우 응집된 책임을 할당하라. 이들 클래스는<br>문제 도메인 상에는 존재하지 않지만 순수하게 전체 설계의 품질을 높이기 위해 설계자의 임의에 따라 추가한 상상속의 가공물이다.</p><p>PURE FABRICATION은 INFORMATION EXPERT 패턴에 따라 책임을 할당한 결과가 바람직하지 않을 경우 대안으로 사용된다.<br>어떤 객체가 책임을 수행하는 데 필요한 많은 정보를 가졌지만 해당 책임을 할당할 경우 응집도가 낮아지고 결합도가 높아진다면<br>가공의 객체를 추가해서 책임을 옮기는 것을 고민하라 </p><p>순수한 가공물(pure fabrication)이라는 표현은 적절한 대안이 없을때 사람들이 창조적인 무언가를 만들어낸다는 것을 의미하는 관용적인 표현이다.</p></blockquote><h1 id="의존성-주입"><a href="#의존성-주입" class="headerlink" title="의존성 주입"></a>의존성 주입</h1><p>사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 <strong>의존성 주입</strong> 이라고 부른다.<br>이 기법을 의존성 주입이라고 부르는 이유는 외부에서 의존성의 대상을 해결한 후 사용하는 객체 쪽으로 주입하기 때문이다.</p><p>의존성 주입은 의존성을 해결하기 위해 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내서 외부에서 필요한 런타임 의존성을 전달할 수 있도록<br>만드는 방법을 포괄하는 명칭이다.</p><h2 id="생성자-주입-Constructor-Injection"><a href="#생성자-주입-Constructor-Injection" class="headerlink" title="생성자 주입 (Constructor Injection)"></a>생성자 주입 (Constructor Injection)</h2><p>객체를 생성하는 시점에 생성자를 통한 의존성 주입</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Movie</span> <span class="variable">avartar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>), <span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br></pre></td></tr></table></figure><h2 id="setter-주입-Setter-Injection"><a href="#setter-주입-Setter-Injection" class="headerlink" title="setter 주입 (Setter Injection)"></a>setter 주입 (Setter Injection)</h2><p>setter 주입은 이미 생성된 객체에 대해 setter 메서드를 통해 의존성을 해결한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Movie</span> <span class="variable">avartar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>));</span><br><span class="line">avartar.setDiscountPolicy(<span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br></pre></td></tr></table></figure><p>setter 주입의 단점은 객체가 올바로 생성되기 위해 어떤 의존성이 필수적인지를 명시적으로 표현할 수 없다는 것이다.<br>setter 메서드는 객체가 생성된 후에 호출돼야 하기 때문에 setter 메서드 호출을 누락한다면 객체는 비정상적인 상태로 생성될 것이다.</p><h2 id="메서드-주입-Method-Injection"><a href="#메서드-주입-Method-Injection" class="headerlink" title="메서드 주입 (Method Injection)"></a>메서드 주입 (Method Injection)</h2><p>메서드 주입은 메서드 호출 주입 (method call injection)이라고도 부르며 메서드가 의존성을 필요로 하는 유일한 경우일 때 사용할 수 있다.<br>생성자 주입을 통해 의존성을 전달받으면 객체가 올바른 상태로 생성되는 데 필요한 의존성을 명확하게 표현할 수 있다는 장점이 있지만<br>주입된 의존성이 1~2개의 메서드에서만 사용된다면 각 메서드의 인자로 전달하는 것이 더 나은 방법일 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Movie</span> <span class="variable">avartar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>));</span><br><span class="line">avartar.calculateDiscountAmount(screnning, <span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br></pre></td></tr></table></figure><h2 id="숨겨진-의존성은-나쁘다"><a href="#숨겨진-의존성은-나쁘다" class="headerlink" title="숨겨진 의존성은 나쁘다"></a>숨겨진 의존성은 나쁘다</h2><p>의존성 주입 외에도 의존성을 해결할 수 있는 방법이 존재한다.<br>대표적인 방법은 SERVICE LOCATOR 패턴이다. SERVICE LOCATOR는 의존성을 해결할 객체들을 보관하는 일종의 저장소다.<br>외부에서 객체에게 의존성을 전달하는 의존성 주입과 달리 SERVICE LOCATOR의 경우 객체가 직접 SERVICE LOCATOR에게 의존성을 해결해줄 것을 요청한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String title, Duration runningTime, Money fee)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.title = title;</span><br><span class="line">    <span class="built_in">this</span>.runningTime = runningTime;</span><br><span class="line">    <span class="built_in">this</span>.fee = fee;</span><br><span class="line">    <span class="built_in">this</span>.dicountPolicy = ServiceLocator.discountPolicy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceLocator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ServiceLocator</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceLocator</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> DiscountPolicy <span class="title function_">discountPolicy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> singleton.discountPolicy();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">provide</span><span class="params">(DicountPolicy discountPolicy)</span> &#123;</span><br><span class="line">    singleton.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServiceLocator.provide(<span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br><span class="line"><span class="type">Movie</span> <span class="variable">avartar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>));</span><br></pre></td></tr></table></figure><p>여기까지만 보면 SERVICE LOCATOR 패턴은 의존성을 해결할 수 있는 가장 쉽고 간단한 도구인 것처럼 보인다.<br>하지만 SERVICE LOCATOR 패턴의 큰 단점은 의존성을 감춘다는 것이다.</p><p>Movie는 DicountPolicy에 의존적이지만 Movie의 퍼블릭 인터페이스에 표시 되지 않고, 의존성은 암시적이며 코드 깊숙한 곳에 숨겨져 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Movie</span> <span class="variable">avartar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>));</span><br></pre></td></tr></table></figure><p>위의 경우 NullPointerException이 발생하게 된다.</p><p>의존성을 구현 내부로 감출 경우 의존성과 관련된 문제가 **컴파일 타임이 아닌 런타임에 가서야 발견된다는 사실을 알 수 있다.  **<br>숨겨진 의존성이 이해하기 어렵고 디버깅하기 어려운 이유는 문제점을 발견할 수 있는 시점을 코드 작성 시점이 아니라 실행 시점으로 미루기 때문이다.</p><p>ServiceLocator는 내부적으로 정적 변수를 이용해 객체들을 관리하기 때문에 모든 단위 테스트 케이스에 걸쳐 ServiceLocator의 상태를 공유하게 된다.<br><strong>이것은 각 단위 테스트는 서로 고립돼야 한다는 단위 테스트의 기본 원칙을 위반한 것이다.</strong></p><p>캡슐화는 코드를 읽고 이해하는 행위와 관련이 있다. 클래스의 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡슐화의 관점에서 훌륭한 코드다.<br>클래스의 사용법을 익히기 위해 구현 내부를 샅샅이 뒤져야 한다면 그 클래스의 캡슐화는 무너진 것이다.</p><p>**숨겨진 의존성이 가지는 가장 큰 문제점은 의존성을 이해하기 위해 코드늬 내부 구현을 이해할 것을 강요한다. **<br>다라서 숨겨진 의존성은 캡슐화를 위반한다.<br>결과적으로 의존성을 구현 내부로 감추도록 강요하는 Service Locator는 캡슐화를 위반할 수밖에 없다.</p><p>숨겨진 의존성은 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어트려 놓는다.<br>이것은 코드를 이해하고 디버깅하기 어렵게 만든다.</p><p><strong>따라서 의존성 주입을 사용하여 외부 인터페이스에 의존성을 노출 시키는 것이 가장 깔끔하다</strong></p><h1 id="의존성-역전-원칙"><a href="#의존성-역전-원칙" class="headerlink" title="의존성 역전 원칙"></a>의존성 역전 원칙</h1><p>객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 상위 수준의 정책이다.<br>Movie와 AmountDiscountPolicy 사이의 협력이 가지는 본질은 영화의 가격을 계산하는 것이다.<br>어떻게 할인 금액을 계산할 것인지는 협력의 본질이 아니다.<br>다시 말해서 어떤 협력에서 중요한 정책이나 의사결정, 비지니스의 본질을 담고 있는 것은 상위 수준의 클래스이다.</p><p>그러나 이런 상위 수준의 클래스가 하위 수준의 클래스에 의존한다면 하위 수준의 변경에 의해 상위 수준 클래스가 영향을 받게 될 것이다.</p><p>의존성은 변경의 전파와 관련된 것이기 때문에 설계는 변경의 영향을 최소화하도록 의존성을 관리해야 한다.<br>상위 수준의 클래스는 어떤 식으로든 하위 수준의 클래스에 의존해서는 안 되는 것이다.</p><p>대부분 재사용하려는 대상은 상위 수준의 클래스이다.<br>상위 수준의 클래스가 하위 수준의 클래스에 의존하면 상위 수준의 클래스를 재사용할 때 하위 수준의 클래스도 필요하기 때문에 재사용하기가 어려워진다.</p><p>이 경우에도 추상화를 통해 해결한다.  Movie와 AmountDiscountPolicy 모두가 추상화에 의존하도록 수정하면<br>하위 수준 클래스의 변경으로 인해 상위 수준 클래스가 영향을 받는 것을 방지할 수 있다.<br>또한 상위 수준을 재사용할 때 하위 수준의 클래스에 얽매이지 않고도 다양한 컨텍스트에서 재사용이 가능하다.</p><p><strong>가장 중요한 것은 추상화에 의존하는 것이다.</strong><br><strong>유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야 한다.</strong></p><p><strong>정리</strong></p><ul><li>상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.</li><li>추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.</li></ul><p>이를 의존성 역전 원칙(Dependency Inversion Principle, DIP) 이라고 부른다. </p><p>역전(Inversion)이라는 단어를 사용한 이유는<br>의존성 역전 원칙을 따르는 설계는 의존성의 방향이 전통적인 절차형 프로그래밍과는 반대 방향으로 나타나기 때문이다.<br>(전통적인 절차형에서는 상위 수준의 모듈이 하위 수준 모듈에 의존적이다.)</p><h2 id="의존성-역전-원칙과-패키지"><a href="#의존성-역전-원칙과-패키지" class="headerlink" title="의존성 역전 원칙과 패키지"></a>의존성 역전 원칙과 패키지</h2><p>역전은 의존성의 방향뿐만 아니라 인터페이스의 소유권에도 적용된다.  </p><p><img src="./dependency-inversion.jpg" alt="dependency-inversion"></p><p>이 그림에서 구체 클래스인 Movie, AmountDiscountPolicy, PercentDiscountPolicy는 모두 추상 클래스인 DiscountPolicy에 의존한다.<br>따라서 개방-폐쇄 원칙을 준수할뿐만 아니라 의존성 역전 원칙도 따르고 있기 때문에 이 설계가 유연하고 재사용 가능하다고 생각할 것이다.<br>하지만 Movie를 다양한 컨텍스트에 재사용하기 위해서는 불필요한 클래스들이 Movie와 함께 배포돼야만 한다.</p><p>Movie가 DiscountPolicy에 대해 컴파일 타임 의존성을 가진다.<br>이 말은 Movie 클래스를 빌드하기 위해 DiscountPolicy가 같은 패키지 내에 필요함을 의미한다.<br>하지만 DiscountPolicy가 있는 패키지에서는 AmountDiscountPolicy, PercentDiscountPolicy가 있기때문에 전체적인 빌드 타임이 증가한다.</p><p>따라서 Movie의 재사용을 위해 필요한 것이 DiscountPolicy 뿐이라면 DiscountPolicy를 Movie와 같은 패키지로 모으고<br>AmountDiscountPolicy, PercentDiscountPolicy를 별도의 패키지에 위치시켜 의존성 문제를 해결할 수 있다.</p><h2 id="Seperated-Interface-패턴"><a href="#Seperated-Interface-패턴" class="headerlink" title="Seperated Interface 패턴"></a>Seperated Interface 패턴</h2><p><img src="./seperated-interface.jpg" alt="seperated-interface"></p><p>위의 그림과 같이 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 한다.<br>그리고 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 한다.<br>이와 같은 기법을 <strong>Seperated Interface 패턴</strong> 이라 부른다.</p><p>이제 Movie클래스를 다른 컨텍스트에서 사용하기 위해서는 단지 Movie, DiscountPolicy가 포함된 패키지만 재사용하면 된다.</p><p>따라서 의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 한다.</p><blockquote><p>전통적인 패러다임에서는 상위 수준의 모듈이 하위 수준 모듈에 의존했다면<br>객체지향 패러다임에서는 상위 수준 모듈과 하위 수준 모듈이 모두 <strong>추상화</strong>에 의존한다.<br>전통적인 패러다임에서는 인터페이스가 하위 수준 모듈에 속했다면 <strong>객체지향 패러다임에서는 인터페이스가 상위 수준 모듈에 속한다.</strong>  </p><p>훌륭한 객체지향 설계를 위해서는 의존성을 역전시켜야 한다.<br>그리고 의존성을 역전시켜야만 유연하고 재사용 가능한 설계를 얻을 수 있다.</p></blockquote><h1 id="유연한-설계는-유연성이-필요할-때만-옳다"><a href="#유연한-설계는-유연성이-필요할-때만-옳다" class="headerlink" title="유연한 설계는 유연성이 필요할 때만 옳다"></a>유연한 설계는 유연성이 필요할 때만 옳다</h1><p>유연하고 재사용 가능한 설계란 런타임 의존성과 컴파일타임 의존성의 차이를 인식하고<br>동일한 컴파일 타임 의존성으로부터 런타임 의존성을 만들 수 있는 코드 구조를 가진 설계를 의미한다.<br>하지만 유연하고 재사용 가능한 설계가 항상 좋은 것은 아니다.<br>설계의 미덕은 단순함과 명확함으로부터 나온다. 단순하고 명확한 설계를 가진 코드는 읽기 쉽고 이해하기도 편하다.<br>변경하기 쉽고 확장하기 쉬운 구조를 만들기 위해서는 단순함과 명확함을 버리게 된다.</p><h2 id="유연한-설계-x3D-복잡한-설계"><a href="#유연한-설계-x3D-복잡한-설계" class="headerlink" title="유연한 설계 &#x3D; 복잡한 설계"></a>유연한 설계 &#x3D; 복잡한 설계</h2><p>사실 <strong>유연한 설계 &#x3D; 복잡한 설계</strong> 이다.<br>변경에 대비 하기 위해 유연한 설계를 하고 복잡한 구조를 만든다.<br>하지만 변경은 예상이 아니라 현실이어야 한다. 미래에 일어날지도 모른다는 막연한 불안감은 불필요하게 복잡한 설계를 낳는다.<br>아직 일어나지 않은 변경은 변경이 아니다.</p><h2 id="유연성은-항상-복잡성을-수반한다"><a href="#유연성은-항상-복잡성을-수반한다" class="headerlink" title="유연성은 항상 복잡성을 수반한다"></a>유연성은 항상 복잡성을 수반한다</h2><p>유연하지 않은 설계는 단순하고 명확하다. 유연한 설계는 복잡하고 암시적이다.<br>객체지향에 입문한 개발자들이 가장 이해하기 어려워하는 부분이 바로 코드 상에 표현된 정적인 클래스 구조와 실행 시점의 동적인 구조가 다르다는 사실이다.<br><strong>절차적 프로그래밍 방식은 코드의 구조가 곧 실행구조이다.</strong><br>하지만 객체지향 프로그래밍 방식에서 클래스의 구조는 발생 가능한 모든 객체 구조를 담는 틀일 뿐이다.<br>특정 시점의 객체 구조를 파악하는 유일한 방법은 클래스를 사용하는 클라이언트 코드 내에서 객체를 생성하거나 변경하는 부분을 직접 살펴보는 것이다.</p><h2 id="불필요한-유연성은-불필요한-복잡성을-낳는다"><a href="#불필요한-유연성은-불필요한-복잡성을-낳는다" class="headerlink" title="불필요한 유연성은 불필요한 복잡성을 낳는다."></a>불필요한 유연성은 불필요한 복잡성을 낳는다.</h2><p>단순하고 명확한 해법이 그런대로 만족스럽다면 유연성을 제거하라<br>유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다.<br>하지만 복잡성에 대한 걱정보다 유연하고 재사용 가능한 설계의 필요성이 더 크다면 코드의 구조와 실행 구조를 다르게 만들어야 한다.</p><h1 id="협력과-책임이-중요하다"><a href="#협력과-책임이-중요하다" class="headerlink" title="협력과 책임이 중요하다"></a>협력과 책임이 중요하다</h1><p>설계를 유연하게 만들기 위해서는 먼저 역할, 책임, 협력에 초점을 맞춰야 한다.<br>다양한 컨텍스트에서 재사용할 필요가 없다면 설계를 유연하게 만들 당위성도 함께 사라진다.</p><p>중요한 비지니스 로직을 처리하기 위해 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것 보다 우선이다. </p><p>객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는 것이 적절하다.</p><p>의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다.<br>따라서 역할, 책임, 협력에 먼저 집중해야 한다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter9. 유연한 설계</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter8. 의존성 관리하기</title>
      <link href="/2020/06/06/object-chapter8/"/>
      <url>/2020/06/06/object-chapter8/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>잘 설계된 객체지향 어플리케이션은 작고 응집도 높은 객체들로 구성된다.<br>작고 응집성 높은 객체란 책임의 초점이 명확하고 한 가지 일만 잘하는 객체를 의미한다.<br>따라서 객체 간 협력을 통해 다른 객체에게 도움을 요청하여 여러가지 일을 수행할 수 있다.<br><strong>협력은 객체가 다른 객체에 대해 알 것을 강요한다</strong><br><strong>다른 객체와 협력하기 위해서는 그런 객체 또는 클래스가 있다는 사실을 알고 있어야 한다.</strong><br><strong>객체가 수신할 수 있는 메세지에 대해서도 알고 있어야 한다.</strong>  </p><p>이런 지식들이 객체 사이의 의존성을 낳는다.</p><h1 id="의존성이란"><a href="#의존성이란" class="headerlink" title="의존성이란"></a>의존성이란</h1><p><strong>의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성</strong>을 의미한다.<br>어떤 객체가 협력하기 위해 다른 객체로 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다.<br>나아가 두 객체 사이 뿐만 아니라 모듈이나 더 큰 규모의 실행 시스템일 수도 있다. (ex. API 의존성)<br>의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.</p><ul><li>실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다. </li><li>구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.</li></ul><h2 id="의존성은-방향성을-가진다"><a href="#의존성은-방향성을-가진다" class="headerlink" title="의존성은 방향성을 가진다."></a>의존성은 방향성을 가진다.</h2><p>의존성은 방향성을 가지며 항상 단방향이다. (그 역은 성립하지 않는다.)<br>예를들어 PerioidCondition class에서 Screening class를 인자로 받는 경우  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Screening screening)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> screenging.startTime() ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PeriodCondition 클래스는 Screening 클래스에 의존한다</code> 라고 표현한다.  </p><p><img src="./dependency.jpg" alt="의존성표현"></p><h2 id="의존성은-변경에-취약하다"><a href="#의존성은-변경에-취약하다" class="headerlink" title="의존성은 변경에 취약하다"></a>의존성은 변경에 취약하다</h2><p>설계과 관련된 대부분의 용어들이 변경과 관련이 있다.<br>의존성 역시 변경과 관련이 있다.<br>두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다.<br>따라서 의존성은 변경에 의한 영향의 전파가능성을 암시한다.</p><h1 id="의존성-전이"><a href="#의존성-전이" class="headerlink" title="의존성 전이"></a>의존성 전이</h1><p><img src="./dependency-transfer.jpg" alt="dependency-transfer"></p><p>PeriodCondition 클래스가 Screening 클래스에 의존하고,  Screening 클래스가 Movie 클래스에 의존하는 경우 의존성이 전이될 수 있다.   </p><p>의존성이란 함께 변경될 수 있는 <strong>가능성</strong> 을 의미하기 때문에 모든 경우에 의존성이 전이되는 것은 아니다.<br>의존성이 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다.  </p><p>단, 의존성 전이는 변경에 의해 영향이 전파될 수도 있다는 일종의 경고이다.</p><h2 id="직접-의존성과-간접-의존성"><a href="#직접-의존성과-간접-의존성" class="headerlink" title="직접 의존성과 간접 의존성"></a>직접 의존성과 간접 의존성</h2><ul><li>직접 의존성: 말 그대로 한 요소가 다른 요소에 직접 의존하는 경우를 가르킨다.</li><li>위의 예제에서 PeriodCondition은 Screening에 직접 의존한다.</li><li>이 경우 의존성은 코드에 명시적으로 드러난다. (PeriodCondition 내부 코드에서 Screening을 참조하는 코드가 존재한다)</li><li>간접 의존성: 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 가리킨다.<ul><li>위의 예제에서 Movie 클래스 변경으로 인해 PeriodCondition까지 변경의 영향이 있을 수도 있음을 의미한다.</li><li>이 경우 의존성은 명시적으로 드러나지 않는다. (PeriodCondition 내부 코드에서 Movie에 대한 참조는 없다)</li></ul></li></ul><h1 id="Runtime-의존성과-Compile-time-의존성"><a href="#Runtime-의존성과-Compile-time-의존성" class="headerlink" title="Runtime 의존성과 Compile time 의존성"></a>Runtime 의존성과 Compile time 의존성</h1><h2 id="Runtime-의존성"><a href="#Runtime-의존성" class="headerlink" title="Runtime 의존성"></a>Runtime 의존성</h2><ul><li>어플리케이션이 실행되는 시점에 갖는 의존성을 의미</li><li>런타임에 실제 생성되는 객체 간의 의존성을 가리킨다.</li></ul><p><img src="./runtime-dependency.jpg" alt="runtime-dependency"></p><p>Movie라는 클래스와 AmountDiscountPolicy, PercentDiscountPolicy는 런타임에 직접적인 의존성을 갖는다.</p><h2 id="Compile-time-의존성"><a href="#Compile-time-의존성" class="headerlink" title="Compile time 의존성"></a>Compile time 의존성</h2><ul><li>작성된 코드를 컴파일 하는 시점을 의미 (또는 문맥에 따라서는 코드 그 차제를 가리키기도 한다.)</li><li>동적 타입 언어의 경우에는 컴파일 타입이 존재하지 않기 때문에 컴파일이 수행되는 시점으로만 생각하면 의미가 모호해진다.</li><li>컴파일 타임에서는 코드에 대한 의존성을 가리킨다.</li><li>코드 관점에서는 Class 간의 의존성을 가리킨다.</li></ul><p><img src="./compiletime-dependency.jpg" alt="compiletime-dependency"></p><p>Movie라는 클래스는 DiscountPolicy라는 클래스는 컴파일타임 의존성을 갖는다.<br>실제 Movie 클래스와 AmountDiscountPolicy, PercentDiscountPolicy는 코드 관점에서의 의존성은 존재하지 않는다.</p><h1 id="유연하고-재사용-가능한-설계"><a href="#유연하고-재사용-가능한-설계" class="headerlink" title="유연하고 재사용 가능한 설계"></a>유연하고 재사용 가능한 설계</h1><p>유연하고 재사용 가능한 설계를 하기 위해서는 동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 한다.<br>어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안된다.<br>실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다.<br>만약 클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 읺스턴스와 협력할 가능성 자체가 없어지게 된다.<br>따라서 <strong>컴파일 타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연하고 재사용 가능해 진다.</strong></p><blockquote><p>객체지향 프로그램의 실행 구조는 소스코드 구조와 일치하지 않는 경우가 종종 있다.<br>코드 구조는 컴파일 시점에 확정되는 것이고 이 구조에는 고정된 상속 클래스 관계들이 포함된다.<br>하지만 프로그램 실행 시점 구조는 협력하는 객체에 따라 달라질 수 있다.</p></blockquote><h2 id="컨텍스트-독립성"><a href="#컨텍스트-독립성" class="headerlink" title="컨텍스트 독립성"></a>컨텍스트 독립성</h2><p>유연하고 확장 가능한 설계를 만들기 위해서는 compile time 의존성과 runtime 의존성이 달라야 한다.<br>클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안 된다.<br>구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문이다.</p><p>클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다.<br>클래스가 사용 될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다.</p><p>이를 <strong>컨텍스트 독립성</strong> 이라 부른다.</p><p><strong>설계를 유연하게 만드는 마법</strong></p><ul><li>자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 작게 알아야 한다.<ul><li>각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못한다는 의미</li><li>최소한의 정보만 알자</li></ul></li><li>정보가 적으면 다양한 컨텍스트에서 재사용 될 수 있다.</li><li>설계는 더 유연해지고 변경에 대응하기 쉬워진다.<ul><li>응집력 있는 객체를 만들 수 있다</li><li>객체 구성 조합에 따라 변경 가능한 시스템으로 나아갈 수 있다.</li></ul></li></ul><h2 id="의존성-해결하기"><a href="#의존성-해결하기" class="headerlink" title="의존성 해결하기"></a>의존성 해결하기</h2><p><strong>compile time 의존성은 구체적인 runtime 의존성으로 대체돼야 한다.</strong></p><p>이를 <strong>의존성 해결</strong> 이라 부른다.</p><p>의존성을 해결하는 방법은 일반적으로 다음과 같은 세 가지 방법을 사용한다.</p><ul><li><p>객체를 생성하는 시점에 생성자를 통해 의존성을 해결</p><ul><li>new A(new B())</li></ul></li><li><p>객체 생성 후 setter 메서드를 통해 의존성 해결</p><ul><li>(new A()).setB(new B())</li></ul></li><li><p>메서드 실행 시 인자를 이용해 의존성 해결</p><ul><li>(new A()).method(new B())</li><li>이 방식은 협력 대상에 대해 지속적으로 의존 관계를 맺을 필요 없이 메서드가 실행되는 동안만 의존 관계가 존재해도 무방한 경우</li><li>메서드 실행 시마다 의존 대상이 매번 달라져야 하는 경우에 유용</li></ul></li></ul><h2 id="Setter-Method-방식의-단점"><a href="#Setter-Method-방식의-단점" class="headerlink" title="Setter Method 방식의 단점"></a>Setter Method 방식의 단점</h2><p>setter 메서드를 이용하는 방법은 실행 시점에 의존 대상을 변경할 수 있기 때문에 설계를 좀 더 유연하게 만들 수 있다.<br>하지만 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에<br><strong>객체를 생성하고 의존 대상을 설정하기 전까지는 객체의 상태가 불완전</strong>할 수 있다는 점이다.</p><p>아래와 같은 코드는 NullPointerException 예외가 발생할 것이다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Movie</span> <span class="variable">avatar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>();</span><br><span class="line">avatar.caculateFee(); <span class="comment">//discount policy가 아직 설정되지 않았기 때문에 NPE가 발생한다</span></span><br><span class="line">avatar.setDiscountPolicy(<span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br></pre></td></tr></table></figure><h2 id="생성자-방식-setter-방식"><a href="#생성자-방식-setter-방식" class="headerlink" title="생성자 방식 + setter 방식"></a>생성자 방식 + setter 방식</h2><p>setter method 방식을 보완하기 위해서는 생성자 방식와 setter 방식을 혼합하는 것이다.<br>항상 객체를 생성할 때 의존성을 해결해서 완전한 상태의 객체를 생성한 후 필요에 따라 setter 메서드를 이용해 의존대상을 변경할 수 있게 할 수 있다.<br>이 방법은 시스템의 상태를 안정적으로 유지하면서도 유연성을 향상시킬 수 있기 때문에 의존성 해결을 위해 가장 선호되는 방법이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Movie</span> <span class="variable">avatar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br><span class="line">avatar.setDiscountPolicy(<span class="keyword">new</span> <span class="title class_">PercentDiscountPolicy</span>());</span><br></pre></td></tr></table></figure><h1 id="의존성과-결합도"><a href="#의존성과-결합도" class="headerlink" title="의존성과 결합도"></a>의존성과 결합도</h1><p>객체지향 패러다임의 근간은 협력이다. 따라서 객체들이 협력하기 위해서는 서로의 존재와 수행 가능한 책임을 알아야한다.<br>이런 지식들이 의존성을 낳는다.<br>따라서 모든 의존성이 나쁜 것은 아니다. 의존성은 객체들의 협력을 가능하게 하는 매개체이기 때문이다.<br>하지만 의존성이 과하면 문제가 된다.</p><p>바람직한 의존성을 위해서는 <strong>재사용성</strong>을 고려해야한다.  </p><ul><li>어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못하다  <ul><li>특정 컨텍스트에 강하게 결합된 의존성은 바람직하지 못하다</li></ul></li><li>어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 있다면 그 의존성은 바람직하다.<ul><li>특정 컨텍스트에 독립적인 의존성은 바람직한 의존성이다.</li></ul></li></ul><p>바람직한 의존성과 바람직 하지 못한 의존성을 나타내는 용어로 <strong>결합도</strong> 라는 용어를 사용한다. </p><ul><li>강한 결합도 (tight coupling)<ul><li>의존성이 다양한 환경에서 클래스를 재사용할 수 없는 바람직하지 못한 의존성</li></ul></li><li>약한 결합도 (loose coupling)<ul><li>의존성이 다양한 환경에서 클래스를 재사용할 수 있는 의존성</li><li>컨텍스트 독립적인 의존성</li></ul></li></ul><h2 id="지식이-결합을-낳는다"><a href="#지식이-결합을-낳는다" class="headerlink" title="지식이 결합을 낳는다."></a>지식이 결합을 낳는다.</h2><p>결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.<br>많은 요소를 알고 있을 수록 두 요소는 강하게 결합된다. </p><p>예시</p><ul><li>일단 가격을 계산한다. -&gt; 약한 결합도</li><li>가격을 계산하는데 할인방식은 금액 할인 방식이고 평일에만 할인이 된다. -&gt; 강한 결합도</li></ul><h2 id="추상화에-의존하라"><a href="#추상화에-의존하라" class="headerlink" title="추상화에 의존하라"></a>추상화에 의존하라</h2><p>추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나<br>감춤으로써 복잡도를 극복하는 방법이다.</p><p>추상화를 이용하면 현재 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다.<br>따라서 대상에 대해 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있다.</p><p>목록에서 아래쪽으로 갈수록 클라이언트가 알아야하는 지식의 양이 적어지기 때문에 결합도가 느슨해진다.</p><ul><li>구체 클래스 의존성 (concrete class dependency)</li><li>추상 클래스 의존성 (abstract class dependency)</li><li>인터페이스 의존성 (interface dependency)</li></ul><p>따라서 의존하는 대상이 더 추상적일 수록 결합도는 낮아진다</p><h2 id="명시적인-의존성"><a href="#명시적인-의존성" class="headerlink" title="명시적인 의존성"></a>명시적인 의존성</h2><p>결합도를 느슨하게 만들기 위해서는 인스턴스 변수의 타입을 추상 클래스나 인터페이스로 선언하는 것만으로는 부족하다<br>클래스 안에서 구체 클래스에 대한 모든 의존성을 제거해야 한다. (아예 import도 안되게)<br>하지만 런타임에는 구체클래스의 인스턴스와 협력해야 하기 때문에 클래스의 인스턴스 타입이 뭔지는 알아야 한다.</p><p>위에서 얘기했던 것 처럼 의존성을 해결하는 방법에는 생성자, setter 메서드, 메서드 파라미터를 사용하는 세 가지 방식이 있다.<br>여기서의 방법은 인스턴스 변수의 타입은 추상 클래스나 인터페이스로 정의하고<br>생성자, setter 메서드, 메서드 파라미터로 실제 코드를 작성할 때에는 구체 클래스를 사용하는 것이다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(DiscountPoilcy discountPolicy)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Movie</span> <span class="variable">movie</span> <span class="operator">=</span> Movie(<span class="keyword">new</span> <span class="title class_">AccountDiscountPolicy</span>());</span><br></pre></td></tr></table></figure><p>의존성을 대상을 <strong>생성자의 인자로 전달받는 방법</strong>과 <strong>생성자 안에서 직접 생성하는 방식</strong> 의 큰 차이점은<br>퍼블릭 인터페이스를 통해 할인 정책을 설정할 수 있는 방법을 제공하는지의 대한 여부다<br>명시적으로 퍼블릭 인터페이스를 통해 의존성을 노출하는 방식을 <strong>명시적인 의존성</strong> 이라고 부른다.</p><h2 id="숨겨진-의존성"><a href="#숨겨진-의존성" class="headerlink" title="숨겨진 의존성"></a>숨겨진 의존성</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = <span class="keyword">new</span> <span class="title class_">AccountDiscountPolicy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>반면 위와 같은 코드에서는 할인 정책에 대한 의존성을 퍼블릭 인터페이스로 제공하지 않고 코드 내에 숨겨져 있다.<br>의존성이 퍼블릭 인터페이스에 표현되지 않는 방식을 <strong>숨겨진 의존성</strong> 이라고 부른다.<br>의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수 밖에 없다.</p><h2 id="의존성을-내부-구현으로-숨겨두지-마라"><a href="#의존성을-내부-구현으로-숨겨두지-마라" class="headerlink" title="의존성을 내부 구현으로 숨겨두지 마라"></a>의존성을 내부 구현으로 숨겨두지 마라</h2><p>의존성은 명시적으로 표현되어야 한다.<br>의존성을 내부 구현에 숨겨 두면 개발자가 직접 내부 구현을 살펴봐야하는 고통이 따른다.<br>유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계이다.<br>명시적인 의존성을 사용해야지만 퍼블릭 인터페이스를 통해 컴파일 타임 의존성을 적절한 런타임 의존성으로 교체할 수  있다.  </p><h2 id="new는-해롭다"><a href="#new는-해롭다" class="headerlink" title="new는 해롭다"></a>new는 해롭다</h2><p>대부분의 언어에서는 클래스의 인스턴스를 생성할 수 있는 new 연산자를 제공한다.<br>안타까운 사실은 new를 잘못 사용하면 클래스 사이의 결합도가 극단적으로 높아진다.<br>결합도 측면에서 new가 해로운 이유는 크게 두 가지다.</p><ul><li>new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 서술하여야 한다.<ul><li>따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수밖에 없기 때문에 결합도가 높아진다.</li></ul></li><li>new 연산자는 생성하려는 구체 클래스 뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다.<ul><li>따라서 new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다.</li></ul></li></ul><p>따라서 new 연산자를 통한 구체 클래스 생성을 잘못하면 결합도가 높아지므로 변경에 의해 영향을 받기 쉬워진다.<br>또한 new를 통해 구체 클래스 생성에 끝나는 것이 아닌 협력할 구체 클래스의 인스턴스를 생성하기 위해 아래와 같은 지식이 필요하다</p><ul><li>어떤 인자들이 필요한가?</li><li>어떤 순서로 파라미터를 사용해야 하는가?</li><li>인자들에 대한 타입도 의존성에 추가된다</li></ul><h2 id="new를-없애기-위해서는"><a href="#new를-없애기-위해서는" class="headerlink" title="new를 없애기 위해서는"></a>new를 없애기 위해서는</h2><p>new를 사용하지 않도록 하기 위해서는 다음과 같은 방법을 사용하면 된다.</p><p><strong>인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리한다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(DiscountPolicy discountPolicy)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//다른 클라이언트 코드에서 생성</span></span><br><span class="line"><span class="type">Movie</span> <span class="variable">movie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>()); <span class="comment">//1</span></span><br><span class="line">movie.setDiscountPolicy(<span class="keyword">new</span> <span class="title class_">PercentDiscountPolicy</span>()); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>위의 코드처럼 사용한다면 Movie라는 클래스 내에서는 구체 클래스에 대한 의존성 없이 DiscountPolicy라는 인터페이스 의존성만 존재한다.  </p><ol><li><p>실제 구체 클래스가 되는 AmountDiscountPolicy의 대한 생성 책임은 Movie 클래스를 생성하는 클라이언트로 옮겨지고<br>Movie는 AmountDiscountPolicy의 인스턴스를 사용하는 책임만 남는다.</p></li><li><p>DiscountPolicy라는 인터페이스 의존성만 Movie 클래스에 두었기 때문에 다른 할인정책을 적용하더라도 유연하게 사용이 가능하다</p></li></ol><h2 id="new를-가끔은-사용해도-괜찮다"><a href="#new를-가끔은-사용해도-괜찮다" class="headerlink" title="new를 가끔은 사용해도 괜찮다."></a>new를 가끔은 사용해도 괜찮다.</h2><p>클래스 안에서 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우도 있다.<br>주로 협력하는 기본 객체를 설정하고 싶은 경우가 이에 속한다. </p><p>대부분의 경우에는 <code>AmountDiscountPolicy</code> 의 인스턴스와 협력하는 경우를 생각해보자 </p><p>이런 상황에서 모든 경우에 인스턴스를 생성하는 책임을 클라이언트로 옮긴다면 클라이언트 코드들 사이에 중복 코드가 늘어나고<br>Movie의 사용성도 나빠질 것이다.</p><p>이런 문제를 해결하는 방법을 기본 객체에 생성하는 생성자를 추가하고<br>이 생성자에서 DiscountPolicy의 인스턴스를 인자로 받는 생성자를 체이닝 하는 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>()); <span class="comment">//1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(DiscountPolicy discountPolicy)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>기본 생성자에서 DiscountPolicy를 파라미터로 받는 생성자를 호출한다.<br>호출 시, AmountDiscountPolicy 객체를 사용하여 Movie 객체를 생성하도록 한다.</li></ol><p>이제 클라이언트에서는 대부분의 경우에 기본 생성자를 통해 AmountDiscountPolicy의 인스턴스와 협력하게 하면서도<br>컨텍스트에 적절한 DiscountPolicy의 인스턴스로 의존성을 교체할 수 있다.</p><h2 id="표준-클래스에-대한-의존은-해롭지-않다"><a href="#표준-클래스에-대한-의존은-해롭지-않다" class="headerlink" title="표준 클래스에 대한 의존은 해롭지 않다"></a>표준 클래스에 대한 의존은 해롭지 않다</h2><p>의존성이 불편한 이유는 그것이 항상 변경에 대한 영향을 암시하기 때문이다.<br>따라서 변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다. </p><p>예를 들어 JDK에 포함된 표준 클래스가 이 부류에 속한다.<br>String, ArrayList와 같은 클래스들은 거의 제로에 가깝기 때문에 인스턴스를 직접 new로 생성하더라도 문제가 되지 않는다.</p><p>비록 클래스를 직접 생성하더라도 가능한 추상적인 타입을 사용하는 것이 확장성 측면에서 유리하다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;DiscountCondition&gt; conditions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>위의 코드와 같이 ArrayList를 사용하여 객체를 생성하더라도 타입을 ArrayList의 인터페이스인 List를 사용하면<br>확장성 측면에서 유리하다</p><p>추가적으로 <strong>의존성에 대한 영향이 적은 경우에도 추상화에 의존하고 의존성을 명시적으로 드러내는 것은 좋은 설계</strong>이다.</p><h1 id="조합-가능한-행동"><a href="#조합-가능한-행동" class="headerlink" title="조합 가능한 행동"></a>조합 가능한 행동</h1><p>어떤 객체와 협력하느냐에 따라 객체의 행동이 달라지는 것은 유연하고 재사용 가능한 설계가 가진 특징이다.<br>유연하고 재사용 가능한 설계는 응집도 높은 책임들을 가진 작은 객체들을 다양한 방식으로 연결함으로써 애플리케이션의 기능을 쉽게 확장할 수 있다.</p><p>그렇다면 유연하고 재사용 가능한 설계는 무엇인가?<br>바로 객체가 어떻게(how) 하는지에 대한 코드를 장황하게 나열하지 않고,<br>객체들의 조합을 통해 무엇(what)을 하는지를 표현하는 클래스들로 구성된다. </p><p>따라서 클래스의 인스턴스를 생성하는 코드를 보는 것만으로 객체가 어떤 일을 하는지 쉽게 파악할 수 있다.<br>코드에 드러난 로직을 해석할 필요 없이 객체가 어떤 객체와 연결됐는지를 보는 것만으로도 객체의 행동을 쉽게 예상하고 이해할 수 있기 때문이다.</p><p>다시 말해 선언적으로 객체의 행동을 정의할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Movie</span>(</span><br><span class="line">  <span class="string">&quot;아바타&quot;</span>,</span><br><span class="line">  Duration.ofMinutes(<span class="number">120</span>),</span><br><span class="line">  Money.wons(<span class="number">10000</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>(</span><br><span class="line">    Money.wons(<span class="number">800</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SequenceCondition</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SequenceCondition</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PeriodCondition</span>(</span><br><span class="line">      DayOfWeek.MONDAY, </span><br><span class="line">      LocalTime.of(<span class="number">10</span>, <span class="number">0</span>), </span><br><span class="line">      LocalTime.of(<span class="number">12</span>, <span class="number">0</span>)</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PeriodCondition</span>(</span><br><span class="line">      DayOfWeek.THURSDAY, </span><br><span class="line">      LocalTime.of(<span class="number">10</span>, <span class="number">0</span>), </span><br><span class="line">      LocalTime.of(<span class="number">21</span>, <span class="number">0</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>위의 코드를 보면 객체의 행동이 짐작이 간다. </p><ol><li>영화 제목은 아바타</li><li>영화의 가격은 10,000원</li><li>가격 할인 정책이 적용된다</li><li>할인 금액은 800원</li><li>1회차, 10회차 영화에 대해 할인이 적용된다</li><li>월요일에는 10시~12시 사이의 영화에 대해서 할인이 적용된다</li><li>목요일에는 10시~21시 사이의 영화에 대해서 할인이 적용된다</li></ol><p>이와 같이 유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로써 새로운 행돌을 이끌어낼 수 있는 설계다<br><strong>훌륭한 객체지향 설계란 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계다</strong></p><p>그리고 지금까지 설명한 것처럼 이런 설계를 창조하는 데 있어서의 핵심은 의존성을 관리하는 것이다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter8. 의존성 관리하기</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter7. 객체 분해</title>
      <link href="/2020/05/30/object-chapter7/"/>
      <url>/2020/05/30/object-chapter7/</url>
      
        <content type="html"><![CDATA[<h1 id="추상화와-분해"><a href="#추상화와-분해" class="headerlink" title="추상화와 분해"></a>추상화와 분해</h1><p>불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만을 남기는 작업을 <strong>추상화</strong> 라고 부른다.<br>가장 일반적인 추상화 방법은 한 번에 다뤄야 하는 문제의 크기를 줄이는 것이다. </p><p>이처럼 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 <strong>분해(decomposition)</strong> 이라고 부른다.<br>분해의 목적은 큰 문제를 한번에 처리할 수 있는 규모의 문제로 나누는 것이다.<br>한 가지 주목할 점은 정보의 가장 작은 단위로서의 개별 항목을 의미하는 것이 아니라 하나의 단위로 취급될 수 있는 논리적인 chunk를 의미한다.</p><p>추상화와 분해는 인간이 세계를 인식하고 반응하기 위해 사용하는 가장 기본적인 사고 도구이다.<br>복잡성이 존재하는 곳에 추상화와 분해 역시 함께 존재한다.<br>소프트웨어 개발 영역에서는 복잡한 문제를 해결하기 위해 추상화와 분해를 사용한다.</p><h1 id="프로시저-추상화와-데이터-추상화"><a href="#프로시저-추상화와-데이터-추상화" class="headerlink" title="프로시저 추상화와 데이터 추상화"></a>프로시저 추상화와 데이터 추상화</h1><p>프로그래밍 언어의 발전은 좀 더 효과적인 추상화를 이용해 복잡성을 극복하려는 개발자들의 노력에서 출발했다.<br>프로그래밍 언어를 통해 표현되는 추상화의 발전은 다양한 프로그래밍 패러다임의 탄생으로 이어졌다.<br>프로그래밍 패러다임은 프로그래밍을 구성하기 위해 사용하는 추상화의 종류와 이 추상화를 이용해 소프트웨어를 분해나는 방법의 두 가지 요소로 결정된다.<br>따라서 모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명할 수 있다.</p><p>현대적인 프로그래밍 언어를 특징 짓는 중요한 두 가지 추상화 메커니즘은 <strong>프로시저 추상화</strong>와 <strong>데이터 추상화</strong> 이다.</p><h2 id="프로시저-추상화"><a href="#프로시저-추상화" class="headerlink" title="프로시저 추상화"></a>프로시저 추상화</h2><ul><li>프로시저 추상화를 중심으로 시스템을 분해하는 것은 기능 분해(functional decomposition)을 통해 추상화 하는 기법이다.  </li><li>기능 분해는 알고리즘 분해(algorithmic decomposition)이라고 부르기도 한다.</li></ul><h2 id="데이터-중심-추상화"><a href="#데이터-중심-추상화" class="headerlink" title="데이터 중심 추상화"></a>데이터 중심 추상화</h2><p>데이터 중심으로 추상화 하는 방법은 타입 추상화와 프로시저 추상화 두 가지가 있다. </p><ul><li><strong>타입 추상화(type abstraction)</strong><ul><li>추상 데이터 타입이라 부른다.</li></ul></li><li><strong>프로시저 추상화(procedure abstraction)</strong><ul><li>객체지향이라 부른다.</li><li>역할과 책임을 수행하는 객체</li></ul></li></ul><h1 id="프로시저-추상화와-기능-분해"><a href="#프로시저-추상화와-기능-분해" class="headerlink" title="프로시저 추상화와 기능 분해"></a>프로시저 추상화와 기능 분해</h1><p>기능은 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용됐다.<br>이 같은 시스템 분해 방식을 <strong>알고리즘 분해</strong> 또는 <strong>기능 분해</strong>라고 부른다.<br>기능 분해의 관점에서 추상화의 단위는 프로시저이며 시스템은 프로시저를 단위로 분해된다.</p><p><strong>프로시저(procedure)</strong> 란</p><ul><li>반복적으로 실행되거나 거의 유사하게 실행되는 작업들의 모임</li><li>로직을 재상용하고 중복을 방지할 수 있는 추상화 방법</li><li>내부의 상세구현을 모르더라도 외부에 공개된 인터페이스만 알면 프로시저를 사용할 수 있다.</li><li>프로시저는 잠재적으로 정보 은닉의 가능성을 제시<ul><li>하지만 효과적인 정보은닉 체계를 구축하는데는 한계가 있다.</li></ul></li></ul><h1 id="하향식-접근법-Top-Down-Approach"><a href="#하향식-접근법-Top-Down-Approach" class="headerlink" title="하향식 접근법(Top-Down Approach)"></a>하향식 접근법(Top-Down Approach)</h1><p>전통적인 분해 방법은 <strong>하향식 접근법</strong>을 따른다.<br>하향식 접근법이란 시스템을 구성하는 최상위 기능을 정의하고 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법<br>분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지 계속된다.<br>각 세분화 단계는 바로 위 단계보다 구체적이어야 한다. (상위 기능보다 덜 추상적이어야 한다.)</p><h2 id="하향식-접근법의-문제점"><a href="#하향식-접근법의-문제점" class="headerlink" title="하향식 접근법의 문제점"></a>하향식 접근법의 문제점</h2><p>하향식 기능 분해 방법은 겉으로는 이상적일 수 있지만, 실제로 설계에 적용하다 보면 다음과 같은 다양한 문제에 직면한다.</p><ul><li>시스템은 하나의 메인 함수로 구성돼 있지 않다.</li><li>기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.</li><li>비지니스 로직이 사용자 인터페이스와 강하게 결합된다.</li><li>하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.</li><li>데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.</li></ul><p>위와 같은 문제로 인해 하향식 접근법과 기능 분해가 가지는 근본적인 문제점은 변경에 취약한 설계를 낳는다는 것이다.</p><h2 id="시스템은-하나의-메인-함수로-구성되지-않는다"><a href="#시스템은-하나의-메인-함수로-구성되지-않는다" class="headerlink" title="시스템은 하나의 메인 함수로 구성되지 않는다."></a>시스템은 하나의 메인 함수로 구성되지 않는다.</h2><ul><li><p>어떤 시스템도 최초에 릴리즈됐던 당시의 모습을 그대로 유지하지는 않는다.  </p></li><li><p>시간이 지나고 사용자를 만족시키기 위한 새로운 요구사항을 도출해나가면서 지속적으로 새로운 기능을 추가하게 된다.<br>이것은 시스템이 오직 하나의 메인 함수만으로 구현된다는 개념과는 완전히 모순된다.  </p></li><li><p>하향식 접근법은 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에는 적합하지만 현대적인 상호작용 시스템을 개발하는 데는 적합하지 않다.</p></li></ul><h2 id="기능-추가나-요구사항-변경으로-인해-메인-함수는-빈번하게-수정된다"><a href="#기능-추가나-요구사항-변경으로-인해-메인-함수는-빈번하게-수정된다" class="headerlink" title="기능 추가나 요구사항 변경으로 인해 메인 함수는 빈번하게 수정된다."></a>기능 추가나 요구사항 변경으로 인해 메인 함수는 빈번하게 수정된다.</h2><ul><li>시스템 안에는 여러 개의 정상급 함수가 존재하기 때문에 결과적으로 하나의 메인 함수를 유일한 정상으로 간주하기 어렵다.  </li><li>하향식 기능 분해의 경우에는 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 한다.  </li><li><strong>기존 로직과는 아무런 상관이 없는 새로운 함수의 적절한 위치를 확보해야 하기 때문</strong>에 메인 함수의 구조를 급격하게 변경하거나 새로 짤 수 밖에 없다.</li><li>코드의 빈번한 수정으로 인한 버그 발생 확률이 높아지고 시스템은 변경에 취약해질 수 밖에 없다.</li></ul><h2 id="비지니스-로직이-사용자-인터페이스와-강하게-결합된다"><a href="#비지니스-로직이-사용자-인터페이스와-강하게-결합된다" class="headerlink" title="비지니스 로직이 사용자 인터페이스와 강하게 결합된다."></a>비지니스 로직이 사용자 인터페이스와 강하게 결합된다.</h2><ul><li>하향식 접근법은 비지니스 로직을 설계하는 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다.  </li><li>결과적으로 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합된다.</li><li>사용자 인터페이스 로직과 비즈니스 로직을 한데 섞기 때문에 사용자 인터페이스를 변경하면 비즈니스 로직까지 영향을 받게 된다.</li><li>하향식 접근법은 기본적으로 변경에 불안정한 아키텍처 구조를 갖게 된다.</li></ul><h2 id="너무-이른-시기에-함수들의-실행-순서를-고정시키기-때문에-유연성과-재사용성이-저하된다"><a href="#너무-이른-시기에-함수들의-실행-순서를-고정시키기-때문에-유연성과-재사용성이-저하된다" class="headerlink" title="너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다."></a>너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.</h2><ul><li>하향식으로 기능을 분해하는 과정에서 함수는 더 작은 함수들로 분해되고, 분해된 함수들의 실행 순서를 결정하는 작업으로 요약된다.</li><li>설계를 시작하는 시점부터 시스템이 무엇을 해야하는지가 아니라 어떻게 동작해야 하는지에 집중하게 한다</li><li>처음부터 구현을 염두에 두기 때문에 자연스럽게 함수들의 시간적 실행 순서를 강조한다.</li><li>결과적으로 모든 중요한 제어 흐름의 결정이 상위 함수에서 이뤄지고 하위 함수는 상위 함수의 흐름에 따라 적절한 시점에 호출된다.</li><li>결과적으로 기능을 추가하서나 변경하는 작업은 기존의 함수 제어 구조를 변경하게 만든다.</li><li>분해된 함수를 재사용하기 어렵다.<ul><li>재사용이라는 개념은 <strong>일반성</strong>이라는 의미를 내포한다. (상위 함수보다 일반적이다)</li><li>하향식 접근법에서는 하위 함수는 상위 함수에 비해 일반적일 수 없다. (재사용이 어렵다.)</li></ul></li></ul><h2 id="데이터-형식이-변경될-경우-파급효과를-예측할-수-없다"><a href="#데이터-형식이-변경될-경우-파급효과를-예측할-수-없다" class="headerlink" title="데이터 형식이 변경될 경우 파급효과를 예측할 수 없다."></a>데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.</h2><p>하향식 기능분해의 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다.<br>따라서 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어렵다.<br>이것은 의존성과 결합도의 문제이다. 그리고 테스트의 문제이기도 하다</p><p>데이터의 변경으로 인한 영향은 데이터를 직접 참조하는 모든 함수로 퍼져나간다.<br>따라서 데이터 변경으로 인해 발생하는 함수에 대한 영향도를 파악하는 것은 예측할 수 없다. </p><p>데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다.<br>데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고 외부에서는 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제한다</p><p>변경에 대한 영향을 최소화하기 위해 영향을 받는 부분과 받지않는 부분을 명확하게 분리하고<br>잘 정의된 퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제해야 한다.</p><h2 id="언제-하향식-분해가-유용한가"><a href="#언제-하향식-분해가-유용한가" class="headerlink" title="언제 하향식 분해가 유용한가?"></a>언제 하향식 분해가 유용한가?</h2><ul><li><p>하향식 접근법은 이미 완전히 이해된 사실을 서술하기에 적합하다</p><ul><li>시스템이나 프로그램 개발자가 이미 완료한 결과에 대한 명확한 아이디어를 서술하기 위해 하향식을 사용하기 좋다.</li><li>작은 프로그램과 개별 알고리즘을 위해서는 하향식 접근법은 유용하다</li><li>프로그래밍 과정에서 이미 해결된 알고리즘을 문서화하고 서술하는 데에는 훌륭한 기법이다.</li></ul></li><li><p>새로운 것을 개발하고 설계하고 발전하는 데는 적합하지 않다.</p></li></ul><h1 id="정보-은닉과-모듈"><a href="#정보-은닉과-모듈" class="headerlink" title="정보 은닉과 모듈"></a>정보 은닉과 모듈</h1><p>시스템의 변경을 관리하는 기본적인 전략은 함께 변경되는 부분을 하나의 구현단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것이다.<br>기능을 기반으로 시스템을 분해하는 것이 아니라 변경의 방향에 맞춰 시스템을 분해하는 것이다.</p><p>정보 은닉은 시스템을 모듈 단위로 분해하기 위한 기본 원리로<br>시스템에서 <strong>자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것</strong>이 핵심이다.</p><p>정보 은닉은 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리다.<br>모듈은 변경될 가능성이 있는 비밀을 내부로 감추고 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공해서<br>내부의 비밀에 함부로 접근하지 못하게 한다.</p><p>비밀을 결정하고 모듈을 분해한 후에는 기능 분해를 이용해 모듈에 필요한 퍼블릭 인터페이스를 구현할 수 있다.  </p><blockquote><p>시스템을 모듈 단위로 어떻게 분해할 것인가?<br>정답은 시스템이 감춰야하는 비밀을 찾는 것이다.<br>외부에서 내부의 비밀에 접근하지 못하도록 커다란 방어막을 쳐서 에워싸라.<br>그렇게 하면 이 방어막이 바로 퍼블릭 인터페이스가 된다.</p></blockquote><p>모듈은 다음과 같은 두 가지 비밀을 감춰야 한다.</p><ul><li>복잡성 <ul><li>모듈이 너무 복잡한 경우 이해하고 사용하기 어렵다.</li><li>외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다.</li></ul></li><li>변경 가능성<ul><li>변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다.</li><li>변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감춘다.</li><li>외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.</li></ul></li></ul><p>시스템의 가장 일반적인 비밀은 <strong>데이터</strong>다<br>비밀이 반드시 데이터일 필요는 없으며 복잡한 로직이나 변경 가능성이 큰 자료 구조일 수도 있다.<br>그럼에도 변경 시 시스템을 굴복시키는 대부분의 경우는 데이터가 변경되는 경우다.</p><h1 id="모듈의-장점과-한계"><a href="#모듈의-장점과-한계" class="headerlink" title="모듈의 장점과 한계"></a>모듈의 장점과 한계</h1><p><strong>모듈의 장점</strong></p><ul><li><p>모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.</p><ul><li>모듈을 사용하면 모듈 내부에 정의된 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한할 수 있다.  </li><li>어떤 데이터가 변경됐을 때 영향을 받는 함수를 찾기 위해 해당 데이터를 정의한 모듈만 검색하면 된다. </li><li>모듈은 데이터 변경으로 인한 파급효과를 제어할 수 있기 때문에 코드를 수정하고 디버깅하기 용이하다</li></ul></li><li><p>비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다</p></li><li><p>전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염(namespace pollution)을 방지한다.</p><ul><li>모듈의 한 가지 용도는 네임스페이스를 제공하는 것이다.</li><li>변수와 함수를 모듈 내부에 포함시키기 때문에 다른 모듈에서도 동일한 이름을 사용할 수 있다.</li><li>모듈은 전역 네임스페이스의 오염을 방지하는 동시에 이름 충돌의 위험을 완화한다.</li></ul></li><li><p>모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다.</p><ul><li>모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합이다.<ul><li>모듈에 있어 외부에 감춰야 하는 비밀은 데이터다.</li></ul></li><li>모듈 내부는 높은 응집도를 유지한다</li><li>모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신한다</li><li>모듈과 모듈 사이에는 낮은 결합도를 유지한다.</li><li>모듈은 데이터와 함수가 통함된 한 차원 높은 추상화를 제공하는 설계 단위이다.</li></ul></li></ul><p><strong>모듈의 단점</strong></p><ul><li>모듈이 프로시저 추상화 보다는 높은 추상화를 제공한다.</li><li>모듈은 인스턴스의 개념을 제공하지 않는다는 단점이 있다.</li></ul><h1 id="데이터-추상화와-추상-데이터-타입"><a href="#데이터-추상화와-추상-데이터-타입" class="headerlink" title="데이터 추상화와 추상 데이터 타입"></a>데이터 추상화와 추상 데이터 타입</h1><h2 id="추상-데이터-타입"><a href="#추상-데이터-타입" class="headerlink" title="추상 데이터 타입"></a>추상 데이터 타입</h2><ul><li><p>프로그래밍 언어에서 <strong>타입(Type)</strong> 이란 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미한다.</p></li><li><p>프로그래밍 언어는 다양한 형태의 내장 타입(built-in type)을 제공한다.</p><ul><li>기능 분해 시대에 사용되던 절차형 언어들은 적은 수의 내장 타입만을 제공</li><li>새로운 타입을 추가하는 것이 불가능하거나 제한적이었다.</li></ul></li></ul><p>추상 데이터 타입은 프로시저 추상화 대신 데이터 추상화를 시반으로 소프트웨어를 개발하게 된 최초의 한걸음이다.<br>추상 데이터 타입을 구현하려면 다음과 같은 특성을 위한 프로그래밍 언어의 지원이 필요하다. </p><ul><li>타입 정의를 선언할 수 있어야 한다.</li><li>타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.</li><li>제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.</li><li>타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.</li></ul><blockquote><p>리스코프는 추상 데이터 타입을 정의하기 위해 제시한 언어적인 메커니즘을 <strong>오퍼레이션 클러스터(operation cluster)</strong> 라고 불렀다.</p></blockquote><h1 id="클래스는-추상-데이터-타입인가"><a href="#클래스는-추상-데이터-타입인가" class="headerlink" title="클래스는 추상 데이터 타입인가?"></a>클래스는 추상 데이터 타입인가?</h1><p>대부분의 프로그래밍 서적에서는 클래스를 추상 데이터 타입으로 설명한다.<br>그러나 명확한 의미에서 추상 데이터 타입과 클래스는 동일하지 않다.</p><ul><li>클래스는 상속과 다형성을 지원하는 데 비해 추상 데이터 타입은 지원하지 못한다.</li><li>상속과 다형성을 지원하는 프로그래밍 기법을 객체지향 프로그래밍 (Object-Oriented Programming)이라 한다.</li><li>상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍 기법을 객체기반 프로그래밍(Object-Based Programming)이라 한다.</li><li>추상 데이터 타입은 Type을 추상화한 것</li><li>클래스는 절차를 추상화한 것</li></ul><p>윌리엄 쿡은 하나의 대표적인 타입이 다수의 세부적인 타입을 감출 수 있기 때문에 이를 타입 추상화라 불렀다.  </p><p><strong>타입 추상화</strong></p><p><img src="./type-abstraction.jpg" alt="type-abstraction"></p><ul><li>개별 오퍼레이션이 모든 개념적인 타입에 대한 구현을 포괄 하도록 함으로써 하나의 물리적인 타입 안에 전체 타임을 감춘다.  </li><li>타입 추상화는 오퍼레이션을 기준으로 타입을 통합하는 데이터 추상화 기법이다.</li></ul><p><strong>객체지향</strong></p><p><img src="./procedural-abstraction.jpg" alt="procedural-abstraction"></p><ul><li>타입을 기준으로 오퍼레이션을 묶는다.</li><li>두 가지 이상의 클래스로 분리할 경우 공통로직을 어디에 둘 것인지가 이슈<ul><li>공통 로직을 제공하기 위한 간단한 방법은 공통 로직을 포함할 부모 클래스를 정의하고 상속 시킨다.</li></ul></li><li>클라이언트는 부모 클래스 참조자에 대해 메세지를 전송하면 실제 클래스가 무엇인지에 따라 다른 메소드가 실행된다.</li><li>실제로 내부에서 수행되는 절차는 다르지만 클래스를 이용한 다형성은 절차에 대한 차이점을 감춘다.<ul><li>따라서 객체지향은 절차 추상화(procedural abstraction)이다</li></ul></li></ul><h1 id="변경을-기준으로-선택하라"><a href="#변경을-기준으로-선택하라" class="headerlink" title="변경을 기준으로 선택하라"></a>변경을 기준으로 선택하라</h1><p>단순히 클래스를 구현 단위로 사용한다는 것이 객체지향 프로그래밍을 한다는 것을 의미하지 않는다.<br>비록 클래스를 사용하고 있더라도 타입을 기준으로 절차를 추상화하지 않았다면 그것은 객체지향 분해가 아니다.  </p><p><strong>추상 데이터 타입 위반 사항 check list</strong></p><ul><li>클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는가?<ul><li>인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체 지향을 위반하는 것으로 간주된다.</li></ul></li></ul><p><strong>객체 지향 위반 사항 check list</strong></p><p><img src="./Polymorphism.jpg" alt="Polymorphism"></p><ul><li><p>타입 변수를 이용한 조건문으로 구분하는가?</p><ul><li>클라이언트가 객체의 타입을 확인하고 메서드를 호출하게 해선 안된다.</li><li>객체가 메세지를 처리할 적절한 메서드를 처리하게 해야한다.</li></ul></li><li><p>OCP (Open-Closed Principle) 개방-폐쇄 원칙을 위반하는가?</p><ul><li>OCP란 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성이다.</li><li>기존코드에서 특성 변수에 대한 분기 로직이 있었다면, 새로운 요구사항이 있는 경우 코드를 수정해야 한다.</li><li>하지만 객체지향을 이용하면 코드 수정없이도 새로운 유형과 행위를 추가할 수 있다.</li></ul></li></ul><h1 id="추상-데이터-타입-vs-객체지향-당신의-선택은"><a href="#추상-데이터-타입-vs-객체지향-당신의-선택은" class="headerlink" title="추상 데이터 타입 vs 객체지향 당신의 선택은?"></a>추상 데이터 타입 vs 객체지향 당신의 선택은?</h1><ul><li>타입 추가가 빈번한가?  &#x3D;&gt; <strong>객체지향</strong><ul><li>추상데이터 타입의 경우 일일이 새로운 타입에 대해 체크하는 클라이언트 코드를 수정해야 한다.</li><li>객체지향의 경우 코드 수정없이 새로운 클래스를 상속 계층에 추가하면 된다.</li></ul></li><li>오퍼레이션 추가가 빈번한가?  &#x3D;&gt; <strong>추상 데이터 타입</strong><ul><li>객체지향의 경우 새로운 오퍼레이션을 추가하기 위해서는 상속 계층에 속하는 모든 클래스를 한번에 수정해야 한다.</li><li>추상 데이터 타입의 경우에는 전체 타입에 대한 구현 코드가 하나의 구현체에 포함되어 있다.</li><li>따라서 새로운 오퍼레이션을 추가하는 작업이 상대적으로 간단하다</li></ul></li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter7. 객체 분해</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter6. 메세지와 인터페이스</title>
      <link href="/2020/05/24/object-chapter6/"/>
      <url>/2020/05/24/object-chapter6/</url>
      
        <content type="html"><![CDATA[<h1 id="협력과-메세지"><a href="#협력과-메세지" class="headerlink" title="협력과 메세지"></a>협력과 메세지</h1><ul><li>협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.</li><li>메세지는 객체 사이의 협력을 가능하게 하는 매개체다</li><li>객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메세지를 전송하는 것뿐이다.</li><li>메세지는 매개로 하는 요청과 응답의 조합이 두 객체 사이의 협력을 구성한다.</li></ul><h2 id="클라이언트-서버-모델"><a href="#클라이언트-서버-모델" class="headerlink" title="클라이언트 서버 모델"></a>클라이언트 서버 모델</h2><p>두 객체 사이의 협력관계를 설명하기 위해 사용하는 전통적인 메타포는 <strong>클라이언트-서버(Client-Server)모델</strong>이다.</p><ul><li>클라이언트 : 협력 안에서 메세지를 전송하는 객체</li><li>서버: 협력 안에서 메세지를 수신하는 객체</li></ul><p><img src="./client-server.jpg" alt="client-server"></p><p>객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 <strong>동시에 수행하는 것이 일반적</strong>이다.<br>협력의 관점에서 객체는 두 가지 종류의 메세지 집합으로 구성된다.</p><ol><li>객체가 수신하는 메세지의 집합</li><li>외부의 객체에게 전송하는 메세지의 집합</li></ol><p><img src="./client-server2.jpg" alt="client-server2"></p><h2 id="메세지와-메세지-전송"><a href="#메세지와-메세지-전송" class="headerlink" title="메세지와 메세지 전송"></a>메세지와 메세지 전송</h2><p><strong>메세지(Message)</strong> 는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.  </p><ul><li>한 객체가 다른 객체에게 도움을 요청하는 것을 <strong>메세지 전송(message sending)</strong> 또는 <strong>메세지 패싱(message passing)</strong> 이라 부른다.</li><li>메세지를 전송하는 객체를 <strong>메세지 전송자(message sender)</strong> 혹은 <strong>클라이언트</strong>라고 부른다.</li><li>메세지를 수신하는 객체를 <strong>메세지 수신자(message receiver)</strong> 혹은 <strong>서버</strong>라고 부른다.</li></ul><p><img src="./message.jpg" alt="message"></p><ul><li>메세지는 오퍼레이션 + 인자로 구성</li><li>메세지 전송은 수신자 + 오퍼레이션 + 인자로 구성</li></ul><h2 id="메세지와-메서드"><a href="#메세지와-메서드" class="headerlink" title="메세지와 메서드"></a>메세지와 메서드</h2><p>메세지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 <strong>메서드</strong>라 부른다.<br>중요한 점은 코드 상에서 동일한 이름의 변수(condition)에게 동일한 메세지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수가 있다는 것이다.</p><ul><li>전통적인 방식 - 컴파일 레벨에서 어떤 코드가 실행될지 정확하게 알고 있는 상황에서 함수 호출이나 프로시저 호출 구문을 작성한다.</li><li>객체지향 방식 - 메세지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다. <ul><li>메세지와 메서드의 구분은 메세지 전송자와 메세지 수신자가 느슨하게 결합되도록 한다.</li><li>메세지 전송자는 자신이 어떤 메세지를 객체에 전송할 지만 알면된다.</li><li>메세지 수신자는 누가 전송하는지는 알 필요가 없고 전송받은 메세지를 처리하기 위해 필요한 메서드를 스스로 결정할 수 있는 자율권을 누린다.</li></ul></li></ul><p><strong>실행 시점에 메세지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.</strong></p><h2 id="Public-인터페이스와-오퍼레이션"><a href="#Public-인터페이스와-오퍼레이션" class="headerlink" title="Public 인터페이스와 오퍼레이션"></a>Public 인터페이스와 오퍼레이션</h2><ul><li><p>객체가 의사소통을 위해 외부에 공개하는 메세지의 집합을 <strong>퍼블릭 인터페이스(public interface)</strong> 라고 한다.</p></li><li><p>퍼블릭 인터페이스에 포함된 메세지를 <strong>오퍼레이션(operation)</strong> 이라고 부른다.</p></li><li><p>오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다</p></li></ul><p>프로그래밍 언어의 관점에서 객체가 다른 객체에게 메세지를 전송하면 런타임 시스템은 메세지 전송을 <strong>오퍼레이션 호출</strong>로 해석한다.<br>메세지를 수신한 객체의 실제 타입을 기반으로 적잘한 메서드를 찾아 실행한다.<br>따라서 퍼블릭 인터페이스와 메세지의 관점에서 보면 <strong>메서드 호출</strong>보다는 <strong>오퍼레이션 호출</strong>이라는 용어를 사용하는 것이 더 적절하다.</p><p><img src="./message-operation.jpg" alt="message-operation"></p><h2 id="메서드-시그니처"><a href="#메서드-시그니처" class="headerlink" title="메서드 시그니처"></a>메서드 시그니처</h2><p>오퍼레이션(또는 메서드)와 파라미터 목록을 합쳐 메서드 시그니처 (method signature)라고 부른다.<br>오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이다.<br>메서드는 이 시그니처에 구현을 더한 것이다.<br>이반적으로 메세지를 수신하면 오퍼레이션의 시그니처와 동일한 메서드가 실행된다.</p><p>오퍼레이션의 관점에서 <strong>다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것</strong>이라고 정의할 수 있다.</p><h1 id="인터페이스와-설계-품질"><a href="#인터페이스와-설계-품질" class="headerlink" title="인터페이스와 설계 품질"></a>인터페이스와 설계 품질</h1><p>좋은 인터페이스는 <strong>최소한의 인터페이스</strong>와 <strong>추상적인 인터페이스</strong>라는 조건을 만족해야 한다.  </p><ul><li>최소한의 인터페이스는 오퍼레이션만을 인터페이스에 포함한다.</li><li>추상적인 인터페이스는 어떻게 수행하는지가 아닌 무엇을 하는지를 표현한다.</li></ul><p><strong>책임 주도 설계 방법</strong>은 메세지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지한다.<br>따라서 인터페이스는 최소의 오퍼레이션만 포함하게 된다.</p><h2 id="디미터-법칙"><a href="#디미터-법칙" class="headerlink" title="디미터 법칙"></a>디미터 법칙</h2><p><strong>디미터 법칙(Law of Demeter)</strong> 는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이다.<br>요약하자면, 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.  </p><ul><li>낯선 자에게 말하지 말라 (don&#96;t talk to strangers)</li><li>오직 인접한 이웃하고만 말하라 (only talk to your immediate neighbors)</li><li>자바와 같이 도트(.)를 이용해 메세지를 전송을 표현하는 언어에서는 “오직 하나의 도트만 사용하라(use only one dot)”</li></ul><p>디미터 프로젝트를 진행하던 사람들은 디미터 법칙을 이용하여 <strong>객체들간의 협력 경로를 제한하면 결합도를 효과적으로 낮출 수 있다</strong>는 사실을 발견하였다.</p><p>디미터 법칙을 따르면 <strong>부끄럼타는 코드 (shy code)</strong> 를 작성할 수 있다.<br>부끄럽타는 코드란 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다.<br>디미터 법칙을 따르는 코드는 메세지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메세지 전송자는 수신자의 내부 구현에 결합되지 않는다.<br>따라서 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.</p><h3 id="디미터-법칙을-어기는-코드"><a href="#디미터-법칙을-어기는-코드" class="headerlink" title="디미터 법칙을 어기는 코드"></a>디미터 법칙을 어기는 코드</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screening.getMovie().getDiscountConditions();</span><br></pre></td></tr></table></figure><p>메세지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메세지를 전송한다.<br>흔히 이와 같은 코드를 <strong>기차 충돌(train wreck)</strong> 이라고 부른다.</p><p>이와 같은 코드는 Movie의 내부 구현을 외부로 노출 시키게 되므로 메세지 수신자의 캡슐화는 무너지고<br>메세지 전송자가 메세지 수신자의 내부 구현에 강하게 결합된다.</p><p>디미터 법칙은 객체의 내부 구조를 묻는 메세지가 아니라 수신자에게 무언가를 시키는 메세지가 더 좋다고 얘기한다.</p><h2 id="묻지-말고-시켜라"><a href="#묻지-말고-시켜라" class="headerlink" title="묻지 말고 시켜라"></a>묻지 말고 시켜라</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screening.getMovie().getDiscountConditions();</span><br></pre></td></tr></table></figure><p>위와 같은 코드는 screening에게 직접 요금을 계산할 책임을 할당한 것이다.<br>디미터 법칙은 훌륭한 메세지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.<br>메세지 전송자는 메세지 수신자의 상태를 기반으로 결정을 내린 후 메세지 수신자의 상태를 바꿔서는 안된다.<br>객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.</p><p>묻지말고 시켜라 원칙으로 얻는 이점</p><ul><li>밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.<ul><li>객체지향의 기본은 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다.</li></ul></li><li>객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.</li><li>자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.</li></ul><h2 id="의도를-드러내는-인터페이스"><a href="#의도를-드러내는-인터페이스" class="headerlink" title="의도를 드러내는 인터페이스"></a>의도를 드러내는 인터페이스</h2><p>켄트 백(Kent Beck)은 Smalltalk Best Practice Patterns에서 메서드를 명명하는 두 가지 방법을 설명했다.  </p><ol><li>메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는다.</li><li>“어떻게”가 아니라 “무엇”을 하는지 드러낸다.</li></ol><h3 id="메서드가-작업을-어떻게-수행하는지를-나타내도록-이름-짓는다"><a href="#메서드가-작업을-어떻게-수행하는지를-나타내도록-이름-짓는다" class="headerlink" title="메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는다."></a>메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는다.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeriodCondition</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedByPeriod</span><span class="params">(Screening screening)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequenceCondition</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBySequence</span><span class="params">(Screening screening)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 스타일은 좋지 않다.</p><ul><li>메서드에 대해 제대로 커뮤니케이션 하지 못한다.  두 메서드 모두 할인 조건을 판단하는 메서드이다.</li><li>하지만 메서드의 이름이 다르기 때문에 두 메서드의 내부 구현을 정확하게 이해하지 못한다면 두 메서드가 동일한 작업을 수행하는 사실을 알아채기 어렵다.</li><li>메서드 수준에서 캡슐화를 위반한다.</li><li>위의 메서드들은 클라이언트로 하여금 객체의 종류를 알도록 강요한다.</li><li>만약에 할인여부가 변경된다면 메세지를 전송하는 클라이언트 코드의  메서드의 이름또한 변경되어야 한다.</li><li>따라서 책임을 수행하는 방법을 드러내는 메서드를 사용한 설계는 변경에 취약할 수밖에 없다.</li></ul><h3 id="“어떻게”가-아니라-“무엇”을-하는지-드러낸다"><a href="#“어떻게”가-아니라-“무엇”을-하는지-드러낸다" class="headerlink" title="“어떻게”가 아니라 “무엇”을 하는지 드러낸다."></a>“어떻게”가 아니라 “무엇”을 하는지 드러낸다.</h3><p>어떻게 수행하는지를 드러내는 이름이란 메서드의 내부 구현을 설명하는 이름이다.<br>협력을 설계하기 시작하는 이른 시기부터 클래스의 내부 구현에 관해 고민할 수 밖에 없다.<br>반면 무엇을 하는지 드러내도록 메서드의 이름을 짓기 위해서는 객체가 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다.<br>이것은 외부의 객체가 메세지를 전송하는 목적을 먼저 생각하도록 만들며, 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeriodCondition</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Screening screening)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequenceCondition</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Screening screening)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클라이언트 관점에서 두 메서드 모두 다 할인 여부를 판단하기 위한 작업을 수행한다.<br>따라서 두 메서드 모두 클라이언트들의 의도를 담을 수 있도록 <code>isSatisfiedBy</code>로 변경하는 것이 적절하다</p><p>자바와 같은 정적 타이핑 언어에서는 단순히 메서드 이름이 같다고 해서 동일한 메세지를 처리할 수 있는 것은 아니다.<br>클라이언트가 동인할 타입으로 간주할 수 있도록 동일한 타입 계층으로 묶어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscountCondition</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Screening screening)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>가장 간단한 방법은 DiscountCondition이라는 인터페이스를 정의하고 이 인터페이스에 isSatisfiedBy 오퍼레이션을 정의하는 것이다.</p><h3 id="의도를-드러내는-선택자-Intention-Revealing-Selector"><a href="#의도를-드러내는-선택자-Intention-Revealing-Selector" class="headerlink" title="의도를 드러내는 선택자 (Intention Revealing Selector)"></a>의도를 드러내는 선택자 (Intention Revealing Selector)</h3><p>메서드가 어떻게 수행하느냐가 아니라 무엇을 하느냐에 초점을 맞추면 클라이언트의 관점에서 동일한 작업을 수행하는 메서드를 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다.<br>그 결과, 다양한 타입의 개규체가 참여할 수 있는 유연한 협력을 얻게 된다.</p><p>이처럼 어떻게 수행하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 <strong>의도를 드러내는 선택자 (Intention Revealing Selector)</strong> 라고 부른다.</p><blockquote><p>하나의 구현을 가진 메세지 이름을 일반화 하도록 도와주는 간단한 방법</p><p>매우 다른 두 번째 구현을 상상하라. 그러고는 메서드에 동일한 이름을 붙인다고 생각해보라<br>그렇게 하면 아마도 그 순간 가장 추상적인 이름을 메서드에 붙일 수 있을 것이다.</p></blockquote><h3 id="의도를-드러내는-인터페이스-Intention-Revealing-Interface"><a href="#의도를-드러내는-인터페이스-Intention-Revealing-Interface" class="headerlink" title="의도를 드러내는 인터페이스 (Intention Revealing Interface)"></a>의도를 드러내는 인터페이스 (Intention Revealing Interface)</h3><p>&lt;도메인 주도 설계&gt;에서 에릭에반스는 <strong>의도를 드러내는 선택자</strong>를 인터페이스 레벨로 확장한 <strong>의도를 드러내는 인터페이스</strong>를 제시했다.<br>의도를 드러내는 인터페이스란, <strong>구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다는 것</strong>이다.  </p><ul><li><p>수행 방법에 관해서는 언급하지 말고 결과와 목적만을 포함하도록 클래스와 오퍼레이션의 이름을 부여하라<br>이렇게 하면 클라이언트 개발자가 내부를 이해해야 할 필요성이 줄어들게 된다.</p></li><li><p>방법이 아닌 의도를 표현하는 추상적인 인터페이스 뒤로 모든 까다로운 메커니즘을 캡슐화해야 한다.<br>도메인의 퍼블릭 인터페이스에서는 관계와 규칙을 시행하는 방법이 아닌 이벤트와 규칙 그 자체만 명시한다.</p></li></ul><h1 id="원칙의-함정"><a href="#원칙의-함정" class="headerlink" title="원칙의 함정"></a>원칙의 함정</h1><h2 id="디미터-법칙은-하나의-도트-를-강제하는-규칙이-아니다"><a href="#디미터-법칙은-하나의-도트-를-강제하는-규칙이-아니다" class="headerlink" title="디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다."></a>디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.</h2><p>디미터 법칙은 “오직 하나의 도트만을 사용하라”라는 말로 요약되기도 한다.<br>그렇다면 builder패턴이나 lambda 식에서 주로 볼 수 있는 method chaining은 디미터 법칙을 위반하는 것일까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="number">1</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">9</span>)</span><br><span class="line">         .filter(x -&gt; x &gt; <span class="number">10</span>)</span><br><span class="line">         .distinct()</span><br><span class="line">         .count();</span><br></pre></td></tr></table></figure><p>위의 코드에서 <code>of</code>, <code>filter</code>, <code>distinct</code> 메서드는 모두 IntStream이라는 동일한 클래스의 인스턴스를 반환한다.  </p><p>따라서 이 코드는 디미터 법칙을 위반하지 않는다.<br>디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.<br>위의 코드에서는 IntStream의 내부 구조가 외부로 노출되지 않았다.<br>단지 IntStream을 다른 IntStream으로 변환할 뿐, 객체를 둘러싸고 있는 캡슐은 그대로 유지된다.</p><p>따라서 하나 이상의 도트(.)를 사용하는 모든 케이스가 디미터 법칙 위반인 것은 아니다.<br>기차 충돌처럼 보이는 코드라도 객체 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.  </p><p>또한 이 메서드들은 객체의 내부에 대한 어떤 내용도 묻지 않는다.<br>그저 객체를 다른 객체로 변환하는 작업을 수행하라고 시킬 뿐이다. 따라서 묻지말고 시켜라 원칙을 위반하지 않는다.</p><blockquote><p>로버트 마틴은 &lt;클린코드&gt;에서 디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료구조 인지에 따라 다르다고 한다.<br>객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는게 좋다.<br>자료 구조는 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.</p></blockquote><h1 id="명령-쿼리-분리-원칙-CQRS"><a href="#명령-쿼리-분리-원칙-CQRS" class="headerlink" title="명령-쿼리 분리 원칙 (CQRS)"></a>명령-쿼리 분리 원칙 (CQRS)</h1><p>명령-쿼리 분리 원칙은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.</p><ul><li>Routine: 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈. 루틴은 프로시져와 함수로 나뉜다.<ul><li>Procedure: 정해진 절차에 따라 내부의 상태를 변경. 부수효과(side effect)를 발생시킬 수 있지만 값을 반환할 수 없다.</li><li>Function: 함수는 값을 반환할 수 있지만, 부수효과(side effect)를 발생시킬 수 없다.</li></ul></li></ul><p>명령(Command)와 쿼리(Query)는 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름이다.  </p><ul><li>Command &#x3D; Procedure : 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.</li><li>Query &#x3D; Function : 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.</li></ul><h2 id="기계로서의-객체-메타포"><a href="#기계로서의-객체-메타포" class="headerlink" title="기계로서의 객체 메타포"></a>기계로서의 객체 메타포</h2><p><img src="./metaphor_machine.jpg" alt="metaphor_machine"></p><p>버트란드 마이어(Bertrand Meyer)는 <Object-Oriented Software Construction>에서 명령-쿼리 분리 원칙을 설명할 때 기계 메타포를 이용한다.<br>이 관점에서 객체는 블랙박스이며 객체의 인터페이스는 객체의 관찰 가능한 상태를 보기 위한 일련의 디스플레이와 객체의 상태를 변경하기 위해 누를 수 있는 버튼의 집합이다.  </p><p>이런 스타일의 인터페이스를 사용함으로써 객체의 캡슐화와 다양한 문맥에서의 재사용성을 보장할 수 있다.<br>마틴 파울러는 명령-쿼리 분리 원칙에 따라 작성된 인터페이스를 <strong>명령-쿼리 인터페이스(Command-Query Interface)</strong> 라고 부른다.</p><ul><li>insert, delete, merge, search는 명령(Command) 버튼으로써 기계의 상태가 변경된다.</li><li>명령(Command) 버튼은 실행 결과를 제공하지 않기 때문에 명령 버튼을 누른 직후에는 기계 내부의 상태를 직접 확인할 수 없다.</li><li>empty, current, first, last는 쿼리(Query) 버튼으로서 기계의 상태를 확인할 수 있다.</li><li>명령(Command) 버튼을 누르지 않고 쿼리(Query) 버튼을 계속 누르게 되면 항상 똑같은 값이 패널에 표시될 것이다.</li></ul><h2 id="명령-쿼리-분리와-참조-투명성"><a href="#명령-쿼리-분리와-참조-투명성" class="headerlink" title="명령-쿼리 분리와 참조 투명성"></a>명령-쿼리 분리와 참조 투명성</h2><ul><li>명령과 쿼리를 엄격하게 분류하면 객체의 부수효과(side effect)를 제어하기 수월해진다.  </li><li>쿼리는 <strong>객체의 상태를 변경하지 않기 때문에 몇 번이고 반복적으로 호출하더라도 상관이 없다.</strong> (항상 같은 값을 리턴한다.) </li><li>명령이 개입하지 않는 한 쿼리의 값은 변경되지 않기 때문에 쿼리의 결과를 예측하기 쉬워진다.  </li><li>또한 쿼리의 순서를 자유롭게 변경할 수도 있다.</li></ul><p>명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 <strong>참조 투명성(referential transparency)</strong> 의 장점을 제한적이나마 누릴 수 있게 된다.<br>참조 투명성을 잘 활용하면 버그가 적고, 디버깅이 용이하고, 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성할 수 있다.</p><p>하지만 명령-쿼리 분리를 하지 않은 함수에서는 내부에 부수효과를 포함할 경우 동일한 인자를 전달하더라도 부수효과에 의해 그 결괏값이 매번 달라질 수 있다.</p><h2 id="수학으로-보는-참조-투명성"><a href="#수학으로-보는-참조-투명성" class="headerlink" title="수학으로 보는 참조 투명성"></a>수학으로 보는 참조 투명성</h2><p>참조 투명성이란 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라고 결과가 달라지지 않는 특성을 의미한다.</p><p>어떤 함수 f(n)이 존재 할 때 n의 값으로 1을 대입하면 그 결과가 3이라고 가정하자 (f(1) &#x3D; 3)</p><ul><li>f(1) + f(1) &#x3D; 6</li><li>f(1) * 2 &#x3D; 6</li><li>f(1)  - 1 &#x3D; 2</li></ul><p>위에서 f(1) &#x3D; 3 이라고 했기 때문에 대입하여 결과를 얻어내기 쉬웠다.<br>f(1) 자리에 3으로 바꿔보자</p><ul><li>3 + 3 &#x3D; 6</li><li>3 * 2 &#x3D; 6</li><li>3  - 1 &#x3D; 2</li></ul><p>이것이 바로 참조 투명성이다.<br>수학에서의 함수는 항상 동일한 입력에 대해 동일한 값을 반환하기 때문에 수학의 함수는 참조 투명성을 만족 시키는 이상적인 예이다.  </p><p>따라서 참조 투명성은 식을 값으로 치환하는 방법을 통해 결과를 쉽게 계산할 수 있게 해준다.<br>여기서 f(1)의 값을 항상 3이라고 말할 수 있는 이유는 f(1)의 값이 변하지 않기 때문이다.<br>이처럼 어떤 값이 변하지 않는 성질을 불변성(immutability)이라고 부른다.<br>어떤 값이 불변한다는 말은 부수효과(side effect)가 발생하지 않았다는 말과 동일하다.</p><p>참조 투명성을 만족하는 식은 두 가지 장점을 제공한다.</p><ul><li>모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.</li><li>모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.</li></ul><p>객체지향 패러다임이 객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다.<br>하지만 명령-쿼리 분리 원칙을 사용하면 조금이나마 예외를 줄일 수 있다.<br>명령-쿼리 분리 원칙은 부수효과를 가지는 명령으로부터 부수효과를 가지지 않는 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있다.</p><h2 id="명령형-프로그래밍과-함수형-프로그래밍"><a href="#명령형-프로그래밍과-함수형-프로그래밍" class="headerlink" title="명령형 프로그래밍과 함수형 프로그래밍"></a>명령형 프로그래밍과 함수형 프로그래밍</h2><ul><li>명령형 프로그래밍 : 부수효과를 기반으로 하는 프로그래밍 방식<ul><li>상태를 변경시키는 연산들을 적절한 순서대로 나열하여 프로그램을 작성한다.</li><li>대부분의 객체지향 프로그래밍 언어는 메세지에 의한 객체의 상태 변경에 집중하기 때문에 명령형 프로그래밍 언어로 본다.</li></ul></li><li>함수형 프로그래밍 : 부수효과가 존재하지 않는 수학적인 함수에 기반한다.<ul><li>참조 투명성의 장점을 극대화할 수 있다.</li><li>명령형 프로그래밍에 비해 프로그램의 실행 결과를 이해하고 예측하기가 쉽다.</li></ul></li></ul><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>디미터 법칙: 협력이라는 컨텍스트 안에서 객체보다 메세지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다.<br>수신할 객체를 알지 못한 상태에서 메세지를 먼저 선택하기 때문에 객체의 내부 구조에 대해 고민할 필요가 없어진다.<br>따라서 메세지가 객체를 선택하게 함으로써 의도적으로 디미터 법칙을 위반할 위험을 최소화할 수 있다.</li><li>묻지 말고 시켜라: 메세지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다.<br>클라이언트의 관점에서 메세지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메세지를 전송하면 된다. </li><li>의도를 드러내는 인터페이스: 메세지를 먼저 선택한다는 것은 메세지를 전송하는 클라이엍느의 관점에서 메세지의 이름을 정한다는 것이다.<br>당연히 그 이름에는 클라이언트가 무엇을 원하는지, 그 의도가 분명하게 드러날 수 밖에 없다.</li><li>명령-쿼리 분리 원칙: 메세지를 먼저 선택한다는 것은 협력이라는 문맥 안에서 객체의 인터페이스에 관해 고민한다는 것을 의미한다.<br>객체가 단순히 어떤 일을 해야 하는지뿐만 아니라 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게 된다. 따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter6. 메세지와 인터페이스</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter5. 책임 할당하기</title>
      <link href="/2020/05/16/object-chapter5/"/>
      <url>/2020/05/16/object-chapter5/</url>
      
        <content type="html"><![CDATA[<h1 id="책임-주도-설계를-향해"><a href="#책임-주도-설계를-향해" class="headerlink" title="책임 주도 설계를 향해"></a>책임 주도 설계를 향해</h1><p>책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 <strong>어떤 객체에게 어떤 책임을 할당할지를 결정하기가 쉽지 않다는 것</strong>이다.<br>책임 할당 과정은 일종의 트레이드오프 활동이다.<br>동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라진다.<br>따라서 올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가할 수 있어야 한다.<br>chapter 5에서는 GRASP 패턴을 이용하여 책임 할당의 어려움을 해결하는 방법을 제시하였다.</p><h1 id="데이터-중심-설계-gt-책임-주도-설계"><a href="#데이터-중심-설계-gt-책임-주도-설계" class="headerlink" title="데이터 중심 설계 -&gt; 책임 주도 설계"></a>데이터 중심 설계 -&gt; 책임 주도 설계</h1><p>데이터 중심의 설계에서 책임 중심의 설계로 전환하기 위해서는 다음의 두 가지 원칙을 따라야 한다.</p><ul><li>데이터보다 행동을 먼저 결정하라</li><li>협력이라는 문맥 안에서 책임을 결정하라</li></ul><h1 id="데이터보다-행동을-먼저-결정하라"><a href="#데이터보다-행동을-먼저-결정하라" class="headerlink" title="데이터보다 행동을 먼저 결정하라"></a>데이터보다 행동을 먼저 결정하라</h1><p>객체에게 중요한 것은 데이터가 아니라 외부에 제공하는 행동이다.<br>클라이언트의 관점에서 객체가 수행하는 행동이란 곧 객체의 책임을 의미한다.<br>객체는 협력에 참여하기 위해 존재하며 협력안에서 수행하는 책임이 객체의 존재가치를 증명한다.</p><p>따라서 <strong>이 객체가 수행해야 하는 일은 무엇인가?</strong> -&gt; <strong>이 객체가 이 일을 수행하기 위해 필요한 데이터는 무엇인가?</strong>  의 순서로 접근해야 한다.</p><h1 id="협력이라는-문맥-안에서-책임을-결정하라"><a href="#협력이라는-문맥-안에서-책임을-결정하라" class="headerlink" title="협력이라는 문맥 안에서 책임을 결정하라"></a>협력이라는 문맥 안에서 책임을 결정하라</h1><p>객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정된다.  </p><ul><li>객체에 할당된 책임이 협력에 어울리지 않는다면 그 책임은 나쁜 책임이다.</li><li>책임이 조금 어색해도 협력에 적합하다면 그 책임은 좋은 것이다.</li><li>책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다.</li><li>협력에 적합한 책임이란 메세지 수신자가 아닌 메세지 전송자에게 적합한 책임이다.<ul><li>메세지를 실제로 요청하는 입장에서 메서드를 작성한다.</li></ul></li><li>협력에 적합한 책임을 수확하기 위해서는 메세지를 결정한 후에 객체를 선택해야 한다.<ul><li>~한 일을 해야 하는데 ~객체를 사용해야 한다.</li><li>메세지를 전송해야하는데 누구한테 전송하지?</li></ul></li><li>클라이언트는 단지 임의의 객체가 메세지를 수신할 것이라는 사실을 믿고 자신의 의도를 표현한 메세지를 전송할 뿐이다<ul><li>실제 메세지를 수신하는 객체가 메세지를 처리할 <code>책임</code>을 할당 받게 된다.</li></ul></li></ul><h1 id="책임-주도-설계의-흐름"><a href="#책임-주도-설계의-흐름" class="headerlink" title="책임 주도 설계의 흐름"></a>책임 주도 설계의 흐름</h1><ol><li>시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.</li><li>시스템 책임을 더 작은 책임으로 분할한다.</li><li>분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.</li><li>객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다</li><li>해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.</li></ol><p>책임 주도 설계의 핵심은 책임을 결정한 후에 책임을 수행할 객체를 결정하는 것이다.<br>협력에 참여하는 객체들의 책임이 어느정도 정리될 때 까지는 객체의 내부 상태에 대해 관심을 가지지 않는 것이다.</p><h1 id="GRASP-패턴"><a href="#GRASP-패턴" class="headerlink" title="GRASP 패턴"></a>GRASP 패턴</h1><p>GRASP (General Responsibility Assignment Software Pattern)의 약자로 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것이다.</p><h2 id="도메인-개념에서-출발하기"><a href="#도메인-개념에서-출발하기" class="headerlink" title="도메인 개념에서 출발하기"></a>도메인 개념에서 출발하기</h2><p>설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려 보는 것이 유용하다<br>따라서 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념이다.</p><p><img src="./domain.jpeg" alt="domain"></p><p>설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요는 없다.<br>중요한 것은 설계를 시작하는 것이지 도메인 개념들을 완벽하게 정리하는 것이 아니다.<br>도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현으로 넘어가는 것이 좋다.</p><h2 id="정보-전문가에게-책임을-할당하라"><a href="#정보-전문가에게-책임을-할당하라" class="headerlink" title="정보 전문가에게 책임을 할당하라"></a>정보 전문가에게 책임을 할당하라</h2><p>책임 주도 설계 방식의 첫 단계는 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것이다.<br>책임의 관점에서 질문을 해본다.</p><ol><li>메세지를 전송할 객체는 무엇을 원하는가?</li><li>메세지를 수신할 적합한 객체는 누구인가?</li></ol><p>이 질문에 답하기 위해서는 객체가 <strong>상태와 행동을 통합한 캡슐화의 단위</strong>라는 사실에 집중해야 한다.<br>객체는 자신의 상태를 스스로 처리하는 자율적인 존재여야 한다.<br>따라서 객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다.<br>이를 <strong>INFORMATION EXPERT(정보 전문가) 패턴</strong>이라고 부른다.</p><blockquote><p>INFORMATION EXPERT(정보 전문가) 패턴<br>책임을 정보 전문가. 즉 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하라<br>INFORMATION EXPERT(정보 전문가) 패턴은 객체가 자율적인 존재여야 한다는 사실을 한번 더 상기시킨다.<br>정보를 알고 있는 객체만이 책임을 어떻게 수행할지 스스로 결정할 수 있기 때문이다.  </p><p>INFORMATION EXPERT(정보 전문가) 패턴을 따르면 정보와 행동을 최대한 가까운 곳(&#x3D;같은 클래스 내)에 위치 시키기 때문에 캡슐화를 유지할 수 있다.<br>필요한 정보를 가진 객체들로 책임이 분산되기 때문에 더 응집력 있고, 이해하기 쉬워진다.<br>따라서 높은 응집도, 낮은 결합도를 가진 시스템을 구축할 수 있다.  </p></blockquote><p><strong>책임을 수행하는 객체가 정보를 <code>알고</code> 있다고 해서 반드시 그 정보를 저장하는 변수를 만들 필요는 없다.</strong><br>다른 객체의 도움을 받아 전달받을 수도 있기 때문이다.</p><h1 id="LOW-COPLING-낮은-결합도-패턴"><a href="#LOW-COPLING-낮은-결합도-패턴" class="headerlink" title="LOW COPLING(낮은 결합도) 패턴"></a>LOW COPLING(낮은 결합도) 패턴</h1><p>어떻게 하면 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있을까?<br>설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라.</p><p>낮은 결합도는 모든 설계 결정에서 염두에 둬야 하는 원리다. 다시 말해 설계 결정을 평가할 때 적용할 수 있는 평가원리다.<br>현재의 책임 할당을 검토하거나 여러 설계 대안들이 있을 때 낮은 결합도를 유지할 수 있는 설계를 선택해야한다.</p><h1 id="HIGH-COHESION-높은-응집도-패턴"><a href="#HIGH-COHESION-높은-응집도-패턴" class="headerlink" title="HIGH COHESION(높은 응집도) 패턴"></a>HIGH COHESION(높은 응집도) 패턴</h1><p>어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가? 높은 응집도를 유지할 수 있게 책임을 할당하라 </p><p>낮은 결합도처럼 높은 응집도 역시 모든 설계 결정에서 염두에 둬야 할 원리다.<br>다시 말해 설계 결정을 평가할 때 적용할 수 있는 평가 원리다.<br>현재의 책임 할당을 검토하고 있거나 여러 설계 대안 중 하나를 선택해야 한다면 높은 응집도를 유지할 수 있는 설계를 선택해야 한다.</p><h2 id="클래스-응집도-판단하기"><a href="#클래스-응집도-판단하기" class="headerlink" title="클래스 응집도 판단하기"></a>클래스 응집도 판단하기</h2><ul><li>클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다. 변경의 이유를 기준으로 클래스를 분리하라<ul><li>다양한 기능이 짬뽕된 클래스이다</li></ul></li><li>클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다.<br>초기화되는 속성의 그룹을 기준으로 클래스를 분리하라<ul><li>인스턴스 생성 시, 모든 변수가 다 초기화 되어야 한다.</li><li>어떤 변수는 초기화 되고 어떤 변수는 초기화가 되지않으면 초기화가 되는 변수들 끼리 묶어서 클래스를 분리한다</li></ul></li><li>메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다.<br>이들 그룹을 기준으로 클래스를 분리하라<ul><li>메서드 내에서 클래스내의 변수를 사용해야 한다. </li><li>메서드 2개에서 사용하는 변수들이 틀리다면 변수들을 기준으로 클래스를 분리 해야한다.</li></ul></li><li>메서드가 너무 긴 경우 private 메서드로 잘게 쪼개면 숨겨진 문제점이 드러나는 경우가 많다</li></ul><h1 id="CREATOR-패턴"><a href="#CREATOR-패턴" class="headerlink" title="CREATOR 패턴"></a>CREATOR 패턴</h1><p>객체 A를 생성해야 할 떄 어떤 객체에게 객체 생성 책임을 할당해야 하는가? 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라. </p><ul><li>B가 A 객체를 포함하거나 참조한다.</li><li>B가 A 객체를 기록한다</li><li>B가 A 객체를 긴밀하게 사용한다</li><li>B가 A 객체를 초기화 하는데 필요한 데이터를 가지고 있다 (이 경우 B는 A에 대한 정보 전문가다)</li></ul><p>CREATOR 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.<br>생성될 객체에 대해 잘 알고 있어야 하거나 그 객체를 사용해야 하는 객체는 어떤 방식으로든 생성될 객체와 연결될 것이다.<br>다시 말해 두 객체는 서로 결합된다.</p><p>이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다.<br>결과적으로 CREATOR 패턴은 이미 존재하는 객체 사이의 관계를 이용하기 때문에 설계가 낮은 결합도를 유지할 수 있게 해준다.</p><h1 id="POLYMORPHISM-패턴"><a href="#POLYMORPHISM-패턴" class="headerlink" title="POLYMORPHISM 패턴"></a>POLYMORPHISM 패턴</h1><p>객체의 타입에 따라 변하는 로직이 있을 때 변하는 로직을 담당할 책임을 어떻게 할당해야 하는가?<br>타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하라</p><p>조건에 따른 변화는 프로그램의 기본 논리다. <strong>프로그램을 if-else 또는 switch case 등의 조건 논리를 사용해서 설계</strong>한다면<br>새로운 변화가 일어난 경우 조건 논리를 수정해야 한다.<br><strong>이것은 프로그램을 수정하기 어렵고 변경에 취약하게 만든다.</strong></p><p>POLYMORPHISM 패턴은 객체의 타입을 검사해서 타입에 따라 여러 대안들을 수행하는 조건적인 논리를 사용하지 말라고 경고 한다.<br>대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하라고 권고한다.</p><h1 id="PROTECTED-VARIATIONS-패턴"><a href="#PROTECTED-VARIATIONS-패턴" class="headerlink" title="PROTECTED VARIATIONS 패턴"></a>PROTECTED VARIATIONS 패턴</h1><p>객체, 서브시스템 그리고 시스템을 어떻게 설계해야 변화와 불안정성이 다른 요소에 나쁜 영향을 미치지 않도록 방지할 수 있을까?<br>변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라</p><p>PROTECTED VARIATIONS 패턴은 책임 할당의 관점에서 캡슐화를 설명한 것이다. <strong>“설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화하라”</strong> 라는 객체지향의 오랜격언은 PROTECTED VARIATIONS 패턴의 본질을 잘 설명해준다.</p><p>우리가 캡슐화해야 하는 것은 변경이다. </p><p><strong>변경될 가능성이 높은가? 그렇다면 캡슐화를 해야한다.</strong></p><h1 id="리팩터링"><a href="#리팩터링" class="headerlink" title="리팩터링"></a>리팩터링</h1><p>책임 주도 설계에 익숙해지기 위해서는 부단한 노력과 시간이 필요하다.<br>한번에 하기 힘들기에 일단은 <strong>절차지향적 방식</strong>으로 프로그램을 구성한 다음에 리팩터링을 통해 <strong>책임 주도 설계로 전환</strong>하는 방법을 사용해보자</p><h2 id="긴-메서드의-단점"><a href="#긴-메서드의-단점" class="headerlink" title="긴 메서드의 단점"></a>긴 메서드의 단점</h2><ul><li>어떤 일을 수행하는지 한눈에 파악하기 어렵기 때문에 코드를 이해하는데 많은 시간이 걸린다.</li><li>하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.</li><li>메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다</li><li>로직의 일부만 재사용하는 것이 불가능하다</li><li>코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣는 것뿐이므로 코드 중복을 초래하기 쉽다.</li></ul><h2 id="이해하기-쉬운-메서드"><a href="#이해하기-쉬운-메서드" class="headerlink" title="이해하기 쉬운 메서드"></a>이해하기 쉬운 메서드</h2><ul><li>메서드가 잘게 나눠진 메서드 (재사용성이 높아진다.)</li><li>고수준의 메서드를 볼때 간략한 코드만으로 어떤 기능을 수행하는지 알 수 있다.</li><li>메서드 이름만으로도 무슨 기능을 수행하는지 파악할 수 있다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - chapter5. 책임 할당하기</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter4. 설계 품질과 트레이드오프</title>
      <link href="/2020/05/16/object-chapter4/"/>
      <url>/2020/05/16/object-chapter4/</url>
      
        <content type="html"><![CDATA[<h1 id="데이터-중심의-설계"><a href="#데이터-중심의-설계" class="headerlink" title="데이터 중심의 설계"></a>데이터 중심의 설계</h1><p>객체지향 설계에는 두 가지 방법을 이용해 시스템을 객체로 분할할 수 있다.  </p><ul><li>데이터를 분할의 중심축으로 삼는 방법 (Entity를 먼저 정의하고 비지니스 로직 구현)<ul><li>데이터 중심의 관점에서는 객체는 <strong>자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의</strong></li><li>객체는 독립된 데이터 덩어리처럼 바라본다</li></ul></li><li>책임을 분할의 중심축으로 삼는 방법 (Interface 기반의 비지니스 로직을 구현하고 필요한 속성을 정의)<ul><li>객체는 다른 객체가 요청할 수 있는 <strong>오퍼레이션을 위해 필요한 데이터만 생성</strong>하는 정도</li><li>객체랑 협력하는 공동체의 일환으로 바라본다</li></ul></li></ul><h1 id="데이터-중심-설계가-안-좋은-이유"><a href="#데이터-중심-설계가-안-좋은-이유" class="headerlink" title="데이터 중심 설계가 안 좋은 이유"></a>데이터 중심 설계가 안 좋은 이유</h1><p>객체지향 설계는 데이터가 아닌 책임에 초점을 맞춰야한다.  </p><ul><li><p>객체의 상태는 구현에 속한다</p></li><li><p>구현은 불안정하기 때문에 변화하기 쉽다</p></li><li><p>상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들어 캡슐화가 무너진다. </p></li><li><p>상태 변경 -&gt; 인터페이스의 변경 -&gt; 의존성을 갖는 객체에게 변경 영향이 퍼짐</p></li><li><p>데이터에 초점을 맞추는 설계는 변경에 취약하다</p></li><li><p>객체의 내부 구현을 인터페이스의 일부로 만든다. <strong>(캡슐화 위반)</strong></p><ul><li>getter&#x2F;setter와 같은 메서드가 퍼블릭으로 생성되어 어디서든 접근이 가능하다</li></ul></li></ul><h1 id="데이터-중심-설계의-문제점"><a href="#데이터-중심-설계의-문제점" class="headerlink" title="데이터 중심 설계의 문제점"></a>데이터 중심 설계의 문제점</h1><p>데이터 중심 설계가 변경에 취약한 이유는 두 가지이다.</p><ul><li>데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 한다.<ul><li>데이터 중심으로 클래스를 구성하다 보면 책임에 대해 무감각해져 캡슐화를 위반하기 쉽다.</li><li>데이터 중심 관점에서는 객체란 그냥 데이터 덩어리이기 때문에 별도로 분리된 객체에서 로직을 구현하게 된다.<ul><li>이는 getter&#x2F;setter의 남용을 불러온다.</li><li>이로 인해 캡슐화가 무너진다.</li></ul></li><li>데이터를 먼저 잡고 오퍼레이션을 잡기 때문에 데이터에 대한 정보가 인터페이스로 외부에 표현된다.</li><li>따라서 객체 내부 구현이 객체의 인터페이스를 어지럽히고 객체의 응집도와 결합도에 나쁜 영향을 준다. (변경에 취약)</li></ul></li><li>데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.<ul><li>올바른 객체지향 설계의 무게중심은 항상 객체 내부가 아니라 외부에 포커스가 가야한다.</li><li>내부에서 어떤 상태를 가지고 뭘하는지는 부가적인 문제이다.</li><li>항상 다른 객체와 어떻게 협력하는지 부터 생각해야 한다.</li><li>데이터 중심 설계에서는 이미 구현(&#x3D;데이터)가 결정된 상태에서 다른 객체와의 협력을 고려하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워 맞출 수 밖에 없다.</li><li>따라서 내부가 변경되면 협력하는 객체 모두가 영향을 받게 된다.</li></ul></li></ul><h1 id="데이터-중심-설계에서-빠지는-착각"><a href="#데이터-중심-설계에서-빠지는-착각" class="headerlink" title="데이터 중심 설계에서 빠지는 착각"></a>데이터 중심 설계에서 빠지는 착각</h1><p>데이터 중심으로 객체를 설계하다보면 객체가 필요한 데이터에 집중하게 된다.<br>이는 예전 DB 기반의 설계를 하던 것과 유사하다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> Duration runningTime;</span><br><span class="line">  <span class="keyword">private</span> Money fee;</span><br><span class="line">  <span class="keyword">private</span> List&lt;DiscountCondition&gt; discountConditions;</span><br><span class="line">  <span class="keyword">private</span> MovieType movieType;</span><br><span class="line">  <span class="keyword">private</span> Money discountAmount;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> discountPercent;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.title;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Duration <span class="title function_">getRunningTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.runningTime;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Money <span class="title function_">getFee</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.fee;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunningTime</span><span class="params">(Duration runningTime)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.runningTime = runningTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFee</span><span class="params">(Money fee)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fee = fee;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>객체지향의 가장 중요한 원칙은 캡슐화가 맞다.<br>내부 데이터가 객체를 빠져나가 외부의 다른 객체들을 오염시키는 것을 막아야 한다.<br>이를 위한 가장 간단한 방법은 위의 코드와 같이 접근자(getter) &#x2F; 수정자(setter)를 추가하는 것이다.  </p><p>위와 같은 코드는 직접 객체의 내부에 접근할 수 없기 때문에 캡슐화의 원칙을 지키고 있는 것 처럼 보인다.<br>하지만 위의 예시는 객체 내부 상태에 대한 어떤 정보도 캡슐화하지 못한다.<br>getter&#x2F;setter는 <strong>객체 내부에 Title, RunningTime, Fee라는 인스턴스 변수가 존재한다는 사실을  public 인터페이스에 노골적으로 드러낸다.</strong></p><p>캡슐화를 한다고 코드를 위와같이 짰지만 캡슐화를 위반하는 코드가 되는 셈이다.</p><h1 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h1><p>객체지향에서 가장 중요한 원리는 캡슐화다.  </p><ul><li><p>외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다 </p></li><li><p>불안정한 구현의 세부 사항을 안정적인 인터페이스 뒤로 숨기는 것이다.</p></li><li><p>캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다.</p></li><li><p>즉, 캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다.</p></li></ul><h2 id="구현과-인터페이스"><a href="#구현과-인터페이스" class="headerlink" title="구현과 인터페이스"></a>구현과 인터페이스</h2><ul><li>구현이란 변경될 가능성이 높은 부분을 의미한다<ul><li>변경될 가능성이 높은 부분은 객체 내부로 숨겨야 한다.</li><li>한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 조절하기 위해서다</li></ul></li><li>인터페이스란 상대적으로 안정적인 부분이다.</li></ul><h1 id="응집도와-결합도"><a href="#응집도와-결합도" class="headerlink" title="응집도와 결합도"></a>응집도와 결합도</h1><p>객체 지향에서의 좋은 설계란, 높은 응집도와 낮은 결합도로 가진 모듈로 구성된 설계를 의미한다.</p><ul><li>응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.<ul><li>모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면, 그 모듈은 높은 응집도를 가진다.</li><li>모듈 내의 요소들이 서로 다른 목적을 추구 한다면 그 모듈은 낮은 응집도를 가진다.</li><li>객체지향 관점에서 응집도는 객체 또는 클래스에 얼마나 높은 책임들을 할당했는지 나타낸다.</li><li>쉽게 말하면 객체 하나가 이 일 저 일 다하면 응집도가 낮은것이다.</li></ul></li><li>결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많이 알고 있는지를 나타낸다.<ul><li>A 모듈이 B 모듈에 대해 너무 자세한 구현부까지 알고 있다면 두 모듈은 높은 결합도를 가진다.</li><li>A 모듈이 B 모듈에 대해 간단한 인터페이스정도만 알고 있다면 두 모듈은 낮은 결합도를 가진다.</li><li>결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있다.</li></ul></li></ul><h2 id="높은-응집도와-낮은-결합도를-추구-해야하는-이유"><a href="#높은-응집도와-낮은-결합도를-추구-해야하는-이유" class="headerlink" title="높은 응집도와 낮은 결합도를 추구 해야하는 이유"></a>높은 응집도와 낮은 결합도를 추구 해야하는 이유</h2><p><strong>변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.</strong>  </p><ul><li>하나의 변경에 의해 여러개의 모듈이 변경되면 <strong>응집도가 낮다</strong>, <strong>결합도가 높다</strong></li><li>하나의 변경에 의해 하나의 모듈이 변경되면 <strong>응집도가 높다</strong>, <strong>결합도가 낮다</strong></li></ul><p>클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.</p><h2 id="결합도가-높아도-상관-없는-경우도-있다"><a href="#결합도가-높아도-상관-없는-경우도-있다" class="headerlink" title="결합도가 높아도 상관 없는 경우도 있다"></a>결합도가 높아도 상관 없는 경우도 있다</h2><p>일반적으로 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것은 아무런 문제가 되지 않는다.<br>표준 라이브러리에 포함된 모듈이나 성숙 단계에 접어든 프레임 워크에 의존하는 경우가 여기에 속한다.<br>ex) String, ArrayList와 같은 클래스는 변경될 확률이 매우 낮기 때문에 결합도에 대해 고민할 필요가 없다   </p><p>하지만 직접 작성한 코드는 항상 불안정하며 언제라도 변경될 가능성이 높기 때문에 주의해야 한다.<br><strong>이런 높은 응집도와 낮은 응집도를 실현하기 위해서는 캡슐화를 향상 시키면 된다.</strong></p><h1 id="캡슐화를-항상-생각하자"><a href="#캡슐화를-항상-생각하자" class="headerlink" title="캡슐화를 항상 생각하자"></a>캡슐화를 항상 생각하자</h1><ul><li>캡슐화는 설계의 제 1원칙이다.  </li><li>데이터 중심의 설계가 낮은 응집도와 높은 결합도라는 문제로 몸살을 앓게 된 근본적인 원인은 바로 캡슐화를 위반했기 때문이다.  </li><li>객체는 자신이 어떤 데이터를 가지고 있는지를 내부에서만 알아야 하고 외부에 공개하면 안된다.  (getter&#x2F;setter를 만들지 마라)</li></ul><h2 id="Rectangle-클래스로-보는-캡슐화의-중요성"><a href="#Rectangle-클래스로-보는-캡슐화의-중요성" class="headerlink" title="Rectangle 클래스로 보는 캡슐화의 중요성"></a>Rectangle 클래스로 보는 캡슐화의 중요성</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> left;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> top;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> right;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> bottom;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.left = left;</span><br><span class="line">    <span class="built_in">this</span>.top = top;</span><br><span class="line">    <span class="built_in">this</span>.right = right;</span><br><span class="line">    <span class="built_in">this</span>.bottom = bottom;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeft</span><span class="params">()</span> &#123; <span class="keyword">return</span> left; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(<span class="type">int</span> left)</span> &#123; <span class="built_in">this</span>.left = left &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRight</span><span class="params">()</span> &#123; <span class="keyword">return</span> right; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(<span class="type">int</span> right)</span> &#123; <span class="built_in">this</span>.right = right &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTop</span><span class="params">()</span> &#123; <span class="keyword">return</span> top; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTop</span><span class="params">(<span class="type">int</span> top)</span> &#123; <span class="built_in">this</span>.top = top &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBottom</span><span class="params">()</span> &#123; <span class="keyword">return</span> bottom; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBottom</span><span class="params">(<span class="type">int</span> bottom)</span> &#123; <span class="built_in">this</span>.bottom = bottom &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnyClass</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">anyMethod</span><span class="params">(Rectangle rectangle, <span class="type">int</span> multiple)</span> &#123;</span><br><span class="line">    rectangle.setRight(rectangle.getRight() * multiple)</span><br><span class="line">    rectangle.setBottom(rectangle.getBottom() * multiple)</span><br><span class="line">    rectangle.setLeft(rectangle.getLeft() * multiple)</span><br><span class="line">    rectangle.setTop(rectangle.getTop() * multiple)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 코드는 많은 문제점이 있다. </p><ul><li><code>코드중복</code>이 발생할 확률이 높다.<ul><li>다른 곳에서도 사각형의 너비와 높이를 증가시키는 코드가 필요하면 또 이 코드를 작성해야 한다.</li><li>악의 근원인 setter를 남발하고 있다.</li></ul></li><li>변경에 취약하다<ul><li>Rectangle이 right와 bottom 대신 length와 height를 이용해서 사각형을 표현하게 되면 여러 부분에 코드를 수정해야 한다.</li><li>이런 변경은 기존 getter&#x2F;setter를 사용하던 코드 전반적으로 영향을 미치게 된다</li></ul></li></ul><p>해결 방법은 캡슐화를 강화시키는 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enlarge</span><span class="params">(<span class="type">int</span> multiple)</span> &#123;</span><br><span class="line">    right *= multiple;</span><br><span class="line">    bottom *= multiple;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자신의 크기를 코드 외부에서 증가시키는 것이 아닌 Rectangle 클래스 내부에서 스스로 할 수 있도록 <strong>책임을 이동하였다.</strong></p><h1 id="캡슐화의-진정한-의미"><a href="#캡슐화의-진정한-의미" class="headerlink" title="캡슐화의 진정한 의미"></a>캡슐화의 진정한 의미</h1><p>캡슐화는 단순히 객체 내부의 데이터를 외부로부터 감추는 것 이상의 의미를 가진다.<br>사실 상 변경될 수 있는 어떤 것이라도 감추는 것이 진정한 캡슐화이다.<br>내부 속성을 외부로 부터 감추는 것은 <strong>데이터 캡슐화</strong>라고 불리는 캡슐화의 한 종류일 뿐이다.<br><strong>만약 클래스 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는 다면 그것은 캡슐화를 위반한 것이다.</strong><br>정리하자면 캡슐화란 무엇이든 변하는 것은 감추는 것이다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>​    Objects(코드로 이해하는 객체지향 설계) - Chapter4. 설계 품질과 트레이드오프</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter3. 역할, 책임, 협력</title>
      <link href="/2020/05/10/object-chapter3/"/>
      <url>/2020/05/10/object-chapter3/</url>
      
        <content type="html"><![CDATA[<h1 id="역할-책임-협력"><a href="#역할-책임-협력" class="headerlink" title="역할, 책임, 협력"></a>역할, 책임, 협력</h1><p>객체지향 패러다임의 관점에서의 핵심은 역할(role), 책임(responsibility), 협력(collaboration)이다.<br>애플리케이션의 기능을 구현하기 위해 <strong>어떤 협력이 필요하고</strong> 협력을 위해 <strong>어떤 역할과 책임이 필요한지</strong> 고민하지 않은 채 너무 이른 시기에 구현에만 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.</p><ul><li>협력: 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용 </li><li>역할: 객체들이 협력안에서 수행하는 책임들을 일컫는 말 (&#x3D; 인터페이스라 의역하면 이해가 쉽다)</li><li>책임: 객체가 협력에 참여하기 위해 수행하는 로직 (&#x3D; 인터페이스 구현체 또는 객체)</li></ul><h1 id="협력"><a href="#협력" class="headerlink" title="협력"></a>협력</h1><p>협력은 객체지향 세계에서 기능을 구현할 수 있는 유일한 방법이다.<br>하나의 객체가 모든 일을 처리하는 것이 아닌 각각의 역할을 수행할 수 있는 객체들간의 <strong>메세지 전송</strong>이라는 커뮤니케이션 수단을 이용하여 객체 간 협력을 통해 애플리케이션 기능을 수행할 수 있다.</p><blockquote><p><strong>협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다.</strong><br>한 객체는 어떤 것이 필요할 때 다른 객체에게 전적으로 위임하거나 서로 협력한다.<br>즉, 두 객체가 상호작용을 통해 더 큰 책임을 수행하는 것이다.<br>객체 사이의 협력을 설계할 때는 <strong>객체를 서로 분리된  인스턴스가 아닌 협력하는 파트너로 인식해야한다.</strong></p></blockquote><p>자율적인 객체는 자신에게 할당된 책임을 수행하던 중 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메세지를 전송해서 협력을 요청한다.  </p><p>객체들 사이의 협력을 구성하는 일련의 요청과 응답을 통해 애플리케이션의 기능이 구현된다.</p><h1 id="협력이-설계를-위한-문맥을-결정한다"><a href="#협력이-설계를-위한-문맥을-결정한다" class="headerlink" title="협력이 설계를 위한 문맥을 결정한다."></a>협력이 설계를 위한 문맥을 결정한다.</h1><ul><li>애플리케이션 안에서 객체가 필요하다면 그 이유는 단 하나여야 한다. (그 객체가 어떠한 협력에 참여하고 있기 때문)</li><li>객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 가지고 있기 때문이다.</li><li>객체는 행동(action)과 상태(state)로 구성된다.<ul><li>행동(action)은 협력 안에서 객체가 처리할 메세지 </li><li>상태(state)는 객체가 행동하는데 필요한 정보</li></ul></li><li>협력은 객체를 설계하는데 필요한 일종의 context를 제공한다.</li></ul><h1 id="책임"><a href="#책임" class="headerlink" title="책임"></a>책임</h1><p>책임이란, 협력에 참여하기 위해 객체 수행하는 행동(action)이라 부른다.<br>책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합으로 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장이다.<br>즉, 객체의 책임은 <strong>‘무엇을 알고 있는가’</strong>, <strong>‘무엇을 할 수 있는가’</strong> 로 구성된다.  </p><p><strong>하는 것</strong></p><ul><li>객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것</li><li>다른 객체의 행동을 시작시키는 것 (메세지를 전송하는 것)</li><li>다른 객체의 활동을 제어하고 조절하는 것</li></ul><p><strong>아는 것</strong></p><ul><li>사적인 정보에 관해 아는 것</li><li>관련된 객체에 관해 아는 것 (의존성)</li><li>자신이 유도하거나 계산할 수 있는 것에 대해 아는 것</li></ul><p>책임은 객체지향 설계의 핵심이다.<br><strong>객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것</strong><br>사실 협력이 중요한 이유는 객체에게 할당할 책임을 결정할 수 있는 문맥을 제공하기 때문이다.</p><h1 id="책임-주도-설계"><a href="#책임-주도-설계" class="headerlink" title="책임 주도 설계"></a>책임 주도 설계</h1><p>협력을 설계하기 위해서는 책임에 초점을 맞춰야 한다.<br>어떤 책임을 선택하느냐가 전체적인 설계의 방향과 흐름을 결정하기 때문이다.<br>이처럼 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을<br><strong>책임 주도 설계(Responsibility-Driven Design, RDD)</strong> 라고 부른다</p><h2 id="책임-주도-설계-방법"><a href="#책임-주도-설계-방법" class="headerlink" title="책임 주도 설계 방법"></a>책임 주도 설계 방법</h2><ol><li>시스템이 사용자에게 제공해야 하는 기능인 시스템의 책임을 판단한다. <ul><li>sms 전송요청 받은 요청을 sms로 보낼 수 있다.</li></ul></li><li>시스템 책임을 더 작은 책임으로 분할한다.<ul><li>sms 요청을 가공한다.</li><li>가공된 sms 요청을 벤더사로 전송한다.</li></ul></li><li>분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.<ul><li>sms 요청을 가공한다. -&gt; MessageTransformer</li><li>가공된 sms 요청을 벤더사로 전송한다. -&gt; MessageVenderSender</li></ul></li><li>객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.<ul><li>sms 요청을 Template 기반으로 변경한다. -&gt; TemplateMessageTransformer</li><li>발신번호가 예전 번호인 경우 신규 발신번호로 변경한다. -&gt; LegacySendNumberExchanger</li></ul></li><li>해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.</li></ol><p>예시</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmsSendRequest</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> sendNo: String,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> recipientNo: String,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> templateId: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MessageTransformer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(smsSendRequest: <span class="type">SmsSendRequest</span>)</span></span>: VendorMessageSendRequest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateMessageTransformer</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> templateLoader: TemplateLoader</span><br><span class="line">): MessageTransformer() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(smsSendRequest: <span class="type">SmsSendRequest</span>)</span></span>: VendorMessageSendRequest &#123;</span><br><span class="line">    <span class="keyword">val</span> template = templateLoader.findByTemplateId(templateId)</span><br><span class="line">    <span class="keyword">return</span> VendorMessageSendRequest(</span><br><span class="line">      sendNo = smsSendRequest.sendNo,</span><br><span class="line">      recipientNo = smsSendRequest.reciepientNo,</span><br><span class="line">      title = template.title,</span><br><span class="line">      contents = template.contents</span><br><span class="line">    )  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmsSendProcessor</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> messageTransformer: MessageTransformer</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> legacySendNumberExchanger: LegacySendNumberExchanger</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> messageVenderSender: MessageVenderSender</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">sendSms</span><span class="params">(smsSendRequest: <span class="type">SmsSendRequest</span>)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    legacySendNumberExchanger.exchange(smsSendRequest)</span><br><span class="line">    <span class="keyword">val</span> vendorMessageSendRequest = messageTransformer.transform(smsSendRequest)</span><br><span class="line">    </span><br><span class="line">    messageVenderSender.sendTo(vendorMessageSendRequest)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="메세지가-객체를-결정한다"><a href="#메세지가-객체를-결정한다" class="headerlink" title="메세지가 객체를 결정한다."></a>메세지가 객체를 결정한다.</h2><p>객체에게 책임을 할당하는 데 필요한 메세지를 먼저 식별하고 메세지를 처리할 객체를 나중에 선택하는 것이 중요하다</p><p>이유는 2가지가 있다.</p><ol><li>객체가 최소한의 인터페이스를 가질 수 있게 된다.<ul><li>필요한 메세지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않게 된다.</li><li>객체는 꼭 필요한 퍼블릭 인터페이스만 가질 수 있다.</li></ul></li><li>객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.<ul><li>객체의 인터페이스는 무엇을 하는지?는 표시해야하지만 어떻게 하는지는 노출하면 안된다.</li><li>메세지는 외부의 객체가 요청하는 무언가를 의미하기 때문에<br>메세지를 먼저 식별하면 무엇을 수행할지에 초점을 맞추는 인터페이스를 얻을 수 있다.</li></ul></li></ol><h2 id="행동이-상태를-결정한다"><a href="#행동이-상태를-결정한다" class="headerlink" title="행동이 상태를 결정한다."></a>행동이 상태를 결정한다.</h2><p>객체가 존재하는 이유는 협력에 참여하기 위해서다.<br>따라서 객체는 협력에 필요한 행동을 제공해야 한다.<br>그렇기 때문에 객체는 상태보다는 행동에 초점을 맞춰야 한다.</p><p>적절한 객체를 만들었는지에 대한 기준은 얼마나 적절한 책임을 할당했느냐에 달려 있고, 책임이 얼마나 적절한지는 협력에 얼마나 적절한가에 달려있다.</p><p>객체지향 패러다임에서 <strong>가장 쉽게 하는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것이다.</strong><br>객체의 행동을 고려하지 않고 일단 필드부터 정의하고 보는 행동이다.<br>이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다.</p><p>상태란, 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료에 지나지 않는다.</p><h1 id="역할"><a href="#역할" class="headerlink" title="역할"></a>역할</h1><p>객체는 협력이라는 주어진 문맥 안에서 특정한 목적을 갖게 된다.<br>객체의 목적은 협력 안에서 객체가 맡게 되는 책임의 집합으로 표시된다.<br>이처럼 <strong>객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합</strong>을 <strong>역할</strong>이라고 부른다.</p><p>역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문이다. (like 인터페이스)<br>인터페이스와 같이 협력 안에서 객체를 바꿔낄 수 있는 슬롯의 역할을 한다.</p><p>따라서 책임과 역할을 중심으로 협력을 바라보는 것이 바로 변경과 확장이 용이한 유연한 설계로 나아가는 첫걸음이다.</p><h2 id="객체-vs-역할"><a href="#객체-vs-역할" class="headerlink" title="객체 vs 역할"></a>객체 vs 역할</h2><p>만약 오직 한 종류의 객체만 협력에 참여하는 상황이라면 역할이라는 개념을 추가하는 것이 과연 좋을까?<br>역할의 개념을 생략하고 바로 협력에 객체를 이용하는 것이 좋지 않을까?<br>(spring에서 하나의 service를 사용하는 과정에서 굳이 인터페이스를 만들어야 할까 말아야 할까와 같다)</p><p>레베카 워브스브록은 </p><blockquote><p>협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 필요가 있다면 그 후보는 역할이 되지만,<br>단지 한 종류의 객체만이 협력에 참여할 필요가 있다면 후보는 객체가 된다.</p></blockquote><p>(즉, 하나의 Service만 필요하다면 클래스 기반의 Service를 만들면 되고, 2개 이상의 Service가 필요하다면 인터페이스 기반의 Service를 만들면 된다.)</p><p><strong>만약 서비스 개발 초반에 역할과 객체를 구분하는 것이 애매하다면 일단 객체로 시작해보자</strong><br><strong>객체로 시작하게 되면 자연스럽게 반복되고 중복되는 코드가 등장하게 되고 그때 역할로 분리해 내면 된다.</strong></p><p>협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용이 가능해진다.<br>역할의 가장 큰 장점은 설계의 구성 요소를 추상화할 수 있다는 점이다.</p><h2 id="역할과-추상화"><a href="#역할과-추상화" class="headerlink" title="역할과 추상화"></a>역할과 추상화</h2><p>추상화는 2가지 장점이 있다.</p><ol><li>추상화 계층만을 이용하면 중요한 정책을 상위 수준에서 단순화 할 수 있다.<ul><li>역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화로 볼 수 있다.</li><li>협력이라는 관점에서는 세부적인 구현보다는 추상적인 책임에 집중하는게 유용하다.</li></ul></li><li>설계가 좀 더 유연해 진다.<ul><li>역할은 다양한 종류의 객체를 끼워 넣을 수 있는 슬롯이기 때문에 서로 대체가 가능하다</li><li>역할은 다양한 환경에서 다양한 객체들을 수용할 수 있게 해주기 때문에 협력에 유연하다</li></ul></li></ol><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - Chapter3. 역할, 책임, 협력</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter2. 객체지향 프로그래밍</title>
      <link href="/2020/05/10/object-chapter2/"/>
      <url>/2020/05/10/object-chapter2/</url>
      
        <content type="html"><![CDATA[<h1 id="객체지향을-설계하는-방법"><a href="#객체지향을-설계하는-방법" class="headerlink" title="객체지향을 설계하는 방법"></a>객체지향을 설계하는 방법</h1><ul><li>클래스가 아닌 실제 working하는 instance(객체)에 초점을 둔다.</li><li>클래스는 객체들의 특징을 추상화 한 것</li><li>클래스 -&gt; 객체가 아닌 객체들을 정의하고 객체들의 특징을 기반으로 클래스를 정의한다.</li><li>객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다.</li><li>객체는 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 구성원의 일원으로 봐야한다.<ul><li>객체를 협력하는 공동체의 일원으로 바라보게 되면 설계를 유연하고 확장 가능하게 만든다.</li></ul></li></ul><p>따라서 객체를 나열 -&gt; 타입으로 분류 -&gt; 클래스 작성 하는 순서를 따르는 것이 좋다.</p><h1 id="도메인-구조를-따르는-프로그램-구조"><a href="#도메인-구조를-따르는-프로그램-구조" class="headerlink" title="도메인 구조를 따르는 프로그램 구조"></a>도메인 구조를 따르는 프로그램 구조</h1><p>도메인이란? 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야<br>도메인 개념을 구현하기 위해 클래스를 사용<br>클래스 이름은 도메인 개념과 동일하거나 최대한 유사하게 짓는다.</p><h1 id="클래스를-설계할-때는-내부와-외부로-나눈다"><a href="#클래스를-설계할-때는-내부와-외부로-나눈다" class="headerlink" title="클래스를 설계할 때는 내부와 외부로 나눈다."></a>클래스를 설계할 때는 내부와 외부로 나눈다.</h1><ul><li>내부는 private, 외부에 공개할 것은 public으로 만든다.</li><li>경계의 명확성이 객체의 자율성을 보장한다.</li><li>클래스를 사용하는 입장에서는 public으로 공개된 인터페이스만 알면 된다. (내부의 구현에 대해서는 알 필요가 없다.)</li><li>클래스를 만들고 수정하는 입장에서는 private으로 된 부분은 클래스 외부에서 참조 하지 않으니 마음대로 구현을 변경해도 된다.</li><li>이러한 내&#x2F;외부의 경계를 잘 나눠야 하는 이유는 변경을 관리 하기 위해서이다.<ul><li>변경될 가능성이 있는 세부적인 구현 내용을 private 영역에 감춤으로써 변경으로 인한 혼란을 최소화 할 수 있다.</li></ul></li></ul><h1 id="객체는-상호-협력하는-존재들이다"><a href="#객체는-상호-협력하는-존재들이다" class="headerlink" title="객체는 상호 협력하는 존재들이다."></a>객체는 상호 협력하는 존재들이다.</h1><ul><li>객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청할 수 있다.</li><li>요청 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답한다.</li></ul><h2 id="객체의-협력"><a href="#객체의-협력" class="headerlink" title="객체의 협력"></a>객체의 협력</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> b: B</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.method() <span class="comment">// 의존성을 가지는 B 클래스의 method 라는 메세지를 전송할 수 있다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">()</span></span> &#123; </span><br><span class="line">    doAction() </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메세지를 전송(send a message) 하는 것 뿐이다.<br>(의역하자면 다른 객체가 가지고 있는 공개된 인터페이스의 method signature를 호출한다.)</li><li>메세지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메세지를 처리할 방법을 결정한다.<br> 수신된 메세지를 처리하기 위한 자신만의 방법을 메서드(method)라고 부른다.<br>(의역하자면 요청 받은 클래스의 인터페이스를 구현한 mehtod body 부분을 메서드라고 하는 것 같다.)</li><li>메세지와 메서드의 구분에서부터 다형성(polymorphism)의 개념이 출발한다.<br>(메세지 : method signature, 메서드 : 실제 method 구현부)</li></ul><h1 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h1><ul><li>상속은 객체 지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.</li><li>자식 클래스는 부모 클래스가 수신할 수 있는 모든 메세지를 수신할 수 있다.<br>그렇기 때문에 자식 클래스는 부모 클래스와 동일한 Type으로 볼 수 있다.</li><li>상속은 부모 클래스의 코드를 기반으로 전혀 수정하지 않거나 일부분을 추가&#x2F;수정 하여 새로운 클래스를 만들 수 있다. (코드의 재사용)<ul><li>부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 차이에 의한 프로그래밍 (programming by difference)라 한다.</li></ul></li><li>자식 클래스가 부모 클래스를 대신하는 것을 업 캐스팅(up casting)이라 한다.</li></ul><h1 id="상속의-단점"><a href="#상속의-단점" class="headerlink" title="상속의 단점"></a>상속의 단점</h1><ul><li>상속은 캡슐화를 위반한다.<ul><li>상속을 이용하기 위해선 부모 클래스의 내부 구조를 잘 알고 있어야 한다.</li><li>부모 클래스의 구현이 자식 클래스에 노출 되기 때문에 캡슐화가 약화된다.+</li><li>캡슐화는 자식 클래스와 부모 클래스의 강결합을 만들어 부모 클래스가 변경되야 하는 경우 자식 클래스도 함께 변경되게 된다.</li><li>상속을 과도하게 사용하면 코드를 변경하기 어렵게 된다.</li></ul></li><li>설계를 유연하게 하지 못한다.<ul><li>부모 클래스와 자식 클래스의 관계를 컴파일 타임에 결정한다.</li></ul></li></ul><h1 id="합성-composition"><a href="#합성-composition" class="headerlink" title="합성 (composition)"></a>합성 (composition)</h1><ul><li>인터페이스에 정의된 메세지를 통해서만 코드를 재사용하는 방법을 <strong>합성</strong>이라 한다.</li><li>인터페이스에 정의된 메세지를 통해서만 재사용이 가능하기 때문에 구현을 캡슐화 하기 용이하다</li><li>의존하는 인스턴스를 교체하는 것이 비교적 쉬워 설계를 유연하게 만든다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeDiscountPolicy</span><span class="params">(DiscountPolicy discountPolicy)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Movie</span> <span class="variable">avartar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="keyword">new</span> <span class="title class_">AmountDiscount</span>());</span><br><span class="line">avartar.changeDiscountPolicy(<span class="keyword">new</span> <span class="title class_">PercentDiscountPolicy</span>());</span><br></pre></td></tr></table></figure></li></ul><h1 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h1><ul><li>동일한 메세지를 수신할 수 있지만, 어떤 메서드가 실행될 지는 수신하는 클래스에 따라 달라진다.<br>(인터페이스의 메서드를 호출할 수 있지만 메서드의 실행은 인터페이스를 구현한 클래스에 따라 달라진다.)</li><li>실행되는 메서드는 Runtime에 결정된다.  <ul><li>이를 Lazy Binding 또는 Dynamic Binding이라 한다.</li></ul></li></ul><h1 id="다형성의-Trade-off"><a href="#다형성의-Trade-off" class="headerlink" title="다형성의 Trade off"></a>다형성의 Trade off</h1><ul><li>다형성을 사용하게 되면 코드의 의존성과 Runtime의 의존성이 서로 다를 수 있다.  <ul><li>어떤 클래스를 주입하느냐에 따라 의존성이 달라진다.</li><li>하지만 코드 상으로는 인터페이스 &#x2F; 추상클래스에 대한 의존성만 가지고 있다.</li></ul></li><li>확장 가능한 객체 지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다.</li><li>코드의 의존성과 실행시점의 의존성이 다르면 코드를 이해하기 어렵고 디버깅을 어렵게 만든다.</li></ul><h1 id="추상화의-힘"><a href="#추상화의-힘" class="headerlink" title="추상화의 힘"></a>추상화의 힘</h1><ul><li>추상화 계층만 따로 떼어 놓고 보면 요구사항의 정책을 높은 수준에서 서술할 수 있다.<br>(뒤에 자세한 구현부는 모르겠지만 전체적인 틀을 잡기 편하다)</li><li>추상화를 이용하면 설계가 조금 더 유연해 진다.</li><li>Runtime에 주입되는 코드는 추상화를 이용해서 정의한 상위의 흐름을 따라가게 된다.</li><li>디자인 패턴(design pattern)이나 프레임워크(framework) 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 매커니즘을 활용하고 있다.</li><li>추상화를 이용하여 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.</li><li>유연성이 필요한 곳에 추상화를 사용하라</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - 객체지향 프로그래밍</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects Study - Chapter1. 객체, 설계</title>
      <link href="/2020/05/09/object-chapter1/"/>
      <url>/2020/05/09/object-chapter1/</url>
      
        <content type="html"><![CDATA[<h1 id="소프트웨어의-목적"><a href="#소프트웨어의-목적" class="headerlink" title="소프트웨어의 목적"></a>소프트웨어의 목적</h1><p>Robert C. Martin은 <strong>클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천방법</strong>에서 소프트웨어 모듈이 가져야 하는 세 가지 기능에 관해 설명한다.<br>(모듈이란, 크기와 상관 없이 클래스나 패키지, 라이브러리와 같은 프로그램을 구성하는 임의의 요소를 의미한다.)</p><ol><li>실행 중에 오류 없이 제대로 동작해야 한다.</li><li>소프트웨어는 변경을 위해 존재한다.  <ul><li>대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다.</li><li>변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 한다.</li></ul></li><li>코드를 읽는 사람과 의사소통 해야 한다.<ul><li>모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다.</li><li>읽는 사람과 소통할 수 없는 모듈은 개선해야 한다.</li></ul></li></ol><h1 id="읽기-어려운-코드는-무엇일까"><a href="#읽기-어려운-코드는-무엇일까" class="headerlink" title="읽기 어려운 코드는 무엇일까?"></a>읽기 어려운 코드는 무엇일까?</h1><p>하나의 Class 또는 Method에서 너무 많은 항목을 다룬다.<br>다시 말해 Class, Method에서 하나 이상의 책임을 가지고 동작하는 코드이기 때문에<br>코드를 읽는 사람이 집중해야 할 부분이 많다.</p><p>코드를 작성하는 사람뿐만 아니라 코드를 읽고 이해해야 하는 사람에게 모두 부담이 된다.</p><h1 id="의존성-Dependency-이란"><a href="#의존성-Dependency-이란" class="headerlink" title="의존성(Dependency)이란?"></a>의존성(Dependency)이란?</h1><p>의존성이란 하나의 객체 안에서 다른 객체에 대한 코드를 호출하는 것이다.<br>의존성은 변경이란 문제와 직결된다. (의존성을 갖는 코드를 변경하게 되면 호출하는 객체에도 수정이 필요하기 때문)<br>객체 사이의 의존성이 강한 경우를 가리켜 <strong>결합도(Coupling)</strong> 가 높다고 말한다.</p><p>좋은 소프트웨어를 설계하기 위한 목표는 결합도가 낮은 코드를 설계하는 것이다.</p><h1 id="결합도는-낮추는-방법은-무엇인가"><a href="#결합도는-낮추는-방법은-무엇인가" class="headerlink" title="결합도는 낮추는 방법은 무엇인가?"></a>결합도는 낮추는 방법은 무엇인가?</h1><h2 id="객체에게-자율성을-부여하자"><a href="#객체에게-자율성을-부여하자" class="headerlink" title="객체에게 자율성을 부여하자"></a>객체에게 자율성을 부여하자</h2><p>자율성이란 객체 내부의 데이터를 변경하는 것을 객체 스스로에게 위임하는 행위를 말한다.<br>객체 내의 데이터를 다른 객체가 변경하는 것을 막는 것만으로도 결합도를 낮출 수 있다.</p><p>이 처럼 객체 스스로 자기 자신의 data를 제어하는 코드를 <strong>응집도(cohesion)</strong> 가 높은 코드라고 말한다.  </p><ul><li>객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임진다.</li><li>객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 한다.</li></ul><h2 id="객체를-캡슐화-한다"><a href="#객체를-캡슐화-한다" class="headerlink" title="객체를 캡슐화 한다"></a>객체를 캡슐화 한다</h2><p>개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 <strong>캡슐화(encapsulation)</strong> 라 한다.<br>캡슐화의 목적은 <strong>변경하기 쉬운 객체</strong> 를 만들기 위함이다.  </p><ul><li>객체 내부의 접근을 제한한다.</li><li>다른 객체에서 객체 내부의 데이터를 접근하거나 수정하지 못하도록 막으면,<br>객체 내에서 일어하는 일만 수정하면 되기 때문에 하나의 Class 파일만 변경할 수 있어 변경에 용이하다.</li></ul><h2 id="의존관계는-Interface에만-의존한다"><a href="#의존관계는-Interface에만-의존한다" class="headerlink" title="의존관계는 Interface에만 의존한다"></a>의존관계는 Interface에만 의존한다</h2><p>객체를 Interface와 구현부로 나누고 Interface만 공개한다.<br>객체간의 의존성이 필요한 부분은 Interface에서 제공하는 메서드를 가지고 코드를 작성하고 실제 구현부는<br>각각의 객체에 위임한다.</p><h1 id="절차-지향-vs-객체-지향"><a href="#절차-지향-vs-객체-지향" class="headerlink" title="절차 지향 vs 객체 지향"></a>절차 지향 vs 객체 지향</h1><p>절차 지향 프로그래밍(Procedural Programming)이란, Process (객체의 행위)와 데이터가 별도의 모듈에 위치한다.<br>객체 내의 데이터를 변경하는 주체가 모듈 내에서 변경하는 것이 아닌 다른 모듈에서 변경 시킨다.  </p><p>객체 지향 프로그래밍 (Object Oriented Programming)이란, Process(객체의 행위)와 데이터가 같은 모듈 내에 위치 한다.</p><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>변경하기 쉬운 설계는 한번에 하나만을 변경 할 수 있는 설계이다.  <ul><li>설계를 어렵게 만드는 것은 의존성이다.</li><li>하나의 변경으로 인해 의존성을 갖는 여러 코드를 변경하는 것은 좋지 못하다.</li></ul></li><li>훌륭한 객체 지향 설계는 캡슐화를 이용해 의존성을 적절히 관리하여 의존성을 최대한 낮추는 것이다.  <ul><li>객체 외부의 파급력이 없어서 변경이 수월하다.</li><li>캡슐화를 하면 객체의 자율성↑, 응집도↑, 결합도↓</li></ul></li><li>객체는 생물 처럼 스스로 생각하고 행동하도록 의인화하며 설계하면 도움이 된다.<ul><li>객체에 대한 적절한 책임을 위임한다.</li><li>기능은 최대한 객체에 위임한다.</li></ul></li><li>좋은 설계란, 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용 할 수 있어야 한다.<ul><li>개발을 시작하는 시점에 요구사항 분석이 100% 이루어지는 것은 불가능에 가깝다.</li><li>코드는 변화하고 살아 숨쉰다. 변화에 유연하게 대처할 수 있는 코드를 작성할 수 있는 설계를 해야 한다.</li></ul></li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Objects(코드로 이해하는 객체지향 설계) - 객체, 설계</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Object-Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HikariCP Maximum Pool Size 설정 시, 고려해야할 부분</title>
      <link href="/2020/01/27/2020-01-27-hikaricp-maximum-pool-size-tuning/"/>
      <url>/2020/01/27/2020-01-27-hikaricp-maximum-pool-size-tuning/</url>
      
        <content type="html"><![CDATA[<h1 id="이-글의-예상-독자"><a href="#이-글의-예상-독자" class="headerlink" title="이 글의 예상 독자"></a>이 글의 예상 독자</h1><p>아래와 같은 에러의 원인을 찾아헤멘 개발자</p><ul><li>o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 0, SQLState: null</li><li>o.h.engine.jdbc.spi.SqlExceptionHelper   : hikari-pool-1 - Connection is not available, request timed out after 30000ms.</li><li>unable to obtain isolated JDBC connection; nested exception is org.hibernate.exception.JDBCConnectionException: unable to obtain isolated JDBC connection</li><li>Could not open JPA EntityManager for transaction; nested exception is org.hibernate.exception.JDBCConnectionException: Unable to acquire JDBC Connection</li></ul><p>또는 HikariCP maximum pool size 설정할 때, 고려할게 있나?  그냥 대충 많이 만들어 두면 되는거 아니었어? 라고 하시는 개발자</p><h1 id="장애를-맞았습니다"><a href="#장애를-맞았습니다" class="headerlink" title="장애를 맞았습니다."></a>장애를 맞았습니다.</h1><p><img src="./db-insert-flow.png" alt="db-insert-flow"></p><p>사내에서 사용하는 시스템의 간략한 모식도 입니다.<br>Message Queue를 통해 Data를 application에서 consume하여 consume 한 데이터를 DB에 insert하고 있습니다.</p><p><img src="./db-write-lag.png" alt="db-write-lag"></p><p>시스템 운영중 Message Queue에 많은 데이터가 한번에 유입되었습니다. 그로 인해</p><ol><li>DB에 insert하는 과정에서 쓰기지연이 발생 하였습니다. </li><li>쓰기 지연이 발생하여, Message Queue의 lag이 증가하여 많은 량의 Data를 처리하지 못하고 밀리는 상황이 되었습니다.</li></ol><p>원인은 분석하니, Message Queue Consumer Thread 갯수와 HikariCP maximum pool size간의 상관관계가 있음을 발견하였고,<br>그 과정에서 <strong>HikariCP의 Pool Size로 인한 Thread dead lock이 발생하여 Insert Query가 실패하고 있음을 알게 되었습니다.</strong><br>이번 장애를 통해 알게 된 <strong>Dead lock을 피할 수 있는 HikariCP maximum pool size 갯수</strong>를 설정하는 방법에 대해 공유하고자 합니다.</p><h1 id="HikariCP에서는-Connection을-어떻게-관리하나"><a href="#HikariCP에서는-Connection을-어떻게-관리하나" class="headerlink" title="HikariCP에서는 Connection을 어떻게 관리하나?"></a>HikariCP에서는 Connection을 어떻게 관리하나?</h1><p>Springboot 2.x가 출범하면서 HikariCP를 default JDBC Connection Pool로 사용하고 있고,  성능이 좋고 빠르기로 이미 검증된 Connection Pool입니다.<br>이번 문제를 해결하면서 하나의 스레드가 Hikari Pool에서 커넥션을 얻고 <strong>(getConnection)</strong>, 커넥션을 반납 <strong>(close)</strong> 하는 과정을 살펴보았습니다.</p><p>아래 내용을 보시기 전에…</p><ul><li>HikariPool에서는 Connection 객체를 한번 wrapping한  PoolEntry라는 Type으로 내부적으로 Connection을 관리합니다.<br>아래 글에서는 이해를 편하게 하도록 Connection이라는 용어로 언급하도록 하겠습니다.</li><li><strong>1인칭 Thread 시점</strong>을 통해 생각해 보았습니다.</li></ul><h2 id="하나의-Query가-실행되는-과정"><a href="#하나의-Query가-실행되는-과정" class="headerlink" title="하나의 Query가 실행되는 과정"></a>하나의 Query가 실행되는 과정</h2><p>내부적인 코드는 더 잘 구성이 되어있지만, 간략한 코드로 표현하자면 아래와 같을 것 입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  connection = hikariDataSource.getConnection(); </span><br><span class="line">  preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">  preparedStatement.executeQuery();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(preparedStatement != <span class="literal">null</span>) &#123;</span><br><span class="line">    preparedStatement.close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(connection != <span class="literal">null</span>) &#123;</span><br><span class="line">    connection.close(); <span class="comment">// this returns the connection to the pool</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>hikariDataSource.getConnection()을 통해 hikariPool에서 Connection을 하나 얻습니다.</li><li>execute()를 통해 쿼리를 실행하고 connection.close()을 통해 hikari pool에 connection을 반납합니다.</li></ol><p>getConnection(), close()를 조금 더 내려가서 HikariPool에서의 처리를 자세하게 살펴보겠습니다.</p><h2 id="Hikari님-Connection-하나만-주세여"><a href="#Hikari님-Connection-하나만-주세여" class="headerlink" title="Hikari님! Connection 하나만 주세여"></a>Hikari님! Connection 하나만 주세여</h2><p>Hikari Pool에서 getConnection 로직은 3단계를 통해 Connection 객체를 얻을 수 있게 되어있습니다.<br><strong>(HikariCP에서 얼마나 성능을 올리기 위해 노력했는지 코드로 보입니다.)</strong><br>Hikari CP에서는 <strong>ConcurrentBag</strong>이라는 구조체를 이용해 Connection을 관리하고 있습니다.<br><strong>HikariPool.getConnection() -&gt; concurrentBag.borrow()</strong> 라는 메서드를 통해 사용가능한 Connection을 리턴하도록 되어있습니다.</p><p>1인칭 Thread 시점으로 Hikari Pool에게 Connection을 하나 요청해 보았습니다.<br><em><strong>(개발은 유치하게 이해할수록 이해도 잘되고 기억에 잘 남는것 같아서.. 각본을 준비해봤습니다.)</strong></em></p><p><em><strong>[Thread-1님]</strong> 안녕하세요 Hikari님! Connection 하나만 주세요~</em><br><strong>[Hikari님]</strong> 안녕하세요 Thread-1님! 저희 pool에서는 Connection을 주는 규칙이 있답니다. 확인해볼게요~<br><strong>[Hikari님]</strong> 이전에 Thread-1님이 저희 pool에 방문한 내역 먼저 살펴볼게요!<br><strong>[Hikari님]</strong> 오! 이전에 방문한 내역이 있으시네요~ 근데 그때 사용한 Connection은 다른 Thread 님이 사용 중(IN_USE) 이시네요~<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;다른 Thread님이 안 쓰셨으면 빠르게 이 Connection 먼저 드렸을 텐데 아쉽네요ㅠㅠ<br><em><strong>[Thread-1님]</strong> 괜찮아요! Hikari님 다른 Connection 주세요~</em><br><strong>[Hikari님]</strong> Pool 전체에서 사용 가능한(idle) Connection이 있는지 찾아볼께요~<br><strong>[Hikari님]</strong> (Loop 돌면서 찾는중…)<br><strong>[Hikari님]</strong> Thread-1님 지금 전체 Connection이 다 사용중이에요! ㅠㅠ<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;저기 handoffQueue 앞에 가서 좀 기다리셔야 할 것 같아요 ㅜㅜ<br><em><strong>[Thread-1님]</strong> 네 괜찮아요! (안 괜찮음) 저기서 30초만 기다려보고 없으면 Exception내면 되죠^^<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <strong>(깨알 Tip. HikariCP default Connection timeout은 30초 입니다.)</strong></em><br><strong>[Hikari님]</strong> 네 죄송합니다 Thread-1님. 다음에 또 다시 방문해주세요~<br><em><strong>[Thread-1님]</strong> (handoffQueue에서 다른 Thread가 쓰고 반납한 Connection을 얻었다!)</em></p><p>혹시 잘 이해가 가셨을까요..?<br>이해가 아직 안되신 분들을 위한 Flow chart를 준비해보았습니다.</p><p><img src="./getConnection-flow.png" alt="getConnection-flow"></p><p>코드 레벨로 확인해보시려면 -&gt; <a href="https://github.com/brettwooldridge/HikariCP/blob/dev/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java#L126">ConcurrentBag.borrow()</a></p><h2 id="Hikari님-Connection-다-썼어요"><a href="#Hikari님-Connection-다-썼어요" class="headerlink" title="Hikari님! Connection 다 썼어요"></a>Hikari님! Connection 다 썼어요</h2><p>HikariCP에서 얻은 Connection은 <code>(ProxyConnection) Connection.close()</code>를 하게 되면 HikariPool에 반납이 됩니다.<br>(HikariPool에서 얻은 Connection은 ProxyConnection 타입입니다.)<br>정상적인 transaction이 마무리 되거나, Rollback이 호출 되어도 <code>connection.close()</code>가 호출되어 Connection을 반납합니다.<br>getConnection과 마찬가지로 <code>connection.close()</code> 시, <code>concurrentBag.requite()</code>이 실행되며 Connection이 반납됩니다.</p><p>위와 같이 1인칭 Thread 시점으로 각본을 짜보겠습니다. </p><p><em><strong>[Thread-1님]</strong> Transaction내의 쿼리를 모두 수행하고 Commit이 되었어 이제 Connection을 반납해볼까?</em><br><em><strong>[Thread-1님]</strong> Thread-1님이 (ProxyConnection) connection.close()을 실행하였습니다.</em><br><strong>[Hikari님]</strong> 안녕하세요 Thread-1님! Connection 이용은 만족스러우셨나요? Connection 반납 절차 도와드리겠습니다.<br><strong>[Hikari님]</strong> 일단 PoolEntry의 상태를 STATE_NOT_IN_USE로 바꿀게요. <strong>(여기서 idle connection이 됩니다.)</strong><br><strong>[Hikari님]</strong> handOffQueue에서 Connection을 받길 원하는 다른 Thread님이 있나봐요~<br><strong>[Hikari님]</strong> (handOffQueue에 Connection 삽입)<br><strong>[Hikari님]</strong> Thread-1님 고생하셨습니다~ 이번에 사용한 Connection 정보 등록해 드릴께요<del>! 다음에 빠르게 이용하실 수 있으실거에요<br>***[Thread-1님]** 감사합니다! Hikari님 또 Connection 받으러 올께요</del>*  </p><p>혹시 잘 이해가 가셨을까요..?<br>이해가 아직 안되신 분들을 위한 Flow chart를 준비해보았습니다.</p><p><img src="./close-flow.png" alt="close-flow"></p><p>코드 레벨로 확인해보시려면 -&gt; <a href="https://github.com/brettwooldridge/HikariCP/blob/dev/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java#L181">ConcurrentBag.requite()</a></p><h1 id="HikariCP에서-Dead-lock이-발생하는-Case"><a href="#HikariCP에서-Dead-lock이-발생하는-Case" class="headerlink" title="HikariCP에서 Dead lock이 발생하는 Case"></a>HikariCP에서 Dead lock이 발생하는 Case</h1><p>consumer thread 갯수에 따른 충분한 HikariCP의 maximum pool size를 설정하지 못해 Dead lock이 발생하여 이번 장애로 이어지게 되었습니다.<br>도데체 무슨 관계가 있다고 Dead lock이 발생했을까요?<br>간단한 예시를 통해 알아보도록 하겠습니다.</p><p>Thread count와 maximum pool size의 조건은 아래와 같습니다.</p><ul><li>Thread Count: 1개</li><li>HikariCP MaximumPoolSize: 1개</li><li>하나의 트랜잭션에서 요구되는 Connection 갯수: <strong>2개!!</strong></li></ul><p>조금은 감이 오시나요?<br>그림으로 살펴보도록 하겠습니다.</p><p><img src="./dead-lock-case.png" alt="dead-lock-case"></p><ol><li>하나의 Thread가 Repository.save(entity) 라는 insert query를 실행하기 위해 Transaction을 구성합니다.</li><li>Transaction용 Connection을 하나 가져옵니다. <strong>(PoolStats : total&#x3D;1, active&#x3D;1, idle&#x3D;0, waiting&#x3D;0)</strong></li><li>Transaction을 시작하였고 Repository.save를 하기 위해 Connection이 하나 더 필요하다고 <strong>가정</strong>해보겠습니다.</li><li>Thread-1은 Hikari Pool에 Connection을 요청합니다.<ol><li>위의 3단계 절차대로, 현재 자기 Thread의 방문내역을 살펴봅니다.<br>아직 방문내역이 등록된 게 없습니다.</li><li>전체 Hikari Pool에서 idle상태의 Connection을 스캔합니다.<br>Pool Size는 1개이고 1개 있던 Connection은 Thread-1에서 이미 사용중입니다.</li><li>마지막으로 handOffQueue에서 누군가 반납한 Connection이 있길 기대하며 30초 동안 기다립니다.<br>하나 있던 Connection을 자기 자신이 사용하고 있기 때문에 자기 자신이 반납하지 않는 이상 사용할 Connection이 없습니다.<br><strong>(PoolStats : total&#x3D;1, active&#x3D;1, idle&#x3D;0, waiting&#x3D;1)</strong></li><li>결국 30초가 지나고 Connection Timeout이 발생하고<br><code>hikari-pool-1 - Connection is not available, request timed out after 30000ms.</code> 와 같은 에러가 발생</li></ol></li><li>Transaction에 대한 evictMark가 찍히고 트랜잭션이 롤백 됩니다. </li><li>롤백 됨과 동시에 Transaction용 Connection은 다시 Pool에 반납됩니다. <strong>(PoolStats : total&#x3D;1, active&#x3D;0, idle&#x3D;0, waiting&#x3D;0)</strong></li></ol><p>이렇게 Thread내에서 하나의 Task에 수행하는데 필요한 Connection갯수가 모자라게 되면<br><strong>Dead Lock 상태에 빠져 Insert Query를 실행할 수 없게 됩니다.</strong></p><h1 id="위에는-예시이고-실제-상황은-뭐였어요"><a href="#위에는-예시이고-실제-상황은-뭐였어요" class="headerlink" title="위에는 예시이고, 실제 상황은 뭐였어요?"></a>위에는 예시이고, 실제 상황은 뭐였어요?</h1><p>제가 장애를 맞았던 실제 환경에 대해 설명해드리겠습니다.</p><p>장애 환경에 대한 Thread count와 maximum pool size의 조건은 아래와 같습니다.</p><ul><li><p>CPU Core : 4개</p></li><li><p>Thread Count: 16개</p></li><li><p>HikariCP MaximumPoolSize: 10개</p></li><li><p>하나의 트랜잭션에서 요구되는 Connection 갯수: <strong>2개</strong><br>(처음엔 1개일거라 생각했지만, getConnection에 대한 디버깅을 해보니 2번의 getConnection 요청이 발생했습니다.)</p></li></ul><p>실제 구현부의 간단한 코드입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> String contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Message <span class="title function_">save</span><span class="params">(<span class="keyword">final</span> Message message)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> repository.save(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>혹시 이 코드에서 왜 Connection이 2개나 필요한지 짐작이 되시나요?<br>코드만 보면 하나의 Connection으로 Insert가 잘 될 것 같습니다.<br>여태까지 그런줄 알았고 이번 장애가 아니었다면 몰랐을 것이었습니다.</p><h2 id="GeneratedValue-strategy-x3D-GenerationType-AUTO"><a href="#GeneratedValue-strategy-x3D-GenerationType-AUTO" class="headerlink" title="@GeneratedValue(strategy &#x3D; GenerationType.AUTO)"></a>@GeneratedValue(strategy &#x3D; GenerationType.AUTO)</h2><p>이 사건의 범인은 이 코드로 부터 시작됩니다.<br>GeneratedValue(strategy &#x3D; GenerationType.AUTO)인 경우에는 JPA 구현체가 자동으로 ID값 생성전략을 결정합니다.<br>사내에서 사용하는 RDB는 MySQL을 사용하고 있습니다.<br>ID의 Type이 long 타입이고, <code>hibernate.id_new_generator_mappings</code> 값이<code>true</code> (default true)이기 때문에<br>ID 필드에 대한 Generator는 내부적으로 SequenceStyleGenerator를 사용하게 됩니다.<br>하지만 MySQL에서는 Oracle처럼 Sequence라는게 존재하지 않기 때문에 <code>hibernate_sequence</code>라는 테이블을 생성하고, 테이블에 단일 로우로 된 id값을 계속 update하며 sequence처럼 관리합니다.  </p><p>getConnection에 대한 call tree를 역주행하면서 hibernate 내부 코드까지 보게 되었습니다.<br>call tree에 대한 대략적인 단계는 아래와 같습니다.</p><ol><li>repository.save(entity): 내부적으로 SimpleJpaRepository.save가 호출됩니다.</li><li>DefaultPersistEventListener에 의해 saveWithGeneratedId가 호출됩니다.</li><li>saveWithGeneratedId가 실행되며, Entity의 Id값을 생성할 때 SequenceStyleGenerator를 이용하여 생성합니다.</li><li>SequenceStyleGenerator.generate 코드에서 databaseStructure.buildCallback()이 실행되며, TableStructure.buildCallBack()이 실행됩니다<br>(이 코드에서 hibernate_sequence에 대한 조회, update가 이루어집니다.)</li><li>hibernate_sequence를 조회, update를 하는데에 있어서 별도의 Transaction으로 동작하게 됩니다.<br>  <code>select next_val as id_val from hibernate_sequence for update</code> 쿼리를 실행하게 되고, 트랜잭션이 끝나기 전까지 Table Lock이 걸리게 됩니다.<br>(만약 같은 Transaction 내에서 동작했다면은 hibernate_sequence table에 대한 Table Lock이 동작해 다른 스레드에서 id값을 생성하지 못할 것입니다.)</li><li><strong>별도의 트랜잭션으로 동작하게 되면서 새로운 Connection을 하나 받아오게 됩니다</strong> (여기서 2번째 connection을 받아옵니다.)</li></ol><p>위의 call tree에 대한 코드 입니다.</p><p><img src="./save.png" alt="save"></p><p><img src="./AbstractSaveEventListener.saveWithGeneratedId.png" alt="AbstractSaveEventListener.saveWithGeneratedId"></p><p><img src="./id_generator.png" alt="id_generator"></p><p><img src="./execute_hibernate_sequence.png" alt="execute_hibernate_sequence"></p><p><img src="./TableStructure.delegateWork.png" alt="TableStructure.delegateWork"></p><h2 id="하나의-Task에서-필요한-Connection은-2개인데-왜-Dead-Lock이-걸리죠"><a href="#하나의-Task에서-필요한-Connection은-2개인데-왜-Dead-Lock이-걸리죠" class="headerlink" title="하나의 Task에서 필요한 Connection은 2개인데 왜 Dead Lock이 걸리죠?"></a>하나의 Task에서 필요한 Connection은 2개인데 왜 Dead Lock이 걸리죠?</h2><p>부하가 크게 걸리지 않는 일반적인 상황에서는 문제가 없을 것입니다. 스레드 전체가 일을 하지 않을 것이기 때문입니다.<br>문제는 전체 스레드가 동시에 일을 하게 되는 부하 상황 시에 발생합니다.  </p><p><img src="./dead-lock-case2.png" alt="dead-lock-case2"></p><p>이런 식으로 16개의 스레드 중 10개의 스레드가 10개의 Connection을 모두 잡고 있으면 10개의 스레드 중 하나의 스레드에서<br>2번째 Connection에 대한 timeout이 발생하지 않으면 계속 30초씩 지연이 발생하게 됩니다.<br>하물며 idle Connection이 다시 발생한들 남은 6개의 Thread들 중 하나가 Connection을 가져가면 dead lock의 악순환의 고리에 빠지게 됩니다.<br>간혹 운이 좋게 하나의 스레드가 Connection 2개를 획득하여 트랜잭션이 성공하는 case도 있을 것 입니다.<br>(이런 경우 간헐적으로 동작하기 때문에 원인 파악이 매우 힘들어 집니다.)</p><h1 id="Dead-lock을-피하는-Maximum-pool-size는-어떻게-설정하나요"><a href="#Dead-lock을-피하는-Maximum-pool-size는-어떻게-설정하나요" class="headerlink" title="Dead lock을 피하는 Maximum pool size는 어떻게 설정하나요?"></a>Dead lock을 피하는 Maximum pool size는 어떻게 설정하나요?</h1><p>HikariCP의 Dead lock에 대한 case는 이미 HikariCP issue에 등록되어있다.<br>HikariCP에서는 Dead Lock을 피하기 위한 최적의 Maximum Pool Size를 방법을 제시하고 있다.  </p><p>공식은 아래와 같다.</p><blockquote><h3 id="pool-size-x3D-Tn-x-Cm-1-1"><a href="#pool-size-x3D-Tn-x-Cm-1-1" class="headerlink" title="pool size &#x3D; Tn x (Cm - 1) + 1"></a><em>pool size &#x3D; Tn x (Cm - 1) + 1</em></h3></blockquote><ul><li><em>Tn</em> : Thread의 최대 수</li><li><em>Cm</em>: 하나의 Task에서 필요한 Connection 갯수</li></ul><h2 id="실제로-맞는-공식인지-알아보자"><a href="#실제로-맞는-공식인지-알아보자" class="headerlink" title="실제로 맞는 공식인지 알아보자"></a>실제로 맞는 공식인지 알아보자</h2><ul><li>Thread Count : 8개</li><li>하나의 Task에 필요한 Connection 갯수: 2개</li><li>pool Size &#x3D; 8 x ( 2 - 1) + 1 &#x3D; 9개</li></ul><p><img src="./avoid-dead-lock.png" alt="avoid-dead-lock"></p><ul><li>thread 8개가 골고루 Connection을 하나씩 얻었고 7개의 스레드가 2번째 스레드를 기다리고 있다.  </li><li>이렇게 되면 스레드 2번의 2번째 Connection은 빠르게 hibernate_sequence만 조회, update하고 빠르게 반납되게 된다.  </li><li>이로 인해 다른 스레드에서도 Connection을 받을 수 있게 된다</li><li>thread 2번에서도 정상적으로 트랜잭션이 처리되게 된다. -&gt; connection이 반납된다.</li><li>위와 같은 pool size로 dead lock을 피할 수 있는 최소한의 pool size를 얻을 수 있게 되었다.</li></ul><h1 id="이-글을-쓰고나니-생기는-질문"><a href="#이-글을-쓰고나니-생기는-질문" class="headerlink" title="이 글을 쓰고나니 생기는 질문"></a>이 글을 쓰고나니 생기는 질문</h1><ul><li><p>Embedded Tomcat의 default thread count는 200개인데 공식을 적용하면 hikari pool size가 수백개가 될 수도 있다.</p><ul><li>기본적으로 task당 1개의 connection만 필요하면 poolSize 1개로도 모든 요청은 다 처리할 수 있다.</li><li>2개 이상의 connection이 필요한 경우에는 tomcat thread count를 줄이고 hikari pool size도 100개 이하로 조정한다.</li><li>퍼포먼스가 안나오는 경우에는 DB에 insert하는 application의 아키텍쳐를 수정하는 방법도 있을 것 같다.</li></ul></li><li><p>퍼포먼스 저하는 없었나?</p><ul><li>기존 16개인 thread를 4개 정도로 조절했다.</li><li>1 thread 당 300 TPS정도의 성능이 나와 4 core인 환경에서는 문제 없이 처리할 수 있다.</li><li>오히려 thread 수를 줄여 message queue의 throttling을 할 수 있게 되었다.</li><li>core 수에 맞게 제한된 리소스를 사용하는 것이 오히려 context-switching에 대한 overhead를 줄여 성능상의 이점이 있다고 한다.<br>([About Pool Sizing] - &lt;<a href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing">https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing</a>)</li></ul></li></ul><blockquote><h4 id="Limited-Resources"><a href="#Limited-Resources" class="headerlink" title="Limited Resources"></a>Limited Resources</h4><p>It is not quite as simple as stated above, but it’s close. There are a few other factors at play. When we look at what the major bottlenecks for a database are, they can be summarized as three basic categories: <em>CPU</em>, <em>Disk</em>, <em>Network</em>. We could add <em>Memory</em> in there, but compared to <em>Disk</em> and <em>Network</em> there are several orders of magnitude difference in bandwidth.</p><p>If we ignored <em>Disk</em> and <em>Network</em> it would be simple. On a server with 8 computing cores, setting the number of connections to 8 would provide optimal performance, and anything beyond this would start slowing down due to the overhead of context switching. But we cannot ignore <em>Disk</em> and <em>Network</em>. Databases typically store data on a <em>Disk</em>, which traditionally is comprised of spinning plates of metal with read&#x2F;write heads mounted on a stepper-motor driven arm. The read&#x2F;write heads can only be in one place at a time (reading&#x2F;writing data for a single query) and must “seek” to a new location to read&#x2F;write data for a different query. So there is a seek-time cost, and also a rotational cost whereby the disk has to wait for the data to “come around again” on the platter to be read&#x2F;written. Caching of course helps here, but the principle still applies.</p></blockquote><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>[About Pool Sizing] - <a href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing">https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing</a></li><li>[Down the Rabbit Hole] - <a href="https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole">https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole</a></li><li><a href="https://github.com/brettwooldridge/HikariCP">https://github.com/brettwooldridge/HikariCP</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot </tag>
            
            <tag> Hikari CP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HikariCP Failed to Validate Connection Warning 이야기</title>
      <link href="/2020/01/08/2020-01-08-hikari-pool-validate-connection/"/>
      <url>/2020/01/08/2020-01-08-hikari-pool-validate-connection/</url>
      
        <content type="html"><![CDATA[<h1 id="hikari-pool-Failed-to-validate-connection"><a href="#hikari-pool-Failed-to-validate-connection" class="headerlink" title="hikari-pool - Failed to validate connection"></a>hikari-pool - Failed to validate connection</h1><p>Springboot2.x를 사용하다 보면 이런 warn level 에러를 마주칠 수 있습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hikari-pool - Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl@1e2db70  </span><br><span class="line">(No operations allowed after connection closed.).  </span><br><span class="line">Possibly consider using a shorter maxLifetime value.</span><br></pre></td></tr></table></figure><p>로그의 내용을 의역하면 아래와 같습니다.</p><ul><li>Hikari pool의 connection을 validate하는데 실패 했다.</li><li>이미 close된 connection에 어떤 operation을 하는것은 안된다.</li><li>HikariPool의 <code>maxLifetime</code> 값을 짧게 하는 것을 생각해봐라</li></ul><h3 id="무슨말-일까요"><a href="#무슨말-일까요" class="headerlink" title="무슨말 일까요?"></a><strong>무슨말 일까요?</strong></h3><p>요약하자면, connection을 갱신하고자 하는데 이미 닫힌 커넥션이라 어떤 행위도 할 수 없다. 입니다.<br>여기서 중요한건 HikariConfig의 MaxLifetime과 MySQL의 wait_timeout의 상관관계를 알아야 합니다.</p><h1 id="Hikari-Pool의-MaxLifetime"><a href="#Hikari-Pool의-MaxLifetime" class="headerlink" title="Hikari Pool의 MaxLifetime"></a>Hikari Pool의 MaxLifetime</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">This property controls the maximum lifetime of a connection in the pool.  </span><br><span class="line">An in-use connection will never be retired, only when it is closed will it then be removed.  </span><br><span class="line">On a connection-by-connection basis, minor negative attenuation is applied to avoid mass-extinction in the pool.  </span><br><span class="line">We strongly recommend setting this value, and it should be several seconds shorter than any  </span><br><span class="line">database or infrastructure imposed connection time limit.   </span><br><span class="line">A value of 0 indicates no maximum lifetime (infinite lifetime),  </span><br><span class="line">subject of course to the idleTimeout setting. Default: 1800000 (30 minutes)</span><br></pre></td></tr></table></figure><p>구글번역기로 대충 돌려보면..</p><ul><li>MaxLifetime은 Hikari pool에서 Connection이 살아 있을 수 있는 시간</li><li>현재 사용중인 Connection은 종료하지 않고 이미 닫혀 있는 경우에만 제거</li><li>Connection을 한번에 대량으로 종료하고 생성하면 비용이 많이 듬 (실제로 2.5%의 유격으로 maxLifetime이 Connection에 설정됨)</li><li>Database에 설정된 Connection time limit 보다 짧아야 한다.</li><li>0으로 설정하면 무한으로 Connection이 살아있음</li><li>default 180000ms (&#x3D; 30분)</li></ul><p>Hikari Pool 내부적으로 Connection의 life time을 관리하는 속성입니다.</p><p>maxLifetime은 최소 30초 이상으로 설정하여야 합니다. (안그러면 180000ms로 설정)</p><p><img src="./minimum-maxLifetime.png" alt="minimum-maxLifetime"></p><h1 id="MySQL의-wait-timeout"><a href="#MySQL의-wait-timeout" class="headerlink" title="MySQL의 wait_timeout"></a>MySQL의 wait_timeout</h1><ul><li>wait_timeout: 활동하지 않는 커넥션을 끊을때까지 서버가 대기하는 시간</li></ul><p>현재 아무것도 안하고 sleep 상태인 Connection을 끊는 주기입니다.</p><h2 id="주의"><a href="#주의" class="headerlink" title="주의!"></a>주의!</h2><p>wait_timeout은 session, global variable 두 개로 구성되어있습니다.</p><ul><li>show variables like ‘wait_timeout’; : 현재 연결된 session에 대한 wait_timeout 값</li><li>show <strong>global</strong> variables like ‘wait_timeout’: global wait_timeout값</li></ul><p>활동하지 않는 커넥션을 종료하는 것은 mysql daemon에서 해주기 때문에 global wait_timeout 값에 의해 종료됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> processlist;</span><br></pre></td></tr></table></figure><p>위의 명령어는 현재 mysql에서 동작중인 process (&#x3D; connection) 정보입니다. </p><p><img src="./processlist.png" alt="processlist"></p><p>Time 필드의 값이 Sleep Command가 실행되고 경과된 시간입니다.<br>Time 필드의 값이 설정된 global wait_timeout 시간이 지나면 <strong>Connection을 종료하게 됩니다.</strong></p><h1 id="Hikari-Pool에서-Connection을-관리하는-방법"><a href="#Hikari-Pool에서-Connection을-관리하는-방법" class="headerlink" title="Hikari Pool에서 Connection을 관리하는 방법"></a>Hikari Pool에서 Connection을 관리하는 방법</h1><p>JDBC4를 지원하는 드라이버에서는 예전처럼 더이상 <code>validationQuery</code> 를 수행하여 Connection을 갱신하지 않습니다.<br>이제는 Connection이 생성될 때 Hikari PoolEntry에 Scheduled Event를 걸어 maxLifetime 시간 이후에 강제적으로 Connection을 종료하도록 되어있습니다.</p><p><img src="./createPoolEntry.png" alt="createPoolEntry"></p><p>maxLifeTime에 2.5%의 변화를 주어 모든 Connection이 한순간에 종료되지 않도록 설정하였습니다.</p><p><img src="./softEvictConnection.png" alt="softEvictConnection"><br><img src="./reserve-PoolEntry-Status.png" alt="reserve-PoolEntry-Status"><br>softEvict Connection. 말 그대로 status만 변경하여 evict connection을 수행합니다.</p><p><img src="./soft-remove.png" alt="soft-remove"></p><p>위에서 변경한 Connection의 상태에 따라 진짜로 connection을 close 할지 말지 결정합니다.<br>(STATE_RESERVED 상태인 PoolEntry에 대한 Connection을 제거 합니다.)</p><p><img src="./connection-close.png" alt="connection-close"></p><h1 id="진짜-validationQuery는-필요없어졌나"><a href="#진짜-validationQuery는-필요없어졌나" class="headerlink" title="진짜 validationQuery는 필요없어졌나?"></a>진짜 validationQuery는 필요없어졌나?</h1><p>기존에는 validationQuery, ConnectionTestQuery &#x3D; SELECT 1등, test-idle-while 같은 기능을 구현하기 위해 또는<br>Connection의 갱신, validation을 하기 위해 의미 없는 Query를 실행하여, DB에 부하를 계속 주고 있었습니다.</p><p>하지만 JDBC4를 구현한 driver에서는 더 이상 validationQuery, ConnectionTestQuery를 사용하지 않도록 권장합니다.<br>(지금도 Hikari CP에는 기능은 있으나 코드가 실행안됨)</p><p>Connection Pool에서 한 개의 Connection을 받아 사용하기 전에 <code>isConnectionAlive</code> 라는 메서드가 실행됩니다.<br>(내가 지금 받은 커넥션이 유효한가? 에 대한 검사입니다.)</p><p><img src="./isConnectionAlive.png" alt="isConnectionAlive"></p><p>위의 코드를 보면 Jdbc4Validation을 사용하는 경우에는 Connection.isValid 메서드를 통해 현재 커넥션이 유효한지 검사합니다.<br>하지만, Jdbc4Validation을 사용하지 않는 경우에는 직접 ConnectionTestQuery를 실행하여 현재 커넥션에 대한 유효성을 판단합니다.</p><p><img src="./isUseJdbc4Validation.png" alt="isUseJdbc4Validation"></p><p>HikariPool 설정에서는 ConnectionTestQuery property가 null인 경우 Jdbc4Validation으로 동작합니다.</p><h1 id="그래서-Failed-to-validate-connection-로그는-왜-나오나요"><a href="#그래서-Failed-to-validate-connection-로그는-왜-나오나요" class="headerlink" title="그래서  Failed to validate connection 로그는 왜 나오나요"></a>그래서  Failed to validate connection 로그는 왜 나오나요</h1><p>저의 경우에는<br>mysql의 global wait_timeout 값이 60초로 설정되어 있었습니다.<br>Hikari Pool의 maxLifetime 값은 default로 180000ms (&#x3D; 30분) 으로 되어져 있었습니다 .</p><p>따라서 30분마다 PoolEntry에서 놀고 있는 Connection을 종료하고자 하였지만, 이미 MySQL process는 종료되었기에<br><strong>이미 닫힌 커넥션에 왜 무언가를 하려고하는가?</strong> 라고 warning log가 발생하였습니다. </p><p><img src="./isConnectionAlive.png" alt="isConnectionAlive"></p><p>catch 절에서 Exception이 발생하여 해당 로그가 찍히게 됩니다.</p><h1 id="maxLifetime-wait-timeout-어떻게-설정해야-하나요"><a href="#maxLifetime-wait-timeout-어떻게-설정해야-하나요" class="headerlink" title="maxLifetime, wait_timeout 어떻게 설정해야 하나요?"></a>maxLifetime, wait_timeout 어떻게 설정해야 하나요?</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">We strongly recommend setting this value, and it should be at least 30 seconds less than any  </span><br><span class="line">database or infrastructure imposed connection time limit.</span><br></pre></td></tr></table></figure><p>Hikari CP에서는 maxLifetime을 MySQL의 wait_timeout보다 최소 30초 이상 적게 주도록 권장하고 있습니다.<br>(하지만 이는 잘못되었다고 합니다. <a href="https://pkgonan.github.io/2018/04/HikariCP-test-while-idle">pkgonan님 질문 참고</a>)</p><p>pkgonan님이 받으신 답변을 참고하면 </p><p>답변 요약</p><ul><li>max_lifetime을 Database의 wait_timeout보다 30초 이상 짧게 주라는 것은 잘못 되었다.<br>공식 문서 업데이트를 진행하지 않은 것이다.</li><li>HikariCP는 DBA를 존중하기 때문에 DBA가 설정한 wait_timeout을 지킨다.</li><li>HikariCP는 커넥션 풀을 관리하기 위해 HouseKeeper라는 Thread가 30초마다 돌고 있다.</li><li>HouseKeeper가 30초마다 돌며 커넥션을 종료하였기에, 이전 29.xx초까지의 커넥션들에 대해 유효성 체크가 누락될 수 있어서 30초의 여유를 준 것이다.</li><li>현재 방식은, ThreadLocal에서 각각 타이머를 통해 max-lifetime에 도달했는지 체크를 하는 방식으로 변경되었다.</li><li><code>따라서, max-lifetime은 네트워크 통신 등을 감안해서 Database의 wait_timeout으로 부터 2~3초 정도 짧게 주면 된다.</code></li><li><code>커넥션이 사용중일 경우 즉시 종료를 하지 않기에 커넥션이 매우 바쁜 상황을 감안해서 여유있게 준다면 wait_timeout으로 부터 5초정도까지 짧게 주면 된다는 개발자의 추가 답변.</code></li></ul><p>결론적으로<br>maxLifetime &#x3D; wait_timeout - (2~5초) 정도로 설정하면 됩니다. </p><h1 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h1><p>저의 경우에는 maxLifetime의 Default를 더 존중하여 30분을 유지하도록 하고<br>MySQL의 global wait_timeout 값을 1830초 정도로(그냥 넉넉하게) 수정하여 사용하도록 변경하였습니다.<br>(maxLifetime을 바꾸자니 너무 잦은 커넥션 생성 비용이 염려스러웠습니다.)  </p><p>이렇게 설정하고 나니 더 이상 Failed to validate connection WARN 로그는 발생하지 않았습니다. </p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://github.com/brettwooldridge/HikariCP">https://github.com/brettwooldridge/HikariCP</a></li><li><a href="https://pkgonan.github.io/2018/04/HikariCP-test-while-idle">https://pkgonan.github.io/2018/04/HikariCP-test-while-idle</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot </tag>
            
            <tag> Hikari CP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Kafka-Streams Serde 내부 이야기</title>
      <link href="/2019/12/23/2019-12-23-kafka-streams-binder-feature/"/>
      <url>/2019/12/23/2019-12-23-kafka-streams-binder-feature/</url>
      
        <content type="html"><![CDATA[<h1 id="Version-Up"><a href="#Version-Up" class="headerlink" title="Version Up"></a>Version Up</h1><p>팀에서 사용하는 Spring boot version up (2.1.6 -&gt; 2.2.2)을 하면서 호환성을 맞추기 위해<br>spring-cloud-stream-binder-kafka-streams 라이브러리도 같이 버전업을 하게 되었습니다. (2.2.0 -&gt; 2.3.4)<br>그 과정에서 발생한 value Serde 이슈에 대한 내용을 얘기해 보고자 합니다.</p><h1 id="Kafka-Streams란"><a href="#Kafka-Streams란" class="headerlink" title="Kafka Streams란?"></a>Kafka Streams란?</h1><p>kafka streams는 kafka streams api를 사용하여, 지속적으로 흘러들어오는 데이터에 대한 분석, 처리를 위한 클라이언트 라이브러리 입니다.</p><p>간단하게는 어떤 Topic으로 들어오는 데이터를 Consume하여, streams api를 통해 처리 후<br>다른 Topic으로 전송(Producing) 하거나 끝내는 행위를 하게 됩니다.</p><h1 id="Spring에서-사용하기"><a href="#Spring에서-사용하기" class="headerlink" title="Spring에서 사용하기"></a>Spring에서 사용하기</h1><p>Springboot에서 kafka streams를 사용하게 되면 <code>@StreamListener</code> annotation을 사용해서 로직을 구현하게 됩니다.</p><p><img src="./StreamListener-annoataion.png" alt="StreamListener-annoataion"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding(MessageDispatcher.Dispatch.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageDispatcher</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@StreamListener(Dispatch.TOPIC)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(KStream&lt;String, Message&gt; input)</span> &#123;</span><br><span class="line">    input.mapValues(value -&gt; value.markSendFlag())</span><br><span class="line">      .to(<span class="string">&quot;next-topic&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Dispatch</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC</span> <span class="operator">=</span> <span class="string">&quot;message-topic&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Input(TOPIC)</span></span><br><span class="line">    KStream&lt;String, Message&gt; <span class="title function_">input</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>간단하게 Message를 처리하는 kafka streams code를 작성해 보았습니다<br><code>message-topic</code>토픽으로 들어오는 메세지를 consume하여 sendFlag 처리를 하고 <code>next-topic</code>으로 다시 producing하는 코드 입니다.</p><p>기본적으로 kafka에서 쓰이는 content-type은 <code>application/json</code>이기 때문에  value fotmat을 Json으로 사용하고 있습니다.</p><p>그렇다면 kafka에는 <strong>분명 value가 json string일텐데,</strong> @StreamListener 메서드에서는 <code>어떻게 json -&gt; Pojo로 Deserializing 해주었을까요? </code></p><p>이걸 찾아보기 전까지는 막연하게 default.value.serde (Serializier&#x2F;DeSerializer)가 해주는줄 알았습니다.  <code>(반은 맞고 반은 아님) </code><br>하지만 이번 version up 이슈를 통해 자세하게 알아보았고, 그 내용을 적어보았습니다.</p><h1 id="spring-cloud-stream-binder-kafka-streams-2-2-0"><a href="#spring-cloud-stream-binder-kafka-streams-2-2-0" class="headerlink" title="spring-cloud-stream-binder-kafka-streams 2.2.0"></a>spring-cloud-stream-binder-kafka-streams 2.2.0</h1><p><code>@StreamListener</code> annoataion은 <code>StreamListenerAnnotationPostProcessor</code> class에 의해 annotation processing 작업이 이루어집니다.</p><p>그 내부에서 StreamListenerSetupMethodOrchestrator class에 의해 processing이 이루어지며,<br>정확히는 <code>KafkaStreamsStreamListenerSetupMethodOrchestrator</code> 입니다.</p><p>살펴볼 코드의 순서는 이렇습니다.</p><ol><li><code>orchestrateStreamListenerSetupMethod</code></li><li><code>adaptAndRetrieveInboundArguments</code></li><li><code>keySerde, valueSerde</code> 설정하는 부분</li><li><code>valueSerde 설정</code> (과연 valueSerde는 뭐를 쓰고 있었을까?)</li><li><code>if (parameterType.isAssignableFrom(KStream.class))</code></li><li><code>getkStream(inboundName, spec, bindingProperties, streamsBuilder, keySerde, valueServde, autoOffsetReset)</code></li><li><code>streamListenerParameterAdapter.adapt</code></li><li><code>deserializeOnInbound</code></li><li><code>convertAndSetMessage</code></li><li><code>ApplicationJsonMessageMarshallingConverter.convertFromInternal</code></li></ol><h2 id="3-keySerde-valueSerde-설정"><a href="#3-keySerde-valueSerde-설정" class="headerlink" title="3. keySerde, valueSerde 설정"></a>3. keySerde, valueSerde 설정</h2><p><img src="./setSerde.png" alt="setSerde"></p><p>6번째 줄부터 keySerde, valueSerde를 설정하는 부분을 볼 수 있습니다.</p><h2 id="4-valueSerde-설정"><a href="#4-valueSerde-설정" class="headerlink" title="4. valueSerde 설정"></a>4. valueSerde 설정</h2><p><img src="./getInboundValueSerde-7085172.png" alt="getInboundValueSerde"></p><p>중요!한 valueSerde 설정 부분입니다.<br>try 블록 첫번째 if문을 보면 consumerProperties에 <code>useNativeDecoding</code> 속성이 true인 경우에만 getValueSerde() 메서드를 호출하여 default.value.serde가 적용되게 됩니다.<br>그게 아니라면 ByteArray Serde가 적용됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When set to true, the inbound message is deserialized directly by client library,</span></span><br><span class="line"><span class="comment"> * which must be configured correspondingly (e.g. setting an appropriate Kafka</span></span><br><span class="line"><span class="comment"> * producer value serializer). <span class="doctag">NOTE:</span> This is binder specific setting which has no</span></span><br><span class="line"><span class="comment"> * effect if binder does not support native serialization/deserialization. Currently</span></span><br><span class="line"><span class="comment"> * only Kafka binder supports it. Default: &#x27;false&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> useNativeDecoding;</span><br></pre></td></tr></table></figure><p>default는 false이기 때문에 기본적으로 ByteArray Serde가 적용됩니다.<br>(그것도 모르고 default.value.serde에 명시한 Serde가 적용되는 줄 알았습니다.)</p><p><img src="./getValueSerde.png" alt="getValueSerde"></p><h2 id="5-if-parameterType-isAssignableFrom-KStream-class"><a href="#5-if-parameterType-isAssignableFrom-KStream-class" class="headerlink" title="5. if (parameterType.isAssignableFrom(KStream.class))"></a>5. if (parameterType.isAssignableFrom(KStream.class))</h2><p><img src="./KStream-if.png" alt="KStream-if"></p><p>여기서 중요하게 봐야 할 부분은 두군데 입니다.</p><ul><li>getkStream()</li><li>streamListenerParameterAdapter.adapt(kStreamWrapper, methodParameter)</li></ul><h2 id="6-getkStream"><a href="#6-getkStream" class="headerlink" title="6. getkStream()"></a>6. getkStream()</h2><p><img src="./getStream.png" alt="getStream"></p><p>마지막의 stream.mapValues 쪽을 잘봐야 합니다.<br>여기에도 nativeDecoding에 대한 조건이 있습니다.<br>contentType은 default를 사용하고 있기 때문에 <code>application/json</code>이 적용됩니다.<br>stream.mapValues내의 함수는 runtime에서 실행되는 함수이기 때문에 kafka streams에서 message를 consume하고 실행하는 함수입니다.</p><p>정리해보면..</p><ul><li>contentType &#x3D; <code>application/json</code></li><li>useNativeDecoding &#x3D; <code>false</code></li></ul><p>이므로</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">returnValue = MessageBuilder.withPayload(value)</span><br><span class="line">  .setHeader(MessageHeaders.CONTENT_TYPE, contentType)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>kafka에서 처리하는 Message Type으로 처리가 되게 됩니다.</p><h1 id="7-streamListenerParameterAdapter-adapt"><a href="#7-streamListenerParameterAdapter-adapt" class="headerlink" title="7. streamListenerParameterAdapter.adapt"></a>7. streamListenerParameterAdapter.adapt</h1><p><img src="./streamListenerParameterAdapter.png" alt="streamListenerParameterAdapter"></p><p><img src="./StreamListenerParameterAdapter-interface.png" alt="StreamListenerParameterAdapter-interface"></p><p>다음은 @StreamListener가 달린 Parameter를 처리하기 위한 Adapter 설정입니다.<br>이 메서드 내에서 KStream&lt;String, YourPojoType&gt;인 KStream의 Deserializing이 이루어집니다.</p><p><img src="./adapt.png" alt="adapt"></p><p>interface 구현체는 <code>KStreamStreamListenerParameterAdapter</code> 클래스입니다.<br>여기서도 useNativeDecoding 속성에 따라 코드가 분기가 됩니다.<br>default &#x3D; false이기 때문에 아래 deserializeOnInbound 메서드가 호출됩니다.</p><h2 id="8-deserializeOnInbound"><a href="#8-deserializeOnInbound" class="headerlink" title="8. deserializeOnInbound"></a>8. deserializeOnInbound</h2><p><img src="./deSerializeOnInbound.png" alt="deSerializeOnInbound"></p><p>쭉~ 복잡한 코드가 보입니다.<br>그중에서도 볼것은 <code>convertAndSetMessage</code> 메서드입니다.</p><h2 id="9-convertAndSetMessage"><a href="#9-convertAndSetMessage" class="headerlink" title="9. convertAndSetMessage"></a>9. convertAndSetMessage</h2><p><img src="./convertAndSetMessage.png" alt="convertAndSetMessage"></p><p><img src="./CompositeMessageConverter-fromMessage.png" alt="CompositeMessageConverter-fromMessage"></p><p>valueClass.isAssignableFrom() &#x3D; false이므로 messageConverter.fromMessage() 메서드가 실행됩니다.<br>(여기서 사용되는 messageConverter는 여러가지 messageConvert를 모아둔 <code>CompositeMessageConverter</code> 가 사용됩니다.)</p><p>그중에서도 <code>ApplicationJsonMessageMarshallingConverter</code>를 사용하여 Json Data를 targetClass 타입으로 변환시킵니다.<br><strong>그렇기 때문에 따로 Serde를 정의하지 않아도 Kafka Stream 라이브러리에서 알아서 잘 deserialize를 해주었습니다.</strong></p><h2 id="10-ApplicationJsonMessageMarshallingConverter-convertFromInternal"><a href="#10-ApplicationJsonMessageMarshallingConverter-convertFromInternal" class="headerlink" title="10. ApplicationJsonMessageMarshallingConverter.convertFromInternal"></a>10. ApplicationJsonMessageMarshallingConverter.convertFromInternal</h2><p><img src="./convertFromInternal2.png" alt="convertFromInternal2"></p><p>내부적으로는 Jackson 라이브러리의 objectMapper를 이용하여 deserialize 하는 코드가 있습니다.</p><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><ul><li>spring kafka streams에 대한 별다른 설정을 안했다면 default로 작동할 것 입니다.</li><li>useNativeDecoding &#x3D; false로 설정 되어있을 것입니다.</li><li>위의 설정을 true로 하지 않았다면, default.key.serde, default.value.serde 설정은 먹히지 않습니다.</li><li>기본적으로 ByteArray valueSerde를 사용했을 것입니다.</li><li>ApplicationJsonMessageMarshallingConverter에 의해 Json String이 파라미터에 정의한 타입에 맞게 알아서 잘 deserializing 해줬을 것입니다.</li></ul><h1 id="spring-cloud-stream-binder-kafka-streams-2-3-4"><a href="#spring-cloud-stream-binder-kafka-streams-2-3-4" class="headerlink" title="spring-cloud-stream-binder-kafka-streams 2.3.4"></a>spring-cloud-stream-binder-kafka-streams 2.3.4</h1><p>대부분의 코드 및 설정은 2.2.0 버전과 같습니다.<br>하지만 2.2.0을 default로 세팅해서 사용하시는 분들은 버전 업 후에는 잘 안되는것을 보실수 있습니다.<br>2.3.4에서 크게 바뀐 점 한 가지로 인해서 코드가 정상적으로 동작하지 않을 수 있게 되었습니다.</p><h2 id="useNativeDecoding의-default가-true로-변경"><a href="#useNativeDecoding의-default가-true로-변경" class="headerlink" title="useNativeDecoding의 default가 true로 변경"></a>useNativeDecoding의 default가 true로 변경</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When set to true, the inbound message is deserialized directly by client library,</span></span><br><span class="line"><span class="comment"> * which must be configured correspondingly (e.g. setting an appropriate Kafka</span></span><br><span class="line"><span class="comment"> * producer value serializer). <span class="doctag">NOTE:</span> This is binder specific setting which has no</span></span><br><span class="line"><span class="comment"> * effect if binder does not support native serialization/deserialization. Currently</span></span><br><span class="line"><span class="comment"> * only Kafka binder supports it. Default: &#x27;false&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> useNativeDecoding;</span><br></pre></td></tr></table></figure><p>2.3.4의 ConsumerProperties의 useNativeDecoding 주석을 보면 여전히 Default: false로 표기되어 있습니다.<br>하지만 로직 상에서는 아무런 처리도 하지 않은 <strong>useNativeDecoding의 값이 true로 나오게 됩니다.</strong></p><p><strong>어디서 useNativeDecoding 값을 true로 바꿨을까요?</strong><br>call tree를 찾아보니 다행히도 딱  세 군데에서만 호출하고 있습니다.</p><ul><li>KStreamBoundElementFactory</li><li>KTableBoundElementFactory</li><li>GlobalKTableBoundElementFactory</li></ul><p><img src="./createInput2-2-0.png" alt="createInput 2.2.0"><br><img src="./createInput.png" alt="createInput 2.3.4"></p><p>createInput 메서드에 집중해 보겠습니다.<br>createInput 메서드는 @StreamListener에 대한 post processing 단계에서 호출되는 코드입니다.</p><p>parameter로 들어오는 name은 input binding name입니다. (@StreamListener에 설정한 input name)<br>코드를 보면 consumerProperties의 useNativeDecoding을 무조건 true로 만들어 주고 있습니다.<br>(2.2.0 버전에서는 없던 코드가 추가되었습니다. useNativeDecoding이 default false였네요)</p><ul><li>KStreamBoundElementFactory</li><li>KTableBoundElementFactory</li><li>GlobalKTableBoundElementFactory</li></ul><p>그래서 useNativeDecoding가 true가 되었다는 의미는<br><strong>더이상 kafka에서 제공하는 Message Type으로 자동 deserializing이 되지 않고 개발자가 하나하나 deserializer을 지정해주어야 함을 의미합니다.</strong></p><p>이를 해결하기 위한 방법은 2가지 있습니다.</p><ol><li>useNativeDecoding을 false로 설정한다. &#x3D;&gt; 다시 kafka에서 제공하는 자동 deserialize 기능을 사용한다.</li><li>binding input 별로 하나하나 deserializer를 지정한다.</li></ol><p>해결방법을 보고나니 spring에서 왜 이렇게 코드를 변경했는지 알 것만 같습니다.</p><p>기존에는 별도로 지정하지 않게 되면 무조건 자동 deserialize가 되도록 했는데,<br>일부러 true로 바꾸었다는 것은 bindings 별로 deserializer를 각각 지정하도록 권장하는 것 같습니다.</p><h2 id="1-useNativeDecoding을-false로-설정한다"><a href="#1-useNativeDecoding을-false로-설정한다" class="headerlink" title="1. useNativeDecoding을 false로 설정한다."></a>1. useNativeDecoding을 false로 설정한다.</h2><p><img src="./createInput.png" alt="createInput"></p><p>위의 코드를 잘 보게되면, encodingDecodingBindAdviceHandler.isDecodingSettingProvided() &#x3D; false일때 true로 설정하게 합니다.<br>저 코드도 궁금해서 한번 들어가보았습니다.</p><p><img src="./EncodingDecodingBindAdviceHandler.png" alt="EncodingDecodingBindAdviceHandler"></p><p>apply() 메서드를 보게되면 spring configuration properties를 모두 읽으면서 조건에 맞는 configName을 찾고 있습니다.<br>아마도 <code>spring.cloud.streams.binding.[input-name].use-native-decoding</code> 또는 <code>encoding</code>을 찾는가 봅니다.<br>저게 설정이 있으면 true로 변경되니 일단 원하는대로 설정을 해줘보겠습니다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.cloud.stream.bindings.message-topic.use-native-decoding</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>이렇게 하면 use-native-decoding 설정이 false가 되어 2.2.0에서 제공하던 kafka의 자동 deserialize 기능이 동작해서 이전버전과 동일하게 동작합니다.</p><blockquote><p>주의) use-native-decoding default 설정을 다시 전체 false로 하고 싶은데..<br>아쉽게도 binder 별로 설정이 적용되어 전체를 하기 어렵게 되었습니다.<br>귀찮더라도 하나하나 지정해 줍시다.</p><p>spring.cloud.stream.bindings.message-topic1.use-native-decoding&#x3D;false<br>spring.cloud.stream.bindings.message-topic2.use-native-decoding&#x3D;false</p></blockquote><h2 id="2-binding-input-별로-하나하나-deserializer를-지정한다"><a href="#2-binding-input-별로-하나하나-deserializer를-지정한다" class="headerlink" title="2. binding input 별로 하나하나 deserializer를 지정한다."></a>2. binding input 별로 하나하나 deserializer를 지정한다.</h2><p>이번 spring-kafka 버전에서 원하는대로 input 별로 하나하나 deserializer를 지정해 주겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MessageSerde</span> <span class="keyword">implements</span> <span class="title class_">Serde</span>&lt;Message&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Serializer&lt;Message&gt; <span class="title function_">serializer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (topic, data) -&gt; JsonUtils.toByteArray(data);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Deserializer&lt;Message&gt; <span class="title function_">deserializer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (topic, data) -&gt; JsonUtils.fromJson(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>참고. JsonUtils는 제가 만든 Json 변환 Utils입니다.</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">stream</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">kafka</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">streams</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">binder</span>:<span class="string"></span></span><br><span class="line">           <span class="attr">configuration</span>:<span class="string"></span></span><br><span class="line">            <span class="attr">default</span>:<span class="string"></span></span><br><span class="line">              <span class="attr">key.serde</span>: <span class="string">org.apache.kafka.common.serialization.Serdes$StringSerde</span></span><br><span class="line">              <span class="attr">value.serde</span>: <span class="string">org.springframework.kafka.support.serializer.JsonSerde</span></span><br><span class="line">          <span class="attr">bindings</span>:<span class="string"></span></span><br><span class="line">            <span class="attr">message-topic</span>:<span class="string"></span></span><br><span class="line">              <span class="attr">consumer</span>:<span class="string"></span></span><br><span class="line">                <span class="attr">applicationId</span>: <span class="string">messageDispatcher</span></span><br><span class="line">                <span class="attr">keySerde</span>: <span class="string">org.apache.kafka.common.serialization.Serdes$StringSerde</span></span><br><span class="line">                <span class="attr">valueSerde</span>: <span class="string">com.my.packages.serde.MessageSerde</span></span><br></pre></td></tr></table></figure><p><strong>주의) property의 depth가 깊어서 틀리지 않게 주의해야 합니다.</strong></p><p>default key, value serde는 <code>spring.cloud.stream.kafka.streams.binder.configuration</code> 아래에 정의합니다.<br>binding input 별 key, value serde는 <code>spring.cloud.stream.kafka.streams.bindings.[input-name].consumer</code> 아래에 정의합니다.</p><h1 id="추가내용"><a href="#추가내용" class="headerlink" title="추가내용"></a>추가내용</h1><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-stream-binder-kafka/3.0.0.M3/reference/html/spring-cloud-stream-binder-kafka.html#_kafka_streams_properties">https://cloud.spring.io/spring-cloud-static/spring-cloud-stream-binder-kafka/3.0.0.M3/reference/html/spring-cloud-stream-binder-kafka.html#_kafka_streams_properties</a></p><p>내용을 보면 <code>useNativeEncoding</code> 과 <code>useNativeDecoding</code> 의 default value가 true라고 알려주고 있습니다.<br>spring-cloud-stream의 backend가 무엇이냐에 따라 default 값이 달라지므로 주의해야할 것 같습니다.<br>(kafka에서는 default가 true이고 다른 backend는 default가 false일 수 있습니다.)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> Springboot </tag>
            
            <tag> Kafka-streams </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Custom @Enable Annotation 만들어보기</title>
      <link href="/2019/12/22/2019-12-22-spring-import/"/>
      <url>/2019/12/22/2019-12-22-spring-import/</url>
      
        <content type="html"><![CDATA[<h1 id="Multi-모듈-프로젝트에서-발생하는-일"><a href="#Multi-모듈-프로젝트에서-발생하는-일" class="headerlink" title="Multi 모듈 프로젝트에서 발생하는 일"></a>Multi 모듈 프로젝트에서 발생하는 일</h1><p>Maven, Gradle을 이용해서 멀티 모듈을 구성하다 보면 각 모듈 별로 중복된 Bean을 계속 생성 코드를 만드는 경우가 있습니다.<br>(ex: Datasource, TransactionManager 등등)  </p><blockquote><p>예시 : Custom Module에서만 사용하는 JPA 환경 구성입니다.<br>일반적으로 하나의 DataSource를 사용하신다면, Spring AutoConfiguration을 이용하면 편리하게 구성하실 수 있습니다.<br>하지만 실무에서는 DataSource를 2개 이상 구성해서 쓰는 경우도 있기에, 직접 경험한 예시를 사용하게 되었습니다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EntityScan(basePackages = &#123;&quot;com.your.packages.module1&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &#123;&quot;com.your.packages.module1&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module_1_Configuration</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties(prefix = &quot;spring.custom-module.datasource&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> HikariConfig <span class="title function_">hikariConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@FlywayDatasource</span></span><br><span class="line">  <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title function_">entityManagerFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">    EntityManagerFactoryBuilder builder,</span></span><br><span class="line"><span class="params">    DataSource dataSource</span></span><br><span class="line"><span class="params">  )</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="string">&quot;com.your.packages.module1&quot;</span>)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> JpaTransactionManager <span class="title function_">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JpaTransactionManager</span>(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EntityScan(basePackages = &#123;&quot;com.your.packages.module2&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &#123;&quot;com.your.packages.module2&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module_2_Configuration</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties(prefix = &quot;spring.custom-module.datasource&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> HikariConfig <span class="title function_">hikariConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title function_">entityManagerFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">    EntityManagerFactoryBuilder builder,</span></span><br><span class="line"><span class="params">    DataSource dataSource</span></span><br><span class="line"><span class="params">  )</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="string">&quot;com.your.packages.module2&quot;</span>)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> JpaTransactionManager <span class="title function_">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JpaTransactionManager</span>(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 두 Configuation 코드는 99% 같은 코드입니다.<br>하지만 왜 같은 코드 두개를 짰을까요?  </p><p>첫 번째는 packages 설정이 달랐습니다.</p><ul><li>packages(“com.your.packages.module1”)</li><li>packages(“com.your.packages.module2”)</li></ul><p>두 번째는 EntityScan, EnableJpaRepositories의 basePackages 설정이 달랐습니다.</p><ul><li>basePackages &#x3D; {“com.your.packages.module1”}</li><li>basePackages &#x3D; {“com.your.packages.module2”}</li></ul><p>세 번째는</p><ul><li>module1에서는 DataSource Bean에 <code>@FlywayDataSource</code> annotation이 있고</li><li>module2에서는 DataSource Bean에 <code>@FlywayDataSource</code> annotation이 없습니다.</li></ul><p>코드가 거의 같더라도, 약간의 설정이 다르다는 이유로 거의 같은 두 개의 Configuration을 사용했습니다.</p><h1 id="리팩토링1-EnableCustomDataSource"><a href="#리팩토링1-EnableCustomDataSource" class="headerlink" title="리팩토링1 - @EnableCustomDataSource"></a>리팩토링1 - @EnableCustomDataSource</h1><p>Spring을 사용하다 보면 @Enable~ 하는 Annotation을 자주 보았을 것이고, 실제로도 많이 사용해 보셨을 겁니다.  </p><ul><li>EnableCaching</li><li>EnableTransactionManagement</li><li>EnableJpaRepositories</li><li>EnableConfigurationProperties</li><li>EnableAsync</li></ul><p>이 처럼 많은 Enable Annotation들을 Spring에서 사용하고 있고, 실제로 개발자가 해야할 귀찮은<br>Configuration이나 BeanPostProcessing 같은 처리들을 손쉽게 하도록 도와줍니다.  </p><p>그렇기 때문에 이번 리팩토링도 Spring의 이런 부분을 벤치마킹하여 <code>@EnableCustomDataSource</code> 를 한번 만들어 보겠습니다.   </p><p>최종적인 모습은 아래와 같은 코드로 깔끔하게 리팩토링을 하는 그림이면 좋겠네요</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCustomDataSource(basePackage = &#123;&quot;com.your.packages.module1&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module1Configuration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="리팩토링2-다른-Enable-Annotation-내부는-어떻게-생겼을까"><a href="#리팩토링2-다른-Enable-Annotation-내부는-어떻게-생겼을까" class="headerlink" title="리팩토링2 - 다른 @Enable~ Annotation 내부는 어떻게 생겼을까?"></a>리팩토링2 - 다른 @Enable~ Annotation 내부는 어떻게 생겼을까?</h1><p><img src="./EnableAsync.png" alt="EnableAsync"></p><p><img src="./EnableConfigurationProperties.png" alt="EnableConfigurationProperties"></p><p><img src="./EnableJpaRepositories.png" alt="EnableJpaRepositories"></p><p>혹시 3개의 Annotation의 공통점이 보이시나요?<br>모두 <code>@Import</code> Annotation을 통해 어떤 class를 import하고 있습니다.<br>대부분의 Enable의 Annotation은 위와 같이 Configuration 클래스를 Import하는 형식으로 많이 작성되고 있습니다.<br>(이외에는 SpringAutoConfiguration으로 작동하는 것들도 있는 것 같습니다.)</p><h1 id="리팩토링3-EnableCustomDataSource-생성"><a href="#리팩토링3-EnableCustomDataSource-생성" class="headerlink" title="리팩토링3 - @EnableCustomDataSource 생성"></a>리팩토링3 - @EnableCustomDataSource 생성</h1><p>위 에서 많은 개발자들이 만든 @Enable Annotation 생성 방식을 모방하여 만들어 보겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.Type)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(??.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일단 @EnableCustomDataSource를 만들었습니다.<br>근데 @Import Annotation에 지정할 Configuration Class가 없어서.. 어떻게 해야 할지 잘 모르겠네요.<br>위에는 2개의 Configuration이 있는데 말이죠</p><h1 id="리팩토링-4-ImportSelector를-이용한-선택적-Configuration-사용"><a href="#리팩토링-4-ImportSelector를-이용한-선택적-Configuration-사용" class="headerlink" title="리팩토링 4 - ImportSelector를 이용한 선택적 Configuration 사용"></a>리팩토링 4 - ImportSelector를 이용한 선택적 Configuration 사용</h1><p>spring-context 라이브러리에서는 @Import Annotation processing에 대한 3가지 Interface를 지원합니다.</p><ul><li>ImportSelector</li><li>ImportBeanDefinitionRegistrar</li><li>ImportAware</li></ul><p>먼저 ImportSelector를 사용하여 선택적으로 Configuration을 사용해 보겠습니다.<br>ImportSelector는 Annotation Attribute의 값에 따라 Import할 Configuration을 지정할 수 있습니다.  </p><p>그렇기 때문에 @EnableCustomDataSource의 Attribute를 수정해보았습니다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.Type)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(CustomDataSourceConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">  Module <span class="title function_">module</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Module</span> &#123; ONE, TWO &#125;</span><br></pre></td></tr></table></figure><p>ImportSelector를 구현한 CustomDataSourceConfigurationSelector 코드를 구성하였습니다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomDataSourceConfigurationSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//find annotation attribute (module)</span></span><br><span class="line">    Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> AnnotationAttributes.fromMap(metaData);</span><br><span class="line">    <span class="type">Module</span> <span class="variable">module</span> <span class="operator">=</span> attributes.getEnum(<span class="string">&quot;module&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//determine configuration class</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">configurationClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">module</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> ONE:</span><br><span class="line">          configurationClass = Module_1_Configuration.class.getName();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TWO:</span><br><span class="line">          configurationClass = Module_2_Configuration.class.getName();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;configurationClass&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Module1의 CustomDataSourceConfiguration에서 Module.ONE이라고 설정을 정의해주면<br>Module_1_Configuration에 대한 설정을 Import할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCustomDataSource(module = Module.ONE)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomDataSourceConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="리팩토링-5-ImportBeanDefinitionRegistrar를-이용한-직접-Bean-생성하기"><a href="#리팩토링-5-ImportBeanDefinitionRegistrar를-이용한-직접-Bean-생성하기" class="headerlink" title="리팩토링 5 - ImportBeanDefinitionRegistrar를 이용한 직접 Bean 생성하기"></a>리팩토링 5 - ImportBeanDefinitionRegistrar를 이용한 직접 Bean 생성하기</h1><p>ImportBeanDefinitionRegistrar를 이용하면 직접 beanRegistry에 Bean을 등록할 수 있습니다.</p><blockquote><p>하지만 추천하는 방식은 아닙니다.<br>실제로 Bean이 등록되는 순서를 제어하기 어렵기 때문에 원하는대로 실행이 되지 않을 수 있습니다.<br>토비의 스프링 ver2에서도 가급적이면 사용을 하지 않을 것을 권장하고 있습니다. </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomDataSourceBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;customDataSourceConfiguration&quot;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">      Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">      <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> AnnotationAttributes.fromMap(metaData);</span><br><span class="line">      EnableCustomDataSource.<span class="type">Module</span> <span class="variable">module</span> <span class="operator">=</span> attributes.getEnum(<span class="string">&quot;module&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">module</span>) &#123;</span><br><span class="line">          <span class="keyword">case</span> ONE:</span><br><span class="line">              beanDefinition = BeanDefinitionBuilder</span><br><span class="line">                      .rootBeanDefinition(Module_1_Configuration.class)</span><br><span class="line">                      .getBeanDefinition();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> TWO:</span><br><span class="line">              beanDefinition = BeanDefinitionBuilder</span><br><span class="line">                      .rootBeanDefinition(Module_2_Configuration.class)</span><br><span class="line">                      .getBeanDefinition();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      registry.registerBeanDefinition(BEAN_NAME, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.Type)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(CustomDataSourceBeanDefinitionRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">  Module <span class="title function_">module</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="리팩토링-6-ImportAware를-이용한-Annoataion-attribute-주입"><a href="#리팩토링-6-ImportAware를-이용한-Annoataion-attribute-주입" class="headerlink" title="리팩토링 6 - ImportAware를 이용한 Annoataion attribute 주입"></a>리팩토링 6 - ImportAware를 이용한 Annoataion attribute 주입</h1><p>마지막으로 ImportAware입니다.</p><p>ImportAware interface는 @Import하는 Configuration class에 @Import 메타 annoatation을 사용하는 annoatation의 attribute를 사용할 수 있도록 해줍니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.Type)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(CustomDataSourceConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomDataSourceConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ImportAware</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties(prefix = &quot;spring.custom-module.datasource&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> HikariConfig <span class="title function_">hikariConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title function_">entityManagerFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">    EntityManagerFactoryBuilder builder,</span></span><br><span class="line"><span class="params">    DataSource dataSource</span></span><br><span class="line"><span class="params">  )</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="string">&quot;com.your.packages.module2&quot;</span>)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> JpaTransactionManager <span class="title function_">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JpaTransactionManager</span>(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setImportMetadata</span><span class="params">(annoatationMetadata: AnnotationMetadata)</span> &#123;</span><br><span class="line">    <span class="comment">//use @EnableCustomDataSource annotation attribute</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 @EnableCustomDataSource annotation의 attribute를 사용할 수 있는 메서드를 제공합니다.</p><p>그렇게 되면, 애초에 2개의 파일로 분리되었던 </p><ul><li>Module_1_Configuration</li><li>Module_2_Configuration</li></ul><p>이 두가지 파일을 하나로 합칠 수 있을 것 같습니다.</p><p>두개의 파일을 하나로 합쳐서 CustomDataSourceConfiguration이라는 class를 만들고<br>@EnableCustomDataSource annotation에서 @Import 해보겠습니다.</p><h2 id="basePackages-attribute-추가"><a href="#basePackages-attribute-추가" class="headerlink" title="basePackages attribute 추가"></a>basePackages attribute 추가</h2><p>@EnableCustomDataSource annotation의 attribute를 조금 변경해 보겠습니다.<br>여태까지 사용한 module attribute는 이제 의미가 없을 것 같습니다.<br>파일을 하나로 합치기로 했기 때문이죠</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.Type)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(CustomDataSourceConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">  String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Module1Configuration class에 드디어 우리가 원하던 대로 @EnableCustomDataSource를 사용해보게 되었습니다.<br>이게 껍데기는 완성되었고 내부 로직만 잘 구성하면 될듯 합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCustomDataSource(basePackages = &#123;&quot;com.your.package.module1&quot;&#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module1Configuration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ImportAware-메서드-코드-구성"><a href="#ImportAware-메서드-코드-구성" class="headerlink" title="ImportAware 메서드 코드 구성"></a>ImportAware 메서드 코드 구성</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomDataSourceConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ImportAware</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String[] basePackages;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties(prefix = &quot;spring.custom-module.datasource&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> HikariConfig <span class="title function_">hikariConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title function_">entityManagerFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">    EntityManagerFactoryBuilder builder,</span></span><br><span class="line"><span class="params">    DataSource dataSource</span></span><br><span class="line"><span class="params">  )</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="built_in">this</span>.basePackages)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> JpaTransactionManager <span class="title function_">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JpaTransactionManager</span>(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setImportMetadata</span><span class="params">(annoatationMetadata: AnnotationMetadata)</span> &#123;</span><br><span class="line">    <span class="comment">//use @EnableCustomDataSource annotation attribute</span></span><br><span class="line">    Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> AnnotationAttributes.fromMap(metaData);</span><br><span class="line">    </span><br><span class="line">    String[] basePackages = attributes.get(<span class="string">&quot;basePackages&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.basePackages = basePackages; <span class="comment">// initialize member variable basePackages</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CustomDataSourceConfiguration을 @Import를 통해 Import하게 되면 @Bean 메서드 보다 setImportMetadata가 먼저 실행됩니다.<br>(이유는 ImportAwareBeanPostProcessor에 의해 @Configuration Bean 초기화 이전에 setImportMetadata 메서드가 실행되기 때문입니다.) </p><blockquote><p>주의: ImportAware를 구현한 Configuration class에는 반드시 @Configuration Annotation을 붙여야 합니다.<br>그래야 Spring 내부적으로 ConfigurationClassPargser가 작동할 때 scan 되어 나중에 ImportAwareBeanPostProcessor에 의해 Post Processing이 될 수 있습니다.</p></blockquote><h1 id="리팩토링-7-아직-끝나지-않았다"><a href="#리팩토링-7-아직-끝나지-않았다" class="headerlink" title="리팩토링 7 - 아직 끝나지 않았다."></a>리팩토링 7 - 아직 끝나지 않았다.</h1><p>아직 끝나지 않았습니다.</p><p>Configuration class를 두 개로 나눈 두번째 이유 @EntityScan, @EnableJpaRepositories의 basePackages에 대한 설정이 다르기 때문입니다.<br>이 문제를 해결하기 위해서는 Spring에서 제공하는 @AliasFor annoataion을 사용해 보았습니다.</p><p><img src="./AliasFor.png" alt="AliasFor"></p><p>@AliasFor Annotation은 Spring 4.2에서 추가된 Annotation입니다. </p><ul><li>AliasFor을 이용해 Attribute의 다른 속성에 값을 바인딩 할 수 있습니다.<br>위의 예시처럼 value로 들어온 값을 attribute의 값에 바인딩</li><li>Annotation의 메타 Annotation의 attribute에 값을 바인딩 할 수 있습니다.<br><strong>(우리는 이 기능을 사용해 보도록 할 것입니다.)</strong></li></ul><blockquote><p>주의: Spring framework 5.2 하위버전에서 AliasFor이 Array에 대해서는 잘 적용이 안되는 이슈가 있었습니다.<br>이 이슈는 Spring framework 5.2, Springboot 2.2.0 이후에는 잘 적용이 됩니다.<br>혹시나 적용이 안되시는 분은 Spring version up을 권장드립니다.</p></blockquote><h2 id="EnableCustomDataSource-수정"><a href="#EnableCustomDataSource-수정" class="headerlink" title="@EnableCustomDataSource 수정"></a>@EnableCustomDataSource 수정</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.Type)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@EntityScan</span> <span class="comment">// meta annotation으로 추가</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span> <span class="comment">// meta annotation으로 추가</span></span><br><span class="line"><span class="meta">@Import(CustomDataSourceConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCustomDataSource &#123;</span><br><span class="line">  <span class="meta">@AliasFor(annotation = EntityScan.class, attribute = &quot;basePackages&quot;)</span></span><br><span class="line">  String[] jpaEntityBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">  <span class="meta">@AliasFor(annotation = EnableJpaRepositories.class, attribute = &quot;basePackages&quot;)</span></span><br><span class="line">  String[] jpaRepositoriesBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@AliasFor annotation은 @Repeatable meta annotation이 없기 때문에 하나의 메서드에 중첩해서 사용할 수 없습니다.<br>그렇기 때문에 @EntityScan에 대한 basePackages를 설정할 수 있는 메서드와<br>@EnableJpaRepositories에 대한 basePacakges를 설정할 수 있는 메서드로 분리 하였습니다.</p><p>위와 같이 설정해 주면<br>jpaEntityBasePackages -&gt; <code>EntityScan.basePackages</code>로 바인딩 됩니다.<br>jpaRepositoriesBasePackages -&gt; <code>EnableJpaRepositories.basePackages</code>로 바인딩 됩니다.<br>물론 EnableCustomDataSource의 attribute로도 사용할 수 있습니다.</p><h2 id="CustomDataSourceConfiguration-수정"><a href="#CustomDataSourceConfiguration-수정" class="headerlink" title="CustomDataSourceConfiguration 수정"></a>CustomDataSourceConfiguration 수정</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomDataSourceConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ImportAware</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String[] basePackages;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setImportMetadata</span><span class="params">(annoatationMetadata: AnnotationMetadata)</span> &#123;</span><br><span class="line">    <span class="comment">//use @EnableCustomDataSource annotation attribute</span></span><br><span class="line">    Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> AnnotationAttributes.fromMap(metaData);</span><br><span class="line">    </span><br><span class="line">    String[] basePackages = attributes.get(<span class="string">&quot;jpaEntityBasePackages&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.basePackages = basePackages; <span class="comment">// initialize member variable basePackages</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>attribute가 변경되어 attribute명을 변경하였습니다.</p><h1 id="리팩토링-8-FlywayDataSource는-어째요"><a href="#리팩토링-8-FlywayDataSource는-어째요" class="headerlink" title="리팩토링 8 - FlywayDataSource는 어째요?"></a>리팩토링 8 - FlywayDataSource는 어째요?</h1><p>Flyway는 Database 자동 구성에 도움을 주는 라이브러리입니다.<br>(저장된 sql을 versioning하고 내부적으로 version관리를 하여 자동으로 Database를 초기화 하도록 해줍니다.)</p><p>이런 FlywayDatasource는 보통 하나의 모듈에서만 초기화 하게됩니다.<br>보통 하나의 DataSource만 사용하는 상황에서는 Flyway를 적용하는 대상도 하나이기 때문에 문제가 안되지만<br>지금과 같은 다중 DataSource를 사용하는 상황에서는 제약이 생길 수 있습니다.</p><p>그래서 @FlywayDataSource annotation을 지정하여 이 DataSource에 Flyway를 적용할 지 말지 결정할 수 있습니다.<br>여기서는 Springboot에서 제공하는 @ConditionalOnProperty를 이용하여 Bean 생성을 해보도록 하겠습니다.</p><p><img src="./ConditionalOnProperty.png" alt="ConditionalOnProperty"></p><ul><li><strong>prefix</strong>: 사용하고자 하는 property의 prefix입니다.</li><li><strong>name</strong>: Condition에 유효한 property인지 테스트할 property명</li><li><strong>havingValue</strong>: prefix + name property의 값이 어떤 value일 경우 조건식이 참이 될지 결정하는 값입니다.</li><li><strong>matchIfMissing</strong>: property를 찾을 수 없는 경우 조건식의 default 값을 정의합니다.</li></ul><h2 id="property-추가"><a href="#property-추가" class="headerlink" title="property 추가"></a>property 추가</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.custom.datasource.flyway.enable</span> = <span class="string">true</span></span><br></pre></td></tr></table></figure><p>이와 같이 custom property를 추가해보겠습니다. (custom datasource에 대한 flyway를 쓸지 말지에 대한 설정입니다.)</p><h2 id="CustomDataSourceConfiguration-수정-1"><a href="#CustomDataSourceConfiguration-수정-1" class="headerlink" title="CustomDataSourceConfiguration 수정"></a>CustomDataSourceConfiguration 수정</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomDataSourceConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ImportAware</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties(prefix = &quot;spring.custom-module.datasource&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> HikariConfig <span class="title function_">hikariConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.custom.datasource.flyway&quot;, </span></span><br><span class="line"><span class="meta">    name = [&quot;enable&quot;],</span></span><br><span class="line"><span class="meta">    havingValue = &quot;true&quot;, </span></span><br><span class="line"><span class="meta">    matchIfMissing = false</span></span><br><span class="line"><span class="meta">  )</span></span><br><span class="line">  <span class="meta">@FlywayDataSource</span></span><br><span class="line">  <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> DataSource <span class="title function_">dataSourceUsingFlyway</span><span class="params">(HikariConfig hikariConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.custom.datasource.flyway&quot;, </span></span><br><span class="line"><span class="meta">    name = [&quot;enable&quot;],</span></span><br><span class="line"><span class="meta">    havingValue = &quot;false&quot;, </span></span><br><span class="line"><span class="meta">    matchIfMissing = true</span></span><br><span class="line"><span class="meta">  )</span></span><br><span class="line">  <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(HikariConfig hikariConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title function_">entityManagerFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">  EntityManagerFactoryBuilder builder,</span></span><br><span class="line"><span class="params">    DataSource dataSource</span></span><br><span class="line"><span class="params">  )</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(dataSource)</span><br><span class="line">      .packages(<span class="string">&quot;com.your.packages.module2&quot;</span>)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> JpaTransactionManager <span class="title function_">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JpaTransactionManager</span>(entityManagerFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setImportMetadata</span><span class="params">(annoatationMetadata: AnnotationMetadata)</span> &#123;</span><br><span class="line">    <span class="comment">//use @EnableCustomDataSource annotation attribute</span></span><br><span class="line">    Map&lt;String, Object&gt; metaData = importingClassMetadata.getAnnotationAttributes(EnableCustomDataSource.class.getName());</span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> AnnotationAttributes.fromMap(metaData);</span><br><span class="line">    </span><br><span class="line">    String[] basePackages = attributes.get(<span class="string">&quot;jpaEntityBasePackages&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.basePackages = basePackages; <span class="comment">// initialize member variable basePackages</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이와 같이 CustomDataSourceConfiguration에서 DataSource Bean을 생성하는 코드를 두개로 하고<br><code>spring.custom.datasource.flyway.enable</code> 값에 따라 자동으로 Bean을 생성하도록 코드를 구성하였습니다.  </p><p>FlywayDataSource를 사용하는 module에만 <code>spring.custom.datasource.flyway.enable</code> 를 추가하여 Bean이 생성되도록 하였습니다.<br>FlywayDataSource를 사용하지 않는 module에는 <code>spring.custom.datasource.flyway.enable</code> 를 설정하지 않고 사용하여<br>일반적인 DataSource만 사용하도록 구성하였습니다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>토비의 스프링 Ver.2</li><li><a href="https://medium.com/@circlee7/spring-conditional-annotation-e288ccf6b536">Spring Conditional annotation</a></li><li><a href="https://docs.spring.io/spring/docs/4.2.0.RC2_to_4.2.0.RC3/Spring%20Framework%204.2.0.RC3/org/springframework/core/annotation/AliasFor.html">Spring AliasFor</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Configuration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Rest Docs를 이용한 API 문서 만들기</title>
      <link href="/2019/08/04/2019-08-04-spring-rest-docs/"/>
      <url>/2019/08/04/2019-08-04-spring-rest-docs/</url>
      
        <content type="html"><![CDATA[<p>Spring Rest API 문서를 자동으로 생성하고자  할 때, 보통 Swagger로 많이 사용하지만<br>이번에는 Spring Rest Docs를 사용하여 API 문서를 자동으로 작성 할 수 있도록 해봤습니다.</p><p>포스팅에 작성된 코드는 <a href="https://github.com/jaehun2841/spring-rest-docs-example">https://github.com/jaehun2841/spring-rest-docs-example</a> 에서 참고하시길 바랍니다.</p><h1 id="Spring-Rest-Docs란"><a href="#Spring-Rest-Docs란" class="headerlink" title="Spring Rest Docs란"></a>Spring Rest Docs란</h1><p>Spring Rest Docs는 테스트 코드를 기반으로 자동으로 API문서를 작성할 수 있게 해주는 프레임워크입니다.<br>그렇기 때문에 반드시 <code>Test가 통과되어야 문서가 작성</code> 된다는 장점이 있습니다.<br>(그렇기 때문에 API Spec이 변경되거나 추가&#x2F;삭제 되는 부분에 대해 항상 테스트 코드를 수정하여야 하며, API 문서가 최신화 될 수 있도록 해줍니다.)<br>기본적으로 asciidoc을 사용하여 문서를 작성합니다 . (asciidoc은 마크다운과 비슷하게 html문서를 작성할 수 있는 언어입니다.)<br>원하는 경우에는 mark down을 사용할 수도 있지만, 이번 포스트에서는 asciidoc을 이용하여 API 문서를 작성해 보도록 하겠습니다.</p><h1 id="Spring-Rest-Docs-Architecture"><a href="#Spring-Rest-Docs-Architecture" class="headerlink" title="Spring Rest Docs Architecture"></a>Spring Rest Docs Architecture</h1><p><img src="./asciidoctor.png" alt="asciidoctor-task"></p><ul><li>Test Case를 수행하면 산출물이 <document-name>.adoc 파일로 &#x2F;build&#x2F;generate-snippets 디렉토리에 생성됩니다. (default path)</li><li>&#x2F;src&#x2F;docs&#x2F;asciidoc 디렉토리에 &#x2F;build&#x2F;generate-snippets에 있는 adoc 파일을 include하여 문서를 생성할 수 있습니다.<ul><li>&#x2F;build&#x2F;generate-snippets&#x2F;*.adoc 파일들은 API Request, Response에 대한 명세들만 있는 파일이고</li><li>&#x2F;src&#x2F;docs&#x2F;asciidoc&#x2F;*.adoc 파일들이 실제 사용자에게 html파일로 변환되어 제공되는 API 문서 파일입니다.</li><li>따라서 &#x2F;src&#x2F;docs&#x2F;asciidoc&#x2F;*.adoc 에 API 문서를 작성하고,<br>필요한 API Request, Response Spec은 자동 생성된 &#x2F;build&#x2F;generate-snippets&#x2F;*.adoc 파일들을 이용해 표현해줍니다.</li><li>이렇게 하면 향후 API Spec이 변경되더라도, 문서를 수정하지 않아도 되는 장점이 있습니다.</li></ul></li><li>이렇게 생성된 asciidoc 문서는 AsciidoctorTask를 통해 html 문서로 processing 되어 &#x2F;build&#x2F;asciidoc&#x2F;html5 하위에 html문서로 생성됩니다.<ul><li>html 문서가 생성되는 기준은 &#x2F;src&#x2F;docs&#x2F;asciidoc&#x2F;*.adoc 파일을 기준으로 생성됩니다.</li></ul></li></ul><h2 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h2><h3 id="x2F-src-x2F-docs-x2F-asciidoc-디렉토리-내에-html로-제공될-문서를-asciidoc으로-작성"><a href="#x2F-src-x2F-docs-x2F-asciidoc-디렉토리-내에-html로-제공될-문서를-asciidoc으로-작성" class="headerlink" title="&#x2F;src&#x2F;docs&#x2F;asciidoc 디렉토리 내에 html로 제공될 문서를 asciidoc으로 작성"></a>&#x2F;src&#x2F;docs&#x2F;asciidoc 디렉토리 내에 html로 제공될 문서를 asciidoc으로 작성</h3><p><img src="./src-template.png" alt="docuement-templates"></p><h3 id="Test-Case의-산출물"><a href="#Test-Case의-산출물" class="headerlink" title="Test Case의 산출물"></a>Test Case의 산출물</h3><ul><li>&#x2F;build&#x2F;generated-snippets 디렉토리 하위에 생성</li><li>Request, Response Spec에 대한 정보를 생성</li><li>&#x2F;src&#x2F;docs&#x2F;asciidoc&#x2F;*.adoc 파일에서 include해서 사용<br><img src="./snippets.png" alt="snippets"><h3 id="x2F-src-x2F-docs-x2F-asciidoc-디렉토리-adoc파일을-기반으로-생성된-html-파일"><a href="#x2F-src-x2F-docs-x2F-asciidoc-디렉토리-adoc파일을-기반으로-생성된-html-파일" class="headerlink" title="&#x2F;src&#x2F;docs&#x2F;asciidoc 디렉토리 adoc파일을 기반으로 생성된 html 파일"></a>&#x2F;src&#x2F;docs&#x2F;asciidoc 디렉토리 adoc파일을 기반으로 생성된 html 파일</h3><img src="./processed-html.png" alt="processed-html"></li></ul><p>자세한 부분은 아래 예시를 따라하면서 보시면 좋을 것 같습니다.</p><h1 id="Spring-Rest-Docs-시작하기"><a href="#Spring-Rest-Docs-시작하기" class="headerlink" title="Spring Rest Docs 시작하기"></a>Spring Rest Docs 시작하기</h1><h2 id="개발-스펙"><a href="#개발-스펙" class="headerlink" title="개발 스펙"></a>개발 스펙</h2><ul><li>Spring Boot 2.1.6.RELEASE</li><li>Junit 5</li><li>Kotlin 1.3.41 (저희 팀에서 코틀린만 써서 코틀린이 편하네요)</li><li>Gradle 5.4.1</li><li>Asciidoctor 1.5.9.2</li></ul><h2 id="Test-Library"><a href="#Test-Library" class="headerlink" title="Test Library"></a>Test Library</h2><p>Spring Rest Docs는 3가지 테스트 라이브러리를 지원합니다.</p><ul><li>MockMvc (@WebMvcTest)</li><li>WebTestClient (Mono &#x2F; Flux, @WebTestClient)</li><li>Rest Assured (IntegrationTest, @SpringBootTest)</li></ul><p>API 문서를 작성할 때 Spring Mvc를 사용하는 환경이라면 가장 가볍게 돌릴 수 있는게 MockMvc를 사용하는 것이라 생각합니다.<br>그래서 이번 포스팅에서는 MockMvc를 사용한 예제로만 진행하도록 하겠습니다.</p><h2 id="Gradle-설정"><a href="#Gradle-설정" class="headerlink" title="Gradle 설정"></a>Gradle 설정</h2><h3 id="asciidoctor-plugin-설정"><a href="#asciidoctor-plugin-설정" class="headerlink" title="asciidoctor plugin 설정"></a>asciidoctor plugin 설정</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        kotlinVersion = <span class="string">&#x27;1.3.41&#x27;</span></span><br><span class="line">        springBootVersion = <span class="string">&quot;2.1.6.RELEASE&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;org.springframework.boot:spring-boot-gradle-plugin:$springBootVersion&quot;</span></span><br><span class="line">        classpath <span class="string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;org.asciidoctor.convert&#x27;</span> version <span class="string">&#x27;1.5.9.2&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;2.1.6.RELEASE&#x27;</span></span><br><span class="line">    id <span class="string">&quot;io.spring.dependency-management&quot;</span> version <span class="string">&quot;1.0.5.RELEASE&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;io.spring.dependency-management&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;kotlin&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&quot;groovy&quot;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&quot;org.springframework.boot&quot;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&quot;io.spring.dependency-management&quot;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&quot;kotlin-kapt&quot;</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">&#x27;com.example&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class="line">sourceCompatibility = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    set(<span class="string">&#x27;snippetsDir&#x27;</span>, file(<span class="string">&quot;build/generated-snippets&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">    testImplementation(<span class="string">&quot;org.springframework.boot:spring-boot-starter-test&quot;</span>) &#123;</span><br><span class="line">        exclude <span class="attr">group:</span> <span class="string">&quot;junit&quot;</span>, <span class="attr">module:</span> <span class="string">&quot;junit&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    testImplementation <span class="string">&quot;org.junit.jupiter:junit-jupiter-api&quot;</span></span><br><span class="line">    testImplementation <span class="string">&quot;org.junit.jupiter:junit-jupiter-params&quot;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&quot;org.junit.jupiter:junit-jupiter-engine&quot;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.springframework.restdocs:spring-restdocs-mockmvc&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&quot;com.nhaarman:mockito-kotlin:1.6.0&quot;</span></span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlinVersion&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kapt &#123;</span><br><span class="line">    useBuildCache = <span class="literal">true</span></span><br><span class="line">    correctErrorTypes = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">    outputs.dir snippetsDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asciidoctor &#123;</span><br><span class="line">    inputs.dir snippetsDir</span><br><span class="line">    dependsOn test <span class="comment">//test Task 이후에 실행될 수 있도록 Dependency를 설정</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asciidoctor.doFirst &#123;</span><br><span class="line">    println <span class="string">&quot;=====start asciidoctor&quot;</span></span><br><span class="line">    <span class="comment">//asciidoctor 실행전 기존에 생성된 API 문서 삭제</span></span><br><span class="line">    delete file(<span class="string">&#x27;src/main/resources/static/docs&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">asciidoctor.doLast &#123;</span><br><span class="line">    println <span class="string">&quot;=====finish asciidoctor&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task copyDocument(<span class="attr">type:</span> Copy) &#123;</span><br><span class="line">    dependsOn asciidoctor</span><br><span class="line">    from file(<span class="string">&quot;build/asciidoc/html5&quot;</span>)</span><br><span class="line">    <span class="comment">// resources/static/docs 로 복사하여 서버가 돌아가고 있을때 /docs/index.html 로 접속하면 볼수 있음</span></span><br><span class="line">    into file(<span class="string">&quot;src/main/resources/static/docs&quot;</span>)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build &#123;</span><br><span class="line">    dependsOn copyDocument</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bootJar &#123;</span><br><span class="line">    archiveName = <span class="string">&#x27;app.jar&#x27;</span></span><br><span class="line">    dependsOn asciidoctor</span><br><span class="line">    <span class="comment">//실제 배포 시, BOOT-INF/classes가 classpath가 됩니다.</span></span><br><span class="line">    from (<span class="string">&quot;$&#123;asciidoctor.outputDir&#125;/html5&quot;</span>) &#123;</span><br><span class="line">        into <span class="string">&quot;BOOT-INF/classes/static/docs&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileKotlin &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        freeCompilerArgs = [<span class="string">&quot;-Xjsr305=strict&quot;</span>]</span><br><span class="line">        jvmTarget = <span class="string">&quot;1.8&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileTestKotlin &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        freeCompilerArgs = [<span class="string">&quot;-Xjsr305=strict&quot;</span>]</span><br><span class="line">        jvmTarget = <span class="string">&quot;1.8&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar.enabled = <span class="literal">false</span></span><br><span class="line">bootJar.enabled = <span class="literal">true</span></span><br><span class="line">bootJar.mainClassName = <span class="string">&#x27;com.example.restdocs.RestdocsApplication&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>testImplementation &#39;org.springframework.restdocs:spring-restdocs-mockmvc&#39;</code> : mockMvc 테스트를 통해 API adoc 파일을 생성해주도록 하는 라이브러리 입니다.</li><li><code>id &#39;org.asciidoctor.convert&#39; version &#39;1.5.9.2&#39;</code> : asciidoc 파일을 html 파일로 processing 해주는 플러그인 입니다.</li><li><code>asciidoctor</code> :  asciidoc 파일을 html 파일로 processing 해주는 Gradle Task를 정의합니다.</li></ul><h2 id="User-API-코드-작성"><a href="#User-API-코드-작성" class="headerlink" title="User API 코드 작성"></a>User API 코드 작성</h2><h2 id="UserController-kt"><a href="#UserController-kt" class="headerlink" title="UserController.kt"></a>UserController.kt</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Suppress(<span class="string">&quot;SpringJavaInjectionPointsAutowiringInspection&quot;</span>)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="string">&quot;/user&quot;</span>)</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>(</span><br><span class="line">        <span class="keyword">val</span> userService: UserService</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(<span class="string">&quot;/&#123;userId&#125;&quot;</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable(value = <span class="string">&quot;userId&quot;</span>)</span> userId: <span class="type">Long</span>)</span></span>: Response&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> searchUser = userService.search(userId)</span><br><span class="line">    <span class="keyword">return</span> Response.success(searchUser)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(<span class="meta">@RequestBody</span> userDto: <span class="type">UserDto</span>)</span></span>: Response&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> createUser = userService.create(User(name = userDto.name, address = userDto.address, age = userDto.age))</span><br><span class="line">    <span class="keyword">return</span> Response.success(createUser)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@PutMapping(<span class="string">&quot;/&#123;userId&#125;&quot;</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">updateUser</span><span class="params">(<span class="meta">@PathVariable(<span class="string">&quot;userId&quot;</span>)</span> userId: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="meta">@RequestBody</span> userDto: <span class="type">UserDto</span>)</span></span>: Response&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> updateUser = userService.update(User(id = userId, name = userDto.name, address = userDto.address, age = userDto.age))</span><br><span class="line">    <span class="keyword">return</span> Response.success(updateUser)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@DeleteMapping(<span class="string">&quot;/&#123;userId&#125;&quot;</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable(value = <span class="string">&quot;userId&quot;</span>)</span> userId: <span class="type">Long</span>)</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    userService.delete(userId)</span><br><span class="line">    <span class="keyword">return</span> Response.success()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping(<span class="string">&quot;/&#123;userId&#125;/role/&#123;roleId&#125;&quot;</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">grantRole</span><span class="params">(<span class="meta">@PathVariable(value = <span class="string">&quot;userId&quot;</span>)</span> userId: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="meta">@PathVariable(value = <span class="string">&quot;roleId&quot;</span>)</span> roleId: <span class="type">Long</span>)</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">     userService.grantRole(userId = userId, roleId = roleId)</span><br><span class="line">    <span class="keyword">return</span> Response.success()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UserService-kt"><a href="#UserService-kt" class="headerlink" title="UserService.kt"></a>UserService.kt</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">search</span><span class="params">(userId: <span class="type">Long</span>)</span></span>: User?</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(user: <span class="type">User</span>)</span></span>: User?</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(user: <span class="type">User</span>)</span></span>: User?</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(userId: <span class="type">Long</span>)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">grantRole</span><span class="params">(userId: <span class="type">Long</span>, roleId: <span class="type">Long</span>)</span></span>: User?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Response-kt"><a href="#Response-kt" class="headerlink" title="Response.kt"></a>Response.kt</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">val</span> code: <span class="built_in">Int</span>,</span><br><span class="line">        <span class="keyword">val</span> message: String,</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span>: T?,</span><br><span class="line">        <span class="keyword">val</span> error: T?</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">success</span><span class="params">()</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; = success(<span class="literal">null</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">success</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>?)</span></span>: Response&lt;T&gt; = Response(<span class="number">200</span>, <span class="string">&quot;OK&quot;</span>, <span class="keyword">data</span>, <span class="literal">null</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">error</span><span class="params">(error: <span class="type">T</span>?)</span></span>: Response&lt;T&gt; = Response(<span class="number">500</span>, <span class="string">&quot;Server Error&quot;</span>, <span class="literal">null</span>, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="User-kt"><a href="#User-kt" class="headerlink" title="User.kt"></a>User.kt</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">        <span class="keyword">val</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">val</span> name: String,</span><br><span class="line">        <span class="keyword">val</span> age: <span class="built_in">Int</span>,</span><br><span class="line">        <span class="keyword">val</span> address: String,</span><br><span class="line">        <span class="keyword">var</span> roles: MutableList&lt;Role&gt; = mutableListOf()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Test-코드-작성"><a href="#Test-코드-작성" class="headerlink" title="Test 코드 작성"></a>Test 코드 작성</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(RestDocumentationExtension::class, SpringExtension::class)</span> <span class="comment">// (1)</span></span><br><span class="line"><span class="meta">@WebMvcTest(UserController::class, secure = false)</span> <span class="comment">// (2)</span></span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span> <span class="comment">// (3)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> mockMvc: MockMvc <span class="comment">// (4)</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@MockBean</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> userService: UserService <span class="comment">// (5)</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> `user search api docs`<span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    given(userService.search((eq(<span class="number">1L</span>))))</span><br><span class="line">            .willReturn(User(<span class="number">1</span>, <span class="string">&quot;배달이&quot;</span>, <span class="number">10</span>, <span class="string">&quot;서울특별시 송파구 올림픽로 295&quot;</span>)) <span class="comment">// (6)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    <span class="keyword">val</span> resultActions = mockMvc.perform(</span><br><span class="line">            RestDocumentationRequestBuilders.<span class="keyword">get</span>(<span class="string">&quot;/user/&#123;userId&#125;&quot;</span>, <span class="number">1</span>)</span><br><span class="line">                    .header(<span class="string">&quot;x-api-key&quot;</span>, <span class="string">&quot;API-KEY&quot;</span>)</span><br><span class="line">                    .accept(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">    ).andDo(MockMvcResultHandlers.print()) <span class="comment">// (7)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//then</span></span><br><span class="line">    resultActions</span><br><span class="line">            .andExpect(status().isOk) <span class="comment">// (8)</span></span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">&quot;user-search&quot;</span>, <span class="comment">// (9)</span></span><br><span class="line">                            getDocumentRequest(), <span class="comment">// (10)</span></span><br><span class="line">                            getDocumentResponse(), <span class="comment">// (11)</span></span><br><span class="line">                            requestHeaders(*header()),  <span class="comment">// (12)</span></span><br><span class="line">                          pathParameters(userIdPathParameter()),  <span class="comment">// (13)</span></span><br><span class="line">                            responseFields(*common())  <span class="comment">// (14)</span></span><br><span class="line">                                    .andWithPrefix(<span class="string">&quot;data.&quot;</span>, *user()) </span><br><span class="line">                                    .andWithPrefix(<span class="string">&quot;data.roles[].&quot;</span>, *role())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;...&#125; <span class="comment">//중략..</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserDto</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;배달이&quot;,</span></span><br><span class="line"><span class="string">        &quot;age&quot;: 10,</span></span><br><span class="line"><span class="string">        &quot;address&quot;: &quot;서울특별시 송파구 올림픽로 295&quot;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">header</span><span class="params">()</span></span>: Array&lt;HeaderDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arrayOf(headerWithName(<span class="string">&quot;x-api-key&quot;</span>).description(<span class="string">&quot;Api Key&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">userIdPathParameter</span><span class="params">()</span></span>: ParameterDescriptor &#123;</span><br><span class="line">    <span class="keyword">return</span> parameterWithName(<span class="string">&quot;userId&quot;</span>).description(<span class="string">&quot;USER ID&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">roleIdPathParameter</span><span class="params">()</span></span>: ParameterDescriptor &#123;</span><br><span class="line">    <span class="keyword">return</span> parameterWithName(<span class="string">&quot;roleId&quot;</span>).description(<span class="string">&quot;ROLE ID&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">common</span><span class="params">()</span></span>: Array&lt;FieldDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arrayOf(</span><br><span class="line">            fieldWithPath(<span class="string">&quot;code&quot;</span>).type(JsonFieldType.NUMBER).description(<span class="string">&quot;응답 코드&quot;</span>),</span><br><span class="line">            fieldWithPath(<span class="string">&quot;message&quot;</span>).type(JsonFieldType.STRING).description(<span class="string">&quot;응답 메세지&quot;</span>),</span><br><span class="line">            subsectionWithPath(<span class="string">&quot;error&quot;</span>).type(JsonFieldType.OBJECT).description(<span class="string">&quot;에러 Data&quot;</span>).optional(),</span><br><span class="line">            subsectionWithPath(<span class="string">&quot;data&quot;</span>).type(JsonFieldType.OBJECT).description(<span class="string">&quot;응답 Data&quot;</span>).optional()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">user</span><span class="params">()</span></span>: Array&lt;FieldDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arrayOf(</span><br><span class="line">            fieldWithPath(<span class="string">&quot;id&quot;</span>).type(JsonFieldType.NUMBER).description(<span class="string">&quot;User ID&quot;</span>),</span><br><span class="line">            fieldWithPath(<span class="string">&quot;name&quot;</span>).type(JsonFieldType.STRING).description(<span class="string">&quot;이름&quot;</span>),</span><br><span class="line">            fieldWithPath(<span class="string">&quot;age&quot;</span>).type(JsonFieldType.NUMBER).description(<span class="string">&quot;나이&quot;</span>),</span><br><span class="line">            fieldWithPath(<span class="string">&quot;address&quot;</span>).type(JsonFieldType.STRING).description(<span class="string">&quot;주소&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">role</span><span class="params">()</span></span>: Array&lt;FieldDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arrayOf(</span><br><span class="line">            fieldWithPath(<span class="string">&quot;id&quot;</span>).type(JsonFieldType.NUMBER).description(<span class="string">&quot;Role ID&quot;</span>).optional(),</span><br><span class="line">            fieldWithPath(<span class="string">&quot;name&quot;</span>).type(JsonFieldType.STRING).description(<span class="string">&quot;Role명&quot;</span>).optional()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> RestApiDocumentUtils &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getDocumentRequest</span><span class="params">()</span></span>: OperationRequestPreprocessor &#123; <span class="comment">// (10)</span></span><br><span class="line">    <span class="keyword">return</span> Preprocessors.preprocessRequest(</span><br><span class="line">            modifyUris()</span><br><span class="line">              .scheme(<span class="string">&quot;http&quot;</span>)</span><br><span class="line">              .host(<span class="string">&quot;user.api.com&quot;</span>)</span><br><span class="line">              .removePort(),</span><br><span class="line">            Preprocessors.prettyPrint()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getDocumentResponse</span><span class="params">()</span></span>: OperationResponsePreprocessor &#123; <span class="comment">// (11)</span></span><br><span class="line">    <span class="keyword">return</span> Preprocessors.preprocessResponse(Preprocessors.prettyPrint())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><ol><li>Junit5에서 Spring Rest Docs를 사용할 때, RestDocumentationExtension::class, SpringExtension::class Extension 두개를 사용합니다.<br>  ExtendWith는 Junit 4 에서 RunWith와 같은 기능입니다.</li><li>@WebMvcTest annotation을 사용하여, mockMvc를 사용할 수 있는 환경을 설정합니다.  </li><li>이 예제에서는 UserController에 대한 테스트와 API문서를 작성하므로, controller를 UserController로 지정합니다.</li><li>spring security를 사용하는 경우, <code>secure=false</code> 옵션을 통해 Spring Security 사용 안함으로 설정할 수 있습니다.</li><li>Spring Rest Docs에 대한 Auto Configuration을 설정합니다.</li><li>mockMvc를 사용하기 위해 MockMvc bean을 Autowiring 해줍니다.</li><li>UserService에 대한 Mocking을 위해 @MockBean annotation을 통해 Test Context에 bean으로 등록해줍니다.</li><li>UserService.search() function에 대한 stubbing을 해줍니다. (호출 시, return 되는 값 지정)</li><li>mockMvc를 이용하여, <code>GET /user/1</code> API를 호출 합니다.</li><li>API 호출 결과에 대해 간단한 status체크 정도로 테스트 항목을 추가했습니다.</li><li>andDo function으로 Asciidoc을 생성하도록 설정합니다.<br>  <code>user-search</code>는 테스트가 수행 된 후, adoc 파일이 생성될 디렉토리 이름입니다.<br>  <code>/build/generate-snippets/user-search/*.adoc</code> path에 adoc 파일이 생성됩니다.</li><li>DocumentRequest에 대한 설정을 추가합니다.</li><li>modifyUris()를 통해 adoc 파일에 어떤 도메인으로 API를 호출 할 지, 정의할 수 있습니다.<br>(Default는 <code>http://localhost:8080</code> 입니다.)</li><li>Request Json을 이쁘장하게 출력하도록 해줍니다</li><li>DocumentResponse에 대한 설정을 추가합니다.</li><li>Response Json을 이쁘장하게 출력하도록 해줍니다</li><li>requestHeader 정보를 추가합니다.</li><li>path parameter 정보를 추가합니다.</li><li>responseFields 정보를 추가합니다.</li></ol><h2 id="Document-생성하기"><a href="#Document-생성하기" class="headerlink" title="Document 생성하기"></a>Document 생성하기</h2><p>asciidoctor를 이용하면 6개의 snippet 파일을 기본적으로 생성해줍니다.</p><h3 id="예시-1"><a href="#예시-1" class="headerlink" title="예시"></a>예시</h3><ul><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/curl-request.adoc</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[source,bash]</span><br><span class="line">----</span><br><span class="line">$ curl &#x27;http://user.api.com/user/1&#x27; -i -X GET \</span><br><span class="line">    -H &#x27;Accept: application/json;charset=UTF-8&#x27; \</span><br><span class="line">    -H &#x27;x-api-key: API-KEY&#x27;</span><br><span class="line">----</span><br></pre></td></tr></table></figure></li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/http-request.adoc</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[source,http,options=&quot;nowrap&quot;]</span><br><span class="line">----</span><br><span class="line">GET /user/1 HTTP/1.1</span><br><span class="line">Accept: application/json;charset=UTF-8</span><br><span class="line">Host: user.api.com</span><br><span class="line">x-api-key: API-KEY</span><br><span class="line"></span><br><span class="line">----</span><br></pre></td></tr></table></figure></li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/http-response.adoc</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[source,http,options=&quot;nowrap&quot;]</span><br><span class="line">----</span><br><span class="line">GET /user/1 HTTP/1.1</span><br><span class="line">Accept: application/json;charset=UTF-8</span><br><span class="line">Host: user.api.com</span><br><span class="line">x-api-key: API-KEY</span><br><span class="line"></span><br><span class="line">----</span><br></pre></td></tr></table></figure></li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/httpie-request.adoc</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[source,bash]</span><br><span class="line">----</span><br><span class="line">$ http GET &#x27;http://user.api.com/user/1&#x27; \</span><br><span class="line">    &#x27;Accept:application/json;charset=UTF-8&#x27; \</span><br><span class="line">    &#x27;x-api-key:API-KEY&#x27;</span><br><span class="line">----</span><br></pre></td></tr></table></figure></li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/request-body.adoc</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[source,http,options=&quot;nowrap&quot;]</span><br><span class="line">----</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;홍길동&quot;</span><br><span class="line">&#125;</span><br><span class="line">----</span><br></pre></td></tr></table></figure></li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/response-body.adoc</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[source,options=&quot;nowrap&quot;]</span><br><span class="line">----</span><br><span class="line">&#123;</span><br><span class="line">  &quot;code&quot; : 200,</span><br><span class="line">  &quot;message&quot; : &quot;OK&quot;,</span><br><span class="line">  &quot;data&quot; : &#123;</span><br><span class="line">    &quot;id&quot; : 1,</span><br><span class="line">    &quot;name&quot; : &quot;배달이&quot;,</span><br><span class="line">    &quot;age&quot; : 10,</span><br><span class="line">    &quot;address&quot; : &quot;서울특별시 송파구 올림픽로 295&quot;,</span><br><span class="line">    &quot;roles&quot; : [ ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;error&quot; : null</span><br><span class="line">&#125;</span><br><span class="line">----</span><br></pre></td></tr></table></figure></li></ul><p>Optional하게 생성되는 snippet도 존재합니다.</p><ul><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/path-parameters.adoc.adoc</code> : Path Parameters에 대한 정보를 표로 나타냅니다.</li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/request-headers.adoc.adoc</code> : request header에 대한 정보를 표로 나타냅니다.</li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/request-fieldadoc</code> : request fields에 대한 정보를 표로 나타냅니다.</li><li><code>&lt;output-directory&gt;/&lt;document-name&gt;/response-fields.adoc</code> : response fields에 대한 정보를 표로 나타냅니다.</li></ul><h3 id="API-Document-생성하기"><a href="#API-Document-생성하기" class="headerlink" title="API Document 생성하기"></a>API Document 생성하기</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ifndef::snippets[]</span><br><span class="line">:snippets: ../../../build/generated-snippets</span><br><span class="line">endif::[]</span><br><span class="line">:doctype: book</span><br><span class="line">:icons: font</span><br><span class="line">:source-highlighter: highlightjs</span><br><span class="line">:toc: left</span><br><span class="line">:toclevels: 4</span><br><span class="line">:sectlinks:</span><br><span class="line">:site-url: /build/asciidoc/html5/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">== Request</span><br><span class="line"></span><br><span class="line">=== [Request URL]</span><br><span class="line">....</span><br><span class="line">GET /user/&#123;userId&#125;</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">=== [Request Headers]</span><br><span class="line">include::&#123;snippets&#125;/user-search/request-headers.adoc[]</span><br><span class="line"></span><br><span class="line">=== [Request Path Parameters]</span><br><span class="line"></span><br><span class="line">include::&#123;snippets&#125;/user-search/path-parameters.adoc[]</span><br><span class="line"></span><br><span class="line">=== [Request HTTP Example]</span><br><span class="line"></span><br><span class="line">include::&#123;snippets&#125;/user-search/http-request.adoc[]</span><br><span class="line"></span><br><span class="line">== Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=== [Response Fields]</span><br><span class="line"></span><br><span class="line">include::&#123;snippets&#125;/user-search/response-fields.adoc[]</span><br><span class="line"></span><br><span class="line">=== [Response HTTP Example]</span><br><span class="line"></span><br><span class="line">include::&#123;snippets&#125;/user-search/http-response.adoc[]</span><br></pre></td></tr></table></figure><ul><li>&#x2F;src&#x2F;docs&#x2F;asciidoc 디렉토리를 생성하고 user-search.adoc 파일을 생성합니다.</li><li>이 파일은 html로 변환될 adoc 파일입니다.</li><li>snippet에 대한 path를 지정하고 <code>include::</code> 를 통해 adoc 파일을 include하여 processing 할 수 있습니다.</li><li>include 된 파일은 include한 부분에 html 태그로 직접 삽입됩니다.</li><li>processing 된 html 파일은 <code>/build/docs/html5</code> 디렉토리에 생성됩니다 (default)</li><li>부가적으로 API 문서에 대한 내용을 작성하여 API 문서를 만들 수 있습니다. (ex: API 설명, 담당자, 주의사항)</li></ul><h1 id="HTML-문서-Serving-해보기"><a href="#HTML-문서-Serving-해보기" class="headerlink" title="HTML 문서 Serving 해보기"></a>HTML 문서 Serving 해보기</h1><p>Spring Rest Docs로 만들어진 API 문서의 최종 형태는 HTML 파일로 제공됩니다.<br>그렇기 때문에 Spring Static Resource Handler를 이용하여 간단하게 html 파일을 Serving하여 웹 브라우져를 통해 사용자에게 API문서를 제공 할 수 있습니다.  </p><p>SpringBoot의 WebMvcConfigure를 상속하여 Configuration을 추가합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.restdocs.configuration</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Configuration</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.<span class="keyword">annotation</span>.ResourceHandlerRegistry</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.<span class="keyword">annotation</span>.WebMvcConfigurer</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span>: <span class="type">WebMvcConfigurer &#123;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addResourceHandlers</span><span class="params">(registry: <span class="type">ResourceHandlerRegistry</span>)</span></span> &#123;</span><br><span class="line">    registry.addResourceHandler(<span class="string">&quot;/docs/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/static/docs/&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 설정을 추가하게 되면<br> <code>localhost:8080/docs/index.html</code>  과 같이 <code>/docs/**</code> 패턴으로 유입되는 url에 대해<br>classpath 하위의 &#x2F;static&#x2F;docs&#x2F; 디렉토리 아래의 파일을 찾아 반환하도록 해줍니다.</p><p><img src="./static-resource-path.png"></p><h1 id="여러가지-Function-사용해보기"><a href="#여러가지-Function-사용해보기" class="headerlink" title="여러가지 Function 사용해보기"></a>여러가지 Function 사용해보기</h1><h2 id="PathParameters"><a href="#PathParameters" class="headerlink" title="PathParameters"></a>PathParameters</h2><ul><li>API의 Path Parameter에 대한 Snippet을 생성합니다. </li><li>&#x2F;build&#x2F;generated-snippets&#x2F;&lt;document-name&gt;&#x2F;path-parameters.adoc 인 파일명으로 생성됩니다.</li><li>pathParameter(parameterWithName(“key 명칭”).description(“key가 의미 하는 내용”)) 으로 코드를 작성합니다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">&quot;user-update&quot;</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(parameterWithName(<span class="string">&quot;userId&quot;</span>).description(<span class="string">&quot;유저 ID&quot;</span>)),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .andWithPrefix(<span class="string">&quot;data.&quot;</span>, *user())</span><br><span class="line">                                    .andWithPrefix(<span class="string">&quot;data.roles[].&quot;</span>, *role())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure><h2 id="requestHeader"><a href="#requestHeader" class="headerlink" title="requestHeader"></a>requestHeader</h2><ul><li>API의 Request Header에 대한 Snippet을 생성합니다.</li><li>&#x2F;build&#x2F;generated-snippets&#x2F;&lt;document-name&gt;&#x2F;request-headers.adoc 인 파일명으로 생성됩니다.</li><li>requestHeader(headerWithName(“header-key명”).description(“header-key가 의미하는 내용”))</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">          .andExpect(status().isOk)</span><br><span class="line">          .andDo(</span><br><span class="line">                  document(</span><br><span class="line">                          <span class="string">&quot;user-grant-role&quot;</span>,</span><br><span class="line">                          getDocumentRequest(),</span><br><span class="line">                          getDocumentResponse(),</span><br><span class="line">                          requestHeaders(headerWithName(<span class="string">&quot;api-auth-key&quot;</span>).description(<span class="string">&quot;API 인증 키&quot;</span>)),</span><br><span class="line">                      pathParameters(userIdPathParameter(), roleIdPathParameter()),</span><br><span class="line">                          responseFields(*common())</span><br><span class="line">                                  .andWithPrefix(<span class="string">&quot;data.&quot;</span>, *user())</span><br><span class="line">                                  .andWithPrefix(<span class="string">&quot;data.roles[].&quot;</span>, *role())</span><br><span class="line">                  )</span><br><span class="line">          )</span><br></pre></td></tr></table></figure><h2 id="fieldWithPath"><a href="#fieldWithPath" class="headerlink" title="fieldWithPath"></a>fieldWithPath</h2><ul><li>API의 Request, Response Snippet을 구성하는 요소를 정의하는 가장 기본적인 function입니다.</li><li>fieldWithPath(“key”) 형태로 API Request, Response 내의 요소를 정의 할 수 있습니다.</li><li>Attributes<ul><li>description(“내용”) : Request, Response 내의 요소의 내용을 정의합니다.</li><li>type(JsonFieldType.TYPE) : Request, Response 내의 요소의 타입을 정의합니다.</li><li>optional() : Request, Response 내의 요소의 필수값 여부를 정의합니다. (optional()를 선언하면 필수값 아님)</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">&quot;user-grant-role&quot;</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter(), roleIdPathParameter()),</span><br><span class="line">                            responseFields(</span><br><span class="line">                            fieldWithPath(<span class="string">&quot;code&quot;</span>).type(JsonFieldType.NUMBER).description(<span class="string">&quot;응답 코드&quot;</span>),</span><br><span class="line">                fieldWithPath(<span class="string">&quot;message&quot;</span>).type(JsonFieldType.STRING).description(<span class="string">&quot;응답 메세지&quot;</span>),</span><br><span class="line">                subsectionWithPath(<span class="string">&quot;error&quot;</span>).type(JsonFieldType.OBJECT).description(<span class="string">&quot;에러 Data&quot;</span>).optional(),</span><br><span class="line">                subsectionWithPath(<span class="string">&quot;data&quot;</span>).type(JsonFieldType.OBJECT).description(<span class="string">&quot;응답 Data&quot;</span>).optional()</span><br><span class="line">      )</span><br><span class="line">                      .andWithPrefix(<span class="string">&quot;data.&quot;</span>, *user())</span><br><span class="line">                      .andWithPrefix(<span class="string">&quot;data.roles[].&quot;</span>, *role())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure><h2 id="subSectionWithPath"><a href="#subSectionWithPath" class="headerlink" title="subSectionWithPath"></a>subSectionWithPath</h2><ul><li>API Request, Response Snippet을 구성하는 요소를 정의하는 function입니다.</li><li>요소의 하위를 선언하고 싶지 않거나, 가변적인 Request, Response가 오는 경우 사용하기 좋습니다.</li><li>subSectionWithPath는 root key가 존재하는 지만 체크하고 하위 key에 대한 체크는 하지 않습니다.</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Parameter validation error&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">4000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;errors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;receivers[0].phone&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;010469090&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;errorMessage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;유효하지 않은 수신자 번호입니다.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>위와 같은 응답이 오는 경우</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">&quot;user-grant-role&quot;</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter(), roleIdPathParameter()),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .and(fieldWithPath(<span class="string">&quot;errors&quot;</span>).type(JsonFieldType.ARRAY).description(<span class="string">&quot;에러 Data&quot;</span>)) <span class="comment">//에러 발생!!</span></span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure><p>아래와 같은 에러가 발생하게 됩니다.<br>에러 내용을 요약하자면, payload에 있는 정보를 문서화 하지 않았다는 에러입니다.<br>즉, errors 하위에 field, value, errorMessage 정보를 문서화 하지 않았기 때문에 발생하는 에러입니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.restdocs.snippet.SnippetException<span class="punctuation">:</span> The following parts of the payload were not documented<span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;errors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;receivers[0].phone&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;010469090&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;errorMessage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;유효하지 않은 수신자 번호입니다.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>하지만 subSectionWithPath를 사용하게 되면 errors 하위에 대한 정보는 문서화 하지 않겠다!를 의미하므로<br>에러가 발생하지 않고, errors 까지만 문서화 됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">&quot;user-grant-role&quot;</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter(), roleIdPathParameter()),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .and(subSectionWithPath(<span class="string">&quot;errors&quot;</span>).type(JsonFieldType.ARRAY).description(<span class="string">&quot;에러 Data&quot;</span>)) </span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure><h2 id="responseField-and"><a href="#responseField-and" class="headerlink" title="responseField().and()"></a>responseField().and()</h2><ul><li>response에 대한 Field정보가 많은 경우 가독성을 해칠 수 있고, Field Snippet에 대한 재사용성이 떨어질 수 있습니다.</li><li>이럴때 and를 사용하면 좋습니다.</li><li>requestField(), responseField() 함수 뒤에 and() 함수를 사용하여 FieldDescriptor에 대한 Concatenation이 가능합니다.</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;배달이&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;서울특별시 송파구 올림픽로 295&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>위와 같이 모든 요소가 1레벨인 Json이 Response로 오는 경우<br>code, message 는 모든 API Response에 대한 공통 요소 입니다.<br>id, name, age, address는 User API Response에만 응답오는 요소라고 할 떄,<br>두 요소에 대한 관리를 별도로 하여 재사용성을 높일 수 있습니다.</p><p>아래와 같이 and를 사용하여 Response에 대한 FieldDesciptor를 concatenation 하여 구성할 수 있습니다. </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">&quot;user-update&quot;</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter()),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .and(*user())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure><h2 id="responseField-andWithPrefix"><a href="#responseField-andWithPrefix" class="headerlink" title="responseField().andWithPrefix()"></a>responseField().andWithPrefix()</h2><ul><li>and()의 사용예제와 동일합니다.</li><li>하지만, andWithPrefix는 key 앞에 prefix를 붙여 depth를 표현할 수 있도록 해줍니다.</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;배달이&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;서울특별시 송파구 올림픽로 295&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>위와 같이 data에 대한 키가 2레벨인 Json이 Response로 오는 경우<br>아래와 같이 and를 사용하여 Response에 대한 FieldDesciptor를 concatination 하여 구성할 수 있습니다. </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">&quot;user-update&quot;</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter()),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .andWithPrefix(<span class="string">&quot;data.&quot;</span>, *user())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure><h2 id="beneathPath"><a href="#beneathPath" class="headerlink" title="beneathPath"></a>beneathPath</h2><ul><li>API를 사용하다 보면 특정 Field의 명세만 별도로 추출하여 문서화 하는 needs가 있을 수 있습니다.</li><li>beneathPath(“data-path”) function을 사용하면 특정 data-path에 대한 field를 별도의 snippet으로 생성해 줍니다.</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;배달이&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;서울특별시 송파구 올림픽로 295&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">&quot;user-search&quot;</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter()),</span><br><span class="line">                            responseFields(</span><br><span class="line">                                    beneathPath(<span class="string">&quot;data&quot;</span>).withSubsectionId(<span class="string">&quot;user&quot;</span>),</span><br><span class="line">                                    *user(),</span><br><span class="line">                                    subsectionWithPath(<span class="string">&quot;roles&quot;</span>).description(<span class="string">&quot;User Role&quot;</span>)</span><br><span class="line">                    )</span><br></pre></td></tr></table></figure><ul><li>data 필드 하위의 내용을 문서화 해줍니다.</li><li>beneathPath(“data”) : data 필드 하위의 내용이라는 Path 지정</li><li>.withSubsectionId(“user”) : response-fields-user.adoc이라고 SubSectionId로 response-fields.adoc 파일이 별도로 만들어 집니다.</li></ul><h1 id="Spring-Rest-Docs-추가-기능"><a href="#Spring-Rest-Docs-추가-기능" class="headerlink" title="Spring Rest Docs 추가 기능"></a>Spring Rest Docs 추가 기능</h1><h2 id="Custom-필드-삽입하기"><a href="#Custom-필드-삽입하기" class="headerlink" title="Custom 필드 삽입하기"></a>Custom 필드 삽입하기</h2><ul><li>Spring Rest Docs에서 기본적으로 제공하는 path, description, optional, type 이외에 다른 메타정보를 추가하고 싶을 때 Custom 필드를 만들어 사용할 수 있습니다.</li><li>AbstractDescriptor에서 제공하는 attributes라는 Map을 이용합니다.</li><li>저는 비고, 최대길이라는 필드를 표현하기 위해 Kotlin Extension Function을 이용하여 기능을 추가해보았습니다.</li><li>기본적으로 AbstractDescriptor의 attributes라는 Map에 key, value라는 내용을 넣어주면 됩니다.<br>(Java에서는 이 방식을 사용하세요)</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : AbstractDescriptor&lt;T&gt;</span>&gt; AbstractDescriptor<span class="type">&lt;T&gt;</span>.<span class="title">remarks</span><span class="params">(remarks: <span class="type">String</span>)</span></span>: T &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.attributes(key(<span class="string">&quot;remarks&quot;</span>).value(remarks))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : AbstractDescriptor&lt;T&gt;</span>&gt; AbstractDescriptor<span class="type">&lt;T&gt;</span>.<span class="title">maxLength</span><span class="params">(length: <span class="type">Int</span>)</span></span>: T &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.attributes(key(<span class="string">&quot;maxLength&quot;</span>).value(length))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">resultActions</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">&quot;user-update&quot;</span>,</span><br><span class="line">                            getDocumentRequest(),</span><br><span class="line">                            getDocumentResponse(),</span><br><span class="line">                            requestHeaders(*header()),</span><br><span class="line">                            pathParameters(userIdPathParameter()</span><br><span class="line">                              .maxLength(<span class="number">10</span>)</span><br><span class="line">                              .remarks(<span class="string">&quot;User ID가 없는 경우는 먼저 생성하세요&quot;</span>)),</span><br><span class="line">                            responseFields(*common())</span><br><span class="line">                                    .andWithPrefix(<span class="string">&quot;data.&quot;</span>, *user())</span><br><span class="line">                                    .andWithPrefix(<span class="string">&quot;data.roles[].&quot;</span>, *role())</span><br><span class="line">                    )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure><p>위의 예제에서는 일단 ParameterDescriptor에 maxLength와 remark 속성을 추가 했습니다.<br>ParameterDescriptor 뿐만 아니라, AbstractDescriptor를 구현하는 모든 Descriptor에 적용이 가능합니다.<br>(FieldDescriptor, SubsectionDescriptor, HeaderDescriptor등…)</p><p>이렇게 추가한 속성을 snippet에 출력해보도록 하겠습니다.<br>위의 예시는 path parameter에 추가한 속성이므로, path-parameters snippet을 override하여 출력해 줄 수 있습니다.  </p><h3 id="path-parameters-snippet-override"><a href="#path-parameters-snippet-override" class="headerlink" title="path-parameters snippet override"></a>path-parameters snippet override</h3><ul><li>&#x2F;test&#x2F;org&#x2F;springframework&#x2F;restdocs&#x2F;templates 하위에 path-parameters.snippet 파일을 새로 등록합니다.</li><li>snippet 파일은 mustache 문법을 사용합니다.</li><li>여기에 제가 추가한 최대길이, 비고 컬럼을 추가하였습니다.</li><li>mustache 문법 중 <code>#maxLength</code> 문법은 maxLength 속성이 존재하는가? 라는 if문과 비슷한 문법입니다.</li><li>반대되는 문법으로 <code>^maxLength</code> 문법은 maxLength 속성이 존재하지 않는가? 라는 문법입니다.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.+&#123;&#123;path&#125;&#125;+</span><br><span class="line">|===</span><br><span class="line">|Parameter|Description|최대길이|비고</span><br><span class="line">&#123;&#123;#parameters&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;`+&#123;&#123;name&#125;&#125;+`&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;&#123;&#123;description&#125;&#125;&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;&#123;&#123;#maxLength&#125;&#125;&#123;&#123;maxLength&#125;&#125;&#123;&#123;/maxLength&#125;&#125;&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;&#123;&#123;#remarks&#125;&#125;&#123;&#123;remarks&#125;&#125;&#123;&#123;/remarks&#125;&#125;&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">&#123;&#123;/parameters&#125;&#125;</span><br><span class="line">|===</span><br></pre></td></tr></table></figure><h3 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h3><p><img src="./add-path-parameter-custom-fields.png" alt="add-path-parameter-custom-fields"></p><h2 id="Custom-Snippet-생성하기"><a href="#Custom-Snippet-생성하기" class="headerlink" title="Custom Snippet 생성하기"></a>Custom Snippet 생성하기</h2><p>API 문서를 작성하다 보면, 특정 API와 관계없는 응답코드나, Status 값에 대한 명세를 정의하고 문서화 해야 할 요구사항이 있을 수 있습니다.<br>그런 경우 Custom Snippet을 생성하여 문서화하면, 별도로 응답코드나 Status가 추가되거나 변경되어도 항상 문서를 최신화 할 수 있습니다.</p><p>생성해야 할 것은 4가지 입니다.</p><ol><li>Test 용 Controller</li><li>Custom Snippet Template 파일</li><li>ResponseCodeSnippet 클래스 (AbstractFieldsSnippet 상속)</li><li>Test Code</li></ol><h3 id="Test용-Controller"><a href="#Test용-Controller" class="headerlink" title="Test용 Controller"></a>Test용 Controller</h3><p>MockMvc 기반에서 생성되는 문서이다 보니 사용하지 않더라도, Test용 Controller가 하나 필요합니다.<br>실제 코드에 영향이 없도록 <code>/test</code> 디렉토리 하위에 Controller를 만들었습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponseCodeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(<span class="string">&quot;/response-code&quot;</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getResponseCode</span><span class="params">()</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Response.success()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Custom-Snippet-Template-파일"><a href="#Custom-Snippet-Template-파일" class="headerlink" title="Custom Snippet Template 파일"></a>Custom Snippet Template 파일</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;title&#125;&#125;</span><br><span class="line">|===</span><br><span class="line">|Code|Message</span><br><span class="line">&#123;&#123;#fields&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;`+&#123;&#123;path&#125;&#125;+`&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">|&#123;&#123;#tableCellContent&#125;&#125;&#123;&#123;description&#125;&#125;&#123;&#123;/tableCellContent&#125;&#125;</span><br><span class="line">&#123;&#123;/fields&#125;&#125;</span><br><span class="line">|===</span><br></pre></td></tr></table></figure><ul><li>title을 변수로 받아서 출력할 예정입니다.</li><li>표에 출력할 필드는 code값과 description입니다.</li></ul><h3 id="ResponseCodeSnippet-클래스"><a href="#ResponseCodeSnippet-클래스" class="headerlink" title="ResponseCodeSnippet 클래스"></a>ResponseCodeSnippet 클래스</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponseCodeSnippet</span></span>(</span><br><span class="line">        name: String, </span><br><span class="line">        descriptors: MutableList&lt;FieldDescriptor&gt;,</span><br><span class="line">        attributes: Map&lt;String, Any&gt;,</span><br><span class="line">        ignoreUndocumentedFields: <span class="built_in">Boolean</span></span><br><span class="line">) : AbstractFieldsSnippet(name, descriptors, attributes, ignoreUndocumentedFields) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getContentType</span><span class="params">(operation: <span class="type">Operation</span>)</span></span>: MediaType? &#123;</span><br><span class="line">    <span class="keyword">return</span> operation.response.headers.contentType</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getContent</span><span class="params">(operation: <span class="type">Operation</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">return</span> operation.response.content</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>name: 생성할 snippet 템플릿의 prefix입니다. (실제 파일은 {name}-fields.snippet 파일로 생성됩니다.)</li></ul><p><img src="./AbstractFieldSnippet-Constructor.png" alt="AbstractFieldSnippet-Constructor"></p><ul><li>descriptors : snippet에 출력될 field 정보들입니다. (예제에서는 ResponseCode 하나하나가 Row가 됩니다.)</li><li>attributes: snippet에 출력할 추가적인 속성입니다.</li></ul><h3 id="Test-Code"><a href="#Test-Code" class="headerlink" title="Test Code"></a>Test Code</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(RestDocumentationExtension::class, SpringExtension::class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(ResponseCodeController::class, secure = false)</span></span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponseCodeDocs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> mockMvc: MockMvc</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> `build response code snippet`<span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    mockMvc.perform(<span class="keyword">get</span>(<span class="string">&quot;/response-code&quot;</span>)</span><br><span class="line">            .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">    ).andDo(MockMvcResultHandlers.print())</span><br><span class="line">            .andExpect(status().isOk)</span><br><span class="line">            .andDo(</span><br><span class="line">                    document(</span><br><span class="line">                            <span class="string">&quot;common&quot;</span>,</span><br><span class="line">                            responseCodeFields(</span><br><span class="line">                                    <span class="string">&quot;response-code&quot;</span>, <span class="comment">//&#123;name&#125;-fields.snippet 이라는 파일명으로 생성</span></span><br><span class="line">                                    Attributes.attributes(Attributes.key(<span class="string">&quot;title&quot;</span>).value(<span class="string">&quot;공통 응답 코드&quot;</span>)),</span><br><span class="line">                                    *convertResponseCodeToFieldDescriptor(ResponseCode.values())</span><br><span class="line">                            )</span><br><span class="line">                    )</span><br><span class="line">            )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">responseCodeFields</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          attributes: <span class="type">Map</span>&lt;<span class="type">String</span>, Any&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="keyword">vararg</span> descriptors: <span class="type">FieldDescriptor</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: ResponseCodeSnippet &#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseCodeSnippet(name, mutableListOf(*descriptors), attributes, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">convertResponseCodeToFieldDescriptor</span><span class="params">(enumTypes: <span class="type">Array</span>&lt;<span class="type">ResponseCode</span>&gt;)</span></span>: Array&lt;FieldDescriptor&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(enumTypes)</span><br><span class="line">            .map &#123;</span><br><span class="line">              fieldWithPath(it.code.toString()).type(JsonFieldType.NUMBER).description(it.message).optional()</span><br><span class="line">            &#125;</span><br><span class="line">            .collect(Collectors.toList())</span><br><span class="line">            .toTypedArray()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="결과-1"><a href="#결과-1" class="headerlink" title="결과"></a>결과</h3><p><img src="./custom-snippet.png" alt="custom-snippet"></p><h3 id="추가"><a href="#추가" class="headerlink" title="추가"></a>추가</h3><p>위의 예시에서는 Custom Field Snippet으로 예시를 들었지만</p><ul><li>AbstractParametersSnippet</li><li>AbstractBodySnippet</li><li>AbstractHeadersSnippet</li></ul><p>위의 AbstractSnippet이 더 있는 걸로 보아 다른 Custom Snippet도 생성할 수 있는 것 같습니다.<br>필요할 때마다 한번씩 써보면 좋겠죠?</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://docs.spring.io/spring-restdocs/docs/current/reference/html5/#introduction">https://docs.spring.io/spring-restdocs/docs/current/reference/html5/#introduction</a></li><li><a href="https://asciidoctor.org/docs/asciidoctor-gradle-plugin/">https://asciidoctor.org/docs/asciidoctor-gradle-plugin/</a></li><li><a href="https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/">https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/</a></li><li><a href="http://woowabros.github.io/experience/2018/12/28/spring-rest-docs.html">http://woowabros.github.io/experience/2018/12/28/spring-rest-docs.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring-Rest-Docs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Event-Driven-Architecture란?</title>
      <link href="/2019/06/23/2019-06-23-event-driven-architecture/"/>
      <url>/2019/06/23/2019-06-23-event-driven-architecture/</url>
      
        <content type="html"><![CDATA[<h1 id="Event-Driven-란"><a href="#Event-Driven-란" class="headerlink" title="Event Driven 란?"></a>Event Driven 란?</h1><p><img src="./EDA.png" alt="EDA"></p><p>Event Driven은 IT 영역에서 오래 사용된 키워드이며, 현재도 그 영향력이 대단하여 2018년 Gartner에서 선정한 유망한 기술 트렌드 중 하나로 뽑히기도 했다.<br>(Top 10 Strategic Technology Trends for 2018: Event-Driven Model)  </p><p>Event Driven이라는 용어는 programming, architecture와 연결되어 다양한 정의로 표현된다.  </p><blockquote><p><strong>EDA (Event-driven architecture)</strong><br>분산된 시스템 간에 이벤트를 생성, 발행 (publishing)하고 발행된 이벤트를 필요로하는 수신자에게 전송된다.<br>이벤트를 수신한 수신자가 이벤트를 처리하는 형태의 시스템 아키텍쳐</p></blockquote><ul><li>Event Driven Pattern - 특정 행동이 자동으로&#x2F;순서에 따라 발생하는 것이 아닌 어떤 일에 대한 반응으로 동작하는 디자인 패턴</li><li>IO Event - 컴퓨터 회로를 구동시키기 위해 발생하는 일  ( ex)  마우스 클릭, 키보드 타이핑, 모바일 터치 등)</li><li>IOT 기기 등의 센서로부터 유입되는 데이터 스트리밍 기반의 동작</li><li>시스템의 내,외부에서 발생한 <strong>주목할 만한 상태의 변화(a significant change in state)</strong></li></ul><p>주로 Event Driven 시스템은 Message Broker(Kafka, Rabbit MQ, Redis)와 결합하여, Message Driven 시스템으로 구성된다.</p><h2 id="EDA-Event-driven-architecture-의-구성요소"><a href="#EDA-Event-driven-architecture-의-구성요소" class="headerlink" title="EDA (Event-driven architecture)의 구성요소"></a>EDA (Event-driven architecture)의 구성요소</h2><p>EDA는 크게 3개의 구성요소로 나누어 볼 수 있다.</p><ul><li>Event generator : 시스템 내,외부의 상태 변화를 감지하여 표준화된 형식의 이벤트를 생성</li><li>Event channel : 이벤트를 필요로 하는 시스템까지 발송</li><li>Event processing engine : 수신한 이벤트를 식별, 적절한 처리를 함. 때에 따라 이벤트 처리의 결과로 또 다른 이벤트를 발생시킬 수 있다.</li></ul><h2 id="Event-Processing-Style"><a href="#Event-Processing-Style" class="headerlink" title="Event Processing Style"></a>Event Processing Style</h2><p>수신한 이벤트를 처리하는 방법에는 세가지 종류가 있다.</p><h3 id="Simple-event-processing"><a href="#Simple-event-processing" class="headerlink" title="Simple event processing"></a>Simple event processing</h3><p>각각의 이벤트가 직접적으로 수행해야할 action과 매핑되어 처리 된다.<br>실시간으로 작업의 흐름을 처리할 때 사용되며, 이벤트 처리 시간과 비용의 손실이 적다.</p><h3 id="Event-Stream-Processing"><a href="#Event-Stream-Processing" class="headerlink" title="Event Stream Processing"></a>Event Stream Processing</h3><p>이벤트를 중요도에 따라  필터링하여 걸러진 이벤트만을 수신자에게 전송.<br>실시간으로 정보의 흐름을 처리할 때 사용되며, 기업에 적용될 경우 신속한 의사 결정을 가능케한다.(BAM)</p><h3 id="Complex-event-processing"><a href="#Complex-event-processing" class="headerlink" title="Complex event processing"></a>Complex event processing</h3><p>일상적인 이벤트의 패턴을 감지하여 더 복잡한 이벤트의 발생을 추론하는 것.<br>예를 들어 ‘주식의 등락’이라는 일상적인 이벤트의 패턴을 감지하여 ‘투자 적기’라는 상위의 이벤트를 추론해 낼 수 있다.</p><h2 id="Event-Driven-Architecture의-장단점"><a href="#Event-Driven-Architecture의-장단점" class="headerlink" title="Event Driven Architecture의 장단점"></a>Event Driven Architecture의 장단점</h2><h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h3><ul><li>Decoupling - 시스템 간의 느슨한 결합이 가능 하므로 분산 시스템, Microservice 환경에서 시스템 간 의존성을 배제 할 수 있다<br>(시스템은 Event Channel인 Message Broker에 대한 의존성만 가진다.)</li><li>다른 시스템의 정보를 알 필요가 없다 - 약속된 Event message를 가지고 상호 정보를 교환한다.</li><li>micro service 단위로 시스템을 분리하기 쉽기 때문에 확장성, 탄력성을 고려하기 쉽다.</li></ul><h3 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h3><ul><li>Broker Dependency - Event를 전송하기 위한 Message Broker에 대한 의존성이 커지기 때문에<br>Message Broker 장애 상황 시, 전체 장애로 이어질 수 있다.</li><li>Transaction 단위가 격리되기 때문에 서비스 장애 발생시 retry&#x2F;rollback을 고려해야 한다.</li><li>시스템 전체 Flow를 파악하기 어렵다. - 명확한 Flow를 보기 위해서는 시스템을 모니터링하여야 한다.</li><li>디버깅이 어렵다.</li></ul><h1 id="Microservice에서의-Event"><a href="#Microservice에서의-Event" class="headerlink" title="Microservice에서의 Event"></a>Microservice에서의 Event</h1><p><img src="./EDM.png" alt="EDM"></p><blockquote><p><strong>EDM(Event Driven Microservice)</strong><br>MSA가 적용된 시스템에서 이벤트 발생시 해당 이벤트 로그를 보관하고 이를 기반으로 동작하며,<br>비동기 통신을 통해 시스템 내 통합(integration)을 수행하는 Architecture </p></blockquote><h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>IT 영역에서의 이벤트는 다양한 정의를 포함하지만, MSA에서 의미하는 이벤트는<br>시스템의 내,외부에서 발생한 <strong>주목할 만한 상태의 변화(a significant change in state)</strong><br>데이터의 생성, 변경, 삭제를 통해 발생하는 서비스의 의미 있는 변화를 의미</p><h2 id="이벤트-로그를-보관"><a href="#이벤트-로그를-보관" class="headerlink" title="이벤트 로그를 보관"></a>이벤트 로그를 보관</h2><ul><li>github를 예시들어 이해하면 이해가 편할 것 같습니다.</li></ul><h3 id="현재의-데이터는-상태-변경의-누적이다"><a href="#현재의-데이터는-상태-변경의-누적이다" class="headerlink" title="현재의 데이터는 상태 변경의 누적이다."></a>현재의 데이터는 상태 변경의 누적이다.</h3><ul><li>github의 commit 한 스냅샷의 연속으로 현재의 소스가 변경</li></ul><h3 id="상태-변경은-이벤트를-의미하고-이를-누적하는-행위는-이벤트-로그를-보관하는-것"><a href="#상태-변경은-이벤트를-의미하고-이를-누적하는-행위는-이벤트-로그를-보관하는-것" class="headerlink" title="상태 변경은 이벤트를 의미하고 이를 누적하는 행위는 이벤트 로그를 보관하는 것"></a>상태 변경은 이벤트를 의미하고 이를 누적하는 행위는 이벤트 로그를 보관하는 것</h3><ul><li>github에 commit &#x3D; Event<br>commit 로그는 이벤트를 보관하는 행위</li></ul><h3 id="보관된-이벤트는-데이터의-현재-상태를-구성하는-근간"><a href="#보관된-이벤트는-데이터의-현재-상태를-구성하는-근간" class="headerlink" title="보관된 이벤트는 데이터의 현재 상태를 구성하는 근간"></a>보관된 이벤트는 데이터의 현재 상태를 구성하는 근간</h3><ul><li>github는 commit이라는 이벤트를 보관하는 store의 역할을 해주며<br>commit의 누적으로 인해 현재의 소스를 구성할 수 있다.</li></ul><h3 id="보관된-이벤트를-바탕으로-장애-발생-또는-특정-요구사항에-따라-지정된-시점으로-복원을-수행"><a href="#보관된-이벤트를-바탕으로-장애-발생-또는-특정-요구사항에-따라-지정된-시점으로-복원을-수행" class="headerlink" title="보관된 이벤트를 바탕으로 장애 발생 또는 특정 요구사항에 따라 지정된 시점으로 복원을 수행"></a>보관된 이벤트를 바탕으로 장애 발생 또는 특정 요구사항에 따라 지정된 시점으로 복원을 수행</h3><ul><li>github는 특정시점으로 롤백 및 revert가 가능</li></ul><h2 id="비동기-통신"><a href="#비동기-통신" class="headerlink" title="비동기 통신"></a>비동기 통신</h2><p>amqp, mqtt, jms 등 메세징 프로토콜을 통한 메세지 큐 방식이 자주 사용됩니다.<br>서비스에서 데이터의 생성,변경,삭제(CUD)를 통해 이벤트가 발생하면 발행 서비스는 <strong>메세지의 형태로 이벤트를 발행</strong>하고, 해당 이벤트에 관심이 있는 서비스에서 구독을 수행합니다.<br>메세지 큐를 사용함으로 requeue&#x2F;dlq(dead letter queue) 등의 기능을 활용할 수 있습니다.</p><h2 id="시스템-내-통합-integration"><a href="#시스템-내-통합-integration" class="headerlink" title="시스템 내 통합(integration)"></a>시스템 내 통합(integration)</h2><p>이상적으로 구현된 MSA는 서비스 간 데이터 참조를 위한 내부 통신이 필요없지만, 현실적으로 서비스 간 내부 통신이 전혀 없는 시스템을 구현하기란 불가능에 가깝습니다. 다양한 사유로 여러 서비스 간 통신을 통해 연동이 발생합니다.</p><h2 id="트랜잭션-관리"><a href="#트랜잭션-관리" class="headerlink" title="트랜잭션 관리"></a>트랜잭션 관리</h2><p>microservice 단위로 분리된 환경이기 때문에 각자 데이터베이스를 적용한 시스템에 대해 데이터 무결성을 보장할 수는 없지만<br>Event를 통해 최종적인 일관성을 유지 할 수는 있습니다.<br><strong>all commit or rollback → eventually consistency</strong> (언젠가는 맞는다.)</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://bigstory.tistory.com/entry/Event-Driven-Architecture">https://bigstory.tistory.com/entry/Event-Driven-Architecture</a></li><li><a href="https://en.wikipedia.org/wiki/Event-driven_architecture">https://en.wikipedia.org/wiki/Event-driven_architecture</a></li><li><a href="https://medium.com/dtevangelist/event-driven-microservice-%EB%9E%80-54b4eaf7cc4a">https://medium.com/dtevangelist/event-driven-microservice-%EB%9E%80-54b4eaf7cc4a</a></li><li><a href="https://www.confluent.io/blog/event-streaming-platform-1">https://www.confluent.io/blog/event-streaming-platform-1</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 88. readObject 메서드는 방어적으로 작성하라</title>
      <link href="/2019/03/17/effective-java-item88/"/>
      <url>/2019/03/17/effective-java-item88/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Item 50에서는 불변인 날짜 범위 클래스를 만드는데 가변인 Date 필드를 이용했다.<br>그래서 불변식을 지키고 불변을 유지하기 위해 생성자와 접근자에서 Date객체를 방어적으로 복사하느라 코드가 상당히 길어졌다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Period</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 시작 시각</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 종료 시각; 시작 시각보다 뒤여야 한다.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException start나 end가 null이면 발행한다.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Period</span><span class="params">(Date start, Date end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = <span class="keyword">new</span> <span class="title class_">Date</span>(start.getTime());</span><br><span class="line">        <span class="built_in">this</span>.end = <span class="keyword">new</span> <span class="title class_">Date</span>(end.getTime());</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.start.compareTo(<span class="built_in">this</span>.end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(start + <span class="string">&quot;가 &quot;</span> + end + <span class="string">&quot;보다 늦다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">start</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(start.getTime()); &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">end</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(end.getTime()); &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> start + <span class="string">&quot;-&quot;</span> + end; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 클래스는 물리적 표현과 논리적 표현이 부합하므로 기본 직렬화를 사용해도 좋다.<br>하지만 이렇게 해서는 주요한 Date의 불변식을 보장하지 못한다.</p><h1 id="필요하다면-매개변수를-방어적으로-복사하라"><a href="#필요하다면-매개변수를-방어적으로-복사하라" class="headerlink" title="필요하다면 매개변수를 방어적으로 복사하라"></a>필요하다면 매개변수를 방어적으로 복사하라</h1><ul><li>readObject 메서드는 실질적으로는 또 다른 public 생성자이기 때문에 생성자와 똑같은 수준으로 주의를 기울여야한다.</li><li>readObject 메서드에서 <strong>인수가 유효한지 검사해야하고 필요하다면 방어적으로 복사하라</strong></li><li>readObject에서 이 작업을 제대로 하지 못하면 공격자는 쉽게 클래스의 불변식을 깨뜨릴 수 있다.</li></ul><h2 id="불변식을-깨뜨릴-용도로-스트림을-조작하면-문제가-생긴다"><a href="#불변식을-깨뜨릴-용도로-스트림을-조작하면-문제가-생긴다" class="headerlink" title="불변식을 깨뜨릴 용도로 스트림을 조작하면 문제가 생긴다"></a>불변식을 깨뜨릴 용도로 스트림을 조작하면 문제가 생긴다</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BogusPeriod</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] serializedForm = &#123;</span><br><span class="line">        (<span class="type">byte</span>)<span class="number">0xac</span>, (<span class="type">byte</span>)<span class="number">0xed</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x73</span>, <span class="number">0x72</span>, <span class="number">0x00</span>, <span class="number">0x06</span>....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Period</span> <span class="variable">p</span> <span class="operator">=</span> (Period) deserialize(serializedForm);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> Object <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] sf)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(sf)).readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>이 코드의 serializedForm에서 상위 비트가 1인 바이트 값들은 byte로 형변환했는데,<br>이는 자바가 바이트 리터럴을 지원하지 않고 byte 타입은 부호가 있는 (signed) 타입이기 때문이다.</li><li>위의 프로그램을 실행하면<br><code>Fri Jan 01 12:00:00 PST 1999 - Sun Jan 01 12:00:00 PST 1984</code>를 출력한다.</li><li>Period를 직렬화할 수 있도록 선언한 것 만으로도 불변식을 깨뜨리는 객체를 만들 수 있다.</li></ul><h1 id="역직렬화-시-불변식을-만족하는-유효성-검사를-해야한다"><a href="#역직렬화-시-불변식을-만족하는-유효성-검사를-해야한다" class="headerlink" title="역직렬화 시, 불변식을 만족하는 유효성 검사를 해야한다."></a>역직렬화 시, 불변식을 만족하는 유효성 검사를 해야한다.</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 불변식을 만족하는지 검사한다.</span></span><br><span class="line">    <span class="keyword">if</span>(start.compareTo(end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(start + <span class="string">&quot;가 &quot;</span> + end + <span class="string">&quot;보다 늦다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위의 if문 추가로 허용되지 않는 Period 인스턴스가 생성되는 일을 막을 수 있지만, 아직도 미묘한 문제가 숨어있다.</li><li>정상 Period 인스턴스에서 시작된 바이트 스트림 끝에 private Date 필드로의 참조를 추가하면 가변 Period 인스턴스를 만들 수 있다.</li></ul><h1 id="가변-공격을-막기위해서는-방어적-복사본을-만들어야-한다"><a href="#가변-공격을-막기위해서는-방어적-복사본을-만들어야-한다" class="headerlink" title="가변 공격을 막기위해서는 방어적 복사본을 만들어야 한다."></a>가변 공격을 막기위해서는 방어적 복사본을 만들어야 한다.</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutablePeriod</span> &#123;</span><br><span class="line">    <span class="comment">//Period 인스턴스</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Period period;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//시작 시각 필드 - 외부에서 접근할 수 없어야 한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Date start;</span><br><span class="line">    <span class="comment">//종료 시각 필드 - 외부에서 접근할 수 없어야 한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Date end;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MutablePeriod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectArrayOutputStream</span>(bos);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//유효한 Period 인스턴스를 직렬화한다.</span></span><br><span class="line">            out.writeObject(<span class="keyword">new</span> <span class="title class_">Period</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 악의적인 &#x27;이전 객체 참조&#x27;, 즉 내부 Date 필드로의 참조를 추가한다.</span></span><br><span class="line"><span class="comment">             * 상세 내용은 자바 객체 직렬화 명세의 6.4절을 참고</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">byte</span>[] ref = &#123;<span class="number">0x71</span>, <span class="number">0</span>, <span class="number">0x7e</span>, <span class="number">0</span>, <span class="number">5</span>&#125;; <span class="comment">// 참조 #5</span></span><br><span class="line">            bos.write(ref); <span class="comment">// 시작 start 필드 참조 추가</span></span><br><span class="line">            ref[<span class="number">4</span>] = <span class="number">4</span>; <span class="comment">//참조 #4</span></span><br><span class="line">            bos.write(ref); <span class="comment">// 종료(end) 필드 참조 추가</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Period 역직렬화 후 Date 참조를 훔친다.</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray()));</span><br><span class="line">            period = (Period) in.readObject();</span><br><span class="line">            start = (Date) in.readObject();</span><br><span class="line">            end = (Date) in.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음 공격 코드를 실행하면 이 공격이 실제로 이뤄지는 모습을 확인할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MutablePeriod</span> <span class="variable">mp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePeriod</span>();</span><br><span class="line">    <span class="type">Period</span> <span class="variable">p</span> <span class="operator">=</span> mp.period;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">pEnd</span> <span class="operator">=</span> mp.end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//시간 되돌리기</span></span><br><span class="line">    pEnd.setYear(<span class="number">78</span>);</span><br><span class="line">    System.out.println(p); <span class="comment">// Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1978</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//60년대로 회귀</span></span><br><span class="line">    pEnd.setYear(<span class="number">60</span>);</span><br><span class="line">    System.out.println(p); <span class="comment">// Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1969</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예시에서 Period 인스턴스는 불변식을 유지한 채 생성됐지만 의도적으로 내부의 값을 수정할 수 있었다.<br>이처럼 변경할 수 있는 Period 인스턴스를 획득한 공격자는 인스턴스가 불변이라고 가정하는 클래스에 넘겨 엄청난 보안 문제를 일으킬 수 있다.</p><p>이 문제의 근원은 <strong>Period의 readObject메서드가 방어적 복사를 충분히 하지 않은 데 있다.</strong><br>객체를 직렬화할 때는 클라이언트가 소유해서는 안 되는 객체 참조를 갖는 필드를 모두 방어적으로 복사해야 한다.<br>따라서 <code>readObject에서는 불변 클래스 안의 모든 private 가변 요소를 방어적으로 복사 해야한다.</code></p><h1 id="readObject-메서드에서는-private-가변요소를-방어-복사하라"><a href="#readObject-메서드에서는-private-가변요소를-방어-복사하라" class="headerlink" title="readObject 메서드에서는 private 가변요소를 방어 복사하라"></a>readObject 메서드에서는 private 가변요소를 방어 복사하라</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 가변 요소들을 방어적으로 복사한다.</span></span><br><span class="line">    start = <span class="keyword">new</span> <span class="title class_">Date</span>(start.getTime());</span><br><span class="line">    end = <span class="keyword">new</span> <span class="title class_">Date</span>(end.getTime());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 불변식을 만족하는지 검사한다.</span></span><br><span class="line">    <span class="keyword">if</span>(start.compareTo(end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(start + <span class="string">&quot;가 &quot;</span> + end + <span class="string">&quot;보다 늦다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>방어적 복사를 유효성 검사보다 앞서 수행하며, Date의 clone 메서드는 사용하지 않았음에 주목하자.  </li><li>두 조치 모두 Period를 공격으로 부터 보호하는데 필요하다. </li><li>또한 final 필드는 방어적 복사가 불가능 하니 주의하자 </li><li>그래서 이 readObject를 사용하려면 start와 end필드에서 final 한정자를 제거해야 한다.</li></ul><h1 id="기본-readObject를-사용해도-되는지에-대한-체크리스트"><a href="#기본-readObject를-사용해도-되는지에-대한-체크리스트" class="headerlink" title="기본 readObject를 사용해도 되는지에 대한 체크리스트"></a>기본 readObject를 사용해도 되는지에 대한 체크리스트</h1><ul><li>transient 필드를 제외한 모든 필드의 값을 매개변수로 받아 유효성 검사 없이 필드에 대입하는 public 생성자를 추가해도 괜찮은가?<ul><li>아니오 -&gt; 커스텀 readObject 메서드를 만들어 유효성 검사와 방어적 복사를 수행</li><li>예 -&gt; 기본 readObject 메서드 사용</li></ul></li><li>직렬화 프록시 패턴을 사용해도 된다 .<ul><li>역직렬화를 안전하게 만드는 데 필요한 노력을 경감해 준다. (권장)</li></ul></li></ul><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>readObject 메서드를 작성할 때는 언제나 public 생성자를 만든다고 생각하고 만들어야 한다.</li><li>private 이어야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사하라 (불변 클래스 내의 가변 요소)</li><li>모든 불변식을 검사하여 어긋나는 게 발견되면 InvalidObjectException을 던진다.<br>방어적 복사 다음에는 반드시 불변식 검사가 뒤따라야 한다.</li><li>역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면 ObjectInputValidation 인터페이스를 사용하라</li><li>직접적이든 간접적이든 readObject메서드에서 재정의 가능한 메서드를 호출해서는 안된다.</li><li>재정의 가능한 메서드가 재정의되면 하위 클래스의 상태가 완전히 역직렬화 되기전에 하위 클래스에서 재정의된 메서드가 실행되므로<br>프로그램 오작동을 일으킬 수 있다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 88. readObject 메서드는 방어적으로 작성하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 87. 커스텀 직렬화 형태를 고려해보라</title>
      <link href="/2019/03/17/effective-java-item87/"/>
      <url>/2019/03/17/effective-java-item87/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>개발 일정에 쫓기는 상황에서는 API 설계에 노력을 집중하는 편이 낫다.<br>다음 릴리스에서 세부적인 기능을 제대로 구현하고 이번 릴리즈는 대충 동작만하게 하면 된다는 뜻이다.<br>하지만 클래스가 Serializable을 구현하고 기본 직렬화 형태를 사용한다면 다음 릴리즈때 버리려 한 현재의 구현에 영원히 발이 묶이게 된다.<br>(현재의 기본 직렬화 형태를 버릴 수 없게 되기 때문이다.)</p><h1 id="먼저-고민해보고-괜찮다고-판단될-때만-기본-직렬화-형태를-사용하라"><a href="#먼저-고민해보고-괜찮다고-판단될-때만-기본-직렬화-형태를-사용하라" class="headerlink" title="먼저 고민해보고 괜찮다고 판단될 때만 기본 직렬화 형태를 사용하라"></a>먼저 고민해보고 괜찮다고 판단될 때만 기본 직렬화 형태를 사용하라</h1><ul><li>기본 직렬화 형태는 유연성,  성능, 정확성, 측면에서 신중히 고민한 후 합당할 때만 사용해야 한다.  </li><li>직접 설계하더라도 기본 직렬화 형태와 거의 같은 결과가 나올 경우에만 기본 형태를 써야 한다. </li><li>기본 직렬화 형태는 그 객체를 루트로 하는 객체 그래프의 물리적 모습을 나름 효율적으로 인코딩한다.</li><li>객체가 포함한 데이터들과 그 객체에서부터 시작해 접근할 수 있는 모든 객체를 담아내며 객체들이 연결된 위상(topology)까지 기술한다.</li><li>하지만 이상적인 직렬화 형태는 <strong>물리적인 모습과 독립된 논리적인 모습만을 표현해야 한다.</strong></li></ul><h1 id="객체의-물리적-표현과-논리적-내용이-같다면-기본-직렬화-형태라도-무방하다"><a href="#객체의-물리적-표현과-논리적-내용이-같다면-기본-직렬화-형태라도-무방하다" class="headerlink" title="객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다"></a>객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Name</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 성. null이 아니어야함</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lastName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 이름. null이 아니어야 함.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String firstName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 중간이름. 중간이름이 없다면 null.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String middleName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>기본 직렬화 형태가 적합하다고 결정했더라고 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다.</li><li>Name의 3개의 필드는 private임에도 불구하고 문서화 주석이 달려있다. </li><li>이 필드들은 결국 클래스의 직렬화 형태에 포함되는 공개 API에 속하며 공개 API는 모두 문서화 해야 하기 때문이다. </li><li>private 필드의 설명을 API 문서에 포함하라고 자바독에 알려주는 역할은 @serial태그가 한다.</li><li>@serial 태그로 기술한 내용은 API 문서에서 직렬화 형태를 설명하는 특별한 페이지에 기록된다.</li></ul><h1 id="기본-직렬화-형태에-적합하지-않은-클래스"><a href="#기본-직렬화-형태에-적합하지-않은-클래스" class="headerlink" title="기본 직렬화 형태에 적합하지 않은 클래스"></a>기본 직렬화 형태에 적합하지 않은 클래스</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringList</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Entry</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        String data;</span><br><span class="line">        Entry next;</span><br><span class="line">        Entry previous;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>논리적으로는 이클래스는 일련의 문자열을 표현한다.<br>물리적으로는 문자열을 이중 연결 리스트로 연결했다. 이 클래스에 기본 직렬화 형태를 사용하면 각 노드의 양방향 연결 정보를 포함해 모든 엔트리(Entry)를 철두철미하게 기록한다.</p><h1 id="객체의-물리적-표현과-논리적-표현의-차이가-클-때-기본-직렬화-형태를-사용하는-경우-생기는-문제"><a href="#객체의-물리적-표현과-논리적-표현의-차이가-클-때-기본-직렬화-형태를-사용하는-경우-생기는-문제" class="headerlink" title="객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하는 경우 생기는 문제"></a>객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하는 경우 생기는 문제</h1><h2 id="공개-API가-현재의-내부-표현-방식에-영구히-묶인다"><a href="#공개-API가-현재의-내부-표현-방식에-영구히-묶인다" class="headerlink" title="공개 API가 현재의 내부 표현 방식에 영구히 묶인다."></a>공개 API가 현재의 내부 표현 방식에 영구히 묶인다.</h2><ul><li>앞의 예에서 private 클래스인 StringList.Entry가 공개 API가 되어버린다.</li><li>다음 릴리스에서 내부 표현 방식을 바꾸더라도 StringList 클래스는 여전히 연결 리스트로 표현된 입력도 처리할 수 있어야 한다.</li><li>즉 연결 리스트를 더 이상 사용하지 않더라도 관련 코드를 제거할 수 없다.</li></ul><h2 id="너무-많은-공간을-차지할-수-있다"><a href="#너무-많은-공간을-차지할-수-있다" class="headerlink" title="너무 많은 공간을 차지할 수 있다."></a>너무 많은 공간을 차지할 수 있다.</h2><ul><li>앞 예의 직렬화 형태는 연결 리스트의 모든 엔트리와 연결 정보까지 기록했지만, 엔트리와 연결 정보는 내부 구현에 해당하니 직렬화 형태에 포함할 가치가 없다.</li><li>이처럼 직렬화 형태가 너무 커져서 디스크에 저장하거나 네트워크로 전송하는 속도가 느려진다.</li></ul><h2 id="시간이-너무-많이-걸릴-수-있다"><a href="#시간이-너무-많이-걸릴-수-있다" class="headerlink" title="시간이 너무 많이 걸릴 수 있다."></a>시간이 너무 많이 걸릴 수 있다.</h2><ul><li>직렬화 로직은 객체 그래프의 위상에 관한 정보가 없으니 그래프를 직접 순회해볼 수밖에 없다.</li><li>앞의 예제는 간단히 다음 참조를 따라가 보는 정도로 충분하다.</li></ul><h2 id="스택-오버플로를-일으킬-수-있다"><a href="#스택-오버플로를-일으킬-수-있다" class="headerlink" title="스택 오버플로를 일으킬 수 있다."></a>스택 오버플로를 일으킬 수 있다.</h2><ul><li>기본 직렬화 과정은 객체 그래프를 재귀 순회하는데 중간정도 크기의 객체 그래프에서도 스택 오버플로 에러가 날 수 있다.</li><li>그때그때 다른 시점에서 스택 오버플로가 날 수 있고, 어떤 플랫폼에서는 에러가 나지 않을 수도 있다.</li></ul><h1 id="합리적인-커스텀-직렬화-형태를-갖춘-StringList"><a href="#합리적인-커스텀-직렬화-형태를-갖춘-StringList" class="headerlink" title="합리적인 커스텀 직렬화 형태를 갖춘 StringList"></a>합리적인 커스텀 직렬화 형태를 갖춘 StringList</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringList</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">Entry</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 이제는 직렬화되지 않는다.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">        String data;</span><br><span class="line">        Entry next;</span><br><span class="line">        Entry previous;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 지정한 문자열을 이 리스트에 추가한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 이 &#123;<span class="doctag">@code</span> StringList&#125; 인스턴스를 직렬화한다.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> 이 리스트의 크기(포함된 문자열의 개수)를 기록한 후</span></span><br><span class="line"><span class="comment">     * (&#123;<span class="doctag">@code</span> int&#125;), 이어서 모든 원소를(각각은 &#123;<span class="doctag">@code</span> String&#125;)</span></span><br><span class="line"><span class="comment">     * 순서대로 기록한다.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="comment">//기본 직렬화를 수행한다.</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        s.writeInt(size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 커스텀 역직렬화를 수행한다.</span></span><br><span class="line">        <span class="comment">// 모든 원소를 올바른 순서로 기록한다.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> head; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">            s.writeObject(e.data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//기본 역직렬화를 수행한다.</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numElements</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 커스텀 역직렬화 부분</span></span><br><span class="line">        <span class="comment">// 모든 원소를 읽어 이 리스트에 삽입한다.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numElements; i++) &#123;</span><br><span class="line">            add((String) s.readObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>StringList의 필드 모두가 transient더라도 writeObject와 readObject는 각각 먼저 defaultWriteObject와 defaultReadObject를 호출한다.</p></li><li><p>클래스의 인스턴스가 모두 transient더라도 defaultWriteObject와 defaultReadObject를 호출해줘야 한다.<br>(향후 릴리즈에서 transient가 아닌 필드가 추가되더라도 상호 호환되기 때문이다)</p></li><li><p>신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화하면 새로 추가된 필드들은 무시될 것이다.</p></li><li><p>구버전 readObject 메서드에서 defaultReadObject를 호출하지 않는다면 역직렬화할 때 StreamCorruptedException이 발생할 것이다.</p></li><li><p>writeObject는 private 메서드임에도 문서화 주석이 달려 있다.<br>이 private 메서드는 직렬화 형태에 포함되는 공개 API에 속하며 공개 API는 모두 문서화 해야한다.</p></li><li><p>메서드에 달린 @serialData 태그는 자바독 유틸리티에게 이 내용을 직렬화 형태 페이지에 추가하도록 요청한다.</p></li><li><p>개선한 StringList는 원래버전의 절반정도의 공간을 차지하며 수행속도 또한 두 배 이상 빠르다.</p></li><li><p>개선한 StringList는 스택 오버플로 에러가 발생하지 않는다. (크기의 제한이 사라짐)</p></li><li><p>객체를 직렬화한 후 역직렬화하면 원래 객체를 그 불변식까지 포함해 제대로 복원해낸다는 점에서 정확하다 할 수 있다.</p></li><li><p>하지만 불변식이 세부 구현에 따라 달라지는 객체에서는 이 정확성마저 깨질 수 있다.</p></li></ul><h1 id="객체의-불변식이-깨지는-경우에는-직렬화를-주의해야한다"><a href="#객체의-불변식이-깨지는-경우에는-직렬화를-주의해야한다" class="headerlink" title="객체의 불변식이 깨지는 경우에는 직렬화를 주의해야한다."></a>객체의 불변식이 깨지는 경우에는 직렬화를 주의해야한다.</h1><p>해시 테이블을 예로 생각해보면 이해할 수 있다.  해시 테이블은 물리적으로는 key-value 엔트리를 담은 해시 버킷을 차례로 나열한 형태다.<br>어떤 엔트리를 어떤 버킷에 담을지는 key에서 구한 hashcode가 결정하는데 <strong>그 계산 방식은 구현에 따라 달라질 수 있다.</strong><br>혹은 계산할 때마다 달라지기도 한다.<br>따라서 해시테이블을 직렬화한 후 역직렬화하면 불변식이 심각하게 훼손된 객체들이 생겨날 수 있는 것이다.</p><h1 id="객체의-논리적-상태와-무관한-필드라고-확신하면-transient-한정자를-생략하라"><a href="#객체의-논리적-상태와-무관한-필드라고-확신하면-transient-한정자를-생략하라" class="headerlink" title="객체의 논리적 상태와 무관한 필드라고 확신하면 transient 한정자를 생략하라"></a>객체의 논리적 상태와 무관한 필드라고 확신하면 transient 한정자를 생략하라</h1><ul><li>기본 직렬화를 수용하든 하지 않든 defaultWriteObject 메서드를 호출하면 transient로 선언하지 않은 모든 인스턴스 필드가 직렬화된다.</li><li>따라서 transient로 선언해되 되는 인스턴스 필드에는 모두 transient를 붙여야 한다.</li><li>JVM을 실행할 때마다 값이 달라지는 필드도 transient를 붙여야 한다.</li><li>커스텀 직렬화 형태를 사용한다면 앞서의 StringList 처럼 대부분의(혹은 모든) 인스턴스 필드를 transient로 선언해야 한다.</li></ul><h1 id="동기화-메커니즘을-직렬화에도-적용해야-한다"><a href="#동기화-메커니즘을-직렬화에도-적용해야-한다" class="headerlink" title="동기화 메커니즘을 직렬화에도 적용해야 한다."></a>동기화 메커니즘을 직렬화에도 적용해야 한다.</h1><p>모든 메서드를 synchronized로 선언하여 스레드 안전하게 만든 객체에서 기본 직렬화를 사용하려면<br>writeObject도 다음 코드 처럼 synchronized로 선언해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>writeObject 메서드 안에서 동기화 하고 싶다면 클래스의 다른 부분에서 사용하는 락 순서를 똑같이 따라야 한다.<br>그렇지 않으면 교착상태 (resource-ordering deadlock)에 빠질 수 있다.</p><h1 id="직렬-버전-UID를-명시적으로-부여하자"><a href="#직렬-버전-UID를-명시적으로-부여하자" class="headerlink" title="직렬 버전 UID를 명시적으로 부여하자"></a>직렬 버전 UID를 명시적으로 부여하자</h1><p>어떤 직렬화 형태를 사용하든 직렬 가능 클래스에 모두 직렬 버전 UID를 명시적으로 부여하자.<br>이렇게 하면 직렬 버전 UID가 일으키는 잠재적인 호환성 문제가 사라진다.<br>성능도 조금 빨라지는데 직렬 버전 UID를 명시하지 않으면 런타임에 이 값을 생성하느라 복잡한 연산을 수행하기 때문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">232923283928929</span>;</span><br></pre></td></tr></table></figure><p>위와 같은 형태로 사용하면 된다.<br>Intellij 에서는 alt+insert 단축키를 누르면 serialVersionUID를 자동으로 생성해 주는 메뉴가 있다.<br>기존 클래스를 구버전으로 직렬화된 인스턴스와 호환성을 유지한 채 사용하고 싶다면<br>기존 클래스를 구버전에서 사용한 자동 생성된 값을 그대로 사용해야 한다.  </p><h2 id="주의할-점"><a href="#주의할-점" class="headerlink" title="주의할 점"></a>주의할 점</h2><p><strong>직렬버전 UID는 클래스의 명세가 변경되면 자동 생성된 값이 바뀌기 때문에 이부분도 주의해야 한다.</strong><br>구버전과 호환이 되지 않아 역직렬화가 되지 않는다.<br>기존 버전의 직렬화된 인스턴스를 역직렬화할 때 InvalidClassException이 던져질 것이다.<br>구버전으로 직렬화된 인스턴스들과 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID를 절대 수정하면 안된다.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>클래스를 직렬화하기로 했다면 어떤 직렬화 형태를 사용할지 심사숙고 해야한다.</li><li>자바의 기본 직렬화 형태는 객체를 직렬화한 결과가 해당 객체의 논리적 표현에 부합할 때만 사용하고 그렇지 않으면 객체를 적절히 설명하는 커스텀 직렬화 형태를 고안해야 한다.</li><li>직렬화 형태도 공개 메서드를 설계할 때에 준하는 시간을 들여 설계 해야 한다.</li><li>한번 공개된 메서드는 향후 릴리즈에서 제거할 수 없듯이 직렬화 형태에 포함된 필드도 마음대로 제거할 수 없다.</li><li>직렬화 호환성을 유지하기 위해 영원히 지원해야 한다.</li><li>잘못된 직렬화 형태를 선택하면 해당 클래스의 복잡성과 성능에 영구히 부정적인 영향을 남긴다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 87. 커스텀 직렬화 형태를 고려해보라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 79. 과도한 동기화는 피하라</title>
      <link href="/2019/03/11/effective-java-item79/"/>
      <url>/2019/03/11/effective-java-item79/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.<br><strong>응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.</strong>  </p><ul><li>동기화(synchronized) 된 코드 블럭 안에서는 재정의 가능한 메서드를 호출해선 안된다.</li><li>클라이언트가 넘겨준 함수객체를 호출해서도 안된다.</li><li>이런 메서드는 동기화도니 클래스 관점에서 외계인 메서드(alien method)라고 칭한다.<br>(무슨일을 할지 모르니, 이 메서드가 예외를 발생시키거나, 교착상태를 만들거나, 데이터를 훼손시킬 수 있다.)</li></ul><h1 id="외계인-메서드"><a href="#외계인-메서드" class="headerlink" title="외계인 메서드"></a>외계인 메서드</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObservableSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">ForwardingSet</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObservableSet</span><span class="params">(Set&lt;E&gt; set)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserver&lt;E&gt;&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            observers.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">return</span> observers.remove(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyElementAdded</span><span class="params">(E element)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">for</span>(SetObserver&lt;E&gt; observer : observers) &#123;</span><br><span class="line">                observer.added(<span class="built_in">this</span>, element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">added</span> <span class="operator">=</span> <span class="built_in">super</span>.add(element);</span><br><span class="line">        <span class="keyword">if</span>(added) &#123;</span><br><span class="line">            notifyElementAdded(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> added;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : c) &#123;</span><br><span class="line">            result |= add(element); <span class="comment">//notifyElementAdded를 호출</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>관찰자들은 addObserver와 removeObserver 메서드를 호출해 구독을 신청하거나 해지한다.</li><li>두 경우 다음 콜백 인터페이스의 인스턴스를 메서드에 전달</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SetObserver</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//ObservableSet에 원소가 더해지면 호출된다.</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">added</span><span class="params">(ObservableSet&lt;E&gt; set, E element)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>이 인터페이스는 구조적으로 BiConsumer&lt;ObservableSet<E>,  E&gt;와 똑같다.</li><li>커스텀 함수형 인터페이스를 정의한 이유는 이름이 더 직관적이고 다중 콜백을 지원하도록 확장할 수 있기 때문이다.</li></ul><h1 id="외계인-메서드-예제1"><a href="#외계인-메서드-예제1" class="headerlink" title="외계인 메서드 - 예제1"></a>외계인 메서드 - 예제1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ObservableSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">ObservableSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">    set.addObserver(<span class="keyword">new</span> <span class="title class_">SetObserver</span>&lt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">added</span><span class="params">(ObservableSet&lt;Integer&gt; s, Integer e)</span> &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            <span class="keyword">if</span>(e == <span class="number">23</span>) &#123;</span><br><span class="line">                s.removeObserver(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        set.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>s.removeObserver에 this를 넘겨야하는데 람다에서는 방법이 없으므로 익명클래스의 형태로 사용</li><li>이 프로그램은 0~23까지 출력한 후 Observer 자신을 구독해제 한 후 아무런 로그도 뜨지 않고 종료할 것 같다.</li><li>하지만 그렇지 않다. 프로그램은 0~23까지 출력한 후 <code>ConcurrentModificationException</code> 을 던진다.</li><li>왜냐하면 Observer의 added 메서드 호출이 일어난 시점이 notifyElementAdded가 Observer들의 리스트를 순회하는 도중이기 때문이다.</li><li>added 메서드 -&gt; ObservableSet.removeObserver를 호출 -&gt; observers.remove 호출</li><li>리스트에서 원소를 제거하려는데 마침 지금은 이 원소를 순회하는 중 <strong>(허용되지 않은 동작)</strong></li><li>notifyElementAdded 메서드에서 수행하는 순회는 동기화 블록 안에 있으므로 동시 수정이 일어나지 않지만<br>정작 자신이 콜백을 거쳐 되돌아와 수정하는 것을 막진 못한다.</li></ul><h1 id="외계인-메서드-예제-2"><a href="#외계인-메서드-예제-2" class="headerlink" title="외계인 메서드 - 예제 2"></a>외계인 메서드 - 예제 2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set.addObserver(<span class="keyword">new</span> <span class="title class_">SetObserver</span>&lt;&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">added</span><span class="params">(ObservableSet&lt;Integer&gt; s, Integer e)</span> &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">if</span>(e == <span class="number">23</span>) &#123;</span><br><span class="line">            <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                exec.submit(() -&gt; s.removeObserver(<span class="built_in">this</span>)).get(); <span class="comment">//여기서 lock이 걸려서 못들어감</span></span><br><span class="line">                <span class="comment">//하지만 메인 스레드는 너의 작업을 기다리고 있어</span></span><br><span class="line">            &#125; <span class="keyword">catch</span>(ExecutionException | InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(ex);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>이 프로그램을 실행하면 에러는 나진 않지만 교착상태(Dead-lock)에 빠진다.</li><li>백그라운드 스레드가 s.removeObserver를 호출하면 Observer를 잠그려 시도하지만 락을 얻을 수 없다.<br>(메인스레드가 이미 락을 쥐고 있기 때문 - removeObserver는 synchronized 키워드가 달려있어서 실행 시 락이 걸린다.)</li><li>그와 동시에 메인 스레드는 백그라운드 스레드가 Observer를 제거하기만을 기다리는 중이다.</li></ul><h1 id="교착상태-해결방법"><a href="#교착상태-해결방법" class="headerlink" title="교착상태 해결방법"></a>교착상태 해결방법</h1><p>자바 언어의 락은 재진입(reentrant)을 허용하므로 교착상태에 빠지지는 않는다.<br>재진입 가능 락은 객체 지향 멀티스레드 프로그램을 쉽게 구현 할 수 있도록 해준다.<br>하지만 응답 불가(교착상태)가 될 상황을 안전 실패(데이터 훼손)으로 변모시킬 수도 있다.  </p><p>이런 경우 외계인 메서드 호출을 동기화 블록 바깥으로 옮기면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyElementAdded</span><span class="params">(E element)</span> &#123;</span><br><span class="line">    List&lt;SetObserver&lt;E&gt;&gt; snapshot = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(observers) &#123;</span><br><span class="line">        snapshot = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(observers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SetObserver&lt;E&gt; observer : snapshot) &#123;</span><br><span class="line">        observer.added(<span class="built_in">this</span>, element); <span class="comment">//외계인 메서드를 동기화 블록 바깥으로 옮겼다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>외계인 메서드 호출을 동기화 블록 바깥으로 옮기는 것 보다 더 나은 방법은 java.util.concurrent 패키지의 CopyOnWriteArrayList를 사용하는 것이 좋다.<br>내부를 변경하는 작업은 항상 깨끗한 복사본을 만들어 수행한다.<br>내부의 배열은 절대 수정되지 않아 락이 없어 빠르다.<br>다른 용도로 쓰인다면 매번 복사해서 느리겠지만, 수정할 일은 드물고 순회만 빈번히 일어나는 Observer 리스트 용으로는 딱이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserser&lt;E&gt;&gt; observers = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> &#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeObserver</span><span class="params">(SetObserver&lt;E&gt; observer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> observers.remove(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyElementAdded</span><span class="params">(E element)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SetObserver&lt;E&gt; observer : observers) &#123;</span><br><span class="line">         observers.added(<span class="built_in">this</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="동기화의-성능"><a href="#동기화의-성능" class="headerlink" title="동기화의 성능"></a>동기화의 성능</h1><p>자바의 동기화 비용은 빠르게 낮아져 왔지만, 과도한 동기화를 피하는일은 오히려 과거 어느 때보다 중요하다.<br>멀티코어가 일반화된 오늘날 과도한 동기화가 초래하는 진짜 비용은 락을 얻는데 드는 CPU 시간이 아니다.<br>서로 스레드끼리 경쟁하는 Race Condition에 낭비가 발생한다.  </p><ul><li>병렬로 실행할 기회를 잃는다.</li><li>모든 코어가 메모리를 일관되게 보기위한 지연시간이 진짜 비용</li><li>가상머신의 코드최적화를 제한하는 점도 숨은 비용</li></ul><h2 id="가변-클래스를-작성하는-경우-동기화에-대해-고려할-점"><a href="#가변-클래스를-작성하는-경우-동기화에-대해-고려할-점" class="headerlink" title="가변 클래스를 작성하는 경우 동기화에 대해 고려할 점"></a>가변 클래스를 작성하는 경우 동기화에 대해 고려할 점</h2><ol><li>동기화를 전혀 하지 말고 가변 클래스를 동시에 사용해야하는 클래스가 외부에서 동기화하자</li><li>동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.<br>(단 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 두번째 방법을 쓴다)</li></ol><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>기본 규칙은 동기화 영역에서 가능한 한 일을 적게하는 것이다.<br>(락을 얻고 공유 데이터를 검사하고, 필요하면 수정하고, 락을 놓는다.)</li><li>오래 걸리는 작업이라면 동기화 영역 밖으로 옮기는 방법을 찾아보자.</li><li>여러 스레드가 호출할 가능성이 있는 메서드가 정적 필드를 수정한다면 그 필드를 사용하기 전에 반드시 동기화 해야 한다.</li><li>교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자</li><li>동기화 영역 안에서 작업은 최소한으로 줄이자</li><li>가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자</li><li>지금은 과도한 동기화를 피하는게 제일 중요하다</li><li>합당한 이유가 있을때만 내부에서 동기화하고 동기화 여부를 문서에 남기자.<br>(웬만하면 외부에서 동기화를 하자)</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 79. 과도한 동기화는 피하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 78. 공유 중인 가변 데이터는 동기화해 사용하라</title>
      <link href="/2019/03/11/effective-java-item78/"/>
      <url>/2019/03/11/effective-java-item78/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>싱글 스레드 기반의 프로그램에서는 하나의 스레드가 하나의 객체를 사용하면 되기 때문에 동기화에 대한 걱정을 하지 않아도 되지만,<br>멀티 스레드 기반의 환경에서는 여러개의 스레드가 하나의 객체를 공유해서 사용하는 경우가 있다.<br>하나의 객체를 공유하며 사용하는 경우 불변 객체에 대해서는 동기화를 걱정할 필요가 없지만,<br>스레드가 메서드를 실행하면서 변수의 데이터를 변경하는 경우 다른 스레드에서 동기화되지 않은 데이터를 읽을 수 있다.<br>이런 경우에는 프로그래머가 기대한 결과와는 다른 결과를 초래할 수 있기 때문에 주의해야 한다.</p><h1 id="동기화란"><a href="#동기화란" class="headerlink" title="동기화란?"></a>동기화란?</h1><p>동기화(Syncronized)란 멀티스레드 환경에서 하나의 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장하는 것을 의미한다.  </p><h2 id="동기화의-특징"><a href="#동기화의-특징" class="headerlink" title="동기화의 특징"></a>동기화의 특징</h2><ul><li>한 객체가 일관된 상태를 가지고 생성되었을 때, 이 객체에 접근하는 메서드는 그 객체에 Lock을 건다.<br>(다른 스레드가 메서드를 실행할 때 실행되지 못하도록 Lock을 건다)</li><li>Lock을 건 메서드는 객체의 상태를 확인하거나 필요하면 수정한다.</li><li>즉 일관된 하나의 상태 -&gt; 다른 일관된 하나의 상태로 변화한다.</li><li>메서드 실행이 끝나면 Lock을 해제한다.</li><li>동기화를 제대로 사용하면 어떤 메서드도 이 객체의 상태가 일관되지 않은 순간을 볼 수 없다.</li><li><strong>동기화 없이는</strong> 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.<br>(동기화가 없다면, 너도나도 접근하는데 시점에 따라 일관된 상태가 아닐 수도 있기 때문)</li><li>언어 명세상 long과 double 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이다.<br>(여러 스레드가 하나의 변수에 동기화 없이 접근해도 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장)</li><li>성능을 높이려면 원자적 데이터를 읽고 쓸 때는 동기화 하지 말아야겠다 <strong>(위험한 발상)</strong><br>(필드를 읽을 때 항상 <strong>수정이 완전히 반영된 값</strong> 을 얻지만, <strong>한 스레드가 저장한 값이 다른 스레드에도 보이는가?</strong> 는 보장하지 않음)</li></ul><h1 id="Java에서의-가변-데이터-동기화-방법"><a href="#Java에서의-가변-데이터-동기화-방법" class="headerlink" title="Java에서의 가변 데이터 동기화 방법"></a>Java에서의 가변 데이터 동기화 방법</h1><p>Java에서는 <strong>synchronized</strong> 키워드를 통해 동기화 처리를 할 수 있다.</p><ul><li>가변데이터를 수정하거나 읽는 메서드를 동기화</li><li>가변 객체에 대한 동기화</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">countup</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(list) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="한-스레드가-저장한-값이-다른-스레드에도-보이는가"><a href="#한-스레드가-저장한-값이-다른-스레드에도-보이는가" class="headerlink" title="한 스레드가 저장한 값이 다른 스레드에도 보이는가?"></a>한 스레드가 저장한 값이 다른 스레드에도 보이는가?</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">backgroundThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위의 코드는 대충 보면 1초뒤에 <code>stopRequested</code> 필드가 false로 바뀌면서 스레드 내의 while문이 종료될 것 처럼 보인다.</li><li>하지만 무한루프!!!</li><li>원인은 동기화에 있다.</li><li>동기화하지 않으면 메인 스레드에서 수정한 <code>stopRequested</code> 필드가 언제 false로 보일지 모른다.<br>(맨 마지막에 stopRequested가 false가 되면서 실제 원잣값은 false가 된다)</li><li>위의 문제를 해결하기 위해서는 <code>stopRequested</code> 필드에 대한 동기화 처리가 필요하다</li></ul><h2 id="동기화가-빠지는-경우-JVM에서-최적화를-수행할-수도-있다"><a href="#동기화가-빠지는-경우-JVM에서-최적화를-수행할-수도-있다" class="headerlink" title="동기화가 빠지는 경우 JVM에서 최적화를 수행할 수도 있다."></a>동기화가 빠지는 경우 JVM에서 최적화를 수행할 수도 있다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//원래 코드</span></span><br><span class="line"><span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 최적화한 코드</span></span><br><span class="line"><span class="keyword">if</span>(!stopRequested) &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>JVM의 호이스팅 기법을 통해 최적화 할 수 있다.</li><li>이 결과 프로그램은 응답 불가 상태가 되어 더 이상 진전이 없다.</li></ul><h1 id="위의-코드를-동기화-해보자"><a href="#위의-코드를-동기화-해보자" class="headerlink" title="위의 코드를 동기화 해보자"></a>위의 코드를 동기화 해보자</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> stopRequested;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">requestStop</span><span class="params">()</span> &#123;</span><br><span class="line">        stopRequested = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">stopRequested</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stopRequested;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">backgroundThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested()) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위와 같이 <strong>stopRequested</strong> 필드의 읽기&#x2F;쓰기에 대한 동기화처리를 하면 위의 프로그램이 1초뒤에 종료된다.</li><li>읽기&#x2F;쓰기 메서드 모두 동기화 처리를 하였음에 주목하자</li><li>쓰기 메서드만 동기화처리를 하고 읽기 메서드에는 동기화처리를 하지 않으면 동작을 보장할 수 없다.</li></ul><h1 id="volatile-키워드"><a href="#volatile-키워드" class="headerlink" title="volatile 키워드"></a>volatile 키워드</h1><p>volatile 키워드의 의미는 <code>volatile 변수를 읽어 들일 때 CPU 캐시가 아니라 컴퓨터의 메인 메모리로 부터 읽어들인다.</code><br>즉 read 할 때도 CPU 캐시가 아닌 메인메모리에서 read하고, write할 때도 메인 메모리에 write를 수행 </p><p><img src="./java-volatile.png" alt="java-volatile"></p><p>long, double을 제외한 기본타입은 <strong>volitile</strong> 키워드를 사용하면 동기화를 생략해도 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">backgroundThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stopRequested) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        stopRequested = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>volitile 예약어는 배타적 수행(한 블록을 한 스레드가 실행) 하는것과는 관계없다</li><li>volatile 변수는 CPU캐시에서 값을 읽는게 아닌 메인 메모리에서 읽기 때문에 항상 최근에 기록된 값을 읽는다.<br>(그렇기 때문에 위의 프로그램이 1초 뒤에 종료됨)</li></ul><h1 id="volatile-사용-시-주의할-점"><a href="#volatile-사용-시-주의할-점" class="headerlink" title="volatile 사용 시 주의할 점"></a>volatile 사용 시 주의할 점</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">nextSerialNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">generateSerialNumber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>이 메서드는 호출 될 때 마다 1씩 증가하여 스레드에서 고유한 값을 반환할 의도로 만들어 졌다.</li><li>겉보기에는 int이기 때문에 원자적으로 접근할 수 있을 것 같다</li><li>Volatile 키워드가 쓰여져있기 때문에 최신 값을 읽을 수 있을 것 같지만 제대로 된 고유한 값이 나오지 않는다.</li></ul><h2 id="원인은-nextSerialNumber"><a href="#원인은-nextSerialNumber" class="headerlink" title="원인은 nextSerialNumber++"></a>원인은 nextSerialNumber++</h2><p>원인은 nextSerialNumber++에 있었다.<br>실제 이 코드는 1줄이지만 풀어쓰면 nextSerialNumber &#x3D; nextSerialNumber + 1; 와 같은 형태이다.<br>결국 nextSerialNumber 값을 한번 읽어와 +1 한다음에 다시 nextSerialNumber 변수에 저장하는 형태이다.<br>만약 두번째 스레드가 nextSerialNumber + 1 연산이 이루어지는 시점을 비집고 들어온다면 1이 두번 리턴되는 형국이다.<br>이런 오류를 <strong>안전 실패(safety failure)</strong> 이라고 한다.</p><h2 id="문제-해결은-synchronized"><a href="#문제-해결은-synchronized" class="headerlink" title="문제 해결은 synchronized"></a>문제 해결은 synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">nextSerialNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">generateSerialNumber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 generateSerialNumber 메서드에 synchronized만 붙여주면 문제는 해결된다.<br>동시에 호출해도 배타적으로 실행 (한번에 한 스레드만 실행) 되기 때문이다.<br>만약 위 처럼 generateSerialNumber 메서드에 synchronized를 붙였다면 nextSerialNumber 변수에는 volatile을 제거해야 한다.<br>만약 메서드를 더 견고하게 하려면 int 대신 long을 사용하는게 더 많은 수를 사용할 수 있다.</p><h1 id="long-double을-사용할-때는-더욱-더-주의하자"><a href="#long-double을-사용할-때는-더욱-더-주의하자" class="headerlink" title="long, double을 사용할 때는 더욱 더 주의하자"></a>long, double을 사용할 때는 더욱 더 주의하자</h1><ul><li>Java.util.concurrent.atomic 패키지의 AtomicLong, AtomicDouble을 사용하는 것이 좋다.  </li><li>이 패키지는 락 없이도(lock-free) 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨 있다.</li><li>volatile은 동기화 속성 중 통신에 대해서만 보장</li><li>Java.util.concurrent.atomic 패키지는 원자성(배타적 실행) 까지 지원한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextSerialNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">generateSerialNumber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextSerialNum.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>동기화에 대한 문제를 피하는 가장 좋은 방법은 가변 데이터를 공유하지 않는 것이다.</li><li>가변데이터는 단일 스레드에서만 사용하는 것이 좋다</li><li>가변데이터를 단일 스레드에서만 사용한다면 문서에 남겨 유지보수 정책에서도 지켜지는것이 중요하다</li><li>멀티 스레드 환경에서 한 스레드가 데이터를 수정한 후에 다른 스레드에 공유할 때는 해당 객체에서 공유하는 부분만 동기화해도 된다.</li><li>클래스 초기화 과정에서 객체를 정적필드, volatile필드, final 필드, 혹은 보통의 락을 통해 접근하는 필드에 저장해도 된다.</li><li>여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 메서드 모두에 반드시 synchronized 키워드를 붙인다.</li><li>배타적 실행 (한번에 한스레드) 동작이 필요없고, 스레드 간 최신데이터만 읽는 거로도 충분하면 가변 변수에 volatile 키워드만으로도 동기화가 가능하다</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 78. 공유 중인 가변 데이터는 동기화해 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 74. 메서드가 던지는 모든 예외를 문서화하라</title>
      <link href="/2019/03/10/effective-java-item74/"/>
      <url>/2019/03/10/effective-java-item74/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>메서드가 던지는 예외는 그 메서드를 올바로 사용하는 데 아주 중요한 정보다.<br>따라서 각 메서드가 던지는 예외 하나하나를 문서화하는 데 충분한 시간을 쏟아야 한다.  </p><h1 id="검사-예외는-throws-태그로-문서화하라"><a href="#검사-예외는-throws-태그로-문서화하라" class="headerlink" title="검사 예외는 @throws 태그로 문서화하라"></a>검사 예외는 @throws 태그로 문서화하라</h1><p>검사 예외(Checked Exception)는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자.<br>공통 상위 예외 클래스 하나로 뭉뚱그려 선언하는 일은 삼가야 한다.<br>극단적인 예로 Exception이나 Throwable을 던진다고 선언해서는 안된다.<br>메서드 사용자에게 각 예외에 대처할 수 있는 힌트를 주지 못할뿐더러 같은 맥락에서 발생할 여지가 있는 다른 예외들 까지 삼켜버릴 수 있기 때문에 API 사용성을 크게 떨어뜨린다.</p><h2 id="잘못된-방법"><a href="#잘못된-방법" class="headerlink" title="잘못된 방법"></a>잘못된 방법</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>같은 맥락에서 발생할 수 있는 다른 예외들까지 삼켜버려 API 사용성이 떨어진다.</li><li>main메서드는 JVM만이 호출하므로 Exception을 던지도록 선언해도 괜찮다.</li></ul><h2 id="권장하는-방법"><a href="#권장하는-방법" class="headerlink" title="권장하는 방법"></a>권장하는 방법</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NumberFormatException - params가 숫자형 데이터가 아닌경우 throw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String params)</span> <span class="keyword">throws</span> IllegalStateException, SQLException, NumberFormatException &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="비검사-예외-Runtime-Exception-도-문서로-남기면-좋다"><a href="#비검사-예외-Runtime-Exception-도-문서로-남기면-좋다" class="headerlink" title="비검사 예외(Runtime Exception)도 문서로 남기면 좋다."></a>비검사 예외(Runtime Exception)도 문서로 남기면 좋다.</h1><p>자바 언어에서 요구하는 것은 아니지만 비검사 예외(Runtime Exception)도 검사 예외(Checked Exception) 처럼 정성껏 문서화 해두면 좋다.<br>비검사 예외(Runtime Exception)는 일반적으로 프로그래밍 오류를 뜻하는데 자신이 일으킬 수 있는 오류들이 무엇인지 알려주면<br>프로그래머는 자연스럽게 해당 오류가 나지 않도록 코딩하게 된다.<br>잘 정비된 비검사 예외 문서는 그 메서드를 성공적으로 수행하기 위한 전제조건이 된다.</p><p>public 메서드라면 필요한 전제조건을 문서화해야 하며, 그 수단으로 가장 좋은 것이 비검사 예외들을 문서화 하는것이다.<br><strong>특히 인터페이스에서 중요하다.</strong><br>이 조건이 인터페이스의 일반 규약에 속하게 되어 인터페이스를 구현한 모든 구현체가 일관되게 동작하도록 해주기 때문이다.  </p><h1 id="비검사-예외-Runtime-Exception-은-메서드-시그니처에-추가하지-말자"><a href="#비검사-예외-Runtime-Exception-은-메서드-시그니처에-추가하지-말자" class="headerlink" title="비검사 예외(Runtime Exception)은 메서드 시그니처에 추가하지 말자"></a>비검사 예외(Runtime Exception)은 메서드 시그니처에 추가하지 말자</h1><p>메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.<br>검사냐 비검사냐에 따라 사용자가 해야할 일이 달라지므로 이 둘을 확실히 구분하는게 좋다.<br>자바독은 메서드 시그니처에 throws 절에 등장하고 메서드 주석의 @throws 태그에도 명시한 예외와 @throws 태그에만 명시한 예외를 시각적으로 구분해준다.<br>그래서 프로그래머는 어떤 것이 비검사 예외인지 바로 알 수 있다.</p><h1 id="거의-모든-메서드에서-같은-예외를-던진다면-Class-설명에-추가하라"><a href="#거의-모든-메서드에서-같은-예외를-던진다면-Class-설명에-추가하라" class="headerlink" title="거의 모든 메서드에서 같은 예외를 던진다면 Class 설명에 추가하라"></a>거의 모든 메서드에서 같은 예외를 던진다면 Class 설명에 추가하라</h1><p>한 클래스에 정의된 웬만한 메서드에서 같은 이유로 같은 예외를 던진다면 그 예외를 각각의 메서드가 아니라 클래스 설명에 추가하는 방법도 있다.<br>NullPointerException이 가장 흔한 사례다.<br>이럴 때는 클래스의 문서화 주석에 <strong>이 클래스의 모든 메서드는 인수로 null이 넘어오면 NullPointerException을 던진다.</strong> 라고 적어도 좋다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 74. 메서드가 던지는 모든 예외를 문서화하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 73. 추상화 수준에 맞는 예외를 던지라</title>
      <link href="/2019/03/10/effective-java-item73/"/>
      <url>/2019/03/10/effective-java-item73/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>수행하려는 일과 관련 없어 보이는 예외가 튀어나오면 당황스럽다.<br>메서드가 저수준 예외를 처리하지 않고 바깥으로 throw 해버릴 때 상위 메서드에서 종종 발생하는 일이다.<br>내부 구현방식을 상위에 드러내어 윗 레벨 API를 오염 시킬 수 있고, 다음 릴리스에서 구현방식이 변경되면 다른 예외가 튀어나와<br>기존 클라이언트 프로그램을 깨지게 할 수도 있다.</p><h1 id="상위-메서드에서-저수준-예외를-번역해야-한다"><a href="#상위-메서드에서-저수준-예외를-번역해야-한다" class="headerlink" title="상위 메서드에서 저수준 예외를 번역해야 한다."></a>상위 메서드에서 저수준 예외를 번역해야 한다.</h1><p>상위 메서드에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다.<br>이를 예외 번역(Exception Translation)이라 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">..<span class="comment">// 저수준 추상화를 이용</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (LowerLevelException e) &#123;</span><br><span class="line">  <span class="comment">// 추상화 수준에 맞게 번역</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HigherLevelException</span>(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="저수준-예외의-내용이-필요하다면-예외-연쇄를-사용하라"><a href="#저수준-예외의-내용이-필요하다면-예외-연쇄를-사용하라" class="headerlink" title="저수준 예외의 내용이 필요하다면 예외 연쇄를 사용하라"></a>저수준 예외의 내용이 필요하다면 예외 연쇄를 사용하라</h1><p>예외 연쇄(Exception chaining)이란 문제의 근본 원인(cause)인 저수준 예외를 고수준 예외에 실어 보내는 방식이다.<br>별도의 접근자 메서드(Throwable의 getCause메서드)를 통해 필요하면 언제든 저수준 예외를 꺼내 볼 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 저수준 추상화를 이용한다.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (LowerLevelException cause) &#123;</span><br><span class="line">  <span class="comment">// 저수준 예외를 고수준 예외에 실어 보낸다.</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HigherLevelException</span>(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HigherLevelException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">  HigherLevelException(Throwable cause) &#123;</span><br><span class="line">    <span class="built_in">super</span>(cause);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있다.<br>그렇지 않은 예외라도 Throwable의 initCause 메서드를 이용해 <code>원인</code> 을 직접 못박을 수 있다.<br>예외 연쇄는 문제의 원인을 프로그램에서 접근할 수 있게 해주며 원인과 고수준 예외의 Stack trace를 잘 통합해준다.</p><h1 id="예외-번역을-남용하지-말자"><a href="#예외-번역을-남용하지-말자" class="headerlink" title="예외 번역을 남용하지 말자"></a>예외 번역을 남용하지 말자</h1><p>가능하다면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.<br>때로는 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 Validator를 이용하여 미리 검사하는 것이 좋다. </p><p>아래 계층에서의 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리하여 문제를 API 호출자에 전파하지 않는 방법이 있다.<br>이 경우 발생한 예외는 log를 활용하여 개발자가 디버깅을 할 수 있는 정도면 충분하다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  lowerLevelMethod();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="comment">//Exception을 먹어버리고 상위로 전파되지 않도록 한다.</span></span><br><span class="line">  log.error(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라</li><li>예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에  좋다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 73. 추상화 수준에 맞는 예외를 던지라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 72. 표준 예외를 사용하라</title>
      <link href="/2019/03/10/effective-java-item72/"/>
      <url>/2019/03/10/effective-java-item72/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>숙련된 프로그래머는 그렇지 못한 프로그래머보다 더 많은 코드를 재사용한다.<br>예외도 마찬가지로 재사용하는 것이 좋으며, 자바 라이브러리는 대부분 API에서 쓰기에 충분한 수의 예외를 제공한다.</p><h1 id="표준-예외를-재사용하라"><a href="#표준-예외를-재사용하라" class="headerlink" title="표준 예외를 재사용하라"></a>표준 예외를 재사용하라</h1><ul><li>표준 예외를 사용하면 다른사람이 API를 익히고 사용하기 쉬워진다 (많은 개발자들이 이미 익숙하게 사용하기 때문)</li><li>표준 예외를 사용한 API는 다른 개발자가 API를 사용하더라도 낯선 예외를 사용하지 않아 코드의 가독성이 높아진다.</li><li>예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스를 로딩하는 시간도 적게 걸린다.<br>(무분별하게 커스텀 예외 클래스를 만들면 빌드하는 시간도 오래 걸리고 클래스 로딩 시간도 더 걸린다는 소리)</li></ul><h1 id="가장-많이-사용되는-예외"><a href="#가장-많이-사용되는-예외" class="headerlink" title="가장 많이 사용되는 예외"></a>가장 많이 사용되는 예외</h1><h2 id="IllegalArgumentException"><a href="#IllegalArgumentException" class="headerlink" title="IllegalArgumentException"></a>IllegalArgumentException</h2><ul><li>호출자가 인수로 부적절한 값을 넘길 때 던지는 예외</li><li>반복 횟수 (loop count)를 지정하는 매개변수에 음수를 건넬 때 쓸 수 있다.</li><li>메서드의 파라미터로 <code>null 값</code>이 들어오면 관례상 IllegalArgumentException보다는 <code>NullPointerException</code>을 던진다.</li><li>시퀀스의 허용 범위를 넘는 값을 건넬 때도 IllegalArgumentException보다는 <code>IndexOutOfBoundsException</code>을 던진다.</li></ul><h2 id="IllegalStateException"><a href="#IllegalStateException" class="headerlink" title="IllegalStateException"></a>IllegalStateException</h2><ul><li>대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때 주로 던진다.</li><li>예를 들면, 초기화되지 않은 객체를 사용하려 할 때 던질 수 있다.</li></ul><h2 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a>ConcurrentModificationException</h2><ul><li>단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때 던진다.<br>(외부 동기화 방식으로 사용하려고 설계한 객체도 마찬가지다.)</li><li>동시 수정을 확실히 검출할 수 있는 안정된 방법은 없으나, 문제가 생길 가능성 정도만 알려주는 역할도 쓰인다.</li></ul><h2 id="UnsupportedOperationException"><a href="#UnsupportedOperationException" class="headerlink" title="UnsupportedOperationException"></a>UnsupportedOperationException</h2><ul><li>예외는 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 던진다.</li><li>보통 구현하려는 인터페이스의 메서드 일부를 구현할 수 없는 경우에 사용</li></ul><h2 id="ArithmeticException-NumberFormatException"><a href="#ArithmeticException-NumberFormatException" class="headerlink" title="ArithmeticException, NumberFormatException"></a>ArithmeticException, NumberFormatException</h2><ul><li>복소수나 유리수를 다루는 객체를 사용할 때 사용</li><li>10 &#x2F; 0 과 같은 연산을 할 때 ArithmeticException이 발생한다. </li><li>숫자형 파라미터가 와야 하는 부분에 String이라든지 다른 형식의 데이터가 들어오는 경우 NumberFormatException이 발생</li></ul><h1 id="예외-사용-시-주의할-점"><a href="#예외-사용-시-주의할-점" class="headerlink" title="예외 사용 시 주의할 점"></a>예외 사용 시 주의할 점</h1><ul><li>Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자.<br>(다른 예외들의 상위 클래스이기 때문에 안정적으로 테스트 할 수 없다.)</li><li>예외에서 더 많은 정보를 제공하길 원한다면 표준 예외를 확장해도 좋다.<br>(단 예외는 직렬화할 수 있기 때문에 주의해야 한다.)</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 72. 표준 예외를 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 68. 일반적으로 통용되는 명명 규칙을 따르라</title>
      <link href="/2019/03/03/effective-java-item68/"/>
      <url>/2019/03/03/effective-java-item68/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>자바 플랫폼은 명명 규칙이 잘 정립되어 있으며, 그중 많은 것이 자바 언어 명세에 기술되어 있다.<br>자바의 명명 규칙은 철자와 문법 두 범주로 나뉜다.<br>철자 규칙은 패키지, 클래스, 인터페이스, 메서드, 필드, 타입 변수의 이름을 다룬다.<br>이 규칙들은 특별한 이유가 없는 한 반드시 따르는게 좋고 이를 어기면 다른 프로그래머들이 그 코드를 읽기 번거로울 뿐 아니라 다른뜻으로 오해할 수도 있고 그로 인해 장애로 발전할 수 있다.</p><h1 id="명명-규칙"><a href="#명명-규칙" class="headerlink" title="명명 규칙"></a>명명 규칙</h1><h2 id="패키지-Package"><a href="#패키지-Package" class="headerlink" title="패키지 (Package)"></a>패키지 (Package)</h2><ul><li>패키지 (Package)와 모듈 이름은 각 요소를 **점(.)**으로 구분하여 계층적으로 짓는다.</li><li>요소들은 모두 소문자 알파벳 혹은 숫자로 이뤄진다.</li><li>com.google, kr.co.edu와 같은 식이다.</li><li>패키지를 설명하는 하나이상의 요소로 이루어져 있다.</li><li>일반적으로 8자 이하의 짧은 단어로 한다.</li><li>utilities보다는 util처럼 의미가 통하는 약어가 좋다.</li><li>요소의 이름은 보통 한 단어 혹은 약어로 이루어진다.</li><li>많은 기능을 제공하는 애플리케이션의 경우에는 계층을 더 많은 요소로 나누는 것이 좋다.</li></ul><h2 id="클래스-인터페이스-열거타입"><a href="#클래스-인터페이스-열거타입" class="headerlink" title="클래스, 인터페이스, 열거타입"></a>클래스, 인터페이스, 열거타입</h2><ul><li>클래스 명은 하나이상의 단어로 구성되며, 첫글자는 대문자로 작성한다.</li><li>여러 단어의 첫글자만 딴 약자나 널리 통용되는 줄임말을 제외하고는 줄임말을 쓰지 않도록 한다.</li><li>조합한 단어를 구분할 수 있게 <strong>camel case</strong>로 작성한다.</li></ul><h2 id="메서드-필드명"><a href="#메서드-필드명" class="headerlink" title="메서드, 필드명"></a>메서드, 필드명</h2><ul><li>첫 글자를 소문자로 작성하고 클래스 명과 같게 단어 별로 <strong>camel case</strong>로 작성한다.</li><li>첫 단어가 약자라면 단어 전체가 소문자여야 한다.</li><li>상수 필드는 예외다. 상수 필드를 구성하는 단어는 모두 대문자로 쓰며 단어 사이는 언더바(_)로 구분한다.<br>(VALUES, NEGATIVE_INFINITY등..)</li><li>상수 필드는 static final인 타입을 의미한다.</li><li>가르키는 객체가 불변이라면, 그 타입은 가변이어도 상수이다.</li><li>지역번수에도 동일한 규칙이 적용된다. 단, 문맥에서 의미를 쉽게 유추할 수 있는 경우에는 <strong>약어를 사용해도 좋다.</strong><br>(i, denom, houseNum등..)</li><li>타입 매개변수의 이름은 한 글자로 표현한다.<ul><li>T: 임의의 타입 (Type)</li><li>E: 컬렉션의 원소 (Element)</li><li>K: 맵의 키 (Key)</li><li>V: 맵의 값 (Value)</li><li>X: 예외 (eXception)</li><li>R: 메서드의 반환타입 (Return)</li><li>그 이외의 타입에는 T, U, V 혹은 T1, T2, T3의 식으로 사용</li></ul></li></ul><h1 id="명명-규칙2"><a href="#명명-규칙2" class="headerlink" title="명명 규칙2"></a>명명 규칙2</h1><ul><li>객체를 생성하는 클래스나 열거타입 인터페이스는 <strong>단수 명사나 명사구를 사용한다.</strong><ul><li>Thread, PriorityQueue, ChessPiece 등..</li></ul></li><li>객체를 생성할 수 없는 클래스 (Utils 클래스)에는 보통 <strong>복수형 명사로 짓는다.</strong><ul><li>Collectors, Collections 등..</li></ul></li><li>인터페이스 이름은 클래스명과 동일하게 짓거나, <strong>ible, able로 끝나는 형용사로 짓는다.</strong><ul><li>Runnable, Iterable, Accessible 등…</li></ul></li><li>애너테이션은 워낙 다양하게 활용되어 지배적인 규칙이 없이 명사, 형용사, 동사, 전치사가 두루 쓰인다.<ul><li>@Binding, @Inject, @ImplementsBy, @Singleton 등..</li></ul></li><li>메서드의 이름은 동사나 목적어를 포함한 <strong>동사구로 짓는다.</strong><ul><li>append, drawImage</li></ul></li><li>boolean 값을 반환하는 메서드라면 <strong>is<del>, has</del>로 짓는다.</strong><ul><li>isDigit, isEmpty, hasSiblings 등..</li></ul></li><li>반환타입이 boolean이 아닌경우 보통 명사, 명사구, get~로 짓는다.<ul><li>size, hashcode, getTime 등…</li><li>get으로 시작하는 형태는 주로 자바빈즈(JavaBeans) 명세에 뿌리를 두고 있다.</li><li>보통 getter&#x2F;setter의 한 묶음 형태로 만드는 경우가 많다.</li></ul></li><li>반환타입을 또다른 타입을 반환하는 경우에는<strong>toType</strong> 의 형태로 짓는다.<ul><li>toString, toArray 등..</li></ul></li><li>객체의 내용을 다른 뷰로 보여주는 메서드는 <strong>asType</strong> 의 형태로 짓는다.<ul><li>asList, asMap 등..</li></ul></li><li>객체의 값을 기본 타입(primitive type)으로 반환하는 경우에는 <strong>typeValue</strong> 의 형태로 짓는다.<ul><li>intValue, longValue 등…</li></ul></li><li>정적 팩터리의 이름은 다양하다<ul><li>from, valueOf, getInstance, newInstance 등..</li></ul></li></ul><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>표준 명명 규칙을 체득하여 자연스럽게 사용하도록 연습하자</li><li>철자 규칙은 직관적이라 모호한 부분이 적지만, 문법 규칙은 더 복잡하고 느슨하다</li><li>오랫동안 따라온 규칙과 충돌한다면 그 규칙을 맹종해서는 안된다. 상식대로 가자</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 68. 일반적으로 통용되는 명명 규칙을 따르라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 67. 최적화는 신중히 하라</title>
      <link href="/2019/03/03/effective-java-item67/"/>
      <url>/2019/03/03/effective-java-item67/</url>
      
        <content type="html"><![CDATA[<h1 id="최적화에-대한-명언"><a href="#최적화에-대한-명언" class="headerlink" title="최적화에 대한 명언"></a>최적화에 대한 명언</h1><blockquote><p>맹목적인 어리석음을 포함해 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다 (심지어 효율을 높이지도 못하면서)</p><p>- 윌리엄 울프(Wulf72)</p></blockquote><blockquote><p>(전체의 97% 정도인) 자그마한 효율성은 모두 잊자. 섣부른 최적화가 만약의 근원이다. - 도널드 크누스(Knuth74)</p></blockquote><blockquote><p>최적화를 할 때는 다음 두 규칙을 따르라.</p><p>첫 번째, 하지마라.<br>두 번째, (전문가 한정) 아직 하지 마라. 다시 말해, 완전히 명백하고 최적화되지 않은 해법을 찾을 때까지는 하지 마라.<br>- M.A 잭슨 (Jackson75)</p></blockquote><p>위의 명언들을 풀어보면,<br>최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고 섣불리 진행하면 특히 더 그렇다.<br>빠르지도 않고 제대로 동작하지도 않으면서 수정하기는 어려운 소프트웨어를 탄생시키는 것이다.</p><h1 id="프로그램을-설계할-때-생각해야-할-점"><a href="#프로그램을-설계할-때-생각해야-할-점" class="headerlink" title="프로그램을 설계할 때 생각해야 할 점"></a>프로그램을 설계할 때 생각해야 할 점</h1><h2 id="빠른-프로그램보다는-좋은-프로그램을-작성하자"><a href="#빠른-프로그램보다는-좋은-프로그램을-작성하자" class="headerlink" title="빠른 프로그램보다는 좋은 프로그램을 작성하자"></a>빠른 프로그램보다는 좋은 프로그램을 작성하자</h2><ul><li>좋은 프로그램이지만 원하는 성능이 나오지 않는다면 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것이다.</li><li>좋은 프로그램은 정보 은닉(캡슐화) 원칙을 따르므로 개별 구성요소 내부를 독립적으로 설계할 수 있다.</li><li>따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다.</li><li>구현상의 문제는 나중에 최적화 할 수 있지만, 아키텍처의 결함이 성능을 제한한다면 시스템을 다시 작성해야 하기 때문이다.</li><li>따라서 설계 단계에서 성능을 반드시 염두하자</li></ul><h2 id="성능을-제한하는-설계를-피하라"><a href="#성능을-제한하는-설계를-피하라" class="headerlink" title="성능을 제한하는 설계를 피하라"></a>성능을 제한하는 설계를 피하라</h2><ul><li>완성 후 변경하기가 가장 어려운 설계 요소는 컴포넌트끼리 또는 외부 시스템과의 소통 방식이다.</li><li>API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등이 있다.</li><li>완성후에는 변경하기 어렵거나 불가능 하고, 동시에 시스템 성능을 제한할 수 있다.</li></ul><h2 id="API를-설계할-때-성능에-주는-영향을-고려하라"><a href="#API를-설계할-때-성능에-주는-영향을-고려하라" class="headerlink" title="API를 설계할 때 성능에 주는 영향을 고려하라"></a>API를 설계할 때 성능에 주는 영향을 고려하라</h2><ul><li>가변 객체를 사용하여 내부데이터를 변경할 수 있게 만들면 불필요한 방어적 복사를 유발할 수 있다.</li><li>컴포지션으로 해결할 수 있는 경우에도 상속을 이용하면 상위클래스에 영원히 종속되고, 성능 제약까지 물려받는다</li><li>인터페이스도 있는데 굳이 클래스 타입으로 사용하면, 차후 개선된 구현체를 사용하기 어려워진다.</li></ul><h2 id="성능을-위해-API를-왜곡하지-말자"><a href="#성능을-위해-API를-왜곡하지-말자" class="headerlink" title="성능을 위해 API를 왜곡하지 말자"></a>성능을 위해 API를 왜곡하지 말자</h2><ul><li>API를 왜곡하도록 만든 성능 문제는 해당 플랫폼이나 아랫단 소프트웨어의 다음 버전에서 사라질 수 있다.</li><li>왜곡된 API를 지원하는 데 따르는 고통은 영원하다</li></ul><h2 id="프로파일링-도구를-적극-활용하자"><a href="#프로파일링-도구를-적극-활용하자" class="headerlink" title="프로파일링 도구를 적극 활용하자"></a>프로파일링 도구를 적극 활용하자</h2><ul><li>프로파일링 도구는 최적화 노력을 어디에 집중해야 할지 찾는 데 도움을 준다.</li><li>개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 제공하여 개발자의 수고를 덜어준다.</li><li>JMH도 알아야 하는 도구이다.  프로파일러는 아니지만 자바 코드의 상세한 성능을 알기 쉽게 보여주는 마이크로 벤치마킹 프레임워크다.</li></ul><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>빠른프로그램을 작성하려 하지 말고 좋은 프로그램을 작성하려 노력하자. 성능은 따라오기 마련이다.</li><li>시스템을 설계할 때 API, 네트워크 프로토코르 영구 저장용 데이터 포맷을 설계할 때는 성능을 염두하자</li><li>시스템 구현을 완료했으면 측정해보고 충분히 빠르면 최적화를 하지 마라</li><li>성능 측정 시에는 프로파일링 도구를 이용해 문제의 원인이 되는 지점을 찾아 최적화하자</li><li>알고리즘을 잘못 골랐다면, 저수준 최적화는 의미가 없다. </li><li>만족할 만한 성능이 나올 때까지 위의 과정을 반복하고, 변경 후에는 성능 측정을 꼭하자</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 67. 최적화는 신중히 하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 66. 네이티브 메서드는 신중히 사용하라</title>
      <link href="/2019/03/03/effective-java-item66/"/>
      <url>/2019/03/03/effective-java-item66/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>자바 네이티브 인터페이스(Java Native Interface, JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다.  </p><blockquote><p>네이티브 메서드란?</p><p>C나 C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다.</p></blockquote><h1 id="네이티브-메서드의-주요-쓰임"><a href="#네이티브-메서드의-주요-쓰임" class="headerlink" title="네이티브 메서드의 주요 쓰임"></a>네이티브 메서드의 주요 쓰임</h1><ul><li>Registry 같은 플랫폼 특화기능을 사용한다.<ul><li>하지만 자바가 진화해가면서 하부 플랫폼의 기능을 흡수하고 있다.</li><li>네이티브 메서드를 사용해야하는 일이 줄어들고 있다.</li><li>자바9 부터는 process API를 추가해 OS에 접근하는 길을 열어주었다.</li></ul></li><li>네이티브 코드로 작성된 기존 라이브러리를 사용해야 하는 경우<ul><li>레거시 데이터를 사용하는 레거시 라이브러리</li><li>Java로 된 라이브러리가 없는 경우 네이티브 라이브러리를 사용한다.</li></ul></li><li>성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.</li></ul><h1 id="네이티브-메서드를-성능개선의-목적으로-사용하지-말라"><a href="#네이티브-메서드를-성능개선의-목적으로-사용하지-말라" class="headerlink" title="네이티브 메서드를 성능개선의 목적으로 사용하지 말라"></a>네이티브 메서드를 성능개선의 목적으로 사용하지 말라</h1><ul><li>자바 초기 시절 (Java 1.3)이전이라면 다른 얘기지만, 그동안 JVM은 빠른 속도로 발전해 왔다.  </li><li>대부분의 작업에서 Java는 다른 플랫폼과 견줄만한 성능을 보인다 (자바가 느리다는 것도 옛말)</li><li>네이티브 라이브러리 쪽은 GNU 다중 정밀 연산 라이브러리(GMP)를 필두로 개선 작업이 계속돼왔다.<br>고성능의 다중 정밀 연산이 필요한 경우에는 네이티브 메서드를 통해 GMP를 사용하는것을 고려해보자</li></ul><h1 id="네이티브-메서드의-단점"><a href="#네이티브-메서드의-단점" class="headerlink" title="네이티브 메서드의 단점"></a>네이티브 메서드의 단점</h1><ul><li>네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로 부터 안전하지 않다.</li><li>네이티브 언어는 플랫폼 종속성이 있으므로 이식성이 좋지 못하다</li><li>디버깅도 어렵다</li><li>오히려 속도가 더 느릴 수 있다.</li><li>JVM의 가비지 컬렉터는 네이티브 메모리는 자동 회수 하지 못하고 추적도 할 수 없다.</li><li>자바 코드와 네이티브 코드의 경계를 넘나 들때마다 비용이 발생한다.</li><li>자바 코드와 네이티브 코드간의 접착 코드(glue code)를 작성해야 하는데 이 부분도 귀찮고 가독성도 떨어진다.</li></ul><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li><p>네이티브 메서드를 사용하는 경우는 한번 더 생각하라</p></li><li><p>네이티브 메서드가 그렇게 성능 향상에 도움을 주지는 않는다.</p></li><li><p>네이티브 메서드를 사용해야 하는 경우에는 최소한으로 사용하고 철저한 테스트를 해야한다.</p></li><li><p>숨은 버그하나가 애플리케이션 전체에 영향을 줄 수도 있다.</p></li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 66. 네이티브 메서드는 신중히 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 65. 리플렉션보다는 인터페이스를 사용하라</title>
      <link href="/2019/03/03/effective-java-item65/"/>
      <url>/2019/03/03/effective-java-item65/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>리플렉션 기능(java.lang.reflect)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.<br>Class 객체가 주어지면 클래스 정보를 통해 아래와 같은 인스턴스를 가져올 수 있다.</p><ul><li>Constructor<ul><li>생성자 시그니처를 가져올 수 있다.</li><li>생성자 인스턴스를 통해 객체를 생성할 수 있다.</li></ul></li><li>Method<ul><li>Method 시그니처를 가져올 수 있다.</li><li>Method 인스턴스를 통해 Method를 실행시킬 수 있다. (Method.invoke)</li></ul></li><li>Field<ul><li>필드타입, 멤버필드 이름등을 가져올 수 있다.</li></ul></li></ul><h1 id="리플렉션의-단점"><a href="#리플렉션의-단점" class="headerlink" title="리플렉션의 단점"></a>리플렉션의 단점</h1><p>리플렉션을 이용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있다.<br>(예를들면.. 외부 라이브러리의 클래스를 리플렉션으로 인스턴스를 생성한다든지…)  </p><h2 id="컴파일타임-타입-검사가-주는-이점을-누릴-수-없다"><a href="#컴파일타임-타입-검사가-주는-이점을-누릴-수-없다" class="headerlink" title="컴파일타임 타입 검사가 주는 이점을 누릴 수 없다."></a>컴파일타임 타입 검사가 주는 이점을 누릴 수 없다.</h2><ul><li>예외 검사, 컴파일 타임 에러를 잡아낼 수 없다.  </li><li>프로그램이 리플렉션 기능을 써서 존재하지 않는 혹은 접근 불가능한 (private 메서드)를 호출하려 하면 런타임 오류가 발생한다.</li></ul><h2 id="리플렉션을-이용하면-코드가-지저분하고-장황해진다"><a href="#리플렉션을-이용하면-코드가-지저분하고-장황해진다" class="headerlink" title="리플렉션을 이용하면 코드가 지저분하고 장황해진다."></a>리플렉션을 이용하면 코드가 지저분하고 장황해진다.</h2><ul><li>지루한 일이고 읽기도 어렵다.</li></ul><h2 id="성능이-떨어진다"><a href="#성능이-떨어진다" class="headerlink" title="성능이 떨어진다."></a>성능이 떨어진다.</h2><ul><li>리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느리다.</li><li>고려해야 하는 요소가 많아 정확한 차이는 이야기하기 어렵다</li><li>하지만 분명 느리다.</li></ul><h2 id="리플렉션은-아주-제한된-형태로만-사용해야-그-단점을-피할-수-있다"><a href="#리플렉션은-아주-제한된-형태로만-사용해야-그-단점을-피할-수-있다" class="headerlink" title="리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피할 수 있다"></a>리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피할 수 있다</h2><ul><li>컴파일타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램은 비록 컴파일타임이라도 적절한 인터페이스나 상위 클래스를 이용할 수는 있을것이다.</li><li>리플렉션은 인스턴스 생성에만 쓰고 이렇게 만든 인터페이스나 상위 클래스로 참조해 사용하자</li></ul><h1 id="리플렉션의-취약한-예"><a href="#리플렉션의-취약한-예" class="headerlink" title="리플렉션의 취약한 예"></a>리플렉션의 취약한 예</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 클래스 이름을 Class 객체로 변환</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Set</span>&lt;String&gt;&gt; cl = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Set</span>&lt;String&gt;&gt;) Class.forName(args[<span class="number">0</span>]); <span class="comment">//비검사 형변환</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        fatalError(<span class="string">&quot;클래스를 찾을 수 없습니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생성자를 얻는다.</span></span><br><span class="line">    Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">Set</span>&lt;String&gt;&gt; cons = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cons = cl.getDeclaredConstructor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        fatalError(<span class="string">&quot;매개변수 없는 생성자를 찾을 수 없습니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//집합의 인스턴스를 만든다.</span></span><br><span class="line">    Set&lt;String&gt; s = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        s = cons.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        fatalError(<span class="string">&quot;생성자에 접근할 수 없습니다.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        fatalError(<span class="string">&quot;클래스를 인스턴스화할 수 없습니다.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        fatalError(<span class="string">&quot;생성자가 예외를 던졌습니다: &quot;</span> + e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        fatalError(<span class="string">&quot;Set을 구현하지 않은 클래스입니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//생성한 집합을 사용한다.</span></span><br><span class="line">    s.addAll(Arrays.asList(args).subList(<span class="number">1</span>, args.length));</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fatalError</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.err.println(msg);</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예시는 리플렉션의 단점을 보여준다.</p><ul><li>런타임에 총 6가지의 예외를 던질 수 있다.</li><li>위에서 발생하는 예외는 모두 컴파일타임에 체크할 수 있는 예외들이다.</li><li>클래스 이름만으로 인스턴스를 생성해내기 위해 무려 25줄이나 되는 코드를 작성했지만, 그게 아닌 경우에는 생성자 1줄이면 끝난다.</li><li>리플렉션 예외를 각각 잡는 대신 상위 클래스인 ReflectiveOperationException을 잡으면 코드량을 줄일 수 있다.<br>(ReflectiveOperationException은 Java 7부터 지원한다.)</li></ul><h1 id="리플렉션은-무조건-쓰지-말아야-한다"><a href="#리플렉션은-무조건-쓰지-말아야-한다" class="headerlink" title="리플렉션은 무조건 쓰지 말아야 한다?"></a>리플렉션은 무조건 쓰지 말아야 한다?</h1><ul><li>Spring MVC, Serialize&#x2F;Deserialize, BeanUtils.copyProperties등 실무에서 사용하는 코드에 리플렉션이 적용된 예는 굉장히 많다.</li><li>단점이 많다고는 하지만 공통적인 기능을 설계하거나, 재사용 가능한 코드를 설계할 경우에는 오히려 리플렉션이 적합할 수 있다.</li><li>그렇기 때문에 Java 1.3 이후부터 리플렉션에 대한 성능향상을 발전시켜왔다고 한다.</li><li>이러한 발전으로 리플렉션은 우려할 만큼 성능이 떨어지지는 않는다고 한다.</li><li>리플렉션을 남발하는 것이 아닌 필요한 상황에 적시적소에 사용한다면 오히려 서비스 개발을 더 단순화 시킬수 있다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 65. 리플렉션보다는 인터페이스를 사용하라</li><li><a href="https://kmongcom.wordpress.com/2014/03/15/%EC%9E%90%EB%B0%94-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%A4%ED%95%B4%EC%99%80-%EC%A7%84%EC%8B%A4/">Java 리플렉션의 오해와 진실</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 64. 객체는 인터페이스를 사용해 참조하라</title>
      <link href="/2019/03/01/effective-java-item64/"/>
      <url>/2019/03/01/effective-java-item64/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Item 51에 제네릭 타입으로 클래스가 아니라 인터페이스를 사용하라고 설명 되어있다.<br>이 말의 의미는 <strong>객체는 클래스가 아닌 인터페이스로 참조하라</strong> 라는 의미로 확장할 수 있다.<br>적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언해야 한다.</p><h1 id="유연한-프로그램을-생성하는-인터페이스-타입-변수"><a href="#유연한-프로그램을-생성하는-인터페이스-타입-변수" class="headerlink" title="유연한 프로그램을 생성하는 인터페이스 타입 변수"></a>유연한 프로그램을 생성하는 인터페이스 타입 변수</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//좋은 예</span></span><br><span class="line">Set&lt;Son&gt; sonSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//나쁜 예</span></span><br><span class="line">LinkedHashSet&lt;Son&gt; sonSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>좋은 예는 Set 인터페이스 타입으로 변수를 선언하였다.</li><li>나쁜 예는 LinkedHashSet 타입으로 변수를 선언하였다.</li></ul><p>만약 LinkedHashSet을 TreeSet으로 변환해야 한다면 어떨까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//좋은 예</span></span><br><span class="line">Set&lt;Son&gt; sonSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//나쁜 예</span></span><br><span class="line">LinkedHashSet&lt;Son&gt; sonSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(); <span class="comment">//컴파일 에러!</span></span><br></pre></td></tr></table></figure><ul><li>위의 좋은 예는 Set 인터페이스 타입이기 때문에 컴파일 타임&#x2F;런타임에 전혀 문제가 되지 않는다.</li><li>나쁜 예는 LinkedHashSet 타입이기 때문에 TreeSet을 LinkedHashSet로 형변환 할 수 없다고 에러가 발생한다.</li></ul><h1 id="인터페이스-타입의-장점"><a href="#인터페이스-타입의-장점" class="headerlink" title="인터페이스 타입의 장점"></a>인터페이스 타입의 장점</h1><ul><li>인터페이스 타입을 사용하면 클라이언트 코드를 수정하지 않고도 참조 객체를 변경할 수 있다.</li><li>다른 타입의 객체를 사용하더라도 컴파일에러&#x2F;런타임에러에 대한 걱정을 하지 않아도 된다.</li></ul><h1 id="인터페이스-타입의-단점"><a href="#인터페이스-타입의-단점" class="headerlink" title="인터페이스 타입의 단점"></a>인터페이스 타입의 단점</h1><ul><li>인터페이스 타입에 선언된 메서드를 구현한 메서드만 사용이 가능하다.</li><li>특정 구현체의 내부 메서드를 사용할 수 없다.</li></ul><h1 id="클래스를-참조해야-하는-경우"><a href="#클래스를-참조해야-하는-경우" class="headerlink" title="클래스를 참조해야 하는 경우"></a>클래스를 참조해야 하는 경우</h1><h2 id="값-타입에는-클래스를-참조하라"><a href="#값-타입에는-클래스를-참조하라" class="headerlink" title="값 타입에는 클래스를 참조하라"></a>값 타입에는 클래스를 참조하라</h2><ul><li>String, Integer, Long과 같이 값 타입에 대해서는 인터페이스를 사용할 수 없으니 클래스를 참조해야 한다.</li><li>또한 Integer, Long과 같은 타입을 사용할 때는 Number와 같은 상위 타입을 사용하지 말아야 한다.<br><strong>형변환이 발생 할 때 특정 데이터가 절삭되어 다른 결과가 발생 할 수 있기 때문이다.</strong></li><li>이런 경우에는 인터페이스나 상위타입 보다는 본래의 클래스로 참조하는 것이 좋다.</li></ul><h2 id="인터페이스에는-없는-메서드를-사용할-때에는-클래스를-참조해라"><a href="#인터페이스에는-없는-메서드를-사용할-때에는-클래스를-참조해라" class="headerlink" title="인터페이스에는 없는 메서드를 사용할 때에는 클래스를 참조해라"></a>인터페이스에는 없는 메서드를 사용할 때에는 클래스를 참조해라</h2><ul><li>PriorityQueue 클래스에는 Queue 인터페이스에는 없는 comparator 메서드를 제공한다.</li><li>클래스 타입을 직접 사용하는 경우에는 추가 메서드를 사용해야 하는 경우로 최소화 하는 것이 좋다.</li></ul><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>인터페이스나 추상클래스를 구현하는 클래스를 사용할 때는 참조 변수를 인터페이스나 추상클래스로 사용하자</li><li>인터페이스나 추상클래스 타입으로 참조 변수를 사용하면 참조 객체를 바꿔도 안전하다</li><li>값 타입을 사용하는 경우에는 클래스 타입의 참조변수를 사용해야 한다.</li><li>인터페이스에는 없는 메서드를 사용할 때는 클래스 타입의 참조변수를 사용해야 한다.</li><li>적합한 인터페이스가 없다면 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 상위 타입을 사용해야 한다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 64. 객체는 인터페이스를 사용해 참조하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 63. 문자열 연결은 느리니 주의하라</title>
      <link href="/2019/03/01/effective-java-item63/"/>
      <url>/2019/03/01/effective-java-item63/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>문자열 연결 연산자(+)는 여러 문자열을 하나로 합쳐주는 편리한 수단이다.<br>그런데 한 줄짜리 출력값(<code>return prefix + str + suffix;</code> 정도?)  혹은 작고 크기가 고정된 객체의 문자열 표현을 만들 때라면 괜찮다.<br>하지만 문자열 여러개를 사용하기 시작하면 성능 저하를 피할 수 없다.  </p><p><strong>문자열 연결 연산자로 문자열 n개를 연결하는 시간은 n^2에 비례한다.</strong><br>문자열은 불변이기 때문에 두 문자열을 연결하는 경우에는 양쪽의 내용을 복사하여 연결한 다음 새로운 String 객체를 만들어야 하기 때문이다.</p><h1 id="문자열-연결을-잘못-사용한-예-느리다"><a href="#문자열-연결을-잘못-사용한-예-느리다" class="headerlink" title="문자열 연결을 잘못 사용한 예 - 느리다!"></a>문자열 연결을 잘못 사용한 예 - 느리다!</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">statement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numItems(); i++) &#123;</span><br><span class="line">        result += lineForItem(i); <span class="comment">//문자열 연결</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="StringBuilder를-사용하여-문자열을-연결한-예"><a href="#StringBuilder를-사용하여-문자열을-연결한-예" class="headerlink" title="StringBuilder를 사용하여 문자열을 연결한 예"></a>StringBuilder를 사용하여 문자열을 연결한 예</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">statement2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(numItems() * LINE_WIDTH);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numItems(); i++) &#123;</span><br><span class="line">       sb.append(lineForItem(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자바 6이후 문자열 연결 성능을 다방면으로 개선 했지만, 두 메서드의 성능 차이는 여전하다.</p><h1 id="String-StringBuffer-StringBuilder의-비교"><a href="#String-StringBuffer-StringBuilder의-비교" class="headerlink" title="String, StringBuffer, StringBuilder의 비교"></a>String, StringBuffer, StringBuilder의 비교</h1><ul><li>String과 StringBuffer는 Java 1.0의 등장과 함께 같이 등장하였다.</li><li>StringBuilder는 조금 뒤인 Java 1.5부터 등장하였다.</li><li>String의 concat연산은 + 기호를 사용하여 concatination을 수행한다.</li><li>StringBuffer와 StringBuilder는 append 메서드를 통해 concatination을 수행한다.</li><li>정확히 말하면 StringBuffer와 StringBuilder는 AbstractStringBuilder를 상속하고 있으며,<br>결국은 같은 append 메서드를 사용한다.</li><li>StringBuffer와 StringBuilder 차이점은 thread-safe에 있다.<ul><li>StringBuffer의 append 메서드에는 <code>syncronized</code> 예약어가 붙어있어 thread-safe하다</li><li>StringBuilder의 append 메서드는 thread-safe 하지 않다.</li><li>따라서 multi-thread 환경에서 문자열 결합을 할 때는 StringBuffer를 사용하는 것이 안전하다.</li><li>단일 thread라면 StringBuilder를 사용하는 것이 StringBuffer보다 성능이 더 좋다.<br>(아무래도 동기화 체크를 안해도 되니 말이다.)</li></ul></li></ul><h2 id="String-String-연산이-느린-이유"><a href="#String-String-연산이-느린-이유" class="headerlink" title="String + String 연산이 느린 이유"></a>String + String 연산이 느린 이유</h2><ul><li>String은 불변 클래스이기 때문에 String + String을 하기 위해서는 </li><li>String내의 char[] 혹은 byte[]를 copy한다.</li><li>2개의 array의 length를 더한 값으로 새로운 array를 생성한다.</li><li>array에 기존의 값을 채워넣는다.</li><li>new String(byte[]) 생성자를 통해 새로운 String 객체를 생성한다.</li><li>이런식으로 하면 String + String 연산이 일어날 때마다 String 객체가 생성된다.</li><li>Heap Memory에 String 객체가 많아지면 GC가 돌면서 String 객체를 제거한다.</li><li>GC는 동작 시 stop the world라는 행위를 한다. <strong>(JVM의 작동이 일시적으로 멈춘다.</strong>)</li><li>위와 같은 행위가 계속되면 당연히 느려 질 수 밖에 없다.</li></ul><h2 id="StringBuilder-append-메서드-파헤치기"><a href="#StringBuilder-append-메서드-파헤치기" class="headerlink" title="StringBuilder.append() 메서드 파헤치기"></a>StringBuilder.append() 메서드 파헤치기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified string to this character sequence.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The characters of the &#123;<span class="doctag">@code</span> String&#125; argument are appended, in</span></span><br><span class="line"><span class="comment">     * order, increasing the length of this sequence by the length of the</span></span><br><span class="line"><span class="comment">     * argument. If &#123;<span class="doctag">@code</span> str&#125; is &#123;<span class="doctag">@code</span> null&#125;, then the four</span></span><br><span class="line"><span class="comment">     * characters &#123;<span class="doctag">@code</span> &quot;null&quot;&#125; are appended.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Let &lt;i&gt;n&lt;/i&gt; be the length of this character sequence just prior to</span></span><br><span class="line"><span class="comment">     * execution of the &#123;<span class="doctag">@code</span> append&#125; method. Then the character at</span></span><br><span class="line"><span class="comment">     * index &lt;i&gt;k&lt;/i&gt; in the new character sequence is equal to the character</span></span><br><span class="line"><span class="comment">     * at index &lt;i&gt;k&lt;/i&gt; in the old character sequence, if &lt;i&gt;k&lt;/i&gt; is less</span></span><br><span class="line"><span class="comment">     * than &lt;i&gt;n&lt;/i&gt;; otherwise, it is equal to the character at index</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;k-n&lt;/i&gt; in the argument &#123;<span class="doctag">@code</span> str&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   str   a string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a reference to this object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    putStringAt(count, str);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위의 코드는 AbstractStringBuilder의 append 메서드이다.  </li><li>새로운 String의 길이 만큼 AbstractStringBuilder의 내의 byte[]의 사이즈를 늘리고 복사한다.</li><li>그 다음 String에 대한 byte[]를 AbstractStringBuilder의 내의 byte[]에 추가한다.</li><li>String + String 연산과의 차이점은 불필요한 String 객체가 발생하지 않는다는 점이다</li></ul><h1 id="String-Concatination의-발전"><a href="#String-Concatination의-발전" class="headerlink" title="String Concatination의 발전"></a>String Concatination의 발전</h1><ul><li>Java String 연산에 대한 성능최적화를 다방면으로 생각하고 있고, Java 9 부터 String의 내부 배열을<br><strong>char[] -&gt; byte[]로 변경</strong>하여 성능을 더 향상 시켰다.</li><li>Java 1.5 버전부터 String + String연산에 대해 <strong>Compile Time에 StringBuilder를 사용하도록 코드를 변경한다.</strong><br>하지만 JDK가 항상 자동으로 바꿔준다는 보장이 없으니 String + String 보다는 StringBuilder를 사용해야 한다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 63. 문자열 연결은 느리니 주의하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 62. 다른 타입이 적절하다면 문자열 사용을 피하라</title>
      <link href="/2019/03/01/effective-java-item62/"/>
      <url>/2019/03/01/effective-java-item62/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>문자열(String)은 텍스트를 표현하도록 설계되었고, 그 일을 아주 멋지게 해낸다.<br>그런데 문자열은 워낙 흔하고 자바가 또 잘 지원해주어 원래 의도하지 않는 용도로도 쓰이는 경향이 있다.</p><h1 id="문자열의-안티패턴"><a href="#문자열의-안티패턴" class="headerlink" title="문자열의 안티패턴"></a>문자열의 안티패턴</h1><h2 id="문자열은-다른-값-타입을-대신하기에-적합하지-않다"><a href="#문자열은-다른-값-타입을-대신하기에-적합하지-않다" class="headerlink" title="문자열은 다른 값 타입을 대신하기에 적합하지 않다."></a>문자열은 다른 값 타입을 대신하기에 적합하지 않다.</h2><p>많은 사람들이 파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때 주로 문자열을 이용한다.<br>하지만 <strong>입력받을 데이터가 진짜 문자열인 경우에만 문자열을 사용하는 것이 좋다.</strong><br>데이터가 수치형이면 int, long, double등 수치에 대한 타입으로 사용하는 것이 좋다.<br>질문의 답이 예&#x2F;아니오라면 boolean을 사용하는것이 좋다.  </p><p>일반화 하여 얘기하자면,<br><strong>기본 타입이든 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고 없다면 새로 하나 타입을 만드는 것이 좋다.</strong></p><h2 id="문자열은-열거-타입-대신하기에-적합하지-않다"><a href="#문자열은-열거-타입-대신하기에-적합하지-않다" class="headerlink" title="문자열은 열거 타입 대신하기에 적합하지 않다."></a>문자열은 열거 타입 대신하기에 적합하지 않다.</h2><p>상수를 열거할 경우에는 문자열 열거 패턴 클래스 보다는 열거 타입(enum)이 훨씬 낫다.</p><h2 id="문자열은-혼합-타입을-대신하기에-적합하지-않다"><a href="#문자열은-혼합-타입을-대신하기에-적합하지-않다" class="headerlink" title="문자열은 혼합 타입을 대신하기에 적합하지 않다."></a>문자열은 혼합 타입을 대신하기에 적합하지 않다.</h2><p>여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">compoundKey</span> <span class="operator">=</span> className + <span class="string">&quot;#&quot;</span> + i.next();</span><br></pre></td></tr></table></figure><p>이 방식은 단점이 많다.<br>예를 들어 문자열에 # 문자열이 있는 경우 혼란스러운 결과가 발생한다.<br>각 요소를 개별적으로 접근하기 위해서는 특정 기준을 통해 문자열을 파싱해야해서 느리고, 귀찮고, 오류 가능성도 크다.</p><p>이럴바에는 <strong>차라리 전용 클래스를 새로 만들어서 각 데이터 별로 멤버 변수를 취하는 것이 좋다.</strong></p><h2 id="문자열은-권한을-표현하기에-적합하지-않다"><a href="#문자열은-권한을-표현하기에-적합하지-않다" class="headerlink" title="문자열은 권한을 표현하기에 적합하지 않다."></a>문자열은 권한을 표현하기에 적합하지 않다.</h2><p>권한(capacity)를 문자열로 표현하는 경우가 종종 있다.</p><h3 id="잘못된-예-문자열을-사용하여-권한을-구분하였다"><a href="#잘못된-예-문자열을-사용하여-권한을-구분하였다" class="headerlink" title="잘못된 예 - 문자열을 사용하여 권한을 구분하였다."></a>잘못된 예 - 문자열을 사용하여 권한을 구분하였다.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ThreadLocal</span><span class="params">()</span> &#123;&#125; <span class="comment">//객체 생성 불가</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 현 스레드의 값을 키로 구분해 저장한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (키가 가르키는) 현 스레드의 값을 반환한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">get</span><span class="params">(String key)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 방식의 문제점은 스레드 구분용 문자열 키가 global namespace에서 공유된다는 점이다.<br>이 방식이 의도대로 동작하려면 각 클라이언트가 고유한 키를 제공해야 한다.<br>만약 두 클라이언트가 서로 소통하지 못해 같은 키를 쓰기로 결정한다면, 의도치 않게 같은 변수를 공유하게 된다.<br>따라서 클라이언트는 제대로 작동하지도 않고 보안에도 취약하다.</p><p>이런 경우에는 String으로 권한을 구분하는 것이 아니라 별도의 타입을 만들어 해결해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ThreadLocal</span><span class="params">()</span> &#123;&#125; <span class="comment">//객체 생성 불가</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Key</span> &#123;</span><br><span class="line">        key() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//위조 불가능한 고유 키를 생성한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Key</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Key key, Object value)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">get</span><span class="params">(Key key)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 방법은 앞서의 문자열 기반 API의 문제점을 해결해 주지만 개선할 부분이 있다.<br>set&#x2F;get 메서드는 이제 static 메서드일 이유가 없다. 따라서 Key의 인스턴스 메서드로 변경하는 것이 좋다.<br>그렇게 하면 Key는 더 이상 스레드 지역변수를 구분하기 위한 키가 아니라 그 자체가 스레드 지역변수가 된다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Key</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Key</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object value)</span>;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 API는 get으로 얻은 Object를 실제 타입으로 타입 캐스팅 해야 해서 타입안전하지 않다.<br>하지만 제네릭을 사용한다면 조금 더 타입 안전하게 만들 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Key</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Key</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>더 적합한 데이터 티입이 있거나 새로 작성할 수 있다면, 문자열을 쓰지 말자</li><li>문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고 오류 가능성도 크다.</li><li>문자열을 잘못 사용하는 흔한 예로는 기본 타입, 열거 타입, 혼합 타입이 있다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 62. 다른 타입이 적절하다면 문자열 사용을 피하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라</title>
      <link href="/2019/03/01/effective-jave-item61/"/>
      <url>/2019/03/01/effective-jave-item61/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>자바의 데이터 타입은 크게 두 가지로 나눌 수 있다.<br><strong>기본 타입 (Primitive type) vs 참조 타입 (Reference Type)</strong> 으로 구분 할 수 있다.  </p><h2 id="기본-타입-Primitive-Type"><a href="#기본-타입-Primitive-Type" class="headerlink" title="기본 타입 (Primitive Type)"></a>기본 타입 (Primitive Type)</h2><ul><li>int</li><li>long</li><li>short</li><li>double</li><li>char</li><li>boolean</li></ul><h2 id="참조-타입-Reference-Type"><a href="#참조-타입-Reference-Type" class="headerlink" title="참조 타입 (Reference Type)"></a>참조 타입 (Reference Type)</h2><ul><li>String</li><li>Integer</li><li>Long</li><li>Double</li><li>Boolean</li></ul><p>기본 타입에 대응되는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다.</p><h1 id="Auto-Boxing-vs-Auto-UnBoxing"><a href="#Auto-Boxing-vs-Auto-UnBoxing" class="headerlink" title="Auto Boxing vs Auto UnBoxing"></a>Auto Boxing vs Auto UnBoxing</h1><p>Java 1.5 부터 기본 타입과 래퍼 타입(Wrapper Type, 참조 타입에 대한 클래스를 래퍼 클래스라고 함)을 자동으로 변환해 주는 기능이 추가되었다.    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; <span class="comment">// Auto UnBoxing</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">l</span> <span class="operator">=</span> k; <span class="comment">//Auto Boxing</span></span><br></pre></td></tr></table></figure><p>이 기능 때문에 개발자는 별도로 Boxing과 UnBoxing을 수행해 주지 않아도 되지만, 그렇다고 두 개가 같은 것은 아니다.<br>기본 타입과 래퍼 타입에는 차이가 있으니 어떤 타입을 사용하는지는 상당히 중요하다.</p><h1 id="기본타입-vs-참조타입"><a href="#기본타입-vs-참조타입" class="headerlink" title="기본타입 vs 참조타입"></a>기본타입 vs 참조타입</h1><p>기본 타입과 참조 타입의 차이점은 크게 3가지이다.</p><ul><li><p>기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)란 속성을 갖는다.</p><ul><li><p>기본 타입은 흔히 말하는 리터럴(Literal)이다.</p><blockquote><p>리터럴(Literal)이란?</p><p>소스 코드의 고정된 값을 의미하는 용어이다.<br>상수(Constants) 또는 변수(Variable)에 할당 할 수 있는 값 자체를 일컫는 용어이다.</p></blockquote></li><li><p>기본 타입의 값은 JVM내의 Stack 메모리에 저장된다.</p></li><li><p>참조 타입의 값은 객체 내의 상수에 저장된다. 따라서 JVM 내의 Heap 메모리에 저장된다.</p></li><li><p>따라서 박싱된 타입의 객체는 같은 값이라 하더라도 다른 객체일 경우에는 다르다고 식별이 가능하다.</p></li></ul></li><li><p>기본 타입의 값은 언제나 유효한 값을 가지고 있으나 박싱된 기본타입은 유효하지 않을 수 있다.</p><ul><li>기본타입의 값은 Java의 경우 초기화 되지 않으면 0으로 초기화 된다.</li><li>박싱된 기본 타입의 경우에는 초기화 되지 않으면 null이 될 수 있다.</li></ul></li><li><p>기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.</p><ul><li>박싱된 타입은 heap에 객체를 생성하기 때문에 메모리 사용면에서 더 안좋다.</li><li>기본타입은 변수에 값이 있는 반면, 박싱된 기본 타입은 변수의 객체참조 정보를 바탕으로 heap에서 찾으므로<br>시간적인 측면에서 기본타입보다 값에 접근하는 시간이 더 들게 된다.</li></ul></li></ul><h1 id="잘못-구현된-비교자-예제"><a href="#잘못-구현된-비교자-예제" class="headerlink" title="잘못 구현된 비교자 예제"></a>잘못 구현된 비교자 예제</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; naturalOrder = (i, j) -&gt; (i &lt; j) ? -<span class="number">1</span> : (i == j ? <span class="number">0</span> : <span class="number">1</span>); </span><br></pre></td></tr></table></figure><ul><li>위의 코드를 기반으로 Integer비교가 실행되면 같은 값을 비교한다고 해도 1이 나올 수 있다.</li><li>첫번째 i &lt; j 에 대한 연산 시, Integer타입인 i와 j는 기본타입 int로 언박싱된다.</li><li>첫번째 연산이 false이면 두번째 연산 i &#x3D;&#x3D; j에서도 false가 발생하게 된다.</li><li>이유는, (i, j)의 타입이 Integer로 추론되기 때문에 i &#x3D;&#x3D; j 연산이 이루어질 때 객체의 동일성검사가 이루어져 false가 발생하기 때문이다. (i와 j는 내부 값은 같지만 서로 다른 객체이기 때문이다.)</li></ul><p><strong>이처럼 같은 객체가 아니라면 박싱된 기본타입에 &#x3D;&#x3D; 연산자를 이용하여 비교하면 예상과는 다른 결과가 나올 수 있다.</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; naturalOrder = (i, j) -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">unBoxi</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="type">int</span> <span class="variable">unBoxj</span> <span class="operator">=</span> j;</span><br><span class="line">    <span class="keyword">return</span> (unBoxi &lt; unBoxj) ? -<span class="number">1</span> : (unBoxi == unBoxj ? <span class="number">0</span> : <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 수정하면 정상적인 결과를 얻을 수 있다.</p><h1 id="갑자기-발생하는-NullPointerException"><a href="#갑자기-발생하는-NullPointerException" class="headerlink" title="갑자기 발생하는 NullPointerException"></a>갑자기 발생하는 NullPointerException</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Unbelievable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Integer i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">42</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;믿을 수 없군&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 프로그램은 “믿을 수 없군”을 출력하지는 않지만, 전혀 예상하지 못한 결과를 보여준다.<br>i &#x3D;&#x3D; 42를 검사하는 과정에서 NullPointerException을 던진다.<br>원인은 i가 literal 값인 42와 비교하는 과정에서 i는 Auto UnBoxing을 수행한다.<br>하지만  i는 null이기 때문에 Auto UnBoxing을 수행하는 과정에서 NullPointerException을 발생시키게 된다.  </p><p><strong>기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.</strong><br>하지만 박싱된 기본타입이 null인 경우에는 NullPointerException이 발생하니 주의 해야 한다.</p><h1 id="의도하지-않은-Auto-Boxing으로-인한-성능저하"><a href="#의도하지-않은-Auto-Boxing으로-인한-성능저하" class="headerlink" title="의도하지 않은 Auto Boxing으로 인한 성능저하"></a>의도하지 않은 Auto Boxing으로 인한 성능저하</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0L</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">        sum += i; <span class="comment">//sum이 UnBoxing되어 i와 연산되고 연산 후에 AutoBoxing되어 Long타입으로 변환된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 sum을 Long으로 선언하였기 때문에 엄청난 성능상 안좋은 코드이다.<br>sum +&#x3D; i;를 수행하는 과정에서 <strong>sum이 long타입으로 UnBoxing되고</strong> sum + i 연산이 이루어진다음 <strong>Long타입으로 AutoBoxing되기 때문이다.</strong></p><h1 id="박싱된-기본타입은-언제-사용해야-하는가"><a href="#박싱된-기본타입은-언제-사용해야-하는가" class="headerlink" title="박싱된 기본타입은 언제 사용해야 하는가?"></a>박싱된 기본타입은 언제 사용해야 하는가?</h1><ul><li>컬렉션의 원소, 키, 값으로 쓴다.<ul><li>컬렉션은 기본타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본타입을 사용해야 한다.</li></ul></li><li>제네릭(Generics) 타입을 이용하는 경우에도 박싱된 기본타입을 사용한다.<ul><li>제네릭 타입에서는 int, double과 같은 기본타입을 지원하지 않기 때문이다.</li></ul></li><li>리플렉션(Reflection)을 통해 메서드를 호출할 때에도 박싱된 기본타입을 사용한다.</li></ul><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>기본 타입과 박싱된 기본 타입을 사용해야 한다면,  가능하면 기본 타입을 사용하는 것이 좋다.</li><li>기본타입은 간단하고 빠르다.</li><li>박싱된 기본 타입을 사용한다면 주의를 기울이자</li><li>AutoBoxing이 기본타입을 변경할 때 번거로움을 줄여주지만 그 위험까지 없애주지는 않는다.<ul><li>박싱된 기본 타입을 &#x3D;&#x3D; 연산자로 비교한다면 객체의 동일성 비교가 이뤄지는데<br>개발자가 의도한 결과가 나오지 않을 가능성이 크다.</li><li>&#x3D;&#x3D; 연산에서 기본 타입과 박싱된 기본 타입의 연산이 이루어지면, 박싱된 기본 타입이 UnBoxing되는데<br>박싱된 기본 타입이 null인 경우 NullPointerException이 발생한다.</li></ul></li><li>기본 타입을 Boxing하는 것은 필요없는 객체를 생성하는 부작용이 나올 수 있다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 60. 정확한 답이 필요하다면 Float와 Double은 피하라</title>
      <link href="/2019/02/28/effective-java-item60/"/>
      <url>/2019/02/28/effective-java-item60/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>float와 double 타입은 과학과 공학 계산용으로 설계되었다.<br>이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 <strong>근사치</strong> 로 계산하도록 세심하게 설계되었다.<br>따라서 정확한 결과가 필요할 때에는 사용해선 안된다<br><strong>float와 double 타입은 특히 금융 관련 계산과는 맞지 않는다.</strong><br>0.1 혹은 10의 거듭 제곱 수를 표현할 수 없기 때문이다.</p><h1 id="예시-금융-계산에-부동소수-타입을-사용"><a href="#예시-금융-계산에-부동소수-타입을-사용" class="headerlink" title="예시 - 금융 계산에 부동소수 타입을 사용"></a>예시 - 금융 계산에 부동소수 타입을 사용</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">funds</span> <span class="operator">=</span> <span class="number">1.00</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">itemBought</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0.10</span>; funds &gt;= price; price += <span class="number">0.10</span>) &#123;</span><br><span class="line">        funds -= price;</span><br><span class="line">        itemsBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">&quot;개 구입&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;잔돈(달러): &quot;</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>프로그램의 실행결과는 사탕 3개를 구입한 후 잔돈은 0.39999999999999달러가 남는다고 나온다.</li><li>잘못된 결과이며, 올바른 결과를 위해서는 <strong>BigDecimal, int, long</strong> 을 사용해야 한다.</li></ul><h2 id="BigDecimal을-사용한-코드-속도가-느리고-쓰기-불편하다"><a href="#BigDecimal을-사용한-코드-속도가-느리고-쓰기-불편하다" class="headerlink" title="BigDecimal을 사용한 코드 - 속도가 느리고 쓰기 불편하다."></a>BigDecimal을 사용한 코드 - 속도가 느리고 쓰기 불편하다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">BigDecimal</span> <span class="variable">TEN_CENTS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;.10&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">itemBought</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">funds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">BigDecimal</span> <span class="variable">price</span> <span class="operator">=</span> TEN_CENT; funds.compareTo(price) &gt;= <span class="number">0</span>; price = price.add(TEN_CENTS)) &#123;</span><br><span class="line">        funds = funds.subtract(price);</span><br><span class="line">        itemsBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">&quot;개 구입&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;잔돈(달러): &quot;</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>이 프로그램의 실행결과는 사탕 4개 구입 후 잔돈이 0달러가 남는다. 올바른 답이다.</li><li>BigDecimal에는 2가지 단점이 있다.<ul><li>기본 타입보다 쓰기가 훨씬 불편하고, 느리다. 단발성 계산이라면 문제는 아니지만 쓰기 불편하다</li><li>BigDecimal의 대안으로 int, long을 사용해도 된다. 하지만 소수점을 직접 관리해야 한다.</li></ul></li></ul><h2 id="int를-사용한-코드-Cent로-문제를-해결"><a href="#int를-사용한-코드-Cent로-문제를-해결" class="headerlink" title="int를 사용한 코드 - Cent로 문제를 해결"></a>int를 사용한 코드 - Cent로 문제를 해결</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">itemBought</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">funds</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">10</span>; funds &gt;= price; price += <span class="number">10</span>) &#123;</span><br><span class="line">        funds -= price;</span><br><span class="line">        itemBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">&quot;개 구입&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;잔돈(달러): &quot;</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>int로 사용하면 BigDecimal 보다는 깔끔하고 정확한 답을 얻을 수 있다.</li></ul><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>정확한 답이 필요한 계산에는 float나 double을 피해야한다.</li><li>소수점 추적은 시스템에 맡기고 코딩시의 불편함이나 성능저하가 중요하지 않다면 BigDecimal을 사용하라</li><li>BigDecimal은 8가지 반올림 모드를 제공하므로 반올림을 거의 완벽하게 제어할 수 있다.</li><li>성능이 중요하고 소수점을 직접 추적할 수 있고 숫자가 너무 크지 않다면 int나 long을 사용하라</li><li>숫자를 9자리 10진수로 표현한다면 int를 사용하라</li><li>숫자를 18자리 10진수로 표현할 수 있다면 long을 사용하라</li><li>숫자가 18자리가 넘어가면 BigDecimal을 사용해야 한다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 60. 정확한 답이 필요하다면 float와 double은 피하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 59. 라이브러리를 익히고 사용하라</title>
      <link href="/2019/02/28/effective-java-item59/"/>
      <url>/2019/02/28/effective-java-item59/</url>
      
        <content type="html"><![CDATA[<h1 id="무작위-정수-만들기"><a href="#무작위-정수-만들기" class="headerlink" title="무작위 정수 만들기"></a>무작위 정수 만들기</h1><p>무작위 정수를 하나 생성한다고 해보자 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">random</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(rnd.nextInt()) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>괜찮아 보이지만 3가지의 문제를 내포하고 있다.</p><ul><li><p>n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다.</p></li><li><p>n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 자주 반환된다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">2</span> * (Integer.MAX_VALUE / <span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(random(n) &lt; n/<span class="number">2</span>) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(low);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>random 메서드가 이상적으로 동작한다면 약 50만개가 출력되어야 하지만, 실제로는 666,666에 가까운 값을 얻는다.<br>무작위로 생성된 수 중에서 2&#x2F;3 가량이 중간값보다 낮은 쪽으로 쏠린 것이다.</p><ul><li>지정한 범위 바깥의 수가 종종 튀어나올 수 있다. rnd.nextInt()가 반환한 값을 Math.abs를 이용해 음수가 아닌 정수로 매핑하기 때문이다.</li></ul><h1 id="표준-라이브러리를-사용하면-다른-프로그래머들의-경험을-활용할-수-있다"><a href="#표준-라이브러리를-사용하면-다른-프로그래머들의-경험을-활용할-수-있다" class="headerlink" title="표준 라이브러리를 사용하면 다른 프로그래머들의 경험을 활용할 수 있다."></a>표준 라이브러리를 사용하면 다른 프로그래머들의 경험을 활용할 수 있다.</h1><ul><li>메서드의 동작 방식은 몰라도 알고리즘에 능통한 개발자나, 여러 분야의 전문가가 설계와 구현에 시간을 들여 개발한 것이다.</li><li>버그가 발생되더라도 다음 릴리스에 수정 보완 개선이 될 수 있다.</li><li>표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.</li><li>핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 되고 어플리케이션 기능 개발에 집중할 수 있다.</li><li>따로 노력하지 않아도 릴리즈가 나올 때 마다 성능이 지속해서 개선된다.</li><li>기능이 점점 많아진다. 개발자 커뮤니티에서 나온 이야기를 바탕으로 논의 후 다음 릴리즈에 기능이 추가되곤 한다.</li><li>라이브러리를 사용하면 많은 사람들에게 낯익은 코드가 된다. 다른 개발자들이 유지보수 하기 쉬워지고 재사용성이 높아진다.</li></ul><h1 id="메이저-버전-릴리즈-마다-수많은-기능이-추가된다"><a href="#메이저-버전-릴리즈-마다-수많은-기능이-추가된다" class="headerlink" title="메이저 버전 릴리즈 마다 수많은 기능이 추가된다."></a>메이저 버전 릴리즈 마다 수많은 기능이 추가된다.</h1><ul><li>자바는 메이저 릴리즈마다 새로운 기능을 설명하는 웹페이지를 공시한다.</li><li>한 번쯤은 읽어볼만 하다</li><li>너무 많아서 읽기 힘든 경우에는 java.lang, java.util, java.io와 하위 패키지들에는 익숙해져야 한다.</li><li>컬렉션 프레임워크나 concurrent 패키지는 알아두면 도움이 도니다.</li></ul><h2 id="예시-transferTo-메서드를-이용해-URL-내용-가져오기"><a href="#예시-transferTo-메서드를-이용해-URL-내용-가져오기" class="headerlink" title="예시 - transferTo 메서드를 이용해 URL 내용 가져오기"></a>예시 - transferTo 메서드를 이용해 URL 내용 가져오기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(args[<span class="number">0</span>]).openStream()) &#123;</span><br><span class="line">        in.transferTo(System.out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java 9 버전 부터 URL정보를 쉽게 출력해 주는 transferTo 메서드를 제공한다.</li></ul><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>라이브러리가 전문적인 기능을 제공해 주지 못할수도 있지만, 라이브러리를 일단 사용해보자</li><li>특별한 기능이 아니라면 누군가 라이브러리로 만들어 두었을 가능성이 높다.<br>일단 라이브러리가 있는지 찾아보자</li><li>일반적으로 라이브러리의 코드는 개발자가 작성한 것보다 품질이 좋고 개선의 여지가 있다.</li><li>라이브러리 코드는 주목을 많이 받고 개발자 커뮤니티에서 문제점이 많이 거론되므로 코드 품질이 점차 좋아진다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 59. 라이브러리를 익히고 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 58. 전통적인 for 문보다는 For-Each문을 사용하라</title>
      <link href="/2019/02/28/effective-java-item58/"/>
      <url>/2019/02/28/effective-java-item58/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>스트림(Stream)이 제격인 작업이 있고, 반복이 제격인 작업이 있다.   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c.iterator(); i.hasNext();) &#123;</span><br><span class="line">    <span class="type">Element</span> <span class="variable">e</span> <span class="operator">=</span> i.next();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> a[i]; <span class="comment">// a[i]로 무언가를 한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 for문과 같은 관용구들은 while문 보다는 낫지만 가장 탁월한 방법은 아니다.<br><strong>반복자와 인덱스 변수는 모두 코드를 지저분하게 할 뿐 우리에게 필요한 건 원소들 뿐이다.</strong><br>또한 컬렉션이냐 배열이냐에 따라 코드 형태가 달라지기 때문에 주의해야 한다.</p><h1 id="향상된-for문-enhanced-for-statement"><a href="#향상된-for문-enhanced-for-statement" class="headerlink" title="향상된 for문 (enhanced for statement)"></a>향상된 for문 (enhanced for statement)</h1><ul><li>반복자와 인덱스 변수를 사용하지 않으니 코드가 깔끔해지고 오류가 날 일이 없다.</li><li>하나의 관용구로 되어있어서 배열이든 컬렉션이든 코드의 형태가 같다.</li><li>콜론(:)은 <strong>안의(in)</strong> 라고 읽으면 된다. (elements안의 각 원소 e에 대해)</li><li>반복 대상이 컬렉션이든 배열이든 for-each문을 사용해도 속도는 그대로이다.</li><li>for-each 문이 만들어 내는 코드는 사람이 손으로 최적화한 것과 사실상 같다.</li></ul><h1 id="컬렉션이-중첩되는-경우-for-each의-이점이-커진다"><a href="#컬렉션이-중첩되는-경우-for-each의-이점이-커진다" class="headerlink" title="컬렉션이 중첩되는 경우 for-each의 이점이 커진다."></a>컬렉션이 중첩되는 경우 for-each의 이점이 커진다.</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Suit</span> &#123; CLUB, DIAMOND, HEART, SPADE&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Rank</span> &#123; ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Collection&lt;Suit&gt; suits = Arrays.asList(Suit.values());</span><br><span class="line"><span class="keyword">static</span> Collection&lt;Rank&gt; ranks = Arrays.asList(Rank.values());</span><br><span class="line"></span><br><span class="line">List&lt;Card&gt; deck = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Suit&gt; i = suits.iterator(); i.hasNext();) &#123;</span><br><span class="line">    <span class="keyword">for</span>(Iterator&lt;Rank&gt; j = ranks.iterator(); j.hasNext();) &#123;</span><br><span class="line">        deck.add(<span class="keyword">new</span> <span class="title class_">Card</span>(i.next(), j.next()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>deck.add(new Card(i.next(), j.next()));</code> 줄이 오류를 일으킨다.</li><li>원래대로 하면 숫자 1개당 rank가 여러번 불려야 하는데 저러면 숫자 1개에 rank 1개 불려 <code>NoSuchElementException</code> 을 던진다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Suit</span> &#123; CLUB, DIAMOND, HEART, SPADE&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Rank</span> &#123; ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Collection&lt;Suit&gt; suits = Arrays.asList(Suit.values());</span><br><span class="line"><span class="keyword">static</span> Collection&lt;Rank&gt; ranks = Arrays.asList(Rank.values());</span><br><span class="line"></span><br><span class="line">List&lt;Card&gt; deck = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Suit suit : suits) &#123;</span><br><span class="line">    <span class="keyword">for</span>(Rank rank : ranks) &#123;</span><br><span class="line">        deck.add(<span class="keyword">new</span> <span class="title class_">Card</span>(suit, rank));   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위와 같이 for-each를 사용하면 깔끔하고 간단하게 코드를 짤 수 있다.</li></ul><h1 id="for-each를-사용할-수-없는-상황"><a href="#for-each를-사용할-수-없는-상황" class="headerlink" title="for-each를 사용할 수 없는 상황"></a>for-each를 사용할 수 없는 상황</h1><ul><li><strong>파괴적인 필터링(destructive filtering)</strong><ul><li>컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 호출해야 한다.</li><li>Java 8 부터 Collection의 removeIf 메서드를 사용해 컬렉션을 명시적으로 순회하지 않을 수 있다.</li></ul></li><li><strong>변형(transforming)</strong><ul><li>리스트나 배열을 순회하면서 원소 값 일부 혹은 전체를 교체하는 경우에는 인덱스를 사용해야 한다.</li></ul></li><li><strong>병렬 반복(parallel iteration)</strong><ul><li>여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.</li></ul></li></ul><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>for문 대신 for-each를 사용할 수 있는 경우는 무조건 사용하자</li><li>전통적인 for문과 비교했을 때, for-each문은 명료하고 유연하고 버그를 예방해 준다.</li><li>for-each문은 컬렉션과 배열은 물론 Iterable 인터페이스를 구현한 객체라면 무엇이든 순회 가능하다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 58. 전통적인 for 문보다는 for-each문을 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 57. 지역변수의 범위를 최소화하라</title>
      <link href="/2019/02/28/effective-java-item57/"/>
      <url>/2019/02/28/effective-java-item57/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p><strong>클래스의 멤버와 접근권한을 최소화하라 (Item 15)</strong> 와 취지가 비슷한 장이다.<br>지역변수의 유효범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.  </p><h1 id="가장-처음-쓰일-때-선언하라"><a href="#가장-처음-쓰일-때-선언하라" class="headerlink" title="가장 처음 쓰일 때 선언하라"></a>가장 처음 쓰일 때 선언하라</h1><ul><li>사용하려면 멀었는데 미리 변수부터 선언하는 코드는 어수선하고 가독성이 좋지 못하다. </li><li>막상 쓰일 시점에 되서는 무슨 타입이었는지, 무슨 값으로 초기화 했는지 기억이 나지 않을 경우가 있다. </li><li>변수가 쓰이는 범위보다 너무 앞서 선언하거나, 다 쓴 뒤에도 할당해제가 되지 않고 여전히 살아있게 된다.</li><li>변수의 scope를 제한하지 못하면 예상하지 못한 결과를 초래할 수 있으니 주의해야 한다.</li></ul><h1 id="모든-지역변수는-선언과-동시에-초기화-하라"><a href="#모든-지역변수는-선언과-동시에-초기화-하라" class="headerlink" title="모든 지역변수는 선언과 동시에 초기화 하라"></a>모든 지역변수는 선언과 동시에 초기화 하라</h1><ul><li><p>초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야한다.</p></li><li><p>try-catch-finally 구문에서는 예외다.</p></li><li><p>변수를 초기화 하는 표현식에서 checked exception을 던질 가능성이 있으면, try 절 안에서 초기화 해야한다.</p></li><li><p>만약, catch나 finally절에서 변수를 이용해야 한다면, try절 바로 앞에 변수를 선언해야 한다.</p></li><li><p>반복문에서는 반복 변수(loop variable)의 범위가 반복문의 몸체, 그리고 for 키워드와 몸체 사이 괄호 안으로 제한된다.</p></li><li><p>반복자 (index)를 사용해야 하는 경우에는 for-each 구문보다 전통적인 for문이 낫다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Element e : c) &#123;</span><br><span class="line">    <span class="comment">// e로 무언가를 반복하는 로직을 구성</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c.iterator(); i.hasNext();) &#123;</span><br><span class="line">    <span class="type">Element</span> <span class="variable">e</span> <span class="operator">=</span> i.next(); <span class="comment">//e와 i로 무언가를 한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="while-문을-사용하는-경우에도-for문을-사용하는-것이-낫다"><a href="#while-문을-사용하는-경우에도-for문을-사용하는-것이-낫다" class="headerlink" title="while 문을 사용하는 경우에도 for문을 사용하는 것이 낫다."></a>while 문을 사용하는 경우에도 for문을 사용하는 것이 낫다.</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Element&gt; i = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext()) &#123;</span><br><span class="line">    doSomeThing(i.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator&lt;Element&gt; i2 = c2.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext()) &#123; </span><br><span class="line">    doSomeThing(i2.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>복붙의 여파로 i2.hasNext()이지만 i.hasNext()를 사용하였다.</li><li>컴파일도 잘되고 실행도 잘되지만, 기대한 결과가 도출되지 않는다.</li><li>for문을 포함한 for-each문을 사용하는 경우에는 이러한 문제를 컴파일 타임에 잡아준다.<br>(반복자의 유효범위가 for문의 종료와 함께 끝나기 때문이다.)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c.iterator(); i.hasNext();) &#123;</span><br><span class="line">    <span class="type">Element</span> <span class="variable">e</span> <span class="operator">=</span> i.next();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i2 = c2.iterator(); i.hasNext();) &#123;</span><br><span class="line">    <span class="type">Element</span> <span class="variable">e2</span> <span class="operator">=</span> i2.next();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>두번째 코드의 i.hasNext()에서 i를 찾을 수 없다는 오류를 보여준다.</li></ul><h1 id="메서드를-작게-유지하고-한-가지-기능에-집중하라"><a href="#메서드를-작게-유지하고-한-가지-기능에-집중하라" class="headerlink" title="메서드를 작게 유지하고 한 가지 기능에 집중하라"></a>메서드를 작게 유지하고 한 가지 기능에 집중하라</h1><ul><li>한 메서드에서 여러 가지 기능을 처리한다면 그중 한 기능과만 관련된 지역변수라도 다른 기능을 수행하는 코드에서 접근할 수 있다.</li><li>단순히 메서드를 기능별로만 쪼개자</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 57. 지역변수의 범위를 최소화하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mongo DB Aggregation Pipeline - SpringBoot에서 사용하기</title>
      <link href="/2019/02/24/2019-02-24-mongodb-3/"/>
      <url>/2019/02/24/2019-02-24-mongodb-3/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot에서-MongoDB-간단설정하기"><a href="#SpringBoot에서-MongoDB-간단설정하기" class="headerlink" title="SpringBoot에서 MongoDB 간단설정하기"></a>SpringBoot에서 MongoDB 간단설정하기</h1><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Spring-boot-starter-data-mongodb Dependency로 간단하게 mongoldb 관련 모든 라이브러리를 로드 할 수 있습니다.</li></ul><h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">mongodb://127.0.0.1:27017/employee-test</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">myUser</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">myUserIsCarrey</span></span><br></pre></td></tr></table></figure><ul><li>SpringBoot에서는 단순하게 application.yml에 connection-uri정보만 있으면 Spring Boot 서버 시작 시<br>MongoDB와 연결할 수 있습니다.</li></ul><h2 id="Mongo-DB-Config"><a href="#Mongo-DB-Config" class="headerlink" title="Mongo DB Config"></a>Mongo DB Config</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MongoConfiguration</span> <span class="keyword">extends</span> <span class="title class_">AbstractMongoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Value(&quot;$&#123;spring.data.mongodb.uri&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line">   <span class="meta">@Value(&quot;$&#123;spring.data.mongodb.username&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String username;</span><br><span class="line">   <span class="meta">@Value(&quot;$&#123;spring.data.mongodb.password&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MongoClient <span class="title function_">mongoClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MongoClientURI</span> <span class="variable">mongoClientURI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MongoClientURI</span>(<span class="built_in">this</span>.url);</span><br><span class="line">        <span class="type">MongoCredential</span> <span class="variable">mongoCredential</span> <span class="operator">=</span> </span><br><span class="line">            MongoCredential.createCredential(<span class="built_in">this</span>.username, mongoClientURI.getDatabase(),<span class="built_in">this</span>.password.toCharArray());</span><br><span class="line">        <span class="type">ServerAddress</span> <span class="variable">serverAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerAddress</span>(mongoClientURI.getHosts().get(<span class="number">0</span>));</span><br><span class="line">        <span class="type">MongoClientOptions</span> <span class="variable">options</span> <span class="operator">=</span> MongoClientOptions.builder().build();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MongoClient</span>(serverAddress, mongoCredential, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getDatabaseName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MongoClientURI</span>(<span class="built_in">this</span>.url).getDatabase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>MongoDB Client 객체를 생성하는 코드를 추가하였습니다.</li><li>credential을 사용하는 경우 저런식으로 credential 객체를 만들어줘야 합니다.</li><li>그렇지 않으면 <code>Command aggregate failed: not authorized on DB to execute command</code> 에러가 발생하며 Mongo DB 기능을 이용할 수 없습니다.</li></ul><h1 id="예제로-풀어보는-Mongo-DB-Aggregation-pipeline"><a href="#예제로-풀어보는-Mongo-DB-Aggregation-pipeline" class="headerlink" title="예제로 풀어보는 Mongo DB Aggregation pipeline"></a>예제로 풀어보는 Mongo DB Aggregation pipeline</h1><p>예제로 등록한 employee collection은 오라클 DB의 예제 DB인 employee 테이블을 차용하였습니다.</p><h2 id="문제-1"><a href="#문제-1" class="headerlink" title="문제 1."></a>문제 1.</h2><p><strong>20 번 및 30 번 부서에서 근무하는 모든 사원들의 ENAME 집합과 부서번호를 출력하라</strong></p><h3 id="Mongo-DB-Aggregation-pipeline"><a href="#Mongo-DB-Aggregation-pipeline" class="headerlink" title="Mongo DB Aggregation pipeline"></a>Mongo DB Aggregation pipeline</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">db.employee.aggregate(</span><br><span class="line">    <span class="punctuation">[</span> </span><br><span class="line">        <span class="punctuation">&#123;</span> </span><br><span class="line">            $match <span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                deptId <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                $in<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">20</span><span class="punctuation">,</span> <span class="number">30</span><span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span> </span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> </span><br><span class="line">            $group <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            _id<span class="punctuation">:</span> <span class="string">&quot;$deptId&quot;</span><span class="punctuation">,</span></span><br><span class="line">                enames<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    $addToSet<span class="punctuation">:</span> <span class="string">&quot;$ename&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            $project <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                _id <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                deptId <span class="punctuation">:</span> <span class="string">&quot;$_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">                enames <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="Spring-Data-MongoDB를-이용한-Java-Code"><a href="#Spring-Data-MongoDB를-이용한-Java-Code" class="headerlink" title="Spring Data MongoDB를 이용한 Java Code"></a>Spring Data MongoDB를 이용한 Java Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 20 번 및 30 번 부서에서 근무하는 모든 사원들의 ENAME 집합과 부서번호를 출력하라</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deptNos</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserListByDeptNo&gt; <span class="title function_">getUserListByDeptNo</span><span class="params">(List&lt;Integer&gt; deptNos)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//match</span></span><br><span class="line">        <span class="type">Criteria</span> <span class="variable">criteria</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Criteria</span>().where(<span class="string">&quot;deptId&quot;</span>).in(deptNos);</span><br><span class="line">        <span class="type">MatchOperation</span> <span class="variable">matchOperation</span> <span class="operator">=</span> Aggregation.match(criteria);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//group</span></span><br><span class="line">        <span class="type">GroupOperation</span> <span class="variable">groupOperation</span> <span class="operator">=</span> Aggregation.group(<span class="string">&quot;deptId&quot;</span>)</span><br><span class="line">                                                   .addToSet(<span class="string">&quot;ename&quot;</span>).as(<span class="string">&quot;enames&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//projection</span></span><br><span class="line">        <span class="type">ProjectionOperation</span> <span class="variable">projectionOperation</span> <span class="operator">=</span> Aggregation.project(<span class="string">&quot;enames&quot;</span>)</span><br><span class="line">                                                             .and(previousOperation()).as(<span class="string">&quot;deptId&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//aggrgation</span></span><br><span class="line">        AggregationResults&lt;UserListByDeptNo&gt; aggregate =</span><br><span class="line">                <span class="built_in">this</span>.mongoTemplate.aggregate(newAggregation(matchOperation, groupOperation, projectionOperation),</span><br><span class="line">                                             Employee.class,</span><br><span class="line">                                             UserListByDeptNo.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> aggregate.getMappedResults();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="문제2"><a href="#문제2" class="headerlink" title="문제2"></a>문제2</h2><p><strong>부서별 연봉합계 순위를 랭킹하여라</strong></p><h3 id="Mongo-DB-Aggregation-pipeline-1"><a href="#Mongo-DB-Aggregation-pipeline-1" class="headerlink" title="Mongo DB Aggregation pipeline"></a>Mongo DB Aggregation pipeline</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">db.employee.aggregate(</span><br><span class="line"> <span class="punctuation">[</span> </span><br><span class="line">     <span class="punctuation">&#123;</span> </span><br><span class="line">         <span class="attr">&quot;$group&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;deptId&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;$deptId&quot;</span> <span class="punctuation">,</span> <span class="attr">&quot;deptName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;$deptName&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;totalSal&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;$sum&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;$sal&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">&#125;</span> <span class="punctuation">,</span> </span><br><span class="line">     <span class="punctuation">&#123;</span> <span class="attr">&quot;$sort&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;totalSal&quot;</span> <span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span> <span class="punctuation">,</span> </span><br><span class="line">     <span class="punctuation">&#123;</span> </span><br><span class="line">         <span class="attr">&quot;$project&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">             <span class="attr">&quot;deptId&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;$_id.deptId&quot;</span> <span class="punctuation">,</span> </span><br><span class="line">             <span class="attr">&quot;deptName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;$_id.deptName&quot;</span> <span class="punctuation">,</span> </span><br><span class="line">             <span class="attr">&quot;totalSal&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line"> <span class="punctuation">]</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Spring-Data-MongoDB를-이용한-Java-Code-1"><a href="#Spring-Data-MongoDB를-이용한-Java-Code-1" class="headerlink" title="Spring Data MongoDB를 이용한 Java Code"></a>Spring Data MongoDB를 이용한 Java Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;SalRankByDept&gt; <span class="title function_">getSalRankByDepts</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//Group</span></span><br><span class="line">       <span class="type">GroupOperation</span> <span class="variable">groupOperation</span> <span class="operator">=</span> Aggregation.group(<span class="string">&quot;deptId&quot;</span>, <span class="string">&quot;deptName&quot;</span>)</span><br><span class="line">               .sum(<span class="string">&quot;sal&quot;</span>).as(<span class="string">&quot;totalSal&quot;</span>);</span><br><span class="line">       <span class="comment">//Sort</span></span><br><span class="line">       <span class="type">SortOperation</span> <span class="variable">sortOperation</span> <span class="operator">=</span> Aggregation.sort(Sort.Direction.DESC, <span class="string">&quot;totalSal&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//Projection</span></span><br><span class="line">       <span class="type">ProjectionOperation</span> <span class="variable">projectionOperation</span> <span class="operator">=</span> Aggregation.project(<span class="string">&quot;deptId&quot;</span>, <span class="string">&quot;deptName&quot;</span>,<span class="string">&quot;totalSal&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//aggrgation</span></span><br><span class="line">       AggregationResults&lt;SalRankByDept&gt; aggregate =</span><br><span class="line">               <span class="built_in">this</span>.mongoTemplate.aggregate(newAggregation(groupOperation, sortOperation, projectionOperation),</span><br><span class="line">                       Employee.class,</span><br><span class="line">                       SalRankByDept.class);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> aggregate.getMappedResults();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="삽질-끝판왕-도전기"><a href="#삽질-끝판왕-도전기" class="headerlink" title="삽질 끝판왕 도전기"></a>삽질 끝판왕 도전기</h1><p>위의 예제 코드 2개를 보면 특이한 점이 한가지 있습니다.<br>바로 Projection Operation 부분이 살짝 다른데요.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//projection</span></span><br><span class="line"><span class="type">ProjectionOperation</span> <span class="variable">projectionOperation</span> <span class="operator">=</span> Aggregation.project(<span class="string">&quot;enames&quot;</span>).and(previousOperation()).as(<span class="string">&quot;deptId&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Projection</span></span><br><span class="line"><span class="type">ProjectionOperation</span> <span class="variable">projectionOperation</span> <span class="operator">=</span> Aggregation.project(<span class="string">&quot;deptId&quot;</span>, <span class="string">&quot;deptName&quot;</span>,<span class="string">&quot;totalSal&quot;</span>);</span><br></pre></td></tr></table></figure><p>위의 코드에서는 grouping key에 대해 조회 할 때</p><p><code>.and(previousOperation()).as(&quot;deptId&quot;)</code> 라고 and 메서드에 <code>previousOperation()</code> 라는 메서드를 적어주었습니다.<br>두번째 코드에서는 그냥 grouping Key를 projection field에 나열하였습니다. </p><p>무슨 차이일까요?</p><ul><li>첫번째 코드는 grouping key가 1개이다.</li><li>두번째 코드는 grouping key가 2개이다.</li></ul><p>위와 같은 차이가 있습니다.</p><p>만약에 1번 코드를 2번처럼 사용한다면</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProjectionOperation</span> <span class="variable">projectionOperation</span> <span class="operator">=</span> Aggregation.project(<span class="string">&quot;deptId&quot;</span>, <span class="string">&quot;enames&quot;</span>);</span><br></pre></td></tr></table></figure><p>이와 같이 사용할 수 있을 것입니다.<br>위의 코드로 수정하고 프로그램을 실행해 보면…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalArgumentException: Parameter deptId must not be null!</span><br></pre></td></tr></table></figure><p>라는 메세지가 나오면서 런타임 예외를 던집니다.<br>뭐 때문에 나는 발생하는 예외 일까요?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Document <span class="title function_">toDocument</span><span class="params">(AggregationOperationContext context)</span> &#123;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">operationObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Document</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.idFields.exposesNoNonSyntheticFields()) &#123;</span><br><span class="line">        operationObject.put(<span class="string">&quot;_id&quot;</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.idFields.exposesSingleNonSyntheticFieldOnly()) &#123;</span><br><span class="line">        <span class="type">FieldReference</span> <span class="variable">reference</span> <span class="operator">=</span> context.getReference((Field)<span class="built_in">this</span>.idFields.iterator().next());</span><br><span class="line">        operationObject.put(<span class="string">&quot;_id&quot;</span>, reference.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Document</span>();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.idFields.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            <span class="type">ExposedField</span> <span class="variable">field</span> <span class="operator">=</span> (ExposedField)var4.next();</span><br><span class="line">            <span class="type">FieldReference</span> <span class="variable">reference</span> <span class="operator">=</span> context.getReference(field);</span><br><span class="line">            inner.put(field.getName(), reference.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        operationObject.put(<span class="string">&quot;_id&quot;</span>, inner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var8</span> <span class="operator">=</span> <span class="built_in">this</span>.operations.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">        GroupOperation.<span class="type">Operation</span> <span class="variable">operation</span> <span class="operator">=</span> (GroupOperation.Operation)var8.next();</span><br><span class="line">        operationObject.putAll(operation.toDocument(context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Document</span>(<span class="string">&quot;$group&quot;</span>, operationObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>원인은 GroupOperation 내부에 있습니다.</strong><br>Aggregation 클래스들의 toDocument 메서드는 MongoDB에 보낼 실제 명령어 구조를 짜는 메서드입니다.  </p><ul><li>첫 번째 if 조건인 <code>this.idFields.exposesNoNonSyntheticFields()</code>은 idFields.isEmpty() 인 경우를 체크 합니다.<ul><li>Group key가 없는 경우는 _id 필드가 null이 되어집니다.</li></ul></li><li>두 번째 if 조건인 <code>this.idFields.exposesSingleNonSyntheticFieldOnly()</code> 은 group key가 1개인 경우를 체크 합니다.<ul><li>group key가 1개인 경우에는 group key 필드에 대한 필드명이 <strong>_id</strong> 로 표현되어 다음 파이프라인에서 사용됩니다.</li><li><code>operationObject.put(&quot;_id&quot;, reference.toString());</code> 여기서 _id에 대한 타입은 <strong>String</strong> 으로 결정나기 때문에<br>다음 파이프라인에서 _id.field와 같은 행위를 할 수 없게 됩니다.</li><li>따라서 {_id : “$deptId”}로 BSON이 생성되기 때문에 다음 파이프라인인 Projection에서는 <strong>deptId인 필드는 찾을 수 없게 되는 것입니다.</strong></li></ul></li><li>마지막 else 조건은 group key가 여러 개인 경우에 대해 Document 객체에 key값을 매핑시킵니다.<ul><li>다음 파이프라인에서 _id.field와 같은 형태로 접근이 가능하기 때문에 group key가 여러개 인 경우에는<br>projection operation에서 group key만 써줘도 자연스럽게 표현이 됩니다.</li><li>내부적으로는 <code>&#123;deptId : &quot;$_id.deptId&quot;, deptName: &quot;$_id.deptName&quot;&#125;</code> 과 같은 형태로 사용 됩니다.</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mongo DB Aggregation Pipeline</title>
      <link href="/2019/02/24/2019-02-24-mongodb-2/"/>
      <url>/2019/02/24/2019-02-24-mongodb-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Aggregation-Pipeline"><a href="#Aggregation-Pipeline" class="headerlink" title="Aggregation Pipeline"></a>Aggregation Pipeline</h1><p>Mongo DB의 Aggregation Framework는 데이터 처리 파이프라인의 개념을 모델로 합니다.<br>문서는 여러 단계의 파이프라인을 거쳐 변화하고 하나의 문서의 형태로 집계할 수 있습니다.</p><p><strong>파이프라인(pipeline)</strong> 이란, 이전 단계의 연산결과를 다음 단계연산에 이용하는 것을 의미합니다.</p><p><img src="./aggregation-pipeline.svg" alt="aggregation-pipeline"></p><h1 id="Stages"><a href="#Stages" class="headerlink" title="Stages"></a>Stages</h1><h2 id="Stages-db-collection-aggregate"><a href="#Stages-db-collection-aggregate" class="headerlink" title="Stages(db.collection.aggregate)"></a>Stages(db.collection.aggregate)</h2><p>db.collection.aggregate 메서드는 파이프라인 단계를 Array의 형태로 나타냅니다.<br>Document는 파이프라인 Array의 순서대로 가공되며, <code>$out</code> 및 <code>$geoNear</code> 를 제외한 모든 단계는 파이프라인에 여러 번 나타날 수 있습니다.</p><h2 id="Match"><a href="#Match" class="headerlink" title="$Match"></a>$Match</h2><ul><li>조건에 만족하는 Document만 Filtering</li></ul><h3 id="입력-형식"><a href="#입력-형식" class="headerlink" title="입력 형식"></a>입력 형식</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $match: &#123; &lt;query&gt; &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> ObjectId(<span class="string">&quot;512bc95fe835e68f199c8686&quot;</span>)<span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;dave&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">80</span><span class="punctuation">,</span> <span class="attr">&quot;views&quot;</span> <span class="punctuation">:</span> <span class="number">100</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> ObjectId(<span class="string">&quot;512bc962e835e68f199c8687&quot;</span>)<span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;dave&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">85</span><span class="punctuation">,</span> <span class="attr">&quot;views&quot;</span> <span class="punctuation">:</span> <span class="number">521</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> ObjectId(<span class="string">&quot;55f5a192d4bede9ac365b257&quot;</span>)<span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ahn&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">60</span><span class="punctuation">,</span> <span class="attr">&quot;views&quot;</span> <span class="punctuation">:</span> <span class="number">1000</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> ObjectId(<span class="string">&quot;55f5a192d4bede9ac365b258&quot;</span>)<span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;li&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">55</span><span class="punctuation">,</span> <span class="attr">&quot;views&quot;</span> <span class="punctuation">:</span> <span class="number">5000</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> ObjectId(<span class="string">&quot;55f5a1d3d4bede9ac365b259&quot;</span>)<span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;annT&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">60</span><span class="punctuation">,</span> <span class="attr">&quot;views&quot;</span> <span class="punctuation">:</span> <span class="number">50</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> ObjectId(<span class="string">&quot;55f5a1d3d4bede9ac365b25a&quot;</span>)<span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;li&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">94</span><span class="punctuation">,</span> <span class="attr">&quot;views&quot;</span> <span class="punctuation">:</span> <span class="number">999</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> ObjectId(<span class="string">&quot;55f5a1d3d4bede9ac365b25b&quot;</span>)<span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ty&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">95</span><span class="punctuation">,</span> <span class="attr">&quot;views&quot;</span> <span class="punctuation">:</span> <span class="number">1000</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.articles.aggregate(</span><br><span class="line">    <span class="punctuation">[</span> <span class="punctuation">&#123;</span> $match <span class="punctuation">:</span> <span class="punctuation">&#123;</span> author <span class="punctuation">:</span> <span class="string">&quot;dave&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span> <span class="punctuation">]</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="연산-결과"><a href="#연산-결과" class="headerlink" title="연산 결과"></a>연산 결과</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> ObjectId(<span class="string">&quot;512bc95fe835e68f199c8686&quot;</span>)<span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;dave&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">80</span><span class="punctuation">,</span> <span class="attr">&quot;views&quot;</span> <span class="punctuation">:</span> <span class="number">100</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> ObjectId(<span class="string">&quot;512bc962e835e68f199c8687&quot;</span>)<span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;dave&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">85</span><span class="punctuation">,</span> <span class="attr">&quot;views&quot;</span> <span class="punctuation">:</span> <span class="number">521</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Group"><a href="#Group" class="headerlink" title="$Group"></a>$Group</h2><ul><li>Document에 대한 Grouping 연산을 수행</li><li>Group에 대한 id를 지정해야하고, 특정 필드에 대한 집계 연산이 가능</li><li>$group은 연산된 Document에 대한 정렬을 지원하지 않음</li></ul><h3 id="입력-형식-1"><a href="#입력-형식-1" class="headerlink" title="입력 형식"></a>입력 형식</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $group: &#123; _id: &lt;expression&gt;, &lt;field1&gt;: &#123; &lt;accumulator1&gt; : &lt;expression1&gt; &#125;, ... &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="accumulator"><a href="#accumulator" class="headerlink" title="accumulator"></a>accumulator</h3><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/addToSet/#grp._S_addToSet"><code>$addToSet</code></a></td><td>id로 Grouping 한 데이터를 중복되지 않은 Set의 형태로 저장</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/avg/#grp._S_avg"><code>$avg</code></a></td><td>숫자 값의 평균을 반환. 숫자가 아닌 값을 무시.</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/first/#grp._S_first"><code>$first</code></a></td><td>각 그룹에 대한 첫 번째 Document의 값을 반환. <br />Document가 정의된 순서가 있는 경우에만 ordering을 지원</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/last/#grp._S_last"><code>$last</code></a></td><td>각 그룹에 대한 마지막 Document의 값을 반환. <br />Document가 정의된 순서가 있는 경우에만 ordering을 지원</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/max/#grp._S_max"><code>$max</code></a></td><td>각 그룹에서 가장 큰 값을 반환</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/mergeObjects/#exp._S_mergeObjects"><code>$mergeObjects</code></a></td><td>각 그룹에 대한 입력 Document를 조합하여 작성한 Document를 반환합니다.</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/min/#grp._S_min"><code>$min</code></a></td><td>각 그룹에서 가장 작은 값을 반환</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/push/#grp._S_push"><code>$push</code></a></td><td>각 그룹의 필드 값의 배열을 반환</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/stdDevPop/#grp._S_stdDevPop"><code>$stdDevPop</code></a></td><td>입력 값의 모집단 표준 편차를 반환</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/stdDevSamp/#grp._S_stdDevSamp"><code>$stdDevSamp</code></a></td><td>입력 값의 샘플 표준 편차를 반환</td></tr><tr><td><a href="https://docs.mongodb.com/master/reference/operator/aggregation/sum/#grp._S_sum"><code>$sum</code></a></td><td>각 그룹의 숫자형 데이터의 합을 반환. 숫자가 아닌 값은 무시</td></tr></tbody></table><h3 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;abc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="attr">&quot;quantity&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;date&quot;</span> <span class="punctuation">:</span> ISODate(<span class="string">&quot;2014-03-01T08:00:00Z&quot;</span>) <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;jkl&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> <span class="attr">&quot;quantity&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;date&quot;</span> <span class="punctuation">:</span> ISODate(<span class="string">&quot;2014-03-01T09:00:00Z&quot;</span>) <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;xyz&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;quantity&quot;</span> <span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="attr">&quot;date&quot;</span> <span class="punctuation">:</span> ISODate(<span class="string">&quot;2014-03-15T09:00:00Z&quot;</span>) <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;xyz&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;quantity&quot;</span> <span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> <span class="attr">&quot;date&quot;</span> <span class="punctuation">:</span> ISODate(<span class="string">&quot;2014-04-04T11:21:39.736Z&quot;</span>) <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;abc&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="attr">&quot;quantity&quot;</span> <span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="attr">&quot;date&quot;</span> <span class="punctuation">:</span> ISODate(<span class="string">&quot;2014-04-04T21:23:13.331Z&quot;</span>) <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="연산-년-x2F-월-x2F-일을-기준으로-group"><a href="#연산-년-x2F-월-x2F-일을-기준으로-group" class="headerlink" title="연산 - 년&#x2F;월&#x2F;일을 기준으로 group"></a>연산 - 년&#x2F;월&#x2F;일을 기준으로 group</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.sales.aggregate(</span><br><span class="line">   <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        $group <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           _id <span class="punctuation">:</span> <span class="punctuation">&#123;</span> month<span class="punctuation">:</span> <span class="punctuation">&#123;</span> $month<span class="punctuation">:</span> <span class="string">&quot;$date&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> day<span class="punctuation">:</span> <span class="punctuation">&#123;</span> $dayOfMonth<span class="punctuation">:</span> <span class="string">&quot;$date&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> year<span class="punctuation">:</span> <span class="punctuation">&#123;</span> $year<span class="punctuation">:</span> <span class="string">&quot;$date&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           totalPrice<span class="punctuation">:</span> <span class="punctuation">&#123;</span> $sum<span class="punctuation">:</span> <span class="punctuation">&#123;</span> $multiply<span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;$price&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$quantity&quot;</span> <span class="punctuation">]</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           averageQuantity<span class="punctuation">:</span> <span class="punctuation">&#123;</span> $avg<span class="punctuation">:</span> <span class="string">&quot;$quantity&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           count<span class="punctuation">:</span> <span class="punctuation">&#123;</span> $sum<span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">]</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>년&#x2F;월&#x2F;일을 기준으로 집계</li><li><code>$price</code> x <code>$quantity</code> 를 곱한 값의 합을 <strong>totalPrice</strong> 필드로 지정</li><li><code>$quantity</code> 필드 값의 평균을 <strong>averageQuantity</strong> 필드로 지정</li><li>Group별 데이터의 갯수를 <strong>count</strong> 로 지정</li></ul><h3 id="연산-결과-1"><a href="#연산-결과-1" class="headerlink" title="연산 결과"></a>연산 결과</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;month&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;day&quot;</span> <span class="punctuation">:</span> <span class="number">15</span><span class="punctuation">,</span> <span class="attr">&quot;year&quot;</span> <span class="punctuation">:</span> <span class="number">2014</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;totalPrice&quot;</span> <span class="punctuation">:</span> <span class="number">50</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;averageQuantity&quot;</span> <span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;count&quot;</span> <span class="punctuation">:</span> <span class="number">1</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;month&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;day&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;year&quot;</span> <span class="punctuation">:</span> <span class="number">2014</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;totalPrice&quot;</span> <span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;averageQuantity&quot;</span> <span class="punctuation">:</span> <span class="number">15</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;count&quot;</span> <span class="punctuation">:</span> <span class="number">2</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;month&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;day&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;year&quot;</span> <span class="punctuation">:</span> <span class="number">2014</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;totalPrice&quot;</span> <span class="punctuation">:</span> <span class="number">40</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;averageQuantity&quot;</span> <span class="punctuation">:</span> <span class="number">1.5</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;count&quot;</span> <span class="punctuation">:</span> <span class="number">2</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Project"><a href="#Project" class="headerlink" title="$Project"></a>$Project</h2><ul><li>Project에서 지정한 필드 값을 다음 파이프라인 단계로 전달</li><li>RDB의 select 와 같은 역할</li><li>Field : 0 - 해당 필드 안보여줌</li><li>Filed : 1 - 해당 필드는 보여줌</li></ul><h3 id="입력형식"><a href="#입력형식" class="headerlink" title="입력형식"></a>입력형식</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $project: &#123; &lt;specification(s)&gt; &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="예제-1"><a href="#예제-1" class="headerlink" title="예제"></a>예제</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  title<span class="punctuation">:</span> <span class="string">&quot;abc123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  isbn<span class="punctuation">:</span> <span class="string">&quot;0001122223334&quot;</span><span class="punctuation">,</span></span><br><span class="line">  author<span class="punctuation">:</span> <span class="punctuation">&#123;</span> last<span class="punctuation">:</span> <span class="string">&quot;zzz&quot;</span><span class="punctuation">,</span> first<span class="punctuation">:</span> <span class="string">&quot;aaa&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  copies<span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>title, author 필드만 표시</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.books.aggregate( [ &#123; $project : &#123; title : 1 , author : 1 &#125; &#125; ] )</span><br></pre></td></tr></table></figure><h3 id="연산-결과-2"><a href="#연산-결과-2" class="headerlink" title="연산 결과"></a>연산 결과</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;title&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;abc123&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;last&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;zzz&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;first&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;aaa&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Sort"><a href="#Sort" class="headerlink" title="$Sort"></a>$Sort</h2><ul><li>정렬 조건에 맞게 파이프라인의 연산결과를 정렬</li><li>ASC : 1, DESC : -1로 표현</li></ul><h3 id="입력-형식-2"><a href="#입력-형식-2" class="headerlink" title="입력 형식"></a>입력 형식</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $sort: &#123; &lt;field1&gt;: &lt;sort order&gt;, &lt;field2&gt;: &lt;sort order&gt; ... &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="예제-2"><a href="#예제-2" class="headerlink" title="예제"></a>예제</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">88</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">92</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">97</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">71</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">79</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">83</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.users.aggregate(</span><br><span class="line">   <span class="punctuation">[</span></span><br><span class="line">     <span class="punctuation">&#123;</span> $sort <span class="punctuation">:</span> <span class="punctuation">&#123;</span> score <span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">]</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="연산-결과-3"><a href="#연산-결과-3" class="headerlink" title="연산 결과"></a>연산 결과</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">97</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">92</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">88</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">83</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">79</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">71</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Skip"><a href="#Skip" class="headerlink" title="$Skip"></a>$Skip</h2><ul><li>입력한 갯수만큼 차례대로 Document를 skip 한 데이터를 다음 파이프라인으로 전달</li></ul><h3 id="입력-형식-3"><a href="#입력-형식-3" class="headerlink" title="입력 형식"></a>입력 형식</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $skip: &lt;positive integer&gt; &#125;</span><br></pre></td></tr></table></figure><h3 id="예제-3"><a href="#예제-3" class="headerlink" title="예제"></a>예제</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate(</span><br><span class="line">    <span class="punctuation">&#123;</span> $skip <span class="punctuation">:</span> <span class="number">5</span> <span class="punctuation">&#125;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="$Sample"></a>$Sample</h2><ul><li>Collection 내에서 입력한 갯수만큼 Random하게 Document 출력</li></ul><h3 id="입력-형식-4"><a href="#입력-형식-4" class="headerlink" title="입력 형식"></a>입력 형식</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> $sample<span class="punctuation">:</span> <span class="punctuation">&#123;</span> size<span class="punctuation">:</span> &lt;positive integer&gt; <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="예제-4"><a href="#예제-4" class="headerlink" title="예제"></a>예제</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;dave123&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;q1&quot;</span> <span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span> <span class="attr">&quot;q2&quot;</span> <span class="punctuation">:</span> <span class="keyword">true</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;dave2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;q1&quot;</span> <span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> <span class="attr">&quot;q2&quot;</span> <span class="punctuation">:</span> <span class="keyword">false</span>  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ahn&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;q1&quot;</span> <span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span> <span class="attr">&quot;q2&quot;</span> <span class="punctuation">:</span> <span class="keyword">true</span>  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;li&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;q1&quot;</span> <span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span> <span class="attr">&quot;q2&quot;</span> <span class="punctuation">:</span> <span class="keyword">false</span>  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;annT&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;q1&quot;</span> <span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> <span class="attr">&quot;q2&quot;</span> <span class="punctuation">:</span> <span class="keyword">true</span>  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;li&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;q1&quot;</span> <span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span> <span class="attr">&quot;q2&quot;</span> <span class="punctuation">:</span> <span class="keyword">true</span>  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ty&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;q1&quot;</span> <span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> <span class="attr">&quot;q2&quot;</span> <span class="punctuation">:</span> <span class="keyword">true</span>  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.users.aggregate(</span><br><span class="line">   <span class="punctuation">[</span> <span class="punctuation">&#123;</span> $sample<span class="punctuation">:</span> <span class="punctuation">&#123;</span> size<span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span> <span class="punctuation">]</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="연산-결과-4"><a href="#연산-결과-4" class="headerlink" title="연산 결과"></a>연산 결과</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;dave2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;q1&quot;</span> <span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> <span class="attr">&quot;q2&quot;</span> <span class="punctuation">:</span> <span class="keyword">false</span>  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;li&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;q1&quot;</span> <span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span> <span class="attr">&quot;q2&quot;</span> <span class="punctuation">:</span> <span class="keyword">false</span>  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ty&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;q1&quot;</span> <span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> <span class="attr">&quot;q2&quot;</span> <span class="punctuation">:</span> <span class="keyword">true</span>  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Count"><a href="#Count" class="headerlink" title="$Count"></a>$Count</h2><ul><li>스테이지에 입력하는 문서 수의 카운트가 포함된 문서를 다음 단계로 전달합니다.</li></ul><h3 id="입력-형식-5"><a href="#입력-형식-5" class="headerlink" title="입력 형식"></a>입력 형식</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> $count<span class="punctuation">:</span> &lt;string&gt; <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="예시-역사-점수-데이터가-있을때"><a href="#예시-역사-점수-데이터가-있을때" class="headerlink" title="예시 - 역사 점수 데이터가 있을때"></a>예시 - 역사 점수 데이터가 있을때</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">88</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">92</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">97</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">71</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">79</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;History&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">83</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="scores-Collection에서-80점-초과인-데이터를-조회하고-그에-대한-Count를-계산"><a href="#scores-Collection에서-80점-초과인-데이터를-조회하고-그에-대한-Count를-계산" class="headerlink" title="scores Collection에서 80점 초과인 데이터를 조회하고 그에 대한 Count를 계산"></a>scores Collection에서 80점 초과인 데이터를 조회하고 그에 대한 Count를 계산</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.scores.aggregate(</span><br><span class="line">  <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      $match<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        score<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          $gt<span class="punctuation">:</span> <span class="number">80</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      $count<span class="punctuation">:</span> <span class="string">&quot;passing_scores&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="연산-결과-5"><a href="#연산-결과-5" class="headerlink" title="연산 결과"></a>연산 결과</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;passing_scores&quot;</span> <span class="punctuation">:</span> <span class="number">4</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="addField"><a href="#addField" class="headerlink" title="$addField"></a>$addField</h2><ul><li>Document에 새 필드를 추가합니다.</li><li>$addFields는 Document 및 새로 추가된 필드에서 모든 기존 필드가 포함된 문서를 출력합니다.</li><li>실제 Document의 문서 내용을 바꾸는 것이 아닌 조회를 하는 용도</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> $addFields<span class="punctuation">:</span> <span class="punctuation">&#123;</span> &lt;newField&gt;<span class="punctuation">:</span> &lt;expression&gt;<span class="punctuation">,</span> ... <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="예시-score라는-collection에-아래와-같은-데이터가-있을때"><a href="#예시-score라는-collection에-아래와-같은-데이터가-있을때" class="headerlink" title="예시 - score라는 collection에 아래와 같은 데이터가 있을때"></a>예시 - score라는 collection에 아래와 같은 데이터가 있을때</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  _id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  student<span class="punctuation">:</span> <span class="string">&quot;Maya&quot;</span><span class="punctuation">,</span></span><br><span class="line">  homework<span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">10</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  quiz<span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">8</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  extraCredit<span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  _id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  student<span class="punctuation">:</span> <span class="string">&quot;Ryan&quot;</span><span class="punctuation">,</span></span><br><span class="line">  homework<span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">5</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  quiz<span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">8</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  extraCredit<span class="punctuation">:</span> <span class="number">8</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="집계-연산을-하여-homework-quiz-필드에-대한-Array의-합을-기존-Document에-추가"><a href="#집계-연산을-하여-homework-quiz-필드에-대한-Array의-합을-기존-Document에-추가" class="headerlink" title="집계 연산을 하여, homework, quiz 필드에 대한 Array의 합을 기존 Document에 추가"></a>집계 연산을 하여, homework, quiz 필드에 대한 Array의 합을 기존 Document에 추가</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.scores.aggregate( <span class="punctuation">[</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">     $addFields<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       totalHomework<span class="punctuation">:</span> <span class="punctuation">&#123;</span> $sum<span class="punctuation">:</span> <span class="string">&quot;$homework&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">,</span></span><br><span class="line">       totalQuiz<span class="punctuation">:</span> <span class="punctuation">&#123;</span> $sum<span class="punctuation">:</span> <span class="string">&quot;$quiz&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">     $addFields<span class="punctuation">:</span> <span class="punctuation">&#123;</span> totalScore<span class="punctuation">:</span></span><br><span class="line">       <span class="punctuation">&#123;</span> $add<span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;$totalHomework&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$totalQuiz&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$extraCredit&quot;</span> <span class="punctuation">]</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span> )</span><br></pre></td></tr></table></figure><h3 id="연산-결과-6"><a href="#연산-결과-6" class="headerlink" title="연산 결과"></a>연산 결과</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;student&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Maya&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;homework&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">10</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;quiz&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">8</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extraCredit&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;totalHomework&quot;</span> <span class="punctuation">:</span> <span class="number">25</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;totalQuiz&quot;</span> <span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;totalScore&quot;</span> <span class="punctuation">:</span> <span class="number">43</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;student&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Ryan&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;homework&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">5</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;quiz&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">8</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extraCredit&quot;</span> <span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;totalHomework&quot;</span> <span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;totalQuiz&quot;</span> <span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;totalScore&quot;</span> <span class="punctuation">:</span> <span class="number">40</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="limit"><a href="#limit" class="headerlink" title="$limit"></a>$limit</h2><ul><li>파이프라인 연산으로 출력된 Document의 갯수를 제한</li></ul><h3 id="입력-형식-6"><a href="#입력-형식-6" class="headerlink" title="입력 형식"></a>입력 형식</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $limit: &lt;positive integer&gt; &#125;</span><br></pre></td></tr></table></figure><h3 id="예제-5"><a href="#예제-5" class="headerlink" title="예제"></a>예제</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate(</span><br><span class="line">    <span class="punctuation">&#123;</span> $limit <span class="punctuation">:</span> <span class="number">5</span> <span class="punctuation">&#125;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="unwind"><a href="#unwind" class="headerlink" title="$unwind"></a>$unwind</h2><ul><li>Document내의 배열 필드를 기반으로 각각의 Document로 분리</li></ul><h3 id="입력-형식-7"><a href="#입력-형식-7" class="headerlink" title="입력 형식"></a>입력 형식</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  $unwind<span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      path<span class="punctuation">:</span> &lt;field path&gt;<span class="punctuation">,</span></span><br><span class="line">      includeArrayIndex<span class="punctuation">:</span> &lt;string&gt;<span class="punctuation">,</span></span><br><span class="line">      preserveNullAndEmptyArrays<span class="punctuation">:</span> &lt;boolean&gt;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>path</code></td><td>string</td><td>배열 필드의 필드 경로.<br />필드 경로를 지정하려면 <code>$</code> 기호를 사용하여 필드 이름에 접두사를 붙이고 따옴표로 묶습니다. (ex : <code>&quot;$arrayField&quot;</code>)</td></tr><tr><td><code>includeArrayIndex</code></td><td>string</td><td>요소의 배열 index값을 저장할 새 필드의 이름. <br />이름은 달러 기호 “$”로 시작할 수 없습니다. (필수 아님)</td></tr><tr><td><code>preserveNullAndEmptyArrays</code></td><td>boolean</td><td>만약 true로 설정 시, path Field값이 null, 빈 배열인 경우에 <code>$unwind</code> 연산 결과가 Document에 표시 됨.<br />만약 false로 설정 시,<code>$unwind</code> 연산 결과가 Document에 표시 되지 않음. (default false) (필수 아님)</td></tr></tbody></table><h3 id="예제-1-기본-예제"><a href="#예제-1-기본-예제" class="headerlink" title="예제 1 - 기본 예제"></a>예제 1 - 기본 예제</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ABC1&quot;</span><span class="punctuation">,</span> sizes<span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="string">&quot;M&quot;</span><span class="punctuation">,</span> <span class="string">&quot;L&quot;</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.aggregate( <span class="punctuation">[</span> <span class="punctuation">&#123;</span> $unwind <span class="punctuation">:</span> <span class="string">&quot;$sizes&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">]</span> )</span><br></pre></td></tr></table></figure><h3 id="연산-결과-1"><a href="#연산-결과-1" class="headerlink" title="연산 결과 1"></a>연산 결과 1</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ABC1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;S&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ABC1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;M&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ABC1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;L&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="예제-2-includeArrayIndex-속성을-이용한-Index-출력"><a href="#예제-2-includeArrayIndex-속성을-이용한-Index-출력" class="headerlink" title="예제 2 - includeArrayIndex 속성을 이용한 Index 출력"></a>예제 2 - includeArrayIndex 속성을 이용한 Index 출력</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ABC&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="string">&quot;M&quot;</span><span class="punctuation">,</span> <span class="string">&quot;L&quot;</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;EFG&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;IJK&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;M&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;LMN&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;XYZ&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="keyword">null</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.aggregate( <span class="punctuation">[</span> </span><br><span class="line">    <span class="punctuation">&#123;</span> $unwind<span class="punctuation">:</span> <span class="punctuation">&#123;</span> path<span class="punctuation">:</span> <span class="string">&quot;$sizes&quot;</span><span class="punctuation">,</span> includeArrayIndex<span class="punctuation">:</span> <span class="string">&quot;arrayIndex&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span> </span><br><span class="line"><span class="punctuation">]</span> )</span><br></pre></td></tr></table></figure><h3 id="연산-결과-2"><a href="#연산-결과-2" class="headerlink" title="연산 결과 2"></a>연산 결과 2</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ABC&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;arrayIndex&quot;</span> <span class="punctuation">:</span> NumberLong(<span class="number">0</span>) <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ABC&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;M&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;arrayIndex&quot;</span> <span class="punctuation">:</span> NumberLong(<span class="number">1</span>) <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ABC&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;arrayIndex&quot;</span> <span class="punctuation">:</span> NumberLong(<span class="number">2</span>) <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;IJK&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;M&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;arrayIndex&quot;</span> <span class="punctuation">:</span> <span class="keyword">null</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="예제-3-preserveNullAndEmptyArrays-속성을-이용한-출력"><a href="#예제-3-preserveNullAndEmptyArrays-속성을-이용한-출력" class="headerlink" title="예제 3 - preserveNullAndEmptyArrays 속성을 이용한 출력"></a>예제 3 - preserveNullAndEmptyArrays 속성을 이용한 출력</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ABC&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="string">&quot;M&quot;</span><span class="punctuation">,</span> <span class="string">&quot;L&quot;</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;EFG&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;IJK&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;M&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;LMN&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;XYZ&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="keyword">null</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.aggregate( <span class="punctuation">[</span></span><br><span class="line">   <span class="punctuation">&#123;</span> $unwind<span class="punctuation">:</span> <span class="punctuation">&#123;</span> path<span class="punctuation">:</span> <span class="string">&quot;$sizes&quot;</span><span class="punctuation">,</span> preserveNullAndEmptyArrays<span class="punctuation">:</span> <span class="keyword">true</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span> )</span><br></pre></td></tr></table></figure><h3 id="연산-결과-3"><a href="#연산-결과-3" class="headerlink" title="연산 결과 3"></a>연산 결과 3</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ABC&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;S&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ABC&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;M&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ABC&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;L&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;EFG&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;IJK&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sizes&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;M&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;item&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;LMN&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://docs.mongodb.com/master/core/aggregation-pipeline/">https://docs.mongodb.com/master/core/aggregation-pipeline/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라</title>
      <link href="/2019/02/24/effective-java-item56/"/>
      <url>/2019/02/24/effective-java-item56/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>API를 쓸모 있게 하려면 잘 작성된 문서도 곁들여야 한다.<br>전통적으로 API는 사람이 직접 작성하므로 코드가 변경되면 매번 함께 수정해야 하는데,<br>자바에서는 자바독(JavaDoc)이라는 유틸리티가 이 귀찮은 작업을 도와준다.</p><p>문서화 주석을 작성하는 규칙은 공식 언어 명세에 속하진 않지만 자바 프로그래머라면 응당 알아야 하는 업계 표준 API라 할 수 있다.</p><h1 id="모든-공개된-리소스에-주석을-달아야-한다"><a href="#모든-공개된-리소스에-주석을-달아야-한다" class="headerlink" title="모든 공개된 리소스에 주석을 달아야 한다."></a>모든 공개된 리소스에 주석을 달아야 한다.</h1><ul><li>API를 올바로 문서화 하려면 공개된 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야 한다.  </li><li>직렬화 할 수 있는 클래스라면 직렬화 형태에 대해서도 적어야 한다.  </li><li>문서화 주석이 없다면 JavaDoc도 그저 공개 API 요소들의 선언만 나열해 주는게 전부다.  </li><li>문서가 잘 갖춰지지 않은 API는 쓰기 헷갈려서 오류의 원인이 되기 쉽다.  </li><li>기본 생성자에는 문서화 주석을 달 방법이 없으니 공개 클래스는 절대 기본 생성자를 사용하면 안된다.  </li><li>유지 보수까지 고려한다면 대다수의 공개되지 않은 클래스, 인터페이스, 생성자, 메서드, 필드에도 문서화 주석을 달아야 한다.</li></ul><h1 id="메서드용-문서화-주석에는-규약을-명료하게-기술해야-한다"><a href="#메서드용-문서화-주석에는-규약을-명료하게-기술해야-한다" class="headerlink" title="메서드용 문서화 주석에는 규약을 명료하게 기술해야 한다."></a>메서드용 문서화 주석에는 규약을 명료하게 기술해야 한다.</h1><ul><li>메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다.</li><li>메서드가 어떻게 동작하는지를 적는게 아니라 무엇을 하는지 기술해야 한다.<br>(how가 아닌 what을 기술해야한다.)</li><li>클라이언트가 해당 메서드를 호출하기 위한 전제조건(precondition)을 모두 나열해야 한다.</li><li>메서드가 성공적으로 수행된 후에 만족해야 하는 사후조건(postcondition)도 모두 나열해야 한다.</li><li>일반적으로 전제조건은 @throw 태그로 비검사 예외를 선언하여 암시적으로 기술한다.<br>비검사 예외 하나가 전제조건 하나와 연결되는 것이다.</li><li>@param 태그를 이용해 그 조건에 영향받는 매개변수에 기술 할 수도 있다.</li></ul><h1 id="전제조건과-사후조건-뿐만-아니라-부작용도-문서화-하라"><a href="#전제조건과-사후조건-뿐만-아니라-부작용도-문서화-하라" class="headerlink" title="전제조건과 사후조건 뿐만 아니라 부작용도 문서화 하라"></a>전제조건과 사후조건 뿐만 아니라 부작용도 문서화 하라</h1><ul><li><strong>부작용</strong>이란 <strong>사후조건으로 명확히 나타나지는 않지만 시스템의 상태에 따라 어떠한 변화</strong>를 가져오는 것을 의미</li><li>예를들어 메서드에서 백그라운드 스레드를 실행시키는 메서드라면 그 사실을 문서에 밝혀야 한다.</li></ul><h1 id="문서화-태그"><a href="#문서화-태그" class="headerlink" title="문서화 태그"></a>문서화 태그</h1><ul><li>@param <ul><li>메서드의 파라미터에 대한 정보</li><li>매개변수가 뜻하는 값을 명사구로 쓴다.</li></ul></li><li>@return <ul><li>메서드의 반환타입이 void가 아니라면 반환 타입을 명시</li><li>반환값이 뜻하는 값을 명사구로 작성</li><li>드물게는 산술표현식으로도 작성하기도 한다.</li></ul></li><li>@throws <ul><li>발생가능성이 있는 모든 예외에 대해 명시</li><li>if로 시작해 해당 예외를 던지를 조건을 설명하는 절이 뒤따른다.</li></ul></li><li>@code<ul><li>태그로 감싼 내용을 코드용 폰트로 렌더링한다.</li><li>태그로 감싼 내용에 포함된 HTML 요소나 다른 JavaDoc 태그를 무시한다.</li><li>@기호에는 무조건 탈출문자를 붙여야 하니 문서화 주석안의 코드에서 annotation을 사용한다면 주의해야한다.</li></ul></li><li>@implSpec<ul><li>자기사용 패턴(self-use pattern)에 대해서도 문서에 남겨 다른 프로그래머에게 그 메서드를 올바르게 재정의 하는 방법을 알려야 한다.</li><li>일반적인 문서화 주석은 해당 메서드와 클라이언트 사이의 관계를 설명</li><li>@implSpec 주석은 해당 메서드와 하위 클래스 사이의 관계를 설명하여, 하위 클래스들이 그 메서드를 상속하거나 super 키워드를 이용해 호출할 때 그 메서드가 어떻게 동작하는지를 명확히 인지하고 사용하게 해야 한다.</li><li>-tag “implSpec:a:Implementation Requirement” 스위치를 키지 않으면 @implSpec 태그를 무시</li></ul></li><li>@literal<ul><li>이 태그는 &lt;, &gt;와 같은 HTML 태그를 무시하게 해준다.</li><li>@code와 비슷하지만, 코드 폰트로 렌더링 하지는 않는다.</li><li>A geometric series converges if {@literal |r| &lt; 1}. 처럼 사용 할 수 있다.</li><li>API 문서에서 가독성을 높이기 위해 사용한다.</li></ul></li></ul><p>관례상 @param, @return, @throws 태그의 설명에는 마침표를 붙이지 않는다.<br>(한글로 작성하는 경우에는 온전한 종결어미로 끝나면 마침표를 붙여주는게 일관돼 보인다.)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This method is &lt;i&gt;not&lt;/i&gt; guaranteed to run in constant time.</span></span><br><span class="line"><span class="comment">* In some implementations it may run in time proportional to the element position.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment">*         (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 이 리스트에서 지정한 위치의 원소를 반환한다.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;이 메서드는 상수시간에 수행됨을 보장하지 &lt;i&gt;않는다.&lt;/i&gt; </span></span><br><span class="line"><span class="comment">* 구현에 따라 원소의 위치에 비례해 시간이 걸릴 수도 있다.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index 반환할 원소의 인덱스</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 이 리스트에서 지정한 위치의 원소</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IndexOutOfBoundsException index가 범위를 벗어나면,</span></span><br><span class="line"><span class="comment">*         즉, (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;) 이면 발생한다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure><h1 id="html-태그의-사용"><a href="#html-태그의-사용" class="headerlink" title="html 태그의 사용"></a>html 태그의 사용</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This method is &lt;i&gt;not&lt;/i&gt; guaranteed to run in constant time.</span></span><br><span class="line"><span class="comment">* In some implementations it may run in time proportional to the element position.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment">*         (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure><ul><li>위에서 보면 <p>나 <i>와 같은 html 태그가 사용되었다.</li><li>JavaDoc 유틸리티는 문서화 주석을 HTML로 변환하므로 문서화 주석 안의 HTML 요소들이 최종 HTML문서에 반영된다.</li></ul><h1 id="요약-설명"><a href="#요약-설명" class="headerlink" title="요약 설명"></a>요약 설명</h1><ul><li><p>각 문서화 주석의 첫 번째 문장은 해당 요소의 요약 설명(Summary description)으로 간주된다.</p></li><li><p><code>Returns the element at the specified position in this list.</code> 와 같은 문장이 이에 속한다.</p></li><li><p>첫 번째 <code>.</code> 기호가 나타나기 전까지의 문장을 첫 번째 문장으로 간주한다.</p></li><li><p>예를들어 “머스터드 대령이나 Mrs. 피콕 같은 용의자.”라고 하면 첫 번째 마침표가 나오는<br>“머스터드 대령이나 Mrs.” 까지만 요약 설명이 된다.</p></li><li><p>위와 같은 예제를 해결하기 위해선 @literal을 사용한다.<br>ex)  머스터드 대령이나 {@literal Mrs.} 피콕 같은 용의자.</p></li><li><p>Java 10부터는 {@summary}라는 요약 설명 전용 태그가 추가되어 한번에 사용 가능하다.<br>{@summary 머스터드 대령이나 Mrs. 피콕 같은 용의자.}</p></li><li><p><strong>요약 설명이란, 문서화 주석의 첫 문장이다.</strong> 라고 말하면 살짝 오해의 소지가 있다.<br>주석 작성 규약에 따르면 요약 설명은 완전한 문장이 되는 경우가 드물기 때문이다.<br>메서드와 생성자의 요약 설명은 해당 메서드와 생성자의 동작을 설명하는 (주어가 없는) 동사구여야 한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList(int initialCapacity): Constructs an empty list with the specified initail capacity</span><br><span class="line">Collection.size(): Returns the number of elements in this collection.</span><br></pre></td></tr></table></figure></li><li><p>클래스나 인터페이스, 필드의 요약설명은 대상을 설명하는 명사절이어야 한다.<br>클래스와 인터페이스의 대상은 그 인스턴스이고, 필드의 대상은 필드 자신이다.  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instant: An instantaneous point on the time-line (타임라인상의 특정순간(지점))</span><br><span class="line">Math.PI: The double value that is closer than any other to pi, the ratio of the circumference of a circle to its diamter (원주율(pi)에 가장 가까운 double 값)</span><br></pre></td></tr></table></figure></li></ul><h1 id="색인-Index-기능"><a href="#색인-Index-기능" class="headerlink" title="색인(Index) 기능"></a>색인(Index) 기능</h1><ul><li><p>자바 9부터는 JavaDoc이 생성한 HTML 문서에 대해 검색(색인) 기능이 추가되어 광대한 API 문서를 누비는 일이 수월해짐</p></li><li><p>@index 태그를 사용해 API에서 중요한 용어를 추가로 색인화 할 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This method compiles with the &#123;@index IEEE 754&#125; standard.</span><br></pre></td></tr></table></figure></li></ul><h1 id="제네릭-타입이나-제네릭-메서드의-주석"><a href="#제네릭-타입이나-제네릭-메서드의-주석" class="headerlink" title="제네릭 타입이나 제네릭 메서드의 주석"></a>제네릭 타입이나 제네릭 메서드의 주석</h1><ul><li>제네릭 타입이나 제네릭 메서드를 문서화 할 때는 모든 타입 매개변수에 주석을 달아야 한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * An object that maps keys to values.  A map cannot contain duplicate keys;</span></span><br><span class="line"><span class="comment"> * each key can map to at most one value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &lt;K&gt; the type of keys maintained by this map</span></span><br><span class="line"><span class="comment"> * @param &lt;V&gt; the type of mapped values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 키와 값을 매핑하는 객체, 맵은 키를 중복해서 가질 수 없다.</span></span><br><span class="line"><span class="comment"> * 즉, 키 하나가 가리킬 수 있는 값은 최대 1개다.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &lt;K&gt; 이 맵이 관리하는 키의 타입</span></span><br><span class="line"><span class="comment"> * @param &lt;V&gt; 매핑된 값의 타입</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br></pre></td></tr></table></figure><h1 id="열거타입에는-상수별로-주석을-달아라"><a href="#열거타입에는-상수별로-주석을-달아라" class="headerlink" title="열거타입에는 상수별로 주석을 달아라"></a>열거타입에는 상수별로 주석을 달아라</h1><ul><li>열거 타입을 문서화할 때는 상수들에도 주석을 달아야 한다.</li><li>열거 타입 자체와 열거 타입의 public 메서드도 물론이다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* An instrument section of a symphony orchestra</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrchestraSection</span> &#123;</span><br><span class="line">    <span class="comment">/** WoodWinds, such as flute, clarinet and oboe */</span></span><br><span class="line">    WOODWIND,</span><br><span class="line">    <span class="comment">/** Brass instruments, such as french horn and trumper */</span></span><br><span class="line">    BRASS,</span><br><span class="line">    <span class="comment">/** Percussion instruments, such as timpani, cymbals */</span></span><br><span class="line">    PERCUSSION,</span><br><span class="line">    <span class="comment">/** Stringed instruments, such as violin and cello */</span></span><br><span class="line">    STRING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="애너테이션-타입을-문서화-할-때는-멤버에도-주석을-달아라"><a href="#애너테이션-타입을-문서화-할-때는-멤버에도-주석을-달아라" class="headerlink" title="애너테이션 타입을 문서화 할 때는 멤버에도 주석을 달아라"></a>애너테이션 타입을 문서화 할 때는 멤버에도 주석을 달아라</h1><ul><li>애너테이션 타입을 문서화할 때는 멤버들에도 모두 주석을 달아야 한다.</li><li>애너테이션 타입 자체도 물론이다.</li><li>필드 설명은 명사구로 한다.</li><li>애너테이션 타입의 요약 설명은 프로그램 요소에 이 애너테이션을 단다는 것이 어떤 의미인지를 설명하는 동사구로 한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates that the annotated method is a test method that </span></span><br><span class="line"><span class="comment"> * must throw the designated exception to pass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTest &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  The exception that the annotated test method must throw</span></span><br><span class="line"><span class="comment">     *  in order to pass. (The test is permitted to throw any subtype</span></span><br><span class="line"><span class="comment">     *  of the type described by this class object.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="패키지를-설명하는-문서화-주석은-package-info-java에-작성한다"><a href="#패키지를-설명하는-문서화-주석은-package-info-java에-작성한다" class="headerlink" title="패키지를 설명하는 문서화 주석은 package-info.java에 작성한다."></a>패키지를 설명하는 문서화 주석은 package-info.java에 작성한다.</h1><ul><li>패키지를 설명하는 문서화 주석은 package-info.java에 명시한다.</li><li>패키지 선언을 반드시 포함해야 하며 패키지 선언관련 애너테이션을 추가로 포함할 수도 있다.</li><li>모듈 시스템을 사용한다면, module-info.java 파일에 작성하면 된다.</li></ul><h1 id="스레드-안전-수준을-반드시-API-설명에-포함해야-한다"><a href="#스레드-안전-수준을-반드시-API-설명에-포함해야-한다" class="headerlink" title="스레드 안전 수준을 반드시 API 설명에 포함해야 한다."></a>스레드 안전 수준을 반드시 API 설명에 포함해야 한다.</h1><ul><li>클래스 혹은 정적 메서드가 스레드 안전하든 그렇지 않든, 스레드 안전 수준을 반드시 API 설명에 포함해야 한다.</li><li>직렬화할 수 있는 클래스라면 직렬화 형태도 API 설명에 기술해야 한다.</li></ul><h1 id="JavaDoc은-메서드-주석을-상속-시킬-수-있다"><a href="#JavaDoc은-메서드-주석을-상속-시킬-수-있다" class="headerlink" title="JavaDoc은 메서드 주석을 상속 시킬 수 있다."></a>JavaDoc은 메서드 주석을 상속 시킬 수 있다.</h1><ul><li>문서화 주석이 없는 API 요소를 발견하면 JavaDoc이 가장 가까운 문서화 주석을 찾아준다.</li><li>상위 클래스보다 구현한 인터페이스 주석을 더 먼저 찾는다.</li><li>@inheritedDoc 태그를 사용해 상위 타입의 문서화 주석 일부를 상속할 수 있다.</li><li>클래스는 자신이 구현한 인터페이스의 문서화 주석을 재사용할 수 있다.</li></ul><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li><p>문서화 주석은 API를 문서화 하는 가장 훌륭하고 효과적인 방법이다.</p></li><li><p>공개 API라면 빠짐없이 설명을 달아야 한다.</p></li><li><p>표준 규약을 일관되게 지키자.</p></li><li><p>문서화 주석이외에 HTML 태그를 사용할 수 있다.</p></li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 55. 옵셔널 반환은 신중히 하라</title>
      <link href="/2019/02/24/effective-java-item55/"/>
      <url>/2019/02/24/effective-java-item55/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>자바 8 전에는  메서드가 특정 조건에서 값을 반환할 수 없을 때 취할 수 있는 선택지가 두 가지 있었다.</p><ul><li>Exception Throw<ul><li>예외는 반드시 예외적인 상황에서만 사용해야 한다.</li><li>예외는 실행 스택을 추적(StackTrace)를 캡처하기 때문에 비용이 비싸다.</li></ul></li><li>Null Return<ul><li>null을 리턴하는 경우에는 NPE(Null Pointer Exception)을 항상 조심해야한다.</li></ul></li></ul><p>자바 8이 등장하면서 Optional이라는 또 하나의 선택지가 추가되었다.</p><h1 id="Optional-이란"><a href="#Optional-이란" class="headerlink" title="Optional 이란?"></a>Optional 이란?</h1><ul><li>Optional이란, 값이 있을 수도 있고 없을 수도 있는 객체이다.  참조 타입의 객체를 한번 감싼 일종의 래퍼 클래스 이다.  </li><li>Optional은 원소를 최대 1개 가질 수 있는 불변 Collection이다.</li><li>자바 8 이전의 코드보다 null-safe한 로직을 처리 할 수 있게 해준다.</li><li>Optional을 반환하여 좀 더 로직을 유연하게 작성할 수 있게 해준다.</li></ul><h1 id="Optional-메서드"><a href="#Optional-메서드" class="headerlink" title="Optional 메서드"></a>Optional 메서드</h1><ul><li><strong>Optional.empty()</strong><ul><li>내부 값이 비어있는 Optional 객체 반환</li></ul></li><li><strong>Optional.of(T value)</strong><ul><li>내부 값이 value인 Optional 객체 반환</li><li>만약 value가 null인 경우 <code>NullPointerException</code> 발생</li></ul></li><li><strong>Optional.ofNullable(T value)</strong><ul><li>가장 자주 쓰이는 Optional 생성 방법</li><li>value가 null이면, empty Optional을 반환하고, 값이 있으면 Optional.of로 생성</li></ul></li><li><strong>T get()</strong><ul><li>Optional 내의 값을 반환</li><li>만약 Optional 내부 값이 null인 경우 <code>NoSuchElementException</code> 발생</li></ul></li><li><strong>boolean isPresent()</strong><ul><li>Optional 내부 값이 null이면 false, 있으면 true</li><li>Optional 내부에서만 사용해야하는 메서드라고 생각</li></ul></li><li><strong>boolean isEmpty()</strong><ul><li>Optional 내부의 값이 null이면 true, 있으면 false</li><li>isPresent() 메서드의 반대되는 메서드</li></ul></li><li><strong>void ifPresent(Consumer&lt;? super T&gt; consumer)</strong><ul><li>Optional 내부의 값이 있는 경우 consumer 함수를 실행</li></ul></li><li><strong>Optional<T> filter(Predicate<T> predicate)</strong><ul><li>Optional에 filter 조건을 걸어 조건에 맞을 때만 Optional 내부 값이 있음</li><li>조건이 맞지 않으면 Optional.empty를 리턴</li></ul></li><li><strong>Optional<U> map(Funtion&lt;? super T, ? extends U&gt; f)</strong><ul><li>Optional 내부의 값을 Function을 통해 가공</li></ul></li><li><strong>T orElse(T other)</strong><ul><li>Optional 내부의 값이 있는 경우 그 값을 반환</li><li>Optional 내부의 값이 null인 경우 other을 반환</li></ul></li><li><strong>T orElseGet(Supplier&lt;? extends T&gt; supplier)</strong><ul><li>Optional 내부의 값이 있는 경우 그 값을 반환</li><li>Optional 내부의 값이 null인 경우 supplier을 실행한 값을 반환</li></ul></li><li><strong>T orElseThrow()</strong><ul><li>Optional 내부의 값이 있는 경우 그 값을 반환</li><li>Optional 내부의 값이 null인 경우 <code>NoSuchElementException</code> 발생</li></ul></li><li><strong>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</strong><ul><li>Optional 내부의 값이 있는 경우 그 값을 반환</li><li>Optional 내부의 값이 null인 경우 exceptionSupplier을 실행하여 Exception 발생</li></ul></li></ul><h1 id="Java8-이전의-코드"><a href="#Java8-이전의-코드" class="headerlink" title="Java8 이전의 코드"></a>Java8 이전의 코드</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">School</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ClassRoom classRoom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassRoom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String subjectName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>학교, 교실, 선생님, 과목이라는 클래스가 주루룩 있을 때 이 학교의 교실의 선생님의 과목을 반환하는 코드를 작성하면</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">school.getClassRoom().getTeacher().getSubject().getSubjectName();</span><br></pre></td></tr></table></figure><p>위와 같은 코드를 작성 할 수 있는데, 위와 같은 코드는 전혀 null-safe 하지 않은 코드가 된다.<br>그렇게 null처리를 추가해보면..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(school != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ClassRoom</span> <span class="variable">classRoom</span> <span class="operator">=</span> school.getClassRoom();</span><br><span class="line">    <span class="keyword">if</span>(classRoom != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> classRoom.getTeacher();</span><br><span class="line">        <span class="keyword">if</span>(teacher != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> teacher.getSubject();</span><br><span class="line">            <span class="keyword">if</span>(subject != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">subjectName</span> <span class="operator">=</span> subject.getSubjectName();</span><br><span class="line">                <span class="keyword">return</span> subjectName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>대충 위와 같은 if 지옥이 발생하게 된다. 조금 다듬어서..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(school == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ClassRoom</span> <span class="variable">classRoom</span> <span class="operator">=</span> school.getClassRoom();</span><br><span class="line"><span class="keyword">if</span>(classRoom == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> classRoom.getTeacher();</span><br><span class="line"><span class="keyword">if</span>(teacher == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> teacher.getSubject();</span><br><span class="line"><span class="keyword">if</span>(subject == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> subject.getSubjectName();</span><br></pre></td></tr></table></figure><p>이정도로 바꿀 수 있겠지만, 만족스러운 코드는 아니다.</p><h1 id="Optional을-이용한-코드"><a href="#Optional을-이용한-코드" class="headerlink" title="Optional을 이용한 코드"></a>Optional을 이용한 코드</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(school).map(School::getClassRoom)    <span class="comment">//Optional&lt;School&gt;</span></span><br><span class="line">                           .map(ClassRoom::getTeacher)   <span class="comment">//Optional&lt;ClassRoom&gt;</span></span><br><span class="line">                           .map(Teacher::getSubject)     <span class="comment">//Optional&lt;Teacher&gt;</span></span><br><span class="line">                           .map(Subject::getSubjectName) <span class="comment">//Optional&lt;Subject&gt;</span></span><br><span class="line">                           .orElse(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><ul><li>map 메서드에서 null인 경우 empty Optional을 반환하기 때문에 NPE가 발생하지 않음</li><li>최후에 orElse 구문에서 Optional 내부의 값이 null인 경우 파라미터로 들어간 null을 반환하기 때문에<br>NPE에 안전하다.</li></ul><h1 id="Optional을-활용한-예제"><a href="#Optional을-활용한-예제" class="headerlink" title="Optional을 활용한 예제"></a>Optional을 활용한 예제</h1><h2 id="Optional을-사용하지-않은-예제"><a href="#Optional을-사용하지-않은-예제" class="headerlink" title="Optional을 사용하지 않은 예제"></a>Optional을 사용하지 않은 예제</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;E&gt;&gt; E <span class="title function_">max</span><span class="params">(Collection&lt;E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(c.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;빈 컬렉션&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(E e : c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="literal">null</span> || e.compareTo(result) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = Objects.requiredNonNull(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional을-사용한-예제"><a href="#Optional을-사용한-예제" class="headerlink" title="Optional을 사용한 예제"></a>Optional을 사용한 예제</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;E&gt;&gt; Optional&lt;E&gt; <span class="title function_">max</span><span class="params">(Collection&lt;E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(c.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(E e : c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="literal">null</span> || e.compareTo(result) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = Objects.requiredNonNull(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Optional.of(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Optional을 반환하여 client에서 더욱 더 유연하게 로직을 작성할 수 있다.</li><li>Optional.of에 null을 넣으면 <code>NullPointerException</code> 이 발생하니 주의해야 한다.</li><li>Optional을 리턴하는 메서드에서는 null을 리턴해서는 안된다. (Optional의 취지와 맞지 않기 때문)</li></ul><h2 id="Stream을-이용한-버전"><a href="#Stream을-이용한-버전" class="headerlink" title="Stream을 이용한 버전"></a>Stream을 이용한 버전</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;E&gt;&gt; Optional&lt;E&gt; <span class="title function_">max</span><span class="params">(Collection&lt;E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.stream().max(Comparator.naturalOrder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="왜-Optional을-사용해야-하는가"><a href="#왜-Optional을-사용해야-하는가" class="headerlink" title="왜 Optional을 사용해야 하는가?"></a>왜 Optional을 사용해야 하는가?</h1><p>기존 로직에서는 null을 반환하거나 예외를 던졌는데, Optional이 등장하고 나서는 Optional을 사용하는 것이 좋다고 한다.<br>그걸 구별하는 기준은 무엇일까?  Optional은 검사 예외와 취지가 비슷하다.<br>즉, 반환값이 있을 수도 있고, 없을 수도 있음을 API 사용자에게 명확히 알려준다.<br>만약 비검사 예외를 던지거나 null을 반환한다면 API 사용자가 그 사실을 인지하지 못해 런타임에서 예상치 못한 장애로 발전할 수 있다.<br>하지만 검사 예외(checked Exception)을 던지면 사용자 코드에서는 try-catch 구문을 통해 예외를 처리하는 로직을 추가해야 한다.<br>비슷하게, 메서드가 Optional을 반환한다면 클라이언트는 값을 받지 못했을 때의 취할 행동을 선택해야 한다.<br>그중 하나는 기본값을 설정하는 것이다.</p><h2 id="Optional-활용1-기본값-defalut-를-정해둘-수-있다"><a href="#Optional-활용1-기본값-defalut-를-정해둘-수-있다" class="headerlink" title="Optional 활용1 - 기본값(defalut)를 정해둘 수 있다."></a>Optional 활용1 - 기본값(defalut)를 정해둘 수 있다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lastWordInLexicon</span> <span class="operator">=</span> max(words).orElse(<span class="string">&quot;단어 없음..&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>실제로 예외를 던진 것이 아니라, empty Optional이 리턴되기 때문에<br>예외 생성 비용이 들지 않는다.</li></ul><h2 id="Optional-활용2-원하는-예외를-던질-수-있다"><a href="#Optional-활용2-원하는-예외를-던질-수-있다" class="headerlink" title="Optional 활용2 - 원하는 예외를 던질 수 있다."></a>Optional 활용2 - 원하는 예외를 던질 수 있다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Toy</span> <span class="variable">myToy</span> <span class="operator">=</span> max(toys).orElseThrow(TemperTantrumException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><ul><li>값이 없는 경우 원하는 예외를 던질 수 있다.</li></ul><h2 id="Optional-활용3-항상-값이-채워져-있는-경우"><a href="#Optional-활용3-항상-값이-채워져-있는-경우" class="headerlink" title="Optional 활용3 - 항상 값이 채워져 있는 경우"></a>Optional 활용3 - 항상 값이 채워져 있는 경우</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Element</span> <span class="variable">lastNobleGas</span> <span class="operator">=</span> max(Elements.NOBLE_GASES).get();</span><br></pre></td></tr></table></figure><ul><li>값이 없는 경우에는 NoSuchElementException이 발생하니 반드시 값이 있는 경우에만 사용해야 한다.</li></ul><h2 id="Optional-활용4-기본값을-설정하는-비용이-큰-경우"><a href="#Optional-활용4-기본값을-설정하는-비용이-큰-경우" class="headerlink" title="Optional 활용4 - 기본값을 설정하는 비용이 큰 경우"></a>Optional 활용4 - 기본값을 설정하는 비용이 큰 경우</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> getConnection(datasource).orElseGet(() -&gt; getLocalConnection());</span><br></pre></td></tr></table></figure><ul><li>기본값을 설정하는 비용이 아주 커서 부담이 되는 경우 orElseGet을 사용하면,<br>값이 처음 필요할 때 Supplier를 사용해 생성하므로 초기 생성비용을 낮출 수 있다.</li></ul><h1 id="Optional-안티-패턴"><a href="#Optional-안티-패턴" class="headerlink" title="Optional 안티 패턴"></a>Optional 안티 패턴</h1><h2 id="Collection-Stream-배열은-Optional로-감싸지-말자"><a href="#Collection-Stream-배열은-Optional로-감싸지-말자" class="headerlink" title="Collection, Stream, 배열은 Optional로 감싸지 말자"></a>Collection, Stream, 배열은 Optional로 감싸지 말자</h2><p>Optional&lt;List<T>&gt;를 반환하기 보다는 빈 ArrayList를 반환하는 것이 좋다. 그렇게 하면 클라이언트 코드에서 Optional 처리 코드를 넣지 않아도 된다.</p><h2 id="Optional을-Map의-키나-값으로-사용하지-말자"><a href="#Optional을-Map의-키나-값으로-사용하지-말자" class="headerlink" title="Optional을 Map의 키나 값으로 사용하지 말자"></a>Optional을 Map의 키나 값으로 사용하지 말자</h2><p>만약 Optional을 Map에서 사용한다면 모호한 상황이 발생한다. </p><ul><li>Key 자체가 없는 경우</li><li>Key는 있지만, 속이 빈 Optional인 경우</li></ul><p>쓸데없이 복잡도만 높아지게 되고 전혀 쓸모없는 짓이니 사용하지 말자.<br>일반화 하자면, <strong>Optional은 Collection의 키, 값, 원소나 배열의 원소로 사용하는게 적절한 상황은 거의 없다.</strong></p><h2 id="isPresent-를-사용하지-말자"><a href="#isPresent-를-사용하지-말자" class="headerlink" title="isPresent()를 사용하지 말자"></a>isPresent()를 사용하지 말자</h2><p>위에서 설명 했듯이 isPresent()는 Optional 객체 내부의 값이 있는경우 true, 없는 경우 false를 반환한다.<br>위의 학교예제를 잠시 따오면..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(school.isPresent()) &#123;</span><br><span class="line">    Optional&lt;ClassRoom&gt; classRoom = school.getClassRoom();</span><br><span class="line">    <span class="keyword">if</span>(classRoom.isPresent()) &#123;</span><br><span class="line">        Optional&lt;Teacher&gt; teacher = classRoom.getTeacher();</span><br><span class="line">        <span class="keyword">if</span>(teacher.isPresent()) &#123;</span><br><span class="line">            Optional&lt;Subject&gt; subject = teacher.getSubject();</span><br><span class="line">            <span class="keyword">if</span>(subject.isPresent()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">subjectName</span> <span class="operator">=</span> subject.getSubjectName();</span><br><span class="line">                <span class="keyword">return</span> subjectName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>이와 같이 사용 될 수 있다.  기존의 if 지옥과 별 다를게 없는 로직이며, Optional의 취지를 제대로 이해하지 못한 로직이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(school).map(School::getClassRoom)    <span class="comment">//Optional&lt;School&gt;</span></span><br><span class="line">                           .map(ClassRoom::getTeacher)   <span class="comment">//Optional&lt;ClassRoom&gt;</span></span><br><span class="line">                           .map(Teacher::getSubject)     <span class="comment">//Optional&lt;Teacher&gt;</span></span><br><span class="line">                           .map(Subject::getSubjectName) <span class="comment">//Optional&lt;Subject&gt;</span></span><br><span class="line">                           .orElse(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>반드시 이런식으로 사용하도록 하는 것이 좋겠다.</p><h1 id="추가-내용"><a href="#추가-내용" class="headerlink" title="추가 내용"></a>추가 내용</h1><ul><li>박싱된 기본타입을 사용할 때에는 OptionalInt, OptionalDouble, OptionalLong을 사용하자<ul><li>박싱된 기본타입을 담는 Optional은 기본타입 보다 무거울 수 밖에 없다. </li><li>따라서 OptionalInt, OptionalDouble, OptionalLong을 사용하는 것이 조금 더 낫다.</li></ul></li><li>값을 반환하지 못할 가능성이 있고, 호출할 때마다 반환값이 없을 가능성을 염두에 둬야 하는 메서드라면<br> Optional을 반환해야 하는 상황일 수 있다.</li><li>Optional을 반환값 이외의 용도로 쓰는 경우는 거의 없다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 55. 옵셔널 반환은 신중히 하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mongo DB 기본쿼리</title>
      <link href="/2019/02/20/2019-02-20-mongodb-1/"/>
      <url>/2019/02/20/2019-02-20-mongodb-1/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB-CRUD-Operation"><a href="#MongoDB-CRUD-Operation" class="headerlink" title="MongoDB CRUD Operation"></a>MongoDB CRUD Operation</h1><p>Mongo DB는 Create, Read, Update, Delete Operation을 제공합니다.</p><h2 id="DDL-SQL-vs-Mongo-DB"><a href="#DDL-SQL-vs-Mongo-DB" class="headerlink" title="DDL SQL vs Mongo DB"></a>DDL SQL vs Mongo DB</h2><p><img src="./create_sql_vs_mongo.png" alt="create_sql_vs_mongo"></p><p><img src="./create_sql_vs_mongo_2.png" alt="create_sql_vs_mongo_2"></p><h1 id="Create-Operations"><a href="#Create-Operations" class="headerlink" title="Create Operations"></a>Create Operations</h1><p>Create, Insert Operation은 컬렉션(Collection)에 도큐먼트(Documents)를 삽입합니다.<br>만약 컬렉션이 아직 존재하지 않는다면, 도큐먼트 삽입과 동시에 컬렉션이 생성됩니다.</p><p>Mongo DB는 아래와 같은 도큐먼트 삽입을 위한 메서드를 제공합니다.</p><ul><li>db.collection.insertOne() <strong>(collection 자리에 실제 collection명을 기재)</strong></li><li>db.collection.insertMany()</li></ul><p>모든 Mongo DB의 삽입 연산은 단일 컬렉션을 대상으로 하며, 모든 쓰기 작업은 단일 도큐먼트에 대해 원자적입니다.</p><p><img src="./insertOne.svg" alt="insertOne"></p><h2 id="Insert-SQL-vs-Mongo-DB-Insert"><a href="#Insert-SQL-vs-Mongo-DB-Insert" class="headerlink" title="Insert SQL vs Mongo DB Insert"></a>Insert SQL vs Mongo DB Insert</h2><p><img src="./insert_sql_vs_mongo.png" alt="insert_sql_vs_mongo"></p><h1 id="Read-Operations"><a href="#Read-Operations" class="headerlink" title="Read Operations"></a>Read Operations</h1><p>읽기 작업(Read Operations)는 컬렉션에서 도큐먼트(Documents)를 검색합니다. (컬렉션을 쿼리하여 문서를 조회)<br>Mongo DB는 아래와 같은 도큐먼트 조회를 위한 메서드를 제공합니다.</p><ul><li>db.collection.find() <strong>(collection 자리에 실제 collection명을 기재)</strong></li></ul><p>Mongo DB 쿼리 간 filter와 조건을 통해 특정한 도큐먼트를 조회할 수 있습니다.<br><img src="./read-query.svg" alt="read-query"></p><p>위의 쿼리는 SQL로 표현한다면 아래와 같습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, address</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">18</span></span><br><span class="line">LIMIT <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="Select-SQL-vs-Mongo-DB-Read"><a href="#Select-SQL-vs-Mongo-DB-Read" class="headerlink" title="Select SQL vs Mongo DB Read"></a>Select SQL vs Mongo DB Read</h2><p><img src="./read_sql_vs_mongo.png" alt="read_sql_vs_mongo"></p><p><img src="./read_sql_vs_mongo2.png" alt="read_sql_vs_mongo2"></p><p><img src="./read_sql_vs_mongo3.png" alt="read_sql_vs_mongo3"></p><h1 id="Update-Operations"><a href="#Update-Operations" class="headerlink" title="Update Operations"></a>Update Operations</h1><p>수정 작업 (Update Operations)은 컬렉션 내에 존재하는 도큐먼트를 수정합니다.<br>Mongo DB는 컬렉션 내의 도큐먼트 수정을 위해 아래와 같은 메서드를 제공합니다. </p><ul><li>db.collection.updateOne() <strong>(collection 자리에 실제 collection명을 기재)</strong></li><li>db.collection.updateMany()</li><li>db.collection.replaceOne()</li></ul><p>Mongo DB에서는 단일 컬렉션을 대상으로 update operation을 지원합니다.<br>Mongo DB 내의 모든 쓰기 작업은 단일 도큐먼트 레벨에서 원자적입니다.</p><p><img src="./update-query.svg" alt="update-query"></p><h2 id="Update-SQL-vs-Mongo-DB-Update"><a href="#Update-SQL-vs-Mongo-DB-Update" class="headerlink" title="Update SQL vs Mongo DB Update"></a>Update SQL vs Mongo DB Update</h2><p><img src="./update_sql_vs_mongo.png" alt="update_sql_vs_mongo"></p><h1 id="Delete-Operations"><a href="#Delete-Operations" class="headerlink" title="Delete Operations"></a>Delete Operations</h1><p>삭제 작업 (Delete Operations)은 컬렉션 내의 도큐먼트를 삭제합니다.<br>Mongo DB는 컬렉션 내의 도큐먼트 삭제를 위해 아래와 같은 메서드를 제공합니다.</p><ul><li>db.collection.deleteOne() <strong>(collection 자리에 실제 collection명을 기재)</strong></li><li>db.collection.deleteMany()</li></ul><p>Mongo DB에서의 삭제 작업은 단일 Collection을 대상으로 합니다.<br>Mongo DB 내의 모든 쓰기 작업은 단일 도큐먼트 레벨에서 원자적입니다.</p><p>특정 filter나 조건을 주어 특정한 도큐먼트를 삭제 할 수 있습니다. (Read Operation과 비슷)</p><p><img src="./delete-query.svg" alt="delete-query"></p><h2 id="Delete-SQL-vs-Mongo-DB-Delete"><a href="#Delete-SQL-vs-Mongo-DB-Delete" class="headerlink" title="Delete SQL vs Mongo DB Delete"></a>Delete SQL vs Mongo DB Delete</h2><p><img src="./delete_sql_vs_mongo.png" alt="delete_sql_vs_mongo"></p><h1 id="Spring-Data-MongoDB를-이용한-CRUD"><a href="#Spring-Data-MongoDB를-이용한-CRUD" class="headerlink" title="Spring Data MongoDB를 이용한 CRUD"></a>Spring Data MongoDB를 이용한 CRUD</h1><p>Spring에서 Mongo DB 연동 시에는 spring-data에서 제공하는 spring-data-mongodb를 이용하는게 가장 편리합니다.</p><h1 id="Maven-설정"><a href="#Maven-설정" class="headerlink" title="Maven 설정"></a>Maven 설정</h1><h2 id="spring-data-mongodb-dependency-추가"><a href="#spring-data-mongodb-dependency-추가" class="headerlink" title="spring-data-mongodb dependency 추가"></a>spring-data-mongodb dependency 추가</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Mongo-DB-QueryDsl-Dependency-추가"><a href="#Mongo-DB-QueryDsl-Dependency-추가" class="headerlink" title="Mongo DB QueryDsl Dependency 추가"></a>Mongo DB QueryDsl Dependency 추가</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.querydsl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>querydsl-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="Document-class-Build-Plugin-설정"><a href="#Document-class-Build-Plugin-설정" class="headerlink" title="Document class Build Plugin 설정"></a>Document class Build Plugin 설정</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysema.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apt-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>jpa-processor<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>process<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>target/generated-sources/java<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">processor</span>&gt;</span>com.querydsl.apt.jpa.JPAAnnotationProcessor<span class="tag">&lt;/<span class="name">processor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>mongodb-processor<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>process<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>target/generated-sources/java<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">processor</span>&gt;</span>org.springframework.data.mongodb.repository.support.MongoAnnotationProcessor<span class="tag">&lt;/<span class="name">processor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Entity-생성"><a href="#Entity-생성" class="headerlink" title="Entity 생성"></a>Entity 생성</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> by Carrey on 2019-02-20</span></span><br><span class="line"><span class="comment"> * Employee Test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Document(collection = &quot;employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String ename;</span><br><span class="line"><span class="keyword">private</span> String job;</span><br><span class="line"><span class="keyword">private</span> Integer mgrId;</span><br><span class="line">    <span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">private</span> LocalDate hiredate;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> sal;</span><br><span class="line"><span class="keyword">private</span> Long commision;</span><br><span class="line">    <span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">private</span> Integer deptId;</span><br><span class="line"><span class="keyword">private</span> String deptName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">raiseSalary</span><span class="params">(DoubleFunction&lt;Long&gt; raiseFormula)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.sal = raiseFormula.apply(<span class="built_in">this</span>.sal);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>@Document</strong> : Class가 Mongo DB Document라는 의미를 지정 (collection 속성에 collection 명 지정)</li><li><strong>@Id</strong> : Document내의 ID지정 (_id 필드에 해당 값이 매핑)<br>(주의! <code>org.springframework.data.annotation.Id</code>를 import 해야함)</li><li>JPA에서는 @Entity 클래스의 ID설정이 무조건 필요했지만, Mongo DB는 선택적으로 @Id지정 가능<br>(@Id를 지정하지 않으면 도큐먼트에 <code>ObjectId라는 키가 자동으로 생성됨</code>)</li><li><strong>@Indexed</strong> : Collection Index를 지정 (단일인덱스 여러개 지정가능)<br>(복합 인덱스도 있으나 일단 기술하지 않음)</li></ul><h2 id="Repository-생성"><a href="#Repository-생성" class="headerlink" title="Repository 생성"></a>Repository 생성</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> by Carrey on 2019-02-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeMongoRepository</span> <span class="keyword">extends</span> <span class="title class_">MongoRepository</span>&lt;Employee, Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MongoRepository-lt-T-ID-gt-에서-제공하는-메서드"><a href="#MongoRepository-lt-T-ID-gt-에서-제공하는-메서드" class="headerlink" title="MongoRepository&lt;T ,ID&gt;에서 제공하는 메서드"></a>MongoRepository&lt;T ,ID&gt;에서 제공하는 메서드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/** CRUDRepository.saveAll */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">&lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">saveAll</span><span class="params">(Iterable&lt;S&gt; entities)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CRUDRepository.findAll */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CRUDRepository.findAll */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort sort)</span>;</span><br><span class="line"></span><br><span class="line">&lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">insert</span><span class="params">(S entity)</span>;</span><br><span class="line"></span><br><span class="line">&lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">insert</span><span class="params">(Iterable&lt;S&gt; entities)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">&lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; example)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">&lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; example, Sort sort)</span>;</span><br></pre></td></tr></table></figure><h2 id="QueryDsl을-이용한-Read-Operations"><a href="#QueryDsl을-이용한-Read-Operations" class="headerlink" title="QueryDsl을 이용한 Read Operations"></a>QueryDsl을 이용한 Read Operations</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeRepository</span> <span class="keyword">extends</span> <span class="title class_">QuerydslRepositorySupport</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@link</span> QuerydslRepositorySupport&#125; for the given &#123;<span class="doctag">@link</span> MongoOperations&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> operations must not be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">EmployeeRepository</span><span class="params">(MongoOperations operations)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(operations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2000$가 넘는 고액 연봉자 조회 쿼리</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getCoreEmployees</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">QEmployee</span> <span class="variable">qEmployee</span> <span class="operator">=</span> QEmployee.employee;</span><br><span class="line">List&lt;Employee&gt; coreEmployees = from(qEmployee).where(qEmployee.sal.gt(<span class="number">2000L</span>))</span><br><span class="line">      .fetch();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> coreEmployees;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>queryDsl 방식의 장점<ul><li>Spring-data 패키지의 메서드를 그대로 쓰기 때문에 JPA에서 사용하던 쿼리와 똑같다.</li></ul></li><li>queryDsl 방식의 단점<ul><li>@Document class를 mongodb-processor를 이용하여 Q클래스로 만들어야 한다.</li><li>Aggregation pipeline을 지원하지 않는다. (가장 큰 단점)</li></ul></li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://docs.mongodb.com/master/crud/">https://docs.mongodb.com/master/crud/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 48. 스트림 병렬화는 주의해서 적용하라</title>
      <link href="/2019/02/17/effective-java-item48/"/>
      <url>/2019/02/17/effective-java-item48/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>주류 언어 중, 동시성 프로그래밍 측면에서는 항상 자바는 앞서왔다.<br>처음 릴리즈된 1996년부터 스레드, 동기화, wait&#x2F;notify를 지원했다. </p><ul><li>자바 5부터는 동시성 컬렉션인 java.util.concurrent 라이브러리와 실행자(Excutor) 프레임워크를 지원했다. </li><li>자바 7부터는 고성능 병렬 분해(parallel decom-position) 프레임워크인 fork-join 패키지를 추가했다.<br>(Fork-join pool에 대한 설명은 <a href="https://okky.kr/article/345720">https://okky.kr/article/345720</a> 여기 참고)  </li><li>자바 8부터는 parallel 메서드만 한 번 호출하면 파이프라인을 병렬 실행할 수 있는 Stream을 지원했다.</li></ul><p>자바로 동시성 프로그램을 작성하기가 점점 쉬워지고 있지만, 이를 올바르고 빠르게 작성하는 일은 어렵다.<br>동시성 프로그래밍을 할 때는 안전성(safety)과 응답 가능(liveness) 상태를 유지하기 애써야 한다.<br>병렬 스트림 파이프라인 프로그래밍에서도 다를 바 없다.</p><h1 id="파이프라인-병렬화가-불가능-한-경우-성능-개선이-되지-않는다"><a href="#파이프라인-병렬화가-불가능-한-경우-성능-개선이-되지-않는다" class="headerlink" title="파이프라인 병렬화가 불가능 한 경우 성능 개선이 되지 않는다."></a>파이프라인 병렬화가 불가능 한 경우 성능 개선이 되지 않는다.</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MersenPrimeTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        primes().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))</span><br><span class="line">                .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                .limit(<span class="number">20</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;running time : &quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        primes().parallel().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))</span><br><span class="line">                .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                .limit(<span class="number">20</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;running time : &quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Stream&lt;BigInteger&gt; <span class="title function_">primes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(TWO, BigInteger::nextProbablePrime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스트림을 이용한 처음 20개의 메르센 소수를 생성하는 프로그램이다.<br>이 프로그램을 실행 시켜보니 test1은 8.2초 정도의 수행시간을 보여줬다<br>test2는 stream의 성능을 향상시켜보고자 parallel()을 호출했다.<br>하지만 메르센 소수의 값이 프린트 되지 않았고, 강제로 중지 하기 전까지 계속 돌고 있었다.<br>아무것도 안된 원인은 stream 라이브러리가 이 파이프라인을 병렬화 하는 방법을 찾아내지 못했기 때문이다.  </p><ul><li>데이터 소스가 Stream.iterate인 경우</li><li>중간 연산으로 limit()를 사용하는 경우<br>위 두 가지 경우에는 파이프라인 병렬화로 성능 향상을 기대하기 어렵다.<br>뿐만 아니라 파이프라인 병렬화는 limit를 다룰 때 <strong>CPU 코어가 남는다면, 원소를 몇 개 더 처리한 후 제한된 개수 이후의 결과를 버려도 아무런 해가 없다고 가정한다.</strong></li></ul><p>따라서 스트림 파이프라인을 마구잡이로 병렬화 해선 안된다. 성능이 오히려 더 나빠질 수 있다.</p><h1 id="언제-병렬화를-사용하나"><a href="#언제-병렬화를-사용하나" class="headerlink" title="언제 병렬화를 사용하나?"></a>언제 병렬화를 사용하나?</h1><ul><li><p>ArrayList</p></li><li><p>HashMap</p></li><li><p>HashSet</p></li><li><p>ConcurrentHashMap</p></li><li><p>배열(Array)</p></li><li><p>int&#x2F;long 범위</p></li></ul><p>스트림의 데이터 소스가 위와 같은 클래스의 인스턴스 일 때 병렬화의 효과가 가장 좋다.<br>위 자료구조들은 모두 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어 다수의 스레드에 분배하기에 좋다.<br>나누는 작업은 <strong>Spliterator</strong>가 담당하며, Spliterator 객체는 Stream, Iterable의 spliterator() 메서드로 얻어올 수 있다.</p><p>또한 위의 자료구조는 <strong>참조 지역성(locality of reference)</strong> 이 높아 성능이 좋다.</p><h1 id="참조-지역성-Locality-of-Reference"><a href="#참조-지역성-Locality-of-Reference" class="headerlink" title="참조 지역성 (Locality of Reference)"></a>참조 지역성 (Locality of Reference)</h1><p><img src="./locality.PNG" alt="locality"></p><p>만일 캐시(Cache)가 어떤 별도의 알고리즘 없이 중간 매개체로만 사용된다면,<br>CPU가 Cache에서 데이터를 읽고 쓰는 속도나 메인 메모리에서 읽고 쓰는 속도나 마찬가지가 될 것이다.  </p><p>캐시 메모리가 제 역할을 하는 것은 데이터의 지역성(locality)를 이용하기 때문.<br>데이터의 지역성은 다음의 세가지로 분류</p><ul><li>공간적 지역성 (partial locality) <ul><li>메인메모리에서 CPU가 요청한 주소지점의 데이터에 인접한 주소들이 앞으로 참조될 확률이 높음을 의미</li><li>이웃한 원소들의 참조가 메모리에 연속적으로 저장되어 있어 다음 참조에 대한 접근 속도가 빠르게 함</li></ul></li><li>시간적 지역성 (temporal locality)<ul><li>한번 참조되었던 데이터는 후에 다시 참조될 가능성이 높음을 의미</li></ul></li><li>순차적 지역성 (sequential locality)<ul><li>따로 분기가 없는 한 데이터가 기억장치에 저장된 순서대로 인출되고 실행될 가능성이 높음을 의미 (FIFO)</li></ul></li></ul><h1 id="스트림-파이프라인의-종단-연산"><a href="#스트림-파이프라인의-종단-연산" class="headerlink" title="스트림 파이프라인의 종단 연산"></a>스트림 파이프라인의 종단 연산</h1><p>스트림 파이프라인의 종단연산의 동작방식 역시 병렬 수행 효율에 영향을 준다.<br>종단 연산 중 병렬화에 가장 적합한 것은 축소(reduction)이다.<br>축소는 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업이다.<br>예를 들면 min, max, sum, count 같이 완성된 형태로 제공되는 메서드가 있다.<br>anyMatch, allMatch, noneMatch처럼 조건에 맞음년 바로 반환되는 메서드도 병렬화에 적합하다.</p><p>반면, 가변 축소(Mutable Reduction)을 수행하는 Stream의 collect 메서드는 병렬화에 적합하지 않다.<br>컬렉션들을 합치는 부담이 크기 때문이다.</p><h1 id="병렬화에-대해-잘모르면-안하는게-낫다"><a href="#병렬화에-대해-잘모르면-안하는게-낫다" class="headerlink" title="병렬화에 대해 잘모르면 안하는게 낫다"></a>병렬화에 대해 잘모르면 안하는게 낫다</h1><p>스트림을 잘못 병렬화하면 (응답 불가를 포함해) 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.<br>(결과가 잘못되거나 오동작하는 것은 <strong>안전 실패(safety failure)</strong> 이라 한다.)<br>안전 실패는 병렬화한 파이프라인이 사용하는 mappers, filters 혹은 프로그래머가 제공한 다른 함수 객체가 명시한대로 동작하지 않을 때 발생할 수 있다.</p><p>Stream 명세는 이때 사용되는 함수 객체에 관한 엄중한 규약을 정의해놨다.</p><h2 id="Stream-명세는-함수-객체에-대한-규약"><a href="#Stream-명세는-함수-객체에-대한-규약" class="headerlink" title="Stream 명세는 함수 객체에 대한 규약"></a>Stream 명세는 함수 객체에 대한 규약</h2><ol><li>Stream의 reduce 연산에 건네지는 accumulator(누적기)와 combiner(결합기) 함수는 반드시 <strong>결합법칙</strong>을 만족해야 한다.<br>(결합 법칙 : (a op b) op c &#x3D; a op (b op c))</li><li>간섭받지 않아야 한다 (non-interfering) - 파이프라인이 수행되는 동안 <strong>데이터소스가 변경되지 않아야한다.</strong></li><li>상태를 갖지 않아야 한다 (stateless)<br>위의 요구사항을 지키지 못하더라도 순차적으로 실행하면 올바른 결과를 얻을 수 있다.<br>하지만 병렬로 수행하면 기대한 결과가 나오지 않을 수 있고, 실패할 수 있으니 주의해야 한다.</li></ol><h1 id="스트림-병렬화는-오직-성능-최적화-수단임을-기억하라"><a href="#스트림-병렬화는-오직-성능-최적화-수단임을-기억하라" class="headerlink" title="스트림 병렬화는 오직 성능 최적화 수단임을 기억하라"></a>스트림 병렬화는 오직 성능 최적화 수단임을 기억하라</h1><p>다른 최적화와 마찬가지로 변경 전후로 반드시 성능테스트를 진행하여 병렬화를 사용할 가치가 있는지 확인해야 한다.<br>이상적으로는 운영 시스템과 같은 환경에서 테스트하는 것이 좋다.<br>보통은 병렬 스트림 파이프라인도 공통의 포크-조인 풀에서 수행되므로 (같은 스레드 풀을 사용)<br>잘못된 파이프라인 하나가 다른 부분의 성능에까지 악영향을 줄 수 있음을 유념하자<br>조건이 잘 갖춰지면 parallel 메서드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 볼 수 있다.</p><h1 id="스트림-파이프라인-병렬화가-효과적인-예"><a href="#스트림-파이프라인-병렬화가-효과적인-예" class="headerlink" title="스트림 파이프라인 병렬화가 효과적인 예"></a>스트림 파이프라인 병렬화가 효과적인 예</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">pi</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">2</span>, n)</span><br><span class="line">                     .mapToObj(BigInteger::valueOf)</span><br><span class="line">                     .filter(i -&gt; i.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                     .count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">pi</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">2</span>, n)</span><br><span class="line">                     .parallel()</span><br><span class="line">                     .mapToObj(BigInteger::valueOf)</span><br><span class="line">                     .filter(i -&gt; i.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">                     .count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>𝛑(n) : n 보다 작거나 같은 소수의 개수를 계산하는 함수</li><li>책에서는 위의 함수를 실행하는데 31초, 아래 parallel()이 추가된 함수를 실행하는데 9.2초가 걸렸다고 한다.</li></ul><h1 id="Random한-수의-경우"><a href="#Random한-수의-경우" class="headerlink" title="Random한 수의 경우"></a>Random한 수의 경우</h1><p>무작위 수들로 이뤄진 스트림을 병렬화하려거든 ThreadLocalRandom(혹은 Random) 보다는<br>SplittableRandom 인스턴스를 이용하자. SplittableRandom은 정확히 이럴 때 쓰고자 설계된 것이라<br>병렬화 하면 성능이 선형으로 증가한다. 한편 ThreadLocalRandom은 단일 스레드에서 사용하고자 만들어 졌다.<br>병렬로 사용하는 경우에는 SplittableRandom &gt; SplittableRandom 성능을 보인다.  </p><p>그냥 Random의 경우에는 모든 연산을 동기화하기 때문에 병렬 처리하면 최악의 성능을 보일 것이다.</p><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>계산도 올바로 수행하고 성능도 빨라질거라는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말자</li><li>스트림 병렬화를 잘못하면 프로그램이 오동작하거나 성능이 급격히 떨어질 수 있다.</li><li>병렬화를 할 경우에는 성능테스트를 반드시 진행하고, 결과가 정확한지 확인해야 한다.</li><li>계산도 정확하고 성능도 좋아졌음이 확실할 때, 그럴 때만 병렬화 버전을 운영 코드에 반영하라</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 48. 스트림 병렬화는 주의해서 적용하라</li><li><a href="https://okky.kr/article/345720">Thread pool과 ForkJoinPool</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 47. 반환 타입으로는 스트림보다 컬렉션이 낫다</title>
      <link href="/2019/02/16/effective-java-item47/"/>
      <url>/2019/02/16/effective-java-item47/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Array형태의 Linear한 자료구조를 반환하는 메서드는 수없이 많다.<br>이런 메서드의 반환타입으로 아래와 같은 타입을 사용했다.</p><ul><li>Collection<E>, Set<E>, List<E>와 같은 컬렉션 인터페이스</li><li>E[]와 같은 배열</li><li>Iterable<E> 인터페이스</li></ul><p>기본은 Collection<E> 타입이다.<br>for-each 문에서만 쓰이거나, (contain(Object) 같은) 일부 Collection 메서드를 구현 할 수 없을 때는 Iterable 인터페이스를 사용한다.<br>성능에 민감한 상황이면, E[] 형태의 배열을 주로 사용해 왔다. </p><p>자바 8이 스트림이라는 개념을 들고오면서 선택이 더욱 복잡해지게 되었다.</p><h1 id="Stream은-반복-loop-을-지원하지-않는다"><a href="#Stream은-반복-loop-을-지원하지-않는다" class="headerlink" title="Stream은 반복(loop)을 지원하지 않는다."></a>Stream은 반복(loop)을 지원하지 않는다.</h1><p>Stream은 반복을 지원하지 않는다.<br>다라서 Stream과 반복을 알맞게 조합해야 좋은 코드가 나온다.<br>API를 Stream만 사용하도록 하면 for-each를 사용하고자 하는 개발자는 불편을 겪을 것이다.<br>(Stream은 Iterator 인터페이스가 정의한 추상메서드를 포함하고 있다. 하지만, Iterator를 확장하진 않아 for-each로 반복하지 못한다.)</p><h2 id="API에서-Stream만-반환하는-경우"><a href="#API에서-Stream만-반환하는-경우" class="headerlink" title="API에서 Stream만 반환하는 경우"></a>API에서 Stream만 반환하는 경우</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a snapshot of all processes visible to the current process.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* &lt;em&gt;Note that processes are created and terminate asynchronously. There</span></span><br><span class="line"><span class="comment">* is no guarantee that a process in the stream is alive or that no other</span></span><br><span class="line"><span class="comment">* processes may have been created since the inception of the snapshot.</span></span><br><span class="line"><span class="comment">* &lt;/em&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> a Stream of ProcessHandles for all processes</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> SecurityException if a security manager has been installed and</span></span><br><span class="line"><span class="comment">*         it denies RuntimePermission(&quot;manageProcess&quot;)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> UnsupportedOperationException if the implementation</span></span><br><span class="line"><span class="comment">*         does not support this operation</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> Stream&lt;ProcessHandle&gt; <span class="title function_">allProcesses</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ProcessHandleImpl.children(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 자바 타입추론의 한계로 컴파일되지 않는다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test.java:6 error: method reference not expected here</span><br><span class="line">for (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) &#123;</span><br><span class="line">                        ^</span><br></pre></td></tr></table></figure><p>이 오류를 바로 잡으려면 메서드 참조를 매개변수화된 Iterable로 적절히 형변환 해줘야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(ProcessHandle ph : (Iterable&lt;ProcessHandle&gt;) ProcessHandle.allProcesses().iterator()) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>책에서는 이런식으로 억지로 형변환을 하면, 작동은 한다고 한다.<br>(하지만 실제로 코드를 실행해 본 결과 <code>ClassCastException</code>이 발생하였다.)</p><h3 id="Stream-lt-E-gt-를-Iterable-lt-E-gt-로-중개해주는-어댑터"><a href="#Stream-lt-E-gt-를-Iterable-lt-E-gt-로-중개해주는-어댑터" class="headerlink" title="Stream&lt;E&gt;를 Iterable&lt;E&gt;로 중개해주는 어댑터"></a>Stream<code>&lt;</code>E<code>&gt;</code>를 Iterable<code>&lt;</code>E<code>&gt;</code>로 중개해주는 어댑터</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Iterable&lt;E&gt; <span class="title function_">iterableOf</span><span class="params">(Stream&lt;E&gt; stream)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stream::iterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ProcessHandle ph : iterableOf(ProcessHandle.allProcesses()) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iterableOf 메서드를 통해 명시적으로 Iterable으로 반환할 수 있다.</p><h2 id="API에서-Iterator만-반환하는-경우"><a href="#API에서-Iterator만-반환하는-경우" class="headerlink" title="API에서 Iterator만 반환하는 경우"></a>API에서 Iterator만 반환하는 경우</h2><p>API에서 Iterator만 반환하는 경우에도 Stream 코드가 편한 개발자들은 불편을 겪을 수 있다.<br>자바는 Iterator -&gt; Stream을 위한 어댑터를 제공하지 않지만, 손쉽게 구현이 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Iterator&lt;E&gt;를 Stream&lt;E&gt;로 중개해주는 어댑터</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; Stream&lt;E&gt; <span class="title function_">streamOf</span><span class="params">(Iterable&lt;E&gt; iterable)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(iterable.spliterator(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>객체 시퀀스를 반환하는 메서드를 작성할 때, 메서드가 오직 Stream 파이프라인에서만 쓰인다면 마음놓고 Stream을 반환하자.<br>하지만 for-each를 사용하는 개발자와 Stream을 사용하는 개발자를 모두 배려하여 Stream과 Iterable을 동시에 제공할 수 있도록 하는 것이 좋다.<br>따라서 <strong>원소 시퀀스를 반환하는 공개 API의 반환 타입에는 Collection이나 그 하위타입을 쓰는 것이 일반적이다</strong></p><h1 id="컬렉션-내의-시퀀스가-크면-전용-컬렉션을-구현하라"><a href="#컬렉션-내의-시퀀스가-크면-전용-컬렉션을-구현하라" class="headerlink" title="컬렉션 내의 시퀀스가 크면 전용 컬렉션을 구현하라"></a>컬렉션 내의 시퀀스가 크면 전용 컬렉션을 구현하라</h1><p>반환하는 시퀀스의 크기가 메모리에 올려도 안전할 만큼 작다면 ArrayList나 HashSet 같은 표준 컬렉션 구현체를 반환하는게 최선일 수 있다.<br>하지만 단지 컬렉션을 반환한다는 이유로 <strong>덩치 큰 시퀀스를 메모리에 올려서는 안된다.</strong></p><h2 id="예시-입력-집합의-멱집합을-전용-컬렉션에-담아-반환한다"><a href="#예시-입력-집합의-멱집합을-전용-컬렉션에-담아-반환한다" class="headerlink" title="예시 - 입력 집합의 멱집합을 전용 컬렉션에 담아 반환한다."></a>예시 - 입력 집합의 멱집합을 전용 컬렉션에 담아 반환한다.</h2><p>멱집합이란, <strong>한 집합의 모든 부분집합을 원소로 하는 집합</strong>이다.<br>예를 들어 (a, b, c)의 멱집합은 ((), (a), (b), (c), (a, b), (a, c), (b, c), (a, b, c))이다.<br>원소의 갯수가 n개일 때, 원소의 갯수는 2^n개가 된다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerSet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;E&gt; Collection&lt;Set&lt;E&gt;&gt; <span class="title function_">of</span><span class="params">(Set&lt;E&gt; s)</span> &#123;</span><br><span class="line">       List&lt;E&gt; src = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(s);</span><br><span class="line">       <span class="keyword">if</span>(src.size() &gt; <span class="number">30</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;집합에 원소가 너무 많습니다(최대 30개).: &quot;</span> + s);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AbstractList</span>&lt;Set&lt;E&gt;&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; src.size();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> o <span class="keyword">instanceof</span> Set &amp;&amp; src.containsAll((Set) o);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Set&lt;E&gt; <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">               Set&lt;E&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; index != <span class="number">0</span>; i++, index &gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span>((index &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                       result.add(src.get(i));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>입력 집합의 원소 수가 30을 넘으면 Power.of가 예외를 던진다.<br>(size() 메서드의 리턴타입은 int이기 때문에 최대길이는 2^31 - 1 또는 Integer.MAX_VALUE로 제한 되기 때문)</li><li>이는 Stream이나, Iterable이 아닌 Collection을 쓸 때의 단점을 보여준다.<br>(Stream이나 Iterable은 size에 대한 고민이 필요없기 때문)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// Query Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of elements in this collection.  If this collection</span></span><br><span class="line"><span class="comment">     * contains more than &#123;<span class="doctag">@code</span> Integer.MAX_VALUE&#125; elements, returns</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Integer.MAX_VALUE&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of elements in this collection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Collection 인터페이스에서는 collection의 size가 int 범위를 넘어가는 경우 Integer.MAX_VALUE를 리턴하라고 하지만 만족스러운 해법은 아니다.</li></ul><h1 id="Stream이-나을-때도-있다"><a href="#Stream이-나을-때도-있다" class="headerlink" title="Stream이 나을 때도 있다."></a>Stream이 나을 때도 있다.</h1><p>위의 예제처럼 AbstractCollection을 활용해서 Collection 구현체를 리턴 할 때는 Iterator용 메서드 외에 2개만 더 구현하면 된다.<br>바로 <code>contains</code>과 <code>size</code>이다.  </p><p>하지만 반복이 시작되기 전에는 (시퀀스의 내용을 확정할 수 없는 등의 사유로) contains와 size를 구현할 수 없는 경우에는 Collection이나 Iterable을 반환하는 편이 낫다.</p><h2 id="예시-입력-리스트의-모든-부분-리스트를-Stream으로-반환"><a href="#예시-입력-리스트의-모든-부분-리스트를-Stream으로-반환" class="headerlink" title="예시 - 입력 리스트의 모든 부분 리스트를 Stream으로 반환"></a>예시 - 입력 리스트의 모든 부분 리스트를 Stream으로 반환</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; <span class="title function_">of</span><span class="params">(List&lt;E&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.concat(Stream.of(Collections.emptyList()), </span><br><span class="line">                             prefixes(list).flatMap(SubList::suffixes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; <span class="title function_">prefixes</span><span class="params">(List&lt;E&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">1</span>, list.size())</span><br><span class="line">                        .mapToObj(end -&gt; list.subList(<span class="number">0</span>, end));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; <span class="title function_">suffixes</span><span class="params">(List&lt;E&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">0</span>, list.size())</span><br><span class="line">                        .mapToObj(start -&gt; list.subList(start, list.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(a, b, c)의 prefixes는 (a), (a, b), (a, b, c) 이다</li><li>(a, b, c)의 suffixes는 (c), (b, c), (a, b, c) 이다</li><li>Stream.concat 메서드는 반환되는 Stream에 빈 리스트를 추가하며, flatMap은 모든 Stream을 하나의 Stream으로 만든다.</li></ul><h2 id="위의-내용과-같은-로직-for-loop를-이용한-코드"><a href="#위의-내용과-같은-로직-for-loop를-이용한-코드" class="headerlink" title="위의 내용과 같은 로직 - for loop를 이용한 코드"></a>위의 내용과 같은 로직 - for loop를 이용한 코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; src.size(); start++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + <span class="number">1</span>; end &lt;= src.size(); end++) &#123;</span><br><span class="line">        System.out.println(src.subList(start, end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="위의-로직과-같은-로직-Stream-중첩"><a href="#위의-로직과-같은-로직-Stream-중첩" class="headerlink" title="위의 로직과 같은 로직 - Stream 중첩"></a>위의 로직과 같은 로직 - Stream 중첩</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; <span class="title function_">of</span><span class="params">(List&lt;E&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> IntStream.range(<span class="number">0</span>, list.size())</span><br><span class="line">        .mapToObj(start -&gt; </span><br><span class="line">                  IntStream.rangeClosed(start + <span class="number">1</span>, list.size())</span><br><span class="line">                           .mapToObj(end -&gt; list.subList(start, end)))</span><br><span class="line">        .flatMap(x -&gt; x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>Stream이나 Iterable을 리턴하는 API에는 Stream -&gt; Iterable, Iterable -&gt; Stream으로 변환하기 위한 어댑터 메서드가 필요하다.</li><li>어댑터는 클라이언트 코드를 어수선하게 만들고 더 느리다 (책에서는 2.3배정도 느리다함)</li><li>원소 시퀀스를 반환하는 메서드를 작성할 때는 Stream, Iterator를 모두 지원할 수 있게 작성하자<br> (되도록 Collection으로 하는게 좋다.)</li><li>원소의 갯수가 많다면, 멱집합의 예처럼 전용 컬렉션을 리턴하는 방법도 고민하자</li><li>만약 나중에 Stream 인터페이스가 Iterable을 지원하도록 수정된다면, 그때는 안심하고 Stream을 반환하면 된다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 47. 반환 타입으로는 스트림보다 컬렉션이 낫다</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 45. 스트림은 주의해서 사용하라</title>
      <link href="/2019/02/16/effective-java-item45/"/>
      <url>/2019/02/16/effective-java-item45/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>스트림 API는 다량의 데이터 처리 작업(순차적이든 병렬적이든)을 돕고자 자바8에 추가되었다.<br>이 API가 제공하는 추상 개념 중 핵심은 두 가지다. </p><ul><li>스트림(Stream)은 데이터 원소의 유한 혹은 무한 시퀀스(sequence)를 의미</li><li>스트림 파이프라인(Stream Pipeline)은 이 원소들로 수행하는 연산단계를 표현하는 개념</li></ul><p>스트림의 원소들은 어디서부터든 올 수 있다. 대표적으로</p><ul><li>컬렉션 (Collection)</li><li>배열 (Array)</li><li>파일 (File)</li><li>정규표현식 (Regex Pattern Matcher)</li><li>난수 생성기 (Random Generator)</li><li>다른 스트림 (Other Stream)</li></ul><p>스트림 안의 데이터 원소들은 객체 참조(reference)나 기본 타입(int, long, double)을 지원한다.</p><ul><li><strong>Stream</strong> : 객체 참조타입에 대한 Stream</li><li><strong>IntStream</strong> : int 타입에 대한 Stream</li><li><strong>LongStream</strong> : long 타입에 대한 Stream</li><li><strong>DoubleStream</strong> : double 타입에 대한 Stream</li></ul><p>기본타입의 경우 위의 IntStream, LongStream, DoubleStream과 같은 Stream을 사용하는 것이 성능상 좋다.</p><h1 id="스트림-파이프라인-Stream-Pipeline"><a href="#스트림-파이프라인-Stream-Pipeline" class="headerlink" title="스트림 파이프라인 (Stream Pipeline)"></a>스트림 파이프라인 (Stream Pipeline)</h1><p>스트림 파이프 라인은 소스 스트림에서 시작해 종단 연산(terminal operation)으로 끝나며,<br>그 사이에 하나 이상의 중간 연산(intermediate operation)이 있을 수 있다.</p><h2 id="종단-연산-terminal-operation"><a href="#종단-연산-terminal-operation" class="headerlink" title="종단 연산 (terminal operation)"></a>종단 연산 (terminal operation)</h2><ul><li><p><strong>forEach(Consumer&lt;? super T&gt; consumer)</strong> : Stream의 요소를 순회</p></li><li><p><strong>count()</strong> : 스트림 내의 요소 수 반환</p></li><li><p><strong>max(Comparator&lt;? super T&gt; comparator)</strong> : 스트림 내의 최대 값 반환 </p></li><li><p><strong>min(Comparator&lt;? super T&gt; comparator)</strong> : 스트림 내의 최소 값 반환</p></li><li><p><strong>allMatch(Predicate&lt;? super T&gt; predicate)</strong> : 스트림 내에 모든 요소가 predicate 함수에 만족할 경우 true</p></li><li><p><strong>anyMatch(Predicate&lt;? super T&gt; predicate)</strong> : 스트림 내에 하나의 요소라도 predicate 함수에 만족할 경우 true</p></li><li><p><strong>noneMatch(Predicate&lt;? super T&gt; predicate)</strong> : 스트림 내에 모든 요소가 predicate 함수에 만족하지않는 경우 true</p></li><li><p><strong>sum()</strong> : 스트림 내의 요소의 합 (IntStream, LongStream, DoubleStream)</p></li><li><p><strong>average()</strong> : 스트림 내의 요소의 평균 (IntStream, LongStream, DoubleStream)</p></li></ul><h2 id="중간-연산-intermediate-operation"><a href="#중간-연산-intermediate-operation" class="headerlink" title="중간 연산 (intermediate operation)"></a>중간 연산 (intermediate operation)</h2><ul><li><p>f<strong>ilter(Predicate&lt;? super T&gt; predicate)</strong> : predicate 함수에 맞는 요소만 사용하도록 필터</p></li><li><p><strong>map(Function&lt;? Super T, ? extends R&gt; function)</strong> : 요소 각각의 function 적용</p></li><li><p><strong>flatMap(Function&lt;? Super T, ? extends R&gt; function)</strong> : 스트림의 스트림을 하나의 스트림으로 변환</p></li><li><p><strong>distinct()</strong> : 중복 요소 제거</p></li><li><p><strong>sort()</strong> : 기본 정렬</p></li><li><p><strong>sort(Comparator&lt;? super T&gt; comparator)</strong> : comparator 함수를 이용하여 정렬</p></li><li><p><strong>skip(long n)</strong> : n개 만큼의 스트림 요소 건너뜀</p></li><li><p><strong>limit(long maxSize)</strong> : maxSize 갯수만큼만 출력</p></li></ul><h1 id="스트림의-지연-평가-Lazy-evaluation"><a href="#스트림의-지연-평가-Lazy-evaluation" class="headerlink" title="스트림의 지연 평가(Lazy evaluation)"></a>스트림의 지연 평가(Lazy evaluation)</h1><p>스트림에 대한 평가는 종단 연산이 호출될 때 이뤄지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다.<br>이러한 지연 평가가 무한 스트림을 다룰 수 있게 해주는 열쇠다.  </p><p>쉽게 말해 <strong>종단 연산(terminal operation)이 없는 스트림 파이프라인은 아무 일도 일어나지 않는다.</strong></p><h1 id="Stream-예제-아나그램-anagram"><a href="#Stream-예제-아나그램-anagram" class="headerlink" title="Stream 예제 - 아나그램(anagram)"></a>Stream 예제 - 아나그램(anagram)</h1><h2 id="일반-loop를-이용한-코드"><a href="#일반-loop를-이용한-코드" class="headerlink" title="일반 loop를 이용한 코드"></a>일반 loop를 이용한 코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">dectionary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">minGroupSize</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; groups = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(dectionary)) &#123;</span><br><span class="line">        <span class="keyword">while</span>(s.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> s.next();</span><br><span class="line">            groups.computeIfAbsent(alphabetize(word), </span><br><span class="line">                                   (unused) -&gt; <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;()).add(word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Set&lt;String&gt; group : groups.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(group.size() &gt;= minGroupSize) &#123;</span><br><span class="line">            System.out.println(group.size() + <span class="string">&quot;: &quot;</span> + group);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">alphabetize</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] a = s.toCharArray();</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>자바 8에서 추가된 computeIfAbsent 메서드를 사용했다</li><li>computeIfAbsent : 맵 안에 키가 있는지 찾은 다음, 있으면 단순히 그 키에 매핑된 값을 반환한다.</li></ul><h2 id="Stream을-과도하게-쓴-코드"><a href="#Stream을-과도하게-쓴-코드" class="headerlink" title="Stream을 과도하게 쓴 코드"></a>Stream을 과도하게 쓴 코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">dectionary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">minGroupSize</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(Stream&lt;String&gt; words = Files.lines(dectionary.toPath())) &#123;</span><br><span class="line">        words.collect(</span><br><span class="line">            groupingBy(word -&gt; word.chars().sorted()</span><br><span class="line">                       .collect(StringBuilder::<span class="keyword">new</span>,</span><br><span class="line">                                (sb, c) -&gt; sb.append((<span class="type">char</span>) c),</span><br><span class="line">                                StringBuilder::append).toString()))</span><br><span class="line">            .values().stream()</span><br><span class="line">            .filter(group -&gt; group.size() &gt;= minGroupSize)</span><br><span class="line">            .map(group -&gt; group.size() + <span class="string">&quot;: &quot;</span> + group)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>스트림을 과용하면 프로그램이 읽거나 유지보수 하기 어려워진다.</li></ul><h2 id="Stream을-적절히-활용한-코드"><a href="#Stream을-적절히-활용한-코드" class="headerlink" title="Stream을 적절히 활용한 코드"></a>Stream을 적절히 활용한 코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">dectionary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">minGroupSize</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(Stream&lt;String&gt; words = Files.lines(dectionary.toPath())) &#123;</span><br><span class="line">        words.collect(groupingBy(word -&gt; alphabetize(word)))</span><br><span class="line">            .values().stream()</span><br><span class="line">            .filter(group -&gt; group.size() &gt;= minGroupSize)</span><br><span class="line">            .forEach(group -&gt; System.out.println(group.size() + <span class="string">&quot;: &quot;</span> + group));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>스트림을 적절하게 사용하면 명료해진다.</li><li>람다에서는 타입 추론 기능을 사용하기 때문에 주로 타입 이름을 생략한다.<br>따라서 매개변수 이름을 잘 지어야 스트림 파이프라인의 가독성이 유지된다.</li><li>연산에 적절한 이름을 지어 주고 도우미 메서드를 적정히 활용하는 것은 일반 반복코드보다 스트림 파이프라인에서 훨씬 크다</li></ul><h1 id="기존-코드는-필요한-경우에만-스트림으로-리팩터링-하자"><a href="#기존-코드는-필요한-경우에만-스트림으로-리팩터링-하자" class="headerlink" title="기존 코드는 필요한 경우에만 스트림으로 리팩터링 하자"></a>기존 코드는 필요한 경우에만 스트림으로 리팩터링 하자</h1><p>스트림을 처음 쓰기 시작하면 모든 반복문을 스트림으로 바꾸고 싶은 유혹이 생긴다.<br>스트림으로 바꾸는 게 가능할 지라도, 가독성과 유지보수 측면에서 볼 때 손해를 볼 수 있기 때문에 무작정 바꾸지는 말자<br>스트림과 반복문을 적절히 활용하는 것이 최선이다.</p><h1 id="코드블럭-vs-람다-lambda"><a href="#코드블럭-vs-람다-lambda" class="headerlink" title="코드블럭 vs 람다(lambda)"></a>코드블럭 vs 람다(lambda)</h1><ul><li>코드블럭에서는 범위 안의 지역변수를 읽고 수정할 수 있다.</li><li>람다에서는 final이거나 사실상 final인 변수만 읽을 수 있다. (캡처)<br>지역 변수를 수정하는 것은 불가능하다.</li><li>코드 블럭에서는 return을 이용해 메서드를 빠져나갈 수 있다.</li><li>코드 블럭에서는 break, continue문을 통해 블럭 바깥의 반복문을 종료 할 수 있다.</li><li>메서드 선언에 명시된 예외(Exception)을 던질 수 있다.</li><li>하지만 람다로는 모든 것이 불가능하다.</li></ul><h1 id="스트림이-적합한-경우"><a href="#스트림이-적합한-경우" class="headerlink" title="스트림이 적합한 경우"></a>스트림이 적합한 경우</h1><ul><li>원소들의 시퀀스를 일관되게 변환한다.</li><li>원소들의 시퀀스를 필터링한다.</li><li>원소들의 시퀀스를 하나의 연산을 사용해 결합한다. (더하기, 연결하기, 최소값 등..)</li><li>원소들의 시퀀스를 컬렉션에 모은다</li><li>원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.</li></ul><h1 id="스트림이-적합하지-않은-경우"><a href="#스트림이-적합하지-않은-경우" class="headerlink" title="스트림이 적합하지 않은 경우"></a>스트림이 적합하지 않은 경우</h1><ul><li>데이터가 파이프라인의 여러 단계(stage)를 통과할 때 이 데이터의 각 단계에서의 값들에 동시에 접근하기 어려운 경우</li><li>스트림 파이프라인은 한 값을 다른 값에 매핑하고 나면 원래의 값을 잃는 구조이기 때문</li></ul><h2 id="예제-메르센-소수-출력하기"><a href="#예제-메르센-소수-출력하기" class="headerlink" title="예제 - 메르센 소수 출력하기"></a>예제 - 메르센 소수 출력하기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Stream&lt;BigInteger&gt; <span class="title function_">primes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.iterator(TWO, BigInteger::nextProbablePrime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위의 코드는 무한 스트림을 반환하는 메서드이다.</li><li>아직 종단 연산이 없기 때문에 실행되지는 않는 스트림이다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    primes().map(p -&gt; TWO.pow(p.intValueExact().subtract(ONE)))</span><br><span class="line">            .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">            .limit(<span class="number">20</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위의 코드는 메르센 소수를 20개를 출력하는 프로그램이다.</li></ul><h1 id="예제-데카르트-곱"><a href="#예제-데카르트-곱" class="headerlink" title="예제 - 데카르트 곱"></a>예제 - 데카르트 곱</h1><h2 id="데카르트-곱을-반복을-이용하여-구현"><a href="#데카르트-곱을-반복을-이용하여-구현" class="headerlink" title="데카르트 곱을 반복을 이용하여 구현"></a>데카르트 곱을 반복을 이용하여 구현</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Card&gt; <span class="title function_">newDeck</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Card&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Suit suit : Suit.values()) </span><br><span class="line">        <span class="keyword">for</span>(Rank rank : Rank.values())</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">Card</span>(suit, rank));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>카드는 숫자(rank)와 무늬(suit)를 묶은 불변 값 클래스이거 숫자와 무늬는 열거타입이다.</li><li>for-each를 통해 스트림을 모르는 개발자라도 쉽게 알아 볼 수 있는 코드이다</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Card&gt; <span class="title function_">newDeck</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(Suit.values())</span><br><span class="line">    .flatMap(suit -&gt; Stream.of(Rank.values())</span><br><span class="line">                      .map(rank -&gt; <span class="keyword">new</span> <span class="title class_">Card</span>(suit, rank)))</span><br><span class="line">    .collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Stream을 중첩하여 만든 코드이다.</li><li>개발자에 따라 어떤 코드가 가독성, 유지보수성이 좋은 코드인지 갈리겠지만,<br>내 기준에는 첫번째 코드가 더 가독성과 유지보수성이 좋아보인다.</li></ul><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>스트림과 함수형 프로그래밍에 익숙한 프로그래머라면 스트림방식이 좀 더 명확하다</li><li>스트림을 사용할 때가 있고, 반복을 사용할 때가 있다.</li><li>스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 택하는 것이 좋다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 45. 스트림은 주의해서 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라</title>
      <link href="/2019/02/04/effective-java-item41/"/>
      <url>/2019/02/04/effective-java-item41/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시 해주는 인터페이스를 마커 인터페이스라고 한다.<br>Serializeable 인터페이스가 가장 좋은 예이다.</p><p><img src="./serializable.png" alt="serializable"></p><p>아무런 메서드도 없다.<br>단지 타입 정보만 알려주는 인터페이스이다.</p><h1 id="마커-인터페이스의-장점"><a href="#마커-인터페이스의-장점" class="headerlink" title="마커 인터페이스의 장점"></a>마커 인터페이스의 장점</h1><ul><li>마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 사용가능하다.<br>(마커 애너테이션은 그렇지 않다.)</li><li>마커 인터페이스는 컴파일타임에 오류를 발견할 수 있다.<br>(마커 애너테이션은 런타임에 발견된다.)</li><li>ObjectOutputStream.writeObject 메서드는 파라미터에 Serializeable 인터페이스를 구현한 파라미터가 와야한다.  <ul><li>Serializeable를 구현한 파라미터가 와도 컴파일 에러는 나지 않는다. </li><li>하지만 런타임에 Serializeable 타입이 아니라는 에러를 발생 시킨다.</li></ul></li><li>적용 대상을 더 정밀하게 지정할 수 있다.<ul><li>적용 대상을 @Target(ElementType.TYPE)으로 선언한 애너테이션은 모든 타입(클래스, 인터페이스, 열거타입, 애너테이션)에 달 수 있다.</li><li>부착 할 수 있는 타입을 더 세밀하게 제한하지 못한다.</li><li>마커 인터페이스의 경우 그냥 마킹하고 싶은 클래스에만 그 인터페이스를 구현하면 된다.<br>그러면 마킹된 타입은 자동으로 그 인터페이스의 하위타입이 보장된다.</li></ul></li><li>마커 인터페이스는 객체의 특정 부분을 불변식으로 규정하거나,<br>그 타입의 인스턴스는 다른 클래스의 특정 메서드가 처리 할 수 있다는 사실을 명시하는 용도로 사용 할 수 있다.<br>(Serializeable 인터페이스가 ObjectOutputStream이 처리할 수 있는 인스턴스이듯이)</li></ul><h1 id="마커-애너테이션의-장점"><a href="#마커-애너테이션의-장점" class="headerlink" title="마커 애너테이션의 장점"></a>마커 애너테이션의 장점</h1><ul><li>거대한 애너테이션 시스템의 지원을 받는다.<ul><li>애너테이션 기반의 프레임워크에서는 마커 애너테이션을 쓰는 쪽이 더 나을 수 있다. (일관적이어서)</li></ul></li><li>클래스, 인터페이스 외의 프로그램 요소 (모듈, 패키지, 필드, 지역변수)에 마킹해햐 할 때는  마커 인터페이스를 쓸 수 없으니<br>마커 애너테이션을 사용할 수밖에 없다.</li></ul><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>마커 인터페이스와 마커 애너테이션은 각자의 쓰임이 있다.</li><li>새로 추가하는 메서드 없이 단지 타입 정의가 목적이라면 마커 인터페이스를 선택하자</li><li>마커 애너테이션을 사용할 때 @Target(ElementType.TYPE)인 마커 애너테이션을 작성하고 있다면,<br>마커 애너테이션을 정말 사용해야 하는지? 마커 인터페이스를 사용할 수 있는지 생각해보고<br>웬만하면 마커 인터페이스를 사용하도록 하자</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 40. @Override 애너테이션을 일관되게 사용하라</title>
      <link href="/2019/02/04/effective-java-item40/"/>
      <url>/2019/02/04/effective-java-item40/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>자바가 기본으로 제공하는 애너테이션 중 보통의 프로그래머에게 가장 중요한 것은 @Override일 것이다.<br>@Override는 메서드 선언에만 달 수 있으며, 이 애너테이션의 의미는 상위 클래스의 메서드를 재정의 했음을 의미한다.</p><h1 id="Override를-선언하지-않은-메서드"><a href="#Override를-선언하지-않은-메서드" class="headerlink" title="@Override를 선언하지 않은 메서드"></a>@Override를 선언하지 않은 메서드</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bigram</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bigram</span><span class="params">(<span class="type">char</span> first, <span class="type">char</span> second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Bigram bigram)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bigram.first == <span class="built_in">this</span>.first &amp;&amp;</span><br><span class="line">                bigram.second == <span class="built_in">this</span>.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * first + second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;Bigram&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; ch &lt;= <span class="string">&#x27;z&#x27;</span>; ch++) &#123;</span><br><span class="line">                s.add(<span class="keyword">new</span> <span class="title class_">Bigram</span>(ch, ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(s.size()); <span class="comment">//260</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bigram이라는 문자 2개를 갖는 클래스에 a~z까지 26개의 문자를 넣고, 10개씩 만든다음에 HashSet에 삽입했다.<br>생각해보면 26개가 나올 것 같지만, 실제로는 260개가 발생한다.</p><p>왜 그럴까?</p><p>HashSet은 내부적으로 equals 메서드를 기반으로 객체의 논리적 동치적(equals) 검사를 실시한다.<br>하지만 자세히 보면 equals메서드의 파라미터 타입이 Bigram이다. equals 메서드를 재정의 한게 아니라 Overloading 한 꼴이다.  </p><p>equals를 재정의 하려면 파라미터 타입이 Object이어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Bigram bigram)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bigram.first == <span class="built_in">this</span>.first &amp;&amp;</span><br><span class="line">        bigram.second == <span class="built_in">this</span>.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 변경하고 컴파일 해보면, </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(15, 5) java: method does not override or implement a method from a supertype</span><br></pre></td></tr></table></figure><p>이러한 컴파일 에러가 발생한다.</p><p>잘못된 부분을 명확히 알려주므로 곧장 수정할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object bigram)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Bigram)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Bigram</span> <span class="variable">b</span> <span class="operator">=</span> (Bigram) bigram;</span><br><span class="line">    <span class="keyword">return</span> b.first == <span class="built_in">this</span>.first &amp;&amp;</span><br><span class="line">        b.second == <span class="built_in">this</span>.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>상위 클래스의 메서드를 재정의 하는 모든 메서드에 @Override 애너테이션을 달자</li><li>굳이 @Override를 달지 않아도 동작은 한다. 하지만 일괄적으로 붙여주는게 좋다.</li><li>인터페이스를 상속한 구체 클래스인데 아직 구현하지 않은 추상 메서드가 남아있다면,<br>컴파일러가 바로 사실을 알려준다.</li><li>Java 8 부터 Default 메서드의 사용이 가능해 지면서, 인터페이스의 메서드를 재정의 할 때도 사용할 수 있다.</li><li>구현하려는 인터페이스에 Default 메서드가 없음을 안다면 @Override를 생략해 코드를 조금 깔끔히 유지해도 좋다.</li><li>웬만하면 추상클래스나 인터페이스에서는 상위 클래스나 상위 인터페이스를 재정의하는 모든 메서드에 @Override를 다는것이 좋다.<br>(실수 했을 때 컴파일러가 알려준다.)</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 40. @Override 애너테이션을 일관되게 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 39. 명명 패턴보다 애너테이션을 사용하라</title>
      <link href="/2019/02/04/effective-java-item39/"/>
      <url>/2019/02/04/effective-java-item39/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>전통적으로 도구나 프레임워크가 특별히 다뤄야 할 프로그램 요소에는 딱 구분되는 명명 패턴을 적용해 왔다.<br>예컨데 테스트 프레임워크인 JUnit3에서는 테스트 메서드 이름을 <strong>test</strong>로 시작하게 지어야 했다.  </p><p>단점은 아래와 같다.</p><ol><li><p>오타가 나면 안된다.<br>실수로 이름을 tset~라고 지으면 그 테스트 메서드는 무시하고 지나가기 때문에 테스트 메서드가 제대로 실행됐는지 어쨌는지 모른다.</p></li><li><p>올바른 프로그램 요소에서만 사용되리라 보증 할 방법이 없다.<br>예컨데 TestSafetyMechanisms으로 JUnit에 던져줬다고 해보자. 개발자는 이 클래스에 정의된 테스트 메서드들을 수행해 주길 기대하겠지만, JUnit은 클래스 이름에는 관심이 없다. 이번에도 경고조차 출력하지 않고 개발자가 의도한 대로 테스트는 진행되지 않는다.</p></li><li><p>프로그램 요소를 매개변수로 전달할 마땅한 방법이 없다는 것이다.<br>특정 예외를 던져야만 성공하는 테스트가 있을 때, 기대하는 예외의 타입을 매개변수로 전달해야 하는 상황이다.<br>예외의 이름을 테스트 메서드 이름에 덧붙이는 방법도 있지만, 보기에도 나쁘고 깨지기도 쉽다.</p></li></ol><p>이런 문제를 해결해 주는 개념으로 JUnit4 부터는 애너테이션을 도입하였다.  </p><h1 id="마커-애너테이션-타입선언"><a href="#마커-애너테이션-타입선언" class="headerlink" title="마커 애너테이션 타입선언"></a>마커 애너테이션 타입선언</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 테스트 메서드임을 선언하는 애너테이션이다.</span></span><br><span class="line"><span class="comment">* 매개변수 없는 정적메서드 전용이다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//성공</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//실행되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//실패</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;실패&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//실행되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//잘못 사용한 예</span></span><br><span class="line">        <span class="comment">//static method가 아니다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m6</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//실행되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m7</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//실패</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;실패&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m8</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//실행되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Test와 같은 애너테이션을 <strong>아무 매개변수 없이 단순히 대상에 마킹(Marking)한다</strong>는 뜻에서 마커 애너테이션 (Marker Annotation)이라고 한다.<br>이 애너테이션을 사용하면 @Test 애너테이션에 오타를 내면 컴파일 오류를 내준다.</p><p>아래 프로그램을 실행하면총 8개의 메서드 중 4개의 테스트 메서드가 실행되고</p><ul><li>성공 1개</li><li>실패 2개</li><li>1개는 잘못 사용한 예이다.</li></ul><p>애너테이션은 Sample클래스의 의미에 직접적으로 영향을 주지는 않는다.<br>그저 애너테이션에 관심있는 프로그램에게 추가 정보를 제공할 뿐이다.<br>다시 말하면, 프로그램 코드에의 의미는 그대로 둔 채 애너테이션에 관심있는 도구에서 특별히 처리하도록 하는 것이다.</p><h2 id="메타-애너테이션-Meta-Annotation"><a href="#메타-애너테이션-Meta-Annotation" class="headerlink" title="메타 애너테이션 (Meta Annotation)"></a>메타 애너테이션 (Meta Annotation)</h2><p>애너테이션 타입에 다는 애너테이션을 메타 애너테이션 (Meta Annotation)이라 한다.<br>메타 애너테이션의 종류로는 </p><ul><li><p><strong>@Documented</strong>: 문서에도 애너테이션 정보가 표현되게 함</p></li><li><p><strong>@Inherited</strong>: 자식클래스가 애너테이션을 상속받을 수 있게 함</p></li><li><p><strong>@Repeatable</strong>: 애너테이션을 반복적으로 사용할 수 있게 함</p></li><li><p><strong>@Retention(RetentionPolicy)</strong>: 애너테이션의 범위를 지정 (어느 시점까지 유효한지?)</p><ul><li><strong>RetentionPolicy.RUNTIME</strong>: 컴파일 이후에도 JVM에 의해 참조가 가능 - 보통 이거로 설정</li><li><strong>RetentionPolicy.CLASS</strong>: 컴파일러가 클래스를 참조할 때 까지 유효</li><li><strong>RetentionPolicy.SOURCE</strong>: 애너테이션 정보가 컴파일 이후 사라짐</li></ul></li><li><p><strong>@Target(ElementType[])</strong>: 애너테이션이 적용될 위치를 선언</p><ul><li><strong>ElementType.PACKAGE</strong>:  패키지 선언시</li><li><strong>ElementType.TYPE</strong>: 타입 선언시</li><li><strong>ElementType.CONSTRUCTOR</strong>: 생성자 선언시</li><li><strong>ElementType.FIELD</strong>: 멤버 변수 선언시</li><li><strong>ElementType.METHOD</strong>:  메소드 선언시</li><li><strong>ElementType.ANNOTATION_TYPE</strong>: 어노테이션 타입 선언시</li><li><strong>ElementType.LOCAL_VARIABLE</strong>: 지역 변수 선언시</li><li><strong>ElementType.PARAMETER</strong>: 매개 변수 선언시</li><li><strong>ElementType.TYPE_PARAMETER</strong>: 매개 변수 타입 선언시</li><li><strong>ElementType.TYPE_USE</strong>: 타입 사용시</li></ul></li></ul><h2 id="마커-애너테이션-processor"><a href="#마커-애너테이션-processor" class="headerlink" title="마커 애너테이션 processor"></a>마커 애너테이션 processor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunTests</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tests</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">passed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Class&lt;?&gt; testClass = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Method m : testClass.getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.isAnnotationPresent(Test.class)) &#123;</span><br><span class="line">                test++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    m.invoke(<span class="literal">null</span>);</span><br><span class="line">                    passed++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException wrappedExc) &#123;</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">exc</span> <span class="operator">=</span> wrappedExc.getCause();</span><br><span class="line">                    System.out.println(m + <span class="string">&quot; 실패: &quot;</span> + exc);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;잘못 사용한 @Test: &quot;</span> + m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.printf(<span class="string">&quot;성공: %d, 실패: %d%n&quot;</span>, passed, tests-passed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>m.isAnnotationPresent(Test.class)</strong>: @Test 애너테이션이 적용된 메서드인지 판별</li><li><strong>m.invoke()</strong>: @Test 메서드 실행</li><li><strong>InvocationTargetException</strong>: 테스트 메서드가 예외를 던지면 리플렉션 메커니즘이 InvocationTargetException으로 감싸서 다시 던진다.<br>그래서 이 프로그램은 InvocationTargetException에 대해 catch절을 구성해 원래 예외에 담긴 정보를 출력한다.</li><li><strong>두번째 catch</strong>: 두번째 catch블럭은 잘못 사용해서 발생한 예외를 처리</li></ul><h1 id="매개변수-하나짜리-애너테이션-타입선언"><a href="#매개변수-하나짜리-애너테이션-타입선언" class="headerlink" title="매개변수 하나짜리 애너테이션 타입선언"></a>매개변수 하나짜리 애너테이션 타입선언</h1><p>특정 예외를 던져야만 성공하는 테스트도 있을 것이다.<br>특정 예외가 발생했을 때 성공하는 테스트를 지원하도록 해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 명시한 예외를 던져야만, 성공하는 테스트케이스 애너테이션</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTest&#123;</span><br><span class="line">    <span class="comment">//한정적 와일드카드를 통해 Throwable을 상속한 모든 타입을 지정</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; values(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="예제-프로그램"><a href="#예제-프로그램" class="headerlink" title="예제 프로그램"></a>예제 프로그램</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample2</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionTest(ArithmeticException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        i = i / i; <span class="comment">//divide by zero. ArithmeticException 예외를 발생시킴 -&gt; 성공</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ExceptionTest(ArithmeticException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a[<span class="number">1</span>]; <span class="comment">//IndexOutOfBoundsException 발생 -&gt; ArithmeticException가 아니므로 실패</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ExceptionTest(ArithmeticException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;&#125; <span class="comment">// 아무 Exception도 발생하지 않음 -&gt; 실패</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="매개변수-하나짜리-애너테이션-processor"><a href="#매개변수-하나짜리-애너테이션-processor" class="headerlink" title="매개변수 하나짜리 애너테이션 processor"></a>매개변수 하나짜리 애너테이션 processor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(m.isAnnotaionPresent(ExceptionTest.class)) &#123;</span><br><span class="line">    test++;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m.invoke(<span class="literal">null</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;테스트 %s 실패: 예외를 던지지 않음%n&quot;</span>, m);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException wrappedExc) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">exc</span> <span class="operator">=</span> wrappedExc.getCause();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; excType = m.getAnnotation(ExceptionTest.class).value();</span><br><span class="line">        <span class="keyword">if</span>(excType.isInstance(exc)) &#123;</span><br><span class="line">            passed++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;테스트 %s 실패: 기대한 예외 %s, 발생한 예외 %s%n&quot;</span>, m, excType.getName(), exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;잘못 사용한 @ExceptionTest: &quot;</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 @Test와의 차이는 애너테이션의 매개변수를 추출하여 테스트 메서드가 올바른 메서드를 던졌는지 확인하는데 사용한다.<br>m.getAnnotation(ExceptionTest.class).value()를 실행할 때 ArithmeticException.class가 리턴된다.</p><h1 id="배열-매개변수를-받는-애너테이션-타입선언"><a href="#배열-매개변수를-받는-애너테이션-타입선언" class="headerlink" title="배열 매개변수를 받는 애너테이션 타입선언"></a>배열 매개변수를 받는 애너테이션 타입선언</h1><p>Exception이 발생하는 종류를 묶어서 처리하고 싶을 때도 있다.<br>@ExceptionTest에서 배열형태로 Exception클래스를 받을 수 있도록 배열로 선언하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 명시한 예외를 던져야만, 성공하는 테스트케이스 애너테이션</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTest&#123;</span><br><span class="line">    <span class="comment">//한정적 와일드카드를 통해 Throwable을 상속한 모든 타입을 지정</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] values(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="예제-프로그램-1"><a href="#예제-프로그램-1" class="headerlink" title="예제 프로그램"></a>예제 프로그램</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample3</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionTest(&#123;IndexOutOfBoundsException.class,</span></span><br><span class="line"><span class="meta">                    NullPointerException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//자바 명세에 따르면, 다음 메서드는 IndexOutOfBoundsException이나,</span></span><br><span class="line">        <span class="comment">//NullPointerException을 던질 수 있다.</span></span><br><span class="line">        <span class="comment">//예외 발생 시 성공</span></span><br><span class="line">        list.addAll(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="배열-매개변수를-받는-애너테이션-processor"><a href="#배열-매개변수를-받는-애너테이션-processor" class="headerlink" title="배열 매개변수를 받는 애너테이션 processor"></a>배열 매개변수를 받는 애너테이션 processor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(m.isAnnotaionPresent(ExceptionTest.class)) &#123;</span><br><span class="line">    test++;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m.invoke(<span class="literal">null</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;테스트 %s 실패: 예외를 던지지 않음%n&quot;</span>, m);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException wrappedExc) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">exc</span> <span class="operator">=</span> wrappedExc.getCause();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] excTypes = m.getAnnotation(ExceptionTest.class).value();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">oldPassed</span> <span class="operator">=</span> passed;</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; excType : excTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span>(excType.isInstance(exc)) &#123;</span><br><span class="line">            passed++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(passed == oldPassed) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;테스트 %s 실패: %s %n&quot;</span>, m, exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;잘못 사용한 @ExceptionTest: &quot;</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드 중 변경되는 부분은  Class&lt;? extends Throwable&gt;[] excTypes을 배열형태로 받아,<br>이미 지정한 Exception 클래스 중에 맞는 클래스가 있는지 확인하는 코드가 변경되었다.</p><h1 id="반복-가능-애너테이션-Repeatable"><a href="#반복-가능-애너테이션-Repeatable" class="headerlink" title="반복 가능 애너테이션 @Repeatable"></a>반복 가능 애너테이션 @Repeatable</h1><p>자바8에서는 여러개의 값을 받는 애너테이션을 다른 방식으로도 만들 수 있다.<br>배열 방식의 매개변수를 사용하는 대신 애너테이션에 @Repeatable 메타애너테이션을 다는 방식이다.<br>@Repeatable 애너테이션은 하나의 메서드에 여러개의 애너테이션을 지정할 수 있다.</p><ol><li>@Repeatable을 단 애너테이션을 반환하는 <strong>컨테이너 애너테이션</strong>을 하나 더 정의한다.</li><li>@Repeatable에 이 컨터이너 애너테이션의 class 객체를 매개변수로 전달해야 한다.</li><li>컨테이너 애너테이션은 내부 애너테이션 타입의 배열을 반환하는 value 메서드를 정의한다.</li><li>컨터이너 애너테이션에는 @Retention과 @Target을 적절히 명시한다.<br>(그렇지 않으면 컴파일되지 않는다.)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Repeatable(ExceptionTestContainer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTest &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTestContainer &#123;</span><br><span class="line">    ExceptionTest[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="예제-프로그램-반복-가능-애너테이션을-적용한-예"><a href="#예제-프로그램-반복-가능-애너테이션을-적용한-예" class="headerlink" title="예제 프로그램 - 반복 가능 애너테이션을 적용한 예"></a>예제 프로그램 - 반복 가능 애너테이션을 적용한 예</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionTest(IndexOutOfBoundsException.class)</span></span><br><span class="line"><span class="meta">@ExceptionTest(NullPointerException.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>반복 가능 애너테이션은 처리할 때 주의를 요한다.<br>반복 가능 애너테이션을 여러개 달면, 하나만 달았을 때와 구분하기 위해 해당 <strong>컨테이너</strong> 애너테이션 타입이 적용 된다.</p><ul><li>getAnnotationByType 메서드는 이 둘을 구분하지 않아 @ExceptionTest와 @ExceptionTestContainer를 모두 가져온다.</li><li>isAnnotationPresent는 둘을 구분한다.<ul><li>만약 @ExceptionTest를 여러번 단 다음, isAnnotationPresent로 ExceptionTest를 검사하면 false가 나온다.<br>(@ExceptionTestContainer로 인식하기 때문)</li><li>반대로 @ExceptionTest를 한번 만 단 다음, isAnnotationPresent로 ExceptionTestContainer를 검사하면 false가 나온다.<br>(@ExceptionTest가 적용되었기 때문)</li></ul></li></ul><h2 id="반복-가능-애너테이션-processor"><a href="#반복-가능-애너테이션-processor" class="headerlink" title="반복 가능 애너테이션 processor"></a>반복 가능 애너테이션 processor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        m.invoke(<span class="literal">null</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;테스트 %s 실패: 예외를 던지지 않음%n&quot;</span>, m);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException wrappedExc) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">exc</span> <span class="operator">=</span> wrappedExc.getCause();</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldPassed</span> <span class="operator">=</span> passed;</span><br><span class="line">    </span><br><span class="line">        ExceptionTest[] excTests = m.getAnnotationByType(ExceptionTest.class);</span><br><span class="line">        <span class="keyword">for</span>(ExceptionTest excType : excTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span>(excType.isInstance(exc)) &#123;</span><br><span class="line">            passed++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(passed == oldPassed) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;테스트 %s 실패: %s %n&quot;</span>, m, exc);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>반복 가능 애너테이션을 사용한 경우 getAnnotationByType를 사용해 애너테이션 정보를 가져오는 것이 좋다.</p><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li><p>애너테이션이 명명패턴을 이용할 때 보다 확실히 낫다.</p></li><li><p>애너테이션으로 할 수 있는 일을 명명 패턴으로 처리할 이유는 없다.</p></li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 39. 명명 패턴보다 애너테이션을 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라</title>
      <link href="/2019/02/04/effective-java-item38/"/>
      <url>/2019/02/04/effective-java-item38/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>타입 안전 열거 패턴은 확장이 가능하나, 열거 타입은 확장을 할 수 없다<br>다시 말해 타입 안전 열거 패턴은 값을 그대로 가져온 다음 값을 더 추가하여 다른 목적으로 쓸 수 있지만,<br>열거 타입은 그럴 수 없다.</p><p>하지만 열거타입도 확장할 수 있는 방법이 한 가지 존재한다.<br>기본적인 아이디어는 열거 타입이 인터페이스를 구현할 수 있다는 사실을 이용하는 것이다.</p><h1 id="인터페이스를-이용한-확장-가능-열거-타입"><a href="#인터페이스를-이용한-확장-가능-열거-타입" class="headerlink" title="인터페이스를 이용한 확장 가능 열거 타입"></a>인터페이스를 이용한 확장 가능 열거 타입</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">BasicOperation</span> <span class="keyword">implements</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line"></span><br><span class="line">    PLUS(<span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(<span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(<span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x * y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(<span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x / y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line"></span><br><span class="line">    BasicOperation(String symbol) &#123;</span><br><span class="line">        <span class="built_in">this</span>.symbol = symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>열거 타입인 BasicOperation은 확장할 수 없지만 인터페이스인 Operation은 확장할 수 있고, 이 인터페이스를 연산의 타입으로 사용하면 된다.</p><h2 id="다른-열거-타입-추가"><a href="#다른-열거-타입-추가" class="headerlink" title="다른 열거 타입 추가"></a>다른 열거 타입 추가</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ExtendedOperation</span> <span class="keyword">implements</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line"></span><br><span class="line">    EXP(<span class="string">&quot;^&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.pow(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    REMAINDER(<span class="string">&quot;%&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x % y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line"></span><br><span class="line">    ExtendedOperation(String symbol) &#123;</span><br><span class="line">        <span class="built_in">this</span>.symbol = symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Operation 인터페이스를 구현하면 다른 열거 타입에서도 인터페이스를 구현하여 기능을 확장할 수 있다.</p><h1 id="열거-타입-확인"><a href="#열거-타입-확인" class="headerlink" title="열거 타입 확인"></a>열거 타입 확인</h1><h2 id="Enum타입을-넘겨-순회하기"><a href="#Enum타입을-넘겨-순회하기" class="headerlink" title="Enum타입을 넘겨 순회하기"></a>Enum타입을 넘겨 순회하기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        test(ExtendedOperation.class, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;T&gt; &amp; Operation&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Class&lt;T&gt; opEnumType, <span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Operation op : opEnumType.getEnumConstants()) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%f %s %f = %f%n&quot;</span>, x, op, y, op.apply(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>&lt;T extends Enum<T> &amp; Operation&gt; : 타입이 Enum타입이면서, Operation을 구현하는 클래스</li></ul><h2 id="Collection-lt-extends-Operation-gt-넘겨-순회하기"><a href="#Collection-lt-extends-Operation-gt-넘겨-순회하기" class="headerlink" title="Collection&lt;? extends Operation&gt; 넘겨 순회하기"></a>Collection&lt;? extends Operation&gt; 넘겨 순회하기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        test2(Arrays.asList(ExtendedOperation.values()), x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(Collection&lt;? extends Operation&gt; opSet, <span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Operation op : opSet) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%f %s %f = %f%n&quot;</span>, x, op, y, op.apply(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>열거 타입의 리스트를 넘겨 &lt;? extends Operation&gt;인 한정적 와일드 카드 타입으로 지정</li></ul><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>확장할 수 있는 열거 타입이 필요한 경우 인터페이스를 정의하여 구현하자</li><li>열거 타입끼리는 상속이 되지 않는다.</li><li>여러 열거 타입 간 공유하는 기능이 있으면, 클래스나 도우미 메서드로 분리하자</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 37. Ordinal 인덱싱 대신 EnumMap을 사용하라</title>
      <link href="/2019/02/04/effective-java-item37/"/>
      <url>/2019/02/04/effective-java-item37/</url>
      
        <content type="html"><![CDATA[<h1 id="ordinal-을-배열-인덱스로-사용해선-안된다"><a href="#ordinal-을-배열-인덱스로-사용해선-안된다" class="headerlink" title="ordinal()을 배열 인덱스로 사용해선 안된다."></a>ordinal()을 배열 인덱스로 사용해선 안된다.</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plant</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Lifecycle</span> &#123; ANNUAL, PERENNIAL, BIENNIAL &#125;</span><br><span class="line">    <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">final</span> Lifecycle lifeCycle;</span><br><span class="line">    </span><br><span class="line">    Plant(String name, Lifecycle lifeCycle) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.lifeCycle = lifeCycle;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Plant&gt;[] plantsByLifeCycle = (Set&lt;Plant&gt;[]) <span class="keyword">new</span> <span class="title class_">Set</span>[Plant.LifeCycle.values().length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; plantsByLifeCycle.length ; i++) &#123;</span><br><span class="line">    plantsByLifeCycle[i] = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Plant p : garden) &#123;</span><br><span class="line">    plantsByLifeCycle[p.lifeCycle.ordinal()].add(p); <span class="comment">//이런 코드는 제발 쓰지 말자</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과 출력</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; plantsByLifeCycle.length; i++) &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%s: %s%n&quot;</span>, Plant.LifeCycle.values()[i], plantsByLifeCycle[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>문제점</strong></p><ul><li><code>Set&lt;Plant&gt;[] plantsByLifeCycle = (Set&lt;Plant&gt;[]) new Set[Plant.LifeCycle.values().length]</code><br>배열은 제네릭과 호환되지 않는다. (비검사 형변환이 수행, 컴파일이 안된다.)</li><li>ordinal()은 상수 선언 순서에 따라 변한다.</li><li>잘못된 값을 사용하면 이상한 동작을 유발한다.</li></ul><h1 id="EnumMap을-사용해-매핑"><a href="#EnumMap을-사용해-매핑" class="headerlink" title="EnumMap을 사용해 매핑"></a>EnumMap을 사용해 매핑</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Plant.LifeCycle, Set&lt;Plant&gt;&gt; plantsByLifeCycle = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(Plant.LifeCycle.class);</span><br><span class="line"><span class="keyword">for</span> (Plant.LifeCycle lc : Plant.LifeCycle.values()) &#123;</span><br><span class="line">    plantsByLifeCycle.put(lc, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Plant p : garden) &#123;</span><br><span class="line">    plantsByLifeCycle.get(p.lifeCycle).add(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>더 간단명료하게 로직이 변환되었다.</li><li>맵의 키인 열거 타입이 그 자체로 출력용 문자열을 제공하니 출력결과에 별도의 formatting이 필요없다.</li><li>EnumMap의 성능이 ordinal을 쓴 배열과 같은 이유는 EnumMap 내부에서 ordinal을 사용한 배열을 사용하기 때문이다.</li><li>개발자가 직접 제어하지 않고 Map을 사용하여, 타입안정성을 얻을 뿐더러 성능상의 이점까지 그대로 가져간다.</li></ul><h1 id="Stream을-이용한-코드"><a href="#Stream을-이용한-코드" class="headerlink" title="Stream을 이용한 코드"></a>Stream을 이용한 코드</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap을 이용한 데이터와 열거타입 매핑</span></span><br><span class="line">Arrays.stream(garden)</span><br><span class="line">      .collect(groupingBy(p -&gt; p.lifeCycle))</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EnumMap을 이용해 데이터와 열거타입 매핑</span></span><br><span class="line">Arrays.stream(garden)</span><br><span class="line">      .collect(groupingBy(p -&gt; p.lifeCycle, () -&gt; <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(LifeCycle.class),</span><br><span class="line">                         toSet()));</span><br></pre></td></tr></table></figure><ul><li>두 방식의 차이 <ul><li>HashMap을 이용한 방식에는 garden에 있는 키만 만든다.</li><li>EnumMap을 이용한 방식에는 garden에 데이터가 없어도 모든 키가 다 만들어 진다.</li></ul></li></ul><h1 id="추가-예제"><a href="#추가-예제" class="headerlink" title="추가 예제"></a>추가 예제</h1><h2 id="ordinal-을-배열의-인덱스로-사용한-예"><a href="#ordinal-을-배열의-인덱스로-사용한-예" class="headerlink" title="ordinal()을 배열의 인덱스로 사용한 예"></a>ordinal()을 배열의 인덱스로 사용한 예</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Phase</span> &#123;</span><br><span class="line">    SOLID, LIQUID, GAS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Transition</span> &#123;</span><br><span class="line">        MELT, FREEZE, BOIL, CONDENSE, SUBLIME, DEPOSIT;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 행은 from의 ordinal을, 열은 to의 ordinal을 인덱스로 사용</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Transition[][] TRANSITIONS = &#123;</span><br><span class="line">            &#123; <span class="literal">null</span>, MELT, SUBLIME &#125;,</span><br><span class="line">            &#123; FREEZE, <span class="literal">null</span>, BOIL &#125;,</span><br><span class="line">            &#123; DEPOSIT, CONDENSE, <span class="literal">null</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 한 상태에서 다른 상태로의 전이를 반환한다.</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Transition <span class="title function_">from</span><span class="params">(Phase from, Phase to)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> TRANSITIONS[from.ordinal()][to.ordinal()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 이 예제는 결국 SOLID, LIQUID, GAS의 상태 변화(from~to)에 대한 배열로 맵을 만든 것이다.<br>이렇게 되면 Phase가 추가 될 때마다 배열을 수정해 줘야 하는 불상사가 발생한다.</p><h2 id="EnumMap을-이용"><a href="#EnumMap을-이용" class="headerlink" title="EnumMap을 이용"></a>EnumMap을 이용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Phase</span> &#123;</span><br><span class="line"></span><br><span class="line">    SOLID, LIQUID, GAS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Transition</span> &#123;</span><br><span class="line">        MELT(SOLID, LIQUID),</span><br><span class="line">        FREEZE(LIQUID, SOLID),</span><br><span class="line">        BOIL(LIQUID, GAS),</span><br><span class="line">        CONDENSE(GAS, SOLID),</span><br><span class="line">        SUBLIME(SOLID, GAS),</span><br><span class="line">        DEPOSIT(GAS, SOLID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phase from;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phase to;</span><br><span class="line"></span><br><span class="line">        Transition(Phase from, Phase to) &#123;</span><br><span class="line">            <span class="built_in">this</span>.from = from;</span><br><span class="line">            <span class="built_in">this</span>.to = to;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt; m = Stream.of(values())</span><br><span class="line">                .collect(groupingBy(t -&gt; t.from, () -&gt; <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(Phase.class),</span><br><span class="line">                        toMap(t -&gt; t.to, <span class="comment">//key-mapper</span></span><br><span class="line">                                t -&gt; t,  <span class="comment">//value-mapper</span></span><br><span class="line">                                (x, y) -&gt; y, <span class="comment">//merge-function</span></span><br><span class="line">                                () -&gt; <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(Phase.class))));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Transition <span class="title function_">from</span> <span class="params">(Phase from, Phase to)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m.get(from).get(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>EnumMap을 사용하여 간단하게 바꾼 모습이다.<br>Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt;을 초기화하는 부분이 복잡하다.</p><ol><li>일단 from으로 grouping 하여 EnumMap을 하나 생성</li><li>toMap으로 하위 Map을 생성</li><li>첫 번째 인자는 Map의 key를 설정하는 Function이다. - Phase to로 선언</li><li>두 번째 인자는 Map의 value를 설정하는 Function이다. - 자기 자신을 참조</li><li>세 번째 인자는 merge-function이다. - 얘는 별 의미없다.</li><li>네 번째 인자는 EnumMap으로 내부 Map을 선언한다.</li></ol><p>따라서 from 메서드에서 Phase별 from~to에 대해 Map -&gt; Map에 접근하여 Transition을 리턴 할 수 있다.</p><h2 id="새로운-Phase가-추가되는-경우"><a href="#새로운-Phase가-추가되는-경우" class="headerlink" title="새로운 Phase가 추가되는 경우"></a>새로운 Phase가 추가되는 경우</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Phase</span> &#123;</span><br><span class="line"></span><br><span class="line">    SOLID, LIQUID, GAS, PLASMA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Transition</span> &#123;</span><br><span class="line">        MELT(SOLID, LIQUID),</span><br><span class="line">        FREEZE(LIQUID, SOLID),</span><br><span class="line">        BOIL(LIQUID, GAS),</span><br><span class="line">        CONDENSE(GAS, SOLID),</span><br><span class="line">        SUBLIME(SOLID, GAS),</span><br><span class="line">        DEPOSIT(GAS, SOLID),</span><br><span class="line">        IONIZE(GAS, PLASMA),</span><br><span class="line">        DEIONIZE(PLASMA, GAS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phase from;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phase to;</span><br></pre></td></tr></table></figure><p>PLASMA라는 Phase가 추가되어도 Transition에 IONIZE, DEIONIZE를 간단히 추가하여 유연하게 대응이 가능하다.</p><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>배열의 인덱스를 얻기 위해 ordinal을 쓰는 것은 일반적으로 좋지 않으니, 대신 EnumMap을 사용하라.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 37. ordinal 인덱싱 대신 EnumMap을 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 36. 비트 필드 대신 EnumSet을 사용하라</title>
      <link href="/2019/02/04/effective-java-item36/"/>
      <url>/2019/02/04/effective-java-item36/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p> 열거한 값들이 주로 단독이 아닌 집합으로 사용 될 경우, 예전에는 각 상수에 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴을 사용해왔다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STYLE_BOLD</span> <span class="operator">=</span>          <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STYLE_ITALIC</span> <span class="operator">=</span>        <span class="number">1</span> &lt;&lt; <span class="number">1</span>; <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STYLE_UNDERLINE</span> <span class="operator">=</span>     <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STYLE_STRIKETHROUGH</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">//8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//매개 변수 styles는 0개 이상의 STYLE_ 상수를 비트별 OR 한 값이다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyStyle</span><span class="params">(<span class="type">int</span> styles)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음과 같은 식으로 비트별 OR을 사용해 여러 상수를 하나의 집합으로 모을 수 있으며,<br>이렇게 만들어진 집합을 비트 필드(bit field)라고 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.applyStyles(STYLE_BOLD | STYLE_ITALIC); <span class="comment">// 1 | 2 =&gt; 3</span></span><br></pre></td></tr></table></figure><p>하지만 비트 필드는 열거 상수의 단점을 그대로 지닌다.</p><ul><li>컴파일 되면 값이 새겨진다 (무슨 의미인지 모름)</li><li>비트 필드 값이 그대로 출력되면 단순한 정수 열거 상수보다 해석하기 어렵다.<br>(어떤 값이 OR연산되서 나온값인지 알기 어렵다.)</li><li>최대 몇 비트가 필요한지 API작성 시 미리 예측이 필요하다.</li></ul><h1 id="비트-필드-대신-EnumSet을-사용하라"><a href="#비트-필드-대신-EnumSet을-사용하라" class="headerlink" title="비트 필드 대신 EnumSet을 사용하라"></a>비트 필드 대신 EnumSet을 사용하라</h1><ul><li>java.util 패키지의 EnumSet 클래스는 열거 타입 상수의 값으로 구성된 집합을 효과적으로 표현해준다.  </li><li>Set 인터페이스를 완벽히 구현하며, 타입 안전하고 다른 Set 구현체와도 함께 사용할 수 있다.  </li><li>EnumSet의 내부는 비트 벡터로 구현되었다.</li><li>원소가 64개 이하인 경우에는 EnumSet 전체를 long 변수 하나로 표현하여 비트 필드에 비견되는 성능을 보여준다.</li><li>removeAll과 retailAll과 같은 대량 작업은 비트를 효율적으로 처리 할 수 있는 산술 연산을 사용하였다.<br>(RegularEnumSet과 JumboEnumSet 클래스를 보면 비트연산을 많이 한다.)</li></ul><h1 id="비트필드를-대체하는-EnumSet-예제"><a href="#비트필드를-대체하는-EnumSet-예제" class="headerlink" title="비트필드를 대체하는 EnumSet 예제"></a>비트필드를 대체하는 EnumSet 예제</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Style</span> &#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 어떤 Set을 넘겨도 되나 EnumSet이 가장 좋다.</span></span><br><span class="line">    <span class="comment">// 이왕이면 Set Interface로 받는게 좋은 습관이다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyStyles</span><span class="params">(Set&lt;Style&gt; styles)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));</span><br></pre></td></tr></table></figure><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>열거할 수 있는 타입을 한데 모아 집합 형태로 사용한다고 해도, 비트 필드를 사용할 이유는 없다.</li><li>EnumSet 클래스가 비트 필드 수준의 명료함과 성능을 제공한다.</li><li>EnumSet의 유일한 단점은 불변 객체를 생성할 수 없는 점이다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 36. 비트 필드 대신 EnumSet을 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 35. Ordinal 메서드 대신 인스턴스 필드를 사용하라</title>
      <link href="/2019/02/04/effective-java-item35/"/>
      <url>/2019/02/04/effective-java-item35/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>대부분의 열거 타입 상수는 자연스럽게 하나의 정숫값에 대응된다.<br>모든 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal이라는 메서드를 제공한다.</p><h1 id="ordinal을-잘못-사용한-예"><a href="#ordinal을-잘못-사용한-예" class="headerlink" title="ordinal을 잘못 사용한 예"></a>ordinal을 잘못 사용한 예</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Ensemble</span> &#123;</span><br><span class="line">    SOLO, DUET, TRIO, QUARTET, QUINTET,</span><br><span class="line">    SEXTET, SEPET, OCTET, NONET, DECTET;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfMusicians</span><span class="params">()</span> &#123; <span class="keyword">return</span> ordinal() + <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>상수 선언 순서를 바꾸는 순간 numberOfMusicians 메서드의 기능을 상실하게 된다.<br>상수 순서를 바꾸는 순간 ordinal 값이 바뀌기 때문에 상수의 의미와 실제 뮤지션 숫자와 일치하지 않는다.</p><p>가령, 똑같이 8명인 복4중주(double quartet)은 OCTET이 있기 때문에 추가할 수 도 없다.</p><h1 id="인스턴스-필드를-사용하라"><a href="#인스턴스-필드를-사용하라" class="headerlink" title="인스턴스 필드를 사용하라"></a>인스턴스 필드를 사용하라</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Ensemble</span> &#123;</span><br><span class="line">    SOLO(<span class="number">1</span>), DUET(<span class="number">2</span>), TRIO(<span class="number">3</span>), QUARTET(<span class="number">4</span>), QUINTET(<span class="number">5</span>),</span><br><span class="line">    SEXTET(<span class="number">6</span>), SEPET(<span class="number">7</span>), OCTET(<span class="number">8</span>), DOUBLE_QUARTET(<span class="number">8</span>),</span><br><span class="line">    NONET(<span class="number">9</span>), DECTET(<span class="number">10</span>), TRIPLE_QUARTET(<span class="number">12</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> numberOfMusicians;</span><br><span class="line">    Ensemble(<span class="type">int</span> numberOfMusicians) &#123;</span><br><span class="line">        <span class="built_in">this</span>.numberOfMusicians = numberOfMusicians;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfMusicians</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.numberOfMusicians; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이처럼 인스턴스 필드를 두어 값을 초기화 하여 사용하는 방법으로 사용하는 것이 좋다.</p><h1 id="ordinal은-언제-사용하나"><a href="#ordinal은-언제-사용하나" class="headerlink" title="ordinal은 언제 사용하나?"></a>ordinal은 언제 사용하나?</h1><blockquote><p>The ordinal of this enumeration constant<br>(its position in the enum declaration, where the initial constant is assigned an ordinal of zero).<br>Most programmers will have no use for this field.<br>It is designed for use by sophisticated enum-based data structures,<br>such as {@link java.util.EnumSet} and {@link java.util.EnumMap}.</p></blockquote><p>ordinal은 enum타입의 상수 값이다. (상수의 위치값)<br>대부분의 프로그래머는 이 값이 필요는 없다.<br>이 값은 EnumSet이나 EnumMap 같은 열거 타입 기반의 범용 자료구조에 사용 될 목적으로 만들어졌다.<br><strong>결론: 사용하지 말자</strong></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 35. ordinal 메서드 대신 인스턴스 필드를 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 34. Int 상수 대신 열거 타입을 사용하라</title>
      <link href="/2019/02/03/effective-java-item34/"/>
      <url>/2019/02/03/effective-java-item34/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>자바에서는 상수(Costants)라는 개념이 있다.<br>변하지 않는 값을 공통적으로 선언하고 한 군데에서 관리하고자 사용한다.<br>Java 1.5 버전부터 enum (enumeration) 타입을 제공하였고, C&#x2F;C++에서 처럼 단순한 정수값을 제공하는 수준을 넘어<br>완전한 형태의 클래스의 역할을 수행 하는 강력한 기능을 제공한다.</p><h1 id="정수-열거-패턴-int-enum-pattern-의-단점"><a href="#정수-열거-패턴-int-enum-pattern-의-단점" class="headerlink" title="정수 열거 패턴(int enum pattern)의 단점"></a>정수 열거 패턴(int enum pattern)의 단점</h1><h2 id="타입-safe하지-않다"><a href="#타입-safe하지-않다" class="headerlink" title="타입 safe하지 않다."></a>타입 safe하지 않다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">APPLE_FUJI</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">APPLE_PIPPIN</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">APPLE_GRANNY_SMITH</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ORANGE_NAVEL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ORANGE_TEMPLE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ORANGE_BLOOD</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>정수 열거 패턴은 위와 같이 선언하고 사용된다.<br>자바는 정수 열거 패턴을 위한 별도의 namespace를 지원하지 않기 때문에 어쩔수 없이 접두어를 사용해서 이름 충돌을 방지한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPLE_FUJI == ORANGE_NAVEL;</span><br></pre></td></tr></table></figure><p>위에 대한 결과는 true가 되기 때문에 type safe 하지 않으며, 표현력도 좋지 않다.</p><h2 id="정수-열거-패턴을-사용한-프로그램은-깨지기-쉽다"><a href="#정수-열거-패턴을-사용한-프로그램은-깨지기-쉽다" class="headerlink" title="정수 열거 패턴을 사용한 프로그램은 깨지기 쉽다."></a>정수 열거 패턴을 사용한 프로그램은 깨지기 쉽다.</h2><p>평범한 상수를 나열한 것뿐이라, 컴파일 하면 그 값이 클라이언트 파일에 그대로 새겨진다.<br>따라서 상수의 값이 바뀌면 클라리언트도 반드시 다시 컴파일 해야 한다.<br><code>다시 컴파일 하지 않은 클라이언트는 실행이 되더라도 엉뚱하게 동작할 수 있다.</code></p><p><img src="./constants-code.png" alt="constants-code"></p><p><img src="./compiled-constants-code.png" alt="compiled-constants-code"></p><p>compile 이후에는 상수에 대한 namespace정보가 없기 때문에 단순히 상수 값만 찍히게 된다.</p><h2 id="정수-상수는-문자열로-출력하기-까다롭다"><a href="#정수-상수는-문자열로-출력하기-까다롭다" class="headerlink" title="정수 상수는 문자열로 출력하기 까다롭다."></a>정수 상수는 문자열로 출력하기 까다롭다.</h2><p>그 값을 출력하거나 디버거로 살펴보면 (의미가 아닌) 단지 숫자로만 보여서 썩 도움이 되지 않는다.<br>(APPLE_FUJI나, ORANGE_NAVEL 같은 의미를 출력하기 어렵다는 의미)<br>같은 정수 열거 그룹에 속한 모든 상수를 한 바퀴 순회하는 방법도 마땅치 않다.<br>(enum은 values()메서드를 통해 상수를 배열 형태로 제공한다.)</p><h2 id="문자열-열거-패턴은-더-나쁘다"><a href="#문자열-열거-패턴은-더-나쁘다" class="headerlink" title="문자열 열거 패턴은 더 나쁘다."></a>문자열 열거 패턴은 더 나쁘다.</h2><p>상수의 의미를 출력할 수 있다는 점은 좋지만, 문자열 상수의 이름 대신 문자열 값을 그대로 하드코딩하게 만들기 때문이다.<br>하드코딩한 문자열에 오타가 있어도 컴파일러는 확인할 길이 없으니, 자연스럽게 런타임 버그가 생긴다.<br>문자열 비교에 따른 성능 저하 역시 당연한 결과다.</p><h1 id="Java의-열거-타입"><a href="#Java의-열거-타입" class="headerlink" title="Java의 열거 타입"></a>Java의 열거 타입</h1><p>자바의 열거(enum) 타입은 완전한 형태의 <code>클래스(class)</code> 이다.<br>Java에서는 Enum.java라는 abstract클래스를 Java 1.5 부터 제공하고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the common base class of all Java language enumeration types.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * More information about enums, including descriptions of the</span></span><br><span class="line"><span class="comment"> * implicitly declared methods synthesized by the compiler, can be</span></span><br><span class="line"><span class="comment"> * found in section 8.9 of</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Note that when using an enumeration type as the type of a set</span></span><br><span class="line"><span class="comment"> * or as the type of the keys in a map, specialized and efficient</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> java.util.EnumSet set&#125; and &#123;<span class="doctag">@linkplain</span></span></span><br><span class="line"><span class="comment"> * java.util.EnumMap map&#125; implementations are available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; The enum type subclass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Josh Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Neal Gafter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Class#getEnumConstants()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.util.EnumSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.util.EnumMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span> <span class="comment">// No serialVersionUID needed due to</span></span><br><span class="line">                            <span class="comment">// special-casing of enum types.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable &#123;</span><br></pre></td></tr></table></figure><p>C&#x2F;C++와 같이 다른 언어에서처럼 단순히 정수값만 지원하는 것이 아니라, 하나의 클래스로써의 역할을 수행해 강력한 기능을 제공한다.</p><h2 id="열거-enum-타입의-특징"><a href="#열거-enum-타입의-특징" class="headerlink" title="열거(enum) 타입의 특징"></a>열거(enum) 타입의 특징</h2><ul><li>열거 타입 자체는 클래스(class)이다.</li><li>상수 하나당 자신의 인스턴스를 하나씩 만들어(Singleton) public static final 필드로 공개한다.</li><li>열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로, 사실상 final이다.<br>(따라서 열거 타입 내 필드도 final이다.)</li></ul><h2 id="타입-safe하다"><a href="#타입-safe하다" class="headerlink" title="타입 safe하다."></a>타입 safe하다.</h2><p>열거 타입은 타입 안전성을 제공한다.<br>위의 APPLE과 ORANGE의 상수 형태를 enum으로 변경한 뒤 다시 테스트 해보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Apple</span> &#123;FUJI, PIPPIN, GRANNY_SMITH&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Orange</span> &#123;NAVEL, TEMPLE, BLOOD&#125;</span><br></pre></td></tr></table></figure><p><img src="./enum-test.png" alt="enum-test"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(24, 33) java: incomparable types: com.study.effectivejavatest.item34.Apple and com.study.effectivejavatest.item34.Orange</span><br></pre></td></tr></table></figure><p>컴파일 시, 위와 같은 에러가 발생한다.<br>Apple.FUJI와 Orange.NAVEL은 비교를 할 수 없는 타입이라는 내용이다.<br>다른 열거 타입의 값끼리 &#x3D;&#x3D; 연산자로 비교하려는 꼴이기 때문이다.</p><h2 id="각자의-namespace가-있다"><a href="#각자의-namespace가-있다" class="headerlink" title="각자의 namespace가 있다."></a>각자의 namespace가 있다.</h2><p>열거타입은 각자의 namespace가 있어서 이름이 같은 상수도 평화롭게 공존한다.<br>열거 타입에 새로운 상수를 추가하거나, 순서를 바꿔도 다시 컴파일 하지 않아도 된다.<br>공개 되는 것이 오직 필드의 이름 뿐이라, 컴파일 시, 클라이언트의 코드에 정수 값이 각인되지 않기 때문이다.</p><p><img src="./compiled-constants-code2.png" alt="compiled-constants-code2"></p><h1 id="데이터와-메서드를-갖는-열거-타입"><a href="#데이터와-메서드를-갖는-열거-타입" class="headerlink" title="데이터와 메서드를 갖는 열거 타입"></a>데이터와 메서드를 갖는 열거 타입</h1><p>열거 타입은 메서드와 필드를 추가 할 수 있다.<br>각 상수 별로 데이터를 가질 수 있고, enum에서 공통적으로 사용하는 메서드를 선언하거나 상수 별로 메서드를 재정의 할 수 있다.<br>단순하게는 상수 모음이지만, 실제로는 클래스이기 때문에 고차원의 추상 개념 하나를 완벽히 표현해낼 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Planet</span> &#123;</span><br><span class="line">    MERCURY(<span class="number">3.302e+23</span>, <span class="number">2.439e6</span>),</span><br><span class="line">    VENUS(<span class="number">4.869e+24</span>, <span class="number">6.052e6</span>),</span><br><span class="line">    EARTH(<span class="number">5.975e+24</span>, <span class="number">6.378e6</span>),</span><br><span class="line">    MARS(<span class="number">6.419e+23</span>, <span class="number">3.393e6</span>),</span><br><span class="line">    JUPITER(<span class="number">1.899e+27</span>, <span class="number">7.149e7</span>),</span><br><span class="line">    SATURN(<span class="number">5.685e+26</span>, <span class="number">6.027e7</span>),</span><br><span class="line">    URANUS(<span class="number">8.683e+25</span>, <span class="number">2.556e7</span>),</span><br><span class="line">    NEPTUNE(<span class="number">1.024e+26</span>, <span class="number">2.447e7</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> mass;            <span class="comment">// 질량(단위: 킬로그램)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> radius;          <span class="comment">// 반지름(단위: 미터)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> surfaceGravity;  <span class="comment">// 표면중력(단위: m / s^2)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 중력상수 (단위: m^3 / kg s^2)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">G</span> <span class="operator">=</span> <span class="number">6.67300E-11</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생성자</span></span><br><span class="line">    Planet(<span class="type">double</span> mass, <span class="type">double</span> radius) &#123;</span><br><span class="line">        <span class="built_in">this</span>.mass = mass;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">        <span class="built_in">this</span>.surfaceGravity = G * mass / (radius * radius);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">surfaceWeight</span><span class="params">(<span class="type">double</span> mass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mass * surfaceGravity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 Planet의 예시를 보면, 행성별 상수는 각각 질량과 반지름을 필드로 가지고 있다.<br>그리고 표면중력에 대한 값을 계산해 주는 surfaceWeight라는 메서드를 공통으로 사용하고 있다.  </p><ul><li>열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.</li><li>열거 타입은 외부로의 생성자를 제공하지 않기 때문에 불변 객체이다.</li><li>모든 필드는 final이다.</li><li>필드를 public으로 선언해도 되지만, private로 선언 후 접근자 메서드를 제공하는 것이 좋다.</li></ul><h1 id="상수별-메서드-구현"><a href="#상수별-메서드-구현" class="headerlink" title="상수별 메서드 구현"></a>상수별 메서드 구현</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    PLUS, MINUS, TIMES, DIVIDE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 사칙 연산 열거타입이 있을 때, 사칙연산에 대한 로직을 열거 타입 내에 작성하고 싶을 때가 있다.<br>여러가지 방법을 통해 구현해 보도록 하겠다.</p><h2 id="switch-case을-이용한-구현"><a href="#switch-case을-이용한-구현" class="headerlink" title="switch-case을 이용한 구현"></a>switch-case을 이용한 구현</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> PLUS: <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">case</span> MINUS: <span class="keyword">return</span> x - y;</span><br><span class="line">        <span class="keyword">case</span> TIMES: <span class="keyword">return</span> x * y;</span><br><span class="line">        <span class="keyword">case</span> DIVIDE: <span class="keyword">return</span> x / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;알 수 없는 연산: &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 경우에는 메서드 하나에 연산을 모아 볼 수 있는 장점은 있다.<br>하지만 상수가 추가 되는 경우, 실수로 case를 추가 하지 않으면, <code>알 수 없는 연산</code>이라는 예외가 발생하게 된다.</p><h2 id="abstract-method를-이용한-구현"><a href="#abstract-method를-이용한-구현" class="headerlink" title="abstract method를 이용한 구현"></a>abstract method를 이용한 구현</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    PLUS&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    MINUS&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    TIMES&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x * y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    DIVIDE&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x / y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 선언하면 상수가 추가 될 때마다 apply 메서드를 재정의 해줘야 한다.</p><h2 id="Funtional-Interface를-이용한-구현"><a href="#Funtional-Interface를-이용한-구현" class="headerlink" title="Funtional Interface를 이용한 구현"></a>Funtional Interface를 이용한 구현</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    PLUS((x, y) -&gt; x + y),</span><br><span class="line">    MINUS((x, y) -&gt; x - y),</span><br><span class="line">    TIMES((x, y) -&gt; x * y),</span><br><span class="line">    DIVIDE((x, y) -&gt; x / y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> BiFunction&lt;Double, Double, Double&gt; operationFuntion;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8에서 제공하는 BiFuntion 을 이용해 람다식을 이용하여 로직을 구현 할 수 있다.</p><h2 id="편한-계산식-출력"><a href="#편한-계산식-출력" class="headerlink" title="편한 계산식 출력"></a>편한 계산식 출력</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Double.parseDouble(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> Double.parseDouble(args[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Operation op : Operation.values()) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%f %s %f = %f%n&quot;</span>, x, op, y, op.apply(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.000000 + 4.000000 = 6.000000</span><br><span class="line">2.000000 - 4.000000 = -2.000000</span><br><span class="line">2.000000 * 4.000000 = 8.000000</span><br><span class="line">2.000000 / 4.000000 = 0.500000</span><br></pre></td></tr></table></figure><h1 id="전략적-열거-타입-패턴"><a href="#전략적-열거-타입-패턴" class="headerlink" title="전략적 열거 타입 패턴"></a>전략적 열거 타입 패턴</h1><p>상수별 메서드 구현에는 열거 타입 상수끼리 코드를 공유하기 어렵다는 단점이 있다.<br>아래 예시는 요일별로 일당을 계산해 주는 열거타입 메서드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PayrollDay</span> &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MINS_PER_SHIFT</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">60</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> minutesWorked, <span class="type">int</span> payRate)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">basePay</span> <span class="operator">=</span> minutesWorked * payRate;</span><br><span class="line">        <span class="type">int</span> overtimePay;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> SATURDAY:</span><br><span class="line">            <span class="keyword">case</span> SUNDAY:</span><br><span class="line">                overtimePay = basePay / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                overtimePay = minutesWorked &lt;= MINS_PER_SHIFT ? <span class="number">0</span> : </span><br><span class="line">                (minutesWorked - MINS_PER_SHIFT) * payRate / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> basePay + overtimePay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>간결하지만, 관리 관점에서는 위험한 코드이다.<br>공휴일과 같은 새로운 값을 열거타입에 추가하려면 그 값을 처리하는 case문을 잊지말고 추가해 줘야 한다.<br>상수별 메서드 구현으로 급여를 정확히 계산하는 방법은 두 가지다.</p><ol><li>잔업수당을 계산하는 코드를 모든 상수에 중복해서 넣는다.</li><li>평일용&#x2F;주말용으로 나눠 각각 도우미 메서드를 생성한다음 각 상수가 자신에게 필요한 메서드를 적절히 호출한다.</li></ol><p>1번으로 로직을 구성할 경우 case 구문을 사용할 때와 동일한 문제가 발생한다.<br>가장 깔끔한 방법은 새로운 상수를 추가할 때, 잔업 수당에 대한 <code>전략</code>을 선택하게 하는 방법이다.</p><h2 id="잔업-수당-전략-선택하기"><a href="#잔업-수당-전략-선택하기" class="headerlink" title="잔업 수당 전략 선택하기"></a>잔업 수당 전략 선택하기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PayrollDay</span> &#123;</span><br><span class="line">    MONDAY(WEEKDAY),</span><br><span class="line">    TUESDAY(WEEKDAY),</span><br><span class="line">    WEDNESDAY(WEEKDAY),</span><br><span class="line">    THURSDAY(WEEKDAY),</span><br><span class="line">    FRIDAY(WEEKDAY),</span><br><span class="line">    SATURDAY(WEEKEND),</span><br><span class="line">    SUNDAY(WEEKEND);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayType payType;</span><br><span class="line">    </span><br><span class="line">    PayrollDay(PayType payType) &#123;</span><br><span class="line">        <span class="built_in">this</span>.payType = payType;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> minutesWorked, <span class="type">int</span> payRate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> payType.pay(minutesWorked, payRate);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">PayType</span> &#123;</span><br><span class="line">        WEEKDAY &#123;</span><br><span class="line">            <span class="type">int</span> <span class="title function_">overtimePay</span><span class="params">(<span class="type">int</span> minutesWorked, <span class="type">int</span> payRate)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> minutesWorked &lt;= MINS_PER_SHIFT ? <span class="number">0</span> : (minutesWorked - MINS_PER_SHIFT) * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        WEEKEND &#123;</span><br><span class="line">            <span class="type">int</span> <span class="title function_">overtimePay</span><span class="params">(<span class="type">int</span> minutesWorked, <span class="type">int</span> payRate)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> minutesWorked * payRate / <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">overtimePay</span><span class="params">(<span class="type">int</span> minutesWorked, <span class="type">int</span> payRate)</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MINS_PER_SHIFT</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">60</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> minutesWorked, <span class="type">int</span> payRate)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">basePay</span> <span class="operator">=</span> minutesWorked &amp; payRate;</span><br><span class="line">            <span class="keyword">return</span> basePay + overtimePay(minutesWorked, payRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 코드를 변경하니 깔끔하게 되었다.<br>switch문은 열거 타입의 상수별 동작을 구현하는데 적합하지 않다.<br>하지만 기존의 열거 타입의 상수별 동작을 혼합해 넣을 때에는 switch문이 좋은 선택이 될 수 있다.<br>(최소한으로 코드를 변경하기 때문)</p><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li><p>필요한 원소를 컴파일타입에 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자</p></li><li><p>int 상수 대신 열거 타입으로 정의하라</p></li><li><p>각 상수와 특정 데이터를 연결 짓거나, 상수마다 다른 action이 필요한 경우 열거 타입이 효과적이다.</p></li><li><p>switch문으로 분기하여 로직을 구성하기 보다는 전략 열거타입 패턴을 사용하여 로직을 구현하라.</p></li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 34. int 상수 대신 열거 타입을 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라</title>
      <link href="/2019/01/28/effective-java-item32/"/>
      <url>/2019/01/28/effective-java-item32/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>가변인수(varargs) 메서드와 제네릭은 Java 5버전에 함께 추가되었다.<br>서로 잘 어우러지리라 생각하겠지만, 그렇지 않다. 가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는데, 구현방식에 헛점이 있다.<br>가변인수 메서드를 호출하면, 가변인수를 담기 위한 배열이 자동으로 하나 만들어진다.<br>그 결과 varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생한다.</p><p>실제화 불가 타입은 런타임에는 컴파일타임보다 타입관련 정보를 적게 담고 있다<code>(소거)</code></p><h1 id="제네릭과-varargs를-혼용하면-타입-안정성이-깨진다"><a href="#제네릭과-varargs를-혼용하면-타입-안정성이-깨진다" class="headerlink" title="제네릭과 varargs를 혼용하면 타입 안정성이 깨진다."></a>제네릭과 varargs를 혼용하면 타입 안정성이 깨진다.</h1><p>매개변수화 타입(Parameterize Type (예 List<String>))의 변수가 타입이 다른 객체를 참조하면 <strong>힙 오염</strong>이 발생한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dangerous</span><span class="params">(List&lt;String&gt;... stringLists)</span> &#123;</span><br><span class="line">  List&lt;Integer&gt; intList = List.of(<span class="number">42</span>);</span><br><span class="line">  <span class="comment">//varargs는 내부적으로 배열이고</span></span><br><span class="line">  <span class="comment">//배열은 공변이기 때문에 List&lt;String&gt;타입은 Object의 하위클래스로 인식되어</span></span><br><span class="line">  <span class="comment">//Object[]에 참조 될 수 있다.</span></span><br><span class="line">  Object[] objects = stringLists;</span><br><span class="line">  Object[<span class="number">0</span>] = intList; <span class="comment">//힙 오염 발생</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// ClassCastException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드를 한줄한줄 분석해보자</p><ol><li>List<String> varargs형태의 파라미터를 받는 메서드이다.</li><li>List<Integer> 제네릭타입 객체를 생성하여 42라는 값을 추가하였다.</li><li>varargs는 내부적으로 배열이고, 배열은 공변이기 때문에 List<String>[] -&gt; Object[]에 참조될 수 있다.</li><li>Object[0] &#x3D; intList 초기화<br>(내부적으로는 List<String> 타입이지만, 런타임에는 제네릭 타입이 소거되므로 같은 List로만 인식되어 할당이 가능하다. <strong>힙 오염 발생</strong>)</li><li>stringList[0]을 하면 List가 나오고 List의 0번째 인덱스 위치의 객체를 호출해 눈에 보이지 않는 String으로 형변환한다.</li></ol><p>-&gt; 여기서 ClassCastException이 발생 </p><p>이처럼 타입안정성이 깨지기 때문에 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다.<br>(실제로 실무에서는 저런 경우는 거의 없다. 웬만하면 varargs 형태로 받아와서 그대로 사용하기 때문)</p><h1 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h1><p>자바 7 전에는 제네릭 가변인수 메서드의 작성자가 호출자 쪽에서 발생하는 경고에 대해서 해줄 수 있는 일이 없었다.<br>사용자는 이 경고를 그냥 무시하거나, 사용하는 메서드에서 @SupprssWarning(“unchecked”) annotation을 달아 경고를 숨겨야 했다.<br>자바 7부터 @SafeVarargs annotation이 추가되어 제네릭 가변인수 메서드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있게 되었다.</p><p>단, @SafeVarargs annotation은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치이므로<br>반드시 메서드가 타입 안전한 경우에만 이 annotation을 붙이는 것이 좋다.</p><h2 id="어떤게-타입-안전할까"><a href="#어떤게-타입-안전할까" class="headerlink" title="어떤게 타입 안전할까?"></a>어떤게 타입 안전할까?</h2><ul><li>가변인수 메서드를 호출하면 varargs 매개변수를 담는 제네릭 배열이 만들어 진다.  </li><li>메서드 내에서 이 배열에 아무것도 저장하지 않고, 배열의 참조가 밖으로 노출되지 않는다면 타입 안전하다.</li><li>순수하게 메서드의 생산자 역할만 충실히 하면 메서드는 안전하다.</li></ul><h2 id="자신의-제네릭-매개변수-배열의-참조를-노출하는-것은-위험하다"><a href="#자신의-제네릭-매개변수-배열의-참조를-노출하는-것은-위험하다" class="headerlink" title="자신의 제네릭 매개변수 배열의 참조를 노출하는 것은 위험하다."></a>자신의 제네릭 매개변수 배열의 참조를 노출하는 것은 위험하다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T[] toArray(T... args) &#123;</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T[] pickTwo(T a, T b, T c) &#123;</span><br><span class="line">  <span class="keyword">switch</span>(ThreadLocalRandom.current().nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> toArray(a, b);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> toArray(b, c);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> toArray(c, a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertiionError</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  String[] attributes = pickTwo(<span class="string">&quot;좋은&quot;</span>, <span class="string">&quot;빠른&quot;</span>, <span class="string">&quot;저렴한&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아무 문제가 없는 메서드이니 별다른 문제없이 컴파일 된다.<br>하지만 실행하면 ClassCastException을 던진다.<br>어디서 발생하는 에러일까?</p><p>정답은 바로 String[] attributes &#x3D; pickTwo(); 메서드에서 보이지 않는 형변환 시 발생한다.</p><p>실제로는 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] attributes = (String[]) pickTwo(<span class="string">&quot;좋은&quot;</span>, <span class="string">&quot;빠른&quot;</span>, <span class="string">&quot;저렴한&quot;</span>);</span><br></pre></td></tr></table></figure><p>Object[]는 String[]의 <code>하위타입</code>이 아니므로 형변환할 수 없다. (다운캐스팅 불가)<br>이 예시는 <strong>제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다.</strong> 를 다시금 알려주는 예제이다.</p><p>단 예외가 두 가지 있다.</p><ul><li>@SafeVarargs로 선언된 타입 안전성이 보장된 또 다른 varargs 메서드에 넘기는 것은 안전하다.</li><li>배열 내용의 일부 함수를 호출만 하는 (varargs를 받지않는) 일반 메서드에 넘기는 것도 안전하다.</li></ul><h1 id="제네릭-varargs-매개변수를-안전하게-사용하는-메서드"><a href="#제네릭-varargs-매개변수를-안전하게-사용하는-메서드" class="headerlink" title="제네릭 varargs 매개변수를 안전하게 사용하는 메서드"></a>제네릭 varargs 매개변수를 안전하게 사용하는 메서드</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">flatten</span><span class="params">(List&lt;? extends T&gt;... lists)</span> &#123;</span><br><span class="line">  List&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span>(List&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; list : lists) &#123;</span><br><span class="line">    result.addAll(list);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 메서드는 안전하다.<br>varargs 배열을 직접 노출 시키지 않고, T타입의 제네릭 타입을 사용하였기 때문에 ClassCastException 또한 발생할 일이 없다.<br>안전한 varargs 메서드에는 @SafeVarargs annotation을 달아서 컴파일러 경고를 없애는 것이 좋다.</p><h1 id="제네릭-varargs-매개변수를-List로-대체하라"><a href="#제네릭-varargs-매개변수를-List로-대체하라" class="headerlink" title="제네릭 varargs 매개변수를 List로 대체하라"></a>제네릭 varargs 매개변수를 List로 대체하라</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">flatten</span><span class="params">(List&lt;List&lt;? extends T&gt;&gt; lists)</span> &#123;</span><br><span class="line">  List&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (List&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; list : lists) &#123;</span><br><span class="line">    result.addAll(list);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 방식의 장점은 이 메서드의 타입 안전성을 검증할 수 있다는 점이다.<br>@SafeVarargs를 달지 않아도 되며 실수로 안전하다고 판단할 걱정도 없다.<br>단점은 클라이언트 코드가 살짝 지저분해지고, 속도가 약간 느려질 수 있다는 점이다.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul><li>varargs 매개변수는 단순히 파라미터를 받아와 메서드의 생산자(T 타입의 객체를 제공하는 용도)로만 사용하자</li><li>varargs는 read-only라고 생각하고, 아무런 데이터를 저장하지 말자</li><li>varargs 배열을 외부에 리턴하거나 노출하지 말자.<br>웬만하면 다시 컬렉션(List)에 담아 리턴하는 안전한 방식을 취하자</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 31. 한정적 와일드 카드(Bounded Wildcard Type)를 사용해 API 유연성을 높여라</title>
      <link href="/2019/01/26/effective-java-item31/"/>
      <url>/2019/01/26/effective-java-item31/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Generic에서 매개변수화 타입(Parameterize Type - List<String>)는 불공변이다.</p><blockquote><p>공변 vs 불공변<br>Java에서 배열은 공변(variant), Generic은 불공변(invariant)이라 한다.<br>배열의 경우 Object[]과 String[] 간에는 부모-자식 클래스 관계가 성립한다. 이를 공변이라한다.<br>하지만 Generic에서는 List<Object>와 List<String>은 부모-자식 관계가 성립하지 않는다 이를 불공변이라한다.</p></blockquote><p>즉, List<String>은 String타입의 문자열만 넣을 수 있지만, List<Object>는 문자열이건, 숫자건 다 넣을 수 있으므로, 부모클래스에서 가능한 일은 자식클래스에서도 가능해야 한다는 <strong>리스코프 치환원칙</strong>에 위배된다.</p><p>하지만 때로는 불공변 방식보다 유연한 무언가가 필요하다.</p><h1 id="생산자-producer-와일드카드-적용"><a href="#생산자-producer-와일드카드-적용" class="headerlink" title="생산자(producer) 와일드카드 적용"></a>생산자(producer) 와일드카드 적용</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; integers = List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">numberStack.pushAll(integers);</span><br></pre></td></tr></table></figure><p>Integer는 Number의 하위타입이기 때문에 잘 동작할 것 같지만, 실제로는 컴파일 시에 오류가 발생한다.</p><p>Parameterize Type이 불공변이기 때문에 Iterator<Number>와 Iterator<Integer>는 부모-자식 관계가 아니다.<br>그렇기 때문에 addAll 메서드의 파라미터로 사용할 수 없는 것이다.</p><p>이런 경우 생산자(producer) 파라미터에 와일드카드 타입을 적용하여 유연하게 만들 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushAll</span><span class="params">(Iterator&lt;? extends E&gt; iterator)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (E e : iterator) &#123;</span><br><span class="line">    push(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>생산자(producer) 파라미터란, 파라미터로 제공되어 메서드 내에서 사용 될 객체를 공급해 주는 파라미터이다. </p><p><code>&lt;? extends E&gt;</code> 형태로 사용하는 경우 E 타입의 하위타입만 파라미터로 올 수 있게 제약을 거는 것이다.<br><code>모든 타입은 자기 자신의 하위타입이다!</code> 라는 규칙이 있으므로 자기 자신에 대한 타입도 들어올 수 있다.</p><h1 id="소비자-consumer-와일드카드-적용"><a href="#소비자-consumer-와일드카드-적용" class="headerlink" title="소비자(consumer) 와일드카드 적용"></a>소비자(consumer) 와일드카드 적용</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popAll</span><span class="params">(Collection&lt;E&gt; dst)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(!isEmpty()) &#123;</span><br><span class="line">    dst.add(pop());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">Collection&lt;Object&gt; objects = List.of(<span class="number">1</span>, <span class="string">&quot;String&quot;</span>);</span><br><span class="line">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure><p>컴파일 하게되면 Collection<Object>는 Collection<Number>의 하위타입이 아니다라는 오류가 나온다.<br>이를 해결하기 위해서는 super를 이용해 와일드카드를 작성해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popAll</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; dst)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(!isEmpty()) &#123;</span><br><span class="line">    dst.add(pop());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>소비자(consumer) 파라미터란, 메서드에 제공되어 메서드 내에서 제공되는 객체를 자기 자신이 사용하는 파라미터를 의미한다.</p><h1 id="PECS-Producer-Extends-Consumer-Super"><a href="#PECS-Producer-Extends-Consumer-Super" class="headerlink" title="PECS(Producer-Extends, Consumer-Super)"></a>PECS(Producer-Extends, Consumer-Super)</h1><p>다음 공식을 외워 어떤 와일드 카드 타입을 쓸지 기억하자</p><ul><li>생산자(producer) - Generic 클래스 내에 타입 파라미터를 이용해 객체를 제공하는 것 <ul><li><? extends E>를 사용하여 유연성을 높일 수 있다.</li></ul></li><li>소비자(consumer) - Generic 클래스 내의 자원을 사용하는 객체를 파라미터로 전달하는 것 <ul><li><? super E>를 사용하여 유연성을 높일 수 있다.</li><li>Comparable, Comparator는 소비자로 사용된다.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; integers = Set.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Set&lt;Double&gt; doubles = Set.of(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line">Set&lt;Number&gt; numbers = union(integers, doubles);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> &#123;</span><br><span class="line">  Set&lt;E&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">  set.addAll(integers);</span><br><span class="line">  set.addAll(doubles);</span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 메서드가 만들어지면 타입이 맞지 않는다고 컴파일 오류가 나게 된다.<br>Set<E>은 불공변이기 때문에 Set<Integer>와 Set<Double>은 Set<Number>의 하위타입이 아니기 떄문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">union</span><span class="params">(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2)</span> &#123;</span><br><span class="line">  Set&lt;E&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">  set.addAll(integers);</span><br><span class="line">  set.addAll(doubles);</span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 변경하면 컴파일 오류도 해결되고 잘 실행 된다.<br>이렇게 공통 API를 작성할 때는 와일드 카드를 적절하게 쓰도록 하자.<br>클래스 사용자가 와일드카드 타입을 신경써야 한다면, 그 API에 문제가 있을 가능성이 크다.</p><h2 id="Java7에서는…"><a href="#Java7에서는…" class="headerlink" title="Java7에서는…"></a>Java7에서는…</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);</span><br></pre></td></tr></table></figure><p>위와 같은 형태로 명시적으로 타입인수를 사용해야 한다.<br>타입추론능력이 부족하기 때문이다.</p><h1 id="심화-Comparable"><a href="#심화-Comparable" class="headerlink" title="심화 - Comparable"></a>심화 - Comparable</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;E&gt;&gt; E <span class="title function_">max</span><span class="params">(List&lt;E&gt; list)</span></span><br></pre></td></tr></table></figure><p>와일드카드를 통해 좀 더 다듬은 모습이다.<br><strong>주의: Comparable을 구현한 클래스만 파라미터로 올 수 있다</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; E <span class="title function_">ma</span><span class="params">(List&lt;? extends E&gt; list)</span> &#123;</span><br><span class="line">           list.sort(Comparator.reverseOrder());</span><br><span class="line">           <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><ul><li>일반적으로는 Comparable<E>보단 Comparable&lt;? super E&gt;를 사용하는게 낫다. (대부분 소비자로 사용)</li></ul><h1 id="심화2-와일드카드를-적절히-사용하라"><a href="#심화2-와일드카드를-적절히-사용하라" class="headerlink" title="심화2 - 와일드카드를 적절히 사용하라"></a>심화2 - 와일드카드를 적절히 사용하라</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List&lt;E&gt; list, <span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br></pre></td></tr></table></figure><p>리스트 내의 특정 인자들의 위치를 뒤바꿔주는 메서드이다.<br>어느 메서드가 더 좋을까?</p><p>기본적으로는 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하는 것이 좋다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">  list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 list.get하는 부분에서 컴파일 오류가 난다.<br>비한정적 와일드카드를 사용하고 있기 때문에 list.set을 하는 경우에는 null밖에 넣을 수가 없다.<br>이런 경우 도우미 메서드를 따로 이용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">swapHelper</span><span class="params">(List&lt;E&gt; list, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">  list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 경우에는 List<E>의 리턴타입이 항상 E인 것을 알기 때문에<br>런타임 시, 타입안정성을 보장 할 수 있고 set하는 경우에도 E 타입을 set할 것을 알기 때문에 컴파일 오류 없이 작동 한다.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><p>조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다.<br>그러나 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해야 한다.<br>PECS 공식을 기억하여 생산자에는 extends, 소비자에는 super를 사용하자.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 31. 한정적 와일드 카드(bounded wildcard type)를 사용해 API 유연성을 높여라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 17. 변경 가능성을 최소화하라</title>
      <link href="/2019/01/20/effective-java-item17/"/>
      <url>/2019/01/20/effective-java-item17/</url>
      
        <content type="html"><![CDATA[<h1 id="불변-클래스-immutable-class-란"><a href="#불변-클래스-immutable-class-란" class="headerlink" title="불변 클래스(immutable class)란?"></a>불변 클래스(immutable class)란?</h1><ul><li>인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다.  </li><li>불변 클래스의 인스턴스는 객체가 생성되는 시점에 초기화되고 소멸이 될 때까지 값이 변경되지 않는다.  </li><li>불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉽다.</li><li>값이 변경되지 않으니 오류가 발생할 일도 적고 안전하다.</li></ul><h1 id="불변-클래스를-만들기-위한-5가지-조건"><a href="#불변-클래스를-만들기-위한-5가지-조건" class="headerlink" title="불변 클래스를 만들기 위한 5가지 조건"></a>불변 클래스를 만들기 위한 5가지 조건</h1><h2 id="객체의-상태를-변경하는-메서드-변경자-를-제공하지-않는다"><a href="#객체의-상태를-변경하는-메서드-변경자-를-제공하지-않는다" class="headerlink" title="객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다."></a>객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.</h2><ul><li>쉽게 말해 setter나, 필드 정보를 변경하는 메서드를 제공하지 않는다.<h2 id="클래스를-확장-할-수-없도록-한다"><a href="#클래스를-확장-할-수-없도록-한다" class="headerlink" title="클래스를 확장 할 수 없도록 한다."></a>클래스를 확장 할 수 없도록 한다.</h2></li><li>클래스를 final로 선언한다.</li><li>모든 생성자는 private으로 만들고 생성자 정적 팩터리 메서드를 제공한다.</li><li>정적 팩터리 메서드는 유연성을 제공한다.</li><li>다음 릴리즈에서 Boolean처럼 <code>캐싱</code>을 이용해 성능을 끌어올릴 수도 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor(access = AccessLevel.PRIVATE)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor(access = AccessLevel.PRIVATE, staticName=&quot;of&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="모든-필드를-final로-선언한다"><a href="#모든-필드를-final로-선언한다" class="headerlink" title="모든 필드를 final로 선언한다."></a>모든 필드를 final로 선언한다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor(access = AccessLevel.PRIVATE, staticName=&quot;of&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>필드에 대해 수정을 막겠다는 설계자의 의도를 보여준다. - final클래스는 생성자에서 딱 <code>1회 초기화</code> 할 수 있기 때문이다.</li><li>인스턴스에 대한 동기화(syncronized)처리 없이도 다른 스레드에서 문제없이 처리 된다.</li></ul><h2 id="모든-필드를-private로-선언한다"><a href="#모든-필드를-private로-선언한다" class="headerlink" title="모든 필드를 private로 선언한다."></a>모든 필드를 private로 선언한다.</h2><ul><li>필드가 참조하는 가변 객체를 클라이언트에서 직접 접근하여 수정하는 일을 막는다.</li><li>public final로만 처리해도 되지만, 그 안의 내용을 바꿀 수 있고 다 릴리즈에서 내부 표현을 변경하지 못하므로 사용하지 않는게 좋다.</li></ul><h2 id="자신-객체-이외에는-내부의-가변-컴포넌트에-접근-할-수-없도록-한다"><a href="#자신-객체-이외에는-내부의-가변-컴포넌트에-접근-할-수-없도록-한다" class="headerlink" title="자신(객체) 이외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다."></a>자신(객체) 이외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.</h2><ul><li>클라이언트에서 인스턴스 내에 가변 객체의 참조를 얻을 수 없게 해야한다. - Collection에 대한 getter를 제공하면 안된다!</li><li>생성자, 접근자(getter), readObject 메서드에서 모두 <code>방어적 복사</code>를 수행해야 한다.</li></ul><h1 id="함수형-프로그래밍"><a href="#함수형-프로그래밍" class="headerlink" title="함수형 프로그래밍"></a>함수형 프로그래밍</h1><ul><li>피연산자에 함수를 적용해 결과를 반환하는 프로그래밍 기법</li><li>피연산자에 대해 연산하지만 피연산자는 값이 변하지 않음<br>(캡처 - 피연산자는 사실상 final)</li><li>코드의 불변이 영역이 되는 비율이 높아져 안전하다.</li></ul><h1 id="불변-객체의-장점"><a href="#불변-객체의-장점" class="headerlink" title="불변 객체의 장점"></a>불변 객체의 장점</h1><ul><li>불변 객체는 생성 시점부터 소멸될 때 까지 변하지 않는다. - 서비스 로직에 더 안전하다.</li><li>불변 객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요가 없다. - 스레드에 따라 값이 변하지 않기 때문이다.</li><li>불변 객체는 안심하고 공유 할 수 있다. - 불변 클래스라면 최대한 재사용 하라 (캐싱)</li><li>불변 객체는 방어적 복사본이 필요없다 - 바뀌지 않으므로 방어할 일이 없다.</li><li>불변 객체는 clone메서드를 제공하지 않는게 좋다. - 의미가 없다.</li><li>불변 객체를 key로 하면 이점이 많다.<ul><li>Map의 key</li><li>Set의 원소</li></ul></li><li>불변 객체는 그 자체로 실패 원자성을 제공한다.<ul><li>메서드에서 예외가 발생하더라도 객체의 변경내용이 없다.</li></ul></li><li>불변 객체끼리는 자유롭게 내부 데이터를 공유 할 수 있다.<ul><li>BigInteger 클래스에서 mag는 크기를 나타내는 배열</li><li>signum은 부호를 나타내는 int 필드</li><li>mag는 배열이지만 불변이므로 방어적 복사본을 만들지 않고 원래 객체의 mag를 써도 된다.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a BigInteger whose value is &#123;<span class="doctag">@code</span> (-this)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> -this&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="built_in">this</span>.mag, -<span class="built_in">this</span>.signum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>불변 객체는 값이 다르면 반드시 독립된 객체로 만들어야 한다.</li></ul><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>접근자(getter)를 제공한다고 습관처럼 수정자(setter)를 만들지 말자<ul><li>꼭 필요한 경우가 아니라면 클래스는 불변이어야 한다.</li><li>장점이 훨씬많고, 단점이라면 잠재적 성능저하 뿐이다.</li></ul></li><li>불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한 줄이자<ul><li>객체가 가질 수 있는 상태를 제한하면, 예외를 예측하기 쉽고, 오류가 생길 가능성이 줄어든다.</li><li>꼭 변경할 필드가 아닌 필드는 final로 선언하자 - 웬만하면 final로 해야한다.</li></ul></li><li>생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.<ul><li>확실한 이유가 없다면, 생성자와 정적팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안된다.</li><li>특히! 객체를 재활용할 목적으로 상태를 다시 초기화 하는 메서드도 안된다.</li><li>복잡성만 커지고 성능 이점은 거의 없다.</li></ul></li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 17. 변경 가능성을 최소화하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라</title>
      <link href="/2019/01/20/effective-java-item16/"/>
      <url>/2019/01/20/effective-java-item16/</url>
      
        <content type="html"><![CDATA[<h1 id="퇴보한-클래스"><a href="#퇴보한-클래스" class="headerlink" title="퇴보한 클래스"></a>퇴보한 클래스</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> x;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 클래스는 데이터 필드에 직접 접근하여 수정이 가능하다. 따라서 캡슐화의 이점을 제공하지 못한다. </p><ul><li>API를 수정하지 않고는 내부 표현을 바꿀 수 없다.</li><li>불변식을 보장할 수 없다.</li><li>외부에서 필드에 접근할 때 부수 작업을 수행 할 수도 없다.<br>(예를들면, x값 조회 시, Comma case로 리턴하는 식의?)</li></ul><h1 id="흔하게-만드는-캡슐레이션"><a href="#흔하게-만드는-캡슐레이션" class="headerlink" title="흔하게 만드는 캡슐레이션"></a>흔하게 만드는 캡슐레이션</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Point</span> <span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getX</span><span class="params">()</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getY</span><span class="params">()</span> &#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">double</span> x)</span> &#123; <span class="built_in">this</span>.x = x; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">double</span> y)</span> &#123; <span class="built_in">this</span>.y = y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>public 클래스라면 반드시 이정도의 접근자와 수정자를 만드는 정도는 해야된다.  </li><li>클래스 내부 표현 방식을 언제든지 바꿀 수 있는 유연성을 제공해야 한다.</li><li>package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다해도 문제가 없다.<ul><li>같은 패키지안에서 특정이유 때문에 사용하던가, 톱레벨 클래스에서만 접근 할 것이기 때문이다.</li></ul></li></ul><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>public 클래스는 절대 가변 필드를 노출해선 안된다.</li><li>불변 필드라면 노출해도 덜위험 하지만 그래도 하지 말아라.</li><li>package-private 클래스, 톱 레벨 클래스에서는 노출하는 편이 나을 수도 있다. (글쎄..?)</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 15. 클래스와 멤버의 접근 권한을 최소화하라</title>
      <link href="/2019/01/19/effective-java-item15/"/>
      <url>/2019/01/19/effective-java-item15/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>잘 설계된 컴포넌트는 클래스는 모든 내부구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리 해놨다.<br>오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.<br>정보은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.</p><h1 id="정보-은닉의-장점"><a href="#정보-은닉의-장점" class="headerlink" title="정보 은닉의 장점"></a>정보 은닉의 장점</h1><h2 id="시스템-개발-속도를-높인다"><a href="#시스템-개발-속도를-높인다" class="headerlink" title="시스템 개발 속도를 높인다."></a>시스템 개발 속도를 높인다.</h2><p>여러가지 컴포넌트를 병렬로 개발할 수 있기 때문이다.<br>예를 들어, 회원탈퇴 기능을 개발한다고 해보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WithdrawalService</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">withdrawalMember</span><span class="params">(Member member)</span>;</span><br><span class="line">  List&lt;Member&gt; <span class="title function_">getMembers</span><span class="params">()</span>;</span><br><span class="line">  WithdrawalProcessType <span class="title function_">getProcessType</span><span class="params">()</span>; </span><br><span class="line">  <span class="keyword">default</span> <span class="title function_">startProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Member&gt; members = getMembers();</span><br><span class="line">    members.stream().foreach(<span class="built_in">this</span>::withdrawalMember);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 회원탈퇴 로직에 대한 인터페이스를 제공하고,<br>일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴등의 로직이 상이하여 Service를 별도로 구현한다고하는 경우 Interface 스펙에 맞추어 여러 개발자가 개발할 수 있기 때문이다.</p><h2 id="시스템-관리-비용을-낮춘다"><a href="#시스템-관리-비용을-낮춘다" class="headerlink" title="시스템 관리 비용을 낮춘다."></a>시스템 관리 비용을 낮춘다.</h2><p>각 컴포넌트를 빨리 파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.<br>위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 로직에 변경이 생긴 경우<br><code>WithdrawalService</code> interface를 구현한 비회원 탈퇴 서비스를 만들면 되기 때문이다.</p><h2 id="성능-최적화에-도움을-준다"><a href="#성능-최적화에-도움을-준다" class="headerlink" title="성능 최적화에 도움을 준다."></a>성능 최적화에 도움을 준다.</h2><p>완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있다.<br>위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 중 비회원 탈퇴에 대해 처리대상이 많아 startProcess 메서드를 확장하여 내부적으로 withdrawalMember 메서드를 사용하지 않고 회원 리스트에 대해 쿼리를 이용해 Insert~ Select로 한방에 처리 할 수도 있다.</p><h2 id="소프트웨어-재사용성을-높인다"><a href="#소프트웨어-재사용성을-높인다" class="headerlink" title="소프트웨어 재사용성을 높인다."></a>소프트웨어 재사용성을 높인다.</h2><p>외부에 의존하지 않고, 독자적으로 동작할 수 있는 컴포넌트라면, 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크다.<br>예를들면 알림톡 서버 API를 호출 할 수 있는 인터페이스가 있는 경우 그 인터페이스를 그대로 사용할 수 있다.</p><h2 id="큰-시스템을-제작하는-난이도를-낮춰준다"><a href="#큰-시스템을-제작하는-난이도를-낮춰준다" class="headerlink" title="큰 시스템을 제작하는 난이도를 낮춰준다."></a>큰 시스템을 제작하는 난이도를 낮춰준다.</h2><p>시스템 전체가 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있다.<br>쉬운 예로 Mockito를 이용한 TestCase 작성이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RunWith(MockitoJUnitRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WithdrawalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TestWithdrawalService</span> <span class="keyword">implements</span> <span class="title class_">WithdrawalService</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">withdrawalMember</span><span class="params">(Member member)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;Member&gt; <span class="title function_">getMembers</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> TestWithdrawalService testWithdrawalService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMocks</span><span class="params">()</span>&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 회원탈퇴_테스트() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        doReturn(Arrays.asList(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;Carrey&quot;</span>))).when(testWithdrawalService).getMembers();</span><br><span class="line">        doCallRealMethod().when(testWithdrawalService).startProcess();</span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> testWithdrawalService.startProcess();</span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        assertThat(result, is(<span class="string">&quot;FINISHED&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java의-접근제한자"><a href="#Java의-접근제한자" class="headerlink" title="Java의 접근제한자"></a>Java의 접근제한자</h1><ul><li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. </li><li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 할 수 있다.</li><li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li><li>public: 모든 곳에서 접근 할 수 있다.</li></ul><h1 id="모든-클래스와-멤버의-접근성을-가능한-좁혀야-한다"><a href="#모든-클래스와-멤버의-접근성을-가능한-좁혀야-한다" class="headerlink" title="모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다."></a>모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.</h1><p>소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다.</p><h2 id="클래스-레벨-접근제한자"><a href="#클래스-레벨-접근제한자" class="headerlink" title="클래스 레벨 접근제한자"></a>클래스 레벨 접근제한자</h2><p>톱레벨 수준(파일명 &#x3D; 클래스명)이 같은 수준에서의 접근제한자는 public과 package-private만 사용 할 수 있다.</p><ul><li>public으로 선언하는 경우 공개 API로 사용 - 하위호환을 평생 신경써야 한다.</li><li>package-private로 사용하는 경우 해당 패키지 안에서만 사용 가능 - 다음 릴리즈에 내부로직을 변경해도 괜찮다.</li></ul><h2 id="이너클래스-사용하기"><a href="#이너클래스-사용하기" class="headerlink" title="이너클래스 사용하기"></a>이너클래스 사용하기</h2><ul><li>한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 사용하는 클래스 안에 private static으로 중첩해보자</li><li>public일 필요가 없는 클래스의 접근 수준을 package-private로 해보자 - 다른 패키지에서 사용하지 못하게 막아야 한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Shop&gt; shops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shop</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Shop&gt; shops;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Shop</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String owner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="private과-package-private은-해당-클래스의-구현에-해당하므로-공개-API에-영향을-주지-않는다"><a href="#private과-package-private은-해당-클래스의-구현에-해당하므로-공개-API에-영향을-주지-않는다" class="headerlink" title="private과 package-private은 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다."></a>private과 package-private은 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다.</h2><ul><li>일단 처음에는 모든 멤버는 private으로 만들어야 한다.</li><li>같은 패키지에서 접근해야 하는 멤버가 있는 경우 package-private로 변경</li><li>단, Serialize를 구현한 클래스의 경우 공개 API에 의도치 않게 공개 될 수도 있다.</li><li>필드의 접근 권한을 package-private에서 protected로 바꾸는 순간 필드에 접근 할 수 있는 대상 범위가 늘어나니 주의해야 한다.</li></ul><h2 id="메서드를-재정의-할-경우에는-접근-수준을-상위-클래스에서보다-좁게-설정-할-수-없다"><a href="#메서드를-재정의-할-경우에는-접근-수준을-상위-클래스에서보다-좁게-설정-할-수-없다" class="headerlink" title="메서드를 재정의 할 경우에는 접근 수준을 상위 클래스에서보다 좁게 설정 할 수 없다."></a>메서드를 재정의 할 경우에는 접근 수준을 상위 클래스에서보다 좁게 설정 할 수 없다.</h2><ul><li>상위 클래스에서 접근제한자가 protected인데 하위클래스에서 갑자기 package-private이나 private로 변경할 수 없다.</li><li>상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환원칙)을 위반하기 때문이다.</li><li>단 인터페이스를 구현하는 경우에는 클래스의 메서드는 모두 public으로 해야 한다.</li></ul><h2 id="코드를-테스트-하려는-목적으로-클래스-인터페이스를-접근-범위를-넓히는-것을-주의하라"><a href="#코드를-테스트-하려는-목적으로-클래스-인터페이스를-접근-범위를-넓히는-것을-주의하라" class="headerlink" title="코드를 테스트 하려는 목적으로 클래스, 인터페이스를 접근 범위를 넓히는 것을 주의하라"></a>코드를 테스트 하려는 목적으로 클래스, 인터페이스를 접근 범위를 넓히는 것을 주의하라</h2><p>public 클래스의 private -&gt; package-private으로 바꾸는거는 괜찮다. 하지만 그이상의 경우 공개 API에 문제가 될 수 있다.</p><h1 id="public-클래스의-인스턴스-필드는-되도록-public이-아니어야-한다"><a href="#public-클래스의-인스턴스-필드는-되도록-public이-아니어야-한다" class="headerlink" title="public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다."></a>public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.</h1><p>필드가 가변객체를 참조하거나(Collections이나 배열), final이 아닌 인스턴스 필드를 public으로 선언하면 <strong>불변식을 보장할 수 없다.</strong><br>public 가변 필드를 갖는 클래스는 일반적으로 thread safe 하지않다.<br>내부 구현을 바꾸고 싶어도 public 필드를 없애는 방식으로는 리팩터링이 불가하다.</p><p>하지만 상수라면 관례대로 public static final 필드로 공개해도 좋다.<br>필드 명 네이밍은 관례 상 <code>대문자 + _(언더바)</code>로 구성한다.<br>그리고 반드시 불변 객체를 참조하도록 한다.<br>불변성이 깨지는 순간 어마무시한 일이 일어난다.</p><h1 id="클래스에서-public-static-final-배열-필드를-두지말아라"><a href="#클래스에서-public-static-final-배열-필드를-두지말아라" class="headerlink" title="클래스에서 public static final 배열 필드를 두지말아라"></a>클래스에서 public static final 배열 필드를 두지말아라</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>이런 경우 VALUES에 대한 참조를 변경할 수는 없지만, 배열내의 내용을 변경하는 것은 가능하다.</p><h2 id="해결책1-Thing-배열을-private로-만들고-public-불변-리스트를-추가한다"><a href="#해결책1-Thing-배열을-private로-만들고-public-불변-리스트를-추가한다" class="headerlink" title="해결책1. Thing 배열을 private로 만들고 public 불변 리스트를 추가한다."></a>해결책1. Thing 배열을 private로 만들고 public 불변 리스트를 추가한다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br></pre></td></tr></table></figure><h2 id="해결책2-Thing-배열을-private로-만들고-public-메서드를-추가한다"><a href="#해결책2-Thing-배열을-private로-만들고-public-메서드를-추가한다" class="headerlink" title="해결책2. Thing 배열을 private로 만들고 public 메서드를 추가한다."></a>해결책2. Thing 배열을 private로 만들고 public 메서드를 추가한다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">  <span class="keyword">return</span> PRIVATE_VALUES.clone(); <span class="comment">//방어적 복사본</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java-9에-추가된-Modules-Project-Jigsaw"><a href="#Java-9에-추가된-Modules-Project-Jigsaw" class="headerlink" title="Java 9에 추가된 Modules (Project Jigsaw)"></a>Java 9에 추가된 Modules (Project Jigsaw)</h1><p>Java9 부터는 Module시스템이라는 개념이 도입 되었다.  </p><p>패키지는 클래스의 묶음인 것 처럼, 모듈(Modules)은 패키지의 묶음이다.<br>모듈은 관례 상, 자신이 속하는 패키지 중 공개(export) 할 것을 선언한다.<br>관례상 <strong>module-info.java</strong> 에 선언한다.<br>모듈을 정의하기 위해 3가지 정보를 작성해야 한다.</p><ol><li>module 명 - module 명칭</li><li>공개할 package (export)</li></ol><ul><li>공개한 package의 public type에 접근제한자만 외부에서 접근할 수 있다.</li><li>만약 export에 적지 않은 패키지의 클래스 중 public 접근제한자가 있어도 접근을 할 수 없다.</li></ul><ol start="3"><li>module내 package의 클래스를 사용하기 위해 종속되는 package (require)</li></ol><ul><li>다른 모듈의 대한 require를 작성하면 다른 모듈에서 export하는 클래스의 public type에 접근이 가능하다</li></ul><h2 id="Java-8에서-접근-제한자"><a href="#Java-8에서-접근-제한자" class="headerlink" title="Java 8에서 접근 제한자"></a>Java 8에서 접근 제한자</h2><ul><li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. </li><li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li><li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li><li>public: 모든 곳에서 접근할 수 있다.</li></ul><h2 id="Java-9부터의-접근-제한자"><a href="#Java-9부터의-접근-제한자" class="headerlink" title="Java 9부터의 접근 제한자"></a>Java 9부터의 접근 제한자</h2><ul><li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. </li><li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li><li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li><li>모듈 내부의 public: 모듈 내부의 모든 곳에서 접근할 수 있다.</li><li>required의 public: 모듈에 종속하는 모듈의 모든 패키지 내의 클래스에 접근할 수 있다.</li><li>export public: module-info.java에서 제공하는 모든 public에 접근할 수 있다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 15. 클래스와 멤버의 접근 권한을 최소화하라</li><li><a href="https://infoscis.github.io/2017/03/24/First-steps-with-java9-and-jigsaw-part-1/">https://infoscis.github.io/2017/03/24/First-steps-with-java9-and-jigsaw-part-1/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 14. Comparable을 구현할지 고려하라</title>
      <link href="/2019/01/13/effective-java-item14/"/>
      <url>/2019/01/13/effective-java-item14/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Comparable을 구현하는 이유는 클래스의 인스턴스들간의 Ordering을 목적으로 구현하는 클래스이다.<br>따라서 Comparable을 구현한 클래스에 대한 배열은 다음처럼 손쉽게 정렬 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(arr);</span><br></pre></td></tr></table></figure><p>사실상 자바 플랫폼 라이브러리의 모든 값 클래스와 열거타입은 Compareable을 구현했다.<br>알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면, 반드시 Comparable 인터페이스를 구현하자</p><h1 id="compareTo-메서드-규약"><a href="#compareTo-메서드-규약" class="headerlink" title="compareTo 메서드 규약"></a>compareTo 메서드 규약</h1><p>이 객체와 주어진 객체의 순서를 비교한다.<br>이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 리턴한다.<br>이 객체와 비교할 수 없는 타입이 주어지면 ClassCaseException을 던진다.</p><h2 id="대칭성"><a href="#대칭성" class="headerlink" title="대칭성"></a>대칭성</h2><ul><li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) &#x3D;&#x3D; (y.compareTo(x)) * (-1)을 만족해야 한다.</li><li>따라서 x.compareTo(y)가 예외를 던지는 경우, y.compareTo(x)도 예외를 던져야 한다.</li></ul><h2 id="추이성"><a href="#추이성" class="headerlink" title="추이성"></a>추이성</h2><ul><li>Comparable을 구현한 클래스는 모든 x, y, z에 대해 x.compareTo(y) &gt; 0 이고 y.compareTo(z)이면, x.compareTo(z)를 만족해야 한다.</li></ul><h2 id="반사성"><a href="#반사성" class="headerlink" title="반사성"></a>반사성</h2><ul><li>Comparable을 구현한 클래스 z는 x.compareTo(y) &#x3D;&#x3D; 0 이면, sgn(x.compareTo(z)) &#x3D;&#x3D; sgn(y.compareTo(z))를 만족해야 한다.</li></ul><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><ul><li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) &#x3D;&#x3D; 0 이면, x.equals(y)를 만족하는 것이 좋다. (권고사항은 아니다.)<br>이 권고를 지키지 않으려면, <code>주의: 이 클래스의 순서는 equals 메서드와 일관되지 않다.</code>라고 명시해 주자.</li></ul><h1 id="equals와-compareTo-차이점"><a href="#equals와-compareTo-차이점" class="headerlink" title="equals와 compareTo 차이점"></a>equals와 compareTo 차이점</h1><p>compareTo 규약 4번째의 예시로 BigDecimal 클래스가 있다.<br>new Decimal(“1.0”)과 new Decimal(“1.00”)이 있다고 할 때 두 객체를 HashSet<Decimal>에 담게 되면 size는 2개가 된다.<br>하지만 TreeSet<Decimal>에 담게 되면 size는 1개가 된다.  </p><p>왜 이런 결과가 나올까?<br>HashSet에서는 equals를 기반으로 비교하기 때문에 new Decimal(“1.0”)과 new Decimal(“1.00”)은 서로 다른 객체이다. 그렇기 때문에 size가 2개가 된다.<br>하지만 TreeSet에서는 객체에 대한 동치성 비교를 compareTo로 하기 때문에 new Decimal(“1.0”)과 new Decimal(“1.00”)의 compareTo는 0을 리턴한다.<br>따라서 같은 객체로 인식하여 size가 1개가 된다.</p><h1 id="compareTo-안티패턴"><a href="#compareTo-안티패턴" class="headerlink" title="compareTo 안티패턴"></a>compareTo 안티패턴</h1><p>compareTo 메서드에서 관계연산자 (<code>&lt;</code> 와 <code>&gt;</code>)를 사용하지 말아야 한다.<br>대신 Type.compare(T t1, T t2)를 사용하여 비교하는 것이 좋다.</p><p>안티 패턴 코드</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; y ? <span class="number">1</span> : (x == y) ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hashcode의 차를 이용한 비교는 안된다. (추이성에 위배된다.)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;() &#123;</span><br><span class="line">  (Object o1, Object o2) -&gt; o1.hashCode() - o2.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드 처럼 실행하면, 정수 overflow를 일으키거나 IEEE754 부동소수점 계산방식에 따른 오류를 발생 시킬 수 있다.<br>따라서 아래 코드로 고쳐서 사용하는 것이 좋다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;() &#123;</span><br><span class="line">  (Object o1, Object o2) -&gt; Integer.compare(o1.hashCode(), o2.hashCode())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());</span><br></pre></td></tr></table></figure><h1 id="사용-예제"><a href="#사용-예제" class="headerlink" title="사용 예제"></a>사용 예제</h1><h2 id="기본-타입-필드가-여러-개-일때-비교자"><a href="#기본-타입-필드가-여러-개-일때-비교자" class="headerlink" title="기본 타입 필드가 여러 개 일때 비교자"></a>기본 타입 필드가 여러 개 일때 비교자</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PhoneNumber pn)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Short.compare(<span class="built_in">this</span>.areaCode, pn.areaCode);</span><br><span class="line">  <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">    result = Short.compare(<span class="built_in">this</span>.prefix, pn.prefix);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">      result = Short.compare(<span class="built_in">this</span>.line</span><br><span class="line">      Num, pn.lineNum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>필드의 정렬 우선순위를 정해 같은 값이 있을 때 마다 조건을 추가한다.</p><h2 id="비교자-생성-메서드를-이용한-비교자"><a href="#비교자-생성-메서드를-이용한-비교자" class="headerlink" title="비교자 생성 메서드를 이용한 비교자"></a>비교자 생성 메서드를 이용한 비교자</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR </span><br><span class="line">                        = comparingInt((PhoneNumber pn) -&gt; pn.areaCode)  </span><br><span class="line">                                      .thenComparingInt(pn -&gt; pn.prefix)  </span><br><span class="line">                                      .thenComparingInt(pn -&gt; pn.lineNum)</span><br></pre></td></tr></table></figure><p>comparingInt라는 static 메서드를 import하여 사용하고, 2번째 조건 부터 thenComparingInt를 사용하여 비교자를 추가 할 수 있다.<br>최초 사용 시, PhoneNumber pn을 사용하여 람다식에서 타입을 추론 할 수 있도록 코드를 추가 하였다.<br>thenComparingInt부터는 자바 컴파일러가 충분히 타입을 추론 할 수 있으므로 명시적으로 지정하지 않았다.<br>Long타입과 Double타입에 대해서는 각각 comparingLong, thenComparingLong과 comparingDouble, thenComparingDouble이 별도로 있다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 14. Comparable을 구현할지 고려하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shallow Copy와 Deep Copy</title>
      <link href="/2019/01/13/java-object-copy/"/>
      <url>/2019/01/13/java-object-copy/</url>
      
        <content type="html"><![CDATA[<h1 id="객체의-복사-Copy"><a href="#객체의-복사-Copy" class="headerlink" title="객체의 복사(Copy)"></a>객체의 복사(Copy)</h1><p>객체 지향 프로그래밍에서 객체를 복사하는 방법은 크게 두가지로 나뉜다.<br>얇은 복사(Shallow Copy)와 깊은 복사(Deep Copy)가 있다.<br>두가지 개념 모두 원본 객체를 바탕으로 새로운 객체를 만들어 낸다는 점에서는 같지만 미묘한 차이가 있다.</p><p>설명을 진행하기 전에 아래와 같은 Interface를 구현한 객체에 대해 copy가 진행된다고 가정하겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Copyable</span>&lt;T&gt; &#123;</span><br><span class="line">   T <span class="title function_">shallowCopy</span><span class="params">(T t)</span>;</span><br><span class="line">   T <span class="title function_">deepCopy</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./clone.jpg" alt="clone"></p><h1 id="Shallow-Copy"><a href="#Shallow-Copy" class="headerlink" title="Shallow Copy"></a>Shallow Copy</h1><p>Shallow copy란 원본 객체를 바탕으로 새로운 객체를 생성한 뒤, 내부 필드의 참조에 대해서는 원본 객체와 같은 필드의 참조를 바라보는 형태이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">implements</span> <span class="title class_">Copyable</span>&lt;Menu&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> Recipe recipe;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Menu <span class="title function_">shallowCopy</span><span class="params">(Menu menu)</span> &#123;</span><br><span class="line">    <span class="type">Menu</span> <span class="variable">copyMenu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(menu.getName(), menu.getPrice(), menu.getRecipe());</span><br><span class="line">    <span class="keyword">return</span> copyMenu;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>불변 객체에 대해서는 같은 객체를 공유한다는 점에서 메모리에 대한 비용을 아낄 수 있다는 장점이 있고, deep copy보다는 빠르다.</p><p>하지만, 가변 객체에 대해서는 원본 객체의 Recipe 객체가 변경되는 경우 의도치 않게 복사한 Recipe도 변경되는 경우가 발생한다.<br>이런 경우에는 Deep Copy를 통해 완전히 분리를 시켜줘야 한다.</p><h1 id="Deep-Copy"><a href="#Deep-Copy" class="headerlink" title="Deep Copy"></a>Deep Copy</h1><p>Deep Copy 원본 객체의 타입을 바탕으로 새로운 객체를 생성한 뒤, 내부 필드가 참조하는 객체에 대해서도 새로운 객체를 만들어 주는 방식이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">implements</span> <span class="title class_">Copyable</span>&lt;Menu&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> Recipe recipe;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Menu <span class="title function_">deepCopy</span><span class="params">(Menu menu)</span> &#123;</span><br><span class="line">    <span class="type">Menu</span> <span class="variable">copyMenu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>();</span><br><span class="line">    copyMenu.setName(<span class="keyword">new</span> <span class="title class_">String</span>(menu.getName));</span><br><span class="line">    copyMenu.setPrice(menu.getPrice());</span><br><span class="line">    copyMenu.setRecipe(Recipe.deepCopy(menu.getRecipe));</span><br><span class="line">    <span class="keyword">return</span> copyMenu;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 필드에 대해 원본객체와 같은 reference를 사용하는 것이 아닌 필드의 reference에 대해서도 새로운 객체를 생성하여 복사하는 방식이다.  </p><p>이런 경우 가변객체에 대한 변경에는 안전하다는 장점이 있다.<br>서로 다른 객체를 다루기 떄문에 안전하다.  </p><p>하지만 객체 생성 비용이 shallow copy보다 비싸고 상대적으로 느리며,<br>copy하는 객체 수가 많을 수록 메모리를 많이 점유하게 된다는 단점이 있다.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 13. Clone 재정의는 주의해서 진행하라</title>
      <link href="/2019/01/13/effective-java-item13/"/>
      <url>/2019/01/13/effective-java-item13/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Cloneable은 복제해도 되는 인터페이스 임을 명시하는 용도의 믹스인 인터페이스이다.<br>하지만 아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라는데 있다. 그래서 Cloneable을 구현하는 것만으로는 외부에서 clone 메서드를 호출 할 수 없다.</p><h1 id="Cloneable-인터페이스는-무슨일을-할까"><a href="#Cloneable-인터페이스는-무슨일을-할까" class="headerlink" title="Cloneable 인터페이스는 무슨일을 할까?"></a>Cloneable 인터페이스는 무슨일을 할까?</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to</span></span><br><span class="line"><span class="comment"> * indicate to the &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; method that it</span></span><br><span class="line"><span class="comment"> * is legal for that method to make a</span></span><br><span class="line"><span class="comment"> * field-for-field copy of instances of that class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Invoking Object&#x27;s clone method on an instance that does not implement the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, classes that implement this interface should override</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Object.clone&#125; (which is protected) with a public method.</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; for details on overriding this</span></span><br><span class="line"><span class="comment"> * method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &#123;<span class="doctag">@code</span> clone&#125; method.</span></span><br><span class="line"><span class="comment"> * Therefore, it is not possible to clone an object merely by virtue of the</span></span><br><span class="line"><span class="comment"> * fact that it implements this interface.  Even if the clone method is invoked</span></span><br><span class="line"><span class="comment"> * reflectively, there is no guarantee that it will succeed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#clone()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자바의 Cloneable 인터페이스를 보면 아무런 메서드도 없다.<br>아무것도 없지만, 사실은 Object의 clone메서드의 동작방식을 결정한다.<br>Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면, 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면, <code>ClassNotSupportedException</code>을 던진다.</p><h1 id="Object-클래스의-clone-규약"><a href="#Object-클래스의-clone-규약" class="headerlink" title="Object 클래스의 clone 규약"></a>Object 클래스의 clone 규약</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns a copy of this object.  The precise meaning</span></span><br><span class="line"><span class="comment"> * of &quot;copy&quot; may depend on the class of the object. The general</span></span><br><span class="line"><span class="comment"> * intent is that, for any object &#123;<span class="doctag">@code</span> x&#125;, the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be true, and that the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, but these are not absolute requirements.</span></span><br><span class="line"><span class="comment"> * While it is typically the case that:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the returned object should be obtained by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> super.clone&#125;.  If a class and all of its superclasses (except</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Object&#125;) obey this convention, it will be the case that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> x.clone().getClass() == x.getClass()&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment"> * of this object (which is being cloned).  To achieve this independence,</span></span><br><span class="line"><span class="comment"> * it may be necessary to modify one or more fields of the object returned</span></span><br><span class="line"><span class="comment"> * by &#123;<span class="doctag">@code</span> super.clone&#125; before returning it.  Typically, this means</span></span><br><span class="line"><span class="comment"> * copying any mutable objects that comprise the internal &quot;deep structure&quot;</span></span><br><span class="line"><span class="comment"> * of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment"> * objects with references to the copies.  If a class contains only</span></span><br><span class="line"><span class="comment"> * primitive fields or references to immutable objects, then it is usually</span></span><br><span class="line"><span class="comment"> * the case that no fields in the object returned by &#123;<span class="doctag">@code</span> super.clone&#125;</span></span><br><span class="line"><span class="comment"> * need to be modified.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The method &#123;<span class="doctag">@code</span> clone&#125; for class &#123;<span class="doctag">@code</span> Object&#125; performs a</span></span><br><span class="line"><span class="comment"> * specific cloning operation. First, if the class of this object does</span></span><br><span class="line"><span class="comment"> * not implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125;, then a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> CloneNotSupportedException&#125; is thrown. Note that all arrays</span></span><br><span class="line"><span class="comment"> * are considered to implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125; and that</span></span><br><span class="line"><span class="comment"> * the return type of the &#123;<span class="doctag">@code</span> clone&#125; method of an array type &#123;<span class="doctag">@code</span> T[]&#125;</span></span><br><span class="line"><span class="comment"> * is &#123;<span class="doctag">@code</span> T[]&#125; where T is any reference or primitive type.</span></span><br><span class="line"><span class="comment"> * Otherwise, this method creates a new instance of the class of this</span></span><br><span class="line"><span class="comment"> * object and initializes all its fields with exactly the contents of</span></span><br><span class="line"><span class="comment"> * the corresponding fields of this object, as if by assignment; the</span></span><br><span class="line"><span class="comment"> * contents of the fields are not themselves cloned. Thus, this method</span></span><br><span class="line"><span class="comment"> * performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The class &#123;<span class="doctag">@code</span> Object&#125; does not itself implement the interface</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Cloneable&#125;, so calling the &#123;<span class="doctag">@code</span> clone&#125; method on an object</span></span><br><span class="line"><span class="comment"> * whose class is &#123;<span class="doctag">@code</span> Object&#125; will result in throwing an</span></span><br><span class="line"><span class="comment"> * exception at run time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>     a clone of this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  CloneNotSupportedException  if the object&#x27;s class does not</span></span><br><span class="line"><span class="comment"> *               support the &#123;<span class="doctag">@code</span> Cloneable&#125; interface. Subclasses</span></span><br><span class="line"><span class="comment"> *               that override the &#123;<span class="doctag">@code</span> clone&#125; method can also</span></span><br><span class="line"><span class="comment"> *               throw this exception to indicate that an instance cannot</span></span><br><span class="line"><span class="comment"> *               be cloned.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Cloneable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure><p>Object에 명시된 clone 규약이 주석으로 쓰여져 있다.</p><ul><li>x.clone() !&#x3D; x은 참이다.<br>복사한 객체와 원본 객체는 서로 다른 객체이다.</li><li>x.clone() .getClass() &#x3D;&#x3D; x.getClass()은 일반적으로 참이다.<br>하지만 반드시 만족해야 하는 것은 아니다.</li><li>x.clone.equals(x) 은 참이다.<br>복사한 객체와 원본객체는 논리적 동치성이 같다.</li><li>x.clone().getClass() &#x3D;&#x3D; x.getClass()은 참이다.<br>관례상, 이 방법으로 반환된 객체는 독립성이 있어야 한다.<br>이를 만족하려면 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.</li><li>Cloneable을 구현하지 않은 클래스의 경우, CloneNotSupportedException이 throw된다.</li><li>모든 Array는 Cloneable을 구현하도록 고려되었다. clone 메서드는 T[]를 리턴하도록 설계</li><li>T는 기본타입 또는 참조타입으로 설계</li><li>기본적으로 Object.clone은 clone대상 클래스에 대해 새로운 객체를 new로 생성</li><li>모든 필드들에 대해 초기화를 진행</li><li>하지만 필드에 대한 객체를 다시 생성하지 않는 Shallow copy 방식으로 수행한다 (deep copy아님)</li><li>클래스에 대한 복제본을 원하지 않는 경우 clone메서드를 재정의하여 CloneNotSupportedException을 throw하도록 함</li></ul><h1 id="clone-메서드-재정의-시-주의할-점"><a href="#clone-메서드-재정의-시-주의할-점" class="headerlink" title="clone 메서드 재정의 시, 주의할 점"></a>clone 메서드 재정의 시, 주의할 점</h1><h2 id="기본적인-clone메서드-재정의"><a href="#기본적인-clone메서드-재정의" class="headerlink" title="기본적인 clone메서드 재정의"></a>기본적인 clone메서드 재정의</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> PhoneNumber <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (PhoneNumber) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ClassNotSupportedException e) &#123;</span><br><span class="line">      <span class="comment">//아무처리를 하지 않거나, RuntimeException으로 감싸는 것이 사용하기 편하다.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>super.clone()을 실행하면 PhoneNumber에 대한 완벽한 복제가 이루어진다.</li><li>super.clone()의 리턴 타입은 Object이지만, 자바의 공변 반환타이핑 기능을 통해 PhoneNumber 타입으로 캐스팅하여 리턴하는 것이 가능하다.<br>(추천하는 기능)</li><li>try-catch 부분으로 감싼것은 super.clone() 메서드에서 ClassNotSupportedException이라는 checked exception을 리턴하기 떄문에 처리 해주었다. <ul><li>하지만 PhoneNumber가 Cloneable을 구현하기 떄문에 절대 실패하지 않는다.<br>따라서 이부분은 RuntimeException으로 처리하거나, 아무것도 설정하지 않아야 한다.</li></ul></li></ul><h2 id="가변-상태를-갖는-필드에-대한-복제"><a href="#가변-상태를-갖는-필드에-대한-복제" class="headerlink" title="가변 상태를 갖는 필드에 대한 복제"></a>가변 상태를 갖는 필드에 대한 복제</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object[] elements;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object o)</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Stack <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Stack</span> <span class="variable">result</span> <span class="operator">=</span> (Stack) <span class="built_in">super</span>.clone();</span><br><span class="line">      result.elements = </span><br><span class="line">    &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 클래스가 단순히 clone메서드를 이용해 super.clone()만 실행하게 된다면,<br>new Stack()을 통해 새로운 객체가 생성되고 필드모두 원본 객체와 동일하게 초기화가 될 것이다.<br>하지만, 위에서 얘기한 Object의 clone 기본규약에는 Deep copy가 아닌 Shallow Copy를 이용해 초기화를 진행한다고 적혀있다.<br>따라서 배열과 같은 가변필드는 원본 필드와 객체를 공유하게 된다. </p><p>Clone메서드는 사실상 생성자와 같은 효과를 낸다.<br>즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.<br>그렇기 때문에 제대로 복제하기 위해서는, elements라는 배열을 똑같이 복사해서 만들어줘야 한다.</p><h2 id="배열-복사"><a href="#배열-복사" class="headerlink" title="배열 복사"></a>배열 복사</h2><p>배열을 복제하는 방법 중 가장 권장하는 방법은<br>array.clone()을 이용해 복사하는 방법이다.<br>사실, 배열은 clone기능을 가장 제대로 사용하는 유일한 예이다.</p><p>하지만, array 필드가 final이 적용되어 있다면 array.clone()을 통한 초기화는 할 수 없다. (final이기 떄문에 객체 생성 이후 초기화 불가)<br><strong>Cloneable 아키텍처는 가변객체를 참조하는 필드는 final로 선언하라 라는 일반 용법과 충돌한다.</strong><br>그래서 복제 할 수 있는 클래스를 만들기 위해 일부 필드에서 final 한정자를 제거해야 할 수도 있다.</p><h2 id="Stack-overflow-문제"><a href="#Stack-overflow-문제" class="headerlink" title="Stack overflow 문제"></a>Stack overflow 문제</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTable</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>  &#123;</span><br><span class="line">  <span class="keyword">private</span> Entry[] buckets = ...;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object key;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry next;</span><br><span class="line"></span><br><span class="line">    Entry(Object key, Object value, Entry next) &#123;</span><br><span class="line">      <span class="built_in">this</span>.key = key;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line">      <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> HashTable <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">HashTable</span> <span class="variable">result</span> <span class="operator">=</span> (HashTable) <span class="built_in">super</span>.clone();</span><br><span class="line">      result.buckets = buckets.clone();</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Assertion</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>복제본은 자신만의 버킷 배열은 갖지만, 배열내의 Entry는 원본과 같은 연결리스트를 참조하여, 불변성이 꺠지게 된다.</p><p>그래서 HashTable.Entry 클래스는 내부적으로 deep copy를 지원하도록 보강되었다. 연결리스트에 대한 next를 복제할 때 재귀적으로 clone을 호출하도록 되어있는데, 재귀 호출 떄문에 연결리스트의 size만큼 스택프레임을 소비하여, 리스트가 길면 stackoverflow에러를 발생시킬 위험이 있다.<br>이 문제를 해결하기 위해서는 재귀 호출을 통한 deepcopy대신 반복자를 써서 순회하는 방법으로 수정해야 한다.</p><h2 id="안전하지만-느린-copy"><a href="#안전하지만-느린-copy" class="headerlink" title="안전하지만 느린 copy"></a>안전하지만 느린 copy</h2><p>HashTable을 예로 들면, buckets필드를 새로운 배열로 초기화 한다음 원본테이블의 있는 버킷의 내용을 put(key, value) 메서드를 호출해<br>새로 버킷을 만드는 방법이 있다.<br>이 방법은 안전하긴 하지만, low level에서 작동하는 copy보다는 느리다.</p><h2 id="생성자-내에서는-재정의-될-수-있는-메서드를-호출-하지-말자"><a href="#생성자-내에서는-재정의-될-수-있는-메서드를-호출-하지-말자" class="headerlink" title="생성자 내에서는 재정의 될 수 있는 메서드를 호출 하지 말자"></a>생성자 내에서는 재정의 될 수 있는 메서드를 호출 하지 말자</h2><p>만약 clone이 하위 클래스에서 재정의한 메서드를 호출하면, 하위 클래스는 복사과정에서 자신의 상태를 교정할 기회를 잃게되어<br>원본과 복제본의 상태가 달라질 수 있다.</p><h2 id="ClassNotSupportedException"><a href="#ClassNotSupportedException" class="headerlink" title="ClassNotSupportedException"></a>ClassNotSupportedException</h2><p>Object의 clone메서드는 CloneNotSupportedException을 던진다고 선언했지만 재정의한 메서드는 그렇지 않다.<br>public인 clone 메서드에서는 throws절을 없애던가, RuntimeException으로 throws 해야한다.<br>그렇지 않으면 clone 메서드를 호출 할 떄마다, 예외처리를 해야 해서 사용하기가 불편하다.</p><p>하위 클래스에서 Clone을 방지하기 위해 동작하지 않게 만들수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CloneNotSupportedException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="스레드-안전성을-고려한다면-적절히-동기화해야-한다"><a href="#스레드-안전성을-고려한다면-적절히-동기화해야-한다" class="headerlink" title="스레드 안전성을 고려한다면 적절히 동기화해야 한다."></a>스레드 안전성을 고려한다면 적절히 동기화해야 한다.</h2><p>스레드 안정성을 고려한다면 clone 메서드에 대해 적절히 동기화 처리 해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">super</span>.clone();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="복사-생성자와-복사-팩터리-메서드"><a href="#복사-생성자와-복사-팩터리-메서드" class="headerlink" title="복사 생성자와 복사 팩터리 메서드"></a>복사 생성자와 복사 팩터리 메서드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Yum</span><span class="params">(Yum yum)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Yum <span class="title function_">newInstance</span><span class="params">(Yum yum)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>복사 생성자와 복사 팩터리 메서드는 Cloneable&#x2F;clone 방식보다 나은 면이 많다. </p><ul><li>언어 모순적이고 위험한 객체 생성 메커니즘을 사용하지 않는다. (super.clone())</li><li>clone 규약에 기대지 않는다.</li><li>정상적인 final필드 용법과도 충돌하지 않는다.</li><li>불필요한 check exception 처리가 필요없다.</li><li>형변환도 필요없다.</li><li>복사 생성자와 복사 팩터리는 인터페이스 타입의 인스턴스를 인수로 받을 수 있다.</li></ul><h1 id="Deep-copy-vs-Shallow-copy"><a href="#Deep-copy-vs-Shallow-copy" class="headerlink" title="Deep copy vs Shallow copy"></a>Deep copy vs Shallow copy</h1><p><a href="http://localhost:4000/2019/01/13/java-object-copy">Shallow Copy와 Deep Copy</a> - 이 포스팅을 참고하자</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 13. clone 재정의는 주의해서 진행하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 12. toString을 항상 재정의하라</title>
      <link href="/2019/01/13/effective-java-item12/"/>
      <url>/2019/01/13/effective-java-item12/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Object의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.<br>이 메서드는 <code>PhoneNumber@adbbd</code>처럼 단순히 <strong>클래스이름@16진수로_표현한_해시코드</strong>를 반환할 뿐이다.<br>toString의 일반 규약에 따르면, <code>간결하면서 사람이 읽기 쉬운 형태의 유익한 정보</code>를 반환해야 한다.<br>toString의 규악은 <code>모든 하위클래스에서 이 메서드를 재정의하라</code>라고 하고 있다.</p><h1 id="toString을-재정의-해야하는-이유"><a href="#toString을-재정의-해야하는-이유" class="headerlink" title="toString을 재정의 해야하는 이유"></a>toString을 재정의 해야하는 이유</h1><ul><li>toString을 잘 구현한 클래스는 사용하기 편하고, 그 클래스에 대해 디버깅 하기 쉽다.<ul><li>map객체를 출력하는 경우 <code>&#123;Jenny=PhoneNumber@addbb&#125;</code> 보다는 <code>&#123;Jenney=707-867-5308&#125;</code>이라는 메세지가 가독서이 좋다.</li></ul></li><li>실전에서는 toString메서드를 재작성 할 때, 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.</li><li>toString을 구현할 때면 반환값의 포맷을 문서화 할 지 정해야 한다.<ul><li>포맷을 명시하면, 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다.</li><li>포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</li><li>단, 포맷을 한번 명시하면, 평생 그 포맷에 얽매이게 된다.</li><li>포맷을 명시하지 않는다면 다음 릴리즈에 포맷을 변경할 수 있는 유연성을 더 가져갈 수 있다.</li></ul></li><li>포맷을 명시하든 아니든, 개발자의 의도는 명확히 밝혀야 한다.</li><li>toString이 반환한 값에 대해 포함된 정보를 얻어올 수 있는 API를 제공하자<ul><li>toString에 있는 getter를 제공하지 않는다면, 클라이언트에서 toString을 파싱하여 사용할 지도 모른다.</li></ul></li></ul><h2 id="포맷을-명시하기로-했으면-명시한-포맷에-맞는-문자열과-객체를-상호전환-할-수-있는-정적-팩터리나-생성자를-함께-제공하면-좋다"><a href="#포맷을-명시하기로-했으면-명시한-포맷에-맞는-문자열과-객체를-상호전환-할-수-있는-정적-팩터리나-생성자를-함께-제공하면-좋다" class="headerlink" title="포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다."></a>포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RunWith(JUnit4.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> toString테스트() &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> <span class="string">&quot;707-908-9999&quot;</span>;</span><br><span class="line">        assertEquals(PhoneNumber.parse(phoneNumber), <span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="number">707</span>, <span class="number">908</span>, <span class="number">9999</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(expected = UnknownFormatConversionException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 파싱문자열_오류_테스트() &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> <span class="string">&quot;707-908&quot;</span>;</span><br><span class="line">        assertEquals(PhoneNumber.parse(phoneNumber), <span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="number">707</span>, <span class="number">908</span>, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PhoneNumber</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer areaCode;</span><br><span class="line">        <span class="keyword">private</span> Integer prefix;</span><br><span class="line">        <span class="keyword">private</span> Integer lineNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">phoneNumberPattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;4&#125;$&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">PhoneNumber</span> <span class="variable">pn</span> <span class="operator">=</span> (PhoneNumber) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.areaCode.equals(pn.areaCode)</span><br><span class="line">                    &amp;&amp; <span class="built_in">this</span>.prefix.equals(pn.prefix)</span><br><span class="line">                    &amp;&amp; <span class="built_in">this</span>.lineNum.equals(pn.lineNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.hashCode(areaCode);</span><br><span class="line">            result = <span class="number">31</span> * result + Integer.hashCode(prefix);</span><br><span class="line">            result = <span class="number">31</span> * result + Integer.hashCode(lineNum);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%03d-%03d-%04d&quot;</span>, areaCode, prefix, lineNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> PhoneNumber <span class="title function_">parse</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!phoneNumberPattern.matcher(phoneNumber).find()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnknownFormatConversionException</span>(phoneNumber + <span class="string">&quot; cannot be parsed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] numbers = phoneNumber.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> PhoneNumber.builder()</span><br><span class="line">                    .areaCode(Integer.parseInt(numbers[<span class="number">0</span>]))</span><br><span class="line">                    .prefix(Integer.parseInt(numbers[<span class="number">1</span>]))</span><br><span class="line">                    .lineNum(Integer.parseInt(numbers[<span class="number">2</span>]))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="toString을-따로-재정의-안해도-되는-경우"><a href="#toString을-따로-재정의-안해도-되는-경우" class="headerlink" title="toString을 따로 재정의 안해도 되는 경우"></a>toString을 따로 재정의 안해도 되는 경우</h1><ul><li>정적 Utils 클래스는 따로 재정의 하지 않아도 된다.<br>(객체의 상태(state)를 가지는 클래스가 아니기 떄문)</li><li>enum 타입 또한 이미 완벽한 toString을 제공한다.</li><li>대다수의 컬렉션 구현체는 추상 컬렉션 클래스(AbstractMap, AbstractSet등)의 toString 메서드를 상속하여 쓴다.</li><li>라이브러리를 통해 자동생성하자<ul><li>구글의 @Autovalue</li><li>Lombok의 @ToString</li><li>위의 라이브러리들을 이용해 자동생성하는 편이 더 간편하다.</li></ul></li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 12. toString을 항상 재정의하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 11. Equals를 재정의하려거든 Hashcode도 재정의하라</title>
      <link href="/2019/01/12/effective-java-item11/"/>
      <url>/2019/01/12/effective-java-item11/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p><code>equals를 재정의한 클래스에서는 hashcode도 재정의 해야한다.</code><br>그렇지 않으면 hash를 사용하는 HashMap, HashSet과 같은 컬렉션의 원소로 사용될 때 문제가 발생할 것이다.</p><p>이번 글을 읽기 전에 아래 글을 먼저 읽어 해시, 해시테이블에 대한 용어를 먼저 익히는 것이 도움이 될 것 같다.</p><ul><li><a href="http://bcho.tistory.com/1072">해쉬 테이블의 이해와 구현 (Hashtable) - 조대협의 블로그</a></li><li><a href="https://d2.naver.com/helloworld/831311">Java HashMap은 어떻게 동작하는가? - Naver D2</a></li></ul><h1 id="hashcode의-규약"><a href="#hashcode의-규약" class="headerlink" title="hashcode의 규약"></a>hashcode의 규약</h1><ul><li>equals비교에 사용되는 정보가 변경되지 않았다면, 객체의 hashcode 메서드는 몇번을 호출해도 항상 일관된 값을 반환해야 한다.<br>(단, Application을 다시 실행한다면 값이 달라져도 상관없다. (메모리 소가 달라지기 때문))</li><li>equals메서드 통해 두 개의 객체가 같다고 판단했다면, 두 객체는 똑같은 hashcode 값을 반환해야 한다.</li><li>equals메서드가 두 개의 객체를 다르다고 판단했다 하더라도, 두 객체의 hashcode가 서로 다른 값을 가질 필요는 없다. (Hash Collision)<br>단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.</li></ul><h1 id="equals-메서드는-재정의했지만-hashcode를-재정의하지-않은-경우"><a href="#equals-메서드는-재정의했지만-hashcode를-재정의하지-않은-경우" class="headerlink" title="equals 메서드는 재정의했지만, hashcode를 재정의하지 않은 경우"></a>equals 메서드는 재정의했지만, hashcode를 재정의하지 않은 경우</h1><p>hashcode의 규약 2번째 조건을 위반하는 행위이다.<br>Effective Java 11장에서 설명하는 PhoneNumber 클래스를 생성해 테스트 해 보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(JUnit4.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashCodeTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hashcode_재정의() &#123;</span><br><span class="line">        HashMap&lt;ExtendedPhoneNumber, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>), <span class="string">&quot;제니&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 1 hashcode : &quot;</span> + <span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 2 hashcode : &quot;</span> + <span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        Assert.assertEquals(map.get(<span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>)), <span class="string">&quot;제니&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hashcode_재정의안함() &#123;</span><br><span class="line">        HashMap&lt;PhoneNumber, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>), <span class="string">&quot;제니&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 1 hashcode : &quot;</span> + <span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 2 hashcode : &quot;</span> + <span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        Assert.assertNotEquals(map.get(<span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>)), <span class="string">&quot;제니&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> firstNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> secondNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> thirdNumber;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">PhoneNumber</span> <span class="variable">p</span> <span class="operator">=</span> (PhoneNumber) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.firstNumber == p.firstNumber &amp;&amp;</span><br><span class="line">                    <span class="built_in">this</span>.secondNumber == p.secondNumber &amp;&amp;</span><br><span class="line">                    <span class="built_in">this</span>.thirdNumber == p.thirdNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ExtendedPhoneNumber</span> <span class="keyword">extends</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ExtendedPhoneNumber</span><span class="params">(<span class="type">int</span> firstNumber, <span class="type">int</span> secondNumber, <span class="type">int</span> thirdNumber)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(firstNumber, secondNumber, thirdNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hashcode</span> <span class="operator">=</span> Integer.hashCode(firstNumber);</span><br><span class="line">            hashcode = c * hashcode + Integer.hashCode(secondNumber);</span><br><span class="line">            hashcode = c * hashcode + Integer.hashCode(thirdNumber);</span><br><span class="line">            <span class="keyword">return</span> hashcode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Test-1-hashcode를-재정의-하지-않은-경우"><a href="#Test-1-hashcode를-재정의-하지-않은-경우" class="headerlink" title="Test.1 hashcode를 재정의 하지 않은 경우"></a>Test.1 hashcode를 재정의 하지 않은 경우</h2><p>PhoneNumber 클래스에서는 객체 동치성 체크를 위해 equals메서드를 재정의했다. <strong>하지만 hashcode 메서드는 재정의 하지 않았다.</strong><br>new를 통해 새로운 객체를 만들 때마다 늘 다른 hashcode를 리턴하여, 실제 HashMap에 key로 PhoneNumber클래스를 삽입하더라도<br>hashcode가 다르기 때문에 다른 버킷에가서 데이터를 조회 하려고해서 결과적으로 null이 나와 기댓값인 <code>&quot;제니&quot;</code>를 만족하지 못했다. </p><p>실제 로그를 찍어보니</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instance 1 hashcode : 1686369710</span><br><span class="line">Instance 2 hashcode : 194706439</span><br></pre></td></tr></table></figure><p>두 개의 다른 객체에 대해 다른 hashcode를 리턴하고 있었다.</p><h2 id="Test-2-hashcode를-재정의-한-경우"><a href="#Test-2-hashcode를-재정의-한-경우" class="headerlink" title="Test.2 hashcode를 재정의 한 경우"></a>Test.2 hashcode를 재정의 한 경우</h2><p>ExtendPhoneNumber 클래스에서는 PhoneNumber를 상속 받은 뒤, hashCode 메서드를 재정의하였다.<br>(equals메서드는 PhoneNumber의 equals를 그대로 사용하였다.) </p><p>실제 로그를 찍어보니</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instance 1 hashcode : 711611</span><br><span class="line">Instance 2 hashcode : 711611</span><br></pre></td></tr></table></figure><p>두 개의 ExtendPhoneNumber 객체에 대해 같은 hashcode를 리턴하고 있었다.<br>그렇기 때문에 HashMap에 삽입한 ExtendPhoneNumber 객체에 대해 new ExtendPhoneNumber()로 조회를 하니 같은 hashCode의 버킷을 조회하여<br><code>&quot;제니&quot;</code>라는 데이터를 얻어올 수 있었다.</p><h1 id="최악의-hashcode-구현"><a href="#최악의-hashcode-구현" class="headerlink" title="최악의 hashcode 구현"></a>최악의 hashcode 구현</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하니 적법한 해시코드 처럼 보인다.<br>하지만, 모든 객체에 대해 똑같은 해시코드를 반환하니 모든 객체가 같은 해시테이블 버킷에 담겨 연결리스트(Linked List)처럼 동작하게 된다.<br>평균 수행시간이 O(1)에서 O(n)으로 느려져서, 성능이 매우 낮아질 뿐더러 버킷에 대한 overflow가 발생하는 경우 데이터가 누락될 수도 있다.</p><h2 id="hashcode가-같으면-HashMap에서-어떻게-동작할까"><a href="#hashcode가-같으면-HashMap에서-어떻게-동작할까" class="headerlink" title="hashcode가 같으면 HashMap에서 어떻게 동작할까?"></a>hashcode가 같으면 HashMap에서 어떻게 동작할까?</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(JUnit4.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashCodeTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hashcode_재정의() &#123;</span><br><span class="line">        HashMap&lt;ExtendedPhoneNumber, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>), <span class="string">&quot;제니&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 1 hashcode : &quot;</span> + <span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 2 hashcode : &quot;</span> + <span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5301</span>).hashCode());</span><br><span class="line">        <span class="comment">//다른 객체를 넣어 데이터를 조회해 보았다.</span></span><br><span class="line">        Assert.assertEquals(map.get(<span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5301</span>)), <span class="string">&quot;제니&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> firstNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> secondNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> thirdNumber;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">PhoneNumber</span> <span class="variable">p</span> <span class="operator">=</span> (PhoneNumber) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.firstNumber == p.firstNumber &amp;&amp;</span><br><span class="line">                    <span class="built_in">this</span>.secondNumber == p.secondNumber &amp;&amp;</span><br><span class="line">                    <span class="built_in">this</span>.thirdNumber == p.thirdNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ExtendedPhoneNumber</span> <span class="keyword">extends</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ExtendedPhoneNumber</span><span class="params">(<span class="type">int</span> firstNumber, <span class="type">int</span> secondNumber, <span class="type">int</span> thirdNumber)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(firstNumber, secondNumber, thirdNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Instance 1 hashcode : 42</span><br><span class="line">Instance 2 hashcode : 42</span><br><span class="line"></span><br><span class="line">java.lang.AssertionError: </span><br><span class="line">Expected :null</span><br><span class="line">Actual   :제니</span><br><span class="line"> &lt;Click to see difference&gt;</span><br></pre></td></tr></table></figure><p>이 결과로 보아하니, hashcode가 같으면 같은 버킷에 LinkedList로 저장되면서 객체에 대해 equals 체크를 통해 데이터를 조회하는 것으로 판단 된다.</p><blockquote><p>설사 두 인스턴스가 같은 버킷에 담았더라도, hashmap.get메서드는 null을 반환한다.<br>만약 hashcode가 다른경우에는 동치성비교를 실행하지 않도록 최적화 되어있기 때문이다.<br>hashcode가 같더라도 동치성비교(equals)를 실행하여 객체에 대한 값(value)를 조회한다.</p></blockquote><h1 id="좋은-해시-함수-만들기"><a href="#좋은-해시-함수-만들기" class="headerlink" title="좋은 해시 함수 만들기"></a>좋은 해시 함수 만들기</h1><p>좋은 해시 함수는 서로 다른 인스턴스에 대해 다른 해시코드를 반환한다.<br>이게 바로 hashcode의 세번째 규약이 요구하는 속성이다.<br>이상적인 해시 함수는 주어진 (서로 다른) 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="comment">//1. int변수 result를 선언한 후 첫번째 핵심 필드에 대한 hashcode로 초기화 한다.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.hashCode(firstNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 기본타입 필드라면 Type.hashCode()를 실행한다</span></span><br><span class="line">    <span class="comment">//Type은 기본타입의 Boxing 클래스이다.</span></span><br><span class="line">    result = c * result + Integer.hashCode(secondNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 참조타입이라면 참조타입에 대한 hashcode 함수를 호출 한다.</span></span><br><span class="line">    <span class="comment">//4. 값이 null이면 0을 더해 준다.</span></span><br><span class="line">    result = c * result + address == <span class="literal">null</span> ? <span class="number">0</span> : address.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 필드가 배열이라면 핵심 원소를 각각 필드처럼 다룬다.</span></span><br><span class="line">    <span class="keyword">for</span> (String elem : arr) &#123;</span><br><span class="line">      result = c * result + elem == <span class="literal">null</span> ? <span class="number">0</span> : elem.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 배열의 모든 원소가 핵심필드이면 Arrays.hashCode를 이용한다.</span></span><br><span class="line">    result = c * result + Arrays.hashCode(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. result = 31 * result + c 형태로 초기화 하여 </span></span><br><span class="line">    <span class="comment">//result를 리턴한다.</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>hashcode를 다 구현했다면, 이 메서드가 동치인 인스턴스에 대해 똑같은 해시코드를 반환할지 TestCase를 작성해보자</li><li>파생필드는 hashcode 계산에서 제외해도 된다.</li><li>equals 비교에 사용되지 않는 필드는 반드시 제외한다.</li><li>31 * result를 곱하는 순서에 따라 result 값이 달라진다.</li><li>곱할 숫자를 31로 지정하는 이유는 31이 홀수 이면서 소수(prime)이기 때문이다. 2를 곱하는 것은 shift연산과 같은 결과를 내기 떄문에 추천하지 않는다.</li><li>31을 이용하면 (i &lt;&lt; 5) - i와 같이 최적화 할 수 있다.</li></ul><h1 id="hashcode를-편하게-만들어-주는-모듈"><a href="#hashcode를-편하게-만들어-주는-모듈" class="headerlink" title="hashcode를 편하게 만들어 주는 모듈"></a>hashcode를 편하게 만들어 주는 모듈</h1><ul><li>Objects.hash()<ul><li>내부적으로 AutoBoxing이 일어나 성능이 떨어진다.</li></ul></li><li>Lombok의 @EqualsAndHashCode</li><li>Google의 @AutoValue</li></ul><h1 id="hashcode를-재정의-할-때-주의-할-점"><a href="#hashcode를-재정의-할-때-주의-할-점" class="headerlink" title="hashcode를 재정의 할 때 주의 할 점!"></a>hashcode를 재정의 할 때 주의 할 점!</h1><ul><li>불변 객체에 대해서는 hashcode 생성비용이 많이 든다면, hashcode를 캐싱하는 것도 고려하자<ul><li>스레드 안전성까지 고려해야 한다.</li></ul></li><li>성능을 높인답시고 hashcode를 계산할 떄 핵심필드를 생략해서는 안된다.<ul><li>속도는 빨라지겠지만, hash품질이 나빠져 해시테이블 성능을 떨어뜨릴 수 있다 (Hashing Collision)</li></ul></li><li>hashcode 생성규칙을 API사용자에게 공표하지 말자<ul><li>그래야 클라이언트가 hashcode값에 의지한 코드를 짜지 않는다.</li><li>다음 릴리즈 시, 성능을 개선할 여지가 있다.</li></ul></li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 11. equals를 재정의하려거든 hashcode도 재정의하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 10. Equals는 일반 규약을 지켜 재정의하라</title>
      <link href="/2019/01/10/effective-java-item10/"/>
      <url>/2019/01/10/effective-java-item10/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>equals 메서드는 Object 클래스에 구현된 메서드로 객체 내의 정보들에 대한 동등성(equality) 비교를 목적으로 하는 메서드이다.<br>equals 메서드를 잘못 작성하게 되면 의도하지 않는 결과들이 초래되므로 웬만하면 변경하지 않는 것이 좋다.</p><h1 id="equals를-재정의-하지-않아도-되는-경우"><a href="#equals를-재정의-하지-않아도-되는-경우" class="headerlink" title="equals를 재정의 하지 않아도 되는 경우"></a>equals를 재정의 하지 않아도 되는 경우</h1><ul><li>각 인스턴스가 본질적으로 고유 한 경우 - 값이 아닌 동작을 표현하는 클래스의 경우 (Thread가 좋은 예이다.)</li><li>인스턴스의 논리적 동치성 (Logical Equality)를 검사할 일이 없는 경우 - <code>java.utils.regex.Pattern</code>의 equals는 내부의 정규표현식이 같은지를 검사하는 메서드이다.</li><li>상위 클래스에서 재정의한 equals가 하위 클래스에서도 적용 되는 경우 - Set, Map, List의 경우 Abstract(Type)의 equals를 쓴다.</li><li>클래스가 private이거나, package-private여서 equals를 호출할 일이 없는 경우</li><li>싱글턴을 보장하는 클래스(인스턴스 통제 클래스, Enum (열거타입)) 인 경우 - 객체 간 동등성, 동일성이 보장된다.</li></ul><h1 id="equals를-재정의-하는-경우-지켜야-할-규약"><a href="#equals를-재정의-하는-경우-지켜야-할-규약" class="headerlink" title="equals를 재정의 하는 경우 지켜야 할 규약"></a>equals를 재정의 하는 경우 지켜야 할 규약</h1><p>equals를 재정의 해야 하는 경우는 객체 동일성(식별성(Object Identity))를 확인해야 하는 경우가 아니라<br>논리적 동치성(동등성(Logical equality))를 비교 하도록 재정의 되지 않았을 경우이다.</p><h2 id="반사성-reflexivity"><a href="#반사성-reflexivity" class="headerlink" title="반사성(reflexivity)"></a>반사성(reflexivity)</h2><p><strong>null이 아닌 모든 참조 값 x에 대해 x.equals(x)를 만족해야한다.</strong><br>단순히 말하면 객체는 자기 자신과 비교했을 때 같아야 한다는 뜻이다.<br>이 조건을 만족하지 않는 예를 찾기가 더 어렵다.<br>만약 x.equals(x)가 성립하지 않는 객체라면, 컬렉션에서 contain 메서드를 사용하는 경우 방금 넣은 객체도 찾을 수 없을 것이다.</p><h2 id="대칭성-symmetry"><a href="#대칭성-symmetry" class="headerlink" title="대칭성 (symmetry)"></a>대칭성 (symmetry)</h2><p><strong>null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true이면, y.equals(x)가 true를 만족해야 한다.</strong>  </p><p>예시 코드를 보면</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CaseInsensitiveString</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String s;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CaseInsensitiveString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.s = Objects.requireNonNull(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> CaseInsensitiveString) &#123;</span><br><span class="line">      <span class="keyword">return</span> s.equalsIgnoreCase(((CaseInsensitiveString) o).s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> String) &#123; <span class="comment">//한 방향으로만 작동!!</span></span><br><span class="line">      <span class="keyword">return</span> s.equalsIgnoreCase((String) o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 클래스를 기반으로 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CaseInsensitiveString</span> <span class="variable">caseInsensitiveString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaseInsensitiveString</span>(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">System.out.println(caseInsensitiveString.equals(test)); <span class="comment">//true</span></span><br><span class="line">System.out.println(test.equals(caseInsensitiveString)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>위의 코드를 실행하게 되면, x.equals(y)가 true일 때, y.equals(x)가 false이므로 <code>대칭성</code>이 깨지는 코드가 된다.<br>String 클래스에서는 CaseInsensitiveString의 존재를 모르기 때문에 false가 날 수 밖에 없는 상황이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CaseInsensitiveString&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">CaseInsensitiveString</span>(<span class="string">&quot;Test&quot;</span>));</span><br><span class="line">System.out.println(list.contain(<span class="string">&quot;test&quot;</span>)); <span class="comment">//false or true</span></span><br></pre></td></tr></table></figure><p>위의 예제의 경우는 JDK버전에 따라 다를 수 있다. x.equals(y)로 비교할 수 도 있고, y.equals(x)로 비교될 수 있기 때문이다.</p><p>위의 내용을 수정한다면, String과의 비교는 포기해야 한다.<br>같은 CaseInsensitiveString 타입인 경우에만 비교하도록 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> o <span class="keyword">instanceof</span> CaseInsensitiveString &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="추이성-transitivity"><a href="#추이성-transitivity" class="headerlink" title="추이성 (transitivity)"></a>추이성 (transitivity)</h2><p><strong>null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y)가 true이고, y.equals(z)가 true이면 x.equals(z)도 true가 되야 한다는 조건이다.</strong></p><p>Point클래스와 ColorPoint 클래스를 가지고 예시를 들어보겠다.<br>(ColorPoint는 Point클래스를 확장(extends)한 클래스이다.)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ColorPoint</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line"><span class="type">Point</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">ColorPoint</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</span><br></pre></td></tr></table></figure><p>위와 같은 인스턴스 a, b, c가 있다.<br>이 때, a.equals(b)와 b.equals(c) 일 때, a.equals(c)<br>가 되는 과정을 살펴 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x == p.x &amp;&amp; <span class="built_in">this</span>.y == p.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="대칭성이-위배되는-case"><a href="#대칭성이-위배되는-case" class="headerlink" title="대칭성이 위배되는 case"></a>대칭성이 위배되는 case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.equals(o) &amp;&amp; <span class="built_in">this</span>.color == ((ColorPoint) o).color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 처럼 ColorPoint 클래스의 equals 메서드를 재정의 했다면… </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ColorPoint</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line"><span class="type">Point</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//false</span></span><br><span class="line">System.out.println(b.equals(a)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ol><li><p><code>a.equals(b)</code>를 보면 a는 ColorPoint이기 떄문에 ColorPoint 클래스에서 재정의 된 equals 메서드를 타게 된다.<br>이렇게 되면 첫번째 if 조건에서 걸리게 된다. b는 Point이지만 ColorPoint는 아니기 떄문이다.<br>따라서 <code>a.equals(b)</code>는 <code>false</code>가 된다.</p></li><li><p><code>b.equals(a)</code>를 보면 b는 Point클래스이기 떄문에 Point클래스의 equals메서드를 타게 된다.<br>이렇게 되면 ColorPoint는 Point클래스를 상속하고 있기 때문에 첫번째 if조건을 통과하게 되고,<br>int x, int y값을 기준으로만 비교하기 떄문에 값이 참이 된다.<br>따라서 <code>b.equals(a)</code>는 <code>true</code>가 된다.</p></li></ol><p>위의 예시는 equals 정의 규약 중 하나인 대칭성을 위반하고 있으므로 다시 작성해야 한다.</p><h3 id="추이성이-위반되는-case"><a href="#추이성이-위반되는-case" class="headerlink" title="추이성이 위반되는 case"></a>추이성이 위반되는 case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.</span></span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> o.equals(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//o가 ColorPoint이면 색상까지 비교한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.equals(o) &amp;&amp; <span class="built_in">this</span>.color == ((ColorPoint) o).color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 처럼 ColorPoint 클래스의 equals메서드를 다시 재정의 했다면..  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ColorPoint</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line"><span class="type">Point</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">ColorPoint</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</span><br><span class="line"></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//true</span></span><br><span class="line">System.out.println(b.equals(c)); <span class="comment">//true</span></span><br><span class="line">System.out.println(a.equals(c)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol><li><code>a.equals(b)</code>를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.<br>b가 Point인 경우이기 때문에 2번쨰 if 절을 타게 되어 Point의 x, y정보만 비교하게 되므로 결과는 <code>true</code>이다.</li><li><code>b.equals(c)</code>를 보면 b는 Point클래스의 인스턴스이므로 Point클래스의 equals 메서드를 실행하게 된다.<br>Point의 x, y정보만 비교하게 되므로 결과는 <code>true</code>이다.</li><li><code>a.equals(c)</code>를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.<br>하지만, c가 ColorPoint클래스의 인스턴스이므로 x, y값 뿐만아니라 color까지 비교하게되어 결과는 <code>false</code>이다.</li></ol><p>이렇게 a.equals(b)는 <code>true</code>를 만족하고 b.equals(c)는 <code>true</code>를 만족하지만 a.equals(c)는 <code>false</code>가 되므로<br>위의 코드는 equals 정의 규약 중 <code>추이성</code>을 위반하는 코드가 된다.</p><h3 id="무한-재귀-Infinite-Recursion-이-발생하는-case"><a href="#무한-재귀-Infinite-Recursion-이-발생하는-case" class="headerlink" title="무한 재귀 (Infinite Recursion)이 발생하는 case"></a>무한 재귀 (Infinite Recursion)이 발생하는 case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmellPoint</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Smell smell;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.</span></span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> SmellPoint)) <span class="keyword">return</span> o.equals(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//o가 ColorPoint이면 색상까지 비교한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.equals(o) &amp;&amp; <span class="built_in">this</span>.smell == ((SmellPoint) o).smell;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 처럼 Point를 상속받는 SmellPoint라는 클래스도 추가되었다고 가정해보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line"><span class="type">Point</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmellPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Smell.SWEET);</span><br><span class="line"></span><br><span class="line">System.out.println(cp.equals(sp));  <span class="comment">//?</span></span><br></pre></td></tr></table></figure><p>위와 같이 ColorPoint와 SmellPoint에 대해 equals비교를 한다고 하면 어떻게 될까??<br>이렇게 되면 두번째 if절에서 무한재귀(Infinite Recursion)이 발생하게 된다.  </p><p>무슨 의미인지 자세히 설명하면, cp는 ColorPoint 클래스의 인스턴스이기 때문에<br><code>cp.equals(sp)</code> 코드는 ColorPoint 클래스의 재정의 된 equals 메서드를 타게 된다.<br>이렇게 되면 두번째 if에서 걸리게 된다. 왜냐하면 o는 <strong>SmellPoint</strong> 타입이기 때문에 <code>!(o instanceof ColorPoint)</code> 이 조건식이 true가 된다.<br>그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 o는 SmellPoint 클래스의 인스턴스이기 때문에<br>SmellPoint 클래스의 재정의된 equals메서드를 타게 된다.</p><p>다시 SmellPoint클래스의 입장에서 보게되면 두번째 if에서 걸리게 된다.<br>여기서 o는 ColorPoint타입이기 때문에 <code>!(o instanceof ColorPoint)</code> 이 조건식이 true가 된다.<br>그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 다시 ColorPoint 클래스의 재정의된 equals메서드를 타게 된다.</p><p>이런 작업이 계속 재귀적으로 호출 되면서, 결국은 StackOverflowError를 내며 프로그램이 죽는 참사를 맞이 하게 될 것이다.</p><h3 id="리스코프-치환-원칙-SOLID"><a href="#리스코프-치환-원칙-SOLID" class="headerlink" title="리스코프 치환 원칙 (SOLID)"></a>리스코프 치환 원칙 (SOLID)</h3><p>SOLID원칙 중 3번째인 리스코프 치횐 원칙이란?</p><blockquote><p>자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.</p></blockquote><p>쉽게 말해서, 자식클래스에서 부모클래스의 기능을 수행하지 못하는 건 리스코프 치환원칙에 위배된다고 볼 수 있다.</p><p>위에서 equals 재정의에 실패해서 다시 또 변경하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Point&gt; unitCircle = Set.of(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Point</span>(-<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">onUnitCircle</span><span class="params">(Point p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unitCircle.contains(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(o == <span class="literal">null</span> || o.getClass() != <span class="built_in">this</span>.getClass()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x == p.x &amp;&amp; <span class="built_in">this</span>.y = p.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이번에는 주어진 점이 반지름이 1인 원안에 포함되는지에 대한 여부를 판단하는 로직이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ColorPoint</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">0</span>, Color.RED);</span><br><span class="line">System.out.println(Point.onUnitCircle(cp)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>ColorPoint는 Point를 상속한 클래스이다.<br>실제 oint.onUnitCircle 메서드의 contains 메서드에서 Set내의 element들에 대한 equals 비교가 일어나게 된다.<br>하지만 equals 메서드 첫번째 if문에서 걸리게 된다.<br>ColorPoint 객체가 파라미터로 전달되어 null은 아니지만,<br>두번째 조건식인 o.getClass()에서 <code>ColorPoint.class</code>가 도출되고 this.getClass()에서는 <code>Point.class</code>가 도출되게 된다.  </p><p>위 조건식 때문에 ColorPoint 클래스는 Point클래스로서 equals메서드 내에서 활용되지 못했기 때문에<br>위 코드는 리스코프 치환원칙에 위배되는 코드로 전락해 버렸다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(o == <span class="literal">null</span> || !(o <span class="keyword">instanceof</span> Point)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.x == p.x &amp;&amp; <span class="built_in">this</span>.y = p.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>차라리 이런식으로 instanceof를 사용했다면 좋았을 것이다.</p><h2 id="상속-대신-컴포지션-Composition-을-사용하라"><a href="#상속-대신-컴포지션-Composition-을-사용하라" class="headerlink" title="상속 대신 컴포지션(Composition)을 사용하라"></a>상속 대신 컴포지션(Composition)을 사용하라</h2><p>구체클래스의 하위클래스에서 값을 추가할 방법은 없지만, 우회방법이 있다.<br>상속 대신에 Point 변수를 갖도록 Composition(구성)을 이용하는 방법이다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ColorPoint &#123;</span><br><span class="line">  <span class="keyword">private</span> Point point;</span><br><span class="line">  <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ColorPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, Color color)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.point = <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">    <span class="built_in">this</span>.color = Objects.requireNonNull(color);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Point <span class="title function_">asPoint</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.point;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ColorPoint</span> <span class="variable">cp</span> <span class="operator">=</span> (ColorPoint) o;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.point.equals(cp) &amp;&amp; <span class="built_in">this</span>.color.equals(cp.color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이와 같이 컴포지션을 이용하면 상속에 때문에 발생하는 대칭성, 추이성, 리스코프 치환원칙에 위배되지 않는 코드를 작성할 수 있다.</p><h2 id="일관성-consistency"><a href="#일관성-consistency" class="headerlink" title="일관성 (consistency)"></a>일관성 (consistency)</h2><p><strong>null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.</strong><br>두 객체가 같다면 수정되지 않는 한 영원히 같아야 함을 의미한다.<br>가변객체는 비교시점에 따라 서로 달라질 수 있지만 불변객체라면 한번 다르면 끝까지 달라야 한다. (그래서 불변객체로 만드는 것이 나을때가 많다)</p><p>하지만, 클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들어서는 안된다.<br><code>java.net.URL</code> 클래스는 URL과 매핑된 host의 IP주소를 이용해 비교한다.<br>당장 우리회사 서버만 봐도 L4스위치가 적용되있기 때문에 로드밸런싱이 되어 같은 도메인주소라도 그떄그떄 나오는 IP정보가 다르다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;www.site-name.co.kr&quot;</span>);</span><br><span class="line"><span class="type">URL</span> <span class="variable">url2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;www.site-name.co.kr&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(url1.equals(url2)); <span class="comment">//?</span></span><br></pre></td></tr></table></figure><p>실제 url1이 10.0.0.1 이라는 IP가 나왔다면<br>url2의 경우 10.0.0.1이 나올수도 있고, 같은 대역에 있는 10.0.0.2가 나올 수도 있다.<br>그렇기 떄문에 equals의 결과가 가변적이기 떄문에 다른 자원의 개입으로 인해 equals의 일관성이 깨지게 된다.  </p><p>그렇게 때문에 항상 equals를 사용할 때는 메모리에 존재하는 객체만을 사용한 결정적(deterministic) 계산만 수행해야 한다.</p><h2 id="not-null"><a href="#not-null" class="headerlink" title="not null"></a>not null</h2><p><strong>null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다</strong><br>기본적으로 x.equals(null)이 true가 되는 일은 생각하기 어렵다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(o == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//불필요</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.x == o.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 equals를 재정의 할 때 이러한 코드를 작성하기 쉽다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> MyClass)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//묵시적 null검사</span></span><br><span class="line">  <span class="type">MyClass</span> <span class="variable">clazz</span> <span class="operator">=</span> (MyClass) o;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.x == clazz.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런식으로 instanceof 키워드를 통해 묵시적 null 체크를 하는 방법이 좋다.</p><h1 id="요약-정리"><a href="#요약-정리" class="headerlink" title="요약 정리"></a>요약 정리</h1><h2 id="equals-구현-절차"><a href="#equals-구현-절차" class="headerlink" title="equals 구현 절차"></a>equals 구현 절차</h2><ul><li><code>==</code> 연산자를 사용해 입력된 파라미터와 자기자신이 같은 객체인지 검사한다. (동일성 검사 - Object Identity)<ul><li>성능 향상을 위한 코드</li><li>equals가 복잡할 때 같은 참조를 가진 객체에 대한 비교를 안하기 위함</li></ul></li><li><code>instanceof</code> 연산자로 파라미터의 타입이 올바른지 체크<ul><li>묵시적 null체크 용도로도 사용</li><li>equals중에서는 같은 interface를 구현한 클래스끼리도 비교하는 경우가 있다.</li></ul></li><li>입력을 올바른 타입으로 형변환한다.<ul><li>Object타입의 파라미터를 비교하고자 하는 타입으로 형변환한다.</li><li>앞서 <code>instanceof</code> 연산을 수행했기 때문에 100% 성공한다.</li></ul></li><li>파라미터 Object 객체와 자기자신의 대응되는 핵심필드들이 모두 일치하는지 확인한다.<ul><li>하나라도 다르면 false를 리턴</li><li>만약 interface기반의 비교가 필요하다면 필드정보를 가져오는 메서드가 interface에 정의되어있어야하고,<br>구현체 클래스에서는 메서드를 재정의 해야한다.</li></ul></li><li>float, double을 제외한 기본타입은 <code>==</code>을 통해 비교</li><li>참조(reference) 타입은 equals를 통해 비교</li><li>float, double은 Float.compare(float, float)와 Double.compare(double, double)로 비교한다.<ul><li>Float.Nan, -0.0f등을 비교하기 위함이다.</li><li>이 메서드들은 float -&gt; Float, double -&gt; Double로 변환하는 오토박싱 기능이 수반되므로 성능상 좋지 못하다.</li></ul></li><li>배열의 모든 원소가 핵심 필드라면 Arrays.equals를 사용하자</li><li>null이 의심되는 필드는 Objects.equals(obj, obj)를 이용해 NullPointerException을 예방하자</li><li>성능을 올리고자 한다면<ul><li>다를 확률이 높은 필드부터 비교한다.</li><li>비교하는 비용(시간복잡도)이 적은 비교를 먼저 수행</li></ul></li></ul><h1 id="주의사항"><a href="#주의사항" class="headerlink" title="주의사항"></a>주의사항</h1><ul><li>equals를 재정의 했다면, 대칭성, 추이성, 일관성에 대한 체크를 꼭 하자 (테스트 케이스 작성 요망)</li><li>equals를 작성할 때는 hashcode도 반드시 재정의하자 (Item.11)</li><li>너무 복잡하게 해결하려 들지 말자</li><li>equals의 파라미터는 Object이외의 타입으로 선언하지 말자 (컴파일 에러 발생)</li><li>구글에서 만든 @AutoValue을 이용해서 equals와 hashcode를 자동으로 재정의해보자 (Lombok의 @EqualsAndHashCode도 있다.)</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 10. equals는 일반 규약을 지켜 재정의하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 9. Try-Finally 보다는 Try-With-Resources를 사용하라</title>
      <link href="/2019/01/08/effective-java-item9/"/>
      <url>/2019/01/08/effective-java-item9/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Java 라이브러리 중에는 close메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, Connection등이 있다.<br>자원 닫기는 클라이언트가 놓치기 쉽기 때문에 예측할 수 없는 성능 문제로 이어지기도 한다.  </p><p>나의 경우에도 신입 때 JDBC로 개발을 해야 했던 적이 있었는데,<br>DB의 max-connection이 10이어서 11번째 호출 시 부터는 JDBCException이 발생하는 오류를 겪은 적이 있다.<br>알고 보니 하나의 메서드에서 Connection 객체에 대한 참조를 해제 하지 않아 계속 Connection을 물고 있는 상황이었다.<br>Spring을 사용하면서는 Mybatis나 JPA같은 프레임웍 내에서 자원에 대한 관리를 해주기 때문에 이런 일을 만날 일은 없게 되었다.</p><p>하지만 예전처럼 JDBC를 사용하거나, IO관련 작업을 할 때는 반드시 close를 통해 자원에 대한 해제가 필요하다.<br>이전에는 finallizer를 통해 했다고는 아는데 이전 장에서 봤듯이 안 쓰는것이 좋다.<br>그리고 try-catch-finally 구문을 통해 Exception이 발생하더라도, finally 절에서 close를 호출 하도록 했는데, 코드가 복잡해 지고, finally 절 내에서 Exception이 발생하는 경우도 있기 때문에 이를 방지하기 위해 더 더러운 코드를 생산하는 일이 적지 않았다.</p><p>옛날에 자주 사용해 본 아주아주 슬픈 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCExam</span> &#123;</span><br><span class="line">  Connection connection;</span><br><span class="line">  Statement statement;</span><br><span class="line">  ResultSet resultSet;</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> <span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;oracle:thin:localhost:1521:ORCL&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;scott&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;tiger&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">JDBCExam</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Class.forName(driverName);</span><br><span class="line">          connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;[로드 오류]\n&quot;</span> + e.getStackTrace());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;[연결 오류]\n&quot;</span> + e.getStackTrace());</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                  connection.close();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">                  statement.close();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (resultSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                  resultSet.close();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;[닫기 오류]\n&quot;</span> + e.getStackTrace());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AutoCloseable"><a href="#AutoCloseable" class="headerlink" title="AutoCloseable"></a>AutoCloseable</h1><p>JDK 1.7 부터 try-with-resources 구문이 추가 되었고, <code>AutoCloseable</code> 인터페이스가 추가되었다. 이 인터페이스가 나오고 부터 Java의 close를 지원하는 클래스에서 AutoCloseable을 구현하도록 변경되었다.</p><h1 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h1><p>try 절에 AutoCloseable을 구현한 클래스에 대한 인스턴스를 선언하게 되면 try절이 종료되는 시점에 AutoCloseable 인터페이스의 close() 메서드를 자동으로 호출 한다. 그렇기 때문에 이전처럼 finally 구문에서 별도로 자원에 대한 해제를 하지 않아도 된다.</p><p>위의 예시코드를 try-with-resources 구문으로 바꿔보았다.<br>위의 코드보다는 한층 깔끔해 짐을 볼 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCExam</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> <span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;oracle:thin:localhost:1521:ORCL&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;scott&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;tiger&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JDBCExam</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">             <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;select * from member&quot;</span>);</span><br><span class="line">             <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.getResultSet();</span><br><span class="line">             )&#123;</span><br><span class="line">            Class.forName(driverName);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;회원명 : &quot;</span> + name);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[로드 오류]\n&quot;</span> + e.getStackTrace());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[연결 오류]\n&quot;</span> + e.getStackTrace());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 9. try-finally 보다는 try-with-resources를 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 8. Finalizer와 Cleaner 사용은 피하라</title>
      <link href="/2019/01/07/effective-java-item8/"/>
      <url>/2019/01/07/effective-java-item8/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Java에서는 2가지의 객체 소멸자를 제공한다.</p><ul><li>finalzier</li><li>cleaner</li></ul><p>이 2가지 객체 소멸자는 JVM내의 GC가 작동할 때 실행되는 구문이다.<br>기본적으로 이 2가지 구문은 <strong>사용하지 말아야 한다.</strong><br>현재 Java 9 버전 부터는 Object 클래스에 대한 finalizer를 <code>Deprecated</code> 처리하였다.<br>아래에 사용하지 말아햐 하는 이유를 하나씩 보도록 하겠다.</p><h1 id="finalizer와-cleaner를-사용하지-말아야-하는-이유"><a href="#finalizer와-cleaner를-사용하지-말아야-하는-이유" class="headerlink" title="finalizer와 cleaner를 사용하지 말아야 하는 이유"></a>finalizer와 cleaner를 사용하지 말아야 하는 이유</h1><h2 id="실행을-보장할-수-없다"><a href="#실행을-보장할-수-없다" class="headerlink" title="실행을 보장할 수 없다."></a>실행을 보장할 수 없다.</h2><p>finalizer에 특정 로직을 삽입하는 경우 실행을 보장 할 수 없다.<br>기본적으로 GC가 발생할 때 실행되는 로직이지만, Java Application이 죽는다던지의 이유로 finalizer 실행이 되지 않을 수 있다.<br>그렇기 때문에 제 때 실행되어야 하거나, 뭔가 상태를 수정하는 행위를 절대적으로 하면은 안된다.</p><h2 id="느리다"><a href="#느리다" class="headerlink" title="느리다."></a>느리다.</h2><p>Effective Java 책의 예제에서는 AutoCloseable과 finalizer의 성능비교를 한 문단이 있다.<br>Autocloseable을 사용한 GC 수행시간은 12ns였지만, finalizer를 사용한 GC 수행 시간은 550ns가 걸렸다고 한다.<br>finalizer가 가비지 컬렉터의 효율을 떨어뜨리기 때문이다.</p><h2 id="시스템-전체-장애를-유발-할-수-있다"><a href="#시스템-전체-장애를-유발-할-수-있다" class="headerlink" title="시스템 전체 장애를 유발 할 수 있다."></a>시스템 전체 장애를 유발 할 수 있다.</h2><p>Java API 문서 상에서는 GC가 UnReachable 상태의 객체를 가비지 컬렉션 할 때 finalizer가 호출된다고 명시하고 있다.<br>하지만 finalizer가 실행되는 시점은 GC 발생 시 즉각적으로 이루어지는게 아니다.<br>finalizer queue에 삽입되어 순차적으로 finalizer를 실행하게 된다.<br>그렇기 때문에 finalizer메소드 실행이 느린 경우 객체 소멸이 느려지므로  <code>Out of Memory</code>와 같은 오류를 발생 시킬 가능성이 높아지게 된다.</p><h2 id="finalizer-공격에-취약하다"><a href="#finalizer-공격에-취약하다" class="headerlink" title="finalizer 공격에 취약하다."></a>finalizer 공격에 취약하다.</h2><p>위에 적은 것 처럼 finalizer 메소드 실행시간이 오래 걸리게 만들면 시스템에 심각한 장애를 유발할 수 있다.<br>finalizer 메서드를 override해서 악의적으로 느리게 할 수 있기 떄문에 finalizer를 사용해야 하는 경우라면<br>메소드에 <code>final</code> 키워드를 붙여서 상속하지 못하도록 해야한다.</p><h1 id="그럼-finalizer나-cleaner는-어디서-쓰나"><a href="#그럼-finalizer나-cleaner는-어디서-쓰나" class="headerlink" title="그럼 finalizer나 cleaner는 어디서 쓰나?"></a>그럼 finalizer나 cleaner는 어디서 쓰나?</h1><ul><li>개발자가 객체의 close를 호출하지 않는 경우 -&gt; 자원 해제를 안하느니 느리더라도 하는게 낫다.<br>(이 경우는 동의 못하겠다. 개발자가 close를 시켜야 한다.)</li><li>native peer와 연결된 객체<ul><li>native peer는 자바 객체가 아니기 떄문에 가비지 컬렉터의 관리 대상이 아니다.<br>그렇기 때문에 native peer가 회수 될때 finalizer 메서드를 실행해 자원을 해제 할 수 있다.</li></ul></li></ul><h1 id="finalizer-기능이-필요한-경우에는-어떻게"><a href="#finalizer-기능이-필요한-경우에는-어떻게" class="headerlink" title="finalizer 기능이 필요한 경우에는 어떻게?"></a>finalizer 기능이 필요한 경우에는 어떻게?</h1><p>Autocloseable Interface를 사용하여 close를 호출시키도록 하자.<br>다음장의 try-catch-resource 구문에서 설명하도록 하겠다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 8. finalizer와 cleaner 사용은 피하라</li><li><a href="http://www.yunsobi.com/blog/entry/finalize-%EB%A9%94%EC%86%8C%EB%93%9C%EC%9D%98-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EC%9D%84-%EC%9E%90%EC%A0%9C%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0">finalize 메소드의 오버라이딩을 자제해야 하는 이유.</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 7. 다 쓴 객체는 참조를 해제하라</title>
      <link href="/2019/01/07/effective-java-item7/"/>
      <url>/2019/01/07/effective-java-item7/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Java의 장점 중 하나는 가비지 컬렉션을 지원하는 언어라는 점이다.<br>C, C++ 처럼 개발자가 메모리를 직접 할당하고 해제하는 방식이 아니기 때문에 Java에서는 메모리 관리가 굉장히 편하다는 장점이 있다.</p><p>하지만 <code>아예 신경을 안써도 되는 것은 아니다.</code><br>가비지 컬렉션을 통해 소멸 대상이 되는 객체가 되기 위해서는 어떠한 reference 변수에서 가르키지 않아야 한다.<br>다 쓴 객체에 대한 참조를 해제하지 않으면 가비지 컬렉션의 대상이 되지 않아 계속 메모리가 할당 되는 <strong>메모리 누수</strong> 현상이 발생 된다.</p><p>가비지 컬렉션을 지원하는 언어에서는 메모리 누수를 찾기가 까다롭다<br>객체 참조(reference)를 하나 살려두면, 가비지 컬렉터는 그 객체 뿐만 아니라 그 객체 내에서 참조하고 있는 객체까지 회수 할 수 없다.</p><p>이로 인해 잠재적으로 성능에 악영향을 줄 수 있다.</p><h1 id="가비지-컬렉션의-소멸-대상이-되기-위해서는…"><a href="#가비지-컬렉션의-소멸-대상이-되기-위해서는…" class="headerlink" title="가비지 컬렉션의 소멸 대상이 되기 위해서는…"></a>가비지 컬렉션의 소멸 대상이 되기 위해서는…</h1><h2 id="직접-할당-해제"><a href="#직접-할당-해제" class="headerlink" title="직접 할당 해제"></a>직접 할당 해제</h2><ul><li>이 방법은 굉장히 단순하다.<br>말 그대로 객체 참조 변수를 null로 초기화 한다.<br>그렇게 되면 실제 heap 메모리에 존재하는 객체는 어떠한 참조(reference)도 가지지 않기 때문에<br><code>가비지 컬렉션의 소멸 대상</code>이 된다.</li><li>하지만 바람직한 방법은 아니다. 반드시 필요한 경우에만 사용 할 수 있도록 하는 것이 좋다.<br>(소스코드가 드러워짐 -_-)</li><li>클래스 내에서 메모리를 관리 하는 객체(Stack 같은…)라면 이 방법을 통해 다 쓴 객체는 할당을 해제 하는 것이 옳다.</li></ul><h2 id="Scope를-통한-자동-할당-해제"><a href="#Scope를-통한-자동-할당-해제" class="headerlink" title="Scope를 통한 자동 할당 해제"></a>Scope를 통한 자동 할당 해제</h2><ul><li>보통은 변수 선언<code>(대게 지역변수)</code>과 동시에 초기화를 사용한다.<br>그 변수에 대한 scope가 종료되는 순간 reference가 해제되어 가비지 컬렉션의 대상이 된다.</li><li>try<del>catch와 같은 구문에서는 catch 구문에서 try내에서 사용하는 변수를 참조하지 못하므로<br>try</del>catch 변수 초기화를 하기 어렵다.<br>그렇게 때문에 finally 구문에서 변수에 대한 참조를 해제한다.</li></ul><h1 id="메모리-누수를-일으키는-주범"><a href="#메모리-누수를-일으키는-주범" class="headerlink" title="메모리 누수를 일으키는 주범"></a>메모리 누수를 일으키는 주범</h1><ul><li>첫번째는 위에서 설명한 class내에서 instance에 대한 참조(reference)를 관리하는 객체이다.</li><li>두번째는 Map과 같은 캐시</li><li>세번째는 리스너(Listener) 혹은 콜백(Callback)</li></ul><p>Map과 같은 캐시에 객체참조를 넣어두고 사용이 끝났는데도 초기화를 안시켜주는 경우 메모리 누수가 발생한다.<br>엔트리가 살아있는 동안만 캐시를 사용하려면 <code>WeakHashMap</code>을 사용하자.<br>WeakHashMap을 이해하려면 Java의 Reference를 좀 알아야 한다.</p><h2 id="Java-Reference"><a href="#Java-Reference" class="headerlink" title="Java Reference"></a>Java Reference</h2><p>Java에는 4가지의 Reference가 있다.</p><ul><li><p>Strong Reference</p><ul><li>우리가 흔히 사용하는 reference</li><li>String str &#x3D; new String(“abc”); 와 같은 형태</li><li>Strong Reference는 GC의 대상이 되지 않는다. </li><li>Strong Reference관계의 객체가 GC가 되기 위해선 null로 초기화해<br>객체에 대한 Reachability상태를 UnReachable 상태로 만들어 줘야 한다.</li></ul></li><li><p>Soft Reference</p><ul><li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference만 있는 상태</li><li>SoftReference<Class> ref &#x3D; new SoftReference&lt;&gt;(new String(“abc”));와 같은 형태로 사용</li><li>Soft Reference는 대게 GC대상이 아니다가 <code>out of memory에러</code>가 나기 직전까지 가면<br>Soft Reference 관계에 있는 객체들은 GC대상이 된다.</li></ul></li><li><p>Weak Reference</p><ul><li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference가 없고 Weak Reference만 있는 상태</li><li>WeakReference<Class> ref &#x3D; new WeakReference<Class>(new String(“abc”)); 와 같은 형태로 사용</li><li>WeakReference는 GC가 발생 할 때마다 대상이 된다.</li></ul></li><li><p>Phantomly Reference</p><ul><li>객체의 Reachability가 Strongly Reachable 객체가 아닌 객체 중 Soft Reference와 Weak Referencerk 모두가 해당되지 않는 객체</li><li>finalize 되었지만 메모리가 아직 회수 되지 않은 객체</li><li>아직 잘 이해가… 안됨</li></ul></li></ul><h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p>Weak Reference를 이용한 HashMap<br>아래의 예제코드를 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassWeakHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Referred</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Good bye cruel world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * GC를 발생 시켜 메모리를 회수하는 코드</span></span><br><span class="line"><span class="comment">    * System.gc()가 잘 동작할지는 모르겠다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Suggesting collection&quot;</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating weak references&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is now a weak reference. </span></span><br><span class="line">        <span class="comment">// The object will be collected only if no strong references. </span></span><br><span class="line">        <span class="type">Referred</span> <span class="variable">strong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Referred</span>(); <span class="comment">//Strong Reference로 하나 추가</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Weak Reference를 이용한 WeakHashMap에 엔트리를 추가하여</span></span><br><span class="line">        <span class="comment">//Weak Reference 추가</span></span><br><span class="line">        Map&lt;Referred, String&gt; metadata = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;Referred, String&gt;();</span><br><span class="line">        metadata.put(strong, <span class="string">&quot;WeakHashMap&#x27;s make my world go around&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attempt to claim a suggested reference. </span></span><br><span class="line">        ClassWeakHashMap.collect();</span><br><span class="line">        <span class="comment">//여기서는 gc가 발생해도 GC대상이 아니게 된다.</span></span><br><span class="line">        <span class="comment">//strong이라는 변수를 통해 Strong Reference를 가지므로 GC 대상이 아니다.</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Still has metadata entry? &quot;</span> + (metadata.size() == <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Removing reference&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The object may be collected. </span></span><br><span class="line">        <span class="comment">//Strong Reference를 끊었다.</span></span><br><span class="line">        strong = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//여기서는 Weak Reference만 남아 있기 때문에 GC대상이 된다.</span></span><br><span class="line">        ClassWeakHashMap.collect();</span><br><span class="line">        System.out.println(<span class="string">&quot;Still has metadata entry? &quot;</span> + (metadata.size() == <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Weak Reference를 가지고 있으면 GC가 발생되기 전까지 객체에 접근이 가능하기 때문에 메모리 누수의 입장으로 볼 때 유리한 것 같다.<br>한번 캐싱하고 사용하고 버리는 대상에 좋은 방법이다.</p><p>하지만 static한 Map을 사용하는 경우에는 비추이다.<br>언제 GC가 일어날지 모를 뿐더러.. 갑자기 데이터가 사라져 자칫 하면 장애가 발생 할 수 있으니,<br>특별한 경우에만 WeakHashMap을 사용해야 한다.</p><h2 id="리스너-혹은-콜백"><a href="#리스너-혹은-콜백" class="headerlink" title="리스너 혹은 콜백"></a>리스너 혹은 콜백</h2><p>리스너와 콜백은 root set에 대한 직접 참조가 아닌 객체에서 참조를 가지고 있다.<br>그렇기 때문에 리스너와 콜백을 사용하는 객체가 unreachable 상태가 되지 않는 이상 메모리에서 GC대상이 되지 않는다.<br>이 경우 weak reference를 이용하면 리스너와 콜백을 사용하고, GC 작동 시에 메모리 해제를 시킬 수 있어, 메모리 누수에 도움이 된다.</p><h1 id="추가적으로"><a href="#추가적으로" class="headerlink" title="추가적으로.."></a>추가적으로..</h1><p>메모리 누수는 겉으로 잘 드러나지 않아 수년 간 잠복하는 사례가 있다고 한다.<br>이런 누수는 철저한 코드리뷰나 힙 프로파일링 도구를 통해 디버깅을 동원해야 발견할 수 있으므로,<br>평소에 코드를 작성할 때 메모리 누수에 대한 부분을 신경을 써주는 것이 중요하다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 7. 다 쓴 객체는 참조를 해제하라</li><li><a href="https://d2.naver.com/helloworld/329631">https://d2.naver.com/helloworld/329631</a></li><li><a href="https://tourspace.tistory.com/42">https://tourspace.tistory.com/42</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 6. 불필요한 객체 생성을 피하라</title>
      <link href="/2019/01/07/effective-java-item6/"/>
      <url>/2019/01/07/effective-java-item6/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>똑같은 기능의 객체를 매번 생성하기 보다는 객체 하나는 재사용하는 편이 나을 때가 많다. (아니 거의 무조건 재사용 할 수 있으면 하는 게 좋다.)<br>재사용은 빠르고 세련되며, 특히 불변 객체는 언제든지 안전하게 재사용 할 수 있다.</p><h1 id="아주-안-좋은-객체-생성의-예"><a href="#아주-안-좋은-객체-생성의-예" class="headerlink" title="아주 안 좋은 객체 생성의 예"></a>아주 안 좋은 객체 생성의 예</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>이러한 코드는 매번 새로운 String 객체를 생성하게 된다.</p><h1 id="String-Constant-pool"><a href="#String-Constant-pool" class="headerlink" title="String Constant pool"></a>String Constant pool</h1><p>위의 코드를 조금 더 보완하면 아래 코드 처럼 사용할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>Java JVM에는 String Constant pool 이라는 것이 있다.<br>(Java 7 버전을 기점으로 Perm영역 -&gt; Heap 영역으로 변경되었다.)<br>위 처럼 쓰는 방식을 String 리터럴 방식이라 한다.  </p><p>String 리터럴을 사용할 경우 기본적으로 String 내장 메서드인 intern()이라는 메서드를 호출하게 된다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ol><li>최초로 Hello라는 String 리터럴을 사용하였기 때문에 intern() 메서드가 호출된다.</li></ol><p>–&gt; String Constant pool에서 해당 문자열을 검색하였지만 존재 하지 않기 때문에 String Constant pool에 넣고 새로운 주소값을 반환한다.</p><ol start="2"><li>두번째로 Hello라는 String 리터럴을 사용하였기 때문에 마찬가지로 intern() 메서드가 호출된다.</li></ol><p>–&gt; String Constant pool에서 해당 문자열을 검색하니 기존에 등록된 주소 값이 반환된다.</p><p>실질적으로 a와 b는 같은 주소값을 가지게 된다.</p><p>그렇기 때문에 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(a == b);      <span class="comment">//true</span></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>위의 코드를 실행해 보면 객체의 동등성 비교와 동일성 비교에서 모두 true가 나온다.</p><ul><li>동등성(equality) : 두 객체의 내용이 같은지 비교</li><li>동일성(identity) : 두 객체가 같은 객체인지 hashcode를 비교</li></ul><p>그렇기 때문에 String을 사용할 경우에는 new를 이용한 객체 생성 방식보다 String 리터럴을 사용하는 방식이 더 좋다. (같은 객체를 재사용 하기 때문)</p><blockquote><p>그렇다고 실제 코드에서 String 리터럴을 사용했다고 <code>==</code> 을 이용한 동일성 비교는 하지말자.<br>상당히 위험한 코드이고, 다른 결과를 초래 할 가능성이 매우 높다.</p></blockquote><h1 id="Boolean의-예시"><a href="#Boolean의-예시" class="headerlink" title="Boolean의 예시"></a>Boolean의 예시</h1><p>Boolean의 경우 new Boolean(true)보다 Boolean.valueOf를 사용하는 것이 더 좋다.</p><p>Boolean 클래스를 보면..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Boolean</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,</span><br><span class="line">                                      Comparable&lt;Boolean&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment">     * value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">TRUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment">     * value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">FALSE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of the Boolean.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3665804199014368530L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated(since=&quot;9&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boolean</span><span class="params">(<span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated(since=&quot;9&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boolean</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(parseBoolean(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">parseBoolean</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">booleanValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new Boolean의 경우 그때그때 새로운 객체를 생성하게 된다.<br>(로컬 컴퓨터에는 OpenJDK 11이 설치되어있는데 Java 9 버전 부터 Boolean 생성자는 Deprecated 처리 되었다.)</p><p>하지만, Boolean.valueOf 라는 정적 메서드는 TRUE, FLASE라는 정적 필드에 이미 생성한 인스턴스를 사용하고 있기 때문에<br>객체를 추가적으로 생성하지 않아 성능상 이점이 있기 때문이다.</p><h1 id="Auto-Boxing을-주의하라"><a href="#Auto-Boxing을-주의하라" class="headerlink" title="Auto Boxing을 주의하라!"></a>Auto Boxing을 주의하라!</h1><p>오토박싱은 Java 5 부터 나온 기능이다.<br>primitive 타입과 Class 타입을 자동으로 변환해 주는 기능이다.<br>이 기능에 대해 간과하게 되면 쓸 데 없는 객체를 많이 만들어 낼 수 있다.  </p><p>책에 소개 된 예제를 잠깐 돌아보면..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">    sum += i; <span class="comment">//i에 대해 Auto Boxing이 일어나고 있다.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i가 더해질 때 마다 AutoBoxing이 발생하게 된다.<br>sum 변수를 쓸데 없이 long으로 선언해서 Long객체가 2^32개 만큼 쓸데 없이 생성 되었다. (책에는 231개라고 나와있는데 오타일 거라 생각한다.)<br>sum을 long으로만 바꿔줘도 불필요한 객체가 생성되는 일은 없을 것이며, 성능도 더 빨라지게 된다. (책에서는 6.3초 -&gt; 0.59초로 성능 향상을 보았다고 한다.)</p><h1 id="나만의-객체-Pool을-만들지-말자"><a href="#나만의-객체-Pool을-만들지-말자" class="headerlink" title="나만의 객체 Pool을 만들지 말자"></a>나만의 객체 Pool을 만들지 말자</h1><p>객체를 생성하는 비용이 많이 드는 객체라면 미리 pool을 생성하여 사용하면 좋다.<br>JDBC에서 사용하는 Connection pool은 생성비용이 높기 때문에 재사용성을 높이기 위해 pool을 사용하는 것이 좋다.<br>하지만 일반적으로 개인이 만든 pool은 코드를 헷갈리게 하고 성능을 떨어뜨린다.<br>(요즘 GC는 최적화가 잘되서, pool을 만드는 것보다 그냥 객체를 생성하는게 더 빠르다고 한다.)</p><h1 id="예외는-있다"><a href="#예외는-있다" class="headerlink" title="예외는 있다."></a>예외는 있다.</h1><p>방어적 복사본을 만들어야 하는 경우가 있다.<br>불변 객체를 유지하기 위해 객체를 수정할 때 마다 새로운 객체를 만들어서 데이터를 수정하는 방식인데, 얼핏 보면 쓸 떼 없는 객체를 생성하는 것 처럼 보인다.<br>하지만 객체를 좀 더 만드는 피해보다, 객체가 재사용 되면서 불변성이 깨져 버그가 발생하는 피해가 더 크다는 사실을 명심해야 한다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 6. 불필요한 객체 생성을 피하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</title>
      <link href="/2019/01/07/effective-java-item5/"/>
      <url>/2019/01/07/effective-java-item5/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 방식이나, 싱글턴 방식이 적합하지 않다.<br>자원에 따라 동작이 달라진다면, 자원의 수만큼 인스턴스를 만들어 동작하게 하는 것이 좋다.<br>이를 <code>의존 객체 주입</code>이라고 하는데 Spring과 같은 프레임워크에서 DI의 개념으로 많이 쓰이고 있다.</p><p>의존 객체 주입은 생성자, 정적팩터리, 빌더 혹은 Setter를 이용해서 자원을 넘겨 줄 수 있다.</p><h1 id="팩터리-메서드-패턴-사용하여-자원-넘겨주기"><a href="#팩터리-메서드-패턴-사용하여-자원-넘겨주기" class="headerlink" title="팩터리 메서드 패턴 사용하여 자원 넘겨주기"></a>팩터리 메서드 패턴 사용하여 자원 넘겨주기</h1><p>자바8에서는 Supplier<T> 인터페이스가 팩터리를 표현한 완벽한 예다.<br>Supplier<T>를 입력으로 받는 메서드는 일반적으로 한정적 와일드 카드 타입을 사용해 팩터리의 타입 매개변수를 제한한다.</p><p>아래의 예제처럼 사용한다.<br>타일들을 이용해 모자이크를 만드는 예제이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mosaic <span class="title function_">create</span><span class="params">(Supplier&lt;? extends Tile&gt; tileFactory)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸 클래스는 사용하지 말자!</li><li>필요한 자원 또는 팩터리를 생성자나 빌더를 통해 의존 객체를 주입하도록 하자</li><li>의존 객체 주입은 유연성, 재사용성, 테스트 용이성을 높여 줄 것이다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 4. 인스턴스화를 막으려거든 Private 생성자를 사용하라</title>
      <link href="/2019/01/07/effective-java-item4/"/>
      <url>/2019/01/07/effective-java-item4/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>단순히 static 메서드와 static 필드만을 담은 클래스를 만들고 싶을 때가 있다.<br>보통 Utils 클래스를 정의할 떄 이런식으로 많이 사용하는데, 이러한 클래스는 인스턴스를 만들어서 사용하고자 만든 목적이 아니기 때문에 인스턴스화를 막아야 한다.<br>생성자를 하나도 명시 하지 않으면 Java에서는 매개변수가 없는 default 생성자를 만들어 준다. </p><h1 id="추상-클래스로-만들면"><a href="#추상-클래스로-만들면" class="headerlink" title="추상 클래스로 만들면?"></a>추상 클래스로 만들면?</h1><p>추상 클래스로 만드는 것으로는 인스턴스 화를 막을 수 없다.<br>단순히 상속을 통해 인스턴스를 만들 수 있기 때문이다. 오히려 abstract 클래스는 하위클래스를 만들어서 사용하라는 뉘앙스가 더 강하다.</p><h1 id="private-생성자를-만들자"><a href="#private-생성자를-만들자" class="headerlink" title="private 생성자를 만들자"></a>private 생성자를 만들자</h1><p>private 생성자를 만드는 것 만으로도 인스턴스화를 막을 수 있다.<br>외부에서 new 키워드를 통해 인스턴스를 만들 수 없기 때문이다.</p><p>이중 보안을 하자면.. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Utils</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 식으로 Error를 발생 시켜주자.</p><p>평소 코딩할 때는 Lombok을 이용해서 깔끔하게 등록해 주는 것도 방법이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor(access = AccessLevel.PRIVATE)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Utils</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 4. 인스턴스화를 막으려거든 private 생성자를 사용하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 3. Private 생성자나 열거 타입으로 싱글턴임을 보증하라</title>
      <link href="/2019/01/07/effective-java-item3/"/>
      <url>/2019/01/07/effective-java-item3/</url>
      
        <content type="html"><![CDATA[<h1 id="싱글턴이란"><a href="#싱글턴이란" class="headerlink" title="싱글턴이란?"></a>싱글턴이란?</h1><p>싱글턴 객체란 Application내에서 단 1개의 인스턴스만 생성할 수 있는 클래스를 의미한다.<br>시스템에서 유일성을 보장하기 위해 1개만 만들어야 하는 경우도 있고, 시스템 구조 상 1개 이상이 되면 개념적으로 맞지 않는 상황도 있기 때문이다.</p><h1 id="싱글턴을-만드는-방법"><a href="#싱글턴을-만드는-방법" class="headerlink" title="싱글턴을 만드는 방법"></a>싱글턴을 만드는 방법</h1><h2 id="private-생성자-static-객체"><a href="#private-생성자-static-객체" class="headerlink" title="private 생성자 + static 객체"></a>private 생성자 + static 객체</h2><p>private 생성자를 통해 내부에서만 객체를 생성 할 수 있도록 하고,<br>public static final 키워드를 이용해 static 변수로 1개의 인스턴스만 제공하는 방식이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자가 Elvis 객체를 클라이언트에서 사용하기 위해서는<br>외부로 노출 된 생성자가 없기 때문에 Elvis.INSTANCE의 형태로 사용해야만 한다.<br>최초로 INSTANCE 변수가 초기화 될 때 private 생성자를 통해 단 한번 인스턴스가 생성되게 된다.</p><blockquote><p>하지만, Java의 Reflection기능을 이용하여, AccessibleObject.setAccessible(true)를 이용하면 private 생성자를 호출 할 수 있다.<br>(이런 부분은 논외로 한다.)  여차하면 두번째 호출 부터 Exception을 발생 시켜 싱글턴을 보장할 수 있도록 방어로직을 심을 수 있다.</p></blockquote><h2 id="정적-팩터리-메서드"><a href="#정적-팩터리-메서드" class="headerlink" title="정적 팩터리 메서드"></a>정적 팩터리 메서드</h2><p>위의 private 생성자 + static 객체에서 조금 진화된 형태가 클래스에서 정적 팩터리 메서드를 제공하는 case이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>지금은 싱글턴 객체를 리턴하는 정적 메서드이지만, 향후 필요에 따라 변경될 수 있는 확장성을 가지고 있다.<br>특정 파라미터나, 특정 스레드에는 다른 인스턴스를 리턴한다던지에 대해 확장과 변경에 열려 있는 장점이 있다.</p></li><li><p>원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.</p></li><li><p>정적 팩터리 메서드의 참조를 공급자(Supplier)로 만들 수 있다.</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Supplier&lt;Elvis&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="열거-타입-Enum-을-이용한-싱글턴-객체-생성"><a href="#열거-타입-Enum-을-이용한-싱글턴-객체-생성" class="headerlink" title="열거 타입(Enum)을 이용한 싱글턴 객체 생성"></a>열거 타입(Enum)을 이용한 싱글턴 객체 생성</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1번째 예시와 비슷하지만 가장 안전하고 좋은 방법이다.<br>복잡한 직렬화 상황이나, 리플렉션 공격에도 안전하다.<br>단, 만들려는 싱글턴이 Enum이외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다.<br>(열거 타입이 다른 인터페이스를 구현하도록 하는 건 가능.)</p><h1 id="싱글턴-객체의-직렬화"><a href="#싱글턴-객체의-직렬화" class="headerlink" title="싱글턴 객체의 직렬화"></a>싱글턴 객체의 직렬화</h1><p>싱글턴 클래스를 직렬화 하기 위해서는 Serializable을 구현한다고 선언하는 것 만으로는 부족하다.<br>모든 인스턴스 필드에 transient 예약어를 붙여 직렬화를 막은 다음 readResolve 메서드를 제공해야 한다.<br>이렇게 하지 않으면 역직렬화 시점에 새로운 인스턴스가 생성 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//역직렬화가 되어 새로운 인스턴스가 생성되더라도, </span></span><br><span class="line">  <span class="comment">//클래스간 공유 변수인 static 변수를 이용하면 싱글턴을 보장 할 수 있다.</span></span><br><span class="line">  <span class="comment">// 새로운 인스턴스는 GC에 의해 UnReachable 형태로 판별되어 제거된다.</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라</title>
      <link href="/2019/01/06/effective-java-item2/"/>
      <url>/2019/01/06/effective-java-item2/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>정적 팩터리 메서드 팩터리와 생성자에는 똑같은 제약이 하나 있다.<br>선택적 매개변수가 많을 경우에 적절하게 대응하기 어렵다는 점이다.<br>매개변수가 3~4개까지는 어떻게 해보겠지만 엄청 많은 경우에는 생성자를 이용해 객체를 생성하는 과정부터가 곤욕이다.</p><p>아래의 예시를 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories, <span class="type">int</span> fat, <span class="type">int</span> sodium, <span class="type">int</span> carbonhydrate)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">    <span class="built_in">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">    <span class="built_in">this</span>.calories = calories;          <span class="comment">//선택</span></span><br><span class="line">    <span class="built_in">this</span>.fat = fat;                    <span class="comment">//선택</span></span><br><span class="line">    <span class="built_in">this</span>.sodium = sodium;              <span class="comment">//선택</span></span><br><span class="line">    <span class="built_in">this</span>.carbohydrate = carbohydrate;  <span class="comment">//선택</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>매개변수가 int만 6개로 이루어져 있다.<br>그리고 default value가 정해져 있지 않기 때문에, servingSize 같은 변수는 정의하기 싫으면 0으로 해야할 지, 아니면 최소값이 있을지 알기가 어렵다.<br>그리고 매개변수 선언 순서가 바뀌면 의도하지 않은 객체가 생성되기 때문에 코딩 할 때 매우 주의를 요해야 한다.</p><h1 id="점층적-생성자-패턴"><a href="#점층적-생성자-패턴" class="headerlink" title="점층적 생성자 패턴"></a>점층적 생성자 패턴</h1><p>위와 같은 문제를 조금이나마 해결해 보려는 노력이 점층적 생성자 패턴이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">    <span class="built_in">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(servingSize, servings);</span><br><span class="line">     <span class="built_in">this</span>.calories = calories;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories, <span class="type">int</span> fat)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(servingSize, servings, calories);</span><br><span class="line">     <span class="built_in">this</span>.fat = fat;     </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories, <span class="type">int</span> fat, <span class="type">int</span> sodium, <span class="type">int</span> carbonhydrate)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">    <span class="built_in">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">    <span class="built_in">this</span>.calories = calories;          <span class="comment">//선택</span></span><br><span class="line">    <span class="built_in">this</span>.fat = fat;                    <span class="comment">//선택</span></span><br><span class="line">    <span class="built_in">this</span>.sodium = sodium;              <span class="comment">//선택</span></span><br><span class="line">    <span class="built_in">this</span>.carbohydrate = carbohydrate;  <span class="comment">//선택</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이것도 선택사항에 대해 하나의 방법으로 작용할 수 있지만, 코드가 길어지고 가독성이 떨어지게 된다.<br>실제로 매개변수의 위치에 따라 의도하지 않은 객체가 생성될 수 있기 때문에 주의를 요해야 하는 코드이다.</p><h1 id="Java-Beans-패턴"><a href="#Java-Beans-패턴" class="headerlink" title="Java Beans 패턴"></a>Java Beans 패턴</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">servingSize</span> <span class="operator">=</span> -<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">servings</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">calories</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">fat</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">sodium</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">carbohydrate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServingSize</span><span class="params">(<span class="type">int</span> servingSize)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.servingSize = servingSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServings</span><span class="params">(<span class="type">int</span> servings)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.servings = servings;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCalories</span><span class="params">(<span class="type">int</span> calories)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.calories = calories;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFat</span><span class="params">(<span class="type">int</span> fat)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fat = fat;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSodium</span><span class="params">(<span class="type">int</span> sodium)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sodium = sodium;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCarboHydrate</span><span class="params">(<span class="type">int</span> carbohydrate)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">NutritionFacts</span> <span class="variable">nutritionFacts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>();</span><br><span class="line"></span><br><span class="line">nutritionFacts.setServingSize(<span class="number">240</span>);</span><br><span class="line">nutritionFacts.setServings(<span class="number">8</span>);</span><br><span class="line">nutritionFacts.setCalories(<span class="number">100</span>);</span><br><span class="line">nutritionFacts.setFat(<span class="number">20</span>);</span><br><span class="line">nutritionFacts.setSodium(<span class="number">35</span>);</span><br><span class="line">nutritionFacts.setCarboHydrate(<span class="number">27</span>);</span><br></pre></td></tr></table></figure><p>자바 빈즈 패턴에서는 객체 하나를 만드느느데 메서드를 여러개 호출 해야한다.  객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.<br>또한 객체의 불변셩이 깨지게 되어 코드에서 버그를 생성할 수 있다.</p><h1 id="Builder-패턴"><a href="#Builder-패턴" class="headerlink" title="Builder 패턴"></a>Builder 패턴</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">calories</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">fat</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">sodium</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">carbohydrate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">      <span class="built_in">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Builder <span class="title function_">calories</span><span class="params">(<span class="type">int</span> calories)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.calories = calories;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Builder <span class="title function_">fat</span><span class="params">(<span class="type">int</span> fat)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.fat = fat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Builder <span class="title function_">sodium</span><span class="params">(<span class="type">int</span> sodium)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.sodium = sodium;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Builder <span class="title function_">carbohydrate</span><span class="params">(<span class="type">int</span> carbohydrate)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NutritionFacts <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories, <span class="type">int</span> fat, <span class="type">int</span> sodium, <span class="type">int</span> carbonhydrate)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.servingSize = servingSize;    <span class="comment">//필수</span></span><br><span class="line">      <span class="built_in">this</span>.servings = servings;          <span class="comment">//필수</span></span><br><span class="line">      <span class="built_in">this</span>.calories = calories;          <span class="comment">//선택</span></span><br><span class="line">      <span class="built_in">this</span>.fat = fat;                    <span class="comment">//선택</span></span><br><span class="line">      <span class="built_in">this</span>.sodium = sodium;              <span class="comment">//선택</span></span><br><span class="line">      <span class="built_in">this</span>.carbohydrate = carbohydrate;  <span class="comment">//선택</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NutritionFacts</span> <span class="variable">nutritionFacts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>.Builder(<span class="number">240</span>, <span class="number">8</span>)</span><br><span class="line">                                                  .calories(<span class="number">100</span>).sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build()</span><br></pre></td></tr></table></figure><p>빌더 패턴은 (파이썬과 스칼라에 있는) 명명된 선택적 매개변수를 흉내낸 것이다.<br>이런 식으로 하면 Java Beans 패턴의 set 역할을 해주면서 build()를 호출 하는 시점에 변수를 freezing 시켜 불변식을 유지 할 수 있다.<br>하지만 시간이 지날 수록 매개 변수가 늘어날 가능성이 있음을 항상 주의 해야 한다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라</title>
      <link href="/2019/01/06/effective-java-item1/"/>
      <url>/2019/01/06/effective-java-item1/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>개발자가 클래스의 인스턴스를 생성하는 방법은 new 키워드를 통한 생성자 호출이다.<br>이외에도 생성자와 별도로 정적 팩터리 메서드를 이용해서 메서드 내부에서 생성자나, 이미 생성된 인스턴스를 반환하여 클라이언트 코드에서 인스턴스를 사용 할 수 있다.</p><h1 id="정적-Static-팩터리-메서드가-좋은-점"><a href="#정적-Static-팩터리-메서드가-좋은-점" class="headerlink" title="정적(Static) 팩터리 메서드가 좋은 점"></a>정적(Static) 팩터리 메서드가 좋은 점</h1><h2 id="이름을-가질-수-있다"><a href="#이름을-가질-수-있다" class="headerlink" title="이름을 가질 수 있다."></a>이름을 가질 수 있다.</h2><p>생성자의 파라미터 시그니처만으로는 어떤 객체를 반환 할 지에 대한 특성을 이해하기 어렵다.<br>하지만, 정적 팩터리 메서드의 경우는 메서드 이름으로 충분히 유추 할 수 있기 때문에 가독성이 좋아진다.</p><h2 id="호출-될-때-마다-인스턴스를-생성하지-않아도-된다"><a href="#호출-될-때-마다-인스턴스를-생성하지-않아도-된다" class="headerlink" title="호출 될 때 마다 인스턴스를 생성하지 않아도 된다."></a>호출 될 때 마다 인스턴스를 생성하지 않아도 된다.</h2><p>new를 통해 인스턴스를 생성하게 되면, 불필요한 중복 객체를 생성할 가능성이 많이진다.<br>하나의 객체를 이용해 캐싱하고 쓰는 경우 정적 팩터리 메서드를 사용하는 게 장점이 될 수 있다.</p><p>대표적으로 Boolean에 대한 예시가 있다.<br>매번 new Boolean(false)처럼 사용을 하면 사용할 때 마다 중복되는 Boolean 객체를 생성하게 된다.  </p><p>하지만 대충 이런식으로 정적 팩터리 메서드를 제공하는 경우</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Boolean&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">FLASE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean.TRUE = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b ? TRUE : FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>쓸 데 없는 boolean 객체를 만들지 않아도 되기 때문에 메모리 관리 측면에서 유리하다.<br>또한 객체를 싱글턴(singleton)으로 제공할 수 있고, 인스턴스화 불가로 만들 수 도 있다.  </p><blockquote><p>반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제 할 수 있다.<br>이런 클래스를 <strong>인스턴스 통제(instance-controlled) 클래스</strong>라 한다.</p></blockquote><h2 id="반환타입의-하위타입-객체-Child-를-반환-할-수-있다"><a href="#반환타입의-하위타입-객체-Child-를-반환-할-수-있다" class="headerlink" title="반환타입의 하위타입 객체(Child)를 반환 할 수 있다."></a>반환타입의 하위타입 객체(Child)를 반환 할 수 있다.</h2><p>인터페이스를 사용해 하위타입 객체를 반환 할 수 있다. 인터페이스 기반 프레임워크의 핵심 기술이라고 볼 수 있다.<br>SpringFramework를 사용하는 경우에도 유용하게 사용 할 수 있다.<br>아래와 같은 예시 코드를 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PaymentService kakaoPaymentService;</span><br><span class="line"><span class="keyword">private</span> PaymentService naverPaymentService;</span><br><span class="line"><span class="keyword">private</span> PaymentService paycoPaymentService;</span><br><span class="line"><span class="keyword">private</span> PaymentService rocketPaymentService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> PaymentService <span class="title function_">getType</span><span class="params">(PaymentType payentType)</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> KAKAO: <span class="keyword">return</span> kakaoPaymentService;</span><br><span class="line">  <span class="keyword">case</span> NAVER: <span class="keyword">return</span> naverPaymentService;</span><br><span class="line">  <span class="keyword">case</span> PAYCO: <span class="keyword">return</span> paycoPaymentService;</span><br><span class="line">  <span class="keyword">case</span> ROCKET: <span class="keyword">return</span> rocketPaymentService;</span><br><span class="line">  <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>외부 결제 모듈을 사용한다고 가정 했을 때 이런식으로 Interface를 통한 하위타입 객체를 제공할 수 있다.</p><h2 id="입력-매개변수에-따라-매번-다른-클래스의-객체를-반환-할-수-있다"><a href="#입력-매개변수에-따라-매번-다른-클래스의-객체를-반환-할-수-있다" class="headerlink" title="입력 매개변수에 따라 매번 다른 클래스의 객체를 반환 할 수 있다."></a>입력 매개변수에 따라 매번 다른 클래스의 객체를 반환 할 수 있다.</h2><p>EnumSet 클래스는 public 생성자 없이 오직 정적 팩터리 메서드만 제공한다.<br>OpenJDK에서는 원소가 64개 이하이면 원소들을 long변수 하나로 관리하는 RegularEnumSet의 인스턴스를 리턴하고,<br>65개 이상이면 long배열로 관리하는 JumboEnumSet의 인스턴스를 반환한다.</p><p>클라이언트는 EnumSet 객체이면 되기 때문에 무슨객체가 리턴되든 알 필요가 없다. </p><h2 id="정적-팩터리-메서드를-작성하는-시점에는-반환할-객체의-클래스가-존재하지-않아도-된다"><a href="#정적-팩터리-메서드를-작성하는-시점에는-반환할-객체의-클래스가-존재하지-않아도-된다" class="headerlink" title="정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다."></a>정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.</h2><p>이러한 유연함은 Service Provider 프레임워크의 근간이 된다.<br>대표적인 예로 JDBC가 있다.</p><ol><li>DriverManager.registerDriver() 메서드로 각 DBMS별 Driver를 설정한다. (제공자 등록 API)  </li><li>DriverManager.getConnection() 메서드로 DB 커넥션 객체를 받는다. (service access API)</li><li>Connection Interface는 DBMS 별로 동작을 구현하여 사용할 수 있다. (service Interface)</li></ol><p>위와 같이 동작하게 된다면 차후에 다른 DBMS가 나오더라도 같은 Interface를 사용하여 기존과 동일하게 사용이 가능하다.</p><h1 id="정적-Static-팩터리-메서드의-단점"><a href="#정적-Static-팩터리-메서드의-단점" class="headerlink" title="정적(Static) 팩터리 메서드의 단점"></a>정적(Static) 팩터리 메서드의 단점</h1><h2 id="상속을-하려면-public-x2F-protected-생성자가-필요하다"><a href="#상속을-하려면-public-x2F-protected-생성자가-필요하다" class="headerlink" title="상속을 하려면 public&#x2F;protected 생성자가 필요하다."></a>상속을 하려면 public&#x2F;protected 생성자가 필요하다.</h2><p>상속을 하기 위해서는 public&#x2F;protected 생성자가 필요하니, 정적 팩터리 메서드만 제공하면 하위클래스를 만들 수가 없다.</p><blockquote><p>컬렉션 프레임 워크의 유틸리티 구현 클래스는 private 생성자만 제공하므로 상속이 불가하다.<br>이러한 제약은 상속보다 컴포지션을 사용하도록 유도되어 오히려 더 장점으로 작용한다.</p></blockquote><h2 id="정적-팩터리-메서드는-개발자가-찾기-어렵다"><a href="#정적-팩터리-메서드는-개발자가-찾기-어렵다" class="headerlink" title="정적 팩터리 메서드는 개발자가 찾기 어렵다."></a>정적 팩터리 메서드는 개발자가 찾기 어렵다.</h2><p>생성자 처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화 할 방법을 찾아야 한다.</p><h1 id="정적-static-팩터리-메서드-명명-규칙"><a href="#정적-static-팩터리-메서드-명명-규칙" class="headerlink" title="정적(static) 팩터리 메서드 명명 규칙"></a>정적(static) 팩터리 메서드 명명 규칙</h1><ul><li>from - 매개변수를 하나만 받아서 해당 타입의 인스턴스를 반환하는 메서드<ul><li>예시) Date date &#x3D; Date.from(dateStr);</li></ul></li><li>of - 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드<ul><li>예시) Set<Rank> faceCards &#x3D; EnumSet.of(JACK, QUEEN, KING);</li></ul></li><li>valueOf - from과 of의 더 자세한 버전<ul><li>BigInteger prime &#x3D; BigInteger.valueOf(Integer.MAX_VALUE);</li></ul></li><li>instance(getInstance) - 매개변수를 받는다면, 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지 않는다.<ul><li>StackWalker luke &#x3D; StackWalker.getInstance(options);</li></ul></li><li>create(newInstance) - instance&#x2F;getInstance와 같지만, 매번 새로운 인스턴스를 반환함을 보장한다.</li><li>get(Type) - getInstance와 맥락은 같으나 특정 Type을 반환할 때 사용<ul><li>Steak steak &#x3D; Food.getSteak(Meet.BEEF);</li></ul></li><li>new(Type) - newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스의 팩터리 메서드를 정의 할 때 사용<ul><li>Steak steak &#x3D; Food.newSteak(Meet.BEEF);</li></ul></li><li>(Type) - getType, newType의 같결한 버전<ul><li>Steak steak &#x3D; Food.steak(Meet.BEEF);</li></ul></li></ul><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><p>정적 팩터리 메서드는 각각의 쓰임새가 있으니, 장단점을 잘 인식하고 쓰는게 좋다.<br>대부분의 경우가 정적 팩터리 메서드로 인스턴스를 생성하는게 유리하니 무작정 public 생성자만 사용하는 습관은 고치는게 좋다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>Effective Java 3rd Edition - Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Effective-Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis 조회 시, All Element Are Null 이슈</title>
      <link href="/2018/12/30/2018-12-30-mybatis-returnInstanceForEmptyRow/"/>
      <url>/2018/12/30/2018-12-30-mybatis-returnInstanceForEmptyRow/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>사내 시스템 운영 중, SMS를 전송해 주는 부분에서 장애가 발생 하였다.<br>어디에선가 NullPointer Exception이 발생하고 있었다. stacktrace기준으로 추적해 보니,<br>Mybatis를 통해 데이터를 조회 한다음 데이터를 가공하는 과정에서 NullPointerException이 발생하고 있었다.<br>일단 디버깅 이전에 코드를 봤다. 아무리 생각해도 null이 발생하지 않을 것 같았다.</p><p>실제 코드를 돌려보았다.<br><img src="./all_element_are_null.png" alt="all_elememt_are_null 에러"></p><p>이 메세지는 무엇?<br>구글에 검색해 보니 List내의 모든 Element의 reference가 null인 것이었다.<br>그래서 size는 있지만, 가르키는 instance가 없기 때문에 Nullpointer Exception이 발생하고 있었다.</p><p>일단은 조회된 모든 컬럼이 null이면 mybatis에는 null을 리턴해 주는건가? 라는 심증만 가지고<br>절대 null이 될 수 없는 id 컬럼을 조회컬럼에 추가해 주었다.<br>(쿼리내에 outer join의 여파로 null만 나오는 쿼리였다.)<br>일단은 id 컬럼을 추가 해주니, 정상적으로 id만 값이 있고 다른 property는 모두 null인 객체가 생성되었다.<br>일단 이렇게 이슈를 종료하고자 했지만, 너무 찝찝했다</p><p>아니 왜? 모든 컬럼이 null이면 왜 객체 생성을 안하지? 우리가 원하는건 null이 아닐텐데…<br>하물며 이런상황에 앞서 조회된 내용에 대해 null 체크를 할 생각을 하니 끔찍했다.</p><p>분명 설정이 있으리라 생각하고 mybatis 사이트를 뒤져보았다.<br>뒤져보니 요런게 있었다.</p><h2 id="returnInstanceForEmptyRow"><a href="#returnInstanceForEmptyRow" class="headerlink" title="returnInstanceForEmptyRow"></a>returnInstanceForEmptyRow</h2><blockquote><p>   MyBatis, by default, returns null when all the columns of a returned row are NULL. When this setting is enabled, MyBatis returns an empty instance instead. Note that it is also applied to nested results (i.e. collectioin and association). Since: 3.4.2</p></blockquote><p>한 마디로 mybatis option중에는 <code>returnInstanceForEmptyRow</code> 이란 옵션이 있는데, 모든 컬럼이 null이면 row를 null로 리턴해 준단다. (이런 ㅡㅡ)<br>근데 설정 옵션이 true이면 null 대신에 모든 값이 null인 인스턴스를 반환해주고 false이면 null을 반환해 준다고 한다.<br>하지만 default옵션이 false이기 때문에 아무 설정도 안한 회사소스에서는 당연히 null이 리턴되게 된다.<br><code>이 옵션은 mybatis 3.4.2부터 지원한다</code> (회사에서는 mybatis&#x2F;3.4.2이상 버전을 사용하고 있다.)</p><h1 id="Test-코드"><a href="#Test-코드" class="headerlink" title="Test 코드"></a>Test 코드</h1><p>테스트 환경은 아래와 같이 설정해 보았다</p><ul><li>Spring Boot</li><li>Mybatis</li><li>H2DB</li></ul><h2 id="환경-설정"><a href="#환경-설정" class="headerlink" title="환경 설정"></a>환경 설정</h2><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyBatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Datasource</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:h2:mem:test</span></span><br><span class="line"><span class="attr">spring.datasource.initialization-mode</span>=<span class="string">always</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string"></span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">org.h2.Driver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#h2 setting</span></span><br><span class="line"><span class="attr">spring.h2.console.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.h2.console.path</span>=<span class="string">/h2-console</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Mybatis Setting</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath*:mapper/**/*SqlMap.xml</span></span><br><span class="line"><span class="attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">mybatis.configuration.return-instance-for-empty-row</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>schema.sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (</span><br><span class="line">    id <span class="type">INTEGER</span> AUTO_INCREMENT <span class="keyword">primary</span> key <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    description <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>data.sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test(id, name, description) <span class="keyword">values</span> (<span class="number">1</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><p>TestRepository.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TestRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;TestDTO&gt; <span class="title function_">getTestAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestSqlMap.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.springstudy.demo6.TestRepository&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTestAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.springstudy.demo6.TestDTO&quot;</span>&gt;</span></span><br><span class="line">        select name, description from test</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MybatisConfig.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.example.springstudy.demo6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Test-Case"><a href="#Test-Case" class="headerlink" title="Test Case"></a>Test Case</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactoryBean sqlSessionFactoryBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestConfiguration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TestContext</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>()</span><br><span class="line">                    .setType(EmbeddedDatabaseType.H2)</span><br><span class="line">                    .addDefaultScripts()</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">            sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">            sqlSessionFactoryBean.getObject()</span><br><span class="line">                     .getConfiguration()</span><br><span class="line">                                 .setMapUnderscoreToCamelCase(<span class="literal">true</span>);</span><br><span class="line">                                 </span><br><span class="line">            sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;mapper/TestSqlMap.xml&quot;</span>)&#125;);</span><br><span class="line">            <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * returnInstanceForEmptyRow 설정이 false일때,</span></span><br><span class="line"><span class="comment">     * 모든 컬럼의 데이터가 null인 경우, List내의 항목이 null이 되는 경우 테스트</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">all_element_null_test_returnInstanceForEmptyRow_false</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        sqlSessionFactoryBean.getObject()</span><br><span class="line">                             .getConfiguration()</span><br><span class="line">                             .setReturnInstanceForEmptyRow(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;TestDTO&gt; tests = sqlSessionFactoryBean.getObject()</span><br><span class="line">                .openSession()</span><br><span class="line">                .getMapper(TestRepository.class)</span><br><span class="line">                .getTestAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//모든 항목이 null인 경우, List내의 Element가 null이 되므로 제거 된다</span></span><br><span class="line">        tests.removeIf(Objects::isNull);</span><br><span class="line">        assertThat(tests).isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * returnInstanceForEmptyRow 설정이 true일때,</span></span><br><span class="line"><span class="comment">     * 모든 컬럼의 데이터가 null인 경우, 모든 property가 null인 인스턴스가 생성되는지에 대한 테스트</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">all_element_null_test_returnInstanceForEmptyRow_true</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        sqlSessionFactoryBean.getObject()</span><br><span class="line">                             .getConfiguration()</span><br><span class="line">                             .setReturnInstanceForEmptyRow(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;TestDTO&gt; tests = sqlSessionFactoryBean.getObject()</span><br><span class="line">                .openSession()</span><br><span class="line">                .getMapper(TestRepository.class)</span><br><span class="line">                .getTestAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//모든 항목이 null인 경우, List내의 Element가 Empty 인스턴스를 가르키므로</span></span><br><span class="line">        <span class="comment">//제거되지 않는다.</span></span><br><span class="line">        tests.removeIf(Objects::isNull);</span><br><span class="line">        assertThat(tests).isNotEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트 코드 실행 결과 returnInstanceForEmptyRow &#x3D; true로 설정 할 경우, empty 객체가 나와 내가 생각한 대로 사용할 수 있게 되었다.</p><h1 id="returnInstanceForEmptyRow-옵션-설정-방법"><a href="#returnInstanceForEmptyRow-옵션-설정-방법" class="headerlink" title="returnInstanceForEmptyRow 옵션 설정 방법"></a>returnInstanceForEmptyRow 옵션 설정 방법</h1><h2 id="mybatisConfig-xml"><a href="#mybatisConfig-xml" class="headerlink" title="mybatisConfig.xml"></a>mybatisConfig.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;returnInstanceForEmptyRow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configurtion</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis.configuration.return-instance-for-empty-row</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="http://www.mybatis.org/mybatis-3/configuration.html">http://www.mybatis.org/mybatis-3/configuration.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018년 회고</title>
      <link href="/2018/12/16/2018-12-16-remind/"/>
      <url>/2018/12/16/2018-12-16-remind/</url>
      
        <content type="html"><![CDATA[<h1 id="새-직장으로-이직"><a href="#새-직장으로-이직" class="headerlink" title="새 직장으로 이직"></a>새 직장으로 이직</h1><p>2017년 8월 중순 중소 SI업체를 용기있게(?) 뛰쳐나왔다.<br>그 곳에서는 오직 나 한명으로 여러 프로젝트를 돌리고 있었고, 같이 일할 선임개발자도 없었기 때문에<br>굉장히 나름대로 스트레스를 받고 있었다.<br>그리고 모든 프로젝트가 나에게 의존적이었기 때문에 관리해야 할 사이트도 많았고..<br>매일매일 프로젝트 했던 사이트들에 대한 유지보수 전화를 받아가며, 신규 프로젝트를 진행하고 있었다.<br>이렇게 개발자로서 소모되어 가고 있다는 생각이 들어 과감하게 퇴사를 하게되었다. 다음에는 어느정도 조직이 구성되어있고 내가 조직원으로서 일할 수 있는 직장을 찾아야겠다! 라는 생각을 하게되었다.<br>이직하고자 하는 회사의 조건은 이렇다.</p><ol><li>개발자 한명이 기획, 개발, 유지보수, 영업을 담당하는 작은회사는 가지 않겠다.</li><li>더 이상 SI는 하지 않겠다. (지방 출장이 잦고, 프로젝트 단위로 사업이 돌아가는 곳은 가지 않겠다.)</li><li>근무지 한 곳에서만 근무 할 수 있는 환경 (예전에는 지방을 여기저기 많이 다녔다.)</li><li>시니어 개발자와 주니어 개발자 층이 어느정도 있고, 같이 의논하며 개발할 수 있는 환경</li><li>Spring 4 &#x2F; Java 1.8 이상을 사용하여 개발하는 조직</li><li>내가 더 발전할 수 있는 조직</li><li>연봉도 많이 올려주면 좋고~! ^^</li></ol><p>하지만 생각보다 이직은 쉽지 않았다. (특히나 선퇴사 후이직 이어서.. 11월쯤에는 굉장히 쫄렸다.)<br>일단 서비스 회사로 이직을 목표로 잡았지만, 기존의 했던 업무가 제조업이나 MES관련 개발을 주로 했었기 때문에 서비스 회사에서는 대부분의 서류 낙방을 경험했다. (이력서를 처음 써봐서 정말 못써서 그럴 수도 있겠지만.)<br>서류 한 군데만 붙어라… 면접은 완전 잘 볼 자신있다!라는 생각으로 서류만 2개월 이상 쓰다보니 10월쯤에는 서류 합격하는 회사가 몇 군데 있었다. 서류합격 메일을 받았을 때 기분이란….크 면접일자가 정해지고, 인터넷에 돌아다니는 예상 면접질문을 바탕으로 하나하나 정리를 하였다. 대게 기술질문은 그 테두리 안에서 나온다는 것이 여러사람들의 의견이었다.<br>그리고 9월쯤엔 대기업 신입공채를 준비했어서, 오랜만에 컴퓨터 이론을 한번 정리 했었는데 이 부분이 정말 도움이 많이 되었다. 자주 안보는 만큼 지금도 기억에서 많이 사라졌는데, 가끔씩 리마인드를 해주는 것이 좋겠다.</p><p>면접은 두 군데정도 봤는데 둘 다 자신감있게 봤었다.<br>아무래도 SI하면서 고객사 상대로 발표도 하고 회의도 자주 하다보니, 남들이랑 대화하고 그런거는 긴장되지 않았다.<br>그렇기 때문에 면접을 보면서 긴장을 덜하고 면접장에서 어필할 수 있었던 것 같다.<br>결국 최종적으로 한 곳의 회사만 합격을 하였는데, 그 곳이 NHN티켓링크이다.<br>최종합격 후 천만다행이라는 생각이 들었고, 2018년 1월 초에 입사를 하게 되었다.</p><h1 id="우리-팀의-개발문화"><a href="#우리-팀의-개발문화" class="headerlink" title="우리 팀의 개발문화"></a>우리 팀의 개발문화</h1><p>예전 SI할 때는 혼자서 사이트를 다 만들어야 했기 때문에, 프론트엔드도 하고 백엔드도하고, 서버설치 등을 혼자 다했다. 하지만 여기와서는 인프라 관련해서는 시스템팀이 별도로 있었고, DBA팀도 별도로 있었다. 내가 할 업무는 티켓링크 백엔드 개발과 약간의 간단한 프론트엔드 작업만 하면되었다.<br>기획팀도 별도로 나뉘어져 있다보니, 내가 직접 기획서를 쓰지 않아도 되고 개발에만 집중 할 수 있다는 환경이 참 좋았다.</p><h2 id="git-flow를-사용한-브랜치-전략"><a href="#git-flow를-사용한-브랜치-전략" class="headerlink" title="git flow를 사용한 브랜치 전략"></a>git flow를 사용한 브랜치 전략</h2><p>SI할때는 SVN만 사용해봤는데 그냥 master에 커밋치던 나에게는 신세계였다. 뭔가 구글링하면서 지나쳤던 얘기들을 실천하고 있는 조직이라는 생각이 들었다.<br>git도 처음 사용해 봤는데, SVN보다 더 유연하고 좋다는 생각이 들었다. (특히 브랜치를 왔다갔다 하면서 작업할 수 있는 점이 좋았던 것 같다.)</p><h2 id="Pull-Request-코드리뷰"><a href="#Pull-Request-코드리뷰" class="headerlink" title="Pull Request + 코드리뷰"></a>Pull Request + 코드리뷰</h2><p>두 번째로는 Pull Request를 올려서 코드리뷰를 강제화 하도록 하는 문화이다.<br>첫 업무를 받아서 PR을 올렸을 때는 Conversation이 50개 이상이 달려서 코드리뷰를 엄청나게 받았다.<br>뭔가 탈탈 털렸다라는 느낌도 받았고, 앞으로 공부해야 할 게 많구나라는 생각이 들었다.<br>한 가지 아쉬운점은… <code>코드리뷰를 하는 사람만 한다.</code> 다른사람들도 적극적으로 해주면 좋을텐데..라는 생각이 들었다.<br>처음에는 나도 다른사람의 코드를 리뷰해줘야지! 라는 생각으로 코드리뷰에 참여하려고 했지만.. 한마디도 달 수 없었다. 그때 딱 드는 생각이, <strong>“내가 아는게 없어서 코드리뷰를 해줄 수가 없구나.. 코드리뷰에 한마디라도 할 수 있도록 공부하자”</strong> 라는 생각을 하게 되었다.<br>돌이켜보면 나는 여태까지 <code>&quot;공부하지 않는 개발자&quot;</code>였다.<br>팀원들을 보면 아침에 일찍와서 책을보는 분도 계셨고, 따로 스터디모임을 하시는 분도 계셨다.<br>입사초기에 나는 살 좀 빼야지.. 라는 생각으로 아침운동을 다녀서 아침에 일찍 공부하기는 힘들었다. 그래서 주로 퇴근 후나 주말에 내가 하고자 하는 공부를 하였다. 그리고 꼭 공부한 내용은 블로그를 작성해서 남겨야겠다고 생각했다.<br>공부는 조금조금씩 계속 했지만, 본격적으로 블로그를 설치하고 시작한 것은 7월 정도인 것 같다.<br>현재 4년차에 Spring기반으로 개발을 계속 해왔다고는 하지만 Spring의 기본을 공부해본적이 없었다.<br>여태까지는 그냥 <code>이렇게 하면 이렇게 되네~</code> 방식의 개발을 해와서, 뭐가 안되면 원인 파악하기가 무척이나 어려웠다.<br>그래서 처음에는 <strong>Spring core</strong>에 대한 공부를 시작했다. 토비의 Spring 책도 사고, 회사 소스에 적용된 기술들을 하나하나 파보기 시작했다. 하나하나 익히고 나니 너무 유용한 기술들이 많이 있었고, 개발할 때 직접 써먹으면서 실전 응용력을 키울 수 있었던 것 같다.</p><h2 id="주간-기술공유"><a href="#주간-기술공유" class="headerlink" title="주간 기술공유"></a>주간 기술공유</h2><p>세 번째는 매주 목요일 기술공유 시간을 짧게 갖는다.<br>팀원 한 명씩 돌아가면서 신기술에 대한 공유나 코드리뷰등을 하는 시간이다. 이런 걸 해보지 않아서 처음에는 무슨 내용을 공유하지?라는 걱정이 앞섰는데, 다행히도 공유 순서가 가까워지면 항상 공유 할 내용이 있었다. 그리고 내 순서가 아니어도 최대한 공유를 하려고 노력했다. (순서가 아니어도 또 해도 된다. 하지만 내 순번에는 또 공유를 해야한다. ㅎㅎ) 최대한 공유를 많이 하려고 노력했고, 기술공유 준비를 하면서 내가 했던 일들이나 기술에 대해 다시 한번 정리하는 시간이 되어 개인적으로 기술에 대한 기억을 오랫동안 보존할 수 있는 방법이었다.<br>또 다른사람의 기술공유를 들었다가 내가 필요할 때 써먹거나, 미처 몰랐던 내용들도 있어서 개발팀 문화 중에 나름 유의미한 시간이라고 생각하고 있다.</p><h1 id="블로그-시작"><a href="#블로그-시작" class="headerlink" title="블로그 시작"></a>블로그 시작</h1><p>올해 목표 중 하나가 블로그에 공부한 내용에 대한 글을 꾸준히 작성하는 것이었다.<br>블로그는 7월쯤에 만들어서 꾸준히 작성하려고 노력하고 있다.</p><p>현재까지 수를 보니..</p><ul><li>7월 - 5개</li><li>8월 - 6개</li><li>9월 - 3개</li><li>10월 - 2개</li><li>11월 - 7개</li><li>12월 - 8개</li></ul><p>정도 해서 총 31개의 포스팅을 작성했다. 시리즈 물로 된 글도 많았고, 회사에서 사용한 기술들을 다시 좀 다듬어서 기록으로 남긴 것들도 있다. (회사 업무내용을 최대한 제외하려 한게 참 힘들었다ㅜㅜ)<br>처음에는 블로그도 안써봐서 글 쓰는데 시간도 오래걸리고 뭐 어떻게 써야하나…라는 생각으로 다른 블로그들을 참고하며 많이 썼던것 같다. 그리고 하나 쓰는데 시간도 꽤 오래 걸린것 같다.<br>한 30개의 글을 써보니 대충 블로그 쓰는 법도 감이 왔다.</p><ul><li>일단 내가 100% 이해하지 못한 상황에서 글을 쓸 수 없다.</li><li>처음에는 블로그 포스팅 수를 늘리고 싶어서 무조건 post부터 생성하고 봤는데, 글의 진도가 나가지 않았다.</li><li>블로그를 빠르고 쉽게 작성하기 위해서는 목차를 먼저 잡고 그에 대한 지식을 채운 다음에 각 섹션별로 담아내고자 하는 내용을 짧게 정리했다.</li><li>예제가 필요한 경우 미리 예제에 대한 실습을 마쳐 놓아야 한다.<ul><li>그때그때 예제코드 작성하면 시간이 오래걸리고, 내가 무슨 글을 쓰던 중이었는지 까먹게 된다.</li></ul></li></ul><p>블로그를 쓰다보니 지식에 대한 인덱스도 나름 생기고, 나중에 기억 안나도 예제코드를 찾아볼 수 있어서 좋았다.<br>앞으로도 계속 블로그를 작성할 예정인데, 제발 귀찮아지지만 않았으면 좋겠다..!</p><h1 id="회사-업무"><a href="#회사-업무" class="headerlink" title="회사 업무"></a>회사 업무</h1><h2 id="1-2월에는-회사-적응도-하고-바로-또-업무를-할당-받았다"><a href="#1-2월에는-회사-적응도-하고-바로-또-업무를-할당-받았다" class="headerlink" title="1~2월에는 회사 적응도 하고, 바로 또 업무를 할당 받았다."></a>1~2월에는 회사 적응도 하고, 바로 또 업무를 할당 받았다.</h2><p>나의 첫 업무는 티켓링크 카카오톡 알림톡 연동이었다. 기존에는 SMS&#x2F;MMS만 사용했는데, 카카오톡 알림톡을 지원하도록 하는 업무였다. 지금 생각해보면 업무는 단순했다. 카카오톡 API를 연동 인터페이스만 구현해주면 되는 것이었는데, 외부 API 연동을 처음 해보는터라 시간도 오래걸리고, 회사 소스를 파악하면서 해야해서 1달이상의 시간이 걸렸던 것 같다.<br>기존 코드의 리팩토링도 해가면서 해서, 나름 재미있게 개발을 했던 첫 업무였다.</p><h2 id="3-4월에는-캡차-시스템-개발을-진행했다"><a href="#3-4월에는-캡차-시스템-개발을-진행했다" class="headerlink" title="3~4월에는 캡차 시스템 개발을 진행했다."></a>3~4월에는 캡차 시스템 개발을 진행했다.</h2><p>티켓시스템에는 사람들이 좌석을 빨리 차지하기 위해 매크로를 많이 쓴다.<br>최근에는 뉴스기사에도 아이돌 콘서트니, 인기 공연에 대해 매크로를 돌려서 빠르게 예매한 다음에 몇배의 가격으로 불려서 암표를 파는 사람이 많다는 기사가 나왔다. 최소한이라도 예방하기 위해 티켓링크에서는 캡차 도입을 고민하고 있었다. 구글의 리캡차나 국내의 캡차 솔루션을 도입하자라는 의견도 나왔고, 직접 구축하는 것이 좋다!라는 의견이 나오고 있을때쯤 집에서 한번 오픈소스를 이용해서 간단하게 캡차를 만들어보았다. 어렵지 않게 예시를 만들수 있었고, 다음날 바로 팀장님께 보여드렸다. 그렇게 캡차 개발은 내 업무가 되었다^^<br>나름 보안과 성능을 생각하며, 이미지 캐싱등의 작업을 하였다. 그리고 캡차를 사용하기 위해서는 Global캐시 Store가 하나는 필요했다. 이로인해 팀에서 NoSQL 도입을 생각하게 되었다.<br>캡차 개발 완료 후 nGrinder를 통해 성능테스트로 진행하였는데 15,000 TPS정도의 높은 성능이 나와서 나름 만족하고 있었다.(하지만 아직 회사에서 인기 공연이나 예매에 사용을 안해서.. 아쉬웠다.)</p><h2 id="Redis-도입"><a href="#Redis-도입" class="headerlink" title="Redis 도입"></a>Redis 도입</h2><p>캡차 사용을 위해 Redis를 도입하게 되었다. 원래 사용하는 NoSQL이 있지만, 추가적으로 NoSQL서버를 자체 구축할 예정이었다. (이유는 따로 적지 않겠다.) 여러가지 NoSQL이 물망에 올랐다. Redis, Arcus등 여러가지 Key-value store가 거론되었지만, 내 욕심 상 Redis를 해보고 싶었다. (아무래도 Key-value store 1순위인 Redis를 써보고 싶었다.)<br>Redis를 도입하면서 단순하게 서버에 Redis만 설치해서 쓰고 싶지는 않았다. 인프라 시스템은 항상 scale out을 고려해야 했기 때문에, 주변에서 Docker를 이용해서 설치 해보라는 얘기가 나왔다.<br>Docker는 난생 처음 들어보는 거였는데.. Docker에 대한 삽질을 어마무시하게 하면서 거의 3주만에 Redis 설치와 Cluster 설치까지 완료했다. 이 기회를 가지면서 Redis에 대한 전반적인 이해가 생기게 되었고, 나름 삽질을 거치면서 Docker라는 시스템도 어느정도 이해하게 되었다. (다시는 까먹지 않게 팀내에서도 3일에 걸쳐 공유를 하고 11부작 정도로 블로그도 작성해 두었다^^)</p><h2 id="결제시스템-개편"><a href="#결제시스템-개편" class="headerlink" title="결제시스템 개편"></a>결제시스템 개편</h2><p>어쩌다보니 내가 티켓링크 결제 시스템 ‘부’가 되어서 티켓링크 결제시스템 개편 업무를 많이 했다.<br>Payco결제, IC카드결제, 네이버페이 연동등을 경험하며, 외부 빌링업체의 결제 프로세스를 경험 할 수 있던 기회였다.<br>네이버페이는 거의 처음부터 만들게 되었는데, Web에서의 결제, App에서의 결제를 모두 봐야 해서 꽤 고생했던 기억이 있다. 하지만 결제관련 Flow는 어느정도 알게 되었던 업무였다.</p><h2 id="MSA시도-해보기"><a href="#MSA시도-해보기" class="headerlink" title="MSA시도 해보기"></a>MSA시도 해보기</h2><p>티켓링크 시스템은 Monolothic 시스템 구조를 가지고 있다. 그렇기 때문에 빌드시간도 만만치않게 걸리고 배포하려고 해도 사이드 이펙트가 발생할 확률이 높다. 그렇기 때문에 올해 말부터 하나씩 하나씩 쪼개는 작업을 진행하고 있다. MSA까지는 아니어도 점진적으로 모듈을 분리하여, 빌드 시간을 단축 시키고, 시스템 안정성을 높이기 위함에 있다.<br>이 부분에 대해서는 나도 의견을 많이 내고 시니어 개발자분들도 관심있게 보는 부분이어서, 내년에 더 활발하게 작업이 진행 될 것 같다.</p><h1 id="내년에는"><a href="#내년에는" class="headerlink" title="내년에는.."></a>내년에는..</h1><p>내년 공부의 시작은 개발 필독 서적을 몇가지 읽어보려고 한다.</p><ul><li>clean code</li><li>TDD 개발 방법론</li><li>Effective Java 3rd Edition<br>(2rd Edition은 한번봤는데, Java8에 대한 내용이 추가되었다고 하니 한번더 봐야겠다.)</li><li>Java ORM 표준 JPA프로그래밍</li><li>현재 MyBatis기반으로 시스템이 구성되어있는데, 새로 만드는 시스템은 무조건 JPA를 도입하자고 얘기가 나오고 있다. 이전 회사에서 JPA사용경험이 있어서 나도 JPA도입을 대찬성하고 있는데, 더 지식을 쌓고 개발할 필요성을 느끼고 있다. 그래서 이 책을 아마 1순위로 공부하지 않을까.. 싶다.</li></ul><p>회사 업무에서는 주니어 개발자이지만, 목소리를 내보려 노력하고 있다.<br>팀에서도 그런 분위기를 조성하려하고 있는 것 같고, 내 의견이 묵살되더라도 생각이라도 해보고, 다른사람의 의견과 비교할 수 있기 때문에 적극적으로 목소리를 내보고자 한다.</p><h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리.."></a>마무리..</h1><p>올해 회고를 쭉 작성해보니 생각보다 많은 일을 했다는 생각이 든다. 그리고 그 과정 속에서 한단계 더 성장한 개발자가 되었다고 나름 생각하고 만족하고 있다. 회고를 쓰면서 회사 얘기가 조금 나와서.. 글을 좀 수정해야 할 경우가 생길 수도 있지만.. 딱히 그럴만한 내용은 없다고 생각이 든다.<br>앞으로는 1년 단위로 회고를 작성하여 한번씩 되돌아보고 추억할 수 있는 시간이 되면 좋겠다.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 2018-remind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker기반 Redis 구축하기 - (11) Redis-Cli Docker로 사용하기</title>
      <link href="/2018/12/07/2018-12-07-docker-11/"/>
      <url>/2018/12/07/2018-12-07-docker-11/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>Redis를 운영하다 보면 redis-cli를 주로 사용하게 되는데<br>항상 docker exec 명령을 통해 docker container 내의 redis-cli를 사용하여 불편한 점이 많았습니다.</p><p>찾아보니 간단하게 Docker로 Redis-cli를 사용할 방법이 있어 기록을 남기게 되었습니다.</p><h1 id="Docker로-Redis-cli-접속하기"><a href="#Docker로-Redis-cli-접속하기" class="headerlink" title="Docker로 Redis-cli 접속하기"></a>Docker로 Redis-cli 접속하기</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it \                                  </span><br><span class="line">                --<span class="built_in">rm</span> \ </span><br><span class="line">                --net host \ </span><br><span class="line">                redis:5.0.0-alpine redis-cli \</span><br><span class="line">                -a <span class="string">&quot;&lt;password&gt;&quot;</span> \</span><br><span class="line">                -p &lt;port&gt;</span><br></pre></td></tr></table></figure><ul><li>it 옵션 : container와 conversation이 가능한 옵션</li><li>rm옵션 : container가 종료되면 container를 삭제</li><li>net옵션 : network 옵션 </li><li>redis:5.0.0-alpine redis-cli : redis:5.0.0-alpine이미지의 redis-cli를 사용</li><li>a 옵션 : redis에서 requirepass를 사용하는 경우 password를 적어준다.</li><li>p 옵션 : 접속 port</li><li>h 옵션 : 접속하고자 하는 host (옵션 안주면 127.0.0.1로 접속한다)</li></ul><h1 id="Docker-Redis-cli로-cluster-설정하기"><a href="#Docker-Redis-cli로-cluster-설정하기" class="headerlink" title="Docker Redis-cli로 cluster 설정하기"></a>Docker Redis-cli로 cluster 설정하기</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it \                                  </span><br><span class="line">                --<span class="built_in">rm</span> \ </span><br><span class="line">                --net host \ </span><br><span class="line">                redis:5.0.0-alpine redis-cli \</span><br><span class="line">                -a <span class="string">&quot;&lt;password&gt;&quot;</span></span><br><span class="line">                --cluster create host:port host:port host:port  \  //master host&amp;port</span><br><span class="line">                 host:port host:port host:port \ //slave host&amp;port</span><br><span class="line">                --cluster-replicas 1 </span><br></pre></td></tr></table></figure><ul><li>–cluster : cluster mode 명령어 수행</li><li>create : cluster 생성 명령</li><li>–cluster-replicas 1 : Redis Replication 명령, Master node 1개당 Slave node 1개를 의미</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker기반 Redis 구축하기 - (10) Redis Cluster Mode 설정하기</title>
      <link href="/2018/12/03/2018-12-03-docker-10/"/>
      <url>/2018/12/03/2018-12-03-docker-10/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>이전 장 까지 했던 Redis 구조는 <code>Redis Replication + Redis Sentinel</code>을 이용한 failover 기능을 구성하고 있었습니다. Spring Application에서 Jedis를 이용하여 Application sharding을 구성하여 사용을 하였습니다. 이렇게 Redis를 잘 사용하나 싶었지만, 최근 Spring Cache Abstraction에 대해 공부했었고, Redis Replication + Sharding + Failover를 사용하면서 <strong>Spring-Data-Redis를 사용할 방법이 없을까?</strong> 라는 생각을 하게 되었습니다.</p><p>맨 처음에 회사에서 Spring + Redis연동을 할 때 당연히 Spring-Data-Redis를 염두하고 시작을 했었지만, 어느 블로그에서 <strong>Spring-Data-Redis는 Sharding을 지원하지 않는다!</strong> 라는 절망적인 얘기를 보고 여태까지 Docker를 이용해 설치한 방식에서 Jedis를 이용한 Sharding을 이용하고 있었습니다.</p><p>그 이후, Redis 관련 문서를 쭉 보던 중.. Redis 공식 홈페이지에서 <code>Redis Cluster Mode</code>에 대한 내용을 보게 되었습니다.<br>그 내용을 요약하자면</p><ul><li>Redis3 버전 부터 Redis는 <code>Cluster Mode</code>를 지원한다.</li><li>Cluster Mode에서는 Redis Sentinel의 도움없이 <code>Cluster 자체적으로 Failover를 진행</code>한다.</li><li>Cluster Mode에서는 Master-Slave 노드 구조를 가질 수 있고, <code>노드 간 Replication을 지원</code>한다.</li><li>Cluster Mode에서는 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행<br><code>Auto Sharding을 지원</code>한다 (이야!!!!!!!!!!!!)</li><li>Application Sharding이 필요없기 때문에, <code>Spring-Data-Redis 사용이 가능하다.</code><br>(사실은 이 목적 때문에 Cluster Mode 설치를 해보게 되었습니다.)</li></ul><h1 id="기존에-설치한-Redis-구조와-다른-점은"><a href="#기존에-설치한-Redis-구조와-다른-점은" class="headerlink" title="기존에 설치한 Redis 구조와 다른 점은?"></a>기존에 설치한 Redis 구조와 다른 점은?</h1><h2 id="이전-장까지-설치-했던-Redis-구조"><a href="#이전-장까지-설치-했던-Redis-구조" class="headerlink" title="이전 장까지 설치 했던 Redis 구조"></a>이전 장까지 설치 했던 Redis 구조</h2><p><img src="./Redis-Cluster-archi.PNG" alt="Redis-Cluster-archi"></p><ul><li>Master - Slave -Slave 구조</li><li>Redis Sentinel을 이용한 Master 감시 + Fail over 기능 지원</li><li>HAProxy를 이용한 Master &#x2F; Slave 접근 Port 분리</li></ul><h2 id="새롭게-구성한-Redis-Cluster"><a href="#새롭게-구성한-Redis-Cluster" class="headerlink" title="새롭게 구성한 Redis Cluster"></a>새롭게 구성한 Redis Cluster</h2><p><img src="./new-redis-cluster.PNG" alt="new-redis-cluster"></p><ul><li><p>HAProxy는 5000번 포트만 사용하도록 축소 5001~5005는 불필요하기 때문</p><ul><li>앞으로는 무조건 Master에만 통신</li><li>어떤 Node와 통신하여 데이터를 set하거나 get 할 수 있음 (Cluster Mode 지원)</li><li>어떤 Node에 set하더라도 자동으로 Sharding</li></ul></li><li><p>감시자 역할의 Sentinel 제거 </p><ul><li>Cluster Mode에서는 Redis Node끼리 감시하며 Fail over가 가능합니다.</li></ul></li><li><p>Slave 갯수도 한개로 축소</p></li></ul><h1 id="Cluster-Mode에서-지원하는-기능"><a href="#Cluster-Mode에서-지원하는-기능" class="headerlink" title="Cluster Mode에서 지원하는 기능"></a>Cluster Mode에서 지원하는 기능</h1><h2 id="Fail-Over"><a href="#Fail-Over" class="headerlink" title="Fail Over"></a>Fail Over</h2><p><img src="./new-redis-cluster2.PNG" alt="new-redis-cluster2"></p><ul><li>Redis Cluster Mode에서는 기존의 Sentinel을 별도로 설치하여 감시자 역할을 하는 것에서 벗어나 Cluster 자체적으로 Node들을 감시하고 Failover를 수행 할 수 있습니다.</li><li>Redis Cluster Mode를 사용하기 위해서는 각 Redis Node 별로 2개의 port가 열려 있어야 합니다.<ul><li>6379, 6380 default - Redis 서버 접속 포트</li><li>16379, 16380 default  <code>(접속 포트 + 10000)</code> - Redis Cluster Bus</li></ul></li><li>Cluster Bus를 이용해 Redis Cluster는 각 노드를 감시하고 서버 다운 시 또는 Connection 유실 시 Fail over를 수행합니다.</li><li>Cluster Bus는 노드 간 데이터 교환에 대해 다른 바이너리 프로토콜을 사용합니다.</li><li>이 프로토콜은 대역폭과 처리 시간을 적게 사용하여 노드 간에 정보를 교환하는 데 더 적합합니다.</li></ul><h2 id="Auto-Sharding"><a href="#Auto-Sharding" class="headerlink" title="Auto Sharding"></a>Auto Sharding</h2><ul><li>Redis Cluster Mode에서는 자동으로 Cluster Node에 대한 자동 샤딩을 제공합니다.</li><li>Redis Cluster에는 16384개의 slot이 있으며, slot에 대한 구간 별로 샤딩이 가능합니다.</li><li>slot을 계산하기 위해 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행합니다.<ul><li>[0-5500] 까지는 1번 Redis Node에 저장</li><li>[5501-11000] 까지는 2번 Redis Node에 저장</li><li>[11001-16384] 까지는 3번 Redis Node에 저장</li><li>Redis Node가 scale out 되는 경우 Master Node 수를 나눈 만큼 대역이 할당</li></ul></li></ul><h2 id="Redis-cli를-이용한-cluster-명령"><a href="#Redis-cli를-이용한-cluster-명령" class="headerlink" title="Redis-cli를 이용한 cluster 명령"></a>Redis-cli를 이용한 cluster 명령</h2><p>Redis 5버전에 포함된 redis-cli 버전 부터 cluster 옵션이 추가 되었습니다.<br>Redis 4버전 이하에 대해서는 별도로 Ruby 기반의 프로그램을 설치해야 되서 번거로워서, Redis 5버전으로 설치를 해보았습니다. (성능도 더 좋을라나?ㅎ)</p><h3 id="Redis-Cluster-생성"><a href="#Redis-Cluster-생성" class="headerlink" title="Redis Cluster 생성"></a>Redis Cluster 생성</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.137.101:6379 192.168.137.102:6379 192.168.137.103:6379 \</span><br><span class="line">192.168.137.102:6380 192.168.137.103:6380 192.168.137.101:6380 \</span><br><span class="line">--cluster-replicas 1</span><br></pre></td></tr></table></figure><ul><li>Redis Cluster를 생성하기 위해서는 Master Node가 최소 3개 이상 필요합니다.</li><li>맨 처음 등록하는 3개의 노드가 Master Node</li><li><code>--cluster-replicas 1</code> 의 의미는 각 Slave Node가 1개임을 의미합니다.</li><li>6개의 노드가 등록 되었다면 처음 3개는 Master, 뒤의 3개는 Slave가 됩니다</li><li>Slave는 선언된 순서 대로 Master의 Slave로 등록 됩니다<ul><li>192.168.137.101:6379 -&gt; 192.168.137.102:6380</li><li>192.168.137.102:6379 -&gt; 192.168.137.103:6380</li><li>192.168.137.103:6379 -&gt; 192.168.137.101:6380</li></ul></li></ul><p><img src="./cluster-setting.PNG" alt="cluster-setting"></p><p><img src="./cluster-setting2.PNG" alt="cluster-setting2"></p><p>redis-cli에 접속하여 cluster nodes 명령어로 cluster를 구성하는 nodes에 대한 정보를 조회해 보았습니다.</p><p><img src="./cluster-nodes.png" alt="cluster-nodes"></p><h3 id="Redis-Node-ADD-x2F-REMOVE"><a href="#Redis-Node-ADD-x2F-REMOVE" class="headerlink" title="Redis Node ADD &#x2F; REMOVE"></a>Redis Node ADD &#x2F; REMOVE</h3><p>새로운 노드를 추가하는 과정은 기본적으로 2가지입니다.</p><ul><li>새로운 Master를 추가하는 경우</li><li>새로운 Slave를 추가하는 경우</li></ul><h3 id="Master-추가"><a href="#Master-추가" class="headerlink" title="Master 추가"></a>Master 추가</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.137.104:6379 192.168.137.101:6379</span><br></pre></td></tr></table></figure><ul><li>위 명령은 cluster에 새로운 노드를 추가하는 명령어입니다.</li><li>192.168.137.101:6379 구성 된 Cluster에 192.168.137.104:6379 추가한다는 명령어입니다.</li><li>cluster를 지정할 때는 master node를 아무거나 지정하면 됩니다. (192.168.137.101~103:6379)</li><li>여기까지 했을 때는 Cluster에 일원이 되어 Cluster로 묶여는지나, <code>실제로 데이터는 저장 되지 않습니다.</code></li><li>hash slot이 할당 되지 않았기 때문에 데이터는 저장되지 않습니다.</li><li><code>re-sharding</code>을 통해 slot의 대역을 할당 받아야 합니다.</li></ul><h3 id="Slave-추가"><a href="#Slave-추가" class="headerlink" title="Slave 추가"></a>Slave 추가</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave</span><br></pre></td></tr></table></figure><ul><li>위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.</li><li>이 경우에는 새롭게 추가된 노드를 <code>복제본의 수가 적은 마스터</code> 나 임의의 마스터에 대한 Slave로 추가됩니다.</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave\</span><br><span class="line">--cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e1</span><br></pre></td></tr></table></figure><ul><li>위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.</li><li>이 경우에는 master node를 지정하기 때문에 특정 master-id에 해당하는 master node의 slave로 추가됩니다.</li></ul><h2 id="Node-제거"><a href="#Node-제거" class="headerlink" title="Node 제거"></a>Node 제거</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node 192.168.137.101:6379 `&lt;node-id&gt;`</span><br><span class="line">redis-cli --cluster del-node 192.168.137.101:6379</span><br><span class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br></pre></td></tr></table></figure><ul><li>위 명령은 Redis Cluster의 node를 제거하는 명령어입니다.</li><li>Redis Cluster에 포함된 아무 node를 적어준다 <code>192.168.137.101:6379 는 Redis Cluster 노드 중 하나</code></li><li>node-id는 삭제하고자 하는 node의 id입니다.</li><li>node-id는 cluster nodes 명령어를 통해 검색하여 적어줍니다.</li><li>Slave는 막 지울 수 있습니다!</li><li>하지만 <strong>Master는 노드에 저장된 내용이 하나도 없어야 삭제가 가능합니다.</strong></li><li>지울 수 있는 대안으로는 수동으로 failover를 하여 slave로 만든 다음에 삭제를 하는 방법이 있습니다.</li></ul><h3 id="Re-sharding"><a href="#Re-sharding" class="headerlink" title="Re-sharding"></a>Re-sharding</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 192.168.137.101:6379</span><br></pre></td></tr></table></figure><ul><li>위 명령은 현재 cluster에 대한 reshard를 수행하는 명령어입니다.</li><li>cluster내의 master node 아무거나 써주면 자동으로 cluster node를 스캔하여 reshard를 수행합니다.</li><li>resharding 중에도 무중단으로 redis를 사용할 수 있습니다.</li><li>하지만 resharding을 <strong>수행하는 key에 대해서는 lock이 걸립니다.</strong></li><li>만약 resharding 대상이 많은 경우에는 redis 서버가 중지되었다가 다시 시작 될 수 있습니다.</li></ul><h1 id="Redis-설치"><a href="#Redis-설치" class="headerlink" title="Redis 설치"></a>Redis 설치</h1><h2 id="Docker-설정하기"><a href="#Docker-설정하기" class="headerlink" title="Docker 설정하기"></a>Docker 설정하기</h2><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">   <span class="attr">redis-master:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">redis:5.0-alpine</span></span><br><span class="line">      <span class="attr">build:</span></span><br><span class="line">         <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">         <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">      <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">      <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=&lt;password&gt;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6379</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../../new_redis-data/redis1:/data&quot;</span></span><br><span class="line">      <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">   <span class="attr">redis-slave:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">redis:5.0-alpine</span></span><br><span class="line">      <span class="attr">build:</span></span><br><span class="line">         <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">         <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">      <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">      <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=&lt;password&gt;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6380</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../../new_redis-data/redis2:/data&quot;</span></span><br><span class="line">      <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><ul><li>redis-cli의 cluster option을 사용하기 위해 redis:5.0-alpine 버전을 사용하였습니다.</li><li>redis:5.0.0이 RELEASE 버전이지만, Dockerfile에서 sed 명령어 사용 시, <code>Permission denied</code>가 발생하는 버그가 있습니다.</li><li>network_mode 는 <code>host</code>로 설정. <code>Docker Redis는 NAT에 대한 지원을 하지 않습니다.</code></li><li>외부 볼륨 연동을 위해 ..&#x2F;..&#x2F;new_redis-data&#x2F;master 폴더와 docker container 내의 &#x2F;data 폴더를 연동하였습니다.</li><li>container down 시 항상 재시작 하도록 restart policy를 always로 설정 하였습니다.</li></ul><h3 id="docker-entrypoint-sh"><a href="#docker-entrypoint-sh" class="headerlink" title="docker-entrypoint.sh"></a>docker-entrypoint.sh</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment">## from redis-5</span></span><br><span class="line">sed -i <span class="string">&quot;s/bind 127.0.0.1/bind <span class="variable">$CLIENTHOST</span> 127.0.0.1/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line">sed -i <span class="string">&quot;s/port 6379/port <span class="variable">$CLIENTPORT</span>/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line">sed -i <span class="string">&quot;s/# requirepass foobared/requirepass <span class="variable">$REQUIREPASS</span>/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line">sed -i <span class="string">&quot;s/# masterauth &lt;master-password&gt;/masterauth <span class="variable">$REQUIREPASS</span>/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line">sed -i <span class="string">&quot;s/# cluster-enabled yes/cluster-enabled yes/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line">sed -i <span class="string">&quot;s/# cluster-config-file nodes-6379.conf/cluster-config-file nodes.conf/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line">sed -i <span class="string">&quot;s/# cluster-node-timeout 15000/cluster-node-timeout 5000/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;1#-&#125;</span>&quot;</span> != <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;1%.conf&#125;</span>&quot;</span> != <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">set</span> -- redis-server <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">chown</span> -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure><ul><li>sed명령어를 통해 container내의 redis.conf파일을 치환<br>   <code>치환자에 대한 설정은 docker-compose.yml &gt; environment에 등록</code><ul><li>bind 옵션에 대해 CLINET IP를 설정</li><li>port도 기본 6379 port에서 6379, 6380으로 치환하였습니다.</li><li>requirepass도 설정</li><li>masterauth도 requirepass와 동일하게 설정</li><li>cluster-mode를 사용하기 위해 <code>cluster-enable yes</code>로 설정</li><li>cluster에 대한 로그를 볼 수 있도록 <code>cluster-config-file nodes.conf</code> conf 파일 지정 (여기에 로그 생성)</li><li>cluster failover를 위해 <code>cluster-node-timeout</code>을 5초로 지정</li></ul></li></ul><h1 id="Failover-Test"><a href="#Failover-Test" class="headerlink" title="Failover Test"></a>Failover Test</h1><p>테스트를 위해 192.168.137.101:6379 (master1)에 대한 docker container를 죽여보았습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 030bb02a246e</span><br></pre></td></tr></table></figure><p><img src="./master-down.png" alt="master-down"></p><ul><li>docker ps -a 명령으로 볼 때 192.168.137.101:6379 (master1)에 대한 docker container가 다운!!</li></ul><p><img src="./failover-1.png" alt="failover-1"></p><ul><li><p>5초 정도 지나니 무슨 로그가 올라왔습니다. epoch vote라는 로그를 보아하니 새로운 마스터를 선출하였습니다.</p></li><li><p>redis-cli를 통해 <code>cluster nodes</code>를 검색해 보니 <code>192.168.137.101:6379 (master1)</code>의 slave였던 <code>192.168.137.103:6380 (slave1)</code> 가 새로운 master로 promote 되었습니다.</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 030bb02a246e</span><br></pre></td></tr></table></figure><ul><li>docker start 명령으로 다시 container를 살려보았습니다.</li></ul><p><img src="./failover2.png" alt="failover2"></p><ul><li>기존의 master는 slave로 편입되어 정상적인 cluster가 작동하고 있습니다.</li></ul><h1 id="Sharding-Test"><a href="#Sharding-Test" class="headerlink" title="Sharding Test"></a>Sharding Test</h1><p><img src="./cluster-keys-command.PNG" alt="cluster-keys-command"></p><ul><li>redis-cli를 통해 foo1~foo10까지 key를 만들어 set해 보았습니다.</li><li>set할때 마다 16384 modules 연산을 통해 slot별로 sharding이 되는 모습입니다.</li><li>각 redis-cli에서 keys * 명령을 통해 조회 해보면 고르게 sharding이 되어있음을 확인 할 수 있습니다.</li></ul><h1 id="Node-ADD-x2F-REMOVE"><a href="#Node-ADD-x2F-REMOVE" class="headerlink" title="Node ADD&#x2F;REMOVE"></a>Node ADD&#x2F;REMOVE</h1><p><img src="./cluster-add.PNG" alt="cluster-add"></p><ul><li>신규 Master node (192.168.137.104:6379)를 새로이 추가해 보았습니다.</li></ul><p><img src="./cluster-add-node-slave.PNG" alt="cluster-add-node-slave"><br><img src="./slave-add-result.png" alt="slave-add-result"></p><ul><li>신규 Slave node (192.168.137.104:6380)를 새로이 추가해 보았습니다.</li><li>신규 Master node (192.168.137.104:6379)의 slave로 추가해보았다.</li><li>정상적으로 모두 등록 되었다.</li></ul><p><img src="./slave-del.png" alt="slave-del"></p><ul><li>slave를 삭제해 보았습니다.</li></ul><p><img src="./slave-del-result.png" alt="slave-del-result"></p><ul><li>slave가 정상적으로 삭제 되었습니다.</li></ul><p><img src="./master-del-fail.png" alt="master-del-fail"></p><ul><li>master 삭제를 시도해 보았습니다.</li><li>slot이 비어있지 않아 삭제가 불가능 했습니다.</li><li>이런 경우 reshard를 통해 slot을 비워준뒤에 삭제 해야합니다.</li></ul><p><img src="./sub-reshard.PNG" alt="sub-reshard"></p><ul><li>reshard 명령을 다시 실행 합니다.</li><li><code>What is the receiving node ID?</code> 라는 질문에 192.168.137.101:6379 node-id를 지정합니다.</li><li><code>Source node</code> 항목에는 우리가 삭제할 192.168.137.104:6379 node-id를 지정합니다.</li><li><code>source node</code> 두번째 항목에는 done을 입력하여 Source node 항목을 모두 입력하였음을 선언해 줍니다.</li></ul><p><img src="./master-del-success.png" alt="master-del-success"></p><ul><li>다시 master를 삭제하니 정상적으로 삭제가 됩니다.</li></ul><h1 id="Re-Sharding-Test"><a href="#Re-Sharding-Test" class="headerlink" title="Re-Sharding Test"></a>Re-Sharding Test</h1><p><img src="./reshard-test-1-3831920.PNG" alt="reshard-test-1"></p><ul><li>새롭게 추가한 노드에 reshard를 해보았습니다.</li><li>4000개정도를 새로이 옮긴다고 조건을 주고 Resharding을 실행 해보았습니다.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br></pre></td></tr></table></figure></li></ul><p><img src="./reshard-test-2-3832564.PNG" alt="reshard-test-2"></p><p><img src="./reshard-test-3.PNG" alt="reshard-test-3"></p><ul><li>정상적으로 resharding이 되어 데이터가 4개의 node에 고르게 분포 되었습니다.</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://redis.io/topics/cluster-tutorial">https://redis.io/topics/cluster-tutorial</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker기반 Redis 구축하기 - (9) Redis-Stats을 이용한 모니터링</title>
      <link href="/2018/12/03/2018-12-03-redis-stats/"/>
      <url>/2018/12/03/2018-12-03-redis-stats/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-stats"><a href="#Redis-stats" class="headerlink" title="Redis-stats"></a>Redis-stats</h1><p>Redis-stat은 대표적인 <code>오픈소스 Redis 모니터링 도구</code>입니다.</p><p>Ruby 기반으로 동작하는 프로그램이며, Ruby만 설치되어 있다면 설치가 간편하고 Web 또는 Console로 Redis 서버를 모니터링 할 수 있습니다.<br>비슷한 모니터링 도구로 Redmon, RedisLive등이 있지만.. Redis 4이상 버전을 아직 지원하지 않아서 Redis-stat으로 설치 해보게 되었습니다.</p><h1 id="Redis-stats-설치하기"><a href="#Redis-stats-설치하기" class="headerlink" title="Redis-stats 설치하기"></a>Redis-stats 설치하기</h1><h2 id="Install-Dependency"><a href="#Install-Dependency" class="headerlink" title="Install Dependency"></a>Install Dependency</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc-c++ patch readline readline-devel zlib zlib-devel openssl-devel make</span><br><span class="line">yum install -y bzip2 autoconf automake libtool bison iconv-devel sqlite-devel libyaml-devel libffi-devel</span><br></pre></td></tr></table></figure><h2 id="Install-RVM-Ruby-Version-Manager"><a href="#Install-RVM-Ruby-Version-Manager" class="headerlink" title="Install RVM (Ruby Version Manager)"></a>Install RVM (Ruby Version Manager)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://rvm.io/mpapis.asc | gpg --import</span><br><span class="line">curl -L get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure><h2 id="Setup-RVM-Environment"><a href="#Setup-RVM-Environment" class="headerlink" title="Setup RVM Environment"></a>Setup RVM Environment</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile.d/rvm.sh</span><br><span class="line">rvm reload</span><br></pre></td></tr></table></figure><h2 id="Install-Ruby-2-3-3"><a href="#Install-Ruby-2-3-3" class="headerlink" title="Install Ruby 2.3.3"></a>Install Ruby 2.3.3</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm install 2.3.3</span><br></pre></td></tr></table></figure><h2 id="Set-Default-Ruby-Version"><a href="#Set-Default-Ruby-Version" class="headerlink" title="Set Default Ruby Version"></a>Set Default Ruby Version</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rvm list</span><br><span class="line">rvm use 2.3.3 --default</span><br></pre></td></tr></table></figure><h2 id="Setup-Redis-stat"><a href="#Setup-Redis-stat" class="headerlink" title="Setup Redis-stat"></a>Setup Redis-stat</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install redis-stat</span><br></pre></td></tr></table></figure><h1 id="Redis-stat-실행하기"><a href="#Redis-stat-실행하기" class="headerlink" title="Redis-stat 실행하기"></a>Redis-stat 실행하기</h1><p>Redis-stat은 Web에서 조회하는 방법과 Console에서 조회하는 방법이 있습니다.<br>두 가지 형태의 모니터링 방법과 속성에 대해 알아보겠습니다.</p><h2 id="Redis-stat-옵션"><a href="#Redis-stat-옵션" class="headerlink" title="Redis-stat 옵션"></a>Redis-stat 옵션</h2><table><thead><tr><th><strong>명령어</strong></th><th><strong>설명</strong></th><th><strong>비고</strong></th></tr></thead><tbody><tr><td>redis-stat 1</td><td>localhost:6379 1초 간격으로 조회</td><td></td></tr><tr><td>redis-stat 1 10</td><td>localhost:6379 1초 간격으로 10회 조회</td><td></td></tr><tr><td>redis-stat –verbose</td><td>localhost:6379 2초 간격으로 보여주기</td><td></td></tr><tr><td>redis-stat 192.168.0.2:6379 192.168.0.2:6380 5</td><td>192.168.0.2:6379 192.168.0.2:6380서버를 5초 간격으로 보여주기</td><td></td></tr><tr><td>redis-stat –csv&#x3D;&#x2F;temp&#x2F;redis-log.csv</td><td>csv파일 남기기</td><td></td></tr><tr><td>redis-stat –daemon –server 8888</td><td>daemon 모드로 실행 port 8888번으로 접속 시, Web Monitoring mode로 작동</td><td>daemon과 server는 반드시 같이 사용해야하는 옵션</td></tr><tr><td>redis-stat -a (–auth) password</td><td>-a 또는 –auth 옵션을 통해 requirepass 비밀번호 설정</td><td></td></tr></tbody></table><h2 id="Redis-stat-Console-Monitoring"><a href="#Redis-stat-Console-Monitoring" class="headerlink" title="Redis-stat (Console Monitoring)"></a>Redis-stat (Console Monitoring)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#192.168.137.101 서버의 6379~6381 포트 정보를 조회</span></span><br><span class="line">redis-stat 1 -a password1234 \</span><br><span class="line">192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381</span><br></pre></td></tr></table></figure><p><img src="./redis-stat-1.PNG" alt="redis-stat-1"></p><h2 id="Redis-stat-Web-Monitoring"><a href="#Redis-stat-Web-Monitoring" class="headerlink" title="Redis-stat (Web Monitoring)"></a>Redis-stat (Web Monitoring)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># CentOs 방화벽 포트 open</span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-port 8888/tcp</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"> </span><br><span class="line"><span class="comment">#192.168.137.101 서버의 6379~6381 포트 정보를 조회</span></span><br><span class="line">redis-stat 1 -a &lt;requirepass&gt; \</span><br><span class="line">192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381 \</span><br><span class="line">--daemon --server=8888</span><br></pre></td></tr></table></figure><h2 id="192-168-137-104-8888-서버로-접속"><a href="#192-168-137-104-8888-서버로-접속" class="headerlink" title="192.168.137.104:8888 서버로 접속"></a>192.168.137.104:8888 서버로 접속</h2><p><img src="./redis-stat-web.PNG" alt="redis-stat-web"></p><p><img src="./redis-stat-web2.PNG" alt="redis-stat-web2"></p><h1 id="아쉬운-점"><a href="#아쉬운-점" class="headerlink" title="아쉬운 점"></a>아쉬운 점</h1><ol><li>그 당시의 모니터링만 가능하다. (별도 저장소가 없기 때문) -&gt; 이전 로그를 보기 위해선 CSV 파일을 남기는 것이 최선</li><li>보고자 하는 정보가 적다. 기본적으로 메모리 사용량, Client 수 Key Size정도는 제공을 하지만 다른 툴에서는 더 많은 정보가 제공되는 것 같다.</li></ol><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://github.com/junegunn/redis-stat">https://github.com/junegunn/redis-stat</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker기반 Redis 구축하기 - (8) HAProxy를 이용한 분산처리 환경 구축하기</title>
      <link href="/2018/12/02/2018-12-02-docker-8/"/>
      <url>/2018/12/02/2018-12-02-docker-8/</url>
      
        <content type="html"><![CDATA[<h1 id="HAProxy란"><a href="#HAProxy란" class="headerlink" title="HAProxy란?"></a>HAProxy란?</h1><p>HAProxy는 기존의 하드웨어 스위치(L4&#x2F;L7)을 대체하는 소프트웨어 로드밸런서입니다.<br>로드 밸런싱이란 부하 분산을 위해서 가상IP를 통해 여러서버에 접속하도록 트래픽을 분배해 주는 기능을 의미합니다.</p><h1 id="Redis-Cluster에-HAProxy가-필요한-이유"><a href="#Redis-Cluster에-HAProxy가-필요한-이유" class="headerlink" title="Redis-Cluster에 HAProxy가 필요한 이유"></a>Redis-Cluster에 HAProxy가 필요한 이유</h1><p>Redis Cluster에서는 Failover가 일어날 수 있습니다.</p><p>처음에 1번이 Master였다가, 2번이 Master가 되고, 3번이 Master가 될 수 있습니다.<br>하지만 Redis Cluster를 사용하는 Application에서 항상 바뀌는 Master의 포트정보를 찾는것은 매우 비용을 낭비하는 행위라 볼 수 있습니다.</p><p>따라서 HAProxy에서 Health check를 하면서 실시간으로 Master를 찾아 신호를 보내줄 수 있기 때문에 HAProxy를 Redis-Cluster에 접목하였습니다.</p><h1 id="다시-한번-보는-Redis-Cluster-구성도"><a href="#다시-한번-보는-Redis-Cluster-구성도" class="headerlink" title="다시 한번 보는 Redis Cluster 구성도"></a>다시 한번 보는 Redis Cluster 구성도</h1><p><img src="./Redis-Cluster-archi.PNG" alt="Redis-Cluster-archi"></p><p>HAProxy Port를 6개를 지정합니다. (각각 1개는 Master Port, Slave Port라고 가정하고 (1(master)+1(slave)) x 3 (서버대수))</p><p>5000, 5002, 5004번 Port는 각 서버의 Master Redis를 체크합니다.<br>따라서 5000, 5002, 5004으로 들어온 요청은 각각의 서버의 Master Redis에 전달 됩니다.</p><p>다음으로 5001, 5003, 5005번 Port는 각 서버의 Slave Redis를 체크합니다.<br>따라서 5001, 5003, 5005으로 들어온 요청은 각각의 서버의 Slave Redis들에게 전달됩니다. (HAProxy에는 여러 서버에 대한 분배방식을 설정 할 수 있는데 고루게 요청할 수 있도록 RoundRobin 방식으로 설정하였습니다)</p><h1 id="HAProxy-설치방법"><a href="#HAProxy-설치방법" class="headerlink" title="HAProxy 설치방법"></a>HAProxy 설치방법</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 관련 모듈을 yum으로 설치한다.</span></span><br><span class="line">yum install gcc gcc-c++ pcre-devel openssl-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># wget명령어도 haproxy 다운로드</span></span><br><span class="line">wget http://www.haproxy.org/download/1.8/src/haproxy-1.8.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 압축을 풀어준다.</span></span><br><span class="line">tar zxvf haproxy-1.8.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 디렉토리 이동</span></span><br><span class="line"><span class="built_in">cd</span> haproxy-1.8.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># c파일을 컴파일 해준다. https 사용이 필요한 경우 USE_OPENSSL=1 설정 추가</span></span><br><span class="line">make TARGET=linux2628 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># /usr/local/haproxy 디렉토리에 설치</span></span><br><span class="line">make PREFIX=/usr/local/haproxy DESTDIR= install</span><br></pre></td></tr></table></figure><h1 id="haproxy-cfg-파일-작성"><a href="#haproxy-cfg-파일-작성" class="headerlink" title="haproxy.cfg 파일 작성"></a>haproxy.cfg 파일 작성</h1><p>haproxy.cfg 파일을 작성 할 때는 크게 2가지 관점으로 작성합니다.</p><ul><li>frontend : haproxy에서 사용할 포트 설정, 포트로 신호가 왔을 시 실행할 backend 연결</li><li>backend : frontend로 부터 온 신호를 바탕으로 연결가능한 서버에 트래픽을 분배</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">global</span><br><span class="line">  <span class="built_in">log</span> 127.0.0.1 local0</span><br><span class="line">  <span class="built_in">log</span> 127.0.0.1 local1 notice</span><br><span class="line"> </span><br><span class="line">defaults REDIS</span><br><span class="line">mode tcp</span><br><span class="line"><span class="built_in">timeout</span> connect 4s</span><br><span class="line"><span class="built_in">timeout</span> server 15s</span><br><span class="line"><span class="built_in">timeout</span> client 15s</span><br><span class="line"><span class="comment"># timeout tunnel 365d</span></span><br><span class="line"> </span><br><span class="line">frontend front_redis_master1</span><br><span class="line"> <span class="built_in">bind</span> *:5000 name redis                 <span class="comment">#5000번 포트에 대한 bind 정보입니다.</span></span><br><span class="line"> default_backend back_redis_master1     <span class="comment">#5000번 포트로 신호가 들어오면 backend를 실행</span></span><br><span class="line"> </span><br><span class="line">backend back_redis_master1</span><br><span class="line"> option tcp-check                       <span class="comment">#tcp-check를 통해 접근가능한 서버 필터링</span></span><br><span class="line"> tcp-check send AUTH\ password1234\r\n  <span class="comment">#비밀번호 password1234를 입력하고 Redis 서버에 접속합니다.</span></span><br><span class="line"> tcp-check expect string +OK            <span class="comment">#OK가 왔는지?</span></span><br><span class="line"> tcp-check send PING\r\n                <span class="comment">#PING을 날려 신호를 점검합니다.</span></span><br><span class="line"> tcp-check expect string +PONG          <span class="comment">#PONG이라는 응답이 왔는지?</span></span><br><span class="line"> tcp-check send info\ replication\r\n   <span class="comment">#info replication 명령을 날려 Redis에 대한 정보를 받아옵니다.</span></span><br><span class="line"> tcp-check expect string role:master    <span class="comment">#role이 master인지 확인 합니다.</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">#repl_backlog_active의 값이 1인지 확인합니다 </span></span><br><span class="line"> <span class="comment">#이 조건을 추가한 이유는 Failover간 잠시의 시간동안 Master가 2대가 되는데 그것을 방지 하기 위함입니다.</span></span><br><span class="line"> <span class="comment">#(진짜 Master Redis에만 1, slave는 0)</span></span><br><span class="line"> tcp-check expect string repl_backlog_active:1 </span><br><span class="line"> tcp-check send QUIT\r\n                <span class="comment">#QUIT 명령을 전송</span></span><br><span class="line"> tcp-check expect string +OK</span><br><span class="line"> server redis1 192.168.137.101:6379 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis2 192.168.137.101:6380 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis3 192.168.137.101:6381 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> </span><br><span class="line">frontend front_redis_slave1</span><br><span class="line"><span class="built_in">bind</span> *:5001 name redis                <span class="comment">#5001번 포트에 대한 bind 정보입니다.</span></span><br><span class="line">default_backend back_redis_slave1</span><br><span class="line"> </span><br><span class="line">backend back_redis_slave1</span><br><span class="line"> balance roundrobin                   <span class="comment">#라운드 로빈 방식으로 분배</span></span><br><span class="line"> option tcp-check</span><br><span class="line"> tcp-check send AUTH\ password1234\r\n        </span><br><span class="line"> tcp-check expect string +OK</span><br><span class="line"> tcp-check send PING\r\n              </span><br><span class="line"> tcp-check expect string +PONG</span><br><span class="line"> tcp-check send info\ replication\r\n </span><br><span class="line"> tcp-check expect string role:slave   <span class="comment">#role key가 slave인지 확인 합니다.</span></span><br><span class="line"> tcp-check send QUIT\r\n</span><br><span class="line"> tcp-check expect string +OK</span><br><span class="line"> server redis1 192.168.137.101:6379 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis2 192.168.137.101:6380 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis3 192.168.137.101:6381 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#Listen on all IP&#x27;s on port 9000 //9000 포트로 접근 시, Web Console에 진입할 수 있습니다. </span></span><br><span class="line">listen stats</span><br><span class="line">   <span class="built_in">bind</span> 0.0.0.0:9000 </span><br><span class="line">   mode http</span><br><span class="line">   balance</span><br><span class="line">   <span class="built_in">timeout</span> client 5000</span><br><span class="line">   <span class="built_in">timeout</span> connect 4000</span><br><span class="line">   <span class="built_in">timeout</span> server 30000</span><br><span class="line"> </span><br><span class="line">   <span class="comment">#This is the virtual URL to access the stats page</span></span><br><span class="line">   stats uri /haproxy_stats //URL주소는 ip:9000/haproxy_stats입니다.</span><br><span class="line">   <span class="comment">#Authentication realm. This can be set to anything. Escape space characters with a backslash.</span></span><br><span class="line">   stats realm HAProxy\ Statistics</span><br><span class="line"> </span><br><span class="line">   <span class="comment">#The user/pass you want to use. Change this password!</span></span><br><span class="line">   stats auth admin:1234 <span class="comment">#Web Console에 접근하는 계정/암호 설정</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">#This allows you to take down and bring up back end servers.</span></span><br><span class="line">   <span class="comment">#This will produce an error on older versions of HAProxy.</span></span><br><span class="line">   stats admin <span class="keyword">if</span> TRUE</span><br></pre></td></tr></table></figure><p>위의 내용에서는 일단 하나의 Master-Slave에 대한 설정값만 있습니다.<br>여태까지 설치 내용에서는 Master-Slave 구성이 3세트이기 때문에 실제 haproxy.cfg를 작성 할 경우에는<br>5002~5005번 포트를 사용하는 설정에 대해서도 추가해야 합니다.</p><h1 id="HAProxy-Web-Console-확인하기"><a href="#HAProxy-Web-Console-확인하기" class="headerlink" title="HAProxy Web Console 확인하기"></a>HAProxy Web Console 확인하기</h1><p><img src="./haproxy1.PNG" alt="haproxy1"></p><p><strong>haproxy-server-ip:9000</strong> 으로 접속하였습니다<br>현재 192.168.137.101 서버에는 6379, 6380, 6381 포트를 사용하는 Redis 노드가 3개가 동작하고 있습니다.<br>현재 master 역할을 수행하는 것은 6380 포트를 사용하는 redis2 노드입니다.<br>따라서 <strong>haproxy-server-ip:5000</strong> 으로 접속하게 되면 redis2 노드에 신호가 분배되어 Redis master서버에 대한 명령을 실행 할 수 있습니다.</p><p>현재 slave 역할을 수행하는 것은 6379, 6381포트를 사용하는 redis1, redis3노드 입니다.<br>따라서 <strong>haproxy-server-ip:5001</strong>으로 접속하게 되면 RoundRobin 방식으로 redis1, redis3 노드에 신호가 분배되어 Redis slave 서버에 대한 명령을 실행 할 수 있습니다</p><blockquote><p><strong>HAProxy를 구성한 이유</strong></p><p>Application에서 Redis를 사용하면서, Master에만 데이터를 입력하고, Slave에서만 데이터를 조회하려는 행위를 많이 하게 됩니다. 아무래도 Redis서버에 대한 부하를 줄여주고자 이러한 행위를 하게 되는데, Haproxy를 설정 해 두면, Application Server에서 failover로 인해 변하는 master&#x2F;slave 포트에 대한 걱정을 할 필요가 없습니다.<br>HAProxy에서 알아서 tcp-check를 통해 master&#x2F;slave를 정해주기 때문입니다.</p></blockquote><h1 id="Failover-Test"><a href="#Failover-Test" class="headerlink" title="Failover Test"></a>Failover Test</h1><p>Sentinel 테스트와 동일하게 Master를 죽여보도록 하겠습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;master-node-id&gt;</span><br></pre></td></tr></table></figure><p><img src="./haproxy2.PNG" alt="haproxy2"></p><p>Master node를 죽이니, 5000번 포트에서는 더이상 master로 갈 수 있는 서버가 없다고 나옵니다.<br>(<strong>이 때 순단을 최소화 하려면 failover 시간과, HAProxy tcp-check 시간을 최소로 줄여야 합니다.</strong>)</p><p><img src="./haproxy3.PNG" alt="haproxy3"></p><p>잠시 시간이 지나고 Redis Failover가 진행됩니다. 진행이 완료되면, HAProxy에서도 tcp-check가 이루어집니다.</p><p><img src="./haproxy4.PNG" alt="haproxy4"></p><p>tcp-check가 끝나고 redis1 노드가 master로 선출되어, 5000번 포트로 접근 시, redis1 노드로 분산되게 됩니다.</p><p>다시, 죽었던 redis2 노드를 살려보겠습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;redis2_node_id&gt;</span><br></pre></td></tr></table></figure><p><img src="./haproxy5.PNG" alt="haproxy5"></p><p>redis2 노드가 다시 살아나고, sentinel에서도 role-change 작업이 이루어집니다.<br>곧이어, HAProxy에서도 tcp-check를 통해 redis2노드가 slave가 되었음을 확인하고 5001 포트에서 분배가능한 서버로 분류됩니다.</p><p><img src="./haproxy6.PNG" alt="haproxy6"></p><p>이와 같이 Application Server에서는 무조건 master port는 5000번, slave port는 5001번 이라고만 알고 있으면 Redis서버에서 failover가 진행되더라도, 설정을 바꿀 필요없이 사용이 가능합니다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="http://blog.whitelife.co.kr/321">http://blog.whitelife.co.kr/321</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker기반 Redis 구축하기 - (7) Docker를 이용한 Redis Sentinel 설치하기</title>
      <link href="/2018/12/02/2018-12-02-docker-7/"/>
      <url>/2018/12/02/2018-12-02-docker-7/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-Sentinel이란"><a href="#Redis-Sentinel이란" class="headerlink" title="Redis Sentinel이란?"></a>Redis Sentinel이란?</h1><p>Redis Cluster 운영환경에서 Master-Slave 관계를 가진 Redis가 있습니다.<br>시스템 오류나 알수 없는 원인으로 인해 Master Redis가 down되어 연결이 중단 되면, 사용자나 Application에서는 Redis Master를 통해 데이터를 등록 할 수 없게 됩니다.<br>이런 경우 Slave Redis를 Master Redis로 승격시켜 시스템이 정상적으로 운영 될 수 있도록 해야 합니다.</p><p>이 때 사용하는 게 Redis Sentinel입니다.<br>Sentinel은 Master Redis의 상태를 감시합니다. 그러다가 Master Redis가 Down이 되어버리면, Sentinel들은 Slave Redis들 중에 어떤 Redis 서버를 Master로 승격시킬지 투표하게 됩니다.<br>Slave Redis 중 Sentinel의 투표를 더 많이 받은 Redis Server가 Master Redis로 승격됩니다.<br>이후 장애를 해결한 원래 Master Redis는 재시작 시, 현재 Master Redis의 Slave Redis로 시작되게 됩니다.</p><p>이와같이, Redis Sentinel은 Redis Cluster 환경에서의 Failover를 자동으로 해주는 Redis의 한 Mode입니다.</p><h1 id="Role-Change-원리"><a href="#Role-Change-원리" class="headerlink" title="Role Change 원리"></a>Role Change 원리</h1><p><img src="./Redis-failover-1.PNG" alt="Redis-failover-1"></p><p>위의 상황은 6379 포트를 사용하는 Master Redis가 Down된 상황입니다.<br>Sentinel들은 일제히 Master Redis를 감시하다가 Down된 상황을 인지하고<br>2번째 그림처럼 Slave Redis들 중 어떤 Redis 서버를 Master Redis로 승격할 지 투표로 정하게 됩니다.<br>여기서 중요한 건 Redis Sentinel의 노드 갯수는 <code>항상 홀수로 설정</code>해야 합니다. (짝수 인 경우 1:1, 2:2 상황이 되어 어떤 Redis Server를 승격 시킬지 알 수 없기 때문입니다.)<br>위의 예제에서는 15485 번 포트를 사용하는 Slave Redis가 2대1로 선택되었습니다.<br>Sentinel은 바로 redis.conf 파일을 조작하여 Slave Redis를 Master Redis로 변경합니다.<br>그리고 자기 자신의 sentinel.conf 정보를 조작하여 감시하는 Redis 서버 정보를 update 합니다.<br>이후 Down되었던 기존의 Master Redis의 장애가 처리되어 Restart되는 경우를 보도록 하겠습니다. </p><p><img src="./Redis-failover-2.PNG" alt="Redis-failover-2"></p><p>Sentinel은 Down되었던 Master 정보를 메모리에 저장하고 있습니다.<br>이후 Down되었던 Master Redis가 장애를 처리하고 다시 시작 되는 경우, Master Redis의 redis.conf 파일을 조작하여<br>현재 Master Redis의 Slave로 설정합니다.</p><blockquote><p>이 경우 Sentinel의 설정 값이 따라 다르지만,<br>일시적으로 Master Redis가 2대가 됩니다.<br>만약에 Down 되었다가 Restart된 Redis에 Data가 저장되는 경우, Slave Redis로 전환되면서 Master의 rdb파일을 바탕으로 Data를 Update하기 때문에 데이터가 사라지는 상황이 오게 됩니다.<br>따라서 Down 되었다가 살아나는 Redis에 접근 하지 못하도록 막아야 합니다. </p></blockquote><h1 id="Redis-Sentinel-설치하기"><a href="#Redis-Sentinel-설치하기" class="headerlink" title="Redis Sentinel 설치하기"></a>Redis Sentinel 설치하기</h1><p>Docker, Docker-Compose, git은 Redis Cluster를 설치하며 설치 했다고 가정하겠습니다.</p><h2 id="Redis-Sentinel-파일-다운로드"><a href="#Redis-Sentinel-파일-다운로드" class="headerlink" title="Redis Sentinel 파일 다운로드"></a>Redis Sentinel 파일 다운로드</h2><p>기존에 github에 올려둔 Sentienel 설정파일을 다운로드 합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /home/redis/redis-sentinel <span class="comment">#Redis-sentinel home 생성</span></span><br><span class="line"><span class="built_in">cd</span> /home/redis</span><br><span class="line"><span class="built_in">mkdir</span> -p ./sentinel-data/sentinel1   <span class="comment">#외부 log파일 볼륨 설정</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ./sentinel-data/sentinel2</span><br><span class="line"><span class="built_in">mkdir</span> -p ./sentinel-data/sentinel3</span><br><span class="line"> </span><br><span class="line">git init</span><br><span class="line">git remote add origin <span class="string">&quot;https://github.com/jaehun2841/redis-sentinel-on-docker.git&quot;</span></span><br><span class="line">git pull origin master <span class="comment">#github에서 sentinel 설정 파일 다운로드</span></span><br></pre></td></tr></table></figure><h2 id="Redis-sentinel-Build"><a href="#Redis-sentinel-Build" class="headerlink" title="Redis sentinel Build"></a>Redis sentinel Build</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/redis/redis-sentinel</span><br><span class="line">docker-compose -f conf/sentinel-docker-compose.yml up --build -d </span><br></pre></td></tr></table></figure><h1 id="Redis-Sentinel-생성을-위한-docker-compose-yml파일"><a href="#Redis-Sentinel-생성을-위한-docker-compose-yml파일" class="headerlink" title="Redis Sentinel 생성을 위한 docker-compose.yml파일"></a>Redis Sentinel 생성을 위한 docker-compose.yml파일</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-sentinel1:</span>                        <span class="comment">#Sentinel Container명</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">lgatica/redis-sentinel:4.0.2</span>  <span class="comment">#redis-sentinel 이미지를 바탕으로 빌드합니다.</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span>                        <span class="comment">#Dockerfile context 설정</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span>             <span class="comment">#Dockerfile명 설정 (Default는 Dockerfile로 된 파일명을 찾습니다.)</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">     <span class="attr">environment:</span>                         <span class="comment">#Container에서 사용할 환경 변수 설정</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=26379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span>                   <span class="comment">#Sentinel의 mymaster port를 적어줍니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">QUORUM=2</span>                          <span class="comment">#QUORUM 값은 Sentinel들이 투표했을때 득표수가 2 이상인 Redis에 대해 Master로 승격할 수 있도록 하는 조건 값입니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DOWN_AFTER_MILLISEC=3000</span>          <span class="comment">#Redis master node down 후 3초 이후 failover 시작</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FAILOVER_TIMEOUT=3000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../../sentinel-data/sentinel1:/redis&quot;</span>  <span class="comment">#Container 외부 볼륨 설정</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span>                         <span class="comment">#restart policy Container가 중지되거나 down되는 경우 무조건 다시 시작합니다.</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-sentinel2:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">lgatica/redis-sentinel:4.0.2</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=26380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">QUORUM=2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DOWN_AFTER_MILLISEC=3000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FAILOVER_TIMEOUT=3000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../../sentinel-data/sentinel2:/redis&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-sentinel3:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">lgatica/redis-sentinel:4.0.2</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=26381</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">QUORUM=2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DOWN_AFTER_MILLISEC=3000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FAILOVER_TIMEOUT=3000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../../sentinel-data/sentinel3:/redis&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><h1 id="Redis-Sentinel-이미지-생성을-위한-Dockerfile-작성"><a href="#Redis-Sentinel-이미지-생성을-위한-Dockerfile-작성" class="headerlink" title="Redis Sentinel 이미지 생성을 위한 Dockerfile 작성"></a>Redis Sentinel 이미지 생성을 위한 Dockerfile 작성</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#redis-sentinel 이미지 기반으로 빌드합니다.</span></span><br><span class="line">FROM lgatica/redis-sentinel:4.0.2   </span><br><span class="line"> </span><br><span class="line">MAINTAINER Carrey </span><br><span class="line"> </span><br><span class="line"><span class="comment">## Copy Redis File</span></span><br><span class="line"><span class="comment">## 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 한다.</span></span><br><span class="line"><span class="comment"># 기존 container의 sentinel-entrypoint.sh 삭제합니다.</span></span><br><span class="line">RUN <span class="built_in">rm</span> -rf /usr/local/bin/sentinel-entrypoint.sh         </span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel 설정이 담긴 sentinel.conf 파일 복사합니다.</span></span><br><span class="line">ADD sentinel.conf /usr/local/bin/sentinel.conf                          </span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel container 시작 시, 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.</span></span><br><span class="line">ADD sentinel-entrypoint.sh /usr/local/bin/sentinel-entrypoint.sh         </span><br><span class="line"> </span><br><span class="line"><span class="comment">## change access authority</span></span><br><span class="line"><span class="comment"># 복사한 파일에 대한 권한을 변경합니다. (Permission Denied 문제)</span></span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /usr/local/bin/sentinel.conf                               </span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /usr/local/bin/sentinel-entrypoint.sh</span><br><span class="line">RUN <span class="built_in">chown</span> redis:redis /usr/local/bin/sentinel.conf</span><br><span class="line">RUN <span class="built_in">chown</span> redis:redis /usr/local/bin/sentinel-entrypoint.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Redis Container에 대한 Port를 지정합니다. (host 모드이기 때문에 외부 노출)</span></span><br><span class="line">EXPOSE <span class="variable">$CLIENTPORT</span>                                    </span><br><span class="line"></span><br><span class="line"><span class="comment"># Container가 생성, 시작하는 시점에 실행됩니다.</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/usr/local/bin/sentinel-entrypoint.sh&quot;</span>]        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Container 빌드가 완료되고 Sentinel Server를 실행시킵니다. </span></span><br><span class="line"><span class="comment"># conf 파일 뿐만 아니라 --sentinel 옵션을 추가하여 Redis가 Sentinel 모드로 실행 되도록 합니다.</span></span><br><span class="line"><span class="comment"># Sentinel 또한 Redis Server이지만, Sentinel 설정을 하여 실행 시키는 것 뿐입니다.</span></span><br><span class="line">CMD [ <span class="string">&quot;redis-server&quot;</span>,<span class="string">&quot;/usr/local/bin/sentinel.conf&quot;</span>, <span class="string">&quot;--sentinel&quot;</span> ]                          </span><br></pre></td></tr></table></figure><h1 id="Redis-Sentinel-설정"><a href="#Redis-Sentinel-설정" class="headerlink" title="Redis Sentinel 설정"></a>Redis Sentinel 설정</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"> </span><br><span class="line"><span class="comment"># bind 127.0.0.1 문자열을 각 이미지에서 설정한 $CLIENTHOST 값으로 변경합니다. </span></span><br><span class="line"><span class="comment"># $CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.</span></span><br><span class="line">sed -i <span class="string">&quot;s/bind 127.0.0.1/bind <span class="variable">$CLIENTHOST</span>/g&quot;</span> /usr/local/bin/sentinel.conf      </span><br><span class="line">         </span><br><span class="line"><span class="comment"># port 6379 문자열을 각 이미지에서 설정한 $CLIENTPORT 값으로 변경합니다. </span></span><br><span class="line"><span class="comment"># Sentinel 이미지 별로 port다르게 설정</span></span><br><span class="line">sed -i <span class="string">&quot;s/port 6379/port <span class="variable">$CLIENTPORT</span>/g&quot;</span> /usr/local/bin/sentinel.conf  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># sentinel에 대한 mymaster를 설정하는 부분입니다. </span></span><br><span class="line"><span class="comment"># 실제 Master Redis의 ip와 port를 설정하고 QUORUM 값을 설정합니다.</span></span><br><span class="line"><span class="comment"># QUORUM 값은 Slave-&gt;Master Role Change 시, slave redis가 받아야 하는 최소 투표 수 입니다.</span></span><br><span class="line">sed -i <span class="string">&quot;s/sentinel monitor mymaster 127.0.0.1 6379 2/sentinel monitor mymaster <span class="variable">$MASTERHOST</span> <span class="variable">$MASTERPORT</span> <span class="variable">$QUORUM</span>/g&quot;</span> /usr/local/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Redis server가 다운되고 후처리 실행 시간 까지 걸리는 시간을 지정합니다. </span></span><br><span class="line"><span class="comment"># ex)3000 -&gt; 3000 밀리세컨드 -&gt; 3초</span></span><br><span class="line">sed -i <span class="string">&quot;s/sentinel down-after-milliseconds mymaster 30000/sentinel down-after-milliseconds mymaster <span class="variable">$DOWN_AFTER_MILLISEC</span>/g&quot;</span> /usr/local/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Redis failover timeout 시간을 설정 합니다.</span></span><br><span class="line">sed -i <span class="string">&quot;s/sentinel failover-timeout mymaster 180000/sentinel failover-timeout mymaster <span class="variable">$FAILOVER_TIMEOUT</span>/g&quot;</span> /usr/local/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># sentinel이 master redis에 접근할 때 인증하는 비밀번호를 설정합니다.</span></span><br><span class="line">sed -i <span class="string">&quot;s/# sentinel auth-pass mymaster MySUPER--secret-0123passw0rd/sentinel auth-pass mymaster <span class="variable">$REQUIREPASS</span>/g&quot;</span> /usr/local/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;1#-&#125;</span>&quot;</span> != <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;1%.conf&#125;</span>&quot;</span> != <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">set</span> -- redis-server <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">chown</span> -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Redis-Sentinel-실행-결과"><a href="#Redis-Sentinel-실행-결과" class="headerlink" title="Redis Sentinel 실행 결과"></a>Redis Sentinel 실행 결과</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f conf/sentinel-docker-compose.yml up --build -d </span><br></pre></td></tr></table></figure><p><img src="./redis-sentinel-log.PNG" alt="redis-sentinel-log"></p><p>sentinel 1<del>3 까지의 로그를 모아보았습니다.<br>테스트용 port인 (6379</del>6381) 에 대한 master&#x2F;slave 정보를 가지고 있는것을 볼수 있습니다.</p><p>로그처럼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel2_1  | 1:X 02 Dec 10:06:24.082 # +monitor master mymaster 192.168.137.101 6379 quorum 2</span><br></pre></td></tr></table></figure><p>sentinel이 자신의 마스터에 대한 정보를 가지고 모니터 하며 quorum 2를 가지고 있는 것을 볼 수 있습니다.</p><h1 id="Failover-Test"><a href="#Failover-Test" class="headerlink" title="Failover Test"></a>Failover Test</h1><p>자, Failover를 구성 했으니 실제로 Master를 한번 죽여보도록 해보겠습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;master_node_id&gt; <span class="comment"># Redis Master Container를 중지</span></span><br></pre></td></tr></table></figure><p><img src="./redis-failover-log.PNG" alt="redis-failover-log"></p><p>맨 처음 로그를 살펴보면 각 sentinel 노드에서 sdown 시그널을 발생시키고 있습니다.</p><p>중간정도 줄을 보면</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+odown master mymaster 192.168.137.101 6379 <span class="comment">#quorum 3/2</span></span><br></pre></td></tr></table></figure><p>라는 로그가 나오게 되는데 3개의 sentinel에서 모두 sdown으로 인지하게 되는것입니다.<br>3&#x2F;2의 뜻은  2개 노드에서 sdown이 발생 했을 때, odown 판정을 내린다는 다수결 투표 숫자입니다.<br>그런데 3개의 노드가 모두 투표를 하여 과반수 이상이 되었으므로 192.168.137.101 6379인 Redis 노드는 odown상태가 되었습니다.</p><p>그 바로 다음 줄 부터 failover 작업이 시작됩니다.<br>위의 예제에서는 6380 포트를 사용하는 redis노드가 새로운 마스터로 선출 되었습니다.<br>따라서 6380 포트를 사용하는 redis노드는 master로 role-change가 되면서 master 노드로써 역할을 수행하게 됩니다.</p><p>이렇게 Redis Sentinel을 이용하여 master node를 감시하며, 장애 상황에 대한 failover를 지원하고 있습니다.</p><h2 id="sdown-vs-odown"><a href="#sdown-vs-odown" class="headerlink" title="sdown vs odown"></a>sdown vs odown</h2><p>Sentinel에서 down을 판단하는 방법은 <code>sdown</code>과 <code>odown</code>으로 이루어집니다.<br>failover 시 Master가 죽었다는 걸 판단하기 위해서는 <code>다수결의 원칙</code>이 적용됩니다. (그래서 Sentinel노드 갯수를 홀수로 설정하는 이유입니다.)</p><p>먼저, Master가 죽게 되면 Sentinel은 자신이 감시하고 있는 Master가 죽었다고 sdown 시그널을 표현합니다 (<code>Subjective Down</code> 이라 합니다.)<br>sdown은 단지 Master와 Sentinel 자기 자신이 연결이 되지 않음을 의미합니다.</p><p>위에서 보듯이 Master가 죽었으니 다른 Sentinel들도 연결이 끊어졌다고 sdown 시그널을 보냅니다.<br>그렇게 되면 다수결에 원칙에 따라 quorum값 만큼의 sdown이 발생하면 sentinel은 odown 시그널을 보냅니다. (<code>Objective Down</code>이라 합니다.)</p><p>odown은 다수결에 의해서 명시적으로 Master가 Down되었다고 선포하는 것과 같습니다.<br>그렇게 되면 Sentinel들은 다음 Master를 선출하기 위해 남아있는 Slave Redis들에게 투표를 하게 됩니다.<br>다수결의 원칙으로 더 많은 투표수를 받은 Slave가 Master로 선출되게 됩니다.</p><h2 id="중단되었던-6379-포트를-사용하는-Redis-노드가-살아나면"><a href="#중단되었던-6379-포트를-사용하는-Redis-노드가-살아나면" class="headerlink" title="중단되었던 6379 포트를 사용하는 Redis 노드가 살아나면?"></a>중단되었던 6379 포트를 사용하는 Redis 노드가 살아나면?</h2><p>아까 stop했던 container를 다시 살려보겠습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;redis1_node_id&gt;</span><br></pre></td></tr></table></figure><p><img src="./redis-failover-3-3748019.PNG" alt="redis-failover-3"></p><p>3번째 줄부터 보시면, sentinel에서 <code>-sdown</code> 로그를 찍어주고 있습니다.<br>sentinel에서 연결되지 않았던 6379번 노드에 대해 정상적으로 커넥션이 맺어지고 있기 때문입니다.<br>중간 줄 부터 보게 되면다른 sentinel 노드에서도 <code>-sdown</code> 로그를 찍어주며 6379번 노드에 대한 부활을 알려주고 있습니다.</p><p>그런 다음에 <code>+convert-to-slave</code> 로그를 보면, 기존의 6379번 노드는 원래 master role을 수행 하던 Redis 노드였습니다.<br>하지만 현재 sentinel에 대한 mymaster는 6380번 노드이기 때문에 6379번 노드는 master role을 수행 할 수 없습니다.</p><p>따라서  <code>+role-change</code> 명령을 통해  기존에 master role -&gt; slave role로 변경되어야 합니다.<br>그리고 현재 master role 권한이 있는 6380번 노드의 slave으로 편입되게 됩니다.<br>redis-cli를 통해 6379번 노드에 접속하여 <code>info replication</code> 명령을 날려보았습니다.</p><p><img src="./redis-failover-4.PNG" alt="redis-failover-4"></p><p>현재 role은 <code>slave</code> 이며, 6380번 노드를 master로 설정하고 있습니다.</p><blockquote><p><strong>왜 기존의 master가 살아나면, slave로 전환하여 사용해야 할까?</strong></p><p>이유는 간단합니다.<br>Redis Master-Slave간 데이터 Replication을 이해 하면 쉽게 이해 할 수 있습니다<br>Redis의 데이터 Replication은 dump.rdb파일을 통해 이루어지는데,<br>master노드 만 dump.rdb파일에 데이터를 write 할 수 있습니다.<br>slave노드에서는 dump.rdb파일을 읽어서 데이터 replication을 하게 되는데,<br>만약 기존의 master의 role이 유지된다면, dump.rdb파일을 조작하여 기존의 master가 다운된 시간 동안<br>들어온 데이터가 삭제될 수 있습니다.<br>그렇게 때문에 데이터 정합성을 위해 기존의 master는 slave로 role이 전환되어야 합니다.</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker기반 Redis 구축하기 - (6) Docker를 이용한 Redis Cluster 설치하기</title>
      <link href="/2018/12/01/2018-12-01-docker-6/"/>
      <url>/2018/12/01/2018-12-01-docker-6/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-Cluster-구성도"><a href="#Redis-Cluster-구성도" class="headerlink" title="Redis Cluster 구성도"></a>Redis Cluster 구성도</h1><p><img src="./Redis-Cluster-archi.PNG" alt="Redis-Cluster-archi"></p><p>간단하게 정리하면.</p><ul><li>각 서버 별로 Redis 3대를 설치. Master 1개, Slave 2개로 구성하여 Replication을 지원할 수 있도록 Cluster를 구성하였습니다.</li><li>각 서버 별로 Sentinel 3대를 설치. 양대비 원리에 맞추어 홀수개로 설정 하였습니다.</li><li>각각의 서버의 Sentinel 3대가 서버의 Master Redis를 감시합니다. (Failover 대기)</li><li>Redis Cluster를 서버 3대에 설치. Data Sharding을 하기 위해 저장소를 3개로 분리하였습니다.</li><li>HAProxy로 분산 처리 구축. 5000, 5002, 5004번 포트는 각 서버의 Master Redis를 바라봅니다.</li><li>5001, 5003, 5005번 포트는 각 서버의 Slave Redis 2대씩 바라봅니다.</li></ul><p>지금부터 Redis Cluster를 어떻게 설치 하였는지 설치 과정에 대해 알아보도록 하겠습니다.</p><h1 id="Docker를-이용한-Redis-Cluster-설치"><a href="#Docker를-이용한-Redis-Cluster-설치" class="headerlink" title="Docker를 이용한 Redis Cluster 설치"></a>Docker를 이용한 Redis Cluster 설치</h1><p>Redis-Cluster를 설치하는 순서는 아래와 같습니다. (CentOS 7기준으로 설치 하였습니다.)</p><ul><li>Git 설치 (미리 올려둔 Docker file들을 다운받기 위함)</li><li>Docker 설치</li><li>Docker-Compose 설치</li><li>Docker Build</li></ul><h2 id="Git-설치-Docker-file-다운로드"><a href="#Git-설치-Docker-file-다운로드" class="headerlink" title="Git 설치 + Docker file 다운로드"></a>Git 설치 + Docker file 다운로드</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git설치</span></span><br><span class="line">yum -y install git</span><br><span class="line">git --version <span class="comment"># git 버전 확인</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#Redis-Cluster 디렉터리 생성</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /home/redis/redis-cluster</span><br><span class="line"> </span><br><span class="line"><span class="comment">#Redis-Cluster-Home 이동</span></span><br><span class="line"><span class="built_in">cd</span> /home/redis/redis-cluster</span><br><span class="line"> </span><br><span class="line"><span class="comment">#아래 디렉터리들은 각 Redis Container의 외부볼륨으로 설정하기 위해 생성하였습니다.</span></span><br><span class="line"><span class="comment">#==&gt; Container 외부 볼륨을 설정해야 Redis Container가 삭제되더라도 Data가 보존됩니다.</span></span><br><span class="line"><span class="comment">#===&gt; dump.rdb 파일이 생성되는 장소</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ./redis-data/redis1</span><br><span class="line"><span class="built_in">mkdir</span> -p ./redis-data/redis2</span><br><span class="line"><span class="built_in">mkdir</span> -p ./redis-data/redis3</span><br><span class="line"> </span><br><span class="line"><span class="comment">#Docker file Download</span></span><br><span class="line"><span class="comment">#설치파일을 다운받습니다.</span></span><br><span class="line">git init</span><br><span class="line">git remote add origin <span class="string">&quot;https://github.com/jaehun2841/redis-cluster-on-docker.git&quot;</span></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><h2 id="Docker-설치"><a href="#Docker-설치" class="headerlink" title="Docker 설치"></a>Docker 설치</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker 설치</span></span><br><span class="line">curl -fsSL https://get.docker.com/ | sh</span><br><span class="line"> </span><br><span class="line"><span class="comment">#docker 설치 후 docker 시작</span></span><br><span class="line">service docker start</span><br></pre></td></tr></table></figure><p>Docker를 yum으로도 설치가 가능하지만 버전이 낮아 Docker-compose를 설치 할 수 없습니다.<br>차후에 update까지 필요하니 위 url에서 제공하는 shell script를 실행하여 설치하도록 합니다.<br><strong>※ 위 Script는 sudo 명령 또는 root 권한을 필요로 합니다.</strong></p><p>Docker 설치 내용은 2장에서 기술한 내용을 참고하시길 바랍니다.</p><h2 id="Docker-Compose-설치"><a href="#Docker-Compose-설치" class="headerlink" title="Docker-Compose 설치"></a>Docker-Compose 설치</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker 공식 github에서 다운로드</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>Docker-Compose 설치 내용은 4장에서 기술한 내용을 참고하시길 바랍니다.</p><h2 id="Docker-build"><a href="#Docker-build" class="headerlink" title="Docker build"></a>Docker build</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cluster home 이동</span></span><br><span class="line"><span class="built_in">cd</span> /home/redis/redis-cluster</span><br><span class="line"> </span><br><span class="line"><span class="comment">#docker build</span></span><br><span class="line">docker-compose -f conf/docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure><ul><li>-f 옵션으로 docker-compose.yml 파일을 설정합니다.<br>(docker-compose.yml 파일은 github redis-cluster 설치파일을 받을때 다운 받았습니다. )</li><li>up 명령으로 docker container를 실행합니다.</li><li>–build 옵션으로 build후 container를 실행합니다.</li><li>-d 옵션으로 background로 실행되도록 합니다.<br>(-d 옵션을 빼면 redis의 로그가….나오며 exit하는 순간 container가 stop됩니다.)</li></ul><h1 id="Redis-Cluster를-빌드하기-위한-docker-compose-yml-파일"><a href="#Redis-Cluster를-빌드하기-위한-docker-compose-yml-파일" class="headerlink" title="Redis Cluster를 빌드하기 위한 docker-compose.yml 파일"></a>Redis Cluster를 빌드하기 위한 docker-compose.yml 파일</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-master:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">redis:5.0-alpine</span>   <span class="comment"># image 옵션으로 redis공식이미지를 기반으로 생성합니다.</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span>             <span class="comment"># build file에 대한 context를 지정</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span>  <span class="comment">#dockerfile명을 지정합니다. (Default는 &quot;Dockerfile&quot; 파일명을 가진 파일을 실행합니다.)</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span>      <span class="comment"># Image가 Container가 되었을때 network모드를 host모드로 설정합니다 (docker0 인터페이스를 사용하지 않고 Host OS의 eth0 인터페이스 사용)</span></span><br><span class="line">     <span class="string">environment:</span>              <span class="comment"># Container 내부에서 사용 할 환경변수를 설정합니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=</span></span><br><span class="line">     <span class="string">volumes:</span>  <span class="comment"># Host OS의 디렉터리와 Container내의 디렉터리와 연동합니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../redis-data/redis1:/data&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-slave1:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">redis:5.0-alpine</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../redis-data/redis2:/data&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-slave2:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">redis:5.0-alpine</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6381</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span> </span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../redis-data/redis3:/data&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Redis Container의 Network모드가 Host인 이유</strong><br>Redis 공식 홈페이지의 cluster-tutorial에서 발췌한 내용입니다.</p><blockquote><p>Redis Cluster and Docker</p><p>Currently Redis Cluster does not support NATted environments and in general environments where IP addresses or TCP ports are remapped.<br>Docker uses a technique called port mapping: programs running inside Docker containers may be exposed with a different port compared to the one the program believes to be using.<br>This is useful in order to run multiple containers using the same ports, at the same time, in the same server.<br><code>In order to make Docker compatible with Redis Cluster you need to use the host networking mode of Docker.</code> Please check the –net&#x3D;host option in the Docker documentation for more information.</p></blockquote><p>Redis Cluster에서는 NAT환경과 IP주소 또는 TCP포트가 재 매핑되는 환경을 지원하지 않는다고 합니다.<br>따라서 Docker에서 Redis Cluster를 호환되게 하기 위해서는 Host 모드로 사용할 것을 권고하고 있습니다.</p></blockquote><h1 id="Redis-Container-생성을-위한-Dockerfile-작성"><a href="#Redis-Container-생성을-위한-Dockerfile-작성" class="headerlink" title="Redis Container 생성을 위한 Dockerfile 작성"></a>Redis Container 생성을 위한 Dockerfile 작성</h1><p>Docker-Compose build를 사용하면서 Dockerfile에는 Redis Container를 구성하는 공통적인 로직을 담았습니다.<br>주로 내부에서 file을 생성하거나 Host OS의 파일을 Container가 생성하는 시점에 복사하기 위한 로직이 주로 들어있습니다.<br>그리고 접근권한이 막혀 파일이 실행되지 않는 문제를 해결하기 위해 접근권한을 변경하였습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FROM redis:5.0-alpine //redis 이미지를 기반으로 빌드됨을 의미합니다.</span><br><span class="line"> </span><br><span class="line">MAINTAINER Carrey (jaehun2841@gmail.com)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Copy Redis File</span></span><br><span class="line"><span class="comment"># 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 합니다.</span></span><br><span class="line"><span class="comment"># 기존의 docker-entryporint.sh 파일을 삭제합니다.</span></span><br><span class="line">RUN <span class="built_in">rm</span> -rf /usr/local/bin/docker-entrypoint.sh  </span><br><span class="line"><span class="comment"># 공통적으로 적용할 redis.conf 파일을 복사합니다.</span></span><br><span class="line">ADD redis.conf /usr/local/bin/redis.conf    </span><br><span class="line"><span class="comment"># Container가 생성, 시작하는 시점에 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.</span></span><br><span class="line">ADD docker-entrypoint.sh /usr/local/bin        </span><br><span class="line"> </span><br><span class="line"><span class="comment">## change access authority</span></span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /usr/local/bin/redis.conf</span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /usr/local/bin/docker-entrypoint.sh</span><br><span class="line"> </span><br><span class="line">RUN <span class="built_in">chown</span> redis:redis /usr/local/bin/redis.conf</span><br><span class="line">RUN <span class="built_in">chown</span> redis:redis /usr/local/bin/docker-entrypoint.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#Redis Container에 대한 Port를 지정합니다. (내부포트이며 외부노출은 안됨)</span></span><br><span class="line">EXPOSE <span class="variable">$CLIENTPORT</span> <span class="comment">#CLIENTPORT에 대한 값은 docker-compose.yml에 정의되어 있습니다.          </span></span><br><span class="line"><span class="comment"># Container가 생성, 시작하는 시점에 실행됩니다.</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/usr/local/bin/docker-entrypoint.sh&quot;</span>] </span><br><span class="line"><span class="comment"># Container 빌드가 완료되고 Redis Server를 실행시킵니다.</span></span><br><span class="line">CMD [ <span class="string">&quot;redis-server&quot;</span>,<span class="string">&quot;/usr/local/bin/redis.conf&quot;</span> ] </span><br></pre></td></tr></table></figure><h1 id="Redis-Cluster-설정"><a href="#Redis-Cluster-설정" class="headerlink" title="Redis Cluster 설정"></a>Redis Cluster 설정</h1><p>Redis Cluster에 대한 Replication 설정에 대해 알아보겠습니다.</p><p>설정 방법은 redis.conf 파일을 각 Container로 복사하여 공통적인 설정을 하였습니다.<br>각 redis.conf 파일에 대한 변경사항은 <code>docker-entrypoint.sh</code> 파일을 통해 redis.conf 파일 정보를 replace하였습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"> </span><br><span class="line"><span class="comment">## from redis-5.0</span></span><br><span class="line"><span class="comment"># Redis서버에 접근가능한 Host를 설정합니다.</span></span><br><span class="line">sed -i <span class="string">&quot;s/bind 127.0.0.1/bind <span class="variable">$CLIENTHOST</span> 127.0.0.1/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">### redis port inside redis.conf</span></span><br><span class="line"><span class="comment">#redis.conf 파일의 port 6379 문자열을 port $CLINETPORT로 변경합니다. </span></span><br><span class="line"><span class="comment">#($CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.)</span></span><br><span class="line">sed -i <span class="string">&quot;s/port 6379/port <span class="variable">$CLIENTPORT</span>/g&quot;</span> /usr/local/bin/redis.conf </span><br><span class="line"></span><br><span class="line"><span class="comment"># requirepass foobared 문자열을 requirepass $REQUIREPASS로 변경하였습니다. </span></span><br><span class="line"><span class="comment">#(Redis 접속 시 비밀번호를 설정하였습니다.)</span></span><br><span class="line">sed -i <span class="string">&quot;s/# requirepass foobared/requirepass <span class="variable">$REQUIREPASS</span>/g&quot;</span> /usr/local/bin/redis.conf          </span><br><span class="line">sed -i <span class="string">&quot;s/# masterauth &lt;master-password&gt;/masterauth <span class="variable">$REQUIREPASS</span>/g&quot;</span> /usr/local/bin/redis.conf   </span><br><span class="line"></span><br><span class="line"><span class="comment">### slaveof &lt;masterip&gt; &lt;masterport&gt; =&gt; slaveof $MASTERHOST $MASTERPORT</span></span><br><span class="line"><span class="comment"># $MASTERPORT가 공백이 아닌 Container에 대해 slaveof 설정을 통해 Master-Slave 설정을 합니다.</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$MASTERPORT</span>&quot;</span> != <span class="string">&quot;&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    sed -i <span class="string">&quot;s/# slaveof &lt;masterip&gt; &lt;masterport&gt;/slaveof <span class="variable">$MASTERHOST</span> <span class="variable">$MASTERPORT</span>/g&quot;</span> /usr/local/bin/redis.conf  </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;1#-&#125;</span>&quot;</span> != <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;1%.conf&#125;</span>&quot;</span> != <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">set</span> -- redis-server <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">chown</span> -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Redis-Cluster-실행-결과"><a href="#Redis-Cluster-실행-결과" class="headerlink" title="Redis Cluster 실행 결과"></a>Redis Cluster 실행 결과</h1><p>Redis.log<br><img src="./redis-replication-3746317.PNG" alt="redis-replication"></p><p>로그에서 0 clients connected (2 slaves) 라는 로그가 보입니다.<br>Redis에 접속한 클라이언트 수는 0 client이며<br>2개의 slave redis와 연결하고 있습니다.</p><p>중간부분 로그에서 로그를 보면 slave로 설정한 Redis와 연동이 되는 것을 확인 할 수 있습니다.</p><p>redis-cli &gt; info replication<br><img src="./redis-replication2-3746337.PNG" alt="redis-replication2"></p><p>redis-cli에서 info replication 명령을 실행하였을 때, 조회되는 내용입니다.<br>slave0, slave1에 대한 참조를 가지고 있는 것을 확인 할 수 있습니다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://redis.io/topics/cluster-tutorial">https://redis.io/topics/cluster-tutorial</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker기반 Redis 구축하기 - (5) Docker Network구조</title>
      <link href="/2018/12/01/2018-12-01-docker-5/"/>
      <url>/2018/12/01/2018-12-01-docker-5/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-Network-모드"><a href="#Docker-Network-모드" class="headerlink" title="Docker Network 모드"></a>Docker Network 모드</h1><p>Docker에서 제공하는 Network 모드는 총 4개 입니다.<br>(추가적으로 2개의 모드가 더 있습니다. Overlay, Macvlan 모드가 있지만 Docker Swarm과 관련된 내용이므로 이번 장에서는 기술 하지 않겠습니다.)</p><ul><li>Bridge 모드</li><li>Container 모드 (이것도 Bridge 모드의 일종)</li><li>Host 모드</li><li>none 모드</li></ul><p>이번 장에서는 위 Network 모드에 대해 알아보도록 하겠습니다.</p><h1 id="Bridge-모드"><a href="#Bridge-모드" class="headerlink" title="Bridge 모드"></a>Bridge 모드</h1><p>Docker에서 network 설정을 별도로 하지 않으면 Default로 작용하는 모드입니다.<br>Docker가 설치되면 docker0라는 네트워크 인터페이스가 생성됩니다. (Virtual Interface)</p><p><img src="./docker-bridge-mode.png" alt="docker-bridge-mode"></p><p>위는 docker0 인터페이스를 바탕으로 각 Container와 Bridge 형식으로 엮어진 모습입니다.</p><p><img src="./docker-bridge-2.PNG" alt="docker-bridge-2"></p><p>Host OS에서 network interface를 검색해 보면 docker0라는 virtual interface를 확인할 수 있습니다.</p><blockquote><p><strong>docker0 interface의 특징</strong></p><ul><li>IP는 자동으로 172.17.0.1로 설정</li><li>IP는 DHCP로 할당받는 것이 아닌 Docker 내부로직에 의해 결정</li><li>docker0는 virtual ethernet bridge</li><li>L2 통신 기반</li></ul></blockquote><p><code>&quot;docker bridge 모드는 같은 host 내에서만 사용 가능하다.&quot;</code> 라는 제약이 있다.<br>즉, 다른 host(다른서버)와의 docker와는 통신이 불가능합니다.<br>왜냐하면 다른 서버가 docker0 인터페이스의 외부에 있기 때문에 그렇습니다.</p><h1 id="docker0-interface와-Container의-연결-방식"><a href="#docker0-interface와-Container의-연결-방식" class="headerlink" title="docker0 interface와 Container의 연결 방식"></a>docker0 interface와 Container의 연결 방식</h1><p><img src="./docker0-interface.PNG" alt="docker0-interface"></p><p>위 이미지를 보면, 현재 Docker를 이용하여 redis와 nginx를 설치한 상태입니다.<br>두 번째 명령을 보면 brctl명령으로 docker0 interface에 연결된 interfaces가 2개 보입니다.</p><ul><li>veth062947b</li><li>veth3b5bdll</li></ul><p>container 2개가 bridge 방식으로 연결 되어 있기 때문에 veth~하는 interface가 생성되어있습니다.<br>위에 그림에서 보듯이 veth와 각 container 내부의 eth0 interface와 연결되어 있습니다.</p><p><img src="./ip.PNG" alt="ip"></p><p>Redis Container에 대해 docker inspect 명령을 날려보았습니다.<br>네트워크 설정 부분이 아래에 나오는데 Network 부분을 보시면 Gateway는 172.17.0.1이라 되어 있습니다.<br>이 ip 주소는 docker0 interface의 ip주소입니다.<br>따라서 docker0의 bridge로 연결되어 172.17.0.2라는 내부 ip를 가진 Container로 생성된 것입니다.</p><h1 id="Container-모드-이것도-Bridge-모드의-일부"><a href="#Container-모드-이것도-Bridge-모드의-일부" class="headerlink" title="Container 모드 (이것도 Bridge 모드의 일부)"></a>Container 모드 (이것도 Bridge 모드의 일부)</h1><p>Container 모드는 다른 Container의 네트워크 리소스를 같이 쓰는? 개념입니다.</p><p>먼저 httpd를 설치하고..<br>그다음에 redis를 설치하여 httpd의 container 정보를 가지고 net설정을 해주었습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d httpd</span><br><span class="line">docker run -d --net=container:(httpd의 containerId) redis</span><br></pre></td></tr></table></figure><p><img src="./httpd.PNG" alt="httpd"></p><p>위 이미지(httpd에 대한 정보)를 보면 docker0 interface를 이용하고 bridge 모드로 설정되어 있습니다.</p><p><img src="./redis1.PNG" alt="redis1"></p><p>하지만, Redis의 Network 정보를 보면 텅텅 비어있습니다.<br>이는 docker0 interface를 통해 네트워크 설정이 bind 되지 않았다는 의미입니다.</p><p>약간 위로 올려보면</p><p><img src="./redis2.PNG" alt="redis2"></p><p>NetworkMode에 httpd의 container 자원을 사용하여 접근하는 것을 알 수 있습니다.<br>다른 docker image 중 내부 명령어로 ip addr을 지원하는 image가 있다면</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> &lt;container ID&gt; ip addr show</span><br></pre></td></tr></table></figure><p>위 명령을 통해 Mac Address가 Container자원을 할당한 Container의 Mac Address와 같음을 알 수 있습니다.</p><h1 id="Host-모드"><a href="#Host-모드" class="headerlink" title="Host 모드"></a>Host 모드</h1><p>Host 모드는 docker0 interface를 사용하지 않고 Host OS의 네트워크 자원을 사용합니다.<br>bridge 형식으로 사용하지 않기 때문에 brctl show docker0 명령으로 검색해도 interfaces에 나타나지 않습니다.<br><strong>Bridge를 쓰지 않기 때문에 Container에서 <code>Port를 노출하지 않는 경우 사용할 수가 없는 점</code>을 유의 해야 합니다.</strong><br>(Redis Cluster를 구성 할 때에도 Redis에서는 Cluster모드 구현 시, docker bridge mode를 지원하지 않기 때문에 host로 설정했었습니다.)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=host -p <span class="string">&quot;6515&quot;</span> <span class="comment">#이렇게 옵션을 추가해주면 됩니다. (port는 문자열로!)</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#또는 docker-compose.yml 파일에서</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">network_mode:</span> <span class="string">host</span> <span class="comment">#이 처럼 표기하시면 됩니다.</span></span><br></pre></td></tr></table></figure><h1 id="none-모드"><a href="#none-모드" class="headerlink" title="none 모드"></a>none 모드</h1><p>–net&#x3D;none 옵션으로 Container 생성 시, 격리된 네트워크 영역을 갖기는 하지만 network 인터페이스가 없는 Container가 생성 됩니다.</p><p>아래의 코드로 테스트를 해보았습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=none -d httpd</span><br><span class="line">docker <span class="built_in">exec</span> httpd ip addr show</span><br></pre></td></tr></table></figure><p><img src="./none.PNG" alt="none"></p><p>검색되는 내부 네트워크 인터페이스가 없습니다.</p><blockquote><p><strong>none으로 처리하는 이유</strong><br>network mode를 none으로 하는 경우는 보통 사용자 정의 interface를 사용할 때 입니다.<br>network 환경을 깔끔하게 만든 다음에 사용자 정의 interface를 적용하기 위함입니다.</p></blockquote><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="http://bluese05.tistory.com/38">http://bluese05.tistory.com/38</a></li><li><a href="https://docs.docker.com/network/network-tutorial-standalone/#use-the-default-bridge-network">https://docs.docker.com/network/network-tutorial-standalone/#use-the-default-bridge-network</a></li><li><a href="https://docs.docker.com/network/network-tutorial-host/">https://docs.docker.com/network/network-tutorial-host/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker기반 Redis 구축하기 - (4) Docker-Compose 설치 및 사용방법</title>
      <link href="/2018/12/01/2018-12-01-docker-4/"/>
      <url>/2018/12/01/2018-12-01-docker-4/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-Compose-이란"><a href="#Docker-Compose-이란" class="headerlink" title="Docker-Compose 이란?"></a>Docker-Compose 이란?</h1><p>기존에는 Docker를 이용해서 1개의 이미지를 바탕으로 하나의 소프트웨어에 대한 컨테이너를 만들 수 있었습니다.<br>하지만 목표는 Web Server도 설치하고, DB도 설치하고, IDE도 설치해서 한 세트로 배포를 해주고 싶은데… 지금까지 배운 방법으로는 Docker image를 내가 필요한 것만큼 다운받아서 Container를 생성해야 합니다.</p><p>이때 필요한 개념이 Docker-Compose입니다.<br>Docker-Compose는 사용자에게 한번에 여러가지 소프트웨어에 대한 이미지 정보를 담아 빌드 할 수 있습니다.<br>사용자는 Docker-Compose로 만든 파일을 다운받아 이미지 내에 포함된 소프트웨어에 대한 Container를 한번에 만들 수 있습니다.</p><h1 id="Docker-Compose-설치"><a href="#Docker-Compose-설치" class="headerlink" title="Docker-Compose 설치"></a>Docker-Compose 설치</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker 공식 github에서 다운로드</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>다운로드 받은 docker-compose 파일을 실행 가능한 파일로 만듭니다.<br>(보통의 리눅스 실행파일 path는 <code>/usr/local/bin</code>입니다. <strong>OS별로 다를 수 있습니다.</strong>)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h1 id="Docker-compose-yml"><a href="#Docker-compose-yml" class="headerlink" title="Docker-compose.yml"></a>Docker-compose.yml</h1><p>Docker-compose.yml 파일은 생성하고자 하는 Container들의 image 정보들을 담고 있는 설정 파일입니다.<br>여기에 설치하고자 하는 소프트웨어들의 빌드정보를 지정 할 수 있습니다.<br>또한 Docker에서 사용한 설정정보를 기술 할 수 있어 사용자는 파일을 받아 별도의 옵션 없이 Container만 생성하면 됩니다.</p><h1 id="Docker-Compose-yml에서-자주-사용하는-options"><a href="#Docker-Compose-yml에서-자주-사용하는-options" class="headerlink" title="Docker-Compose.yml에서 자주 사용하는 options"></a>Docker-Compose.yml에서 자주 사용하는 options</h1><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>build는 해당 이미지가 빌드 될 때 사용 할 Dockerfile을 지정할 수 있는 options입니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">redis:5.0-alpine</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">       <span class="attr">args:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">buildno :</span> <span class="number">1</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">username :</span> <span class="string">carrey</span></span><br></pre></td></tr></table></figure><ul><li><p>context : dockerfile의 위치를 지정합니다. Default는 현재위치 (.&#x2F;) 입니다.</p></li><li><p>dockerfile : dockerfile명을 지정합니다 Default는 Dockerfile 입니다.</p></li><li><p>args : Dockerfile내에서 사용할 Arguments를 설정합니다.</p></li></ul><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>command는 Dockerfile에서 CMD역할을 했던 명령을 <code>Override</code>합니다.<br>(Dockerfile과 같이 사용하는 경우 Dockerfile의 CMD명령이 아닌 <code>Docker-compose의 command명령이 실행</code>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1:</span></span><br><span class="line">  <span class="attr">command :</span> <span class="string">startup.sh</span> <span class="string">-p</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><h2 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h2><p>Docker-compose 내의 이미지가 2개 이상인 경우 실행 의존성을 줄 수 있습니다.<br>예를들어 DB가 먼저 실행된 다음에 WAS가 실행되어야 하는 경우 Docker-Compose에서는 depend_on 설정에 따라 다른 이미지를 먼저 빌드 합니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span> <span class="string">//web</span> <span class="string">이미지에</span> <span class="string">대한</span> <span class="string">Container는</span> <span class="string">redis와</span> <span class="string">db가</span> <span class="string">생성되고</span> <span class="string">시작되기</span> <span class="string">전에는</span> <span class="string">빌드되지</span> <span class="string">않습니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span>       </span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure><h2 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h2><p>Container가 run 또는 start 시, entrypoint 로직을 실행 합니다.<br>entrypoint와 Dockerfile이 함께 사용되는 경우, <code>Dockerfile의 ENTRYPOINT설정은 무시됩니다.</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1 :</span> </span><br><span class="line"><span class="attr">image:</span> <span class="string">redis:5.0-alpine</span></span><br><span class="line"><span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure><h2 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h2><p>Env 파일을 Container 내부에 import 하는 경우에 사용합니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ubuntu:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line">    <span class="attr">env_file :</span> <span class="string">../env/environments.env</span></span><br></pre></td></tr></table></figure><h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><p>Container 내부에서 사용할 환경 변수를 등록합니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1:</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.130.93</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.130.93</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br></pre></td></tr></table></figure><h2 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h2><p>Container내의 내부 포트만 설정 (외부 노출은되지 않습니다.)<br>link된 Container끼리는 expose에 설정된 포트로 통신이 가능</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line"><span class="attr">expose:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure><h2 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h2><p>Host OS 포트와 Container 내부포트 매핑 (포트포워딩)<br>Host OS 포트를 사용할 수 있으므로 외부접속이 가능</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tomcat:</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;80:8080&quot;</span>  <span class="comment"># &lt;Host OS포트&gt; : &lt;컨테이너 내부포트&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">#Short Syntax --&gt; 권장하는 방식</span></span><br><span class="line"><span class="attr">ubuntu:</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span>        <span class="comment">#이 구문은 &quot;3000:3000&quot; 과 동일</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;3000-3005&quot;</span>   <span class="comment">#이 구문은 &quot;3000-3005:3000-3005&quot;와 동일</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;9090-9091:8080-8081&quot;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;49100:22&quot;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:8001:8001&quot;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:5000-5010:5000-5010&quot;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;6060:6060/udp&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#Long Syntax --&gt; 권장하지 않는 방식</span></span><br><span class="line"><span class="attr">tomcat2:</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">target :</span> <span class="number">8080</span> <span class="comment">#Container 내부포트</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">published :</span> <span class="number">80</span> <span class="comment"># 외부 OS 포트</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">protocol :</span> <span class="string">tcp</span> <span class="comment"># tcp 또는 udp</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">mode :</span> <span class="string">host</span> <span class="comment">#host: 각각의 Container 노드와 1:1로 매핑 </span></span><br></pre></td></tr></table></figure><blockquote><p>포트 매핑 시 주의 할 점<br>Host : Container 형식으로 포트를 매핑하면 YAML이 xx:yy 형식은 구문 분석시에 default를 60으로 주기 때문에 60번 이하 포트에 대해서 잘못된 결과가 초래될 수 있음.<br>(8000 : 22 와 같이 숫자만 적는 경우 문제가 발생)<br>따라서, <code>포트 매핑은 항상 문자열로 적어야 합니다.</code><br>( “8000 : 22”와 같이 문자열로 선언해야 안전합니다. ) &#x3D;&#x3D;&gt; 60번 이하 포트를 쓰지말라는 소리가 아님.</p></blockquote><h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><p>어떤 image를 바탕으로 생성할 것인지 지정합니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span> </span><br><span class="line">      <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">ubuntu:</span> </span><br><span class="line">      <span class="attr">image:</span> <span class="string">ubuntu:14.04</span></span><br></pre></td></tr></table></figure><h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><ul><li>다른 Container와 연결하기 위해 설정합니다.</li><li>외부 Port노출이 안되어도 Expose명령으로 노출된 Port로 연결</li><li>network_mode가 <code>host인 경우 사용할 수 없습니다.</code> (host인 경우 Host OS의 port를 직접 사용하기 때문)</li><li>서비스 이름:Alias 형태로 선언하거나 서비스 이름만 지정합니다.</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line">  <span class="attr">link:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">db:mycontainerdb-alias</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">db:</span> </span><br><span class="line">  <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">redis:</span> </span><br><span class="line">  <span class="attr">image:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><h2 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h2><p>Docker network policy 설정 (다음 장에 상세 설명하겠습니다.)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;bridge&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;none&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;service:[service name]&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;container:[container name/id]&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>Docker Swarm을 사용하는 경우 network_mode 옵션은 무시됩니다.</p></blockquote><h2 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h2><ul><li>Host OS의 디렉터리 경로를 Container 내부의 디렉터리에 Mount 합니다. (쉽게 말해서 디렉토리가 연동됩니다.)</li><li>docker run -v 또는 –volume과 같습니다.</li><li>Dockerfile의 VOLUME[] 과 같습니다.</li><li>docker-compose.yml의 volumes에는 상대경로를 지정할 수 있습니다.</li><li>호스트:컨테이너:권한 순으로 작성하여 읽기&#x2F;쓰기 권한 설정을 할 수 있습니다. (Default는 rw)<ul><li>ro : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수만 있음. Container에서 파일에 대한 수정이 불가능합니다.</li><li>rw : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수 있고, Container에서 파일 수정이 가능하고, Host OS 디렉토리에 반영이 됩니다.</li></ul></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span> </span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">/usr/local/redis/data:/data</span> <span class="comment"># &lt;Host OS 디렉터리 경로&gt; : &lt;Container 내부 data 경로&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">/usr/local/redis/data:/data:ro</span> <span class="comment">#ReadOnly </span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">/usr/local/redis/data:/data:rw</span> <span class="comment">#ReadWrite</span></span><br></pre></td></tr></table></figure><h2 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h2><p>Container 재 시작에 대한 policy를 설정합니다.</p><ul><li>no : 문제가 발생하여 Container가 중지된 경우 재시작 하지 않음 (default)</li><li>always : 어떠한 문제로 Container가 중지되는 경우 무조건 재시작 </li><li>on-failure : Container의 exit code 0 이 아닌 경우 재시작</li><li>unless-stopped : 명시적으로 중지되거나, Docker 자체가 중지되는 경우 재시작</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="literal">no</span>            </span><br><span class="line"><span class="attr">restart:</span> <span class="string">always</span>          </span><br><span class="line"><span class="attr">restart:</span> <span class="string">on-failure</span>      </span><br><span class="line"><span class="attr">restart:</span> <span class="string">unless-stopped</span>  </span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></li><li><a href="http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/">http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/</a></li><li><a href="https://www.joinc.co.kr/w/man/12/docker/Guide/DataWithContainer">https://www.joinc.co.kr/w/man/12/docker/Guide/DataWithContainer</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker기반 Redis 구축하기 - (3) Dockerfile</title>
      <link href="/2018/12/01/2018-12-01-docker-3/"/>
      <url>/2018/12/01/2018-12-01-docker-3/</url>
      
        <content type="html"><![CDATA[<h1 id="Dockerfile-이란"><a href="#Dockerfile-이란" class="headerlink" title="Dockerfile 이란?"></a>Dockerfile 이란?</h1><p>이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소프트웨어에 대한 공식이미지도 있지만, Docker Hub 사용자들이 공식이미지를 바탕으로 커스터마이징하여 배포한 이미지도 등록되어 있습니다.</p><p>어떻게 이미지를 빌드하고 배포 할 수 있었을까요? <strong>Dockerfile을 이용한 이미지 빌드를 이용하면 가능합니다.</strong></p><p>Dockerfile은 이미지를 바탕으로 몇가지 명령을 실행 할 수 있는 로직을 담은 파일입니다.<br>Dockerfile을 통해 더 유연하게 이미지에 대한 설정을 변경할 수 있고, 그 설정을 이미지에 담아 배포 할 수 있습니다.</p><p>물론 Docker run 구문에서 options을 사용하여 같은 기능을 하도록 구현 할 수 있지만, Dockerfile로 작성하게 되면 향후 유지보수가 쉬워지고 run 구문에 대한 options을 전부 기억하지 않아도 되는 장점이 있습니다.</p><p>이번 장에서는 Dockerfile을 작성하는 명령어를 위주로 알아보겠으며, 간단한 예제 Dockerfile을 보도록 하겠습니다.</p><h1 id="Dockerfile-사용방법"><a href="#Dockerfile-사용방법" class="headerlink" title="Dockerfile 사용방법"></a>Dockerfile 사용방법</h1><p>Dockerfile을 이용한 docker build</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dockerfile이 위치한 directory의 dockerfile을 가지고 build합니다.</span></span><br><span class="line">docker build -f /path/to/dockerfile </span><br></pre></td></tr></table></figure><h1 id="Dockerfile을-구성하는-핵심-명령어"><a href="#Dockerfile을-구성하는-핵심-명령어" class="headerlink" title="Dockerfile을 구성하는 핵심 명령어"></a>Dockerfile을 구성하는 핵심 명령어</h1><h2 id="From-Dockerfile의-시작"><a href="#From-Dockerfile의-시작" class="headerlink" title="From - Dockerfile의 시작"></a>From - Dockerfile의 시작</h2><p>From 명령어는 어떤 이미지를 바탕으로 container를 빌드 할 것인지 명시합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis:5.0-alpine 이미지를 바탕으로 빌드</span></span><br><span class="line">From redis:5.0-alpine</span><br></pre></td></tr></table></figure><h2 id="CMD-Dockerfile의-끝"><a href="#CMD-Dockerfile의-끝" class="headerlink" title="CMD - Dockerfile의 끝"></a>CMD - Dockerfile의 끝</h2><ul><li>CMD명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li><li>보통은 해당 프로그램을 실행시키는 명령을 사용합니다. ( ex&gt; startup.sh)</li><li>CMD 명령은 Dockerfile에서 <code>단 한번만 사용</code>할 수 있습니다.</li></ul><p>명령어 예제</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 일반적인 실행 방법</span></span><br><span class="line">CMD [<span class="string">&quot;execute.sh&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># Entrypoint 실행을 위한 Default Parameter - Entrypoint를 위한 파라미터를 제공</span></span><br><span class="line">CMD [<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># shell form</span></span><br><span class="line">CMD execute.sh param1 param2</span><br></pre></td></tr></table></figure><blockquote><p>CMD 구문 사용 시, 주의사항!</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -f ./dockerfile <span class="built_in">test</span></span><br><span class="line"><span class="comment"># Container 생성 시, docker run [이미지] [실행파일 또는 명령] 입니다.</span></span><br><span class="line">docker run <span class="built_in">test</span> <span class="built_in">echo</span> <span class="string">&quot;test!&quot;</span> </span><br></pre></td></tr></table></figure><p>위 예시 처럼 run 명령 시, 이미지 명 뒤에 <code>실행파일이나 명령어</code>가 오게되면 CMD에 설정된 명령은 <code>무시</code>되고 docker run 구문에서 사용된 명령이 <strong>CMD 대신 실행</strong>됩니다.</p></blockquote><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><ul><li>ENTRYPOINT명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li><li>보통 스크립트를 실행하거나, 실행명령을 수행하게 됩니다.</li><li>ENTRYPOINT명령은 Dockerfile에서 <code>단 한번만 사용가능</code> 합니다.</li><li>기본적으로 FROM에서 설정한 이미지의 &#x2F;bin&#x2F;sh 파일을 기반으로 실행되며, 이미지에 &#x2F;bin&#x2F;sh 파일이 없는 경우 실행이 불가능 합니다.</li></ul><p>ENTRYPOINT 사용 예시</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;docker-entrypoint.sh&quot;</span>, <span class="string">&quot;--param1=true&quot;</span>, <span class="string">&quot;--param2=1&quot;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#run 명령의 options으로 구현한 방식</span></span><br><span class="line"><span class="comment">#이러한 방식으로도 사용할 수 있지만, 추천하지 않는 안티패턴입니다.</span></span><br><span class="line">docker run --entrypoint=<span class="string">&quot;docker-entrypoint.sh&quot;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h1 id="Dockerfile에서-자주-사용하는-명령어"><a href="#Dockerfile에서-자주-사용하는-명령어" class="headerlink" title="Dockerfile에서 자주 사용하는 명령어"></a>Dockerfile에서 자주 사용하는 명령어</h1><h2 id="ADD-파일을-Container에-추가"><a href="#ADD-파일을-Container에-추가" class="headerlink" title="ADD - 파일을 Container에 추가"></a>ADD - 파일을 Container에 추가</h2><ul><li>Container 내부에 Host OS의 파일을 추가하려고 할 때 사용합니다.</li><li>ADD &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li><li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li><li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li><li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li><li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li><li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀어서 Container에 추가됩니다.<br>(Container에 압축 해제 된 파일들이 추가됨)</li><li>인터넷에 있는 파일 URL은 압축만 해제된 뒤, tar파일만 추가됩니다.</li><li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li><li>ADD로 추가되는 파일은 root root 기존 권한을 따릅니다 (단, URL로 추가된 파일의 경우 600)</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADD ../file.sh /home/file.sh (x) <span class="comment">#상위 디렉터리 사용x</span></span><br><span class="line">ADD /home/user/file.sh /home/file.sh(x) <span class="comment">#절대경로 사용x</span></span><br><span class="line">ADD file.sh ../../file.sh (x) <span class="comment">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class="line"> </span><br><span class="line">ADD file.sh /home/file.sh (O) <span class="comment">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class="line">ADD *.sh /home (O) <span class="comment"># 와일드카드를 이용하여 복사 가능</span></span><br><span class="line">ADD compress.tar.gz / <span class="comment"># Container / 경로에 compress.tar파일의 풀어진 형태로 파일 추가</span></span><br><span class="line">ADD http://file.co.kr/file/1234.tar.gz / <span class="comment"># Container 내부의 / 경로에 1234.tar.gz 파일 추가</span></span><br></pre></td></tr></table></figure><h2 id="COPY-파일을-Container로-복사"><a href="#COPY-파일을-Container로-복사" class="headerlink" title="COPY - 파일을 Container로 복사"></a>COPY - 파일을 Container로 복사</h2><ul><li>ADD의 기능과 거의 유사합니다.</li><li>COPY &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li><li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li><li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li><li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li><li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li><li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀지않고 그대로 복사됩니다. <strong>(ADD와 차이점)</strong></li><li>인터넷에 있는 파일 URL은 사용 불가. <strong>(ADD와 차이점)</strong></li><li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li><li>COPY로 추가되는 파일은 root root 기존 권한을 따릅니다</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">COPY ../file.sh /home/file.sh (x) <span class="comment">#상위 디렉터리 사용x</span></span><br><span class="line">COPY /home/user/file.sh /home/file.sh(x) <span class="comment">#절대경로 사용x</span></span><br><span class="line">COPY file.sh ../../file.sh (x) <span class="comment">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class="line"> </span><br><span class="line">COPY file.sh /home/file.sh (O) <span class="comment">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class="line">COPY *.sh /home (O) <span class="comment"># 와일드카드를 이용하여 복사 가능</span></span><br><span class="line">COPY compress.tar.gz / (O)<span class="comment"># Container / 경로에 compress.tar파일이 복사</span></span><br><span class="line">COPY http://file.co.kr/file/1234.tar.gz / (X) <span class="comment"># COPY는 인터넷 파일URL 사용 불가</span></span><br></pre></td></tr></table></figure><h2 id="RUN-Container-내부에서-명령-실행"><a href="#RUN-Container-내부에서-명령-실행" class="headerlink" title="RUN - Container 내부에서 명령 실행"></a>RUN - Container 내부에서 명령 실행</h2><ul><li>기본적으로 &#x2F;bin&#x2F;sh 파일로 실행됩니다.</li><li>Window의 경우 cmd 기반 명령을 수행합니다.</li></ul><p>Dockerfile 내 RUN 명령어 사용법</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># software 설치 명령 실행 (예시의 경우 yum이 Container내부에 설치되어야 합니다.)</span></span><br><span class="line">RUN yum -y install software  </span><br><span class="line"><span class="comment"># /usr/local/redis directory 생성</span></span><br><span class="line">RUN <span class="built_in">mkdir</span> -p /usr/local/redis </span><br><span class="line"><span class="comment"># execute.sh 파일 실행 </span></span><br><span class="line">RUN [<span class="string">&quot;execute.sh&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>] </span><br></pre></td></tr></table></figure><p>명령어의 길이가 긴 경우 \ 문자를 사용하여 append 가능합니다</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN yum -y install software \</span><br><span class="line">         <span class="built_in">echo</span> <span class="string">&quot;install software&quot;</span> \</span><br><span class="line">         <span class="built_in">mkdir</span> -p /usr/local/redis</span><br></pre></td></tr></table></figure><h2 id="ENV-Container-내부에서-사용할-환경-변수-추가"><a href="#ENV-Container-내부에서-사용할-환경-변수-추가" class="headerlink" title="ENV - Container 내부에서 사용할 환경 변수 추가"></a>ENV - Container 내부에서 사용할 환경 변수 추가</h2><p>Container는 Host OS와 독립된 공간이기 때문에 Container 내부에서 사용 할 환경변수를 추가할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV LOCAL_PORT 80</span><br><span class="line">ENV REDIS_HOME /usr/local/bin/redis</span><br></pre></td></tr></table></figure><h2 id="EXPOSE-Container의-Port-설정"><a href="#EXPOSE-Container의-Port-설정" class="headerlink" title="EXPOSE - Container의 Port 설정"></a>EXPOSE - Container의 Port 설정</h2><ul><li>Host OS - Container와 통신할 포트를 설정</li><li>EXPOSE는 Host OS와 연결만 할 뿐 외부에 노출 되지는 않습니다.</li><li>포트를 노출 하기 위해서는 docker run -p 또는 -P 옵션 사용해야 합니다.</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 80   <span class="comment">#Container 내의 Web Server Port 노출</span></span><br><span class="line">EXPOSE 6379 <span class="comment">#Container 내의 Redis Server Port 노출</span></span><br><span class="line"> </span><br><span class="line">EXPOSE 80 6379 <span class="comment">#포트 여러개 노출</span></span><br></pre></td></tr></table></figure><h2 id="VOLUME-외부-볼륨-설정"><a href="#VOLUME-외부-볼륨-설정" class="headerlink" title="VOLUME - 외부 볼륨 설정"></a>VOLUME - 외부 볼륨 설정</h2><ul><li>Container 내부의 Directory와 Host OS의 Directory를 동기화 시키는 설정</li><li>log파일이나 설정파일은 보통 Container 내부에만 있는데 이를 Host OS에 동기화 하여 파일에 대한 접근이 가능하게 한다.</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile volume 설정</span></span><br><span class="line">VOLUME [<span class="string">&quot;/data&quot;</span>, <span class="string">&quot;/var/log&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker run 사용 시, volumn 설정</span></span><br><span class="line"><span class="comment"># -v 옵션을 사용하여 설정 -v &lt;host 디렉터리&gt;:&lt;컨테이너 디렉터리&gt;</span></span><br><span class="line">docker run -v /host/os/data:/container/data app </span><br></pre></td></tr></table></figure><h2 id="WORKDIR-Container의-Work-Directory-설정"><a href="#WORKDIR-Container의-Work-Directory-설정" class="headerlink" title="WORKDIR - Container의 Work Directory 설정"></a>WORKDIR - Container의 Work Directory 설정</h2><ul><li>RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉터리</li><li>중간에 Directory가 변경되는 경우 바꿀수 있다.</li><li>리눅스의 cd 명령어와 비슷하다.</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /usr/local/bin</span><br><span class="line">ADD redis.conf /usr/local/bin/redis.conf</span><br><span class="line"> </span><br><span class="line">WORKDIR /usr/local</span><br><span class="line">ADD redis.log /usr/local/redis.log</span><br><span class="line"></span><br><span class="line">WORKDIR var</span><br><span class="line">WORKDIR lib</span><br><span class="line">RUN <span class="built_in">touch</span> file.sh <span class="comment"># /var/lib/file.sh 생성</span></span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="http://pyrasis.com/book/DockerForTheReallyImpatient">http://pyrasis.com/book/DockerForTheReallyImpatient</a></li><li><a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker기반 Redis 구축하기 - (2) Docker 설치 및 사용방법</title>
      <link href="/2018/11/28/2018-11-28-docker-2/"/>
      <url>/2018/11/28/2018-11-28-docker-2/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>지난 장에서는 Docker에 대한 개념, Image와 컨테이너, VM과의 차이점등을 그림으로 설명하였습니다.<br>이번 장부터는 Docker를 linux서버에 설치하는 과정을 설명하고자 합니다.<br>(Linux서버 설치는 hyper-v를 이용하여 vm으로 설치 하였습니다. &lt;차후에 hyper-v 설정기를 올릴 예정입니다.&gt;)<br>Windows, Mac에도 설치 할 수 있지만, Linux에 설치하는게 거의 표준이다 싶히 사용되고 있으며, Windows, Mac에 설치를 하더라도 어차피 가상화 환경에서 Docker가 설치 되기 때문에… linux를 설치하여 Docker를 설치하였습니다.<br>(지울 때 편하게 지우고 싶어서 그런건 안비밀)</p><h1 id="CentOS-7-환경에서-Docker-설치하기"><a href="#CentOS-7-환경에서-Docker-설치하기" class="headerlink" title="CentOS 7 환경에서 Docker 설치하기"></a>CentOS 7 환경에서 Docker 설치하기</h1><p>Docker를 설치하는 방법은 다양한 방법이 있겠지만.. 가장 간단한 방법으로 설치해 보도록 하겠습니다.</p><p>설치 환경은 아래와 같습니다.</p><ul><li>OS: CentOS 7 (VM 환경(Hyper-v)에서 테스트)</li><li>user: docker-user (일부러 root가 아닌 사용자를 생성하였습니다… 이유는 아래에)</li><li>SW: Redis 5</li></ul><blockquote><p>Docker 다운로드 yum을 이용해서 Docker를 받는 방법도 있지만, <code>최신버전이 아닙니다. </code><br>차후 Docker-compose를 사용하기 위해서는 Docker버전이 1.13 이상이 되야 합니다.<br>따라서 한번에 패키지로 설치해 주는 url로 설치하도록 합니다. </p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -fsSL https://get.docker.com/ | sudo sh</span><br><span class="line">sudo sh sudo service docker start <span class="comment">#Docker Daemon Start</span></span><br></pre></td></tr></table></figure><h1 id="Docker의-Permission"><a href="#Docker의-Permission" class="headerlink" title="Docker의 Permission"></a>Docker의 Permission</h1><p>Docker를 설치하고 확인하기 위해 Docker 명령을 입력하였습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p><img src="./docker-permission.png" alt="docker permission"></p><p>docker명령을 입력했을 시, permission denied 에러가 발생한 것을 볼 수 있습니다.<br>docker는 명령을 실행 할 때 기본적으로 root계정을 필요로 합니다. (docker의 특성상 시스템의 내부적인 부분에 접근하는 게 많다보니… 그렇다고 합니다.)<br>그렇기 때문에 sudo명령을 사용하여 docker 명령을 실행 할 수 있습니다.</p><p><code>하지만 sudo가 너무 귀찮다! 하시는 분들은...</code> 아래 명령을 실행하여 계정을 <code>docker 그룹</code>에 포함 시켜주시면 됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br><span class="line">sudo service docker restart</span><br><span class="line"> </span><br><span class="line"><span class="built_in">exit</span> <span class="comment">#로그아웃</span></span><br><span class="line">docker-user &lt;password&gt; <span class="comment">#다시 로그인</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p><img src="./sudo-docker.png" alt="sudo docker"></p><p>이제 sudo 명령 없이도 docker 명령어 실행이 잘 됩니다!</p><h1 id="간단한-Docker-Container-깡통-를-만들어-봅시다"><a href="#간단한-Docker-Container-깡통-를-만들어-봅시다" class="headerlink" title="간단한 Docker Container(깡통)를 만들어 봅시다!"></a>간단한 Docker Container(깡통)를 만들어 봅시다!</h1><p>Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 사이트에 들어가면 우리가 필요로하는 많은 프로그램들이 이미지로 올라가 있습니다.<br>이번 예제에서는 Redis를 가지고 Docker Container를 만들어보도록 하겠습니다.</p><p><img src="./docker-hub.png" alt="docker-hub"></p><p>docker hub 사이트에서 redis를 검색해 보았습니다.<br>여러가지 redis 이미지가 보이는데 official이라고 되어있는 것이 공식이미지 입니다.<br>bitnami&#x2F;redis라고 되어있는 것은 docker hub의 사용자들이 올린 이미지입니다.</p><p><img src="./redis-versions.png" alt="redis-versions"></p><p>official 이미지의 상세 버전을 보니 4.x~5.0.1까지 있습니다.<br>이번 예제에서는 그나마 stable한 버전인 인 5.0-alpine 버전을 사용해 보도록 하겠습니다.</p><h1 id="Docker-이미지-다운로드-Docker-hub-gt-Docker-Client"><a href="#Docker-이미지-다운로드-Docker-hub-gt-Docker-Client" class="headerlink" title="Docker 이미지 다운로드 (Docker hub -&gt; Docker Client)"></a>Docker 이미지 다운로드 (Docker hub -&gt; Docker Client)</h1><p>pull 명령을 통해 docker hub에 있는 이미지를 다운로드 합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:&lt;tag&gt; <span class="comment"># ex) redis:5.0-alpine, redis:4-alpine, redis:latest(가장 마지막 배포 버전입니다.)</span></span><br><span class="line">docker pull redis <span class="comment">#tag version을 적지 않은 경우 자동으로 lastest 버전을 다운로드 합니다.</span></span><br></pre></td></tr></table></figure><h1 id="Docker-이미지-확인-x2F-삭제"><a href="#Docker-이미지-확인-x2F-삭제" class="headerlink" title="Docker 이미지 확인 &#x2F; 삭제"></a>Docker 이미지 확인 &#x2F; 삭제</h1><h2 id="Docker-이미지-확인"><a href="#Docker-이미지-확인" class="headerlink" title="Docker 이미지 확인"></a>Docker 이미지 확인</h2><p>images 명령을 이용하여 docker image리스트를 확인합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><ul><li>자주 사용하는 options<ul><li>-a –all : 숨겨진 임시 이미지를 보여줍니다.</li><li>-f –filter : filter를 이용하여 이미지 조회 조건을 변경하여 조회 할 수 있습니다.</li><li>-q –quite : image의 image ID만 출력합니다.</li></ul></li></ul><blockquote><p>docker의 이미지는 1개의 파일이 아닌, 여러 이미지의 레이어(Layer)로 구성되어 있습니다.<br>따라서 Redis이미지를 다운받더라고 Redis 이미지 하나가 아닌 여러 이미지의 레이어로 구성되어 있습니다.<br><img src="./image-layer.png" alt="image layer"><br>따라서 하나의 이미지라도 여러 이미지가 투영되어 보이는 결과물이라 볼 수 있습니다.</p></blockquote><h2 id="Docker-이미지-삭제"><a href="#Docker-이미지-삭제" class="headerlink" title="Docker 이미지 삭제"></a>Docker 이미지 삭제</h2><p>rmi 명령을 이용하여 docker의 image를 삭제 할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex) docker rmi redis:5.0-alpine, docker rmi &lt;imageID&gt;</span></span><br><span class="line">docker rmi &#123;이미지명/이미지ID&#125; </span><br></pre></td></tr></table></figure><ul><li>자주 사용하는 Options<ul><li>-f –force : 이미지를 강제로 삭제합니다. (해당 이미지로 만들어진 Docker Container가 존재하는 경우 이미지를 삭제 할 수 없는데, 그 때 강제로 삭제 하기위해 사용)</li></ul></li></ul><h1 id="Docker-Container-생성-x2F-삭제"><a href="#Docker-Container-생성-x2F-삭제" class="headerlink" title="Docker Container 생성 &#x2F; 삭제"></a>Docker Container 생성 &#x2F; 삭제</h1><h2 id="Docker-Container-생성"><a href="#Docker-Container-생성" class="headerlink" title="Docker Container 생성"></a>Docker Container 생성</h2><p>run 명령으로 Container를 생성합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex) docker run -it -d redis:5.0-alpine,</span></span><br><span class="line"><span class="comment">#     docker run -it -d 4760dc956b2d</span></span><br><span class="line">docker run &#123;options&#125; &lt;image명/image ID&gt; </span><br></pre></td></tr></table></figure><ul><li><p>자주 사용하는 Options</p><ul><li>-d –detach : Container 생성 후 Background로 실행 (이 옵션 없을 시, Redis 같은 경우에는 Console에 Redis log가 지속적으로 표시됩니다.)</li><li>-h –hostname : Container 명 지정</li><li>-i –interactive : 소통형 모드로 실행 (주로 ubuntu와 같은 Container 실행 시 사용)</li><li>-p –publish : 해당 Container의 외부 Port 지정 (10000:6379) (외부:내부) 형식으로 지정</li><li>-P –publish-all : 여러개의 Port 노출 (1000-1100)</li><li>–rm : Container 종료 시, Container 삭제 <code>(자주 사용되는 옵션입니다)</code></li><li>-v –volume : 외부 볼륨 연동 &#x2F;home&#x2F;user&#x2F;data:&#x2F;data (외부 OS 디렉토리:컨테이너 내부 디렉토리) - 상호 데이터가 공유됨</li></ul></li></ul><h2 id="Docker-Container-목록-조회"><a href="#Docker-Container-목록-조회" class="headerlink" title="Docker Container 목록 조회"></a>Docker Container 목록 조회</h2><p>ps 명령으로 Container 목록을 조회합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps &#123;options&#125;</span><br></pre></td></tr></table></figure><ul><li>자주 사용하는 Options</li><li>-a : 비활성 상태의 Container까지 조회</li><li>-q : Container ID만 조회</li><li>-f –filter : Container 조회 시, Filter를 이용하여 조회</li></ul><h2 id="Docker-Container-내부-접속"><a href="#Docker-Container-내부-접속" class="headerlink" title="Docker Container 내부 접속"></a>Docker Container 내부 접속</h2><p>attach 명령을 이용하여 접속</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [container명/container ID]</span><br></pre></td></tr></table></figure><blockquote><p>attach 명령은 &#x2F;bin&#x2F;bash로 실행 되기 때문에, Container에 &#x2F;bin&#x2F;bash가 없는 경우에는 접속이 불가능 합니다. </p></blockquote><p>exec 명령을 이용하여 Container 내부 명령 수행</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex) docker exec -it redis:5.0-alpine /bin/sh</span></span><br><span class="line"><span class="comment"># Redis의 경우 Container에 bin/bash가 없어 bin/sh로 실행하면 내부접속이 가능합니다</span></span><br><span class="line">docker <span class="built_in">exec</span> &#123;options&#125; [container명/container ID] [명령어]  </span><br></pre></td></tr></table></figure><ul><li>자주 사용하는 options<ul><li>-d –detach : 명령수행을 Background 모드로 수행</li><li>-e –env : 환경변수 (Environment) 설정</li><li>-i –interaction : 대화형 모드로 설정</li></ul></li></ul><h1 id="Docker-Container-삭제"><a href="#Docker-Container-삭제" class="headerlink" title="Docker Container 삭제"></a>Docker Container 삭제</h1><p>rm 명령으로 Container를 삭제 합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex) docker rm -f redis:5.0-alpine</span></span><br><span class="line">docker <span class="built_in">rm</span> &#123;options&#125; [container명/container ID] </span><br></pre></td></tr></table></figure><ul><li>자주 사용하는 options<ul><li>-f –force : 활성(active) 상태의 Container 강제삭제</li><li>-l –link : Container간 link가 관계인 Container 삭제</li><li>-v –volumes : Container 관련 볼륨(외부 디렉토리) 삭제</li></ul></li></ul><h1 id="자주-사용한-명령어-모음"><a href="#자주-사용한-명령어-모음" class="headerlink" title="자주 사용한 명령어 모음"></a>자주 사용한 명령어 모음</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Container 전체 삭제 (-a -q 옵션으로 전체 Container의 ID만 뽑아온다.)</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Image 전체 삭제 (-q 옵션으로 images에 대한 Image ID만 뽑아온다.)</span></span><br><span class="line">docker rmi $(docker images -q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#특정 Container 삭제 (grep 명령으로 Container ID만 뽑아온다.)</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -a | grep <span class="string">&quot;redis:5.0-alpine&quot;</span>| awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#특정 이미지 삭제 (grep + awk 명령어로 image ID만 뽑아온다.)</span></span><br><span class="line">docker rmi $(docker images | grep <span class="string">&quot;^redis&quot;</span>| awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#Docker 삭제</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">yum remove -y docker*</span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="http://www.sauru.so/blog/docker-installation-and-test-drive/">http://www.sauru.so/blog/docker-installation-and-test-drive/</a></li><li><a href="https://hub.docker.com/_/redis/">https://hub.docker.com/_/redis/</a></li><li><a href="http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03">http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03</a></li><li><a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker기반 Redis 구축하기 - (1) Docker란 무엇인가?</title>
      <link href="/2018/11/25/2018-11-25-docker-1/"/>
      <url>/2018/11/25/2018-11-25-docker-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker란-무엇인가"><a href="#Docker란-무엇인가" class="headerlink" title="Docker란 무엇인가?"></a>Docker란 무엇인가?</h1><p><img src="./docker-logo.png" alt="docker-logo"></p><p>Docker란 <strong>Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼</strong> 입니다.</p><p>위의 Docker 이미지처럼 선박에 화물을 수송하는 이미지를 떠올리면 이해하기가 쉬운데, 실제 선박에는 자동차, 오토바이, 전자제품등 여러 물건을 담을 수 있습니다.</p><p>선박에 대한 이미지를 유지한 채, Web Service 운영환경을 생각해 보면..<br>Web Service 운영환경을 구성하기 위해서는 Web Application이 구동 될 수 있는 WAS와 DataBase가 필요합니다.</p><p>이 2가지 프로그램을 Docker라는 선박에 담는다고 생각해 봅시다.<br>그 다음 우리가 배포할 서버를 항구(Port)라고 생각하고,<br>각 서버에 Web Service 운영환경을 싣고 있는 선박을 정착 시켜 서버에서 접근가능한 서비스로 이용할 수 있습니다. 따라서 어떤 서버에서도 Docker만 설치되어 있다면, 다양한 <code>프로그램과 실행환경을 추상화 하여 동일한 인터페이스를 제공</code>하고 서버관리를 쉽고 단순하게 만들어 줄 수 있습니다.</p><p>Docker에서는 <code>Image</code>와 <code>Container</code>라는 개념을 사용하는데, 이 두 가지 개념에 대해 알아보도록 하겠습니다.</p><h1 id="Docker-Image"><a href="#Docker-Image" class="headerlink" title="Docker Image"></a>Docker Image</h1><p><img src="./docker-image.png" alt="docker-image"></p><p>Docker Image는 우리가 사용할 프로그램을 추상화 한 개념입니다.</p><p>Image에는 Container 실행에 필요한 파일(redis.conf, redis.log…., docker-entrypoing.sh등)등을 포함하고,<br>설정값(port, env, data directory등) 정보를 포함하고 있습니다.<br><code>1개의 이미지</code>를 바탕으로<code> 여러 개의 컨테이너</code>를 만들 수 있습니다.<br>(ex. 하나의 Redis 이미지를 바탕으로 3개의 Redis Container를 구성하여 Cluster환경을 구성할 수 있습니다.)<br>이 내용을 좀 더 쉽게 이해하자면, 한번 쯤은 WM에 Linux를 설치 해 본 경험이 있을텐데, Linux를 설치 하기 위해선 linux.iso 파일이 필요 합니다.<br>이때 iso파일이 Linux를 구성하기 위한 파일과 설정 정보를 담고 있고 VM에 Linux를 설치 할 수 있게 해줍니다.<br>여기서 <code>iso파일</code>을 <code>Image</code>라고 생각하고, <code>VM위에 설치되는 리눅스</code>를 <code>Container</code>라고 이해 할 수 있겠습니다.</p><p>Docker를 이용한 운영 배포 시, 이미지를 <code>Docker Hub</code>라는 곳에 올려 각 서버에서 받아 사용할 수 있습니다.<br>(Docker Hub는 github나 maven repository 같은 클라우드 저장소 같은 개념으로 이해 하시면 됩니다.)</p><h1 id="Docker-Container"><a href="#Docker-Container" class="headerlink" title="Docker Container"></a>Docker Container</h1><p>Container란, <strong>프로그램의 실행에 필요한 실행환경을 독립적으로 운용할 수 있도록, 다른 실행환경과의 간섭을 막고 독립성을 확보해 주는 운영체제 수준의 격리 기술</strong>을 의미합니다.</p><p>이러한 격리된 환경이 필요한 경우를 생각해 볼 수 있는데, 극단적인 예시로 Java 1.6 환경에서만 실행되는 프로그램과 Java 1.8이상 환경에서만 실행 되는 프로그램을 하나의 서버에 설치한다고 가정하겠습니다.</p><p>프로그램이 실행 되기 위해서는 운영체제에 설치 된 라이브러리의 대해 의존성을 가질 수 밖에 없는데, 하나의 OS에서 Java Version에 대한 격리 환경을 가지게 하는 것은 상당히 번거로운 일입니다.<br>이러한 경우 Docker를 사용하면 격리된 구역에서 실행 환경을 만들어 줄 수 있기 때문에 타 시스템에 영향을 주지 않고 안정적으로 운영환경을 구성 할 수 있습니다.</p><p>Docker을 처음 공부할 때 Image와 Container 관계가 무척이나 헷갈렸는데.. 예시를 통해 이해해 보겠습니다.<br>Image는 실행 환경에 대한 파일과 설정 정보를 담고 있다고 했습니다. 그리고 프로그램을 추상화 한 개념이라고 하였습니다.<br>이는 Java의 Class와 같은 개념으로 인식 할 수 있습니다.<br>Container는 Image를 기반으로 생성된 격리 된 실행환경이라 했습니다. 그리고 Container를 실행 할 경우 파라미터를 통해 Container 내부 설정정보를 변경 할 수도 있습니다.<br>이는 Class를 바탕으로 만들어진 Instance의 개념으로 이해 할 수 있습니다.<br>이처럼 Java의 Class와 Instance의 관계로 이해한다면, Docker에서의 Image와 Container 관계에 대해 어렵지 않게 이해 할 수 있을 것 같습니다.</p><p><img src="./docking-image.png" alt="docking-image"></p><p>도킹에 성공한 Container는 Host OS에 설치 된 프로그램 처럼 사용할 수 있다.</p><h1 id="Docker-vs-Virtual-Machine"><a href="#Docker-vs-Virtual-Machine" class="headerlink" title="Docker vs Virtual Machine"></a>Docker vs Virtual Machine</h1><p>위에서 설명하길 “Docker란 <strong>Linux 컨테이너(Container) 기반의 오픈소스 가상화 플랫폼</strong>입니다.” 라고 이야기 하였습니다.<br>가상화라고 하면 대표적인 예가 Virtual Machine 즉 VM을 떠올릴 수 있는데요.</p><p>VM과 Docker는 몇가지 차이점이 있습니다.<br>먼저 그림으로 그 구조를 확인해 보겠습니다.</p><p><img src="./vm-vs-docker.png" alt="vm-vs-docker"></p><p>먼저 VM의 가상화 방식은 기존의 <code>Host OS위에 Hyper Visor를 이용</code>하여 가상화 OS를 띄우는 방식으로 많이 구현했습니다.<br>주로 Windows에서 VMWare, Virtual Box, Hyper-V등 가상화 도구를 이용해 Guest OS를 설치하고 그 OS 위에 우리가 사용하고자 하는 프로그램을 설치하여 사용하였습니다.</p><p>이러한 방식은 <code>완벽한 수준의 격리</code>이며, Host OS에서 Guest OS의 프로그램을 직접적으로 제어할 수 없습니다<br>또한 Host OS에서 할당한 자원(Resource)밖에 사용할 수 없기 때문에 Host OS에서도 가상 OS에 점유한 자원을 유동적으로 사용할 수 없어 낭비가 생깁니다.</p><p>반면에 Container 방식은 <strong>기존의 Host OS위에 Docker를 이용하여 해당 프로그램의 의존성 라이브러리(프로그램 구동에 필요한 라이브러리)만 가지고 Container가 생성</strong>됩니다. 그렇기에 <code>최소한의 용량으로 이미지를 구성</code> 할 수 있습니다.<br>VM에서 사용되는 OS나 Kernel이 없기 때문에 부팅을 할 필요도 없으며, Host OS의 Resource 또한 유동적으로 사용할 수 있어 자원관리가 효율적입니다.</p><p>단순히 프로세스를 격리시키는 것이기 때문에 <code>VM에 비해 매우 빠르게 동작</code>합니다.<br>단점인 부분은 <strong>Host OS에 종속적인 부분이 있습니다.</strong><br>VM방식의 경우 각각의 OS에 대한 독립성을 가지고 있어, Host OS에 대해 독립적입니다. (예를들어 Host OS가 리눅스이고, Guest OS가 Windows인 경우, MSSQL을 Guest OS에서 사용할 수 있다)<br>하지만 Container방식은 Host OS의 자원을 기반으로 생성 되기 때문에 <code>Host OS에서 작동할 수 없는 프로그램은 Container 내부에서 작동 할 수 없습니다.</code></p><h1 id="Docker-for-XX"><a href="#Docker-for-XX" class="headerlink" title="Docker for XX"></a>Docker for XX</h1><p>Docker는 리눅스 컨테이너 기반으로 동작하지만 최근 Windows와 Mac에 대해서도 Docker를 지원하고 있습니다.<br>하지만 Linux기반 Docker와 조금 차이점이 있습니다.<br>아무래도 Linux 기반 컨테이너이기 때문에 Windows에서는 Hyper-V에 리눅스를 설치하여 연동되게 되어있습니다.<br>이 경우 Host OS가 Windows가 되는 것이 아니라, Hyper-V의 리눅스가 Host OS가 되는 것이기 때문에 Hyper-V에 할당된 메모리와 디스크 용량을 기반으로 자원을 활용하게 됩니다.<br>Linux가 아닌 다른 운영체제에서 Docker 설치 시 유의해야 할 부분입니다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><p><a href="http://www.sauru.so/blog/getting-started-with-docker/">http://www.sauru.so/blog/getting-started-with-docker/</a></p></li><li><p><a href="http://www.sauru.so/blog/getting-started-with-docker/">http://www.sauru.so/blog/getting-started-with-docker/</a>     </p></li><li><p><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p></li><li><p><a href="https://www.docker.com/enterprise-edition#/platform">https://www.docker.com/enterprise-edition#/platform</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpEL Expression(2)</title>
      <link href="/2018/11/25/2018-11-25-spel-expression-2/"/>
      <url>/2018/11/25/2018-11-25-spel-expression-2/</url>
      
        <content type="html"><![CDATA[<h1 id="리터럴-표현식-Literal-Expression"><a href="#리터럴-표현식-Literal-Expression" class="headerlink" title="리터럴 표현식 (Literal Expression)"></a>리터럴 표현식 (Literal Expression)</h1><p>리터럴 표현식을 제공하는 타입은 문자열(String), 숫자(int, real, hex), boolean, null이다.</p><ul><li>문자열 (Strings)는 따옴표(‘)로 구분된다 <code>(쌍따옴표가 아님)</code> - 문자열 표현 시, <code>&#39;Hello World&#39;</code> 처럼 SpEL을 작성</li></ul><p>다음은 리터럴 표현식 (Literal Expression)에 대한 간단한 예제이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//따옴표로 이루어진 &#x27;Hello World&#x27; =&gt; Hello World라는 문자열로 평가 된다.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">helloWorld</span> <span class="operator">=</span> (String) parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;&quot;</span>).getValue();</span><br><span class="line"><span class="comment">//Double 타입의 숫자로 평가</span></span><br><span class="line"><span class="type">double</span> <span class="variable">avogadrosNumber</span> <span class="operator">=</span> (Double) parser.parseExpression(<span class="string">&quot;6.0221415E+23&quot;</span>).getValue();</span><br><span class="line"><span class="comment">//2147483647로 평가</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> (Integer) parser.parseExpression(<span class="string">&quot;0x7FFFFFFF&quot;</span>).getValue();</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">trueValue</span> <span class="operator">=</span> (Boolean) parser.parseExpression(<span class="string">&quot;true&quot;</span>).getValue();</span><br><span class="line"><span class="comment">//null로 평가 된다. -&gt; null String이 아니다. (주의)</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">nullValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;null&quot;</span>).getValue();</span><br></pre></td></tr></table></figure><ul><li>숫자는 음수기호(-), 지수표시(E), 소수점(.)을 지원한다.</li><li>기본적으로 실제 숫자는 Double.parseDouble()로 파싱한다.</li></ul><h1 id="메서드-호출"><a href="#메서드-호출" class="headerlink" title="메서드 호출"></a>메서드 호출</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String 리터럴 abc에 대한 substring 메서드 호출 -&gt; bc가 리턴된다.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;&#x27;abc&#x27;.substring(2, 3)&quot;</span>).getValue(String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//사용자 정의 메서드 호출 (Return Type : Boolean) -&gt; boolean 타입으로 평가된다.</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;isMember(&#x27;Mihajlo Pupin&#x27;)&quot;</span>).getValue(</span><br><span class="line">        societyContext, Boolean.class);</span><br></pre></td></tr></table></figure><p>위의 코드는 메서드 호출에 대한 예제 코드이다.</p><ul><li>메서드는 Java 문법을 사용하여 호출 할 수 있다.</li><li>Literal에 대한 메서드 호출도 가능하다.</li><li>Varargs 형식의 파라미터도 지원하고 있다.</li></ul><h1 id="프로퍼티-배열-리스트-맵에-대한-접근-지원"><a href="#프로퍼티-배열-리스트-맵에-대한-접근-지원" class="headerlink" title="프로퍼티, 배열, 리스트, 맵에 대한 접근 지원"></a>프로퍼티, 배열, 리스트, 맵에 대한 접근 지원</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 발명품 배열</span></span><br><span class="line"><span class="type">StandardEvaluationContext</span> <span class="variable">teslaContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>(tesla);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Induction motor&quot;로 평가된다.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">invention</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;inventions[3]&quot;</span>).getValue(teslaContext, String.class); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 회원 리스트</span></span><br><span class="line"><span class="type">StandardEvaluationContext</span> <span class="variable">societyContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>(ieee);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Nikola Tesla&quot;로 평가된다.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;Members[0].Name&quot;</span>).getValue(societyContext, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리스트와 배열 탐색</span></span><br><span class="line"><span class="comment">// &quot;Wireless communication&quot;로 평가된다.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">invention</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;Members[0].Inventions[6]&quot;</span>).getValue(societyContext, String.class);</span><br></pre></td></tr></table></figure><ul><li>프로퍼티의 맨 첫글자는 대소문자를 구별하지 않는다.</li><li>SpEL은 표준 <code>dot 표기법</code>(예: prop1.prop2.prop3)을 사용해서 중첩된 프로퍼티와 프로퍼티의 값 설정도 지원한다.</li><li>public 필드에 대한 접근을 지원한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Officer의 딕션어리</span></span><br><span class="line"><span class="type">Inventor</span> <span class="variable">pupin</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;Officers[&#x27;president&#x27;]&quot;</span>).getValue(societyContext, Inventor.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Idvor&quot;로 평가된다</span></span><br><span class="line"><span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;Officers[&#x27;president&#x27;].PlaceOfBirth.City&quot;</span>).getValue(societyContext, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 값을 설정한다</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;Officers[&#x27;advisors&#x27;][0].PlaceOfBirth.Country&quot;</span>).setValue(societyContext, <span class="string">&quot;Croatia&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>대괄호<code>[]</code> 를 사용하여 Map의 key를 바탕으로 데이터에 접근한다.<br>(위의 예제에서는 Officers가 <code>Map</code>, president가 <code>key</code>이다.)</li><li>SpEL은 표준 ‘dot’ 표기법 (예: prop1.prop2.prop3)을 사용해서 Map내의 value 객체의 프로퍼티에도 접근 가능하다.</li><li>setValue 메서드를 통해 데이터를 수정할 수 있다.</li></ul><h1 id="인라인-리스트-Inline-list"><a href="#인라인-리스트-Inline-list" class="headerlink" title="인라인 리스트 (Inline list)"></a>인라인 리스트 (Inline list)</h1><p>리스트는 {} 표기법을 사용하여 리스트로 사용 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4개의 숫자를 담고 있는 리스트로 평가된다</span></span><br><span class="line">List&lt;Integer&gt; numbers = (List) parser.parseExpression(<span class="string">&quot;&#123;1,2,3,4&#125;&quot;</span>).getValue(context); </span><br><span class="line"></span><br><span class="line"><span class="comment">//List의 List의 형태의 List로 평가된다.</span></span><br><span class="line"><span class="comment">//listOfLists[0] = &#123;&#x27;a&#x27;, &#x27;b&#x27;&#125;</span></span><br><span class="line"><span class="comment">//listOfLists[1] = &#123;&#x27;x&#x27;, &#x27;y&#x27;&#125;</span></span><br><span class="line"><span class="type">List</span> <span class="variable">listOfLists</span> <span class="operator">=</span> (List) parser.parseExpression(<span class="string">&quot;&#123;&#123;&#x27;a&#x27;,&#x27;b&#x27;&#125;,&#123;&#x27;x&#x27;,&#x27;y&#x27;&#125;&#125;&quot;</span>).getValue(context);</span><br></pre></td></tr></table></figure><h1 id="배열-생성"><a href="#배열-생성" class="headerlink" title="배열 생성"></a>배열 생성</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers1 = (<span class="type">int</span>[]) parser.parseExpression(<span class="string">&quot;new int[4]&quot;</span>).getValue(context); </span><br><span class="line"></span><br><span class="line"><span class="comment">// initializer가진 배열</span></span><br><span class="line"><span class="type">int</span>[] numbers2 = (<span class="type">int</span>[]) parser.parseExpression(<span class="string">&quot;new int[]&#123;1,2,3&#125;&quot;</span>).getValue(context); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 다차원 배열</span></span><br><span class="line"><span class="type">int</span>[][] numbers3 = (<span class="type">int</span>[][]) parser.parseExpression(<span class="string">&quot;new int[4][5]&quot;</span>).getValue(context);</span><br></pre></td></tr></table></figure><ul><li>Java 문법과 같은 표현식을 사용하여 배열을 생성 할 수 있다.</li><li>{} 표현식을 통해 초기값을 세팅할 수 있다.</li><li>2차원 배열이상의 다차원 배열도 선언이 가능하다. (<code>단, 다차원 배열은 초기값을 설정할 수 없다.</code>)</li></ul><h1 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h1><h2 id="관계-연산자"><a href="#관계-연산자" class="headerlink" title="관계 연산자"></a>관계 연산자</h2><p>표준 관계 연산자를 사용한다. 사용 할 수 있는 관계 연산자는 아래와 같다.</p><ul><li>같음 (<code>==</code>)</li><li>같지 않음 (<code>!=</code>)</li><li>작음 (<code>&lt;</code>)</li><li>작거나 같음 (<code>&lt;=</code>)</li><li>큼 (<code>&gt;</code>)</li><li>크거나 같음 (<code>&gt;=</code>)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">trueValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;2 == 2&quot;</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// false로 평가된다</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">falseValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;2 &lt; -5.0&quot;</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">trueValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;&#x27;black&#x27; &lt; &#x27;block&#x27;&quot;</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure><h2 id="심볼릭-연산자"><a href="#심볼릭-연산자" class="headerlink" title="심볼릭 연산자"></a>심볼릭 연산자</h2><p>XML과 같이 문서형식에 관계 연산자가 제한을 받는 경우, 사용 가능한 문자 표현식을 제공한다.<br>연산자에 대한 대소문자는 구별하지 않는다.</p><ul><li>같음 (<code>eq</code>)</li><li>같지 않음 (<code>ne</code>)</li><li>작음 (<code>lt</code>)</li><li>작거나 같음 (<code>le</code>)</li><li>큼 (<code>gt</code>)</li><li>크거나 같음 (<code>gt</code>)</li><li>div (<code>/</code>)</li><li>mod (<code>%</code>)</li><li>not (<code>!</code>)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">trueValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;22 eq 22&quot;</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// false로 평가된다</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">falseValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;&#x27;test&#x27; eq &#x27;test!&#x27;&quot;</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure><h2 id="정규-표현식"><a href="#정규-표현식" class="headerlink" title="정규 표현식"></a>정규 표현식</h2><p>matches를 이용한 정규표현식을 지원한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">trueValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;&#x27;5.00&#x27; matches &#x27;^-?\\d+(\\.\\d&#123;2&#125;)?$&#x27;&quot;</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// false로 평가된다</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">falseValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;&#x27;5.0067&#x27; matches &#x27;^-?\\d+(\\.\\d&#123;2&#125;)?$&#x27;&quot;</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>Java에서 super타입에 대한 연산을 위해 instanceof를 표현식으로 사용할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false로 평가된다</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">falseValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;&#x27;xyz&#x27; instanceof T(int)&quot;</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true로 평가된다.</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">trueValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;&#x27;xyz&#x27; instanceof T(String)&quot;</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure><h2 id="논리연산자"><a href="#논리연산자" class="headerlink" title="논리연산자"></a>논리연산자</h2><p>AND, OR, NOT에 대한 표현식을 지원한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -- AND --</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false로 평가된다</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">falseValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;true and false&quot;</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line"><span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span>  <span class="string">&quot;isMember(&#x27;Nikola Tesla&#x27;) and isMember(&#x27;Mihajlo Pupin&#x27;)&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">trueValue</span> <span class="operator">=</span> parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- OR --</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">trueValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;true or false&quot;</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true로 평가된다</span></span><br><span class="line"><span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span>  <span class="string">&quot;isMember(&#x27;Nikola Tesla&#x27;) or isMember(&#x27;Albert Einstien&#x27;)&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">trueValue</span> <span class="operator">=</span> parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- NOT --</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false로 평가된다</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">falseValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;!true&quot;</span>).getValue(Boolean.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- AND and NOT --</span></span><br><span class="line"><span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span>  <span class="string">&quot;isMember(&#x27;Nikola Tesla&#x27;) and !isMember(&#x27;Mihajlo Pupin&#x27;)&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">falseValue</span> <span class="operator">=</span> parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br></pre></td></tr></table></figure><h2 id="수식-연산자"><a href="#수식-연산자" class="headerlink" title="수식 연산자"></a>수식 연산자</h2><ul><li>더하기 (+) 연산자를 숫자, 날짜, 문자열에 사용할 수 있다.</li><li>빼기(-) 연산자를 숫자, 날짜에 사용할 수 있다.</li><li>곱하기(*), 나누기(&#x2F;), 나머지(%)에 대한 연산은 숫자에만 사용 할 수 있다.</li><li>연산자 우선 순위 법칙이 적용된다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 더하기</span></span><br><span class="line"><span class="type">int</span> <span class="variable">two</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;1 + 1&quot;</span>).getValue(Integer.class); <span class="comment">// 2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">testString</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;&#x27;test&#x27; + &#x27; &#x27; + &#x27;string&#x27;&quot;</span>).getValue(String.class);  <span class="comment">// &#x27;test string&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 빼기</span></span><br><span class="line"><span class="type">int</span> <span class="variable">four</span> <span class="operator">=</span>  parser.parseExpression(<span class="string">&quot;1 - -3&quot;</span>).getValue(Integer.class); <span class="comment">// 4</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;1000.00 - 1e4&quot;</span>).getValue(Double.class); <span class="comment">// -9000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 곱하기</span></span><br><span class="line"><span class="type">int</span> <span class="variable">six</span> <span class="operator">=</span>  parser.parseExpression(<span class="string">&quot;-2 * -3&quot;</span>).getValue(Integer.class); <span class="comment">// 6</span></span><br><span class="line"><span class="type">double</span> <span class="variable">twentyFour</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;2.0 * 3e0 * 4&quot;</span>).getValue(Double.class); <span class="comment">// 24.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 나누기</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minusTwo</span> <span class="operator">=</span>  parser.parseExpression(<span class="string">&quot;6 / -3&quot;</span>).getValue(Integer.class); <span class="comment">// -2</span></span><br><span class="line"><span class="type">double</span> <span class="variable">one</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;8.0 / 4e0 / 2&quot;</span>).getValue(Double.class); <span class="comment">// 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 계수(Modulus)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">three</span> <span class="operator">=</span>  parser.parseExpression(<span class="string">&quot;7 % 4&quot;</span>).getValue(Integer.class); <span class="comment">// 3</span></span><br><span class="line"><span class="type">int</span> <span class="variable">one</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;8 / 5 % 2&quot;</span>).getValue(Integer.class); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 연산자 우선순위</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minusTwentyOne</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;1+2-3*8&quot;</span>).getValue(Integer.class); <span class="comment">// -21</span></span><br></pre></td></tr></table></figure><h2 id="3항-연산자-If-Then-Else"><a href="#3항-연산자-If-Then-Else" class="headerlink" title="3항 연산자 (If-Then-Else)"></a>3항 연산자 (If-Then-Else)</h2><p>표현식에서 3항연산자를 통해 if-then-else 로직을 수행할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//falseExp로 평가 된다.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">falseString</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;false ? &#x27;trueExp&#x27; : &#x27;falseExp&#x27;&quot;</span>).getValue(String.class);</span><br></pre></td></tr></table></figure><h2 id="Elvis-연산자"><a href="#Elvis-연산자" class="headerlink" title="Elvis 연산자"></a>Elvis 연산자</h2><ul><li>Elvis 연산자는 3항 연산자 구문을 단축시키고 Groovy 언어로 사용된다.</li><li>3항 연산자는 변수를 2번 반복해서 써야하는 단점이 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Elvis Presley&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">displayName</span> <span class="operator">=</span> name != <span class="literal">null</span> ? name : <span class="string">&quot;Unknown&quot;</span>;</span><br></pre></td></tr></table></figure><p>이런 조잡한 표현식 대신에 Elvis 연산자를 사용하면..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;name?:&#x27;Unknown&#x27;&quot;</span>).getValue(String.class);  </span><br><span class="line">System.out.println(name); <span class="comment">// &#x27;Unknown&#x27;</span></span><br></pre></td></tr></table></figure><p>간단하게 변수에 대해 <code>?</code> 를 붙여주는 것만으로도 null 체크를 해준다.<br>? 모양이 엘비스 프레슬리의 머리모양을 닮아서 Elvis 연산자라고 명명하였다고 한다.</p><h2 id="안전한탐색-Navigation-연산자"><a href="#안전한탐색-Navigation-연산자" class="headerlink" title="안전한탐색(Navigation) 연산자"></a>안전한탐색(Navigation) 연산자</h2><ul><li>안전한 탐색 연산자는 NPE를 피하기 위해 사용, Groovy 언어로 제공</li><li>java로 코딩을 하다보면 습관적으로 if(variable &#x3D;&#x3D; null) 과 같은 체크를 하게 된다.</li><li>하지만 Safe Navigation 연산자를 사용하면 NPE를 발생시키지 않고, 그냥 null을 리턴해 준다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Inventor</span> <span class="variable">tesla</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inventor</span>(<span class="string">&quot;Nikola Tesla&quot;</span>, <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line">tesla.setPlaceOfBirth(<span class="keyword">new</span> <span class="title class_">PlaceOfBirth</span>(<span class="string">&quot;Smiljan&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">StandardEvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>(tesla);</span><br><span class="line"></span><br><span class="line"><span class="comment">//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행</span></span><br><span class="line"><span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;PlaceOfBirth?.City&quot;</span>).getValue(context, String.class);</span><br><span class="line">System.out.println(city); <span class="comment">// Smiljan</span></span><br><span class="line"></span><br><span class="line">tesla.setPlaceOfBirth(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//placeOfBirth가 null인가? 체크하고 placeOfBirth.city에 대한 연산 수행</span></span><br><span class="line">city = parser.parseExpression(<span class="string">&quot;PlaceOfBirth?.City&quot;</span>).getValue(context, String.class);</span><br><span class="line">System.out.println(city); <span class="comment">// null - null pointer exception이 발생하지 않는다.</span></span><br></pre></td></tr></table></figure><h1 id="할당"><a href="#할당" class="headerlink" title="할당"></a>할당</h1><ul><li>할당연산자(<code>=</code>)를 이용하여 Context내의 프로퍼티에 value를 할당 할 수 있다.</li><li>보통은 setValue 메서드를 이용하여 value를 할당</li><li>getValue 메서드를 이용하여 할당 할 수도 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Inventor</span> <span class="variable">inventor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inventor</span>();</span><br><span class="line"><span class="type">StandardEvaluationContext</span> <span class="variable">inventorContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>(inventor);</span><br><span class="line"><span class="comment">//inventor.name에 Alexander Seovic2 문자열을 할당</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;Name&quot;</span>).setValue(inventorContext, <span class="string">&quot;Alexander Seovic2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//할당연산자(`=`)를 이용하여 inventor.name에 Alexander Seovic2 문자열을 할당</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aleks</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;Name = &#x27;Alexandar Seovic&#x27;&quot;</span>).getValue(inventorContext, String.class);</span><br></pre></td></tr></table></figure><h1 id="클래스-표현식"><a href="#클래스-표현식" class="headerlink" title="클래스 표현식"></a>클래스 표현식</h1><ul><li><code>T</code> 연산자를 통해 클래스의 인스턴스를 지정하는데 사용할 수 있다.</li><li><code>T</code> 연산자를 통해 클래스의 static method도 사용할 수 있다.</li><li>웬만하면 full package를 적어준다.</li><li>StandardEvaluationContext는 타입을 찾으려고 TypeLocator를 사용</li><li>StandardTypeLocator는 java.lang 패키지로 만들어진다.</li><li>따라서 java.lang.String과 같은 타입은 T(String)으로 간단하게 표현 가능하다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">dateClass</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;T(java.util.Date)&quot;</span>).getValue(Class.class);</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;T(String)&quot;</span>).getValue(Class.class);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">trueValue</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR&quot;</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure><h1 id="생성자-호출"><a href="#생성자-호출" class="headerlink" title="생성자 호출"></a>생성자 호출</h1><ul><li>생성자는 새로운 연산자를 사용해서 호출할 수 있다.</li><li>primitive type(원시 타입 int, double등..)과 String 외에는 모두 정규화된 클래스명을 사용해야 한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Inventor</span> <span class="variable">einstein</span> <span class="operator">=</span> p.parseExpression(<span class="string">&quot;new org.spring.samples.spel.inventor.Inventor(&#x27;Albert Einstein&#x27;, &#x27;German&#x27;)&quot;</span>).getValue(Inventor.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//리스트의 add 메서드내에서 새로운 inventor 인스턴스를 생성한다</span></span><br><span class="line">p.parseExpression(<span class="string">&quot;Members.add(new org.spring.samples.spel.inventor.Inventor(&#x27;Albert Einstein&#x27;, &#x27;German&#x27;))&quot;</span>).getValue(societyContext);</span><br></pre></td></tr></table></figure><h1 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h1><ul><li><code>#</code> 표현식을 통해 표현식 내에 변수를 참조할 수 있다.</li><li>StandardEvaluationContext에서 setVariable 메서드를 사용해서 변수를 설정한다.</li><li>자주 쓰이는 표현식이다. (@Cacheable Annotation에서도 사용)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Inventor</span> <span class="variable">tesla</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inventor</span>(<span class="string">&quot;Nikola Tesla&quot;</span>, <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line"><span class="type">StandardEvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>(tesla);</span><br><span class="line">context.setVariable(<span class="string">&quot;newName&quot;</span>, <span class="string">&quot;Mike Tesla&quot;</span>); <span class="comment">//newName변수에 대한 value할당</span></span><br><span class="line"></span><br><span class="line">parser.parseExpression(<span class="string">&quot;Name = #newName&quot;</span>).getValue(context);</span><br><span class="line"></span><br><span class="line">System.out.println(tesla.getName()) <span class="comment">// &quot;Mike Tesla&quot;</span></span><br></pre></td></tr></table></figure><h2 id="root"><a href="#root" class="headerlink" title="#root"></a>#root</h2><ul><li>변수 #root는 항상 정의되며 루트 컨텍스트 개체의미</li><li>#root는 항상 루트를 나타낸다.</li><li>setRootObject 메서드를 통해 root를 정의한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StandardEvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>(tesla);</span><br><span class="line"></span><br><span class="line"><span class="type">SomeCustomObject</span> <span class="variable">someObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeCustomObject</span>();</span><br><span class="line">context.setRootObject(someObject);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;kocko&quot;</span>;</span><br><span class="line">context.setVariable(<span class="string">&quot;name&quot;</span>, kocko);</span><br><span class="line"><span class="type">String</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="string">&quot;#root.stringLength(#kocko) == 5&quot;</span>;</span><br><span class="line"><span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> parser.parseExpression(statement);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> expression.getValue(context, Boolean.class);</span><br></pre></td></tr></table></figure><ul><li>#root는 SomeCustomObject를 의미</li></ul><h2 id="this"><a href="#this" class="headerlink" title="#this"></a>#this</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create an array of integers</span></span><br><span class="line">List&lt;Integer&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">primes.addAll(Arrays.asList(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 파서를 생성하고 &#x27;primes&#x27; 변수를 정수 배열로 설정한다</span></span><br><span class="line"><span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line"><span class="type">StandardEvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class="line">context.setVariable(<span class="string">&quot;primes&quot;</span>,primes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리스트에서 10보다 큰 모든 소수(?&#123;...&#125; 선택을 사용)</span></span><br><span class="line"><span class="comment">// [11, 13, 17]로 평가된다</span></span><br><span class="line">List&lt;Integer&gt;</span><br><span class="line"> primesGreaterThanTen = (List&lt;Integer&gt;) </span><br><span class="line">parser.parseExpression(<span class="string">&quot;#primes.?[#this&gt;10]&quot;</span>).getValue(context);</span><br><span class="line"><span class="comment">//#primes 변수에 대해 평가하며, #this는 2~17까지 값을 의미한다.</span></span><br></pre></td></tr></table></figure><ul><li>#this는 항상 정의되어 있고, 현재 평가되는 객체를 가리킨다.</li><li>#this는 계속 변경될 수 있다. (위의 예제에서 보면 2,3,5,7등 평가 시점에 따라 달라질수 있다.)</li></ul><h1 id="사용자-정의-함수"><a href="#사용자-정의-함수" class="headerlink" title="사용자 정의 함수"></a>사용자 정의 함수</h1><ul><li>표현식 문자열 내에서 호출 가능한 사용자 정의 함수를 등록하여 SpEL의 기능을 확장할 수 있다.</li><li>StandardEvaluationContext에 사용자정의 함수를 등록하여 사용하면 된다.</li></ul><p>예시로 문자열을 reverse 하는 메서드를 구현하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">StringUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseString</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">backwards</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; input.length(); i++)</span><br><span class="line">            backwards.append(input.charAt(input.length() - <span class="number">1</span> - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> backwards.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>메서드를 StandardEvaluationContext에 등록</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line"><span class="type">StandardEvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringUtils 클래스에 정의된 reserveString 메서드를 등록한다.</span></span><br><span class="line"><span class="comment">//파라미터 타입은 String 타입 객체 1개이다.</span></span><br><span class="line">context.registerFunction(<span class="string">&quot;reverseString&quot;</span>, StringUtils.class.getDeclaredMethod(<span class="string">&quot;reverseString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello 문자열을 뒤집은 olleh가 리턴된다.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">helloWorldReversed</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;#reverseString(&#x27;hello&#x27;)&quot;</span>).getValue(context, String.class);</span><br></pre></td></tr></table></figure><h1 id="Bean-참조"><a href="#Bean-참조" class="headerlink" title="Bean 참조"></a>Bean 참조</h1><p>evaluation context에 Bean Resolver가 설정된 경우 <code>@</code> 표현식으로 bean을 사용할 수 있다.<br>Spring Docs에 있는 예제는 잘 이해가 안되어 직접 테스트 해보았다.</p><p>Bean 클래스 생성</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBean</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;do Test&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line"><span class="type">StandardEvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//실용적인 테스트를 위해 Application Context의 BeanFactory를 설정</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (DefaultListableBeanFactory) ((ConfigurableApplicationContext) applicationContext).getBeanFactory();</span><br><span class="line">context.setBeanResolver(<span class="keyword">new</span> <span class="title class_">BeanFactoryResolver</span>(factory));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Application Context에 등록된 testBean이라는 bean을 불러와 test메서드를 실행하였다.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;@testBean.test()&quot;</span>).getValue(context, String.class);</span><br><span class="line"><span class="keyword">return</span> result; <span class="comment">//do Test가 리턴되었다.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Collection-선택-기능"><a href="#Collection-선택-기능" class="headerlink" title="Collection 선택 기능"></a>Collection 선택 기능</h1><ul><li>컬렉션 (Collection) 선택 기능은 Context내의 Collection 필드에 접근하여 조건(Criteria)를 기반으로 서브 컬렉션을 반환 할 수 있다.</li><li><code>?[selectionExpression]</code> 표현식을 이용한다.</li><li>리스트, 맵에서 모두 사용 가능하다</li><li>객체가 context로 들어오는 경우 object.?[필드에 대한 조건]</li><li>컬렉션이 context로 들어오는 경우 .?[필드에 대한 조건] (별도의 필드가 없는 경우 #this를 사용)</li></ul><p>Twice 클래스를 선언</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Twice</span> &#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Member&gt; members = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Member&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;지효&quot;</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;나연&quot;</span>, <span class="number">24</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;모모&quot;</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;사나&quot;</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;다현&quot;</span>, <span class="number">21</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;미나&quot;</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;채영&quot;</span>, <span class="number">19</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;쯔위&quot;</span>, <span class="number">19</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;정연&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Member</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Twice&gt; <span class="title function_">twice</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line">    <span class="type">StandardEvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Twice의 멤버 필드에 접근</span></span><br><span class="line">    <span class="comment">// 컬렉션의 age 필드에 대해 20 이하인 대상을 반환</span></span><br><span class="line">    List&lt;Twice&gt; filterList = (List&lt;Twice&gt;) parser.parseExpression(<span class="string">&quot;members.?[age &lt; 20]&quot;</span>).getValue(<span class="keyword">new</span> <span class="title class_">Twice</span>());</span><br><span class="line">    <span class="keyword">return</span> filterList; <span class="comment">//[&#123;&quot;name&quot;:&quot;채영&quot;,&quot;age&quot;:19&#125;,&#123;&quot;name&quot;:&quot;쯔위&quot;,&quot;age&quot;:19&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Collection-투영-기능"><a href="#Collection-투영-기능" class="headerlink" title="Collection 투영 기능"></a>Collection 투영 기능</h1><ul><li>투영기능은 컬렉션에 하위표현식을 반영하여 새로운 컬렉션을 리턴한다.</li><li><code>![projectionExpression]</code> 표현식을 사용한다.</li></ul><p>위의 Twice 예제를 바탕으로 설명하겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">twice2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line">    <span class="type">StandardEvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class="line"></span><br><span class="line">    List&lt;Member&gt; testList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Member&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;지효&quot;</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;나연&quot;</span>, <span class="number">24</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;모모&quot;</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;사나&quot;</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;다현&quot;</span>, <span class="number">21</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;미나&quot;</span>, <span class="number">23</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;채영&quot;</span>, <span class="number">19</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;쯔위&quot;</span>, <span class="number">19</span>));</span><br><span class="line">            add(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;정연&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Twice 멤버 배열을 받아, 컬렉션 투영기능을 이용하여 그중 name에 대한 필드만 뽑아온 것이다.</span></span><br><span class="line">    List&lt;String&gt; filterList = (List&lt;String&gt;) parser.parseExpression(<span class="string">&quot;![name]&quot;</span>).getValue(testList);</span><br><span class="line">    <span class="keyword">return</span> filterList; <span class="comment">//[&quot;지효&quot;,&quot;나연&quot;,&quot;모모&quot;,&quot;사나&quot;,&quot;다현&quot;,&quot;미나&quot;,&quot;채영&quot;,&quot;쯔위&quot;,&quot;정연&quot;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="표현식-템플릿"><a href="#표현식-템플릿" class="headerlink" title="표현식 템플릿"></a>표현식 템플릿</h1><ul><li>표현식 템플릿을 사용하면 평가 블록과 Literal text를 혼합할 수 있다.</li><li>평가블록은 prefix와 subfix로 구분</li><li>일반적으로 <code>#&#123;</code> 와 <code>&#125;</code>로 구분한다.</li><li>parseExpression() 메서드의 두번째 파라미터로 사용자 정의 ParseContext 객체를 넣어준다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateParserContext</span> <span class="keyword">implements</span> <span class="title class_">ParserContext</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getExpressionPrefix</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;#&#123;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getExpressionSuffix</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;random number is 0.7038186818312008&quot;로 평가된다</span></span><br><span class="line"><span class="type">String</span> <span class="variable">randomPhrase</span> <span class="operator">=</span> </span><br><span class="line">   parser.parseExpression(<span class="string">&quot;random number is #&#123;T(java.lang.Math).random()&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">TemplateParserContext</span>()).getValue(String.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpEL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpEL Expression(1)</title>
      <link href="/2018/11/21/2018-11-21-spel-expression/"/>
      <url>/2018/11/21/2018-11-21-spel-expression/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>Spring Cache Abstraction 기능을 사용하게 되면서, key modeling 시, 필요한 SpEL에 대해 알아보게 되었다.<br>기본적인 설명과 예제는 Spring Docs를 기반으로 번역</p><h1 id="SpEL-Spring-Expression-Language-이란"><a href="#SpEL-Spring-Expression-Language-이란" class="headerlink" title="SpEL (Spring Expression Language)이란?"></a>SpEL (<u>Sp</u>ring <u>E</u>xpression <u>L</u>anguage)이란?</h1><p>Spring Expression Language (줄여서 SpEL)은 런타임에 쿼리를 지원하고 객체를 조작할 수 있는 강력한 표현식 언어이다. 언어 구문은 Unified EL과 유사하지만, 여러가지 추가 기능을 제공한다.</p><p>다른 Java에서 사용가능한 표현식 언어가 있지만, SpEL은 Spring 커뮤니티에 표현식 언어를 제공하기 위해 만들어졌다.<br>Spring 포트폴리오 내에서 표현식 평가 (Expression evaluation)의 기반으로 SpEL을 제공하지만, SpEL은 Spring과 직접 연계되지 않고 독립적으로 사용 할 수 있다.<br>독립적으로 사용하기 위해서는 Parser 같은 Bootstraping 기반 클래스에 대한 설정을 몇가지 할 필요가 있다.<br>하지만 웬만한 개발자들은 이런 기반 클래스에 대한 설정 없이 SpEL 표현식만 잘 작성하면 된다.</p><h1 id="SpEL에서-지원하는-기능"><a href="#SpEL에서-지원하는-기능" class="headerlink" title="SpEL에서 지원하는 기능"></a>SpEL에서 지원하는 기능</h1><ul><li>리터럴 표현식 (Literal Expression)</li><li>Boolean과 관계형 Operator (Boolean and Relational Operator)</li><li>정규 표현식 (Regular Expression)</li><li>클래스 표현식 (Class Expression)</li><li>프로퍼티, 배열, 리스트, 맵에 대한 접근 지원 (Accessing properties, arrays, lists, maps)</li><li>메서드 호출 (Method Invocation)</li><li>관계형 Operator (Relational Operator)</li><li>할당 (Assignment)</li><li>생성자 호출 (Calling Constructors)</li><li>Bean 참조 (Bean References)</li><li>배열 생성 (Array Contruction)</li><li>인라인 리스트&#x2F;맵 (Inline List&#x2F;Map)</li><li>삼항 연산자 (Ternary Operator)</li><li>변수 (Variables)</li><li>사용자 정의 함수 (User defined functions)</li><li>컬렉션 투영 (Collections Projection)</li><li>컬렉션 선택 (Collections Selection)</li><li>Template 표현식 (Templated expression)</li></ul><h1 id="Expression-인터페이스를-이용한-표현식-파싱"><a href="#Expression-인터페이스를-이용한-표현식-파싱" class="headerlink" title="Expression 인터페이스를 이용한 표현식 파싱"></a>Expression 인터페이스를 이용한 표현식 파싱</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpressionTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> parseExpression(<span class="string">&quot;\&quot;Hello World\&quot;&quot;</span>, String.class);</span><br><span class="line">        System.out.println(message); <span class="comment">//&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">message2</span> <span class="operator">=</span> parseExpression(<span class="string">&quot;\&quot;Hello World\&quot;.concat(&#x27;!&#x27;)&quot;</span>, String.class);</span><br><span class="line">        System.out.println(message2); <span class="comment">//&quot;Hello World!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">parseExpression</span><span class="params">(String expression, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">exp</span> <span class="operator">=</span> parser.parseExpression(expression);</span><br><span class="line">        <span class="keyword">return</span> exp.getValue(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위의 코드는 SpEL표현식 문자열에 대한 파싱(Parsing) 하는 프로그램의 예제 코드이다.</li><li>ExpressionParser Interface를 구현하는 SpelExpressionParser로 SpEL 표현식의 내용을 파싱(Parsing) 할 수 있다.</li><li>exp.getValue() 메서드를 이용해 파싱된 결과값을 Object 타입으로 얻거나, Class정보를 파라미터로 추가해 자동으로 타입 캐스팅이 가능하다.</li></ul><h1 id="EvaluationContext-인터페이스를-이용한-표현식-파싱"><a href="#EvaluationContext-인터페이스를-이용한-표현식-파싱" class="headerlink" title="EvaluationContext 인터페이스를 이용한 표현식 파싱"></a>EvaluationContext 인터페이스를 이용한 표현식 파싱</h1><ul><li>Property, Method, Field에 대한 파싱을 처리</li><li>타입변환을 수행하는 표현식을 평가 할 때 EvaluationContext 인터페이스를 사용</li><li>EvaluationContext의 구현체인 StandardEvaluationContext는 객체를 조작하기 위해 java reflection의 기능을 사용</li><li>성능을 향상 시키기 위해 java.lang.reflect의 Method, Field, Constructor를 캐싱한다.</li></ul><p>SpEL의 더 일반적인 사용법은 특정 객체 인스턴스(root객체)에 대해 평가되는 표현식 문자열을 제공하는 것이다.<br>root객체를 제공하는 방식은 2가지 방식이 있다.</p><h2 id="root-객체를-똑같이-제공하는-경우"><a href="#root-객체를-똑같이-제공하는-경우" class="headerlink" title="root 객체를 똑같이 제공하는 경우"></a>root 객체를 똑같이 제공하는 경우</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create and set a calendar</span></span><br><span class="line"><span class="type">GregorianCalendar</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line">c.set(<span class="number">1856</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// name, birthday, nationality를 파라미터로 갖는 생성자이다.</span></span><br><span class="line"><span class="type">Inventor</span> <span class="variable">tesla</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inventor</span>(<span class="string">&quot;Nikola Tesla&quot;</span>, c.getTime(), <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line"><span class="type">Expression</span> <span class="variable">exp</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;name&quot;</span>); <span class="comment">//tesla객체의 name 프로퍼티가 파싱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Context에 tesla객체를 넣어준다.</span></span><br><span class="line"><span class="type">EvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>(tesla);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) exp.getValue(context); <span class="comment">//name = &quot;Nikola Tesla&quot;</span></span><br></pre></td></tr></table></figure><ul><li>StandardEvaluationContext는 <code>name</code> 프로퍼티가 평가 될 객체를 지정하는 클래스이다.<br>(위의 예제는 root객체, 즉 tesla 객체를 고정하여 사용하는 예제)</li><li>위의 SpelExpressionParser가 표현식을 평가 할 때, 표현식의 대한 기준을 Tesla 객체로 지정하는 부분이다.</li><li><code>parser.parseExpression(&quot;name&quot;);</code> 가 실행되면, tesla 객체의 name 프로퍼티가 파싱된다.</li><li>name변수에는 <code>Nikola Tesla</code> 문자열이 리턴된다.</li><li>타입 캐스팅 실패 시에는, <code>EvaluationException</code>이 throw된다.</li></ul><h2 id="root-객체가-계속-변경되는-경우"><a href="#root-객체가-계속-변경되는-경우" class="headerlink" title="root 객체가 계속 변경되는 경우"></a>root 객체가 계속 변경되는 경우</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create and set a calendar</span></span><br><span class="line"><span class="type">GregorianCalendar</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line">c.set(<span class="number">1856</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// name, birthday, nationality를 파라미터로 갖는 생성자이다.</span></span><br><span class="line"><span class="type">Inventor</span> <span class="variable">tesla</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inventor</span>(<span class="string">&quot;Nikola Tesla&quot;</span>, c.getTime(), <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line"><span class="type">Expression</span> <span class="variable">exp</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;name&quot;</span>); <span class="comment">//tesla객체의 name 프로퍼티가 파싱</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) exp.getValue(tesla);</span><br></pre></td></tr></table></figure><p>getValue 메서드 호출 시에, StandardEvaluationContext를 사용하지 않고 root 객체를 직접 지정해 준다.</p><h2 id="두-가지-방식의-차이"><a href="#두-가지-방식의-차이" class="headerlink" title="두 가지 방식의 차이"></a>두 가지 방식의 차이</h2><ul><li>StandardEvaluationContext를 사용하는 경우 생성 비용이 상대적으로 많이 든다.</li><li>반복적으로 사용하는 동안 <code>Field에 대해 캐싱되고 있기 때문에 표현식 파싱이 더 빠르다</code>는 장점이 있다.</li><li>설정 파일에서 SpEL을 사용하는 경우에는, root 객체를 고정하고 SpEL 표현식만 개발자에게 설정 하도록 하는 것이 좋다.</li></ul><h1 id="Bean을-정의하는-표현식"><a href="#Bean을-정의하는-표현식" class="headerlink" title="Bean을 정의하는 표현식"></a>Bean을 정의하는 표현식</h1><ul><li>BeanDefinition을 정의하는 XML이나, Annotation 기반의 설정에는 MetaData와 SpEL표현식을 같이 사용할 수 있다.</li><li><code>#&#123;&lt;expression&gt;&#125;</code> 문법으로 사용한다.</li></ul><h2 id="XML-Based"><a href="#XML-Based" class="headerlink" title="XML Based"></a>XML Based</h2><ul><li>프로퍼티나 생성자 Argument 값을 표현식으로 나타낼 수 있다.<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;numberGuess&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.spring.samples.NumberGuess&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;randomNumber&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123; T(java.lang.Math).random() * 100.0 &#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>systemProperties bean을 미리 지정하여 사용할 수 있다. (bean을 사용하였지만 <code>@</code> 문자를 안붙인 것을 주의)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;taxCalculator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.spring.samples.TaxCalculator&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultLocale&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>아래 예제 처럼 다른 bean의 Properties를 사용할 수 있다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;numberGuess&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.spring.samples.NumberGuess&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;randomNumber&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123; T(java.lang.Math).random() * 100.0 &#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;shapeGuess&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.spring.samples.ShapeGuess&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialShapeSeed&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123; numberGuess.randomNumber &#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Annotation-Based"><a href="#Annotation-Based" class="headerlink" title="Annotation Based"></a>Annotation Based</h2><ul><li>기본값을 지정하기 위해 @Value Annotation을 이용해 Field, Method, Method-Parameter에 붙일 수 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FieldValueTestBean</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDefaultLocale</span><span class="params">(String defaultLocale)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getDefaultLocale</span><span class="params">()</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.defaultLocale;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PropertyValueTestBean</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDefaultLocale</span><span class="params">(String defaultLocale)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(MovieFinder movieFinder, </span></span><br><span class="line"><span class="params">                 <span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;&#125; String defaultLocale)</span> &#123;</span></span><br><span class="line"><span class="params">  <span class="built_in">this</span>.movieFinder = movieFinder;</span></span><br><span class="line"><span class="params">  <span class="built_in">this</span>.defaultLocale = defaultLocale;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html">https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html</a></li><li><a href="https://blog.outsider.ne.kr/835">https://blog.outsider.ne.kr/835</a></li><li><a href="https://blog.outsider.ne.kr/837">https://blog.outsider.ne.kr/837</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpEL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EHCache 설정방법 (Spring Boot)</title>
      <link href="/2018/11/07/2018-11-04-ehcache-config-for-springboot/"/>
      <url>/2018/11/07/2018-11-04-ehcache-config-for-springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="EHCache-설정하기"><a href="#EHCache-설정하기" class="headerlink" title="EHCache 설정하기"></a>EHCache 설정하기</h1><p>설정 순서는 아래와 같다.</p><ol><li>Maven Dependency 설정</li><li>Ehcache.xml 작성 (ehcache 설정파일)</li><li>@EnableCaching 설정</li></ol><h1 id="Maven-Dependency-설정"><a href="#Maven-Dependency-설정" class="headerlink" title="Maven Dependency 설정"></a>Maven Dependency 설정</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Ehcache-xml-작성-ehcache-설정파일"><a href="#Ehcache-xml-작성-ehcache-설정파일" class="headerlink" title="Ehcache.xml 작성 (ehcache 설정파일)"></a>Ehcache.xml 작성 (ehcache 설정파일)</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxBytesLocalHeap</span>=<span class="string">&quot;300M&quot;</span> &lt;!<span class="attr">--</span> <span class="attr">CacheManager</span>에 의해 관리되는 캐시의 메모리를 <span class="attr">300M</span>로 제한 <span class="attr">--</span>&gt;</span></span><br><span class="line">         updateCheck=&quot;false&quot;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 임시저장 경로를 설정 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;java.io.tmpdir&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,</span></span><br><span class="line"><span class="comment">        maxDepthExceededBehavior = &quot;continue&quot; :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색</span></span><br><span class="line"><span class="comment">        maxDepthExceededBehavior = &quot;abort&quot; : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sizeOfPolicy</span> <span class="attr">maxDepth</span>=<span class="string">&quot;100000&quot;</span> <span class="attr">maxDepthExceededBehavior</span>=<span class="string">&quot;continue&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- default Cache 설정 (반드시 선언해야 하는 Cache) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;1200&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 사용하고자 하는 캐시 별 설정 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;LocalCacheData&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;1200&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;AuthMemberList&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;1200&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)</li><li>cache는 하나의 캐시를 사용할 때마다 구현</li><li>name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.</li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>name</td><td>코드에서 사용할 캐시 name</td><td>필수</td></tr><tr><td>maxEntriesLocalHeap</td><td>메모리에 생성 될 최대 캐시 갯수</td><td>0</td></tr><tr><td>maxEntriesLocalDisk</td><td>디스크에 생성 될 최대 캐시 갯수</td><td>0</td></tr><tr><td>eternal</td><td>영속성 캐시 설정 (지워지는 캐시인지?) <br />external &#x3D; “true”이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨</td><td>false</td></tr><tr><td>timeToIdleSecond</td><td>해당 초동안 캐시가 호출 되지 않으면 삭제</td><td>0</td></tr><tr><td>timeToLiveSeconds</td><td>해당 초가 지나면 캐시가 삭제</td><td>0</td></tr><tr><td>overflowToDisk</td><td>오버플로우 된 항목에 대해 disk에 저장할 지 여부</td><td>false</td></tr><tr><td>diskPersistent</td><td>캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정</td><td>false</td></tr><tr><td>diskExpiryThreadIntervalSeconds</td><td>Disk Expiry 스레드의 작업 수행 간격 설정</td><td>0</td></tr><tr><td>memoryStoreEvictionPolicy</td><td>캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br />LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br />LFU : 호출 빈도가 가장 적은 캐시를 삭제<br />FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제</td><td>LRU</td></tr></tbody></table><p>#@EnableCaching 설정 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching(proxyTargetClass = true, mode = AdviceMode.PROXY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EHCacheConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> EhCacheManagerFactoryBean <span class="title function_">ehCacheManagerFactoryBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">EhCacheManagerFactoryBean</span> <span class="variable">ehCacheManagerFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EhCacheManagerFactoryBean</span>();</span><br><span class="line">        ehCacheManagerFactoryBean.setConfigLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;config/ehcache.xml&quot;</span>));</span><br><span class="line">        ehCacheManagerFactoryBean.setShared(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ehCacheManagerFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> EhCacheCacheManager <span class="title function_">ehCacheCacheManager</span><span class="params">(EhCacheManagerFactoryBean ehCacheManagerFactoryBean)</span> &#123;</span><br><span class="line">        <span class="type">EhCacheCacheManager</span> <span class="variable">ehCacheCacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EhCacheCacheManager</span>();</span><br><span class="line">        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());</span><br><span class="line">        <span class="keyword">return</span> ehCacheCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@EnableCaching Annotation은 <code>&lt;cache:annotation-driven&gt;</code>와 마찬가지로 어노테이션 기반 캐시를 사용 할 수 있는 설정</li><li>내부적으로 Spring AOP를 통해 @Cacheable, @CacheEvict와 같은 어노테이션을 Pointcut으로 이용해서 Cache기능을 구현하는 듯 하다.</li><li>proxyTargetClass : class 기반 프록시를 생성함을 의미 (CGLIB라이브러리에 대한 의존성 필요)</li><li>Mode : 어떤 Advisor 모듈을 선택할지에 대한 설정 <ul><li>PROXY : Spring AOP Proxy방식을 이용</li><li>ASPECTJ : LTW, CTW기능을 이용한 위빙</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> EHCache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EHCache 설정방법 (Spring Framework)</title>
      <link href="/2018/11/07/2018-11-04-ehcache-config-for-springframework/"/>
      <url>/2018/11/07/2018-11-04-ehcache-config-for-springframework/</url>
      
        <content type="html"><![CDATA[<h1 id="EHCache-설정하기"><a href="#EHCache-설정하기" class="headerlink" title="EHCache 설정하기"></a>EHCache 설정하기</h1><p>설정 순서는 아래와 같다.</p><ol><li>Maven Dependency 설정</li><li>Ehcache.xml 작성 (ehcache 설정파일)</li><li>CacheManager 설정 (xml)</li></ol><h1 id="Maven-Dependency-설정"><a href="#Maven-Dependency-설정" class="headerlink" title="Maven Dependency 설정"></a>Maven Dependency 설정</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- EHCache 모듈 (블로그 작성 시점에서 2.10.6이 최신이다.) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Spring Caching Interface --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.20.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- EHCache Support 모듈, 다른 Caching 지원모듈 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.20.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="ehcache-xml-작성"><a href="#ehcache-xml-작성" class="headerlink" title="ehcache.xml 작성"></a>ehcache.xml 작성</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxBytesLocalHeap</span>=<span class="string">&quot;300M&quot;</span> &lt;!<span class="attr">--</span> <span class="attr">CacheManager</span>에 의해 관리되는 캐시의 메모리를 <span class="attr">300M</span>로 제한 <span class="attr">--</span>&gt;</span></span><br><span class="line">         updateCheck=&quot;false&quot;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 임시저장 경로를 설정 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;java.io.tmpdir&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        Cache에 저장할 레퍼런스의 최대값을 100000으로 지정,</span></span><br><span class="line"><span class="comment">        maxDepthExceededBehavior = &quot;continue&quot; :  초과 된 최대 깊이에 대해 경고하지만 크기가 조정 된 요소를 계속 탐색</span></span><br><span class="line"><span class="comment">        maxDepthExceededBehavior = &quot;abort&quot; : 순회를 중지하고 부분적으로 계산 된 크기를 즉시 반환</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sizeOfPolicy</span> <span class="attr">maxDepth</span>=<span class="string">&quot;100000&quot;</span> <span class="attr">maxDepthExceededBehavior</span>=<span class="string">&quot;continue&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- default Cache 설정 (반드시 선언해야 하는 Cache) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;1200&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 사용하고자 하는 캐시 별 설정 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;LocalCacheData&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;1200&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;AuthMemberList&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;1200&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>defaultCache는 반드시 구현해야 할 캐시 (직접 생성하는 캐시에 대한 기본 설정)</li><li>cache는 하나의 캐시를 사용할 때마다 구현</li><li>name 속성은 캐시의 이름을 지정하며, 코드에서는 이 캐시의 이름을 사용하여 사용할 Cache 인스턴스를 구한다.</li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>name</td><td>코드에서 사용할 캐시 name</td><td>필수</td></tr><tr><td>maxEntriesLocalHeap</td><td>메모리에 생성 될 최대 캐시 갯수</td><td>0</td></tr><tr><td>maxEntriesLocalDisk</td><td>디스크에 생성 될 최대 캐시 갯수</td><td>0</td></tr><tr><td>eternal</td><td>영속성 캐시 설정 (지워지는 캐시인지?) <br />external &#x3D; “true”이면, timeToIdleSecond, timeToLiveSeconds 설정이 무시됨</td><td>false</td></tr><tr><td>timeToIdleSecond</td><td>해당 초동안 캐시가 호출 되지 않으면 삭제</td><td>0</td></tr><tr><td>timeToLiveSeconds</td><td>해당 초가 지나면 캐시가 삭제</td><td>0</td></tr><tr><td>overflowToDisk</td><td>오버플로우 된 항목에 대해 disk에 저장할 지 여부</td><td>false</td></tr><tr><td>diskPersistent</td><td>캐시를 disk에 저장하여, 서버 로드 시 캐시를 말아 둘지 설정</td><td>false</td></tr><tr><td>diskExpiryThreadIntervalSeconds</td><td>Disk Expiry 스레드의 작업 수행 간격 설정</td><td>0</td></tr><tr><td>memoryStoreEvictionPolicy</td><td>캐시의 객체 수가 maxEntriesLocalHeap에 도달하면, 객체를 추가하고 제거하는 정책 설정<br />LRU : 가장 오랫동안 호출 되지 않은 캐시를 삭제<br />LFU : 호출 빈도가 가장 적은 캐시를 삭제<br />FIFO : First In First Out, 캐시가 생성된 순서대로 가장 오래된 캐시를 삭제</td><td>LRU</td></tr></tbody></table><h1 id="CacheManager-Bean-설정"><a href="#CacheManager-Bean-설정" class="headerlink" title="CacheManager Bean 설정"></a>CacheManager Bean 설정</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">z<span class="comment">&lt;!-- Annotation 기반 캐시 사용 (@Cacheable, @CacheEvict..) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- EHCache 기반 CacheManager 설정 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cacheManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ehcache&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ehcache.xml 설정 로드 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ehcache&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:config/ehcache.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;shared&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://github.com/skoh/common/blob/master/common-web/src/main/resources/ehcache.xml">https://github.com/skoh/common/blob/master/common-web/src/main/resources/ehcache.xml</a></li><li><a href="https://www.mkyong.com/spring/spring-caching-and-ehcache-example/">https://www.mkyong.com/spring/spring-caching-and-ehcache-example/</a></li><li><a href="http://hyeooona825.tistory.com/86">http://hyeooona825.tistory.com/86</a></li><li><a href="http://blog.naver.com/PostView.nhn?blogId=kyung778&amp;logNo=60164009610">http://blog.naver.com/PostView.nhn?blogId=kyung778&amp;logNo=60164009610</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> EHCache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache에 대하여.. (Spring+EHCache)</title>
      <link href="/2018/11/07/2018-10-03-spring-ehcache/"/>
      <url>/2018/11/07/2018-10-03-spring-ehcache/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며.."></a>들어가며..</h1><p>엔터프라이즈 급 Application에서는 DBMS의 부하를 줄이고, 성능을 높이기 위해 캐시(Cache)를 사용한다. 우리 회사에서도 EHCache, Redis를 사용하지만, EHCache쪽은 공부한 적이 없어서 이번 기회에 정리하면서 공부해 보게 되었다.<br>대부분 <code>docs.spring.io</code>의 문서를 번역한 내용을 위주로 정리 하였다.</p><h1 id="Cache란"><a href="#Cache란" class="headerlink" title="Cache란?"></a>Cache란?</h1><p>Cache의 사전적인 의미를 알아보기 위해 위키백과를 검색해 보았다.</p><blockquote><p><strong>캐시</strong>(cache, <a href="https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4">문화어</a>: 캐쉬, 고속완충기, 고속완충기억기)는 <a href="https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99">컴퓨터 과학</a>에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 캐시는 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.</p><p>캐시는 시스템의 효율성을 위해 여러 분야에서 두루 쓰인다.</p></blockquote><p>결국 캐시란, 반복적으로 데이터를 불러올 때 지속적으로 DBMS 혹은 서버에 요청하는 것이 아닌 메모리에 데이터를 저장하였다가 데이터를 불러다가 쓰는 것을 의미한다. 따라서 서버나 DBMS에 부담을 덜어주고, 엄청 빠르기 때문에 많은 시스템에서 사용하고 있다.<br>대표적으로 Browser Cache, Apacha Cache, DNS Cache등 여러가지 형태로 캐시가 사용되고 있다.</p><p>EHCache 사이트에서는 캐시에 대한 용어를 이렇게 정리 하였다.</p><ul><li><strong>Cache</strong> : 캐시는 <code>미래에 필요할 것이고 빠르게 검색할 수 있는 데이터를 담은 저장소</code> 라고 정의 한다. 캐시는 다른 곳에 있는 데이터를 복제하거나, 계산 결과를 임시적으로 저장하는 데이터 저장소이다. 캐시에 있는 데이터는 시간과 자원 면에서 최소한의 비용으로 반복적으로 접근 할 수 있다.</li><li><strong>Cache Hit</strong> : 데이터 요소가 캐시에 요청되고 해당 키에 대한 요소가 존재하면 Cache Hit (또는 단순히 ‘Hit’)라고 한다.</li><li><strong>Cache Miss</strong>:데이터 요소가 캐시에 요청되고 해당 키에 대해 요소가 존재하지 않으면 Cache Miss (또는 단순히 ‘Miss’)라고 한다.</li><li><strong>System-of-record</strong> : 데이터에 대한 신뢰할 수있는 정보원. 이것을 흔히 시스템 레코드(SOR)이라고 한다. 캐시는 시스템 레코드에서 검색되거나 시스템 레코드에 저장된 데이터의 로컬 사본으로 작동된다. Ehcache를 사용하기 위해 SOR은 데이터베이스로 간주된다.</li></ul><h1 id="Long-Tail-법칙"><a href="#Long-Tail-법칙" class="headerlink" title="Long Tail 법칙"></a>Long Tail 법칙</h1><p><img src="./17110B4350CC5EC51D.jpeg" alt="Long Tail"></p><p>20%의 요구가 시스템 리소스의 대부분을 잡아먹는다는 법칙.<br>자주 사용되는 <code>20%의 기능에 캐시를 이용</code>하면 리소스 사용량을 대폭 줄일 수 있어, <code>시스템의 성능을 대폭 향상</code> 시킬 수 있다.</p><h1 id="Local-Cache-vs-Global-Cache"><a href="#Local-Cache-vs-Global-Cache" class="headerlink" title="Local Cache vs Global Cache"></a>Local Cache vs Global Cache</h1><ul><li><p>Local Cache</p><ul><li>Local 장비 내에서만 사용 되는 캐시</li><li>Local 장비의 Resource를 이용한다 (Memory, Disk)</li><li>Local에서 작동 되기 때문에 속도가 빠르다.</li><li>Local에서만 작동되기 때문에 다른 서버와 데이터 공유가 어렵다</li></ul></li><li><p>Global Cache</p><ul><li>여러 서버에서 Cache Server에 접근하여 사용하는 캐시</li><li>데이터를 분산하여 저장 할 수 있다. <ul><li>Replication - 데이터를 복제</li><li>Sharding - 데이터를 분산하여 저장</li></ul></li><li>Local Cache에 비해 상대적으로 느리다 (네트워크 트래픽)</li><li>별도의 Cache Server를 이용하기 때문에 서버 간 데이터 공유가 쉽다.</li></ul></li></ul><h1 id="Spring-Cache-Abstraction"><a href="#Spring-Cache-Abstraction" class="headerlink" title="Spring Cache Abstraction"></a>Spring Cache Abstraction</h1><p>Spring 3.1버전부터 Spring Application에 캐시를 쉽게 추가할 수 있도록 기능을 제공하게 되었다. 유사 트랜잭션을 지원하고, 사용하고 있는 코드(메소드)에 영향을 최소화 하면서 일관된 방법으로 캐시를 사용 할 수 있게 되었다.</p><p>Spring에서 캐시 추상화는 메소드를 통해 기능을 지원하는데, 메소드가 실행되는 시점에 파라미터에 대한 캐시 존재 여부를 판단하여 없으면 캐시를 등록하게 되고, 캐시가 있으면 메소드를 실행 시키지 않고 캐시 데이터를 Return 해주게 된다.</p><p>Spring 캐시 추상화를 지원하기 때문에 개발자는 별도의 캐시 로직을 작성하지 않아도 된다. 하지만 캐시를 저장하는 저장소는 직접 설정을 해주어야 한다. Spring에서는 <code>CacheManager</code>라는 Interface를 제공하여 캐시를 구현하도록 하고 있다.</p><br/><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Boot에서는 <code>spring-boot-starter-cache</code> Artifact를 추가 하여 CacheManager를 구성 할 수 있다.<br>기본적으로 별도의 추가적인 서드파티 모듈이 없는 경우에는 Local Memory에 저장이 가능한 ConcurrentMap기반인 <code>ConcurrentMapCacheManager</code>가 Bean으로 자동 생성 된다.</p><p>이외에도 EHCache, Redis등의 서드파티 모듈을 추가 하게 되면 <code>EHCacheCacheManager</code>, <code>RedisCacheManager</code>를 Bean으로 등록 하여 사용할 수 있다. 이렇게 되면 별도로 다른 설정 없이도  단순 Memory Cache가 아닌 Cache Server를 대상으로 캐시를 저장 할 수 있도록 지원하고 있다.</p><h1 id="Spring-Cache-Annotation"><a href="#Spring-Cache-Annotation" class="headerlink" title="Spring Cache Annotation"></a>Spring Cache Annotation</h1><p>Spring에서는 Cache Annotation을 지원하여 좀 더 쉽게 메서드에 대한 캐시를 제어할 수 있다.</p><ul><li>@EnableCaching<ul><li>Annotation 기반 캐싱 설정을 사용 (내부적으로 Spring AOP 이용)</li></ul></li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>proxyTargetClass</td><td>클래스 기반의 Proxy생성 여부<br />false인 경우 JDK Dynamic Proxy 사용 (Interface 기반)<br />true인 경우 CGLIB Proxy 사용 (Class 기반)</td><td>false</td></tr><tr><td>mode</td><td>위빙 (Weaving) 모드에 대한 설정<br />PROXY : 기존의 Spring AOP 방식을 이용한 RTW방식 사용<br />ASPECTJ : aspectj 라이브러리를 이용한 CTW, LTW 방식 지원</td><td>PROXY</td></tr><tr><td>order</td><td>AOP order 설정</td><td>Integer.MAX_VALUE</td></tr></tbody></table><ul><li>@Cacheable<ul><li>캐싱할 수 있는 메서드를 지정하기 위해 사용</li></ul></li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>value, cacheName</td><td>캐시 명</td><td>{}</td></tr><tr><td>key</td><td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td><td>“”</td></tr><tr><td>keyGenerator</td><td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td><td>“”</td></tr><tr><td>cacheManager</td><td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td><td>“”</td></tr><tr><td>cacheResolver</td><td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td><td>“”</td></tr><tr><td>condition</td><td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 <code>true</code>인 경우에만 캐싱</td><td>“”</td></tr><tr><td>unless</td><td>캐싱이 이루어지지 않는 조건을 설정<br />연산 조건이 <code>true</code> 이면 경우에는 캐싱되지 않는다<br />예시 : id가 null아 아닌 경우에만 캐싱 (unless &#x3D; “#id &#x3D;&#x3D; null”)</td><td>“”</td></tr><tr><td>sync</td><td>캐시 구현체가 Thread safe 하지 않는 경우, 자체적으로 캐시에 동기화를 거는 속성</td><td>false</td></tr></tbody></table><ul><li>@CacheEvict<ul><li>메서드 실행 시, 해당 캐시를 삭제</li></ul></li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>value, cacheName</td><td>캐시 명</td><td>{}</td></tr><tr><td>key</td><td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td><td>“”</td></tr><tr><td>keyGenerator</td><td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td><td>“”</td></tr><tr><td>cacheManager</td><td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td><td>“”</td></tr><tr><td>cacheResolver</td><td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td><td>“”</td></tr><tr><td>condition</td><td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 <code>true</code>인 경우에만 캐시 삭제</td><td>“”</td></tr><tr><td>allEntries</td><td>Cache Key에 대한 전체 데이터 삭제 여부</td><td>false</td></tr><tr><td>beforeInvocation</td><td>true면 메서드 실행 이전에 캐시 삭제, false면 메서드 실행 이후 삭제</td><td>false</td></tr></tbody></table><ul><li>@CachePut<ul><li>메서드 실행에 영향을 주지 않고 캐시를 갱신해야 하는 경우 사용</li><li>보통은 @Cacheable과 @CachePut Annotation을 같이 사용하지 않는다.<br>(둘은 다른 동작을 하기 때문에, 실행순서에 따라 다른 결과가 나올 수 있다.)</li><li>@CachePut Annotation은 캐시 생성용으로만 사용한다.</li></ul></li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>value, cacheName</td><td>캐시 명</td><td>{}</td></tr><tr><td>key</td><td>같은 캐시명을 사용 할 때, 구분되는 구분 값 (KeyGenerator와 함께 쓸 수 없다.)</td><td>“”</td></tr><tr><td>keyGenerator</td><td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td><td>“”</td></tr><tr><td>cacheManager</td><td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td><td>“”</td></tr><tr><td>cacheResolver</td><td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td><td>“”</td></tr><tr><td>condition</td><td>SpEL 표현식을 통해 특정 조건에 부합하는 경우에만 캐시 사용<br />and, or 표현식등을 통해 복수 조건 사용가능<br />연산 조건이 <code>true</code>인 경우에만 캐싱</td><td>“”</td></tr><tr><td>unless</td><td>캐싱이 이루어지지 않는 조건을 설정<br />연산 조건이 <code>true</code> 이면 경우에는 캐싱되지 않는다<br />예시 : id가 null아 아닌 경우에만 캐싱 (unless &#x3D; “#id &#x3D;&#x3D; null”)</td><td>“”</td></tr></tbody></table><ul><li>@Caching<ul><li>@CacheEvict이나 @CachePut을 여러개 지정해야 하는 경우에 사용</li><li>조건식이나 표현식이 다른 경우에 사용한다.</li><li>여러가지의 key에 대한 캐시를 중첩적으로 삭제해야 할 때 사용</li></ul></li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>cacheable[]</td><td>@Cacheable 적용할 Annotation을 등록한다.</td><td>{}</td></tr><tr><td>put[]</td><td>@CachePut 적용할 Annotation을 등록한다.</td><td>{}</td></tr><tr><td>evict[]</td><td>@CacheEvic 적용할 Annotation을 등록한다.</td><td>{}</td></tr></tbody></table><ul><li>@CacheConfig<ul><li>클래스 단위로 캐시설정을 동일하게 하는데 사용</li><li>이 설정은 CacheManager가 여러개인 경우에만 사용</li><li>Member조회 클래스에서는 Redis기반 캐시를 사용하고<br>Product 조회 클래스에서는 EHCache 기반 캐시를 사용할 때<br>각 클래스 별로 CacheManager를 지정 가능</li></ul></li></ul><table><thead><tr><th>속성</th><th>설명</th><th>Default</th></tr></thead><tbody><tr><td>cacheNames</td><td>캐시 명</td><td>{}</td></tr><tr><td>keyGenerator</td><td>특정 로직에 의해 cache key를 만들고자 하는 경우 사용<br />4.0이후 버전 부터 SimpleKeyGenerator를 사용<br />Custom Key Generator를 사용하고 싶으면, KeyGenerator 인터페이스를 별도로 구현</td><td>“”</td></tr><tr><td>cacheManager</td><td>사용할 CacheManager를 지정 (EHCacheManager, RedisCacheManager등)</td><td>“”</td></tr><tr><td>cacheResolver</td><td>Cache 키에 대한 결과값을 돌려주는 Resolver (Interceptor역할)<br />CacheResolver를 구현하여 Custom하게 처리 할 수도 있다.</td><td>“”</td></tr></tbody></table><h1 id="EHCache"><a href="#EHCache" class="headerlink" title="EHCache"></a>EHCache</h1><p><img src="./EHCACHE.png" alt="EHCACHE"></p><ul><li>EHCache는 오픈 소스 기반의 Local Cache이다. </li><li>속도가 빠르며 경량 Cache라는 장점이 있다.</li><li>Disk, Memory 저장이 가능한 형태</li><li>서버 간 분산 캐시를 지원한다 (동기&#x2F;비동기 복제)</li><li>JSR107 JCache 표준을 지원한다.<br>따라서 JCache에서 제공하는 Annotation을 통해 이미 작성된 코드에 간단하게 기능 추가가 쉽다.<blockquote><p><strong>JSR-107</strong> : (JCACHE – Java Temporary Caching API) 객체 생성, 공유 액세스, 스풀링, 무효화 및 JVM 전반에 걸친 일관성을 포함하여 Java 객체의 메모리 캐싱에서 사용할 API 에 대한 기준으로 볼 수 있다.    해당 Spec 으로 구현된 cache로는 EhCache가 유명하며, Hazelcast, Infinispan, Couchbase, Redis, Caffeine 등도 해당 기준을 따르는 것으로 알려져 있다.</p></blockquote></li></ul><h1 id="EHCache-설정-방법"><a href="#EHCache-설정-방법" class="headerlink" title="EHCache 설정 방법"></a>EHCache 설정 방법</h1><p>내용이 길어 질 것 같아 별도의 포스트로 작성</p><ul><li><a href="http://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springframework/">EHCache 설정방법 (Spring Framework)</a></li><li><a href="http://jaehun2841.github.io/2018/11/07/2018-11-04-ehcache-config-for-springboot/">EHCache 설정방법 (Spring Boot)</a></li></ul><h1 id="EHCache-예시-코드"><a href="#EHCache-예시-코드" class="headerlink" title="EHCache 예시 코드"></a>EHCache 예시 코드</h1><p>테스트 시나리오</p><ol><li>가상으로 DBMS에서 데이터를 조회 하는 Repository를 생성</li><li>3초 정도 슬로우쿼리가 실행된다고 가정</li><li>최초 1회는 DB에서 조회, 2회차 부턴 캐시 사용</li><li>캐시를 조회했을 때, 걸리는 시간 확인</li><li>캐시가 만료되었을때, 걸리는 시간 확인</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EHCacheController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EHCacheRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/data/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> repository.getData(id);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;쿼리 수행 시간 : &#123;&#125;ms&quot;</span>, end-start);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/data/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getExpireCache</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        repository.evictCache(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EHCacheRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(cacheNames = &quot;testData&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test-data&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(cacheNames = &quot;testData&quot;, allEntries = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evictCache</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;delete cache all&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching(proxyTargetClass = true, mode = AdviceMode.PROXY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EHCacheConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> EhCacheManagerFactoryBean <span class="title function_">ehCacheManagerFactoryBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">EhCacheManagerFactoryBean</span> <span class="variable">ehCacheManagerFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EhCacheManagerFactoryBean</span>();</span><br><span class="line">        ehCacheManagerFactoryBean.setConfigLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;config/ehcache.xml&quot;</span>));</span><br><span class="line">        ehCacheManagerFactoryBean.setShared(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ehCacheManagerFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> EhCacheCacheManager <span class="title function_">ehCacheCacheManager</span><span class="params">(EhCacheManagerFactoryBean ehCacheManagerFactoryBean)</span> &#123;</span><br><span class="line">        <span class="type">EhCacheCacheManager</span> <span class="variable">ehCacheCacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EhCacheCacheManager</span>();</span><br><span class="line">        ehCacheCacheManager.setCacheManager(ehCacheManagerFactoryBean.getObject());</span><br><span class="line">        <span class="keyword">return</span> ehCacheCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxBytesLocalHeap</span>=<span class="string">&quot;300M&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">updateCheck</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;java.io.tmpdir&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sizeOfPolicy</span> <span class="attr">maxDepth</span>=<span class="string">&quot;100000&quot;</span> <span class="attr">maxDepthExceededBehavior</span>=<span class="string">&quot;continue&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;1200&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;LocalCacheData&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;1200&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;testData&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><br/><p>결과</p><p><img src="./ehcache-test.png" alt="ehcache-test"></p><ol><li>최초로 <code>GET localhost:8080/data/1</code> 요청 시, 3초 이상의 슬로우 쿼리가 실행</li><li>두번째로 동일하게 <code>GET localhost:8080/data/1</code> 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)</li><li><code>GET localhost:8080/data/delete/1</code> 요청으로 캐시 삭제</li><li><code>GET localhost:8080/data/1</code> 요청 시, 3초 이상의 슬로우 쿼리가 실행 (캐시 삭제 후 요청)</li><li><code>GET localhost:8080/data/1</code> 요청 시, 3ms의 빠른 실행 결과가 나타남 (캐시 적용)</li></ol><blockquote><p>주의 할 점! </p><p>EHCache는 ehcache.xml 또는 Java 코드에서 addCache를 이용하여 반드시 Cache Key를 등록해 줘야 함<br>이거를 안 등록하고 Cache Key를 막쓰다가.. 계속 Cache Key가 없다는 오류가 발생하여 잠깐 삽질..</p></blockquote><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="http://www.ehcache.org/documentation/2.8/integrations/spring.html#introduction">http://www.ehcache.org/documentation/2.8/integrations/spring.html#introduction</a></li><li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache">https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache</a></li><li><a href="http://blog.breakingthat.com/2018/03/19/springboot-ehcache-%EC%A0%81%EC%9A%A9/">http://blog.breakingthat.com/2018/03/19/springboot-ehcache-%EC%A0%81%EC%9A%A9/</a></li><li><a href="https://jojoldu.tistory.com/57">https://jojoldu.tistory.com/57</a></li><li><a href="http://www.ehcache.org/documentation/2.8/configuration/index.html">http://www.ehcache.org/documentation/2.8/configuration/index.html</a></li><li><a href="https://www.slideshare.net/heungrae_kim/spring-31-ehcache">https://www.slideshare.net/heungrae_kim/spring-31-ehcache</a></li><li><a href="https://shortstories.gitbooks.io/studybook/content/cache.html">https://shortstories.gitbooks.io/studybook/content/cache.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Import와 @ImportResource Annotation</title>
      <link href="/2018/10/21/2018-10-21-java-config-import/"/>
      <url>/2018/10/21/2018-10-21-java-config-import/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>회사 프로젝트 설정은 대부분이 xml설정으로 되어있다.<br>아무도 그 xml설정을 건드리지 않고 있는데, 내가 차츰차츰 Java-Config로 바꾸자고 주장하고 있었고<br>최근에 일부 xml Config를 Java Config로 전환하는 작업을 진행 하였다.<br>그 때 사용한 @Import, @ImportResource Annotation에 대한 기록을 남겨보고자 한다.</p><h1 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h1><p>@Import Annotation은 기본적으로 Java 파일에 대한 Import를 위해 사용한다.<br>사용하는 개념은 기존에 xml 파일을 import하는.. <import /> 구분과 동일하게 사용된다.</p><p>예를 들어 Cache에 대한 Datasource를 설정하는 부분이 있다고 가정을 하면..</p><p><strong>RedisClusterConfig</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(value = RedisShardsConfig.class)</span> <span class="comment">// Redis Shard정보에 대한 Config이다.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClusterConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;redisConfig&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Properties redisConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GenericObjectPoolConfig <span class="title function_">jedisPoolConfig</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">    poolConfig.setMaxTotal(redisConfig.getProperty(<span class="string">&quot;redis.cluster.connectionCount&quot;</span>));</span><br><span class="line">poolConfig.setMaxIdle(commonConfig.getProperty(<span class="string">&quot;redis.cluster.connectionCount&quot;</span>));</span><br><span class="line">poolConfig.setMinIdle(commonConfig.getProperty(<span class="string">&quot;redis.cluster.connectionCount&quot;</span>));</span><br><span class="line">poolConfig.setNumTestsPerEvictionRun(<span class="number">2</span>);</span><br><span class="line">poolConfig.setTestOnBorrow(<span class="literal">true</span>);</span><br><span class="line">poolConfig.setTestOnReturn(<span class="literal">false</span>);</span><br><span class="line">poolConfig.setTestWhileIdle(<span class="literal">true</span>);</span><br><span class="line">poolConfig.setTimeBetweenEvictionRunsMillis(<span class="number">300000</span>);</span><br><span class="line"><span class="keyword">return</span> poolConfig;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//따로 @Autowired 하지 않고, 변수명 = bean이름으로 자동으로 매칭될 수 있게 설정하였다.</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ShardedJedisPool <span class="title function_">masterShardedPool</span><span class="params">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisMasterShards)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShardedJedisPool</span>(jedisPoolConfig, redisMasterShards, Hashing.MURMUR_HASH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ShardedJedisPool <span class="title function_">slaveShardedPool</span><span class="params">(GenericObjectPoolConfig jedisPoolConfig, List&lt;JedisShardInfo&gt; redisSlaveShards)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShardedJedisPool</span>(jedisPoolConfig, redisSlaveShards, Hashing.MURMUR_HASH);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RedisShardsConfig.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisShardsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;redisConfig&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Properties redisConfig;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> List&lt;JedisShardInfo&gt; <span class="title function_">redisMasterShards</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.url&quot;</span>);</span><br><span class="line">        <span class="comment">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">masterPort1</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.master.port1&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">masterPort2</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.master.port2&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">masterPort3</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.master.port3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">masterShardKey1</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.master.key1&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">masterShardKey2</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.master.key2&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">masterShardKey3</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.master.key3&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;JedisShardInfo&gt;() &#123;</span><br><span class="line">&#123;</span><br><span class="line">add(<span class="keyword">new</span> <span class="title class_">JedisShardInfo</span>(url, masterPort1, masterShardKey1));</span><br><span class="line">add(<span class="keyword">new</span> <span class="title class_">JedisShardInfo</span>(url, masterPort2, masterShardKey2));</span><br><span class="line">add(<span class="keyword">new</span> <span class="title class_">JedisShardInfo</span>(url, masterPort3, masterShardKey3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> List&lt;JedisShardInfo&gt; <span class="title function_">redisSlaveShards</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.url&quot;</span>);</span><br><span class="line">        <span class="comment">//Integer 형변환 생략함...(길어져서 안보임)</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">slavePort1</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.slave.port1&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">slavePort2</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.slave.port2&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">slavePort3</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.slave.port3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">slaveShardKey1</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.slave.key1&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">slaveShardKey2</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.slave.key2&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">slaveShardKey3</span> <span class="operator">=</span> redisConfig.getProperty(<span class="string">&quot;redis.cluster.slave.key3&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;JedisShardInfo&gt;() &#123;</span><br><span class="line">&#123;</span><br><span class="line">add(<span class="keyword">new</span> <span class="title class_">JedisShardInfo</span>(url, slavePort1, slaveShardKey1));</span><br><span class="line">add(<span class="keyword">new</span> <span class="title class_">JedisShardInfo</span>(url, slavePort2, slaveShardKey2));</span><br><span class="line">add(<span class="keyword">new</span> <span class="title class_">JedisShardInfo</span>(url, slavePort3, slaveShardKey3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedisClusterConfig.java에서는 실제 Redis Cluster Bean을 생성하는 코드이다.<br>RedisShardsConfig.java에서는 Shard Node에 대한 설정을 하는 부분이다.<br>이렇게 설정을 두개로 분리하여 @Import를 Annotation을 사용 하여 상속보다는 유동적으로 Config 설정을 할 수 있다.<br>이 설정은 기본 Spring Configuration 설정 보다는 Test Case작성 시에 큰 힘을 발휘 할 것이라고 생각된다.<br>xml을 로드해서 전체 Bean을 올리는게 아닌, 필요한 Bean 설정만 Import해서 올릴 수 있기 때문이다.</p><h1 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h1><p>모든 설정을 JavaConfig로 변경하면 좋겠지만, 시간 관계상이나 복잡한것들은 나중에 하려고 xml파일 형태로 남겨둔 것들이 있다. (예를들면 Datasource나… 외부 연동 Bean들…)</p><p>그런 configuration들을 import해주기 위해 @ImportResource Annotation을 사용하였다.<br>사용법은 간단하다. @ImportResource Annotation value에 배열 형태로 선언만 해주면 되기 때문이다.</p><p>예시는 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(value = &#123;</span></span><br><span class="line"><span class="meta">&quot;classpath:applicationContextForExternalMember.xml&quot;,    //External-Member</span></span><br><span class="line"><span class="meta">&quot;classpath*:applicationContextForExternalAPI.xml&quot;,      //External-API</span></span><br><span class="line"><span class="meta">&quot;classpath*:applicationContextForExternalLogger.xml&quot;    //External-Logger</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 위와같이 설정하면, @Configuration Annotation에 의해 Component-scan 되는 시점에 해당 파일들이 import되어 Configuration 설정이 적용된다.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Java-Config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Application-Context와 Servlet-Context</title>
      <link href="/2018/10/21/2018-10-21-spring-context/"/>
      <url>/2018/10/21/2018-10-21-spring-context/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>회사 업무 중에 AOP를 이용하여 개발 중에 AOP가 제대로 설정이 되지 않는 문제가 있었다.<br>문제의 원인은 Component-scan 위치에 따른 Bean 생성 위치에 있었다.<br>core가 되는 프로젝트는 applicationContext에서 component-scan을 통해 bean을 생성 하고 있었고,<br>각 endpoint가 되는 프로젝트내의 패키지는 모두 servlet-context에서 component-scan을 하고 있었다.<br>Bean의 생성 위치 상, AOP를 적용할 수 없었기 때문에 발생한 문제 였다.</p><p>이번 기회에 Application Context와 Servlet Context의 계층을 알게 되어 나름대로 정리 해보고자 한다.</p><h1 id="Web-Application-Context"><a href="#Web-Application-Context" class="headerlink" title="Web Application Context"></a>Web Application Context</h1><p><img src="./99A34C3359FEAA8410.png" alt="img"></p><h2 id="Application-Context"><a href="#Application-Context" class="headerlink" title="Application Context"></a>Application Context</h2><ul><li>Web Application 최상단에 위치하고 있는 Context</li><li>Spring에서 ApplicationContext란 BeanFactory를 상속받고 있는 Context</li><li>Spring에서 root-context.xml, applicationContext.xml 파일은 ApplicationContext 생성 시 필요한<br>설정정보를 담은 파일 (Bean 선언 등..)</li><li>Spring에서 생성되는 Bean에 대한 IoC Container (또는 Bean Container)</li><li>특정 Servlet설정과 관계 없는 설정을 한다 (@Service, @Repository, @Configuration, @Component)</li><li>서로 다른 여러 Servlet에서 공통적으로 공유해서 사용할 수 있는 Bean을 선언한다.</li><li><strong>Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할 수 없다.</strong></li></ul><h2 id="Servlet-Context-servlet-context-xml"><a href="#Servlet-Context-servlet-context-xml" class="headerlink" title="Servlet-Context (servlet-context.xml)"></a>Servlet-Context (servlet-context.xml)</h2><ul><li>Servlet 단위로 생성되는 context</li><li>Spring에서 servlet-context.xml 파일은 DispatcherServlet 생성 시에 필요한 설정 정보를 담은 파일<br>(Interceptor, Bean생성, ViewResolver등..)</li><li>URL설정이 있는 Bean을 생성 (@Controller, Interceptor)</li><li>Application Context를 자신의 부모 Context로 사용한다.</li><li>Application Context와 Servlet Context에 같은 id로 된 Bean이 등록 되는 경우,<br>Servlet Context에 선언된 Bean을 사용한다.</li><li>Bean 찾는 순서 <ul><li>Servlet Context에서 먼저 찾는다.</li><li>만약 Servlet Context에서 bean을 못찾는 경우 Application Context에 정의된 bean을 찾는다.</li></ul></li><li><strong>Servlet Context에 정의된 Bean은 Application Context의 Bean을 사용할 수 있다.</strong></li></ul><h1 id="web-xml-설정-살펴보기"><a href="#web-xml-설정-살펴보기" class="headerlink" title="web.xml 설정 살펴보기"></a>web.xml 설정 살펴보기</h1><h2 id="web-xml-이란"><a href="#web-xml-이란" class="headerlink" title="web.xml 이란"></a>web.xml 이란</h2><p>서블릿 클래스는 JSP 페이지와 달리 설치뿐만 아니라 등록을 하는 과정을 필요로 한다.<br>여기서 서블릿 클래스를 등록하는 곳의 이름을 <code>Web application deployment descriptor</code>라고 하는데 (줄여서 DD-Deployment Descriptor) 이 역할을 하는 것이 바로 <code>web.xml</code>이다. <code>web.xml</code> 파일은 웹 애플리케이션 디렉터리마다 딱 하나씩만 존재할 수 있다.</p><p>DD는 WAS 구동 시 <code>/WEB-INF</code> 디렉토리에 존재하는 <code>web.xml</code>을 읽어 웹 애플리케이션의 설정을 구성하기 위해 존재한다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- applicationContext.xml에서 설정한 Bean은 모든 서블릿, 필터에서 공유 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 서블릿과 필터에 공유 할 수 있도록 리스너를 설정 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">              org.springframework.web.context.ContextLoaderListener</span><br><span class="line">          <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">&lt;!-- Processes application requests --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">              <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!-- dispatcherServlet 생성 시, 서블릿 설정파일 로드 --&gt;</span></span><br><span class="line">                  /WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class="line">              <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">&lt;!-- dispatcherServlet 대한 url-pattern을 정의 </span></span><br><span class="line"><span class="comment">        /로 들어오는 모든 요청은 DispatcherServlet에서 처리 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="그래서-Context-설정은-어떻게-쓰냐"><a href="#그래서-Context-설정은-어떻게-쓰냐" class="headerlink" title="그래서 Context 설정은 어떻게 쓰냐?"></a>그래서 Context 설정은 어떻게 쓰냐?</h1><p>Spring에서 Application Context와 Servlet Context를 나누는 기준은 간단하다.</p><ul><li>Application Context<ul><li>공통 기능을 할 수 있는 Bean설정 (Datasource, Service 등..)</li><li>각 Servlet에서 공유할 수 있는 Bean</li></ul></li><li>Servlet Context<ul><li>Servlet 구성에 필요한 Bean 설정 (Controller, Interceptor, MappingHandler등..)</li></ul></li></ul><p>가장 중요한 게 Bean을 자동으로 scan하여 생성하는 component-scan이라고 생각된다.<br>각 applicationContext.xml과 servletContext.xml 파일을 설정한다고 가정하면 아래와 같이 설정 할 수 있다.</p><p>ApplicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.myapp.core, com.myapp.app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Component-scan대상에서 @Controller annotation Class는 제외한다. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Servlet-Context.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.myapp.app&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Component-scan대상은 @Controller annotation Class만 scan한다. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Servlet-Context.xml 설정 시, <code>use-default-filters</code> 속성을 <code>false</code>로 처리 하였다.<br><code>use-default-filters</code> 속성은 원래 <code>default가 true</code>인데,<br>@Compont Annotation(@Controller, @Service, @Repository등..) 의 <code>클래스를 자동으로 Bean으로 등록해 주는 filter속성</code>이다.<br>따라서 위의 필터를 false로 변경하고, scan할 대상에 대한 Annotation만 include-filter에 추가하였다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><ul><li><a href="http://hoonmaro.tistory.com/31">http://hoonmaro.tistory.com/31</a></li><li><a href="https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html">https://plus4070.github.io/nhn%20entertainment%20devdays/Web.xml.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> WAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IoC &amp; DI(2)</title>
      <link href="/2018/09/22/2018-09-21-spring-ioc-2/"/>
      <url>/2018/09/22/2018-09-21-spring-ioc-2/</url>
      
        <content type="html"><![CDATA[<h1 id="IoC란"><a href="#IoC란" class="headerlink" title="IoC란?"></a>IoC란?</h1><p>Inversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.<br>보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.<br>하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며<br>개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.</p><p>따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여<br>제어의 역전 (Inversion of Control)이라 불린다.</p><h1 id="Container가-도데체-뭐람"><a href="#Container가-도데체-뭐람" class="headerlink" title="Container가 도데체 뭐람?"></a>Container가 도데체 뭐람?</h1><p><img src="./containers.jpg" alt="containers"></p><p>개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다.<br>Spring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등.. Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까?<br>위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다.<br>이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.<br>컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는.. 컨테이너를 생각하는 것이 도움이 될 것 같다.<br>실제 프레임워크에서의 컨테이너도 같은 역할을 한다. </p><p><strong>이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체</strong>라고 할 수 있다. </p><p>위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면</p><p>서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,<br>외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.</p><p>Spring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.</p><h1 id="DI란"><a href="#DI란" class="headerlink" title="DI란?"></a>DI란?</h1><p>DI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.<br>DI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.<br>개념 자체는 <code>IoC의 형태 중 하나</code>라고 볼 수 있다.</p><p>DI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.<br>클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.</p><p>Spring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며<br>객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.</p><ol><li>Constructor Injection</li><li>Dependency Constructor Injection</li><li>Setter Injection</li><li>Field Injection</li></ol><h1 id="의존성-주입-Annotation"><a href="#의존성-주입-Annotation" class="headerlink" title="의존성 주입 Annotation"></a>의존성 주입 Annotation</h1><p>Spring&#x2F;Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.</p><ul><li>@Autowired<ul><li>Spring에서 지원하는 Annotation</li><li><code>Type</code>에 맞춰서 주입이 된다.</li><li>Interface에 상응하는 Bean이 2개 이상 인 경우에는 <code>@Qualifier(&quot;beanName&quot;)을 혼용</code>하여<br>필요한 Bean객체를 주입한다.</li></ul></li><li>@Inject<ul><li>Java에서 지원하는 Annotation</li><li><code>Type</code>에 맞춰서 주입이 된다.</li></ul></li><li>@Resource<ul><li>Java에서 지원하는 Annotation</li><li><code>이름</code>에 맞춰서 주입이 된다.</li></ul></li></ul><p>Spring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject&#x2F;@Resource를 사용하면 문제는 없을 것이나.. 대부분은 @Autowired를 사용한다.</p><h1 id="DI-구현방식"><a href="#DI-구현방식" class="headerlink" title="DI 구현방식"></a>DI 구현방식</h1><h2 id="Constructor-Injection"><a href="#Constructor-Injection" class="headerlink" title="Constructor Injection"></a>Constructor Injection</h2><p>생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.<br>이 방법은 xml 설정 시에 유용한 방법이다.<br>객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class UserService &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userRepository&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.user.UserRepository&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span>, <span class="attr">class</span>=<span class="string">&quot;com.example.user.UserService&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">construct-args</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;userRepository&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">construct-args</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Extension-Constructor-Injection"><a href="#Extension-Constructor-Injection" class="headerlink" title="Extension Constructor Injection"></a>Extension Constructor Injection</h2><p>Spring 4에 추가된 DI방법이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class UserService &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.<br>어찌보면 당연한 내용 같은데…  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> Class UserService &#123;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Setter-Injection"><a href="#Setter-Injection" class="headerlink" title="Setter Injection"></a>Setter Injection</h2><p>Setter를 통해 DI하는 방법이다.<br>이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class UserService &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">setUserRepository</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Field-Injection"><a href="#Field-Injection" class="headerlink" title="Field Injection"></a>Field Injection</h2><p>Spring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.<br>아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class UserService &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="용어-설명"><a href="#용어-설명" class="headerlink" title="용어 설명"></a>용어 설명</h1><ul><li>Bean<ul><li>Spring Container에 등록 되는 POJO객체 </li><li>Spring Application의 Component들이 등록 된다.</li><li>기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.</li></ul></li><li>Bean Factory<ul><li>Spring IoC를 담당하는 핵심 컨테이너</li><li>Bean에 대한 등록&#x2F;생성&#x2F;조회&#x2F;소멸을 관리한다.</li><li>BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.</li><li>대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)</li></ul></li><li>Application Context<ul><li>BeanFactory 인터페이스의 구현체 ()<ul><li>정확히는 ListableBeanFactory</li><li>Bean을 Listable하게 보관하는 인터페이스를 말한다.</li></ul></li><li>BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.<ul><li>ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.</li><li>ApplicationEventPublisher - 이벤트 발생을 관장한다.</li><li>MessageSource - properties파일을 통해 다국어 설정이 가능</li><li>BeanLifecycle - Bean의 초기화, 소멸을 담당한다.</li></ul></li></ul></li><li>Configuration Meta Data <ul><li>Application Context에서 IoC 설정을 위해 사용되는 메타정보</li><li>컨테이너에 어떤 기능을 세팅할때 사용</li><li>Bean 생성&#x2F;구성할 경우에도 사용</li><li>@Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능</li></ul></li></ul><h1 id="Bean-등록-방법"><a href="#Bean-등록-방법" class="headerlink" title="Bean 등록 방법"></a>Bean 등록 방법</h1><h2 id="Component-Scan"><a href="#Component-Scan" class="headerlink" title="Component-Scan"></a>Component-Scan</h2><p>Spring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.<br>Spring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.<br>분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에<br>불필요한 메모리 할당이 이루어질 수 있다.<br>그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 <code>가장 많이 하는 설정</code>이 아닐까 싶다.</p><ul><li>@Component 종류<ul><li>@Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)</li><li>@Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)</li><li>@Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)</li><li>@Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)</li></ul></li></ul><h2 id="Servlet-Context-xml"><a href="#Servlet-Context-xml" class="headerlink" title="Servlet-Context.xml"></a>Servlet-Context.xml</h2><p>기존 Bean 생성을 xml로 등록하는 방식이다.<br>이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만…<br>보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.<br>위에서 언급한 <code>Component-scan</code>을 주로 사용하는 것이 좋다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;beanNameViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>xml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.<br>뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.<br>Bean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 <code>@Bean</code> 어노테이션을 붙여주면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123; <span class="comment">//메소드 명이 기본적으로 Bean Name으로 추가된다.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우<br>아주 유용한 방법이라 할 수 있겠다.</p><h1 id="Bean-생명주기"><a href="#Bean-생명주기" class="headerlink" title="Bean 생명주기"></a>Bean 생명주기</h1><p>Spring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.<br>Bean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.</p><p>Bean 생명주기 처리를 하는 방법은 3가지 방식이 있다.</p><ol><li>InitializingBean, DisposableBean 인터페이스 구현</li><li>Bean정의 시 , 메소드 지정</li><li>@PostConstruct, @PreDestroy Annotation 사용</li></ol><h2 id="InitializingBean-DisposableBean-인터페이스-구현"><a href="#InitializingBean-DisposableBean-인터페이스-구현" class="headerlink" title="InitializingBean, DisposableBean 인터페이스 구현"></a>InitializingBean, DisposableBean 인터페이스 구현</h2><p>InitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시<br>기능을 확장 할 수 있다.</p><p>InitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에<br>Spring에 종속적이게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanClass</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection conn;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//자원의 할당 처리</span></span><br><span class="line">        conn = DBConnectionCaller.getConnection();</span><br><span class="line">        System.out.println(<span class="string">&quot;bean 생성 및 초기화 : afterPropertiesSet() 호출됨&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//주로 할당된 자원의 해제를 한다.</span></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>) conn.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;bean 소멸 : destroy 호출됨&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Bean정의-시-메소드-지정"><a href="#Bean정의-시-메소드-지정" class="headerlink" title="Bean정의 시 , 메소드 지정"></a>Bean정의 시 , 메소드 지정</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.TestBeanClass&quot;</span>                      </span></span><br><span class="line"><span class="tag">   <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>xml설정 파일 <bean>에서 <strong>init-method</strong> 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출</li><li>xml설정 파일 <bean>에서 <strong>destroy-method</strong> 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출</li></ul><h2 id="PostConstruct-PreDestroy-Annotation-사용"><a href="#PostConstruct-PreDestroy-Annotation-사용" class="headerlink" title="@PostConstruct, @PreDestroy Annotation 사용"></a>@PostConstruct, @PreDestroy Annotation 사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanClass</span> &#123;be</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection conn;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//자원의 할당 처리</span></span><br><span class="line">        conn = DBConnectionCaller.getConnection();</span><br><span class="line">        System.out.println(<span class="string">&quot;bean 생성 및 초기화&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//주로 할당된 자원의 해제를 한다.</span></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>) conn.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;bean 소멸&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@PostConstuct, @PreDestroy 은 <code>JSR-250 Annotation</code> 기반이다 (한마디로 자바기반)<br>따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.</p><p>@PostConstuct, @PreDestroy 을 사용하기 위해서는<br><code>&lt;annotation-config/&gt; </code>설정이나, <code>@AnnotationDrivenConfig </code>어노테이션을 붙여줘야 한다.</p><h1 id="Bean-Scope"><a href="#Bean-Scope" class="headerlink" title="Bean Scope"></a>Bean Scope</h1><p><a href="https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html">https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html</a> 을 참고함</p><ul><li>Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.</li><li>Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.</li><li>Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용</li><li>Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.<br>(이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)</li><li>Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다.</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p><a href="http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F">http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F</a><br><a href="http://wiki.javajigi.net/pages/viewpage.action?pageId=281">http://wiki.javajigi.net/pages/viewpage.action?pageId=281</a><br><a href="https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/">https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/</a><br><a href="https://okky.kr/article/415474">https://okky.kr/article/415474</a><br><a href="http://www.javajigi.net/pages/viewpage.action?pageId=68">http://www.javajigi.net/pages/viewpage.action?pageId=68</a><br><a href="http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1">http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1</a><br><a href="http://isstory83.tistory.com/91">http://isstory83.tistory.com/91</a><br><a href="https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3">https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3</a><br>토비의 스프링 VOL.2 Spring IoC</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IoC &amp; DI(1) - IoC 등장배경(과정)</title>
      <link href="/2018/09/21/2018-09-12-spring-ioc/"/>
      <url>/2018/09/21/2018-09-12-spring-ioc/</url>
      
        <content type="html"><![CDATA[<h1 id="IoC-등장배경"><a href="#IoC-등장배경" class="headerlink" title="IoC 등장배경"></a>IoC 등장배경</h1><p>IoC의 등장배경을 알기 위해서는 EJB나 Spring과 같은 프레임워크를 사용하기 이전 시대의 개발 방식에 대해 얘기를 해야한다.<br>온고지신(?)이라 하였던가.. IoC를 이해하기 위해 옛날이야기를 해보도록 하겠다.</p><p>태초에 Java로 만든 프로그램은 main()이라는 메소드에서 시작이 되었다.<br>main() 메소드 내에서 필요한 클래스를 개발자가 직접 코드내에서 생성하여 사용하였다.<br>어떠한 프로그램을 만들던지 간에 프로그램에는 <code>모델(Model)</code>이라는 개념이 생겨나게 된다.<br>이렇게 만들어진 클래스 간에서는 <code>관계(Relation)</code>과 <code>의존성(Dependency)</code>가 생기게 된다. </p><p><code>의존성이란?</code> A클래스에서 B클래스의 기능을 사용할 때 클래스A는 클래스B에 의존적이다 라고 하며<br>A –&gt; B 라고 표현한다 (UML에서는 클래스 간의 Dependency를 점선으로 표현한다.)<br>즉, B클래스의 기능이 변하게 되면 A클래스에도 영향이 생긴다는 말로 직역할 수 있다.</p><p>이해를 돕기위해 급식을 받는 학생에 대한 예제를 들어보겠다.<br>(이 학교는 아침&#x2F;점심&#x2F;저녁을 다 주는 좋은 학교이다)</p><h2 id="클래스-gt-클래스-호출-관계"><a href="#클래스-gt-클래스-호출-관계" class="headerlink" title="클래스 -&gt; 클래스 호출 관계"></a>클래스 -&gt; 클래스 호출 관계</h2><p><img src="./image-20180921143924788.png" alt="image-20180921143924788"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Restaurant</span> <span class="variable">restaurant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Restaurant</span>();</span><br><span class="line">        <span class="comment">//식사 시작</span></span><br><span class="line">        restaurant.eatBreakfast();</span><br><span class="line">        restaurant.eatLunch();</span><br><span class="line">        restaurant.eatDinner();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Restaurant</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eatBreakfast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Breakfast</span> <span class="variable">breakfast</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Breakfast</span>();</span><br><span class="line">        System.out.println(breakfast.getInfo() + <span class="string">&quot;을 먹었습니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eatLunch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Lunch</span> <span class="variable">lunch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lunch</span>();</span><br><span class="line">        System.out.println(lunch.getInfo() + <span class="string">&quot;을 먹었습니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eatDinner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Dinner</span> <span class="variable">dinner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dinner</span>();</span><br><span class="line">        System.out.println(dinner.getInfo() + <span class="string">&quot;을 먹었습니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student 클래스는 밥을 먹기위해 Restaurant클래스를 new로 생성하였다.<br>Restaurant클래스 내에서는 아침&#x2F;점심&#x2F;저녁을 먹을 수 있도록 각각 Breakfast, Lunch, Dinner클래스를 new로 생성하였다.<br>위의 의존성에 대해 위 예제를 풀어보면 Student는 Restaurant에 대해 의존적이다. (Student —&gt; Restaurant)<br>Student클래스에서 Restaurant클래스를 생성하여 밥을 먹기 때문이다. 만약에 Restaurant 클래스에서 밥을 못먹게 하면<br>Student클래스는 정상적으로 밥을 먹는 기능을 수행할 수 없다.<br>Restaurant클래스는 Breakfast&#x2F;Lunch&#x2F;Dinner에 대해 의존적이다.<br>각각의 메소드에서 Breakfast&#x2F;Lunch&#x2F;Dinner클래스를 생성하여 밥을 먹는 행위를 하도록 하고있다.</p><p>가만히 보게 되면 의존성에 대한 공통점을 발견할 수 있다.<br>그것은 바로 <code>new</code>이다. <code>클래스 내에서의 new는 곧 의존성을 의미</code>하게 된다. new로 생성한 클래스가 문제가 생기면 사용을 하는 클래스의 기능에도 문제가 생기기 떄문이다.</p><p>따라서 <strong>프로그래밍의 의존성은 new이다</strong> 로 간단하게 정의를 내릴 수 있겠다.</p><h2 id="클래스-gt-인터페이스-interface-gt-클래스-구조"><a href="#클래스-gt-인터페이스-interface-gt-클래스-구조" class="headerlink" title="클래스 -&gt; 인터페이스(interface) -&gt; 클래스 구조"></a>클래스 -&gt; 인터페이스(interface) -&gt; 클래스 구조</h2><p>클래스 내에서 클래스를 생성하여 호출 하는 경우에는 변경에 많은 비용이 발생하게 된다.<br>만약에 학교에서 야식까지 먹어가며 밤을 새는 경우에는 야식이라는 의존성을 또 추가하게 된다.<br>뿐만 아니라 Breakfast&#x2F;Lunch&#x2F;Dinner 클래스에 변경이 생기는 경우에도 Restaurant 클래스는 영향을 받게 된다.</p><p>이와 같은 문제를 쪼금 더 편하게 해결 할 수 있게 Java에서는 interface라는게 있다.<br>(개인적으로 Service나 Repository 같은 클래스들을 생성 할 때 웬만하면 interface를 선언하는 편이다.)</p><p>차후에 Mock객체 생성하기도 좋고, 요구사항이 변경 되었을 때 유연하게 대응 할 수 있어 개인적으로는 Interface를 자주 사용하는 편이다.</p><p>Breakfast&#x2F;Lunch&#x2F;Dinner클래스를 자세히 보면… getInfo() 메소드가 공통적으로 쓰이고 있다.<br>(getInfo메소드는 식단에 대한 정보이다.)<br>따라서 하나의 interface로 Breakfast&#x2F;Lunch&#x2F;Dinner클래스를 추상화 할 수 있다.<br>그렇게 되면 eat이라는 메소드 하나만으로도 아침~저녁을 먹을 수 있는 기능을 구현할 수 있다.<br>위에서 말로 한 얘기를 코드로 풀어보면..</p><p><img src="./image-20180921145310488.png" alt="image-20180921145310488"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Restaurant</span> <span class="variable">restaurant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Restaurant</span>();</span><br><span class="line">        <span class="comment">//식사 시작</span></span><br><span class="line">        restaurant.eat(<span class="keyword">new</span> <span class="title class_">Breakfast</span>());</span><br><span class="line">        restaurant.eat(<span class="keyword">new</span> <span class="title class_">Lunch</span>());</span><br><span class="line">        restaurant.eat(<span class="keyword">new</span> <span class="title class_">Dinner</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Eatable</span>() &#123;</span><br><span class="line">String <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Restaurant</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Eatable eatable)</span> &#123;</span><br><span class="line">        System.out.println(eatable.getInfo() + <span class="string">&quot;을 먹었습니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 클래스 -&gt; 클래스 간의 Dependency 구조보다는 interface를 사용하므로써 많이 결합도가 완화된 모습이다.<br>이전에는 Restaurant 클래스가 Break&#x2F;Lunch&#x2F;Dinner에 대해 모두 Dependency를 가지고 가는 구조여서 결합도가 강한 형태였는데, interface를 사용하여 결합도를 많이 약화 시켰다.</p><p>자세히 보면 <code>Student클래스에서 Break/Lunch/Dinner를 생성하여 Restaurant에 주입</code>해 주었다.<br>이러한 모습이 향후 DI의 개념과 비슷한 개념으로 발전하게 된다.<br>Restaurant입장에서는 개발자가 생성한 객체가 아닌 <code>외부로 부터 주입받은 형태</code>로 Break&#x2F;Lunch&#x2F;Dinner에 대해 사용을 하기 때문이다.<br>이 부분을 잘 이해하면 차후 IoC와 DI를 이해하는데 크게 도움이 된다.</p><h2 id="클래스-gt-팩토리-factory-패턴"><a href="#클래스-gt-팩토리-factory-패턴" class="headerlink" title="클래스 -&gt; 팩토리(factory) 패턴"></a>클래스 -&gt; 팩토리(factory) 패턴</h2><p>디자인 패턴 중에는 팩토리(Factory) 패턴이라는 구현 방식이 있다.<br>팩토리 패턴에 대해 간단하게 설명하자면, 객체의 상태(State) 또는 구분자(Type)을 통해 필요한 객체를 Return 해주는 패턴이다. 위에서 설명한 클래스 -&gt; 인터페이스 방식을 차용하여 한 단계 더 Wrapping한 개념이라고 생각하면 편하다.<br>팩토리 패턴을 이용하면 아예 <code>개발자에게 객체 생성에 대한 권한을 주지 않겠다! </code>를 구현 할 수 있게 된다.<br><strong>개발자가 객체 생성을 직접 하지 않고도 시스템에 요청하여 원하는 객체를 얻어낼 수 있다.</strong> &lt;– 이 내용은 DL(Dependency Lookup)과 비슷한 개념으로 통할 수 있을 것 같다.</p><p>팩토리 패턴으로 만든 코드를 만들게 된다면, 아래와 같이 만들 수 있을 것이다.</p><p><img src="./image-20180921153027741.png" alt="image-20180921153027741"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Restaurant</span> <span class="variable">restaurant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Restaurant</span>();</span><br><span class="line">        <span class="comment">//식사 시작</span></span><br><span class="line">        restaurant.eat(EatFactory.get(Meal.BREAKFAST));</span><br><span class="line">        restaurant.eat(EatFactory.get(Meal.LUNCH));</span><br><span class="line">        restaurant.eat(EatFactory.get(Meal.DINNER));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Meal</span> &#123;</span><br><span class="line">   BREAKFAST, LUNCH, DINNER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EatFactory</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Eatable <span class="title function_">get</span><span class="params">(Meal meal)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(meal) &#123;</span><br><span class="line">            <span class="keyword">case</span> BREAKFAST : <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Breakfast</span>();</span><br><span class="line">            <span class="keyword">case</span> LUNCH : <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Lunch</span>();</span><br><span class="line">            <span class="keyword">case</span> DINNER : <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dinner</span>();</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Not using Meal Type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Eatable</span>() &#123;</span><br><span class="line">String <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Restaurant</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Eatable eatable)</span> &#123;</span><br><span class="line">        System.out.println(eatable.getInfo() + <span class="string">&quot;을 먹었습니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 개발자가 개발하는 코드에서 Breakfast&#x2F;Lunch&#x2F;Dinner에 대한 Dependency는 완전히 제거 되었다.<br>야식이라는 식사 메뉴가 추가되어도 Meal enum에 야식 항목을 추가하고, EatFactory에 야식에 대한 case만 추가 해 주면<br>Student 클래스는 유연하게 추가된 기능에 대해 대처가 가능하다.</p><h2 id="IoC-패턴"><a href="#IoC-패턴" class="headerlink" title="IoC 패턴"></a>IoC 패턴</h2><p>IoC패턴을 알기 전에 IoC에 대해 간단히 설명하자면..<br>기능을 담당하는 POJO class를 프로그램 시작 시, IoC 컨테이너에 Bean이라는 이름으로 객체를 생성해 둔다.<br>이렇게 싱글톤으로 생성된 객체들을 필요한 시점에 IoC 컨테이너에서 의존성을 가지는 객체에 직접 주입을 해주는 패턴을 IoC패턴이라 한다.</p><p>쉽게 말하면 객체의 멤버에 대한 상태가 없고(stateless) 기능의 역할을 담은 클래스들을 1개씩 IoC컨테이너라는 상자에 담아두고, 의존성 객체가 필요한 경우 IoC컨테이너에서 필요한 객체를 주입해준다. 라고 생각하면 편할 것 같다.<br>객체에 대해 new 생성자를 통해 객체를 생성할 필요가 없으니, 메모리적인 낭비가 없다는 장점이 있을 뿐 더러 개발자에게 객체 관리에 대한 미시적인 역할을 맡기지 않아도 되는 장점이 있다. 자세한 내용은 다음 장에 기술하도록 하겠다.</p><p>위의 내용을 Spring을 사용한 개발이라고 한다면… 아래와 같이 코드를 짤 수 있겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &quot;com.example.ioc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Restaurant restaurant;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EatFactory eatFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">SpringApplication.run(SpringStudyApplication.class, args);</span><br><span class="line">        <span class="comment">//식사 시작</span></span><br><span class="line">        restaurant.eat(eatFactory.get(Meal.BREAKFAST));</span><br><span class="line">        restaurant.eat(eatFactory.get(Meal.LUNCH));</span><br><span class="line">        restaurant.eat(eatFactory.get(Meal.DINNER));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Meal</span> &#123;</span><br><span class="line">   BREAKFAST, LUNCH, DINNER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EatFactory</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;breakfast&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Eatable breakfast;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;lunch&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Eatable lunch;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;dinner&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Eatable dinner;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Eatable <span class="title function_">get</span><span class="params">(Meal meal)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(meal) &#123;</span><br><span class="line">            <span class="keyword">case</span> BREAKFAST : breakfast;</span><br><span class="line">            <span class="keyword">case</span> LUNCH : lunch;</span><br><span class="line">            <span class="keyword">case</span> DINNER : dinner;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Not using Meal Type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Eatable</span>() &#123;</span><br><span class="line">String <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Restaurant</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Eatable eatable)</span> &#123;</span><br><span class="line">        System.out.println(eatable.getInfo() + <span class="string">&quot;을 먹었습니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring에서는 component-scan이라는 기능을 통해 @Component 어노테이션이 붙은 클래스는 IoC 컨테이너에 Bean으로써 자동 등록 해준다. 이러한 Bean은 @Autowired &#x2F; @Inject 와 같은 어노테이션을 통해 클래스에 주입을 해줄 수 있다.<br>이렇게 되면 개발자가 new를 통해 의존성을 강제화 하지 않고 프레임워크가 이 역할을 대신 수행해 준다.</p><p>개발자가 객체 생성과 의존성 주입에 대한 역할을 대신 해준다<br>Inversion of Control (객체 관리과 의존성 관리를 시스템에서 해준다 : 제어의 역전) 이라고 불리게 되었다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p><a href="http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F">http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F</a><br><a href="http://wiki.javajigi.net/pages/viewpage.action?pageId=281">http://wiki.javajigi.net/pages/viewpage.action?pageId=281</a><br><a href="https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/">https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/</a><br><a href="https://okky.kr/article/415474">https://okky.kr/article/415474</a><br><a href="http://www.javajigi.net/pages/viewpage.action?pageId=68">http://www.javajigi.net/pages/viewpage.action?pageId=68</a><br><a href="http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1">http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1</a><br><a href="http://isstory83.tistory.com/91">http://isstory83.tistory.com/91</a><br>토비의 스프링 VOL.2 Spring IoC</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet이란?</title>
      <link href="/2018/09/01/2018-09-01-servlet/"/>
      <url>/2018/09/01/2018-09-01-servlet/</url>
      
        <content type="html"><![CDATA[<p><img src="./servlet.png" alt="servlet"></p><h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, “이렇게 코딩하면 이렇게 동작하네<del>“ 라는 생각만 가지고 개발을 해왔었다. 근 1</del>2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 “이게 이래서 이렇게 동작하는구나~” 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.</p><p>최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.</p><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Servlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데… 이제와서 알아보게 되었다.</p><p>Servlet의 정의에 대해 찾아보게 되었다. (출처 : <a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF">wikipedia</a>)</p><blockquote><p>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 “서블릿”이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.</p></blockquote><p>결국은 <code>웹 서버에서 돌아가는 Java 코드</code>라는 뜻이다.<br>Java 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.<br><code>HttpServlet</code> 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.</p><h2 id="Servlet의-특징"><a href="#Servlet의-특징" class="headerlink" title="Servlet의 특징"></a><strong>Servlet의 특징</strong></h2><ul><li>Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술</li><li>흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.</li><li>클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.</li><li>Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.<br>(doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)</li><li>클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다.<br>(WAS 내의 Thread pool의 Thread 객체를 이용한다.)</li><li>Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다<br>(내부적으로 Sington을 구현하고 있지는 않다고한다.)<br>여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.</li><li>요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.<br>(오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)</li><li>MVC에서 컨트롤러로 이용됨..</li></ul><h1 id="Servlet-Container"><a href="#Servlet-Container" class="headerlink" title="Servlet Container"></a>Servlet Container</h1><p>Servlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?<br>당연히 있다. WAS라고 불리우는 프로그램이 있다.<br>Java 진영에서 자주 사용하는 WAS는 단연 으뜸으로 <code>Apache Tomcat</code>이 있다.<br>(다른거로는 <code>Jeus</code>나, <code>jBoss</code> 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)</p><p>WAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.</p><ul><li><p>Web Server (apache, nginx)와의 통신 지원</p><ul><li>클라이언트 요청(Request)에 대한 Socket 통신 지원</li></ul></li><li><p>Servlet Lifecycle 관리</p></li><li><p>Client 접근 URL에 대한 Servlet Mapping </p></li><li><p>클라이언트 요청(Request)에 대한 멀티 스레드 관리</p></li><li><p>선언적인 보안관리</p><ul><li>보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.</li><li>Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문</li><li>DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.<br>대표적인 예로 Spring Security가 있다.</li></ul></li></ul><h1 id="Servlet-LifeCycle"><a href="#Servlet-LifeCycle" class="headerlink" title="Servlet LifeCycle"></a>Servlet LifeCycle</h1><p><img src="./Servlet-life-cycle.png" alt="Servlet-life-cycle"></p><p>Servlet의 LifeCycle은 3단계로 이루어 진다.</p><ul><li>init() <ul><li>WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.</li><li>주로 Servlet 객체에 대한 초기화 로직을 작성한다.</li><li>실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고<br>다시 서블릿 생성과 동시에 init()이 실행</li></ul></li><li>service()<ul><li>Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.<br>(doGet(), doPost(), doPut(), doDel())</li></ul></li><li>destroy()<ul><li>WAS shutdown 시 호출 된다.</li><li>주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다</li><li>자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.</li></ul></li></ul><h1 id="Servlet-설정하기"><a href="#Servlet-설정하기" class="headerlink" title="Servlet 설정하기"></a>Servlet 설정하기</h1><h2 id="Servlet-class-생성하기"><a href="#Servlet-class-생성하기" class="headerlink" title="Servlet class 생성하기"></a>Servlet class 생성하기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.demo3.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebServlet(name=&quot;demoServlet&quot;, url-pattern=&quot;/servlet/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;doGet() 실행실행실행!!!&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        log.info(<span class="string">&quot;Thread ID : &quot;</span> + thread.getId());</span><br><span class="line">        <span class="built_in">super</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Servlet destroy()&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Servlet init()&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.<br>(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)</p><p>기본적으로 Servlet 클래스 생성은 <code>HttpServlet</code> 클래스를 상속 받아 생성한다.<br>HttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.</p><h2 id="web-xml-기반-설정"><a href="#web-xml-기반-설정" class="headerlink" title="web.xml 기반 설정"></a>web.xml 기반 설정</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.springstudy.demo3.servlet.DemoServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/demo<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>web.xml에 servlet 클래스를 선언하고 <servlet-mapping> 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.</p><h2 id="Java-Config-기반-설정"><a href="#Java-Config-기반-설정" class="headerlink" title="Java Config 기반 설정"></a>Java Config 기반 설정</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.demo3.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.demo3.servlet.DemoServlet;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServletConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">demoServletRegistrationBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServletRegistrationBean</span> <span class="variable">demoServletRegistrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>();</span><br><span class="line">        demoServletRegistrationBean.setServlet(<span class="keyword">new</span> <span class="title class_">DemoServlet</span>());</span><br><span class="line">        demoServletRegistrationBean.addUrlMappings(<span class="string">&quot;/servlet/demo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> demoServletRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.<br>ServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.</p><h1 id="JSP-vs-Servlet"><a href="#JSP-vs-Servlet" class="headerlink" title="JSP vs Servlet"></a>JSP vs Servlet</h1><p><strong>JSP와 Servlet의 차이점</strong></p><ul><li>JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태</li><li>Servlet은 html 태그가 out.println(“<html>“) 형태로 들어간 형태</li></ul><h2 id="JSP-gt-Servlet-변환-과정"><a href="#JSP-gt-Servlet-변환-과정" class="headerlink" title="JSP -&gt; Servlet 변환 과정"></a>JSP -&gt; Servlet 변환 과정</h2><p><img src="./jspToServlet.jpeg" alt="jspToServlet"></p><p>Servlet의 최종 형태는 out.println(“<html>“) 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p><a href="http://mangkyu.tistory.com/14">http://mangkyu.tistory.com/14</a><br><a href="http://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">http://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80</a><br><a href="http://til0804.tistory.com/25">http://til0804.tistory.com/25</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> J2EE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Handle Exception</title>
      <link href="/2018/08/30/2018-08-25-spring-mvc-handle-exception/"/>
      <url>/2018/08/30/2018-08-25-spring-mvc-handle-exception/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>Spring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.<br>Dispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.<br>Spring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.</p><h1 id="예외-Exception-처리는-어떻게"><a href="#예외-Exception-처리는-어떻게" class="headerlink" title="예외(Exception) 처리는 어떻게?"></a>예외(Exception) 처리는 어떻게?</h1><p>Spring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.</p><ol><li>Controller 레벨에서 처리</li><li>Global 레벨에서 처리</li><li>HandlerExceptionResolver를 이용한 처리</li></ol><h1 id="Controller-레벨에서의-처리"><a href="#Controller-레벨에서의-처리" class="headerlink" title="Controller 레벨에서의 처리"></a>Controller 레벨에서의 처리</h1><p>Spring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.<br><code>@ExceptionHandler</code> 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.</p><p>예제 코드</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.demo2.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(path=&quot;/exception/demo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">occurDemoException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DemoException</span>(); <span class="comment">//occur DemoException (RuntimeException)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(path=&quot;/exception/demo2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">occurDemoException2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DemoException</span>(); <span class="comment">//occur DemoException (RuntimeException)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value=DemoException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleDemoException</span><span class="params">(DemoException e)</span> &#123;</span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/error/404&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DemoController내에서 발생한 DemoException에 대해서는 <code>handleDemoException</code> 메소드에서 모두 처리를 해준다.</p><ul><li>Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면<code> @ExceptionHandler</code> 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.</li><li>Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.</li></ul><p>Spring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.</p><h1 id="Global-레벨에서의-처리"><a href="#Global-레벨에서의-처리" class="headerlink" title="Global 레벨에서의 처리"></a>Global 레벨에서의 처리</h1><p>만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?<br>위의 방식 처럼 Controller 별로 <code>@ExceptionHandler</code> 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.<br>Spring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.</p><ul><li><code>@ControllerAdvice</code> - Exception 처리 후 Error Page등을 통해 처리가 가능하다.</li><li><code>@RestControllerAdvice</code><ul><li>REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)</li><li>@RestControllerAdvice &#x3D; @ControllerAdvice + @ResponseBody</li></ul></li></ul><p>위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.</p><p><strong>주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!</strong></p><p>예제 코드</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoControllerAdvisor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = DemoException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleDemoExceptionForGlobal</span><span class="params">(DemoException e)</span> &#123;</span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/error/404&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="여기서-궁금한-점…"><a href="#여기서-궁금한-점…" class="headerlink" title="여기서 궁금한 점…"></a>여기서 궁금한 점…</h2><p>Controller 클래스 내에 <code>@ExceptionHandler</code>, <code>@ControllerAdvice</code> 클래스 내의 <code>@ExceptionHandler</code> 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?</p><p>실험을 해보았다.<br>준비물은 아래와 같다.</p><ol><li>DemoException을 throw하는 DemoController1, DemoController2</li><li>DemoController1에서는 DemoException에 대해 <code>@ExceptionHandler</code>를 구현하였다.</li><li>DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.</li><li>전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고<br><code>@ExceptionHandler</code>를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.</li></ol><h3 id="Test-Case"><a href="#Test-Case" class="headerlink" title="Test-Case"></a>Test-Case</h3><ol><li>DemoController1 -&gt; throw DemoException</li><li>DemoController2 -&gt; throw DemoException</li></ol><h3 id="어떤-결과가-나왔을까"><a href="#어떤-결과가-나왔을까" class="headerlink" title="어떤 결과가 나왔을까?"></a>어떤 결과가 나왔을까?</h3><ol><li><p>DemoController1 -&gt; throw DemoException</p><ul><li>예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.</li><li>예외처리가 끝난 후 404페이지가 리턴 되었다.</li><li><code>@ControllerAdvice내의 @ExceptionHandler</code>는 실행 되지 않았다.</li></ul><p><strong>&#x3D;&gt; <strong>@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.</strong><br>     더 상위로 Exception을 throw하더라도 <code>@ControllerAdvice의 @ExceptionHandler</code>에서 예외처리를 하지 않는다.</strong></p></li><li><p>DemoController2 -&gt; throw DemoException</p><ul><li>예상대로 DemoControllerAdvice 내의 <code>@ExceptionHandler</code> 메소드에서 예외처리가 되었다.</li><li>DemoController2에는 <code>@ExceptionHandler</code>가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.</li></ul></li></ol><h1 id="HandlerExceptionResolver를-이용한-처리"><a href="#HandlerExceptionResolver를-이용한-처리" class="headerlink" title="HandlerExceptionResolver를 이용한 처리"></a>HandlerExceptionResolver를 이용한 처리</h1><p>HandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.<br><code>DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것</code>이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.<br>(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)</p><p>HandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, <span class="meta">@Nullable</span> Object var3, Exception var4)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.<br>사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.<br>Spring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.</p><p>Dispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.</p><ol><li>ExceptionHandlerExceptionResolver</li><li>ResponseStatusExceptionResolver</li><li>DefaultHandlerExceptionResolver</li></ol><p>순으로 Resolver가 실행된다.</p><p><img src="./image-20180831234615081.png" alt="image-20180831234615081"></p><h2 id="ExceptionHandlerExceptionResolver"><a href="#ExceptionHandlerExceptionResolver" class="headerlink" title="ExceptionHandlerExceptionResolver"></a>ExceptionHandlerExceptionResolver</h2><p>Spring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.<br>위에서 사용한 <code>@ExceptionHandler</code> 어노테이션에 대한 Resolver 클래스이다.</p><h2 id="ResponseStatusExceptionResolver"><a href="#ResponseStatusExceptionResolver" class="headerlink" title="ResponseStatusExceptionResolver"></a>ResponseStatusExceptionResolver</h2><p>ResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다.<br>특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.</p><p>사용 예제 (@ExceptionHandler와 함께 사용)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.</span></span><br><span class="line"><span class="comment">//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.</span></span><br><span class="line"><span class="meta">@ResponseStatus(value = HttpStatus.FORBIDDEN, reason = &quot;Permission Denied&quot;)</span></span><br><span class="line"><span class="meta">@ExceptionHandler(value=DemoException.class)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handleDemoException</span><span class="params">(DemoException e)</span> &#123;</span><br><span class="line">    log.error(e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/error/403&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./image-20180831235454808.png" alt="image-20180831235454808"></p><p>위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.<br>(403에 대한 페이지는 못만들었다 ^^;)</p><h2 id="DefaultHandlerExceptionResolver"><a href="#DefaultHandlerExceptionResolver" class="headerlink" title="DefaultHandlerExceptionResolver"></a>DefaultHandlerExceptionResolver</h2><p>DispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 <code>DefaultHandlerExceptionResolver</code>에서 예외처리를 해준다.</p><p>DefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.<br>각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다. </p><ul><li>Request URL에 맞는 Controller를 못찾는 경우 &#x3D;&#x3D;&gt; 404 Not Found</li><li>Controller 메소드 실행 중 예외가 발생하는 경우 &#x3D;&#x3D;&gt; 500 Internal Server error</li><li>Controller의 파라미터 형식이 잘못된 경우 &#x3D;&#x3D;&gt; 400 Bad Request</li></ul><h2 id="SimpleMappingExceptionResolver"><a href="#SimpleMappingExceptionResolver" class="headerlink" title="SimpleMappingExceptionResolver"></a>SimpleMappingExceptionResolver</h2><p>SimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.<br>Exception별로 error-page를 매핑할 수 있는 기능을 제공한다.</p><p>설정방법은 2가지로 설명하도록 하겠다.</p><ol><li>Java config 방식</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> WebMvcConfig <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(name=“customMappingExceptionResolver”)</span></span><br><span class="line">    <span class="keyword">public</span> SimpleMappingExceptionResolver <span class="title function_">customMappingExceptionResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SimpleMappingExceptionResolver</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">mappings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        mappings.setProperty(<span class="string">&quot;DatabaseException&quot;</span>, <span class="string">&quot;databaseError&quot;</span>);</span><br><span class="line">        mappings.setProperty(<span class="string">&quot;DemoException&quot;</span>, <span class="string">&quot;demoError&quot;</span>);</span><br><span class="line"></span><br><span class="line">        r.setExceptionMappings(mappings);  </span><br><span class="line">        r.setDefaultErrorView(<span class="string">&quot;default-error-page&quot;</span>);    </span><br><span class="line">        r.setExceptionAttribute(<span class="string">&quot;ex&quot;</span>);     </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>xml 방식</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;simpleMappingExceptionResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;DatabaseException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;databaseError&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;DemoException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;demoError&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultErrorView&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.<br>근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?</p><h1 id="다시-한번-Spring-MVC를-보자-자꾸-보게되네"><a href="#다시-한번-Spring-MVC를-보자-자꾸-보게되네" class="headerlink" title="다시 한번 Spring MVC를 보자 (자꾸 보게되네?)"></a>다시 한번 Spring MVC를 보자 (자꾸 보게되네?)</h1><p><img src="./spring-mvc-request.jpg" alt="spring-mvc-request"></p><p>Spring MVC의 대한 처리는 99프로가 <code>Dispatcher Servlet</code>에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.<br>하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 <code>HandlerExceptionResolver</code>의 처리를 받을 수 없다. 이럴때는 어떡할건가?<br>지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.</p><h1 id="Filter에서-예외가-발생하면"><a href="#Filter에서-예외가-발생하면" class="headerlink" title="Filter에서 예외가 발생하면?"></a>Filter에서 예외가 발생하면?</h1><p>filter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.</p><p>Filter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.</p><ul><li>web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현</li><li>Filter 내부에서 try-catch 구문을 통해 예외 발생 시, <code>request.getRequestDispatcher(String)</code>를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.<br>(웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.<br> Interceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)</li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p><a href="https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc">https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc</a><br><a href="https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver">https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver</a><br><a href="http://www.nextree.co.kr/p3239/">http://www.nextree.co.kr/p3239/</a><br><a href="http://springsource.tistory.com/7">http://springsource.tistory.com/7</a><br><a href="http://stewie38.tistory.com/59">http://stewie38.tistory.com/59</a><br><a href="https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/">https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Exception</title>
      <link href="/2018/08/29/2018-08-29-java-exception/"/>
      <url>/2018/08/29/2018-08-29-java-exception/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>Java&#x2F;Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.<br>예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.<br>이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.</p><h1 id="에러-Error-와-예외-Exception"><a href="#에러-Error-와-예외-Exception" class="headerlink" title="에러(Error)와 예외(Exception)"></a>에러(Error)와 예외(Exception)</h1><p><img src="./Exception-Class.png" alt="Exception-Class"></p><p>Java에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.<br>Exception은 또 2가지 종류로 구분 할 수 있다.</p><ul><li>Error <ul><li>주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.</li><li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li><li>주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.</li><li>관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.<br>(어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)</li></ul></li><li>Checked Exception <ul><li>점검지정 예외</li><li>Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.</li><li>예외처리를 하지 않을 시, <code>컴파일 오류가 발생</code></li><li>주로 <code>복구 가능한 상황</code>에 Checked Exception을 사용한다.</li><li>Custom Checked Exception을 만들 경우 <code>Exception</code> 클래스를 상속하여 만든다.</li></ul></li><li>Unchecked Exception<ul><li>무점검 예외</li><li>프로그래밍 오류를 표현하는 경우 사용</li><li>개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.</li><li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li><li>Custom Unchecked Exception을 만들 경우 <code>RuntimeException</code> 클래스를 상속하여 만든다</li></ul></li></ul><h2 id="추가적으로"><a href="#추가적으로" class="headerlink" title="추가적으로.."></a>추가적으로..</h2><p>개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.<br>아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.<br>Checked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.<br>지원자가 했던 “Checked Exception 절대 쓰지 말자!” “Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!”라는 의견도 어느정도는 맞는 소리이다.<br>새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의….로 간다고 하면 밑에서 부터 계속 throw..throw.. 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다.<br>다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.</p><h1 id="Java에서의-기본적인-예외처리"><a href="#Java에서의-기본적인-예외처리" class="headerlink" title="Java에서의 기본적인 예외처리"></a>Java에서의 기본적인 예외처리</h1><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h2><p>try-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.<br>프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//핵심 로직 수행</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">//예외 발생 시, 예외에 대한 처리</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="comment">//try block, catch block 실행 후 반드시 실행하는 로직</span></span><br><span class="line">   <span class="comment">//주로 자원에 대한 해제 로직이 추가된다. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-catch-resources"><a href="#try-catch-resources" class="headerlink" title="try-catch-resources"></a>try-catch-resources</h2><p>Java 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123; </span><br><span class="line">     <span class="comment">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class="line">     <span class="comment">//핵심 로직 수행</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">//예외 발생 시, 예외에 대한 처리</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Multi-catch"><a href="#Multi-catch" class="headerlink" title="Multi catch"></a>Multi catch</h2><p>Java 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123; </span><br><span class="line">     <span class="comment">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class="line">     <span class="comment">//핵심 로직 수행</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException | ArrayIndexBoundException e) &#123;</span><br><span class="line">    <span class="comment">//예외 발생 시, 예외에 대한 처리</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Exception-Handling"><a href="#Exception-Handling" class="headerlink" title="Exception Handling"></a>Exception Handling</h1><p>Checked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.</p><ul><li>Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기</li><li>try-catch구문을 통한 예외처리를 하도록 유도</li></ul><p>보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.<br>하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.</p><h1 id="Anti-Pattern"><a href="#Anti-Pattern" class="headerlink" title="Anti Pattern"></a>Anti Pattern</h1><ol><li>Exception을 무시 하지 말 것</li><li>exception.printStackTrace()는 쓰는게 아니다.</li><li>반복문 내에서는 Checked Exception에 대한 처리는 지양하자</li></ol><h2 id="Exception을-무시-하지-말-것"><a href="#Exception을-무시-하지-말-것" class="headerlink" title="Exception을 무시 하지 말 것"></a>Exception을 무시 하지 말 것</h2><p>간혹 코드를 보다 보면..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//열심히 작성</span></span><br><span class="line">    veryHardDo();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">//아무것도 안해요~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고.. 막상 catch구문에 작성할 코드는 없어보이고… 할 때 저런 코드들이 나오게 된다.<br>이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고.. 왜 에러나는지 모르는 코드가 되어버린다.<br>되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자.. (로그라도 남겨줘 ㅜㅜ)</p><h2 id="exception-printStackTrace-는-쓰는게-아니다"><a href="#exception-printStackTrace-는-쓰는게-아니다" class="headerlink" title="exception.printStackTrace()는 쓰는게 아니다."></a>exception.printStackTrace()는 쓰는게 아니다.</h2><p>exception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)<br>하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.</p><h2 id="반복문-내에서는-Checked-Exception에-대한-처리는-지양하자"><a href="#반복문-내에서는-Checked-Exception에-대한-처리는-지양하자" class="headerlink" title="반복문 내에서는 Checked Exception에 대한 처리는 지양하자"></a>반복문 내에서는 Checked Exception에 대한 처리는 지양하자</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String item : items) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        insert(item);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.<br>이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.</p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p>Effective Java 2nd Edition (Joshua Bloch)<br>가장 빨리 만나는 자바8 (카이 호스트만)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Filter와 Interceptor</title>
      <link href="/2018/08/25/2018-08-18-spring-filter-interceptor/"/>
      <url>/2018/08/25/2018-08-18-spring-filter-interceptor/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며.."></a>들어가며..</h1><p>개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다.<br>회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.<br>Filter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.</p><h1 id="Spring-Request-Flow"><a href="#Spring-Request-Flow" class="headerlink" title="Spring Request Flow"></a>Spring Request Flow</h1><p><img src="./spring-request-lifecycle.jpg" alt="spring-request-lifecycle"></p><p>이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.<br>(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)</p><p>그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.<br>Filter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 <code>J2EE 표준스펙</code>이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다. </p><p>Interceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.<br>따라서 Interceptor는 <code>Spring Framework에서 제공하는 API</code>이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.</p><h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><p>위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.<br>실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 <code>Spring Security, CORS Filter</code>등이 있다.</p><h2 id="Filter-Chain"><a href="#Filter-Chain" class="headerlink" title="Filter Chain"></a>Filter Chain</h2><p><img src="./filter-chain.gif" alt="filter-chain"></p><p>Filter의 큰 특징으로는 Filter chain이라는 개념이 있다.<br>실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 <code>Standard Context</code>에 <code>FilterMap</code>이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 <code>Filter chain</code>을 구성하게 되어 순차적으로 실행 되게 된다. </p><ul><li><a href="https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705">Request에 대한 Filter Chain 생성</a></li><li><a href="https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53">Request URL에 대한 FilterMap 생성</a></li></ul><p>※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.</p><p>Filter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.</p><ol><li>url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li><li>servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li></ol><h2 id="Filter-생성"><a href="#Filter-생성" class="headerlink" title="Filter 생성"></a>Filter 생성</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="comment">//filter 생성 시 처리</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//다음 Filter 실행 전 처리 (preHandle)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)</span></span><br><span class="line">filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//다음 Filter 실행 후 처리 (postHandle)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="설정-방법"><a href="#설정-방법" class="headerlink" title="설정 방법"></a>설정 방법</h2><p>Filter를 등록하는 방식을 크게 4가지 정도 있다.</p><ol><li>web.xml 등록 방식</li><li>Java config 등록 방식 -&gt; FilterRegistration Bean을 정의하여 추가할 Filter를 정의</li><li>java config 등록 방식 -&gt; AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</li><li>@WebFilter Annotation 등록 방식</li></ol><h3 id="1-web-xml-등록-방식"><a href="#1-web-xml-등록-방식" class="headerlink" title="1. web.xml 등록 방식"></a>1. web.xml 등록 방식</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>testServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>testServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-FilterRegistration-Bean을-정의하여-추가할-Filter를-정의"><a href="#2-FilterRegistration-Bean을-정의하여-추가할-Filter를-정의" class="headerlink" title="2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의"></a>2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.filter.TestFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebApplicationFilterConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean <span class="title function_">testFilterRegistration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FilterRegistrationBean</span> <span class="variable">filterRegistrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class="line">        filterRegistrationBean.setFilter(<span class="keyword">new</span> <span class="title class_">TestFilter</span>());</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        filterRegistrationBean.setName(<span class="string">&quot;Test-Filter&quot;</span>);</span><br><span class="line">        filterRegistrationBean.setOrder(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean <span class="title function_">testFilter2Registration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FilterRegistrationBean</span> <span class="variable">filterRegistrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class="line">        filterRegistrationBean.setFilter(<span class="keyword">new</span> <span class="title class_">TestFilter2</span>());</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        filterRegistrationBean.setName(<span class="string">&quot;Test-Filter2&quot;</span>);</span><br><span class="line">        filterRegistrationBean.setOrder(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Filter chain의 실행 순서는 Filter1(Prehandle) -&gt; Filter2(Prehandle) -&gt; Filter2 (Posthandle) -&gt; Filter1 (Posthandle) 순으로 실행 된다. </p><h3 id="3-AbstractAnnotationConfigDispatcherServletInitializer에서-getServletFilter에-추가"><a href="#3-AbstractAnnotationConfigDispatcherServletInitializer에서-getServletFilter에-추가" class="headerlink" title="3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가"></a>3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</h3><p>※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInitializerConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="comment">//추가할 필터 리스트를 추가한다.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;<span class="keyword">new</span> <span class="title class_">TestFilter</span>(), <span class="keyword">new</span> <span class="title class_">TestFilter2</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-Component-WebFilter-Order-어노테이션을-이용한-필터-등록"><a href="#4-Component-WebFilter-Order-어노테이션을-이용한-필터-등록" class="headerlink" title="4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록"></a>4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WebFilter(</span></span><br><span class="line"><span class="meta">        description = &quot;1번째 필터&quot;,</span></span><br><span class="line"><span class="meta">        urlPatterns = &quot;/*&quot;,</span></span><br><span class="line"><span class="meta">        filterName = &quot;Test-Filter1&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start testFilter1&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        System.out.println(<span class="string">&quot;finish testFilter1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.<br>@Component -&gt; Component-scan 시 Spring Bean으로 등록 된다.<br>@WebFIlter -&gt; Filter등록에 필요한 Interface를 제공한다.<br>@Order -&gt; @Component 어노테이션 사용 시 <code>Order Interface</code> 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다.<br>개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.</p><h1 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h1><p>인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.</p><p>인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 <code>preHandle(), postHandle()</code> 메소드가 구분 되어져 있어, 분기가 명확하다.<br>또한 Filter와는 다르게 <code>handlerMethod</code>를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.</p><h2 id="Interceptor-동작-방식"><a href="#Interceptor-동작-방식" class="headerlink" title="Interceptor 동작 방식"></a>Interceptor 동작 방식</h2><ol><li>외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.</li><li>DispatcherServlet의 doDispatch() 메소드에서 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013">getHandler()</a> 메소드로 HandlerExecutionChain를 호출 한다.<br>(정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)</li><li><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227">getHandler()</a> 메소드 내부에는 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401">getHandlerInternal()</a> 메소드로 handler를 가져오는 부분이 있다.<br>   이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.</li><li>그 다음 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480">getHandlerExecutionChain()</a> 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.</li><li>추출 된 interceptor들에 대해 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032">preHandle()</a> 메소드를 실행 시킨다.<br>(preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)</li><li>그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.</li><li>메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044">postHandle()</a> 메소드를 실행 시킨다.</li></ol><h2 id="설정-방법-1"><a href="#설정-방법-1" class="headerlink" title="설정 방법"></a>설정 방법</h2><p>설정 방법은 크게 2가지로 이루어져 있다.</p><ol><li><p>servlet-context.xml에 등록</p></li><li><p>Java-config 방식을 이용한 등록 -&gt; WebMvcConfigurationSupport 이용하여 등록</p></li></ol><h3 id="1-Servlet-context-xml에-등록"><a href="#1-Servlet-context-xml에-등록" class="headerlink" title="1. Servlet-context.xml에 등록"></a>1. Servlet-context.xml에 등록</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/client&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/client/test1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">class</span>=<span class="string">&quot;com.example.springstudy.interceptor.TestInterceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-WebMvcConfigurationSupport-이용하여-등록"><a href="#2-WebMvcConfigurationSupport-이용하여-등록" class="headerlink" title="2. WebMvcConfigurationSupport 이용하여 등록"></a>2. WebMvcConfigurationSupport 이용하여 등록</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.interceptor.TestInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.interceptor.TestInterceptor2;</span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * addInterceptors 메소드를 통해 Interceptor 등록</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addInterceptors(registry);</span><br><span class="line">        <span class="comment">//String... 타입으로 여러개 지정 가능</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">TestInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/client/test1&quot;</span>, <span class="string">&quot;/client/help&quot;</span>);</span><br><span class="line">        <span class="comment">//List 타입으로 여러개 지정 가능</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">TestInterceptor2</span>())</span><br><span class="line">                .addPathPatterns(Lists.newArrayList(<span class="string">&quot;/client&quot;</span>, <span class="string">&quot;/client/test1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p><a href="http://javacan.tistory.com/entry/58">http://javacan.tistory.com/entry/58</a><br><a href="http://www.leafcats.com/39">http://www.leafcats.com/39</a><br><a href="https://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war">https://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war</a><br><a href="https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/">https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Dispatcher Servlet</title>
      <link href="/2018/08/11/2018-08-11-spring-dispatcher-servlet/"/>
      <url>/2018/08/11/2018-08-11-spring-dispatcher-servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Dispatcher-Servlet"><a href="#Spring-Dispatcher-Servlet" class="headerlink" title="Spring Dispatcher Servlet"></a>Spring Dispatcher Servlet</h1><p>Spring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다. </p><h1 id="Front-Controller-Pattern"><a href="#Front-Controller-Pattern" class="headerlink" title="Front Controller Pattern"></a>Front Controller Pattern</h1><p>Dispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.</p><p><img src="./Front-controller-pattern.png" alt="Front-controller-pattern"></p><p>Spring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.<br>모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다.<br>자세한 Cycle은 아래 그림과 같다.</p><h1 id="Dispatcher-Servlet-Cycle"><a href="#Dispatcher-Servlet-Cycle" class="headerlink" title="Dispatcher Servlet Cycle"></a>Dispatcher Servlet Cycle</h1><p><img src="./dispatcher-servlet-lifecycle.jpg" alt="dispatcher-servlet-lifecycle"></p><ol><li>doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942">doDispatch()</a> 메소드를 호출한다. </li><li>아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017">getHandler()</a>  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.</li><li>요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.</li><li>실행될 interceptor들이 있다면 interceptor의 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036">preHandle()</a> 메소드를 차례로 실행한다.</li><li>Controller의 인스턴스는 HandlerExecutionChain의 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017">getHandler()</a> 메소드를 이용해서 얻는다.</li><li>HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024">getHandlerAdaptor()</a> 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.</li><li>선택된 HanlderAdaptor의 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041">handle()</a> 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.</li><li>계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894">invoke()</a>한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)</li><li>interceptor의 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048">postHandle()</a> 메소드가 실행된다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409">resolveViewName()</a> 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.</li><li>Model 객체의 데이터를 보여주기 위해 해당 View 객체의 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119">render()</a> 메소드가 수행된다.</li></ol><h1 id="web-xml-설정하기"><a href="#web-xml-설정하기" class="headerlink" title="web.xml 설정하기"></a>web.xml 설정하기</h1><h3 id="기본-설정"><a href="#기본-설정" class="headerlink" title="기본 설정"></a>기본 설정</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span> <span class="comment">&lt;!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!-- Default Servlet을 의미 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>appServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.<br>Dispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, <code>/</code> prefix로 들어오는 모든 요청을 처리한다.</p><p>servlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 <code>/WEB-INF/appServlet-servlet.xml</code>을 찾게 된다. </p><h3 id="contextConfigLocation을-이용한-설정"><a href="#contextConfigLocation을-이용한-설정" class="headerlink" title="contextConfigLocation을 이용한 설정"></a>contextConfigLocation을 이용한 설정</h3><p>빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다. </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">        /WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class="line"><span class="comment">&lt;!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ContextLoaderListener를-이용한-설정"><a href="#ContextLoaderListener를-이용한-설정" class="headerlink" title="ContextLoaderListener를 이용한 설정"></a>ContextLoaderListener를 이용한 설정</h3><p>일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.<br>또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.<br>이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.<br>공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고,<br>web layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ApplicationContext 빈 설정 파일--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--빈 설정 파일들간에 구분은 줄바꿈(\n),컴마(,),세미콜론(;)등으로 한다.--&gt;</span> </span><br><span class="line">        /WEB-INF/config/myapp-service.xml,</span><br><span class="line">        /WEB-INF/config/myapp-dao.xml </span><br><span class="line">    <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, </span></span><br><span class="line"><span class="comment">로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.</span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span> <span class="tag">&lt;/<span class="name">listener</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>employee<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> <span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span> /WEB-INF/config/myapp-servlet.xml <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>webservice<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> <span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span> /WEB-INF/config/myapp-webservice.xml <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.<br>(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)</p><p>따라서<br>employee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,<br>webServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a href="http://mangkyu.tistory.com/18">http://mangkyu.tistory.com/18</a><br><a href="http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet">http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet</a><br><a href="http://hermeslog.tistory.com/156">http://hermeslog.tistory.com/156</a><br><a href="https://github.com/dongmyo/dispatcher2">https://github.com/dongmyo/dispatcher2</a><br><a href="https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/">https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/</a><br><a href="https://nesoy.github.io/articles/2017-02/Front-Controller">https://nesoy.github.io/articles/2017-02/Front-Controller</a><br><a href="http://wonwoo.ml/index.php/post/1590">http://wonwoo.ml/index.php/post/1590</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring에서 Client IP구하기</title>
      <link href="/2018/08/10/2018-08-10-httprequest-client-ip/"/>
      <url>/2018/08/10/2018-08-10-httprequest-client-ip/</url>
      
        <content type="html"><![CDATA[<h1 id="HttpServletRequest에서-IP-구하기"><a href="#HttpServletRequest에서-IP-구하기" class="headerlink" title="HttpServletRequest에서 IP 구하기"></a>HttpServletRequest에서 IP 구하기</h1><p>회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다. </p><p>생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.</p><p>HttpServletRequest에서 IP를 구하는 소스는 아래와 같다.</p><p>이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 (<a href="https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/">Spring Argument Resolver</a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodParameter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modelAndViewContainer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nativeWebRequest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webDataBinderFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">clientIp</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(clientIp)|| <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">        <span class="comment">//Proxy 서버인 경우</span></span><br><span class="line">        clientIp = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">        <span class="comment">//Weblogic 서버인 경우</span></span><br><span class="line">        clientIp = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">        clientIp = request.getHeader(<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">        clientIp = request.getHeader(<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">        clientIp = request.getRemoteAddr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clientIp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.<br>구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.</p><h1 id="IPv6-형식으로-나오는-IP를-IPv4로-변환"><a href="#IPv6-형식으로-나오는-IP를-IPv4로-변환" class="headerlink" title="IPv6 형식으로 나오는 IP를 IPv4로 변환"></a>IPv6 형식으로 나오는 IP를 IPv4로 변환</h1><p>위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.</p><p><img src="./ipv6.png" alt="ipv6"></p><p>예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다. </p><p> IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.</p><ol><li>Tomcat인 경우<ol><li>$CATALINA_HOME\bin\catalina.bat(.sh) 을 찾는다.</li><li><code>:noJuliConfig, :noJuliManager</code> 를 검색한다. </li><li>JAVA_OPTS에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li></ol></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if not &quot;%LOGGING_CONFIG%&quot; == &quot;&quot; goto noJuliConfig</span><br><span class="line">set LOGGING_CONFIG=-Dnop</span><br><span class="line">if not exist &quot;%CATALINA_BASE%\conf\logging.properties&quot; goto noJuliConfig</span><br><span class="line">set LOGGING_CONFIG=-Djava.util.logging.config.file=&quot;%CATALINA_BASE%\conf\logging.properties&quot;</span><br><span class="line">:noJuliConfig</span><br><span class="line">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true</span><br><span class="line"></span><br><span class="line">if not &quot;%LOGGING_MANAGER%&quot; == &quot;&quot; goto noJuliManager</span><br><span class="line">set LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class="line">:noJuliManager</span><br><span class="line">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true</span><br></pre></td></tr></table></figure><ol start="2"><li>개발 환경에서 VM 속성 추가 하기<ol><li>사용 중인 IDE에서 VM Options에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li></ol></li></ol><p><img src="./ide-setting.png" alt="ide-setting"></p><p>확인 결과</p><p><img src="./ipv4.png" alt="ipv4"></p><p>127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a href="http://all-record.tistory.com/168">http://all-record.tistory.com/168</a><br><a href="http://www.leafcats.com/35">http://www.leafcats.com/35</a><br><a href="http://ooz.co.kr/138">http://ooz.co.kr/138</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Argument Resovler</title>
      <link href="/2018/08/09/2018-08-10-spring-argument-resolver/"/>
      <url>/2018/08/09/2018-08-10-spring-argument-resolver/</url>
      
        <content type="html"><![CDATA[<p>회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나.. 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.</p><p>그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.</p><p>하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다.. (Client IP를 구하는 코드가 한 10줄 정도는 된다.)</p><p>그래서 중간에 Filter나 Interceptor로 해볼까..? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.</p><h1 id="Spring-Argument-Resolver"><a href="#Spring-Argument-Resolver" class="headerlink" title="Spring Argument Resolver"></a>Spring Argument Resolver</h1><p>Spring Argument Resolver는 <code>Controller에 들어오는 파라미터를 가공</code> 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공&#x2F;추가&#x2F;수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.<br>Spring에서는 <code>HandlerMethodArgumentResolver</code>라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.</p><h1 id="Argument-Resolver-동작-방식"><a href="#Argument-Resolver-동작-방식" class="headerlink" title="Argument Resolver 동작 방식"></a>Argument Resolver 동작 방식</h1><p><img src="./Dispatch-Seq.jpg" alt="Dispatch-Seq"></p><p>(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)</p><ol><li>Client Request 요청</li><li>Dispatcher Servlet에서 해당 요청을 처리</li><li>Client Request에 대한 Handler Mapping <ol><li>RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)</li><li>Interceptor처리</li><li><code>Argument Resolver 처리</code> &lt;– 바로 여기서 우리가 지정한 Argument Resolver 실행</li><li>Message Converter 처리</li></ol></li><li>Controller Method invoke</li></ol><p><img src="./RequestMappingHandlerAdapter.png" alt="RequestMappingHandlerAdapter"></p><p>RequestHandlerMappingAdapter.java &gt; getDefaultArgumentResolvers</p><p>위에서 지정 된 순서대로 Argument Resolver를 실행 한다.<br>메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.<br>아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.</p><h1 id="Custom-Argument-Resolver-만들기"><a href="#Custom-Argument-Resolver-만들기" class="headerlink" title="Custom Argument Resolver 만들기"></a>Custom Argument Resolver 만들기</h1><p>내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에..)</p><p>기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.<br>Custom Argument Resolver를 만들기 위해서는 <code>HandlerMethodArgumentResolver</code> 인터페이스를 구현하여 만든다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.resolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientIpArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resolveArgument를 실행 할 수 있는 method인지 판별</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter methodParameter)</span> &#123;</span><br><span class="line">        <span class="comment">//@ClientIP 어노테이션이 붙은 파라미터에 대해 적용</span></span><br><span class="line">        <span class="keyword">return</span> methodParameter.hasParameterAnnotation(ClientIP.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndViewContainer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nativeWebRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> webDataBinderFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">clientIp</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(clientIp)|| <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">            clientIp = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">            clientIp = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">            clientIp = request.getHeader(<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">            clientIp = request.getHeader(<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">            clientIp = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clientIp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.</p><ul><li>supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)<ul><li>물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.</li></ul></li><li>resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.</li></ul><h1 id="Custom-Argument-Resolver-등록하기"><a href="#Custom-Argument-Resolver-등록하기" class="headerlink" title="Custom Argument Resolver 등록하기"></a>Custom Argument Resolver 등록하기</h1><p>개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.</p><p>전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.</p><ol><li>ServletContext.xml 에 등록하는 방법</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:argument-resolvers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.example.springstudy.resolver.ClientIpArgumentResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:argument-resolvers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>Java Config를 이용하는 방법</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurationSupport를 상속 </span></span><br><span class="line"><span class="comment">//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//우리가 만든 ArgumentResolver를 추가한다.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addArgumentResolvers(argumentResolvers);</span><br><span class="line">        argumentResolvers.add(<span class="keyword">new</span> <span class="title class_">ClientIpArgumentResolver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Controller에-적용"><a href="#Controller에-적용" class="headerlink" title="Controller에 적용"></a>Controller에 적용</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 요청을 보낸 Client Ip를 return</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientIp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/client&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClientIp</span><span class="params">(<span class="meta">@ClientIP</span> String clientIp)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Request Client Ip = %s&quot;</span>, clientIp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.</p><p>실행 결과</p><p><img src="./argument-resolver-result.png" alt="argument-resolver-result"></p><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p>토비의 스프링 vol.2</p><p><a href="http://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0">http://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0</a></p><p><a href="http://zgundam.tistory.com/38">http://zgundam.tistory.com/38</a></p><p><a href="http://rstoyanchev.github.io/spring-mvc-31-update/#13">http://rstoyanchev.github.io/spring-mvc-31-update/#13</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP (5)</title>
      <link href="/2018/07/24/2018-07-24-spring-aop5/"/>
      <url>/2018/07/24/2018-07-24-spring-aop5/</url>
      
        <content type="html"><![CDATA[<p>AOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.<br>결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.<br>AOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.<br>아래의 리뷰와 같다.</p><p><img src="/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2.png" alt="AOP코드리뷰"></p><p>메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.</p><p>이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.</p><h1 id="Custom-Annotation"><a href="#Custom-Annotation" class="headerlink" title="Custom Annotation"></a>Custom Annotation</h1><p>API에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.</p><h2 id="Annotation-생성하기"><a href="#Annotation-생성하기" class="headerlink" title="Annotation 생성하기"></a>Annotation 생성하기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span>  <span class="comment">//Annotation의 상속이 가능함 </span></span><br><span class="line"><span class="meta">@Documented</span> <span class="comment">//JavaDoc 문서 추가 가능</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 컴파일 이후에도 JVM에 의해서 참조가 가능</span></span><br><span class="line"><span class="comment">//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효</span></span><br><span class="line"><span class="comment">//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)</span></span><br><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">        ElementType.PACKAGE,         // 패키지 선언시</span></span><br><span class="line"><span class="meta">        ElementType.TYPE,            // 타입 선언시</span></span><br><span class="line"><span class="meta">        ElementType.CONSTRUCTOR,     // 생성자 선언시</span></span><br><span class="line"><span class="meta">        ElementType.FIELD,           // 멤버 변수 선언시</span></span><br><span class="line"><span class="meta">        ElementType.METHOD,          // 메소드 선언시</span></span><br><span class="line"><span class="meta">        ElementType.ANNOTATION_TYPE, // 어노테이션 타입 선언시</span></span><br><span class="line"><span class="meta">        ElementType.LOCAL_VARIABLE,  // 지역 변수 선언시</span></span><br><span class="line"><span class="meta">        ElementType.PARAMETER,       // 매개 변수 선언시</span></span><br><span class="line"><span class="meta">        ElementType.TYPE_PARAMETER,  // 매개 변수 타입 선언시</span></span><br><span class="line"><span class="meta">        ElementType.TYPE_USE         // 타입 사용시</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnotation &#123;  <span class="comment">//interface에 @를 붙여주면 Annotation으로 등록</span></span><br><span class="line">    <span class="comment">/* enum 타입을 선언할 수 있습니다. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Quality</span> &#123;BAD, GOOD, VERYGOOD&#125;</span><br><span class="line">    <span class="comment">/* String은 기본 자료형은 아니지만 사용 가능합니다. */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/* 배열 형태로도 사용할 수 있습니다. */</span></span><br><span class="line">    <span class="type">int</span>[] values();</span><br><span class="line">    <span class="comment">/* enum 형태를 사용하는 방법입니다. */</span></span><br><span class="line">    Quality <span class="title function_">quality</span><span class="params">()</span> <span class="keyword">default</span> Quality.GOOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Annotation-Pointcut-지정하기"><a href="#Annotation-Pointcut-지정하기" class="headerlink" title="Annotation Pointcut 지정하기"></a>Annotation Pointcut 지정하기</h2><p>예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.aopexam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능</span></span><br><span class="line"><span class="meta">@ComponentScan(value=&#123;&quot;com.example.aopexam&quot;, &quot;com.example.custom.annotation&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopExamApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(AopExamApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.aopexam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.custom.annotation.CustomLog;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/aop-test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApiService apiService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@CustomLog</span> <span class="comment">//get 메소드에 @CustomLog추가</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getTest</span><span class="params">()</span> &#123;</span><br><span class="line">        apiService.method(ApiType.GET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postTest</span><span class="params">()</span> &#123;</span><br><span class="line">        apiService.method(ApiType.POST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putTest</span><span class="params">()</span> &#123;</span><br><span class="line">        apiService.method(ApiType.PUT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTest</span><span class="params">()</span> &#123;</span><br><span class="line">        apiService.method(ApiType.DELETE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.custom.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">//메소드 어노테이션 적용</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomLog &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.custom.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span> <span class="comment">//cglib 사용 -&gt; class기반 proxy생성</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomLogAdvisor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Annotation을 기준으로 pointcut설정</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.example.custom.annotation.CustomLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customLogPointcut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(value=&quot;customLogPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pringLog</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;메소드 실행 전 무조건 이 로그를 보게 될 것이야...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/aop-test</span><br><span class="line"></span><br><span class="line">메소드 실행 전 무조건 이 로그를 보게 될 것이야...</span><br><span class="line">[ApiService.method] apiType : GET</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP (4)</title>
      <link href="/2018/07/21/2018-07-22-spring-aop4/"/>
      <url>/2018/07/21/2018-07-22-spring-aop4/</url>
      
        <content type="html"><![CDATA[<h1 id="AspectJ란"><a href="#AspectJ란" class="headerlink" title="AspectJ란?"></a>AspectJ란?</h1><blockquote><p>AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.</p></blockquote><p>AspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, <code>CTW, LTW</code>과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.<br>또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.<br>현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.</p><blockquote><p>Aspect란?</p><p>Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.<br>그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.<br>구조적으로 보자면 Aspect &#x3D; PointCut + Advisor이다.</p></blockquote><h1 id="위빙-Weaving"><a href="#위빙-Weaving" class="headerlink" title="위빙 Weaving"></a>위빙 Weaving</h1><p>위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.<br>위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.</p><h2 id="런타임-시-위빙-RTW-Runtime-Weaving"><a href="#런타임-시-위빙-RTW-Runtime-Weaving" class="headerlink" title="런타임 시, 위빙 (RTW: Runtime Weaving)"></a>런타임 시, 위빙 (RTW: Runtime Weaving)</h2><p>Spring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.<br>실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.<br>소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.</p><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw" alt="Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼"></p><h2 id="컴파일-시-위빙-CTW-Compile-time-Weaving"><a href="#컴파일-시-위빙-CTW-Compile-time-Weaving" class="headerlink" title="컴파일 시, 위빙 (CTW: Compile time Weaving)"></a>컴파일 시, 위빙 (CTW: Compile time Weaving)</h2><p>AspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.<br>AJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.<br>장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)</p><h3 id="CTW를-사용하기-위한-메이븐-설정"><a href="#CTW를-사용하기-위한-메이븐-설정" class="headerlink" title="CTW를 사용하기 위한 메이븐 설정"></a>CTW를 사용하기 위한 메이븐 설정</h3><p><strong>라이브러리 추가:</strong> (pom.xml)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure><p><strong>플러그인 설정:</strong> (pom.xml)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectj-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">showWeaveInfo</span>&gt;</span>true<span class="tag">&lt;/<span class="name">showWeaveInfo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">complianceLevel</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class="tag">&lt;/<span class="name">complianceLevel</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outxml</span>&gt;</span>true<span class="tag">&lt;/<span class="name">outxml</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>test-compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>(*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)</em></p><p>위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용 </p><p>AspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용</p><h2 id="클래스-로드-시-위빙-LTW-Load-time-Weaving"><a href="#클래스-로드-시-위빙-LTW-Load-time-Weaving" class="headerlink" title="클래스 로드 시, 위빙 (LTW: Load time Weaving)"></a>클래스 로드 시, 위빙 (LTW: Load time Weaving)</h2><p> ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식<br>RTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.<br>Application Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.</p><p>그리고 설정이 가장 복잡하지 않은가 싶다..</p><p>아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:load-time-weaver</span>/&gt;</span> <span class="comment">&lt;!-- 스프링 설정 파일에 추가 servlet.xml --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableLoadTimeWeaving</span> <span class="comment">//Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//IDE에서 개발 시, 해당 설정을 추가</span><br><span class="line">-javaagent:/fullpath/aspectjweaver-1.8.1.jar </span><br><span class="line">-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//톰캣 시작 시, jvmargs 옵션에 추가</span><br><span class="line">-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure><h1 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h1><h2 id="JoinPoint-관련-Annotations"><a href="#JoinPoint-관련-Annotations" class="headerlink" title="JoinPoint 관련 Annotations"></a>JoinPoint 관련 Annotations</h2><p>공통적으로 pointcut에 대한 표현식을 인자로 받는다.</p><ul><li>@Before<ul><li>메소드 실행 이전 부분에 대한 Joinpoint 설정</li></ul></li><li>@Around<ul><li>ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.</li><li>메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.</li></ul></li><li>@After<ul><li>메소드 실행 이후 부분의 대한 Joinpoint 설정</li></ul></li><li>@AfterReturning<ul><li>메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정</li></ul></li><li>@AfterThrowable<ul><li>메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정</li></ul></li></ul><h2 id="Pointcut-관련-Annotation"><a href="#Pointcut-관련-Annotation" class="headerlink" title="Pointcut 관련 Annotation"></a>Pointcut 관련 Annotation</h2><ul><li>@Pointcut<ul><li>Pointcut에 대한 표현식을 값으로 가짐</li><li>@Pointcut이 적용된 메소드는 무조건 리턴타입이 void</li></ul></li></ul><h1 id="Point-Cut"><a href="#Point-Cut" class="headerlink" title="Point Cut"></a>Point Cut</h1><p>포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.<br>여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.</p><p><img src="https://t1.daumcdn.net/cfile/tistory/223B623D548C415631" alt="pointcut 개념"></p><h2 id="포인트-컷-표현식"><a href="#포인트-컷-표현식" class="headerlink" title="포인트 컷 표현식"></a>포인트 컷 표현식</h2><p>Expression을 이용한 pointcut 표현식</p><p><img src="http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg" alt="pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼"></p><ol><li><p>접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)</p><ul><li>* 인 경우 모든 접근제어자에 대해 설정 가능</li><li>생략 시, * 과 같은 효과</li></ul></li><li><p>리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)</p><ul><li>필수 적으로 기재해야 한다.</li><li>* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.</li></ul></li><li><p>Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)</p><ul><li>단, 패키지 명도 기재해야 함 </li><li>com.springframework.aop.. 처럼 ..으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리</li><li>필수 적으로 기재해야 한다.</li></ul></li><li><p>메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정</p><ul><li>필수 적으로 기재해야 한다.</li><li>모든 메소드에 적용 하려면 * 을 사용</li></ul></li><li><p>파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정</p><ul><li>필수 적으로 기재해야 한다.</li><li>,로 구분하여 순서대로 파라미터를 기재한다.</li><li>타입과 갯수에 상관없다면 .. 또는 * 를 기재한다.</li></ul></li><li><p>예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)</p></li></ol><h2 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h2><ul><li><p><strong>execution(int minus(int, int))</strong>: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p></li><li><p><strong>execution(* minus(int, int))</strong>: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p></li><li><p><strong>execution(* minus(..))</strong>: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드</p></li><li><p>**execution(* *(..))**: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드</p></li><li><p>**execution(* *())**: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드</p></li><li><p><strong>execution(* springbook.aop.Target.*(..))</strong>: springbook.aop.Target 클래스의 모든 메소드</p></li><li><p><strong>execution(* springbook.aop.<em>.</em>(..))</strong>: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.</p></li><li><p><strong>execution(* springbook.aop..<em>.</em>(..))</strong>: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함</p></li><li><p>**execution(* <em>..Target.</em>(..))**: 패키지에는 상관없이 Target 클래스의 모든 메소드</p></li><li><p>*<em>execution(</em> *(..) throws Exception) **: Exception을 throw하는 모든 메소드</p></li><li><p><strong>within(com.springbook.aop.service.</strong>*) : service 패키지 내의 모든 Joinpoint</p></li><li><p><strong>within(com.springbook.aop.service..</strong>*) : service 패키지의 하위패키지 내의 모든 Joinpoint</p></li><li><p><strong>this(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint</p></li><li><p><strong>target(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint</p></li><li><p><strong>args(java.utils.List)</strong> : 파라미터가 1개이고 List타입인 모든 Joinpoint</p></li><li><p><strong>@target(org.springframework.transaction.annotation.Transactional)</strong> :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점</p></li><li><p><strong>@within(org.springframework.transaction.annotation.Transactional)</strong> : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점</p></li><li><p><strong>@annotation(org.springframework.transaction.annotation.Transactional)</strong> : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점</p></li></ul><ul><li><p><strong>@args(com.xyz.security.Classified)</strong> : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점</p></li><li><p><strong>bean(UserRepository)</strong> : “UserRepository” 빈</p></li><li><p><strong>!bean(UserRepository)</strong> :  “UserRepository” 빈을 제외한 모든 빈</p></li><li><p><strong>bean(*)</strong> : 모든 빈</p></li><li><p><em><em>bean(user</em>)</em>* : 이름이 ‘user’로 시작되는 모든 빈</p></li><li><p>*<em>bean(<em>Repository)</em></em> : 이름이 “Repository”로 끝나는 모든 빈</p></li><li><p><strong>bean(user&#x2F;*)</strong> : 이름이 “user&#x2F;“로 시작하는 모든 빈</p></li><li><p>**bean(<em>dataSource) || bean(<em>DataSource)</em></em> : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈</p></li></ul><h1 id="예시코드"><a href="#예시코드" class="headerlink" title="예시코드"></a>예시코드</h1><h2 id="Aspect-파일-사용"><a href="#Aspect-파일-사용" class="headerlink" title="Aspect 파일 사용"></a>Aspect 파일 사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> aspect TestAdvisor &#123;</span><br><span class="line">    pointcut <span class="title function_">advicePoint</span><span class="params">()</span> : execution(* com.example.advice..*(..));</span><br><span class="line">    </span><br><span class="line">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;처음으로 실행되는 로그&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;두번째로 실행되는 로그&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//order는 어떻게 주는건지 모르겠다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Aspect-어노테이션-사용"><a href="#Aspect-어노테이션-사용" class="headerlink" title="@Aspect 어노테이션 사용"></a>@Aspect 어노테이션 사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAdvisor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.advice..*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@order(2)</span> <span class="comment">//order가 높은 순으로 먼저 실행</span></span><br><span class="line">    <span class="meta">@After(pointcut=&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterAdvice</span><span class="params">(Joinpoint joinpoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;처음으로 실행되는 로그&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@order(1)</span></span><br><span class="line">    <span class="meta">@After(pointcut=&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showLog</span><span class="params">(Joinpoint joinpoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;두번째로 실행되는 로그&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a href="http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014</a></p><p><a href="http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9">http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9</a></p><p><a href="https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5">https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP (3)</title>
      <link href="/2018/07/20/2018-07-21-spring-aop3/"/>
      <url>/2018/07/20/2018-07-21-spring-aop3/</url>
      
        <content type="html"><![CDATA[<p>앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.</p><p>이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.</p><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>AOP란 <code>횡단 관심사 (Cross Cutting Concern)</code> 을 한데 모아 로직을 설계한다음<br>런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다. </p><p>이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.<br>한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.<br>또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.</p><h1 id="Proxy란"><a href="#Proxy란" class="headerlink" title="Proxy란?"></a>Proxy란?</h1><p><img src="https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336" alt="Proxy구성도"></p><blockquote><p>Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.</p><p>그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.</p><p>토비의 스프링 vol.1 (p. 430)</p></blockquote><p>토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다. </p><p>Spring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.</p><blockquote><p>OCP (Open-Close Principal : 개방 폐쇄의 원칙)</p><p><strong>개방-폐쇄 원칙</strong>(OCP, Open-Closed Principle)은 ‘소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.’는 프로그래밍 원칙이다.  </p></blockquote><p>실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.</p><h1 id="Proxy-vs-Proxy-Pattern"><a href="#Proxy-vs-Proxy-Pattern" class="headerlink" title="Proxy vs Proxy Pattern"></a>Proxy vs Proxy Pattern</h1><p>일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.<br>비슷한 개념이지만, 내용이 조금 다르다.</p><p>일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.</p><p>Proxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.</p><h1 id="JDK-Dynamic-Proxy"><a href="#JDK-Dynamic-Proxy" class="headerlink" title="JDK Dynamic Proxy"></a>JDK Dynamic Proxy</h1><p><img src="https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif" alt="JDK Dynamic Proxy"></p><p>JDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.<br>JDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다.<br>따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.<br>이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다. </p><p>내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamDynamicHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ExamInterface target; <span class="comment">// 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExamDynamicHandler</span><span class="params">(ExamInterface target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> (String)method.invoke(target, args); <span class="comment">//타입 Safe하지 않는 단점이 있다.</span></span><br><span class="line">        <span class="keyword">return</span> ret.toUpperCase(); <span class="comment">//메소드 기능에 대한 확장</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CGLIB-Proxy"><a href="#CGLIB-Proxy" class="headerlink" title="CGLIB Proxy"></a>CGLIB Proxy</h1><p>CGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다.<br>실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.</p><p>하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다. </p><p>CGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.</p><p><img src="http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png" alt="CGLIB Proxy"></p><ul><li><p>CGLIB Proxy 설정법</p></li><li><p>~~~yaml<br>spring.aop.proxy-target-class&#x3D;false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">~~~xml</span><br><span class="line">&lt;aop:config proxy-target-class=&quot;true&quot;&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; &lt;!-- AspectJ를 사용하는 경우 --&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다</span></span><br><span class="line"><span class="meta">@EnableAsync(proxyTargetClass = true)</span></span><br><span class="line"><span class="meta">@EnableCaching(proxyTargetClass = true)</span> </span><br></pre></td></tr></table></figure></li></ul><h1 id="Spring-Bean에-대한-Proxy는"><a href="#Spring-Bean에-대한-Proxy는" class="headerlink" title="Spring Bean에 대한 Proxy는?"></a>Spring Bean에 대한 Proxy는?</h1><p>Spring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.<br>하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데.. 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?</p><p><img src="https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png" alt="00.png"></p><p>Spring에서는 <code>자동 프록시 생성기</code> 라는 것이 있다.</p><p>빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  <code>DefaultAdvisorAutoProxyCreator</code> 라는 클래스를 사용한다.<br>이 클래스는 어드바이저를 이용한 <code>자동 프록시 생성기</code> 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.</p><p>DefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.</p><ol><li>후처리기는 <code>빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해</code> 전달받은 빈이 프록시 적용 대상인지 확인한다.</li><li>프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 <code>프록시를 생성하고 어드바이저를 연결한다.</code></li><li>프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.</li><li>컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.</li></ol><p>이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.</p><h1 id="요약"><a href="#요약" class="headerlink" title="요약.."></a>요약..</h1><ul><li>Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.</li><li>Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.<ul><li>JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)</li><li>CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)<br>따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)</li></ul></li><li>Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.<br>(그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)</li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p>토비의 스프링 vol.1</p><p><a href="http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p><p><a href="https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99">https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP (2)</title>
      <link href="/2018/07/20/2018-07-20-spring-aop2/"/>
      <url>/2018/07/20/2018-07-20-spring-aop2/</url>
      
        <content type="html"><![CDATA[<p>앞선 포스팅에선 간단하게 AOP의 필요성과 간단한 예제 코드를 통해 풀어보는 방법을 적어보았다.</p><p>여기서는 AOP의 개념적인 의미에 대해서 정리해보고 AOP 세상에서 사용되는 용어들에 대한 정리 해보았다.</p><h1 id="AOP-Aspect-Oriented-Programming-란"><a href="#AOP-Aspect-Oriented-Programming-란" class="headerlink" title="AOP(Aspect Oriented Programming) 란?"></a>AOP(Aspect Oriented Programming) 란?</h1><h2 id="AOP의-등장배경"><a href="#AOP의-등장배경" class="headerlink" title="AOP의 등장배경"></a>AOP의 등장배경</h2><p> AOP의 등장배경을 알기 위해 프로그래밍의 패러다임을 살펴보면, 오랜 옛날에는 절차적 프로그래밍(procedural programming)이 있었다. 이는 기계에 필요한 기능, 로직을 설계하던 프로그래밍 방식이었고, 쉽게 위에서 아래로 실행 되는 구조를 가지고 있었다. 이전에는 규모가 작았기 때문에 프로그램을 효율적으로 작성하는 방식에 대해서는 대두되지 않았다. 하지만  고 수준의 Enterprise System을 개발하는데에는 무리가 있고, 유지보수의 어려움, 스파게티 코드를 양산하는 프로그래밍 방식이었다.  </p><p> 수 년에 걸쳐 프로그래밍의 패러다임은 객체 지향 프로그래밍 (Object Oriented Programming) 방식을 도입 하였다. 객체지향 프로그래밍 방식은 목표한 기능을 수행하기 위해 기능적, 개념적 단위를 설계하고 이를 class라는 추상화 된 명세를 통해 독립된 기능을 수행하는 프로그래밍 방식이다. 또한 객체들이 유기적으로 협력하여 로직을 수행할 수 있고 유지보수, 확장성이 용이한 프로그래밍 방식이다.</p><p> 하지만 객체지향 프로그래밍 방식에도 헛점은 있었다.<br>실제 핵심 로직을 수행하는 Method에서 아무리 설계를 잘하더라도 분리된 모듈로 작성하기 힘든 부분이 발생한다. <code>횡단 관심사 (CrossCutting Concerns)</code>이라 한다. 횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.</p><h2 id="AOP의-개념"><a href="#AOP의-개념" class="headerlink" title="AOP의 개념"></a>AOP의 개념</h2><p> 실제 핵심 로직(Core Concern)을 수행하면서 발생하는 <code>횡단 관심사 (CrossCutting Concerns)</code> 를 한데 모아 처리하는 것을 AOP라 한다. AOP를 사용하기 위해 Aspect Class를 별도로 지정하여 실행 Method의 조인포인트(Join Point)를 기반으로 포인트 컷(Point Cut)을 설정하여 실제 모듈의 핵심 로직에 관여하지 않고도 횡단 로직을 처리 할 수 있도록 해준다.</p><p><img src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/cross-cutting-concern.png" alt="횡단관심사와 핵심로직"></p><p>AOP는 이러한 횡단 관심사 로직을 Method가 실행되는 조인포인트에 코드를 적용 시켜, 실제 메소드에 코드가 있는 것 처럼 실행 하도록 해준다. 이러한 개념을 위빙(Weaving)이라고 한다.</p><p>AOP에서는 이러한 기능을 Aspect라는 이름으로 부르고 있다.<br>Aspect를 정의 하자면,<br>실제 모듈에 대한 핵심기능을 담고 있지는 않지만 모듈이나 Method를 구성하는 한가지 요소이고, 핵심기능에 부가되어 의미를 갖는 모듈을 가르킨다. </p><p>이러한 설명을 보게 되면은 AOP는 OOP를 대체 할 수 있는 획기적인 방법론이라고 생각할 수 있다.<br>AOP는 OOP를 대체 하는 것이 아닌 OOP의 가치를 더 올려 줄 수 있는 보조적이고 상호 보완적인 관계라고 생각 해야 한다.</p><h1 id="AOP-에서-사용되는-용어들"><a href="#AOP-에서-사용되는-용어들" class="headerlink" title="AOP 에서 사용되는 용어들"></a>AOP 에서 사용되는 용어들</h1><h2 id="Join-Point"><a href="#Join-Point" class="headerlink" title="Join Point"></a>Join Point</h2><p>말그대로 Join + Point이다. <code>횡단관심사(Cross Cutting Concern)</code> 로 분리 된 로직이 끼어들 수 있는 (조인할 수 있는) 위치 또는 시점을 일컫는 말이다.</p><h2 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h2><p><code>횡단관심사(Cross Cutting Concern)</code> 으로 분리 된 로직에 대한 코드<br>Aspect로 분리 되어 실행 시, 위빙되어 구체적인 처리를 하는 로직을 일컫는 단어</p><h2 id="Point-Cut"><a href="#Point-Cut" class="headerlink" title="Point Cut"></a>Point Cut</h2><p>말그대로 (Join) Point + cut이다. Join Point는 모든 메소드에 있는 위치 또는 시점을 일컫는 말이지만,<br>Point cut은 공통으로 적용할 Join Point를 표현식 같은 기능을 사용하여 하나로 묶어내는 역할을 한다. 실제 Advice코드가 적용 될 지점을 의미 하는 단어</p><h2 id="Weaving"><a href="#Weaving" class="headerlink" title="Weaving"></a>Weaving</h2><p>Advice 코드를 핵심 로직의 Point cut에 적용하는 것을 의미하는 단어이다.<br>즉, Advice로 분리한 코드를 핵심 로직에 다시 합치는 일이다.<br>방법에 따라 </p><ul><li>런타임 시, Proxy로 생성하며 코드를 합치는 방법</li><li>컴파일 시, 클래스 로드 시, 바이트 코드를 조작하여 실제 코드를 끼워 넣는 방법<br>이 있다.</li></ul><h2 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h2><p>여러 객체에 공통으로 적용되는 관심 사항을 Aspect라고 한다.<br>보안, 트랜잭션, 로깅등이 대표적인 예이다.<br>Aspect는 AOP의 핵심 단위 이며 Advice + Point cut &#x3D; Aspect 이다.</p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>핵심 로직을 구현하는 클래스 또는 객체<br>AOP를 적용하여 Advice를 받을 대상을 의미하는 단어이다.</p><h2 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h2><p>Advice 코드와 Pointcut을 합쳐놓은 것을 Advisor라고 부른다.<br>공통 관심사 코드를 뽑아서 하나의 클래스에 담은 것이다.</p><hr><p>참고</p><p><a href="https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD">https://jongmin92.github.io/2018/02/17/Spring/spring-aop/#aop%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD</a></p><p><a href="http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p><p><a href="http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106">http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039147106</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP (1)</title>
      <link href="/2018/07/15/2018-07-15-spring-aop/"/>
      <url>/2018/07/15/2018-07-15-spring-aop/</url>
      
        <content type="html"><![CDATA[<p>개발 하던 중에 Custom Annotation을 구현해서 사용해야 할 일이 생겼다.<br>Custom Annotation을 구현하기 위해선 Spring AOP와 AspectJ의 기능을 사용하여 구현해야 하는데, 이번 기회에  다시 한번 Spring AOP에 대해 정리 해보려고 이 포스팅을 기록 하게 되었다.</p><h1 id="들어가면서"><a href="#들어가면서" class="headerlink" title="들어가면서.."></a>들어가면서..</h1><p>정리하고자 하는 내용</p><ol><li>AOP를 사용해야하는 이유</li><li>AOP에서 사용되는 용어 정리</li><li>Spring AOP</li><li>AspectJ</li><li>Custom Annotation</li></ol><p>내용이 많아 질 것 같아서 위의 순서대로 별도로 포스트를 작성할 예정이다.</p><h1 id="1-AOP를-사용-해야-하는-이유"><a href="#1-AOP를-사용-해야-하는-이유" class="headerlink" title="1. AOP를 사용 해야 하는 이유"></a>1. AOP를 사용 해야 하는 이유</h1><h2 id="AOP란"><a href="#AOP란" class="headerlink" title="AOP란?"></a>AOP란?</h2><p> AOP(Aspect Oriented Programming) 란 우리말로 관점지향 프로그래밍이라고 한다.<br>객체지향의 5대원칙 중에는 단일책임의 원칙 (Single Responsibility Programming 이하 SRP) 라는 원칙이 있다.<br>하나의 클래스, 메서드는 하나의 역할만을 가진다는 원칙이다. 하지만 객체지향 프로그래밍(OOP)를 기반으로 로직을 설계하다 보면 단일책임의 원칙을 지키지 못하는 경우가 다반사로 발생한다.</p><p>예를 들어 결제를 담당하는 소스가 있다고 할 때</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PaymentResponse <span class="title function_">doPaymentByCash</span><span class="params">(PaymentRequest paymentRequest)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//결제 요청에 대한 현금 결제처리</span></span><br><span class="line">    <span class="type">PaymentResponse</span> <span class="variable">response</span> <span class="operator">=</span> paymentModule.paymentCash(paymentRequest);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class="line">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> PaymentResponse <span class="title function_">doPaymentByCreditCard</span><span class="params">(PaymentRequest paymentRequest)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//결제 요청에 대한 카드 결제 처리</span></span><br><span class="line">    <span class="type">PaymentResponse</span> <span class="variable">response</span> <span class="operator">=</span> paymentModule.paymentCreditCard(paymentRequest);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//결제 요청에 대한 로그 데이터 DB Insert</span></span><br><span class="line">    paymentLogRepository.insert(paymentRequest, response);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 doPaymentByXX라는 메서드는 실제 결제 요청 데이터에 대해 결제를 수행하는 메서드이다.<br>결제 처리 아랫쪽의 로그 데이터를 DB에 저장하는 부분은 doPaymentByXX라는 메서드 명에 어울리지 않는다.<br>굳이 변경하자면 doPaymentByXXWithLog 정도로 메서드명을 변경해야 의미가 맞겠지만, SRP의 원칙에 맞지 않는다고 생각한다.</p><p>여기서 로그 데이터를 삽입하는 로직은 결제 로직에 대해서는 횡단 로직으로 다른 관심사로 볼 수 있다.<br>뿐만 아니라 결제 수단 별로 나뉘어진 메서드에 대해 중복되는 로직으로 볼 수 있다.</p><p>이런 경우 우리는 결제 로그 삽입 이라는 다른 관심사로 분리하여 코드를 작성 할 수 있다.</p><p>그리고 이렇게 횡단 관심사로 분리되어진 공통 로직을 프로그램이<br>컴파일 시에, 런타임 시에, 클래스가 로드되는 시점에 각 로직을 삽입 해주는 것을 AOP라는 개념으로 볼 수 있다.</p><p>AOP를 적용한다면 아래처럼 코드를 만들 수 있겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PaymentResponse <span class="title function_">doPaymentByCash</span><span class="params">(PaymentRequest paymentRequest)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//결제 요청에 대한 현금 결제처리</span></span><br><span class="line">    <span class="type">PaymentResponse</span> <span class="variable">response</span> <span class="operator">=</span> paymentModule.paymentCash(paymentRequest);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> PaymentResponse <span class="title function_">doPaymentByCreditCard</span><span class="params">(PaymentRequest paymentRequest)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//결제 요청에 대한 카드 결제 처리</span></span><br><span class="line">    <span class="type">PaymentResponse</span> <span class="variable">response</span> <span class="operator">=</span> paymentModule.paymentCreditCard(paymentRequest);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentLogAdvisor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentLogRepository paymentLogRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* com.example.payment.doPayment*(..))&quot;, returning=&quot;paymentResponse&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPayment</span><span class="params">(JoinPoint jp, PaymentResponse paymentResponse)</span> &#123;</span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        <span class="keyword">if</span>(args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">illegalArgumentException</span>(<span class="string">&quot;argument is none&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!(args[<span class="number">0</span>] <span class="keyword">instanceof</span> PaymentRequest)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;argument is not PaymentRequest Type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">PaymentRequest</span> <span class="variable">paymentRequest</span> <span class="operator">=</span> (PaymentRequest) args[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//결제 로그 삽입</span></span><br><span class="line">        paymentLogRepository.insert(paymentRequest, paymentResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
