<!DOCTYPE html><html lang="lang"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Carrey"><meta name="copyright" content="Carrey"><title>공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다. | Carrey`s 기술블로그</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300"></div><div class="author-info__name text-center">Carrey</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="archives"><span class="pull-left">Articles</span><span class="pull-right">112</span></a><a class="author-info-articles__tags article-meta" href="tags"><span class="pull-left">Tags</span><span class="pull-right">27</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="index.html">Carrey`s 기술블로그</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Carrey`s 기술블로그</div><div id="site-sub-title">공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="2022/03/10/2022-03-11-spring-cloud-config/">Spring Cloud Config 시작하기</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-11</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Spring/">Spring</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Spring-Cloud/">Spring Cloud</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Spring-Cloud-Config/">Spring Cloud Config</a></span><div class="content"><h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>해당 글에서 사용한 예제의 버전 정보는 아래와 같습니다</p>
<ul>
<li>kotlin 1.6.0</li>
<li>Spring Boot 2.6.3</li>
<li>Spring Cloud Dependencies 2021.0.1</li>
</ul>
<p>Spring Cloud Config 관련 글은 총 4개의 글로 작성되었습니다.</p>
<ul>
<li><strong>Spring Cloud Config 시작하기</strong></li>
<li>Spring Cloud Bus 시작하기</li>
<li>Spring Cloud Config Monitor 시작하기</li>
<li>Spring Cloud Config 주기적으로 Polling 하기</li>
</ul>
<h1 id="Spring-Cloud-Config란"><a href="#Spring-Cloud-Config란" class="headerlink" title="Spring Cloud Config란"></a>Spring Cloud Config란</h1><p>Spring Cloud Config는 분산 시스템에서 remote configuration을 제공합니다.</p>
<p>Config Server-Client의 구조로 이루어져 있습니다. </p>
<p><img src="./spring-cloud-config1.png"></p>
<h1 id="Spring-Cloud-Config-Server"><a href="#Spring-Cloud-Config-Server" class="headerlink" title="Spring Cloud Config Server"></a>Spring Cloud Config Server</h1><p>Config Server는 remote configuration을 HTTP API로 제공합니다.</p>
<h2 id="Spring-Cloud-Config에서-지원하는-Backend-저장소"><a href="#Spring-Cloud-Config에서-지원하는-Backend-저장소" class="headerlink" title="Spring Cloud Config에서 지원하는 Backend 저장소"></a>Spring Cloud Config에서 지원하는 Backend 저장소</h2><p>spring cloud config에서는 Backend 저장소로 다양한 시스템을 지원합니다.</p>
<ul>
<li>git (가장 많이 사용되는 repository 입니다.)</li>
<li>File System</li>
<li>Vault</li>
<li>JDBC (이번 프로젝트에서는 시스템에서 설정을 용이하게 변경하기 위해 JDBC를 사용했습니다)</li>
<li>Redis</li>
<li>AWS S3</li>
<li>CrudHub</li>
</ul>
<h2 id="설정-방법"><a href="#설정-방법" class="headerlink" title="설정 방법"></a>설정 방법</h2><h3 id="1-build-gradle-의존성-추가"><a href="#1-build-gradle-의존성-추가" class="headerlink" title="1. build.gradle 의존성 추가"></a>1. build.gradle 의존성 추가</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.cloud:spring-cloud-starter-config&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.cloud:spring-cloud-config-server&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.boot:spring-boot-starter-jdbc&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>spring-cloud-starter-config, spring-cloud-config-server<ul>
<li>spring cloud config server 구현을 위해 의존성을 추가합니다.</li>
</ul>
</li>
<li>spring-boot-starter-jdbc<ul>
<li>JDBC Backend 사용을 위해 의존성을 추가합니다.</li>
</ul>
</li>
</ul>
<h3 id="2-코드-구성"><a href="#2-코드-구성" class="headerlink" title="2. 코드 구성"></a>2. 코드 구성</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;ConfigServerApplication&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@EnableConfigServer</code> 어노테이션을 선언하여 Config Server 기능이 동작하도록 합니다.</li>
</ul>
<h3 id="3-Properties-Table-추가"><a href="#3-Properties-Table-추가" class="headerlink" title="3. Properties Table 추가"></a>3. Properties Table 추가</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> remote_configurations</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">integer</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    application <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    profile     <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    label       <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    prop_key    <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    prop_value  <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    created_at  datetime(<span class="number">6</span>) <span class="keyword">default</span> now(<span class="number">6</span>),</span><br><span class="line">    modified_at datetime(<span class="number">6</span>) <span class="keyword">default</span> now(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">primary</span> key (id)</span><br><span class="line">) engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<ul>
<li>application: 프로퍼티가 적용될 application의 이름입니다. (ex. jaehun-config-admin)</li>
<li>profile: 프로퍼티가 적용될 profile 입니다 (ex. dev, beta, prod)</li>
<li>label: 프로퍼티를 적용한 label 입니다.  기본값은 master입니다.</li>
<li>prop_key: 프로퍼티 key 입니다.</li>
<li>prop_value: 프로퍼티 value 입니다.</li>
<li>created_at: 프로퍼티의 생성 시각입니다.</li>
<li>modified_at: 프로퍼티의 수정 시각입니다.</li>
</ul>
<h3 id="4-application-yml-설정"><a href="#4-application-yml-설정" class="headerlink" title="4. application.yml 설정"></a>4. application.yml 설정</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">jdbc:</span></span><br><span class="line">          <span class="attr">sql:</span> <span class="string">select</span> <span class="string">prop_key,</span> <span class="string">prop_value</span> <span class="string">from</span> <span class="string">remote_configurations</span> <span class="string">where</span> <span class="string">application=?</span> <span class="string">and</span> <span class="string">profile=?</span> <span class="string">and</span> <span class="string">label=?</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/config-server</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">&lt;database-username&gt;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&lt;database-password&gt;</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.mariadb.jdbc.Driver</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jdbc</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">local</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>spring.cloud.config.enabled=true</code> : remote configuration을 사용합니다.</li>
<li><code>spring.cloud.config.server.jdbc.enabled=true</code> : spring cloud config server에서 jdbc backend를 사용합니다.</li>
<li><code>spring.cloud.config.server.jdbc.sql</code> : config 조회 요청 시,  application, profile, label을 파라미터로 수행하는 쿼리입니다.<ul>
<li>이 쿼리의 실행 결과로 나온 프로퍼티가 client에 전달됩니다.</li>
</ul>
</li>
<li><code>spring.datasource.*</code> : remote configuration에 대한 Datasource를 정의합니다.</li>
<li><code>spring.profiles.active=jdbc</code> JDBC Backend를 사용하기 위해 active profiles에 추가합니다.</li>
</ul>
<h2 id="Config-Server에서-어떤-API로-configuration-properties를-조회하나요"><a href="#Config-Server에서-어떤-API로-configuration-properties를-조회하나요" class="headerlink" title="Config Server에서 어떤 API로 configuration properties를 조회하나요?"></a>Config Server에서 어떤 API로 configuration properties를 조회하나요?</h2><p><code>spring-cloud-config-server</code> 의존성을 추가하게 되면 <code>EnvironmentController</code> 가 생성되어 properties 조회를 위한 API를 제공합니다. (이외에도 더 많습니다)</p>
<p><img src="./EnvironmentController.png"></p>
<ul>
<li>대표적으로 사용하는 API는 <code>/&#123;application-name&#125;/&#123;profile&#125;/&#123;label&#125;</code> 로 이루어진 API를 사용합니다. (ex. GET http:&#x2F;&#x2F;<config-server-url>&#x2F;jaehun-microservice-router&#x2F;prod&#x2F;master)</li>
<li>위의 endpoint로 요청하게 되면 내부적으로 backend 저장소에 저장된 application, profile, label에 부합하는 설정 값을 리턴하게 됩니다.</li>
</ul>
<h3 id="리턴되는-정보-예시"><a href="#리턴되는-정보-예시" class="headerlink" title="리턴되는 정보 예시"></a>리턴되는 정보 예시</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request GET <span class="string">&#x27;http://config-server/jaehun-microservice-router/prod/master&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;jaehun-microservice-router&quot;</span>,</span><br><span class="line">    <span class="string">&quot;profiles&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;prod&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;label&quot;</span>: <span class="string">&quot;master&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: null,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: null,</span><br><span class="line">    <span class="string">&quot;propertySources&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;jaehun-microservice-router-prod&quot;</span>,</span><br><span class="line">            <span class="string">&quot;source&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;routing.weight.A&quot;</span>: <span class="string">&quot;51&quot;</span>,</span><br><span class="line">                <span class="string">&quot;routing.weight.B&quot;</span>: <span class="string">&quot;49&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>클라이언트에서는 리턴되는 프로퍼티 정보를 기반으로 context를 refresh 합니다.</li>
<li>이때 <code>@RefreshScope</code> 로 빈 스코프가 정의된 bean에 대해 조회한 프로퍼티로 바인딩 합니다.</li>
</ul>
<h1 id="Spring-Cloud-Config-Client"><a href="#Spring-Cloud-Config-Client" class="headerlink" title="Spring Cloud Config Client"></a>Spring Cloud Config Client</h1><p>클라이언트가 되는 Spring Boot 애플리케이션은 Spring Cloud Config Server에서 제공하는 properties를 즉시 사용할 수 있습니다.</p>
<h2 id="설정-방법-1"><a href="#설정-방법-1" class="headerlink" title="설정 방법"></a>설정 방법</h2><h3 id="1-build-gradle-의존성-추가-1"><a href="#1-build-gradle-의존성-추가-1" class="headerlink" title="1. build.gradle 의존성 추가"></a>1. build.gradle 의존성 추가</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.cloud:spring-cloud-starter-config&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.cloud:spring-cloud-config-client&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.boot:spring-boot-starter-actuator&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.boot:spring-boot-starter-aop&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>spring-cloud-starter-config, spring-cloud-config-client<ul>
<li>spring cloud config client 구성을 위해 의존성을 추가 합니다.</li>
</ul>
</li>
<li>spring-boot-starter-actuator<ul>
<li><code>/actuator/refresh</code> 를 호출 하여 context refresh를 하기 위해 추가합니다.</li>
</ul>
</li>
<li>spring-boot-starter-aop<ul>
<li>client 설정 중 retry 옵션을 사용하기 위해 추가합니다.</li>
</ul>
</li>
</ul>
<h3 id="2-application-yml-설정-spring-boot-2-4-이상-버전"><a href="#2-application-yml-설정-spring-boot-2-4-이상-버전" class="headerlink" title="2. application.yml 설정 (spring boot 2.4 이상 버전)"></a>2. application.yml 설정 (spring boot 2.4 이상 버전)</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;refresh&quot;</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">import:</span> <span class="string">&quot;optional:configserver:http://localhost:8080&quot;</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">jaehun-microservice-router</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">true</span> </span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="number">1000</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1.1</span></span><br><span class="line">      <span class="attr">request-connect-timeout:</span> <span class="number">2000</span></span><br><span class="line">      <span class="attr">request-read-timeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>management.endpoints.web.exposure.include=refresh</code><ul>
<li>&#x2F;actuator&#x2F;refresh endpoint를 노출 시켜, 클라이언트의 context refresh를 실행시키도록 합니다.</li>
<li>context refresh가 실행되면 config server로 부터 현재 프로퍼티 정보를 받아옵니다.</li>
</ul>
</li>
<li><code>spring.config.import=optional:configserver:http://localhost:8080</code><ul>
<li>spring boot 2.4 이상 버전부터 지원하는 설정입니다.</li>
<li>2.3 이하 버전에서는 bootstrap.yml 파일에 spring.cloud.config 설정을 작성해야 합니다.</li>
<li>configserver에 대한 host 정보를 설정합니다.<ul>
<li>default는 <a href="http://localhost:8888입니다">http://localhost:8888입니다</a>.</li>
</ul>
</li>
<li>optional을 제거하고 <code>configserver:http://localhost:8080</code> 으로 설정 시, config server에 연결할 수 없는 경우 애플리케이션 구동에 실패합니다.</li>
</ul>
</li>
<li><code>spring.cloud.config.name=jaehun-microservice-router</code><ul>
<li>현재 애플리케이션의 application-name을 지정합니다.</li>
<li>이 값은 기본으로 <a target="_blank" rel="noopener" href="http://spring.application.name/">spring.application.name</a> 프로퍼티 값을 사용합니다.</li>
<li>이 값으로 config server에 조회할 application-name으로 사용합니다.</li>
</ul>
</li>
<li><code>spring.cloud.config.fail-fase=true</code><ul>
<li>config-server에 연결할 수 없는 경우 애플리케이션 구동에 실패합니다.</li>
<li><code>configserver:http://localhost:8080</code> 와 비슷한 설정입니다.</li>
<li>retry 옵션을 사용하고자 하는 경우에 반드시 선언되어야 합니다.</li>
</ul>
</li>
<li><code>spring.cloud.config.retry.*</code><ul>
<li>config server에 연결 실패하거나 응답 에러가 발생하는 경우 재시도하는 정책입니다.</li>
<li><code>initial-interval</code> : config server api 요청 실패 후 다음 retry 요청을 위한 internal 입니다. 단위는 ms(밀리세컨드)입니다.</li>
<li><code>max-attempts</code> : 최대로 retry하는 횟수 입니다.</li>
<li><code>multiplier</code>: 한번 retry 할 때마다 interval 시간의 지연율을 곱합니다<ul>
<li>initial-interval: 1000 경우 2번째 retry는 1100ms 이후 실행합니다.</li>
</ul>
</li>
</ul>
</li>
<li><code>spring.cloud.config.request-connect-timeout</code><ul>
<li>config server 요청 시 사용하는 connection timeout 값입니다.</li>
<li>단위는 ms(밀리세컨드)</li>
<li>기본값은 10초 입니다.</li>
</ul>
</li>
<li><code>spring.cloud.config.request-read-timeout</code><ul>
<li>config server 요청 시 사용하는 read timeout 값입니다.</li>
<li>단위는 ms(밀리세컨드)</li>
<li>기본값은 185초 입니다.</li>
</ul>
</li>
</ul>
<h2 id="어떻게-런타임에-프로퍼티를-갱신하나요"><a href="#어떻게-런타임에-프로퍼티를-갱신하나요" class="headerlink" title="어떻게 런타임에 프로퍼티를 갱신하나요?"></a>어떻게 런타임에 프로퍼티를 갱신하나요?</h2><p>클라이언트에 POST &#x2F;actuator&#x2F;refresh API를 요청해 프로퍼티를 config server에서 불러와 갱신합니다.</p>
<h2 id="모든-Bean을-다시-만드나요"><a href="#모든-Bean을-다시-만드나요" class="headerlink" title="모든 Bean을 다시 만드나요?"></a>모든 Bean을 다시 만드나요?</h2><p>Bean Scope가 <code>@RefreshScope</code> 로 선언된 Bean에 대해서만 다시 생성합니다.</p>
<ul>
<li>Bean 내에 선언된 <code>@Value</code> 어노테이션을 사용한 프로퍼티의 값을 갱신 합니다.</li>
<li><code>@ConfigurationProperties</code> bean을 갱신합니다.</li>
<li>단! remote property를 기반으로<code>@ConditionalOnProperty</code>는 사용할 수 없습니다.<ul>
<li>라이프사이클이 달라 적용되지 않습니다.</li>
</ul>
</li>
</ul>
<h3 id="사용-예제"><a href="#사용-예제" class="headerlink" title="사용 예제"></a>사용 예제</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeightedRoutingPolicy</span></span>(</span><br><span class="line">  <span class="meta">@Value(<span class="string">&quot;\$&#123;routing.weight.A&#125;&quot;</span>)</span> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> routingWeightForA: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="meta">@Value(<span class="string">&quot;\$&#123;routing.weight.B&#125;&quot;</span>)</span> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> routingWeightForB: <span class="built_in">Int</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="질문-있어요"><a href="#질문-있어요" class="headerlink" title="질문 있어요~!"></a>질문 있어요~!</h1><h2 id="RefreshScope가-선언된-bean을-사용하는-bean도-재생성-되나요"><a href="#RefreshScope가-선언된-bean을-사용하는-bean도-재생성-되나요" class="headerlink" title="@RefreshScope가 선언된 bean을 사용하는 bean도 재생성 되나요?"></a>@RefreshScope가 선언된 bean을 사용하는 bean도 재생성 되나요?</h2><p><img src="./No.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanA도 재생성될까? =&gt; No!!</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanA</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> beanB BeanB</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanB</span></span>(</span><br><span class="line">  <span class="meta">@Value(<span class="string">&quot;\$&#123;custom.remote-config.value&#125;&quot;</span>)</span> <span class="keyword">val</span> customRemoteConfigValue: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>아닙니다~! @RefreshScope가 선언된 bean은 기본 생성 전략이 lazy-loading입니다.<br>따라서 최초 사용하는 시점에 initializing이 이루어집니다.</p>
<p>그렇기 때문에 @RefreshScope가 선언된 bean을 사용하는 bean은 재생성 되지 않습니다!<br>@RefreshScope가 선언된 bean이 재생성되고 최초로 사용할 때 initializing 되게 됩니다</p>
<h1 id="Spring-Cloud-Config의-기본적인-기능을-살펴보았습니다"><a href="#Spring-Cloud-Config의-기본적인-기능을-살펴보았습니다" class="headerlink" title="Spring Cloud Config의 기본적인 기능을 살펴보았습니다"></a>Spring Cloud Config의 기본적인 기능을 살펴보았습니다</h1><p><img src="./programmer-chaos.jpg"></p>
<p>근데말이죠…</p>
<p>클라이언트 모듈을 여러 대 운영하면 일일이 &#x2F;actuator&#x2F;refresh를 호출해야 할까요? </p>
<p>이런 고통과 고민을 덜어주기 위해 다음 글에서는 Spring Cloud Bus라는 기능을 소개합니다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-config/docs/3.0.3/reference/html/">https://docs.spring.io/spring-cloud-config/docs/3.0.3/reference/html/</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="2020/11/22/2020-11-22-spring-data-jpa-batch-insert/">Spring JPA Batch Insert 과연 생각대로 동작할까?</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-22</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Spring/">Spring</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/JPA/">JPA</a></span><div class="content"><h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>Spring JPA를 사용하며 대량으로 insert 시, 1건씩 insert 되기에 성능이 너무 안나온다고 생각을 하고 있었습니다.<br>그래서 초반에는 bulk insert와 같은 키워드로 검색을 해보니 Hibernate Batch Insert라는 내용이 있어<br>그대로 설정을 해보았으나 1건씩 insert 되기는 마찬가지였습니다.  </p>
<p>다른 사람들이 작성한 블로그를 읽어보면 뭔가 되는듯 한데, 나만 안되는 건가? 라는 생각이 들었고<br>끝내 원하던 방법을 찾아 그 내용을 공유하는 글을 작성하게 되었습니다. </p>
<p>예제 코드는 아래 github에 있습니다.<br><a target="_blank" rel="noopener" href="https://github.com/jaehun2841/spring-jpa-batch-insert-test">https://github.com/jaehun2841/spring-jpa-batch-insert-test</a></p>
<h1 id="Batch-Insert-왜-insert-하나에-안합쳐져"><a href="#Batch-Insert-왜-insert-하나에-안합쳐져" class="headerlink" title="Batch Insert? 왜 insert 하나에 안합쳐져?"></a>Batch Insert? 왜 insert 하나에 안합쳐져?</h1><p>대부분 Insert 구문은 아래와 같이 사용됩니다</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;e8e6255c-bd9b-4310-af8b-72ab1ce31259&#x27;</span>, <span class="number">620000</span>);</span><br></pre></td></tr></table></figure>



<p>우리는 모두 많은 데이터를 입력할 시, 아래와 방법처럼 insert 구문을 실행하지 않고</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6c5fe953-ec38-4b26-b2f7-29a389cb8c03&#x27;</span>, <span class="number">619988</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;1959cb84-1dd5-42cc-95c1-8fd501881f1f&#x27;</span>, <span class="number">619989</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;daf8073e-78ea-435c-ac36-ac0796c4c283&#x27;</span>, <span class="number">619990</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;b98761f6-5f0b-448c-8f7f-aeffc22032d6&#x27;</span>, <span class="number">619991</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9a740e9c-2249-4c05-9349-9118c5825755&#x27;</span>, <span class="number">619992</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;d1b0e19c-9002-40d9-a43c-ae5e7293a7f4&#x27;</span>, <span class="number">619993</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;5ac02554-a877-4d1e-93b1-3f15bb58261c&#x27;</span>, <span class="number">619994</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;36673f68-3c56-4be6-8e09-3d970d5f361e&#x27;</span>, <span class="number">619995</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9d64f853-bd04-4ace-ba14-acc072f19729&#x27;</span>, <span class="number">619996</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;37190885-c1e7-4417-b545-f78130854acf&#x27;</span>, <span class="number">619997</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;fa7dc828-8aeb-45f1-9e80-8843890fd527&#x27;</span>, <span class="number">619998</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6e860c36-00f5-4349-952c-f7c09dfcc263&#x27;</span>, <span class="number">619999</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;e8e6255c-bd9b-4310-af8b-72ab1ce31259&#x27;</span>, <span class="number">620000</span>);</span><br></pre></td></tr></table></figure>



<p>이와 같이 멀티라인 insert가 효율이 더 좋음을 알고 있기에, 이러한 방법을 사용할 것입니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> </span><br><span class="line">(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6c5fe953-ec38-4b26-b2f7-29a389cb8c03&#x27;</span>, <span class="number">619988</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;1959cb84-1dd5-42cc-95c1-8fd501881f1f&#x27;</span>, <span class="number">619989</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;daf8073e-78ea-435c-ac36-ac0796c4c283&#x27;</span>, <span class="number">619990</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;b98761f6-5f0b-448c-8f7f-aeffc22032d6&#x27;</span>, <span class="number">619991</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9a740e9c-2249-4c05-9349-9118c5825755&#x27;</span>, <span class="number">619992</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;d1b0e19c-9002-40d9-a43c-ae5e7293a7f4&#x27;</span>, <span class="number">619993</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;5ac02554-a877-4d1e-93b1-3f15bb58261c&#x27;</span>, <span class="number">619994</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;36673f68-3c56-4be6-8e09-3d970d5f361e&#x27;</span>, <span class="number">619995</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9d64f853-bd04-4ace-ba14-acc072f19729&#x27;</span>, <span class="number">619996</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;37190885-c1e7-4417-b545-f78130854acf&#x27;</span>, <span class="number">619997</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;fa7dc828-8aeb-45f1-9e80-8843890fd527&#x27;</span>, <span class="number">619998</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6e860c36-00f5-4349-952c-f7c09dfcc263&#x27;</span>, <span class="number">619999</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;e8e6255c-bd9b-4310-af8b-72ab1ce31259&#x27;</span>, <span class="number">620000</span>);</span><br></pre></td></tr></table></figure>

<p>처음에 Hibernate에서 제공하는 batch insert가 이와 같은 기능인 줄 <strong>착각</strong> 하여 이런 기능을 제공하지 않는 줄 알았습니다.</p>
<h1 id="JDBC-Batching"><a href="#JDBC-Batching" class="headerlink" title="JDBC Batching"></a>JDBC Batching</h1><p><a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#batch-jdbcbatch">batch-jdbcbatch</a> 이 글에는 JDBC에서 제공하는 batch 처리 옵션을 알려주고 있습니다.  </p>
<blockquote>
<p>JDBC offers support for batching together SQL statements that can be represented as a single PreparedStatement. Implementation wise this generally means that drivers will send the batched operation to the server in one call, which can save on network calls to the database. Hibernate can leverage JDBC batching. The following settings control this behavior.</p>
</blockquote>
<p>번역기를 통해 번역해보면..</p>
<blockquote>
<p>JDBC는 단일 PreparedStatement로 표현 될 수있는 SQL 문을 일괄 처리 할 수 있도록 지원합니다.<br>구현 측면에서 이것은 일반적으로 드라이버가 한 번의 호출로 일괄 처리 된 작업을 서버로 전송하여 데이터베이스에 대한 네트워크 호출을 절약 할 수 있음을 의미합니다.<br>Hibernate는 JDBC 일괄 처리를 활용할 수 있습니다. </p>
</blockquote>
<p>다시 한번 의역해보면..</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6c5fe953-ec38-4b26-b2f7-29a389cb8c03&#x27;</span>, <span class="number">619988</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;1959cb84-1dd5-42cc-95c1-8fd501881f1f&#x27;</span>, <span class="number">619989</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;daf8073e-78ea-435c-ac36-ac0796c4c283&#x27;</span>, <span class="number">619990</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;b98761f6-5f0b-448c-8f7f-aeffc22032d6&#x27;</span>, <span class="number">619991</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9a740e9c-2249-4c05-9349-9118c5825755&#x27;</span>, <span class="number">619992</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;d1b0e19c-9002-40d9-a43c-ae5e7293a7f4&#x27;</span>, <span class="number">619993</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;5ac02554-a877-4d1e-93b1-3f15bb58261c&#x27;</span>, <span class="number">619994</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;36673f68-3c56-4be6-8e09-3d970d5f361e&#x27;</span>, <span class="number">619995</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9d64f853-bd04-4ace-ba14-acc072f19729&#x27;</span>, <span class="number">619996</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;37190885-c1e7-4417-b545-f78130854acf&#x27;</span>, <span class="number">619997</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;fa7dc828-8aeb-45f1-9e80-8843890fd527&#x27;</span>, <span class="number">619998</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6e860c36-00f5-4349-952c-f7c09dfcc263&#x27;</span>, <span class="number">619999</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;e8e6255c-bd9b-4310-af8b-72ab1ce31259&#x27;</span>, <span class="number">620000</span>);</span><br></pre></td></tr></table></figure>

<p>이 SQL문을 그냥 한번에 실행해 주는 역할 정도만 한다는 의미입니다. (생각했던 multi-row insert가 아닌)</p>
<h2 id="JDBC-Options"><a href="#JDBC-Options" class="headerlink" title="JDBC Options"></a>JDBC Options</h2><h3 id="hibernate-jdbc-batch-size"><a href="#hibernate-jdbc-batch-size" class="headerlink" title="hibernate.jdbc.batch_size"></a>hibernate.jdbc.batch_size</h3><p>이 옵션은 몇개의 statement 즉, 하나의 sql이 쌓이면 DB서버로 요청할 지 정하는 단위입니다.<br>예를들어 10으로 정하면</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;b98761f6-5f0b-448c-8f7f-aeffc22032d6&#x27;</span>, <span class="number">619991</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9a740e9c-2249-4c05-9349-9118c5825755&#x27;</span>, <span class="number">619992</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;d1b0e19c-9002-40d9-a43c-ae5e7293a7f4&#x27;</span>, <span class="number">619993</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;5ac02554-a877-4d1e-93b1-3f15bb58261c&#x27;</span>, <span class="number">619994</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;36673f68-3c56-4be6-8e09-3d970d5f361e&#x27;</span>, <span class="number">619995</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9d64f853-bd04-4ace-ba14-acc072f19729&#x27;</span>, <span class="number">619996</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;37190885-c1e7-4417-b545-f78130854acf&#x27;</span>, <span class="number">619997</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;fa7dc828-8aeb-45f1-9e80-8843890fd527&#x27;</span>, <span class="number">619998</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6e860c36-00f5-4349-952c-f7c09dfcc263&#x27;</span>, <span class="number">619999</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> (<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;e8e6255c-bd9b-4310-af8b-72ab1ce31259&#x27;</span>, <span class="number">620000</span>);</span><br></pre></td></tr></table></figure>

<p>이와 같이 sql이 10개가 내부 큐에 쌓이면 전송하는 방식입니다.</p>
<h3 id="hibernate-order-inserts-hibernate-order-updates"><a href="#hibernate-order-inserts-hibernate-order-updates" class="headerlink" title="hibernate.order_inserts, hibernate.order_updates"></a>hibernate.order_inserts, hibernate.order_updates</h3><p>아래와 같은 경우에는 batch insert가 적용되지 않습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeInserts</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">  List&lt;Child&gt; childList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">    <span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parent</span>(...);</span><br><span class="line">    <span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(...);</span><br><span class="line">  </span><br><span class="line">    child.setParent(parent);</span><br><span class="line">    childList.add(child);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  childRepository.saveAll(childList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>내부적으로 parent가 insert되고 child가 insert가 되기 때문에 쓰기지연 SQL 저장소에는 이런식으로 구성이 되어 batch insert가 실행되지 않습니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">6</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">7</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">9</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">9</span>, <span class="number">9</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">10</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>



<p>하지만 <code>hibernate.order_inserts = true</code> 가 적용되면 각각의 insert 구문이 정렬되어 batch insert가 가능해집니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">6</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">7</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">9</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent (id) <span class="keyword">values</span> (<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">9</span>, <span class="number">9</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> child(id, parent_id) <span class="keyword">values</span> (<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>




<h1 id="rewrite-옵션"><a href="#rewrite-옵션" class="headerlink" title="rewrite 옵션"></a>rewrite 옵션</h1><p>정말로 multi-row insert가 지원이 안되나? 하고 찾아보니 jdbc.batch_size 옵션을 사용하면 내부적으로 <code>addBatch()</code> 메서드를 통해 batch로 처리하지만<br>multi-row는 지원되지 않았습니다.  </p>
<p>원하는 multi-row insert를 하기 위해선 jdbcUrl에 아래와 같은 옵션이 추가되어야 합니다.</p>
<ul>
<li><strong>MySQL</strong>  : jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jpa-test?useSSL&#x3D;false&amp; <strong>rewriteBatchedStatements&#x3D;true</strong></li>
<li><strong>PostgreSQL</strong> : jdbc:postgresql:&#x2F;&#x2F;localhost:5432&#x2F;jpa-test?useSSL&#x3D;false&amp; <strong>rewriteBatchedInserts&#x3D;true</strong></li>
</ul>
<p>이 옵션을 추가하면,  connector 레벨에서 insert 구문을 재작성(rewrite) 하게 되어 아래와 같은 형태로 SQL이 재작성됩니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_data (created_at, uuid, id) <span class="keyword">values</span> </span><br><span class="line">(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6c5fe953-ec38-4b26-b2f7-29a389cb8c03&#x27;</span>, <span class="number">619988</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;1959cb84-1dd5-42cc-95c1-8fd501881f1f&#x27;</span>, <span class="number">619989</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;daf8073e-78ea-435c-ac36-ac0796c4c283&#x27;</span>, <span class="number">619990</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;b98761f6-5f0b-448c-8f7f-aeffc22032d6&#x27;</span>, <span class="number">619991</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9a740e9c-2249-4c05-9349-9118c5825755&#x27;</span>, <span class="number">619992</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;d1b0e19c-9002-40d9-a43c-ae5e7293a7f4&#x27;</span>, <span class="number">619993</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;5ac02554-a877-4d1e-93b1-3f15bb58261c&#x27;</span>, <span class="number">619994</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;36673f68-3c56-4be6-8e09-3d970d5f361e&#x27;</span>, <span class="number">619995</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;9d64f853-bd04-4ace-ba14-acc072f19729&#x27;</span>, <span class="number">619996</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;37190885-c1e7-4417-b545-f78130854acf&#x27;</span>, <span class="number">619997</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;fa7dc828-8aeb-45f1-9e80-8843890fd527&#x27;</span>, <span class="number">619998</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;6e860c36-00f5-4349-952c-f7c09dfcc263&#x27;</span>, <span class="number">619999</span>)</span><br><span class="line">,(<span class="string">&#x27;2020-11-22 19:28:05.79&#x27;</span>, <span class="string">&#x27;e8e6255c-bd9b-4310-af8b-72ab1ce31259&#x27;</span>, <span class="number">620000</span>);</span><br></pre></td></tr></table></figure>



<h1 id="주의할-점"><a href="#주의할-점" class="headerlink" title="주의할 점"></a>주의할 점</h1><h2 id="JPA에서-ID-채번-방식을-GenerateType-IDENDITY-사용-시-batch-insert를-할-수-없다"><a href="#JPA에서-ID-채번-방식을-GenerateType-IDENDITY-사용-시-batch-insert를-할-수-없다" class="headerlink" title="JPA에서 ID 채번 방식을 GenerateType.IDENDITY 사용 시 batch insert를 할 수 없다"></a>JPA에서 ID 채번 방식을 GenerateType.IDENDITY 사용 시 batch insert를 할 수 없다</h2><blockquote>
<p>Hibernate disables insert batching at the JDBC level transparently if you use an identity identifier generator.</p>
</blockquote>
<p>Entity의 Id 채번방식을 GenerateType.IDENDITY을 사용하는 경우에는 batch insert가 적용되지 않습니다. (JDBC 레벨에서 차단)<br>실제 insert 시, <code>select last_insert_id()</code> 쿼리를 실행하여 다음에 insert할 ID를 채번해오기 때문에 batch insert를 막는듯 합니다.</p>
<p><strong>따라서 batch insert를 사용하기 위해선 ID 채번방식을 GenerateType.SEQUENCE나 GenerateType.TABLE을 사용해야 합니다.</strong></p>
<h2 id="MySQL의-경우-max-allowed-packet-값을-고려해서-써야한다"><a href="#MySQL의-경우-max-allowed-packet-값을-고려해서-써야한다" class="headerlink" title="MySQL의 경우 max_allowed_packet 값을 고려해서 써야한다."></a>MySQL의 경우 max_allowed_packet 값을 고려해서 써야한다.</h2><p>MySQL의 경우  max_allowed_packet이라는 설정값이 있습니다.<br>이 설정값은 DB server로 보낼 수 있는 최대 요청 packet size입니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_allowed_packet&#x27;</span></span><br></pre></td></tr></table></figure>

<p>위 SQL을 통해 확인 할 수 있으며, 기본적으로  4MB로 설정되어있습니다. </p>
<p>multi-row insert를 하는 경우 row수가 많아지면 max_allowed_packet size를 넘을 수 있기 때문에 적절한 batch_size를 고려해야 합니다.</p>
<h1 id="SequenceGenerator의-채번-방식을-변경해서-사용하라"><a href="#SequenceGenerator의-채번-방식을-변경해서-사용하라" class="headerlink" title="SequenceGenerator의 채번 방식을 변경해서 사용하라"></a>SequenceGenerator의 채번 방식을 변경해서 사용하라</h1><p>MySQL에서 SequenceGenerator의 동작방식은 아래와 같습니다.</p>
<ol>
<li><code>hibernate_sequence</code> 테이블에서 현재 sequence 값 조회 (select next_val from hibernate_sequence)</li>
<li><code>hibernate_sequence</code> 테이블 update (update hibernate_sequence set next_val + 1 where next_val &#x3D; ?)</li>
<li>Entity 객체에 ID를 부여해서 insert</li>
</ol>
<p>이와 같이 사용하는 경우 1개의 ID를 채번하는데 사용되는 query가 2개입니다.  따라서 batch insert를 하더라도 큰 성능 향상을 기대하기 어렵습니다.</p>
<p>이 경우 SequenceGenerator의 optimizer를 변경하여 사용하면 큰 성능 향상을 볼 수 있습니다.  </p>
<p>아래 글을 참고하면 hibernate id generator에 대한 optimizer 설명을 볼 수 있습니다.</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators-optimizer">identifires-generator-optimizer</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://woowabros.github.io/experience/2020/02/06/hikaricp-avoid-dead-lock-2.html">HikariCP Dead lock에서 벗어나기 (실전편)</a></p>
</li>
</ul>
<p>여기서는 간단하게 <code>pooled-lo</code> optimizer를 사용하도록 한 예시를 제공합니다.</p>
<p><img src="./PooledLoOptimizer.png" alt="PooledLoOptimizer"></p>
<p>한번에 일정 범위만큼 채번을 하여 메모리에 저장하여 사용하는 방식입니다.<br>ex) 한번에 1000개만큼 채번 후 <code>(update hibernate_sequence set next_val + 1000 where next_val = ?) </code> 1000개 ID를 메모리에 할당 후 사용</p>
<p>위와 같은 optimizer를 사용하면 1000개의 entity를 insert하는데 1번의 hibernate_sequence에 대한 쿼리가 실행되어 매우 효율적으로 ID채번이 가능합니다.</p>
<h1 id="pooled-lo-optimizer를-적용한-코드"><a href="#pooled-lo-optimizer를-적용한-코드" class="headerlink" title="pooled-lo optimizer를 적용한 코드"></a>pooled-lo optimizer를 적용한 코드</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestData</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO, generator = &quot;test-sequence-generator&quot;)</span></span><br><span class="line">    <span class="meta">@GenericGenerator(</span></span><br><span class="line"><span class="meta">            name = &quot;test-sequence-generator&quot;,</span></span><br><span class="line"><span class="meta">            strategy = &quot;sequence&quot;,</span></span><br><span class="line"><span class="meta">            parameters = &#123;</span></span><br><span class="line"><span class="meta">                    @Parameter(name = SequenceStyleGenerator.SEQUENCE_PARAM, value = SequenceStyleGenerator.DEF_SEQUENCE_NAME),</span></span><br><span class="line"><span class="meta">                    @Parameter(name = SequenceStyleGenerator.INITIAL_PARAM, value = &quot;1&quot;),</span></span><br><span class="line"><span class="meta">                    @Parameter(name = SequenceStyleGenerator.INCREMENT_PARAM, value = &quot;1000&quot;),</span></span><br><span class="line"><span class="meta">                    @Parameter(name = AvailableSettings.PREFERRED_POOLED_OPTIMIZER, value = &quot;pooled-lo&quot;)</span></span><br><span class="line"><span class="meta">            &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Column(name = &quot;uuid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line">    <span class="meta">@Column(name = &quot;created_at&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TestData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = <span class="number">0L</span>;</span><br><span class="line">        <span class="built_in">this</span>.uuid = UUID.randomUUID().toString();</span><br><span class="line">        <span class="built_in">this</span>.createdAt = LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestData <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestData</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="성능-비교"><a href="#성능-비교" class="headerlink" title="성능 비교"></a>성능 비교</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EntityScan</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaBatchTestApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestDataRepository testDataRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(JpaBatchTestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        List&lt;TestData&gt; testDataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            testDataList.add(TestData.create());</span><br><span class="line">        &#125;</span><br><span class="line">        testDataRepository.saveAll(testDataList);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="type">long</span> <span class="variable">totalTimeMillis</span> <span class="operator">=</span> stopWatch.getTotalTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;total time : &quot;</span> + totalTimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>위 코드에 대해 3가지 방식의 설정으로 실행시간을 비교해 보았습니다. (총 10만건 insert)</p>
<ul>
<li>jdbc.batch_size 설정x + rewriteBatchedStatements &#x3D; false<ul>
<li>소요시간: 138,136ms (약 2분)</li>
</ul>
</li>
<li>jdbc.batch_size &#x3D; 20000 + rewriteBatchedStatements &#x3D; false<ul>
<li>소요시간: 52,710ms (약 52초)</li>
</ul>
</li>
<li>jdbc.batch_size &#x3D; 20000 + rewriteBatchedStatements &#x3D; true<ul>
<li>소요시간: 4,667ms (약 4초)</li>
</ul>
</li>
</ul>
<p>+추가) saveAll이 아닌 단건 save의 경우에는?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        List&lt;TestData&gt; testDataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">          testDataRepository.save(TestData.create());</span><br><span class="line">        &#125;</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="type">long</span> <span class="variable">totalTimeMillis</span> <span class="operator">=</span> stopWatch.getTotalTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;total time : &quot;</span> + totalTimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>위의 코드의 경우에는 소요시간이 <code>555,435ms</code> 만큼 소요 되었습니다.</p>
<p>위 성능테스트 비교 결과 <code>jdbc.batch_size + rewriteBatchedStatements = true</code>하는 옵션이 어마어마한 성능차이를 보여줌을 확인하였습니다.</p>
<h1 id="application-yml-설정-코드"><a href="#application-yml-설정-코드" class="headerlink" title="application.yml 설정 코드"></a>application.yml 설정 코드</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/jpa-test?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.mariadb.jdbc.Driver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">jpa-test-hikari-pool</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">jdbc-url:</span> <span class="string">$&#123;spring.datasource.url&#125;</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">$&#123;spring.datasource.username&#125;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">$&#123;spring.datasource.password&#125;</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">$&#123;spring.datasource.driver-class-name&#125;</span></span><br><span class="line">      <span class="attr">data-source-properties:</span></span><br><span class="line">        <span class="attr">rewriteBatchedStatements:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">hibernate:</span></span><br><span class="line">        <span class="attr">format_sql:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">order_inserts:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">order_updates:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">jdbc:</span></span><br><span class="line">          <span class="attr">batch_size:</span> <span class="number">20000</span></span><br><span class="line">        <span class="attr">dialect:</span> <span class="string">org.hibernate.dialect.MySQL57InnoDBDialect</span></span><br><span class="line">    <span class="attr">generate-ddl:</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>HikariCP를 이용하는 경우 <code>spring.datasource.hikari.data-source-properties</code>에 queryString으로 들어갈 properties를 작성할 수 있습니다.</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.baeldung.com/jpa-hibernate-batch-insert-update">https://www.baeldung.com/jpa-hibernate-batch-insert-update</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.plura.io/?p=4493">http://blog.plura.io/?p=4493</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html">https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@jerolba/persisting-fast-in-database-jdbc-76912ec2ef42">https://medium.com/@jerolba/persisting-fast-in-database-jdbc-76912ec2ef42</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP/issues/758">https://github.com/brettwooldridge/HikariCP/issues/758</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators-optimizer">https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators-optimizer</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="2020/08/08/2020-08-08-spring-batch-db-connection-issue/">Spring Batch에서 Chunk 작업이 길어지는 경우 주의할 점</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-08</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Springboot/">Springboot</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Hikari-CP/">Hikari CP</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Spring-Batch/">Spring Batch</a></span><div class="content"><h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>Spring Batch 실행 중 아래와 같은 에러 메세지를 확인 하는 경우 이 글에서 설명하는 case일 수 있습니다.</p>
<ul>
<li>Caused by: java.io.EOFException: unexpected end of stream, read 0 bytes from 4 (socket was closed by server)</li>
<li>org.springframework.transaction.TransactionSystemException: Could not roll back JPA transaction; nested exception is org.hibernate.TransactionException: Unable to rollback against JDBC Connection</li>
<li>Caused by: org.springframework.dao.DataAccessResourceFailureException: PreparedStatementCallback; SQL [UPDATE BATCH_STEP_EXECUTION_CONTEXT SET SHORT_CONTEXT &#x3D; ?, SERIALIZED_CONTEXT &#x3D; ? WHERE STEP_EXECUTION_ID &#x3D; ?]; (conn&#x3D;376) unexpected end of stream, read 0 bytes from 4 (socket was closed by server); nested exception is java.sql.SQLNonTransientConnectionException: (conn&#x3D;376) unexpected end of stream, read 0 bytes from 4 (socket was closed by server)</li>
<li>org.springframework.batch.core.step.FatalStepExecutionException: JobRepository failure forcing rollback</li>
</ul>
<h1 id="상황"><a href="#상황" class="headerlink" title="상황"></a>상황</h1><p>Spring Batch Application을 이용하여 월 단위 데이터 rolling 중 위와 같은 에러메세지를 내며 간헐적으로 배치가 실패하는 case를 발견하였습니다.<br>배치가 실패하는 원인은 chunk 단위로 작업 시, 작업이 길어지는 경우 배치가 실패하는 현상을 발견하였고 아래 항목에 대한 상관관계가 있음을 발견하였습니다.</p>
<ul>
<li>mysql wait_timeout </li>
<li>chunk 단위의 작업시간</li>
</ul>
<p>제가 겪은 case는 chunk단위로 DB를 조회하여 데이터를 rolling하는 작업이었는데 마지막 Page에 대해 조회할 때 slow query가 발생하여<br>chunk의 작업시간이 mysql wait_timeout 시간이 넘어가는 case였습니다.<br>그렇기 때문에 로그로 확인해봐도 마지막 chunk 작업 시, error가 발생하여 배치작업이 실패하는 것을 확인할 수 있었습니다.</p>
<h1 id="Spring-Batch가-하고-있는-일"><a href="#Spring-Batch가-하고-있는-일" class="headerlink" title="Spring Batch가 하고 있는 일"></a>Spring Batch가 하고 있는 일</h1><p>이 글의 내용을 정확히 이해하기 위해서는 Spring Batch라는 framework에서 내부적으로 하는 일을 알아야 합니다.<br>Spring Batch는 배치의 실행 결과 &#x2F; parameter에 대한 meta 정보를 RDB내의 테이블에 내부적으로 저장하고 있습니다.</p>
<ul>
<li>BATCH_JOB_EXECUTION</li>
<li>BATCH_JOB_EXECUTION_CONTEXT</li>
<li>BATCH_JOB_EXECUTION_PARAM</li>
<li>BATCH_JOB_EXECUTION_SEQ</li>
<li>BATCH_JOB_INSTANCE</li>
<li>BATCH_JOB_SEQ</li>
<li>BATCH_STEP_EXECUTION</li>
<li>BATCH_STEP_EXECUTION_CONTEXT</li>
<li>BATCH_STEP_EXECUTION_SEQ</li>
</ul>
<p>이 중에서도 이 글에서 집중해서 봐야할 테이블은 <strong>BATCH_STEP_EXECUTION</strong> 입니다.<br>이 테이블은 STEP 실행에 대한 상태를 담고 있습니다.  </p>
<p>chunk기반 STEP의 경우 chunk 단위 작업이 종료될 때 마다 commit_count, read_count와 같은 상태를 업데이트하고 있습니다.  </p>
<h1 id="Hikari-CP-max-life-time과-MySQL-wait-timeout의-관계"><a href="#Hikari-CP-max-life-time과-MySQL-wait-timeout의-관계" class="headerlink" title="Hikari CP max life time과 MySQL wait_timeout의 관계"></a>Hikari CP max life time과 MySQL wait_timeout의 관계</h1><p><a href="https://jaehun2841.github.io/2020/01/08/2020-01-08-hikari-pool-validate-connection">HikariCP Failed to Validate Connection Warning 이야기</a><br>위 글에 maxLifeTime과 wait_timeout에 대한 자세한 설명이 있으니 참고 부탁드립니다.</p>
<p>간략하게 설명하면</p>
<ul>
<li><strong>HikariCP maxLifeTime</strong>: Connection Pool레벨에서 maxLifeTime이 지나도록 idle 상태인 connection 객체를 pool에서 제거합니다.<br>(GC에 의해 제거 됨)</li>
<li><strong>MySQL wait_timeout</strong>: MySQL DBMS에서 wait_timeout 시간이 지나도록 사용하지 않은 Connection에 대해 Connection 연결을 해제합니다.<ul>
<li>사용하지 않았다는 의미는 Connection을 이용하여 어떠한 Query도 실행하지 않았음을 의미합니다.</li>
</ul>
</li>
</ul>
<p>JDBC4를 지원하는 드라이버에서는 더 이상 SELECT 1과 같은 validateQuery를 이용하여 Connection을 갱신하지 않습니다.<br><strong>따라서 클라이언트의 Connection Pool에서 Connection 객체를 취득하였더라도 어떠한 작업도 하지 않는다면 DBMS입장에서는 아무런 Action도 없는 상태와 마찬가지 입니다.</strong></p>
<h1 id="Connection-객체의-내부"><a href="#Connection-객체의-내부" class="headerlink" title="Connection 객체의 내부"></a>Connection 객체의 내부</h1><p>JDBC 표준으로 만들어진 Connection 클래스 내부에는 DBMS와 TCP socket을 이용하여 연결을 맺을 수 있도록 되어있습니다.<br>기본적으로 Connection 객체 한 개당 1 socket 연결이라고 생각하면 쉽습니다.<br>따라서 Connection 객체가 생길때 마다 MySQL에서 show processlist 명령어를 쳐보면 현재 연결된 session의 정보를 확인할 수 있습니다.</p>
<p>예를들어 Connection Pool 갯수가 10개라면 MySQL에도 똑같이 10개의 session이 맺어진 것을 확인할 수 있습니다.<br><strong>따라서 이 socket이 실제로 DBMS로 Query를 전송하는 통로 역할을 한다고 볼 수 있습니다.</strong></p>
<p><img src="./Connection.png" alt="Connection 객체의 내부"></p>
<h1 id="상황-재현"><a href="#상황-재현" class="headerlink" title="상황 재현"></a>상황 재현</h1><p>상황을 재현하기 위한 조건은 아래와 같이 설정하였습니다.</p>
<ul>
<li>mysql의 global wait_timeout을 30초로 설정<ul>
<li>set GLOBAL wait_timeout &#x3D; 30;</li>
</ul>
</li>
<li>HikariCP의 maxLifeTimeout을 29초로 설정<ul>
<li>spring.datasource.hikari.max-lifetime &#x3D; 29000</li>
</ul>
</li>
<li>HikariCP의 maximum-pool-size를 3개로 설정<ul>
<li>spring.datasource.hikari.maximum-pool-size &#x3D; 3</li>
</ul>
</li>
<li>chunk 단위의 작업시간을 약 50초 정도로 설정<ul>
<li>sleep 명령어를 통해 50초의 Delay를 설정해보았습니다.</li>
</ul>
</li>
</ul>
<h2 id="테스트를-위한-간략한-코드"><a href="#테스트를-위한-간략한-코드" class="headerlink" title="테스트를 위한 간략한 코드"></a>테스트를 위한 간략한 코드</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestJobConfiguration</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> jobBuilderFactory: JobBuilderFactory,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> stepBuilderFactory: StepBuilderFactory</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">testJob</span><span class="params">()</span></span>: Job &#123;</span><br><span class="line">    <span class="keyword">return</span> jobBuilderFactory.<span class="keyword">get</span>(<span class="string">&quot;testJob&quot;</span>)</span><br><span class="line">      .start(testStep())</span><br><span class="line">      .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">testStep</span><span class="params">()</span></span>: Step &#123;</span><br><span class="line">    <span class="keyword">val</span> testList = (<span class="number">1.</span><span class="number">.100_000</span>).map &#123; it &#125;.toList()</span><br><span class="line">    <span class="keyword">return</span> stepBuilderFactory.<span class="keyword">get</span>(<span class="string">&quot;testStep&quot;</span>)</span><br><span class="line">      .chunk&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;(<span class="number">100</span>)</span><br><span class="line">      .reader(DelayedItemReader(testList))</span><br><span class="line">      .writer &#123;</span><br><span class="line">        it.forEach &#123; int -&gt;</span><br><span class="line">          print(<span class="string">&quot;<span class="variable">$int</span> &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      .build()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayedItemReader</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">  items: List&lt;T&gt;</span><br><span class="line">) : ItemReader&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> list: MutableList&lt;T&gt; = items.toMutableList()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    Thread.sleep(<span class="number">500</span>)</span><br><span class="line">    <span class="keyword">return</span> list.removeAt(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>위의 코드에서는 chunk단위가 100개 이며, item 하나를 read하는데 500ms가 소요됩니다.<br>따라서 chunk size만큼 읽는데 총 50초가 소요됩니다.</p>
<h1 id="Transaction-단위-x3D-chunk-단위"><a href="#Transaction-단위-x3D-chunk-단위" class="headerlink" title="Transaction 단위 &#x3D; chunk 단위"></a>Transaction 단위 &#x3D; chunk 단위</h1><p>Spring Batch Framework에서는 chunk 기반 Step에 대해 chunk단위로 Transaction을 보장합니다.  </p>
<p>TaskletStep 내의 doExecute 메서드 내부를 보면 TransactionTemplate을 기반으로 chunk를 실행합니다.</p>
<p><img src="./doInChunkContext.png" alt="doInChunkContext"></p>
<p>아래 코드에서 transactionManager.getTransaction을 통해 transaction을 하나 생성하게되고<br>이 과정에서 HikariPool에서 Connection 객체를 하나 받아옵니다.</p>
<p><img src="./execute_getTransaction.png" alt="execute_getTransaction"></p>
<h1 id="그렇다면-왜-Connection으로-인한-오류가-발생할까요"><a href="#그렇다면-왜-Connection으로-인한-오류가-발생할까요" class="headerlink" title="그렇다면 왜 Connection으로 인한 오류가 발생할까요?"></a>그렇다면 왜 Connection으로 인한 오류가 발생할까요?</h1><h2 id="chunk-시작-시-Transaction-생성으로-인한-Connection-취득"><a href="#chunk-시작-시-Transaction-생성으로-인한-Connection-취득" class="headerlink" title="chunk 시작 시 Transaction 생성으로 인한 Connection 취득"></a>chunk 시작 시 Transaction 생성으로 인한 Connection 취득</h2><p><img src="./getConnection.png" alt="getConnection"></p>
<ol>
<li><p>chunk 단위에 대한 작업 시작 시, transaction 생성으로 인해 Hikari Pool에서 connection을 취득합니다.</p>
</li>
<li><p>Hikari Pool 내부에서는 Active Connection으로 인식하며, 이 Connection은 max-lifetime 시간이 지나도 pool에서 제거되지 않습니다.<br>(이미 사용중이라고 인식하는 Connection이기 때문입니다.)</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-08-08 15:09:10.481 DEBUG 81263 --- [ool housekeeper] com.zaxxer.hikari.pool.HikariPool :  </span><br><span class="line">spring-batch-meta-connection-pool - Pool stats (total=3, active=1, idle=2, waiting=0)</span><br></pre></td></tr></table></figure>

<h2 id="wait-timeout-시간이-지나고-session-제거"><a href="#wait-timeout-시간이-지나고-session-제거" class="headerlink" title="wait_timeout 시간이 지나고 session 제거"></a>wait_timeout 시간이 지나고 session 제거</h2><p><img src="./session-remove.png" alt="session-remove"></p>
<ol>
<li>item read 과정에서 50초동안 meta DB Connection을 사용하여 Query를 실행하지 않으므로 DBMS 입장에서는 connection이 유휴상태입니다.</li>
<li>따라서 wait_timeout 시간인 30초가 경과하면 DBMS에서 session 연결을 제거합니다.</li>
<li>이렇게 되면 <strong>Hikari Connection 객체는 유지되지만 내부 socket 연결은 끊어진 상태라고 볼 수 있습니다.</strong></li>
</ol>
<h2 id="chunk-작업-이후-meta-DB-update-query-실행"><a href="#chunk-작업-이후-meta-DB-update-query-실행" class="headerlink" title="chunk 작업 이후 meta DB update query 실행"></a>chunk 작업 이후 meta DB update query 실행</h2><p><img src="./update-query.png" alt="update-query"></p>
<ol>
<li>50초가 지나고 chunk에 대한 작업이 완료되어 meta db에 있는 <strong>BATCH_STEP_EXECUTION</strong> 테이블에 step 실행 결과를 update 하고자 query를 전송합니다.</li>
<li>하지만 Connection 내의 socket을 사용하려고 하는 순간 이미 socket 연결이 끊어졌기 때문에 쿼리를 DBMS에 실행할 수 없게 됩니다.</li>
<li>따라서 예외가 발생하게 되며 rollback을 수행하려합니다.</li>
<li>하지만 이미 socket이 끊어졌기 때문에 rollback 명령어도 전송하지 못하고 아래의 에러를 내며 batch가 종료됩니다.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.batch.core.step.FatalStepExecutionException: JobRepository failure forcing rollback</span><br><span class="line">	</span><br><span class="line">Caused by: org.springframework.dao.DataAccessResourceFailureException: PreparedStatementCallback; SQL [UPDATE BATCH_STEP_EXECUTION_CONTEXT SET SHORT_CONTEXT = ?, SERIALIZED_CONTEXT = ? WHERE STEP_EXECUTION_ID = ?]; (conn=376) unexpected end of stream, read 0 bytes from 4 (socket was closed by server); nested exception is java.sql.SQLNonTransientConnectionException: (conn=376) unexpected end of stream, read 0 bytes from 4 (socket was closed by server)</span><br><span class="line">	</span><br><span class="line">Caused by: java.io.EOFException: unexpected end of stream, read 0 bytes from 4 (socket was closed by server)</span><br><span class="line">	at org.mariadb.jdbc.internal.io.input.StandardPacketInputStream.getPacketArray(StandardPacketInputStream.java:249) ~[mariadb-java-</span><br><span class="line"></span><br><span class="line">org.springframework.transaction.TransactionSystemException: Could not roll back JPA transaction; nested exception is org.hibernate.TransactionException: Unable to rollback against JDBC Connection</span><br><span class="line">	</span><br><span class="line">Caused by: org.hibernate.TransactionException: Unable to rollback against JDBC Connection</span><br><span class="line">	at </span><br><span class="line">	</span><br><span class="line">Caused by: java.sql.SQLException: Connection is closed</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>Spring Batch를 사용하다 보면 chunk 단위로 작업을 쪼개서 하는 행위를 많이 하게 됩니다.<br>위와 같은 에러로 인한 배치 실패를 경험하지 않기 위해서는 chunk의 작업 수행 시간이 wait_timeout 시간보다 반드시 적게 걸려야 한다는 점을 유의해야할 합니다.</p>
<p>chunk의 작업 시간에 영향을 미치는 것은 아래와 같습니다.</p>
<ul>
<li>read 지연</li>
<li>process 지연</li>
<li>write 지연</li>
</ul>
<p>특히 read 시, slow query와 같은 이슈가 발생할 가능성이 있습니다. 저 또한 그랬고요<br>위의 예시가 많은 분들의 도움이 되길 바랍니다.</p>
<p>테스트 한 코드는 아래 repository를 참고 부탁드립니다.<br><a target="_blank" rel="noopener" href="https://github.com/jaehun2841/spring-batch-connection-close-issue">https://github.com/jaehun2841/spring-batch-connection-close-issue</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="2020/07/25/object-chapter15/">Objects Study - Chapter15. 디자인 패턴과 프레임워크</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-25</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="디자인-패턴"><a href="#디자인-패턴" class="headerlink" title="디자인 패턴"></a>디자인 패턴</h1><p>애플리케이션을 설계하다 보면 어떤 요구사항을 해결하기 위해 과거에 경험했던 유사한 해결방법을 다시금 사용하는 경우가 있다.<br>소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결방법을 <strong>디자인 패턴</strong> 이라고 부른다. </p>
<p>디자인 패턴은 특정한 변경을 일관성 있게 다룰 수 있는 <strong>협력 템플릿</strong> 을 제공한다</p>
<h1 id="프레임워크"><a href="#프레임워크" class="headerlink" title="프레임워크"></a>프레임워크</h1><p>설계와 코드를 함께 재사용하기 위한 것을 <strong>프레임워크</strong> 라고 부른다.<br>프레임워크는 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.<br>프레임워크에서 제공하는 아키텍처가 적합하다면 다양한 환경에서 테스트를 거친 견고한 구현 코드를 쉽고 빠르게 재사용할 수 있다.<br>프레임워크는 각 애플리케이션의 요구에 따라 적절하게 커스터마이징할 수 있는 확장 포인트를 제공한다</p>
<p>프레임워크는 일관성 있게 다룰 수 있는 <strong>확장 가능한 코드 템플릿</strong> 을 제공한다.</p>
<h1 id="소프트웨어-패턴"><a href="#소프트웨어-패턴" class="headerlink" title="소프트웨어 패턴"></a>소프트웨어 패턴</h1><p>패턴이랑 무엇인가를 논의할 때면 반복적으로 언급되는 몇 가지 핵심적인 특징이 있다.</p>
<ul>
<li>패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.</li>
<li>패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다.</li>
<li>패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.</li>
<li>패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.</li>
</ul>
<blockquote>
<p>마틴 파울러의 &lt;Analysis Pattern&gt;</p>
<p>패턴 정의는 하나의 실무 컨텍스트에서 유용하게 사용해왔고 다른 실무 컨텍스트에서도 유용할 것이라고 예상되는 아이디어다<br>아이디어라는 용어를 사용하는 이유는 어떤 것도 패턴이 될 수 있기 때문이다.<br>협력하는 객체그룹이 될 수도 있고, 프로젝트의 조직 원리가 될 수도 있다.<br>실무 컨텍스트라는 용어는 패턴이 실제 프로젝트의 실무 경험에서 비록됐다는 사실을 반영한다.</p>
</blockquote>
<p>패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 <strong>아이디어</strong> 이다.<br>일반적으로 패턴으로 인정하기 위해서는 최소 3가지의 서로 다른 시스템에 특별한 문제 없이 적용할 수 있고, 유용한 경우에만 패턴으로 간주할 수 있다.</p>
<h2 id="패턴은-경험의-산물이다"><a href="#패턴은-경험의-산물이다" class="headerlink" title="패턴은 경험의 산물이다."></a>패턴은 경험의 산물이다.</h2><p>패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점이다.  </p>
<p>패턴은 경험의 산물이다.<br>따라서 실무 경험이 적은 초보자라고 하더라고 패턴을 익히고 반복적으로 적용하는 과정 속에서 유연하고 품질 높은 소프트웨어를 개발하는 방법을 익힐 수 있게 된다.</p>
<h2 id="패턴의-이름은-높은-수준의-대화를-가능하게-한다"><a href="#패턴의-이름은-높은-수준의-대화를-가능하게-한다" class="headerlink" title="패턴의 이름은 높은 수준의 대화를 가능하게 한다."></a>패턴의 이름은 높은 수준의 대화를 가능하게 한다.</h2><p>패턴을 모르는 사람은 아래 처럼 말 뜻을 풀어서 어렵고 길게 말한다<br><strong>“인터페이스를 하나 추가하고 이 인터페이스를 구체화하는 클래스를 만들고 생성자나 setter 메서드를 통해 runtime에 알고리즘을 바꿀 수 있게 하자”</strong> </p>
<p>패턴을 아는 사람은<br><strong>“STRATEGY 패턴 적용하시죠”</strong> 라고 간단하고 명확하게 말할 수 있기 때문이다.</p>
<h1 id="패턴-분류"><a href="#패턴-분류" class="headerlink" title="패턴 분류"></a>패턴 분류</h1><p>패턴을 분류하는 가장 일반적인 방법은 패턴의 범위나 적용 단계에 따라 4가지로 분류된다.</p>
<ul>
<li>디자인 패턴(Design Pattern)<ul>
<li>특정 상황 내에서 일반적인 설계 문제를 해결하며 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다</li>
<li>특정한 설계문제를 해결하는 것을 목적으로 함</li>
<li>프로그래밍 언어나 패러다임에 독립적이다</li>
</ul>
</li>
<li>아키텍처 패턴 (Architecture Pattern)<ul>
<li>소프트웨어의 전체적인 구조를 결정하기 위해 사용</li>
<li>미리 정의된 서브시스템들을 제공하고 서브시스템들의 책임, 관계를 조직화하는 규칙과 가이드를 제공한다</li>
</ul>
</li>
<li>분석 패턴(Analysis Pattern)<ul>
<li>도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다</li>
<li>업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합</li>
</ul>
</li>
<li>이디엄(Idiom)<ul>
<li>특정 프로그래밍 언어에만 국한된 패턴이다</li>
<li>주어진 언어의 기능&#x2F;특성을 이용해 컴포넌트 간의 특정 측면을 구현하는 방법을 서술<ul>
<li>C++에서는 객체가 스스로 자신을 참조하는 객체들의 개수를 카운트 해서 더 이상 자신이 참조되지 않으면 스스로를 삭제하는 COUNT POINTER라는 이디엄이 있다.</li>
<li>하지만 JVM기반의 언어에서는 참조 되지 않은 객체들은 가비지 컬렉터에 의해 자동으로 삭제되기에 COUNT POINTER 이디엄은 유용하지 않다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="자주-쓰이는-디자인-패턴"><a href="#자주-쓰이는-디자인-패턴" class="headerlink" title="자주 쓰이는 디자인 패턴"></a>자주 쓰이는 디자인 패턴</h1><p>패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.<br>패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공한다</p>
<h2 id="STRATEGY-Pattern"><a href="#STRATEGY-Pattern" class="headerlink" title="STRATEGY Pattern"></a>STRATEGY Pattern</h2><p>STRATEGY Pattern은 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공한다</p>
<ul>
<li>로직내의 변하지 않는 부분을 추상화 하여 추상클래스나 인터페이스로 분리한다</li>
<li>구체적인 내용은 구체 클래스를 구현하여 메세지를 정의한다</li>
</ul>
<p><img src="./pay.png" alt="STRATEGY Pattern"></p>
<h2 id="BRIDGE-Pattern"><a href="#BRIDGE-Pattern" class="headerlink" title="BRIDGE Pattern"></a>BRIDGE Pattern</h2><p>BRIDGE Pattern은 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해하여<br>설계를 확장 가능하게 만든다.</p>
<p><img src="./BRIDGE_Pattern.png" alt="BRIDGE Pattern"></p>
<h2 id="COMPOSITE-Pattern"><a href="#COMPOSITE-Pattern" class="headerlink" title="COMPOSITE Pattern"></a>COMPOSITE Pattern</h2><p>COMPOSITE Pattern은 객체들을 트리구조로 구성하여 그릇 객체와 내용물 객체를 동일하게 취급할 수 있도록 만들기 위한 패턴</p>
<p><img src="./COMPOSITE_Pattern.jpeg" alt="COMPOSITE Pattern"></p>
<h2 id="TEMPLATE-METHOD-Pattern"><a href="#TEMPLATE-METHOD-Pattern" class="headerlink" title="TEMPLATE METHOD Pattern"></a>TEMPLATE METHOD Pattern</h2><p>TEMPLATE METHOD Pattern은 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 내용은 자식 클래스에서 정의하게 함으로써 변경을 캡슐화할 수 있는 디자인 패턴이다</p>
<p><img src="./TEMPLATE_METHOD_Pattern.jpeg" alt="TEMPLATE METHOD Pattern"></p>
<ul>
<li><p>calculateFee 메서드에서 추상 메서드인 calculateDiscountAmount() 메서드를 호출한다</p>
</li>
<li><p>추상 메서드 calculateDiscountAmount는 하위 클래스인 AmountDiscoutMovie, PercentDiscoutMovie 에서 직접 구현한다</p>
</li>
<li><p>그렇게 하면 calculateFee 메서드는 변경없이 사용할 수 있고 calculateDiscountAmount 메서드를 통해 기능을 확장할 수 있다.</p>
</li>
</ul>
<h2 id="DECORATOR-Pattern"><a href="#DECORATOR-Pattern" class="headerlink" title="DECORATOR Pattern"></a>DECORATOR Pattern</h2><p>DECORATOR Pattern은 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 이용한다.</p>
<p><img src="./DECORATOR_Pattern.jpeg" alt="DECORATOR Pattern"></p>
<ul>
<li>BasicRatePolicy는 실제 역할을하는 ConcreteComponent이다</li>
<li>AdditionalRatePolicy는 요건들을 더 추가할 수 있는 Decorator이다</li>
</ul>
<h1 id="코드-재사용과-설계-재사용"><a href="#코드-재사용과-설계-재사용" class="headerlink" title="코드 재사용과 설계 재사용"></a>코드 재사용과 설계 재사용</h1><p>코드 재사용, 설계 재사용 한쪽만 남용하는 방법은 좋지 않다.<br>가장 이상적인 재사용 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것이다.  </p>
<p>프레임워크란 </p>
<ul>
<li>추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계</li>
<li>애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 application skeleton  <strong>(설계와 코드 재사용)</strong></li>
</ul>
<p>프레임워크는 코드를 재사용함으로써 설계 아이디어를 재사용한다.<br>프레임워크는 애플리케이션의 아키텍처를 제공하며 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함한다.<br>애플리케이션을 확장할 수 있도록 부분적으로 구현된 추상 클래스와 인터페이스 집합뿐만 아니라 추가적인 작업 없이도 재사용 가능한 다양한 종류의 컴포넌트도 함께 제공한다</p>
<h1 id="제어-역전-원리"><a href="#제어-역전-원리" class="headerlink" title="제어 역전 원리"></a>제어 역전 원리</h1><p>의존성 역전 원리는 전통적인 설계 방법과 객체지향을 구분하는 가장 핵심적인 원리다.<br>의존성 역전 원리에 따라 구축되지 않은 시스템은 협력 흐름을 재사용할 수도 없으며 변경에 유연하게 대처할 수도 없다.<br>시스템이 진화하는 방향에는 항상 의존성 역전 원리를 따르는 설계가 존재해야 한다.<br>만약 요구사항이 빠르게 진화하는 코드에서 의존성 역전 원리가 적절하게 지켜지지 않고 있다면 그곳에는 변경을 적절하게 수용할 수 없는 하향식 코드만 남을 뿐이다.</p>
<p>프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다<br>그리고 이렇게 <strong>완성되지 않은 채로 남겨진 동작을 훅(Hook)</strong> 이라고 부른다<br>훅은 프레임워크 코드에서 호출하는 프레임워크의 특정 부분이다. 재정의된 훅은 제어 역전 원리에 따라 프레임워크가 원하는 시점에 호출 된다.</p>
<p><strong>여기서 협력을 제어하는 것은 프레임워크이다.</strong><br>이 말 자체가 제어 역전 원리이다.<br>전통적인 방식에서는 개발자가 개발한 코드를 실행하기 위해서는 개발자가 직접 객체를 생성해서 메시지를 객체에 날려야 했다.<br>하지만 <strong>프레임워크에서는 프레임워크 내의 코드가 개발자가 개발한 코드를 실행한다.</strong></p>
<p>이러한 제어의 역전이 프레임워크의 핵심 개념이자 코드의 재사용을 가능하게 하는 힘이다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - chapter15. 디자인 패턴과 프레임워크</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="2020/07/18/object-chapter13/">Objects Study - Chapter13. 서브클래싱과 서브타이핑</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-18</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="상속의-용도"><a href="#상속의-용도" class="headerlink" title="상속의 용도"></a>상속의 용도</h1><ul>
<li>타입 계층 구현 : 부모클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다.<ul>
<li>부모 클래스는 자식 클래스의 <strong>일반화(generalization)</strong></li>
<li>자식 클래스는 부모 클래스의 <strong>특수화(specialization)</strong></li>
</ul>
</li>
<li>코드 재사용<ul>
<li>간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있다.</li>
<li>재사용을 위해 상속을 사용하는 경우 부모 클래스와 자식 클래스가 강하게 결합되어 변경이 어렵다.</li>
</ul>
</li>
</ul>
<p>상속을 사용하는 이유는 객체의 <strong>행동</strong> 을 기반으로 하는 타입 계층을 구현해야 한다.<br>타입 사이의 관계를 고려하지 않은 채 단순히 코드를 재사용하기 위해 상속을 사용해서는 안된다.</p>
<h1 id="객체지향-프로그래밍-vs-객체기반-프로그래밍"><a href="#객체지향-프로그래밍-vs-객체기반-프로그래밍" class="headerlink" title="객체지향 프로그래밍 vs 객체기반 프로그래밍"></a>객체지향 프로그래밍 vs 객체기반 프로그래밍</h1><ul>
<li>객체기반 프로그래밍(Object-Based Programming)<ul>
<li>상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식</li>
<li>상속과 다형성은 지원하지 않는다</li>
<li>초기 버전의 비쥬얼 베이직은 객체라는 개념은 존재하지만 클래스 사이의 상속과 다형성은 존재x</li>
<li>클래스를 사용하지 않고 객체만 사용하는 프로그래밍 방식</li>
</ul>
</li>
<li>객체지향 프로그래밍(Object-Oriented Programming)<ul>
<li>객체기반 프로그래밍의 한 종류</li>
<li>상속과 다형성을 지원</li>
<li>Java, C++, 루비, C#등의 언어는 상속과 다형성 지원’</li>
<li>클래스를 사용하는 프로그래밍 방식</li>
</ul>
</li>
</ul>
<h1 id="타입"><a href="#타입" class="headerlink" title="타입"></a>타입</h1><p>객체지향 프로그래밍에서 타입의 의미를 이해하려면 두 가지 관점의 타입을 이해할 필요가 있다</p>
<ul>
<li>프로그래밍 언어 관점의 타입</li>
<li>개념 관점의 타입</li>
</ul>
<h2 id="개념-관점의-타입"><a href="#개념-관점의-타입" class="headerlink" title="개념 관점의 타입"></a>개념 관점의 타입</h2><p>개념 관점에서 타입이란 우리가 인지하는 세상의 사물의 종류를 의미한다.  </p>
<ul>
<li><strong>타입</strong> : 객체들에 적용하는 개념이나 아이디어<ul>
<li>타입은 사물을 분류하기 위한 틀로 사용된다.  </li>
<li>예를 들어 자바, 루비, 자바스크립트, C를 프로그래밍 언어라고 부를 때 우리는 이것들을 프로그래밍 언어라는 타입으로 분류하고 있는 것이다.</li>
</ul>
</li>
<li><strong>인스턴스</strong> : 어떤 대상이 타입으로 분류될 때의 대상을 가리켜 인스턴스라고 부른다.</li>
<li><strong>객체</strong> : 일반적으로 타입의 인스턴스를 가리켜 객체라고 부른다.</li>
<li><strong>심볼</strong> : 타입에 이름을 붙인 것.</li>
<li><strong>내연(intension)</strong> : 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동<ul>
<li>예를 들어 프로그래밍 언어의 정의인 <strong>컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합</strong> 이 바로 내연이다.</li>
</ul>
</li>
<li><strong>외연(extension)</strong> : 타입에 속하는 객체들의 집합<ul>
<li>예를들어 프로그래밍 언어 타입의 경우에는 자바, 루비, 자바스크립트, C가 속한 집합이 외연을 구성한다.</li>
</ul>
</li>
</ul>
<h2 id="프로그래밍-언어-관점의-타입"><a href="#프로그래밍-언어-관점의-타입" class="headerlink" title="프로그래밍 언어 관점의 타입"></a>프로그래밍 언어 관점의 타입</h2><p>프로그래밍 언어 관점에서의 타입은 연속적인 비트의 의미와 제약을 부여하기 위해 사용된다.<br>비트에 담긴 데이터를 문자열로 다룰지 정수로 다룰지는 전적으로 데이터를 사용하는 애플리케이션에 의해 결정된다.<br>따라서 프로그래밍 언어의 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 가리킨다.</p>
<p>프로그래밍 언어에서 타입은 두 가지 목적을 위해 사용된다.</p>
<h3 id="타입에-수행될-수-있는-유효한-오퍼레이션의-집합을-정의한다"><a href="#타입에-수행될-수-있는-유효한-오퍼레이션의-집합을-정의한다" class="headerlink" title="타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다"></a>타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다</h3><ul>
<li>자바에서 ‘+’ 연산자는 <strong>원시형 숫자 타입이나 문자열 타입의 객체에서는 사용할 수 있지만</strong> 다른 클래스의 인스턴스에 대해서는 사용할 수 없다. </li>
<li>C++ &#x2F; C# 에서는 연산자 오버로딩을 통해 ‘+’ 연산자 사용이 가능하다</li>
<li>모든 객체지향 언어들은 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한함으로써 프로그래머의 실수를 막아준다.</li>
</ul>
<h3 id="타입에-수행되는-오퍼레이션에-대해-미리-약속된-문맥을-제공한다"><a href="#타입에-수행되는-오퍼레이션에-대해-미리-약속된-문맥을-제공한다" class="headerlink" title="타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다"></a>타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다</h3><ul>
<li><p>정수 a + b는 a와 b를 더한다. 문자열 a + b는 a와 b에 대해 문자열을 합친다 -&gt; 즉, a 와 b에 부여된 타입이 ‘+’ 연산자의 문맥을 정의</p>
</li>
<li><p>new 연산자는 타입에 정의된 크기만큼 저장 공간을 할당하고 생성된 객체를 초기화하기 위해 타입의 생성자를 자동으로 호출한다<br>이 경우 객체를 생성하는 방법에 대한 문맥을 결정하는 것은 바로 객체의 타입이다.</p>
</li>
</ul>
<h2 id="객체지향-패러다임에서-바라-보는-프로그래밍-언어-관점의-타입"><a href="#객체지향-패러다임에서-바라-보는-프로그래밍-언어-관점의-타입" class="headerlink" title="객체지향 패러다임에서 바라 보는 프로그래밍 언어 관점의 타입"></a>객체지향 패러다임에서 바라 보는 프로그래밍 언어 관점의 타입</h2><p>프로그래밍 언어 관점에서의 타입은 호출 가능한 오퍼레이션의 집합을 정의한다.<br><strong>객체지향 프로그래밍에서 오퍼레이션 &#x3D; 객체가 수신할 수 있는 메시지</strong> 이다</p>
<p>객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의하는 것이다.<br><strong>객체가 수신할 수 있는 메시지 &#x3D; 객체의 퍼블릭 인터페이스</strong> 이다</p>
<p>따라서 객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다</p>
<h2 id="객체지향-패러다임에서-바라-보는-개념-관점의-타입"><a href="#객체지향-패러다임에서-바라-보는-개념-관점의-타입" class="headerlink" title="객체지향 패러다임에서 바라 보는 개념 관점의 타입"></a>객체지향 패러다임에서 바라 보는 개념 관점의 타입</h2><p>개념 관점에서 타입은 공통의 특성을 가진 객체들을 분류하기 위한 기준이다.<br>객체의 퍼블릭 인터페이스가 타입을 결정한다.  따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.<br><strong>객체들이 동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르면, 서로 다른 타입으로 분류된다.</strong></p>
<h1 id="타입-사이의-포함관계"><a href="#타입-사이의-포함관계" class="headerlink" title="타입 사이의 포함관계"></a>타입 사이의 포함관계</h1><p>수학에서 집합은 다른 집합을 포함할 수 있다.<br>타입 역시 객체들의 집합이기 때문에 다른 타입을 포함하는 것이 가능하다<br>타입 안에 포함된 객체들은 좀 더 상세한 기준으로 묶어 새로운 타입을 정의하면 이 새로운 타입은 자연스럽게 기존 타입의 부분 집합이 된다.</p>
<p><img src="./programming-type-instance.jpeg" alt="programming-type-instance"><br>예를 들면 자바, 루비, C++과 같은 프로그래밍 언어들은 <strong>프로그래밍 언어</strong> 라는 타입으로 묶을 수 있다.</p>
<p><img src="./classified-instance.jpeg" alt="classified-instance"></p>
<p>집합의 원소들을 상세한 기준으로 분류할 수 있다. </p>
<ul>
<li>객체지향 언어</li>
<li>클래스기반 언어 : 자바, C++, 루비 </li>
<li>프로토타입 기반 언어: 자바스크립트, 셀프</li>
<li>절차적 언어: C, 파스칼</li>
</ul>
<p>프로그래밍 언어 타입은 <strong>객체지향 언어</strong> 타입과 <strong>절차적 언어</strong> 로 분류할 수 있다.<br>나아가 객체지향 언어타입의 자바와 루비는 <strong>클래스 기반 언어</strong> 자바스크립트는 <strong>프로토타입 기반 언어</strong> 로 분류할 수 있다.  </p>
<p>타입이 다른 타입에 포함될 수 있기 때문에 동일한 인스턴스가 하나 이상의 타입으로 분류되는 것도 가능하다<br>자바는 <strong>프로그래밍 언어</strong> 인 동시에 <strong>객체지향 언어</strong> 에 속하며 더 세부적으로 <strong>클래스 기반 언어</strong> 타입에 속한다</p>
<p>다른 타입을 포함하는 타입은 포함되는 타입보다 좀 더 일반화된 의미를 표현할 수 있다.<br><strong>프로그래밍 언어</strong> 타입은 <strong>객체지향 언어</strong> 타입보다 더 일반적이고 <strong>객체지향 언어</strong> 타입은 <strong>클래스 기반 언어</strong> 보다 더 일반적이다.</p>
<p>포함하는 타입은 외연 관점에서는 더 크고 내연 관점에서는 더 일반적이다.<br>포함되는 타입은 외원 관점에서는 더 작고 내연 관점에서는 더 특수하다.<br>이것은 포함 관계로 연결된 타입 사이에 개념적으로 <strong>일반화(generalization)와 특수화(specialization)</strong> 관계가 존재한다는 것을 의미한다.</p>
<h2 id="타입-계층"><a href="#타입-계층" class="headerlink" title="타입 계층"></a>타입 계층</h2><p><img src="./type-tree.jpeg" alt="type-tree"></p>
<p>타입 계층을 표현할 때는 더 일반적인 타입을 위쪽에 더 특수한 타입을 아래쪽에 배치하는 것이 관례다.  </p>
<ul>
<li><p><strong>슈퍼타입(supertype)</strong> : 타입계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입</p>
<ul>
<li>프로그래밍 언어 타입은 객체지향 언어, 절차적 언어의 슈퍼타입이다.</li>
</ul>
</li>
<li><p><strong>서브타입(subtype)</strong> : 타입계층을 구성하는 두 타입 간의 관계에서 더 특수한 타입</p>
</li>
</ul>
<h2 id="내연과-외연-관점에서의-일반화와-특수화"><a href="#내연과-외연-관점에서의-일반화와-특수화" class="headerlink" title="내연과 외연 관점에서의 일반화와 특수화"></a>내연과 외연 관점에서의 일반화와 특수화</h2><ul>
<li>내연 관점<ul>
<li>일반화 : 어떤 타입의 정의를 좀 더 보편적이고 추상적으로 만드는 과정</li>
<li>특수화 : 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정</li>
</ul>
</li>
<li>외연 관점<ul>
<li>일반화 : 특수한 타입의 인스턴스 집합을 표현하는 슈퍼셋(superset)</li>
<li>특수화 : 일반적인 타입의 인스턴스 집합에 포함된 서브셋(subset)</li>
</ul>
</li>
</ul>
<blockquote>
<p>일반화는 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 행위의 결과<br>특수화는 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 행위의 결과</p>
</blockquote>
<ul>
<li>슈퍼타입(superset)<ul>
<li>집합이 다른 집합의 모든 멤버를 포함한다</li>
<li>타입 정의가 다른 타입보다 좀 더 일반적이다</li>
</ul>
</li>
<li>서브타입(subset)<ul>
<li>집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다</li>
<li>타입 정의가 다른 타입보다 좀 더 구체적이다</li>
</ul>
</li>
</ul>
<h1 id="객체지향-프로그래밍과-타입-계층"><a href="#객체지향-프로그래밍과-타입-계층" class="headerlink" title="객체지향 프로그래밍과 타입 계층"></a>객체지향 프로그래밍과 타입 계층</h1><p>객체의 타입을 결정하는 것은 퍼블릭 인터페이스다<br>일반적인 타입이란 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.  </p>
<p>퍼블릭 인터페이스의 관점에서 슈퍼타입과 서브타입을 다음과 같이 정의할 수 있다. </p>
<ul>
<li><p><strong>슈퍼타입</strong> 이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화 시켜 상대적으로 범용적이고 <strong>넓은 의미</strong> 로 정의한 것이다.</p>
</li>
<li><p><strong>서브타입</strong> 이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화 시켜 상대적으로 범용적이고 <strong>좁은 의미</strong> 로 정의한 것이다.</p>
</li>
</ul>
<h1 id="서브클래싱과-서브타이핑"><a href="#서브클래싱과-서브타이핑" class="headerlink" title="서브클래싱과 서브타이핑"></a>서브클래싱과 서브타이핑</h1><p>객체지향 프로그래밍 언어에서 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것이다.<br>그리고 타입 계층을 구현하는 일반적인 방법은 상속을 이용하는 것이다.  </p>
<ul>
<li>슈퍼타입 : 부모 클래스</li>
<li>서브타입 : 자식 클래스</li>
</ul>
<h2 id="언제-상속을-사용해야-하는가"><a href="#언제-상속을-사용해야-하는가" class="headerlink" title="언제 상속을 사용해야 하는가?"></a>언제 상속을 사용해야 하는가?</h2><p>아래 질문에 모두 yes라고 답할 수 있을때만 상속을 사용한다</p>
<ul>
<li>상속관계가 is-a 관계를 모델링하는가?<ul>
<li>일반적으로 <strong>자식 클래스 is 부모 클래스</strong> 라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.</li>
</ul>
</li>
<li>클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?<ul>
<li>상속 계층을 사용하는 클라이언트 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다.</li>
<li>이를 자식 클래스와 부모 클래스 사이의 <strong>행동 호환성</strong> 이라 부른다.</li>
</ul>
</li>
</ul>
<p>중요한 점은 <strong>클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?</strong> 이 질문에 포커스를 맞춰야 한다.<br>클라이언트 관점에서 두 클래스에 대해 기대하는 <strong>행동</strong> 이 다르라면 is-a 관계가 성립하더라도 상속을 사용해서는 안된다.</p>
<h2 id="is-a-관계"><a href="#is-a-관계" class="headerlink" title="is-a 관계"></a>is-a 관계</h2><p>두 클래스가 어휘적으로 <strong>is-a</strong> 관계를 모델링할 경우에만 상속을 사용해야 한다<br>하지만 is-a 관계가 직관적이고 명확하지는 않다  </p>
<p>다음의 예는 is-a 관계가 직관적이지 않음을 보여주는 예시이다</p>
<ul>
<li>펭귄은 새다</li>
<li>새는 날 수 있다</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;....&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Penguin</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>펭귄은 분명 새지만 날 수 없는 새이다. 하지만 코드에서는 <strong>펭귄은 새이고 날 수 있다</strong> 라고 표현되고 있다.<br>이 예는 어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다는 사실을 잘 보여준다.<br>어휘적으로는 펭귄은 새지만 만약 새의 정의에 날 수 있다는 행동이 포함된다면 펭귄은 새의 서브타입이 될 수 없다.  </p>
<p>타입 계층의 의미는 <strong>행동</strong> 이라는 문맥에 따라 달라질 수 있다.<br>따라서 슈퍼타입과 서브타입 관계에서는 is-a보다 행동 호환성이 더 중요하다</p>
<h2 id="행동-호환성"><a href="#행동-호환성" class="headerlink" title="행동 호환성"></a>행동 호환성</h2><p>타입 사이에 개념적으로 어떤 연관성이 있다고 하더라도 행동에 연관성이 없다면 is-a 관계를 사용하지 말아야 한다.<br>결론은 두 타입 사이에 행동이 호환되는 경우에만 타입 계층으로 묶어야 한다.  </p>
<p>행동의 호환 여부를 판단하는 기준은 <strong>클라이언트 관점</strong> 이다.<br>클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.<br>하지만 클라이언트가 두 타입이 동일하게 행동하지 않을 것이라고 기대한다면 두 타입을 타입 계층으로 묶어서는 안된다.</p>
<h2 id="인터페이스-분리-원칙-ISP"><a href="#인터페이스-분리-원칙-ISP" class="headerlink" title="인터페이스 분리 원칙 (ISP)"></a>인터페이스 분리 원칙 (ISP)</h2><p>클라이언트에 따라 인터페이스를 분리하면 변경에 대한 영향을 더 세밀하게 제어할 수 있다.<br>대부분의 경우 인터페이스는 <strong>클라이언트의 요구가 바뀜에 따라 변경된다</strong><br>클라이언트에 따라 인터페이스를 분리하면 각 클라이언트의 요구가 바뀌더라도 영향의 파급효과를 효과적으로 제어할 수 있게 된다.  </p>
<p>이처럼 <strong>인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어</strong> 하는 설계 원칙을<br><strong>인터페이스 분리 원칙(Interface Segregation Principle, ISP)</strong> 라고 한다.</p>
<p><strong>비대한 인터페이스</strong></p>
<ul>
<li>비대한 인터페이스를 가지는 클래스는 응집성이 없는 인터페이스를 가지는 클래스이다.  </li>
<li>이런 클래스의 인터페이스는 메서드의 그룹으로 분해될 수 있고, 각 그룹은 각기 다른 클라이언트 집합을 지원한다.</li>
</ul>
<p><strong>비대한 클래스</strong> </p>
<ul>
<li>클라이언트 사이에 이상하고 해로운 결합이 생기게 만든다</li>
<li>클라이언트가 비대한 클래스에 변경을 가하면 나머지 모든 클래스가 영향을 받는다</li>
</ul>
<p><strong>비대한 인터페이스의 단점 해결하기</strong></p>
<ul>
<li>클라이언트는 자신이 실제로 호출하는 메서드에만 의존해야 한다.</li>
<li>비대한 클래스의 인터페이스를 여러개로 분리함으로써 해결할 수 있다.</li>
<li>호출되지 않는 메서드에 대한 클라이언트의 의존성을 끊고 클라이언트가 서로에 대해 독립적이 되게 만들 수 있다.</li>
</ul>
<h1 id="서브클래싱과-서브-타이핑"><a href="#서브클래싱과-서브-타이핑" class="headerlink" title="서브클래싱과 서브 타이핑"></a>서브클래싱과 서브 타이핑</h1><ul>
<li><strong>서브클래싱(subclassing)</strong> : 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우<ul>
<li>자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.</li>
<li>구현상속(implementation inheritance) 또는 클래스 상속 (class inheritance)이라고 부른다</li>
</ul>
</li>
<li><strong>서브타이핑(subtyping)</strong> : 타입 계층을 구성하기 위해 상속을 사용하는 경우<ul>
<li>자식클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.</li>
<li>서브타이핑을 인터페이스 상속 (interface inheritance) 이라고 한다</li>
<li>서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다</li>
<li>행동 호환성을 만족 시켜야 한다.</li>
</ul>
</li>
</ul>
<p>슈퍼타입과 서브타입 사이의 관계에서 가장 중요한 것은 <strong>퍼블릭 인터페이스</strong> 이다.<br>슈퍼타입 인스턴스를 요구하는 모든 곳에서 서브타입의 인스턴스를 대신 사용하기 위해 만족해야 하는 최소한의 조건은 서브타입의 퍼블릭 인터페이스가 슈퍼 타입에서 정의한 퍼블릭 인터페이스와 동일하거나 더 많은 오퍼레이션을 포함해야 한다.<br>따라서 개념적으로 서브타입이 슈퍼타입의 퍼블릭 인터페이스를 상속받는 것 처럼 보이게 된다.</p>
<h1 id="리스코프-치환-원칙"><a href="#리스코프-치환-원칙" class="headerlink" title="리스코프 치환 원칙"></a>리스코프 치환 원칙</h1><p>바바라 리스코프는 올바른 상속 관계의 특징을 정의하기 위해 <strong>리스코프 치환 원칙(Liskov Substitution Principle, LSP)</strong> 을 발표했다.<br>상속 관계로 연결한 두 클래스가 서브타이핑 관계를 만족시키기 위해서는 다음의 조건을 만족해야 한다.</p>
<blockquote>
<p>S형의 각 객체 o1에 대해 T형의 객체 o2가 하나 있고,<br>T에 의해 정의된 모든 프로그램 P에서 T가 S로 치환될 때 P의 동작이 변하지 않으면 S는 T의 서브타입이다.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S o1 = new S();</span><br><span class="line">T o2 = new T();</span><br><span class="line"> </span><br><span class="line">P(o1); //정상</span><br><span class="line">P(o2); //정상 </span><br></pre></td></tr></table></figure>

<p>리스코프 치환 원칙을 정리하면 <strong>서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다</strong><br>클라이언트가 차이점을 인식하지 못한 채 파생 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다는 것이다.<br>리스코프 치환 원칙은 <strong>행동 호환성</strong>을 설계 원칙으로 정리한 것이다.</p>
<p>따라서 <strong>행동호환성을 유지함으로써 부모 클래스를 대체할 수 있도록 구현된 상속 관계</strong>만을 서브타이핑이라고 해야한다.<br>Stack과 Vector는 리스코프 치환 원칙을 위반하는 전형적인 예이다. </p>
<h2 id="Stack과-Vector"><a href="#Stack과-Vector" class="headerlink" title="Stack과 Vector"></a>Stack과 Vector</h2><p>클라이언트가 부모 클래스인 Vector에 대해 기대하는 행동을 Stack에서는 기대할 수 없기 때문에 행동 호환성을 만족 시키지 않는다.<br>Vector와 Stack는 Vector의 코드를 재사용하는 목적만으로 상속을 사용했기 때문에 서브클래싱 관계이다.</p>
<p>리스코프 치환 원칙을 위반하는 가장 큰 이유는 상속으로 인해 Stack에 포함돼서는 안 되는 Vector의 퍼블릭 인터페이스가 Stack의 퍼블릭 인터페이스에 포함됐기 때문이다.<br>Vector를 사용하는 클라이언트의 관점에서 Stack의 행동은 Vector의 행동과 호환되지 않는다.</p>
<h2 id="클라이언트가-보기에는"><a href="#클라이언트가-보기에는" class="headerlink" title="클라이언트가 보기에는.."></a>클라이언트가 보기에는..</h2><p>상속이 적합한지를 판단하기 위해 두 가지 질문을 다시 한번 보면</p>
<ul>
<li>(클라이언트 입장에서) 상속관계가 is-a 관계를 모델링하는가?</li>
<li>클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?</li>
</ul>
<p>is-a 관계는 객체지향에서 중요한 것은 객체의 속성이 아니라 객체의 행동이라는 점을 강조한다.<br>일반적으로 클라이언트를 고려하지 않은 채 개념과 속성의 측면에서 상속 관계를 정할 경우 리스코프 치환 원칙을 위반하는 서브클래싱에 이르게 될 확률이 높다.</p>
<p>결론적으로 상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계다.<br>서브클래싱을 구현하기 위해 상속을 사용했다면 is-a 관계라고 할 수 없다.</p>
<h2 id="유연한-설계의-기반"><a href="#유연한-설계의-기반" class="headerlink" title="유연한 설계의 기반"></a>유연한 설계의 기반</h2><p>리스코프 치환 원칙은 클라이언트가 어떤 자식 클래스와도 안정적으로 협력할 수 있는 상속 구조를 구현할 수 있는 가이드라인을 제공한다.<br>새로운 자식 클래스를 추가하더라도 클라이언트 입장에서 동일하게 행동하기만 한다면 클라이언트를 수정하지 않고도 상속 계층을 확장할 수 있다.<br>다시 말해서 클라이언트의 입장에서 퍼블릭 인터페이스와 행동 방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게 된다는 것이다. </p>
<p>자식 클래스가 클라이언트 관점에서 부모 클래스를 대체할 수 있다면<br>기능 확장을 위해 자식 클래스를 추가하더라도 코드를 수정할 필요가 없어진다.<br>따라서 리스코프 치환 원칙은 <strong>개방-폐쇄 원칙</strong>을 만족하는 설계를 위한 전제 조건이다.</p>
<h1 id="계약에-의한-설계와-서브타이핑"><a href="#계약에-의한-설계와-서브타이핑" class="headerlink" title="계약에 의한 설계와 서브타이핑"></a>계약에 의한 설계와 서브타이핑</h1><p>클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것을 <strong>계약에 의한 설계 (Design By Contract, DBC)</strong> 라고 부른다. </p>
<p>계약에 의한 설계는 사전조건, 사후조건, 클래스 불변식 세 가지 요소로 구성된다.</p>
<ul>
<li><strong>사전조건(precondition)</strong> : 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 조건</li>
<li><strong>사후조건(postcondition)</strong> : 메서드가 실행된 후에 클라이언트에게 보장해야 하는 조건</li>
<li><strong>클래스 불변식(class invariant)</strong> : 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 조건</li>
</ul>
<p>리스코프 치환 원칙은 어떤 타입이 서브타입이 되기 위해서는 슈퍼타입의 인스턴스와 협력하는 클라이언트 관점에서<br>서브타입의 인스턴스가 슈퍼타입을 대체하더라도 협력에 지장이 없어야 한다는 것을 의미한다<br>따라서 계약에 의한 설계를 사용하면 리스코프 치환 원칙이 강제하는 조건을 계약의 개념을 이용해 좀 더 명확하게 설명할 수 있다.</p>
<blockquote>
<p><strong>리스코프 치환 원칙과 계약에 의한 설계</strong></p>
<p>서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 <strong>계약</strong> 을 준수해야한다.</p>
</blockquote>
<h2 id="서브타입과-계약"><a href="#서브타입과-계약" class="headerlink" title="서브타입과 계약"></a>서브타입과 계약</h2><p>계약의 관점에서 상속이 초래하는 가장 큰 문제는 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 수 있다는 것이다.</p>
<p>계약의 관점에서 볼때 아래의 규칙을 지켜야 한다.</p>
<ul>
<li>서브타입에서 더 강력한 사전조건을 정의할 수 없다.<ul>
<li>사전에 슈퍼타입에서 계약한 행동을 위반한다.</li>
<li>예시) <ul>
<li>슈퍼타입 메서드의 파라미터는 정수만 들어올 수 있다.</li>
<li>서브타입 메서드의 파라미터는 양수만 들어올 수 있다. (더 강한 사전조건) <ul>
<li>슈퍼타입에서는 음수도 들어올 수 있어서 <strong>행동 호환성</strong> 이 맞지 않는다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.<ul>
<li>예시)<ul>
<li>슈퍼타입 메서드의 파라미터는 양수만 들어올 수 있다.</li>
<li>서브타입 메서드의 파라미터는 정수만 들어올 수 있다. (더 약한 사전조건) <ul>
<li>슈퍼타입을 사용하는 클라이언트는 어차피 양수만 넣을 것이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.<ul>
<li>예시)<ul>
<li>슈퍼타입 메서드의 반환 값은 0보다 큰 값이다.</li>
<li>서브타입 메서드의 반환 값은 1000보다 큰 값이다. (더 강한 사후조건) <ul>
<li>슈퍼타입을 사용하는 클라이언트는 어차피 0보다 큰 값이면 된다</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>서브타입에 더 약한 사후조건을 정의할 수 없다.<ul>
<li>예시)<ul>
<li>슈퍼타입 메서드의 반환 값은 1000보다 큰 값이다.</li>
<li>서브타입 메서드의 반환 값은 0보다 큰 값이다. (더 약한 사후조건) <ul>
<li>슈퍼타입을 사용하는 클라이언트는 1000보다 큰 값을 기대하기 때문에 <strong>행동 호환성</strong> 이 맞지 않는다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>위처럼 서브타이핑을 위해 상속을 사용하는 경우 슈퍼타입에서 클라이언트와 맺고 있는 계약에 대해 고민해야 한다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - chapter13. 서브클래싱과 서브타이핑</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="2020/07/12/object-chapter12/">Objects Study - Chapter12. 다형성</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-12</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="상속의-오해와-진실"><a href="#상속의-오해와-진실" class="headerlink" title="상속의 오해와 진실"></a>상속의 오해와 진실</h1><p>코드 재사용을 목적으로 상속을 사용하면 변경하기 어렵고 유연하지 못한 설계에 이를 확률이 높아진다.<br>상속의 목적은 코드 재사용이 아니다.<br><strong>상속은 타입 계층을 구조화하기 위해 사용해야 한다.</strong><br>타입 계층은 객체지향 프로그래밍의 중요한 특성 중의 하나인 다형성의 기반을 제공한다. </p>
<p>객체지향 패러다임이 주목받기 시작하던 초기에 상속은 타입 계층과 다형성을 구현할 수 있는 거의 유일한 방법이었다.<br>하지만 최근의 언어들은 상속 이외에도 다형성을 구현할 수 있는 다양한 방법들을 제공하고 있다.<br>따라서 상속의 중요성이 이전에 비해 많이 낮아졌다.</p>
<h1 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h1><p><strong>다형성(Polymorphism)</strong> 이라는 단어는 ploy(많은) + morph(형태)의 합성어로 많은 형태를 가질 수 있는 능력을 의미한다.<br>다형성을 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력으로 정의된다.<br>다형성은 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법이다. </p>
<h2 id="여러가지-다형성"><a href="#여러가지-다형성" class="headerlink" title="여러가지 다형성"></a>여러가지 다형성</h2><p>객체지향 프로그래밍에서 사용되는 다형성은 그림과 같이 나눌 수 있다.</p>
<p><img src="./polymorphism.jpeg" alt="polymorphism"></p>
<ul>
<li><strong>강제 다형성</strong> : 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식을 가리킨다.<ul>
<li>예) 플러스 연산자 : 숫자 연산에서는 덧셈, 문자열 연산에서는 연결 연산자로 동작한다.</li>
<li>일반적으로 오버로딩 다형성과 강제 다형성을 함께 사용하면 모호해질 수 있는데 실제로 어떤 메서드가 호출될지를 판단하기가 어려워지기 때문이다.</li>
</ul>
</li>
<li><strong>오버로딩 다형성</strong> : 일반적으로 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우를 가리킨다<ul>
<li>유사한 역할을 하는 메서드이지만 시그니처가 다른 경우 사용한다.</li>
</ul>
</li>
<li><strong>매개변수 다형성</strong> : <strong>제네릭 프로그래밍</strong> 과 관련이 깊다. 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식<ul>
<li>예) 자바의 List 인터페이스는 컬렉션에 보관할 요소를 임의의 타입 T로 지정하고 있다. 실제 인스턴스를 생성하는 시점에 T를 구체적인 타입으로 지정할 수 있게 한다.<br>List 인터페이스는 다양한 타입의 요소를 다루기 위해 동일한 오퍼레이션을 사용할 수 있다.</li>
</ul>
</li>
<li><strong>포함 다형성</strong> : 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력을 의미<ul>
<li>다른 말로 <strong>서브타입(Subtype) 다형성</strong> 이라고도 부른다.</li>
<li>일반적인 다형성을 얘기할 때 포함 다형성을 얘기한다.</li>
</ul>
</li>
</ul>
<h1 id="상속의-양면성"><a href="#상속의-양면성" class="headerlink" title="상속의 양면성"></a>상속의 양면성</h1><p>객체지향 패러다임의 근간을 이루는 아이디어는 데이터와 행동을 객체라고 불리는 하나의 실행 단위 안으로 통합하는 것이다.<br>따라서 객체지향 프로그램을 작성하기 위해서는 항상 데이터와 행동이라는 두 가지 관점을 함께 고려해야 한다.</p>
<h2 id="데이터-관점의-상속"><a href="#데이터-관점의-상속" class="headerlink" title="데이터 관점의 상속"></a>데이터 관점의 상속</h2><p>상속을 이용하면 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함 시킬 수 있다.<br>Lecture와 GradeLecture 두 가지 클래스가 있고, GradeLecture는 Lecture를 상속하고 있다고 하자</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lecture</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> pass;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Integer&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Lecture</span><span class="params">(String title, <span class="type">int</span> pass, List&lt;Integer&gt; scores)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.title = title;</span><br><span class="line">    <span class="built_in">this</span>.pass = pass;</span><br><span class="line">    <span class="built_in">this</span>.scores = scores;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeLecture</span> <span class="keyword">extends</span> <span class="title class_">Lecture</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Grade&gt; grades;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Lecture</span><span class="params">(String title, <span class="type">int</span> pass, List&lt;Grade&gt; grades, List&lt;Integer&gt; scores)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.title = title;</span><br><span class="line">    <span class="built_in">this</span>.pass = pass;</span><br><span class="line">    <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    <span class="built_in">this</span>.scores = scores;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lecture</span> <span class="variable">lecture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GradeLecture</span>(</span><br><span class="line">  <span class="string">&quot;객체지향 프로그래밍&quot;</span>,</span><br><span class="line">  <span class="number">70</span>,</span><br><span class="line">  Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Grade</span>(<span class="string">&quot;A&quot;</span>, <span class="number">100</span>, <span class="number">95</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Grade</span>(<span class="string">&quot;B&quot;</span>, <span class="number">94</span>, <span class="number">80</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Grade</span>(<span class="string">&quot;C&quot;</span>, <span class="number">79</span>, <span class="number">70</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Grade</span>(<span class="string">&quot;D&quot;</span>, <span class="number">69</span>, <span class="number">50</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Grade</span>(<span class="string">&quot;F&quot;</span>, <span class="number">49</span>, <span class="number">0</span>),</span><br><span class="line">  ),</span><br><span class="line">  Arrays.asList(<span class="number">81</span>, <span class="number">95</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">45</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>실제 메모리 상의 GradeLecture의 인스턴스는 아래 그림과 같이 표현할 수 있다.<br>상속을 인스턴스 관점에서 바라볼 때는 개념적으로 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스가 포함되는 것으로 생각하는 것이 유용하다.<br>인스턴스를 참조하는 lecture는 GradeLecture의 인스턴스를 가리키기 때문에 특별한 방법을 사용하지 않으면 GradeLecture 안에 포함된 Lecture의 인스턴스에 직접 접근할 수 없다.</p>
<p><img src="./data_class.jpeg" alt="data_class"></p>
<p>위와 같이 자식 클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 내부에 포함하게 된다.</p>
<h2 id="행동-관점의-상속"><a href="#행동-관점의-상속" class="headerlink" title="행동 관점의 상속"></a>행동 관점의 상속</h2><p>상속을 이용하면 부모 클래스에서 정의한 일부 메서드를 자식 클래스에 포함 시킬 수 있다.<br>부모 클래스에 정의된 어떤 메서드가 자식 클래스에 포함될지는 언어의 종류와 각 언어에서 제공하는 접근 제어자의 의미에 따라 다르지만<br><strong>공통적으로 부모 클래스의 모든 퍼블릭 메서드는 자식 클래스의 퍼블릭 인터페이스에 포함된다.</strong><br>따라서 외부의 객체가 부모 클래스의 인스턴스에게 전송할 수 있는 모든 메세지는 자식 클래스의 인스턴스에도 전송할 수 있다.</p>
<p>부모 클래스의 퍼블릭 인터페이스가 자식 클래스의 퍼블릭 인터페이스에 합쳐지만 실제로 코드가 복사되어 합쳐지는 것은 아니다.<br>런타임에 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 이 메서드를 부모 클래스 안에서 탐색하기 때문이다.</p>
<h2 id="메서드는-인스턴스-간-공유가-가능하다"><a href="#메서드는-인스턴스-간-공유가-가능하다" class="headerlink" title="메서드는 인스턴스 간 공유가 가능하다"></a>메서드는 인스턴스 간 공유가 가능하다</h2><p>객체의 경우에는 서로 다른 상태를 저장할 수 있도록 각 인스턴스별로 독립적인 메모리를 할당받아야 한다.<br>하지만 메서드의 경우에는 동일한 클래스의 인스턴스끼리 공유가 가능하기 때문에 클래스는 한 번만 메모리에 로드하고<br>각 인스턴스별로 클래스를 가리키는 포인터를 갖게 하는 것이 경제적이다.</p>
<p>아래와 그림과 같이 표현할 수 있다.</p>
<p><img src="./class_instance.jpg" alt="class_instance"></p>
<p>Lecture 객체에 대한 인스턴스는 메모리에 2개가 생성되었지만 실제 메서드를 실행할 때는 class 포인터를 이용하여 클래스에 접근한다.<br>부모 클래스에 접근하기 위해서는 parent 포인터를 이용하여 접근하는 것을 볼 수 있다.</p>
<p>따라서 각 객체에서 class 포인터와 parent 포인터를 조합하면 현재 인스턴스의 클래스에서 최상위 부모 클래스에 이르기 까지<br>모든 부모 클래스에 접근하는 것이 가능하다.</p>
<h1 id="업캐스팅과-동적-바인딩"><a href="#업캐스팅과-동적-바인딩" class="headerlink" title="업캐스팅과 동적 바인딩"></a>업캐스팅과 동적 바인딩</h1><p>코드 안에서 선언된 참조 타입과 무관하게 실제로 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 달라질 수 있는 것은<br>업캐스팅과 동적 바인딩이라는 메커니즘이 작용하기 때문이다.  </p>
<ul>
<li>업캐스팅: 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다.</li>
<li>동적 바인딩: 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다.<br>객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에 결정하기 때문이다.</li>
</ul>
<blockquote>
<p>개방-폐쇄 원칙과 의존성 역전 원칙</p>
<p>업캐스팅과 동적 메서드 탐색은 코드를 변경하지 않고도 기능을 추가할 수 있게 해주며 이것은 개방-폐쇄 원칙의 의도와도 일치한다.<br>개방-폐쇄 원칙은 유연하고 확장 가능한 코드를 만들기 위해 의존관계를 구조화하는 방법을 설명한다.<br>업캐스팅과 동적 메서드 탐색은 상속을 이용해 개방-폐쇄 원칙을 따르는 코드를 작성할 때 하부에서 동작하는 기술적인 내부 메커니즘을 설명한다.<br>개방-폐쇄 원칙이 목적이라면 업캐스팅과 동적 메서드 탐색은 목적에 이르는 방법이다.</p>
</blockquote>
<h2 id="업캐스팅"><a href="#업캐스팅" class="headerlink" title="업캐스팅"></a>업캐스팅</h2><p>상속을 이용하면 부모 클래스의 퍼블릭 인터페이스가 자식 클래스의 퍼블릭 인터페이스에 합쳐지기 때문에 부모 클래스의 인스턴스에게 전송할 수 있는 메시지를 자식 클래스의 인스턴스에게 전송할 수 있다.<br>부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용하더라도 메시지를 처리하는 데는 아무런 문제가 없다.<br>컴파일러는 명시적인 타입 변환 없이도 자식 클래스가 부모 클래스를 대체할 수 있게 허용한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lecture</span> <span class="variable">lecture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GradeLecture</span>();</span><br></pre></td></tr></table></figure>



<p>부모 클래스 타입으로 선언된 파라미터에 자식 클래스 인스턴스를 전달하는 것도 가능하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Professor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Professor</span><span class="params">(String name, Lecture lecture)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Professor</span> <span class="variable">professor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Professor</span>(<span class="string">&quot;교수님&quot;</span>, <span class="keyword">new</span> <span class="title class_">GradeLecture</span>());</span><br></pre></td></tr></table></figure>



<p>반대로 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해서는 명시적인 타입 캐스팅이 필요하다.<br>이를 <strong>다운캐스팅(downcasting)</strong> 이라고 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lecture</span> <span class="variable">lecture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GradeLecture</span>();</span><br><span class="line"><span class="type">GradeLecture</span> <span class="variable">gradeLecture</span> <span class="operator">=</span> (GradeLecture) lecture;</span><br></pre></td></tr></table></figure>

<p><img src="./up-down_casting.jpeg" alt="up-down_casting"></p>
<h2 id="동적-바인딩"><a href="#동적-바인딩" class="headerlink" title="동적 바인딩"></a>동적 바인딩</h2><p>전통적인 언어에서 함수를 실행하는 방법은 함수를 호출하는 것이다.<br>객체지향 언어에서 메서드를 실행하는 방법은 메시지를 전송하는 것이다.<br>이 두가지의 메커니즘은 완전히 다르다. </p>
<ul>
<li>함수 호출 <ul>
<li>코드를 작성하는 시점에 호출될 코드가 결정된다.</li>
<li>컴파일 타임에 호출할 함수를 결정하는 방식을</li>
</ul>
</li>
</ul>
<p><strong>정적 바인딩(static binding), 초기 바인딩(early binding), 컴파일타임 바인딩(compile-time binding)</strong> 이라고 부른다.</p>
<ul>
<li>메서드 호출<ul>
<li>메시지를 수신했을 때 실행될 메서드가 런타임에 결정된다. </li>
<li>실행될 메서드를 런타임에 결정하는 방식을 <strong>동적 바인딩(dynamic binding), 지연 바인딩(late binding)</strong> 이라고 부른다.</li>
<li>실행 시점에 어떤 클래스의 인스턴스에 메시지를 전달하는지 알아야 실제 실행되는 메서드를 알 수 있다.</li>
</ul>
</li>
</ul>
<h1 id="동적-메서드-탐색과-다형성"><a href="#동적-메서드-탐색과-다형성" class="headerlink" title="동적 메서드 탐색과 다형성"></a>동적 메서드 탐색과 다형성</h1><p>객체지향 시스템은 다음 규칙에 따라 실행할 메서드를 선택한다. </p>
<ul>
<li>메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한다.<ul>
<li>존재하면 메서드를 실행하고 탐색을 종료한다.</li>
</ul>
</li>
<li>메서드를 찾이 못했다면, 부모 클래스에서 메서드 탐색을 계속한다.<ul>
<li>메서드를 찾을 때까지 상속 계층을 따라 올라가며 계속된다.</li>
</ul>
</li>
<li>상속 계층의 최상위 클래스에 이르렀지만 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색을 중단한다.</li>
</ul>
<h2 id="self-참조-self-reference"><a href="#self-참조-self-reference" class="headerlink" title="self 참조 (self reference)"></a>self 참조 (self reference)</h2><p>메시지 탐색과 관련해서 이해해야할 중요한 변수로 <strong>self 참조 (self reference)</strong> 라는 변수이다.<br>self 변수는 아래와 같이 동작한다.</p>
<ul>
<li>객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 후 메시지를 수신한 객체를 가리키도록 설정한다. </li>
<li>동적 메서드 탐색은 self가 가리키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로 이뤄진다.</li>
<li>메서드 탐색이 종료되는 순간 self 참조는 자동으로 소멸된다.</li>
<li>자바에서는 self 참조를 this라고 부른다.</li>
</ul>
<h2 id="동적-메서드-탐색하기"><a href="#동적-메서드-탐색하기" class="headerlink" title="동적 메서드 탐색하기"></a>동적 메서드 탐색하기</h2><p>self 참조를 통해 상속계층을 따라 동적으로 메서드 탐색이 이루어진다. </p>
<p><img src="./method_find.jpeg" alt="method_find"></p>
<p>메서드 탐색은 자식 클래스에서 부모 클래스의 방향으로 진행된다.<br>따라서 항상 자식 클래스의 메서드가 부모 클래스의 메서드보다 먼저 탐색되기 때문에 자식 클래스에 선언된 메서드가<br>부모 클래스의 메서드보다 더 높은 우선 순위를 가진다.</p>
<p>동적 메서드 탐색은 두 가지 원리로 구성된다.</p>
<ul>
<li><strong>자동적인 메시지 위임</strong> : 자식 클래스는 자신이 이해할 수 없는 메시지를 전송받은 경우 자동으로 상속 계층을 따라 부모 클래스에게 처리를 위임한다.</li>
<li><strong>메서드를 탐색하기 위해 동적인 문맥을 사용</strong> : 메시지를 수신했을 때 실제로 어떤 메서드를 실행할지는 런타임에 이뤄지며 self 참조를 이용해서 결정한다.<br>(self가 가리키는 인스턴스를 기준으로 탐색을 시작한다.)</li>
</ul>
<p>메시지가 처리되는 문맥을 이해하기 위해서는 정적인 코드를 분석하는 것만으로는 충분하지 않다.<br>런타임에 실제로 메시지를 수신한 객체가 어떤 타입인지를 추적해야 한다.<br>이 객체의 타입에 따라 메서드를 탐색하는 문맥이 동적으로 결정되며, 여기서 가장 중요한 역할을 하는 것이 바로 self 참조다.</p>
<h2 id="자동적인-메시지-위임"><a href="#자동적인-메시지-위임" class="headerlink" title="자동적인 메시지 위임"></a>자동적인 메시지 위임</h2><p>상속을 이용할 경우 메시지를 처리할 방법을 알지 못할 경우 메시지에 대한 처리를 부모 클래스에 위임한다.<br>적절한 메서드를 <strong>찾을 때까지</strong> 상속 계층을 따라 부모 클래스로 처리가 위임된다.<br>상속을 이용할 경우 프로그래머가 메시지 위임과 관련된 코드를 명시적으로 작성할 필요가 없다. <strong>메시지는 상속 계층을 따라 자동적으로 위임된다.</strong></p>
<p>자식 클래스 -&gt; 부모 클래스의 방향으로 메시지 처리가 위임되기 때문에 자식 클래스에서 어떤 메서드를 구현하고 있느냐에 따라 부모 클래스에 구현된 메서드의 운명이 결정된다.</p>
<h2 id="동적인-문맥"><a href="#동적인-문맥" class="headerlink" title="동적인 문맥"></a>동적인 문맥</h2><p>상속을 이용하면 메시지를 수신한 객체가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 동적으로 바뀐다는 것이다.<br>이 동적인 문맥을 결정하는 것은 바로 메시지를 수신한 객체를 가리키는 self 참조다.</p>
<p>동일한 코드라고 하더라도 self 참조가 가리키는 객체가 무엇인지에 따라 메서드 탐색을 위한 상속 계층의 범위가 동적으로 변한다.<br>따라서 self 참조가 가리키는 객체의 타입을 변경함으로써 객체가 실행될 문맥을 동적으로 바꿀 수 있다.</p>
<h2 id="self가-self에게"><a href="#self가-self에게" class="headerlink" title="self가 self에게"></a>self가 self에게</h2><p>self 참조가 동적인 문맥을 결정한다는 사실은 종종 어떤 메서드가 실행될지를 예상하기 어렵게 만든다.<br>대표적인 경우가 <strong>자신에게 다시 메시지를 전송하는 self 전송이다</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lecture</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">stats</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;Title: %s. Evaluation Method: %s&quot;</span>, title, getEvaluationMethod());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getEvaluationMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Pass or Fail&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stats() 메서드에서 getEvaluationMethod() 메시지를 전송하였다.<br>현재 클래스의 메서드를 호출 하는 것이 아닌 현재 객체에게 getEvaluationMethod를 전송하는 것이다.<br><strong>즉 self 참조가 가리키는 객체에게 getEvaluationMethod 메시지를 전송한 것이다.</strong></p>
<p>self 전송을 이해하기 위해서는 self 참조가 가리키는 바로 그 객체에서부터 메시지 탐색을 다시 시작한다는 사실이다.</p>
<p><img src="./self.jpeg" alt="self"></p>
<h1 id="이해할-수-없는-메시지"><a href="#이해할-수-없는-메시지" class="headerlink" title="이해할 수 없는 메시지"></a>이해할 수 없는 메시지</h1><p>클래스는 자신이 처리할 수 없는 메시지를 수신하면 부모 클래스로 처리를 위임한다.<br>이해할 수 없는 메시지를 처리하는 방법은 정적 언어인지, 동적 언어인지에 따라 달라진다.</p>
<h2 id="정적-타입-언어와-이해할-수-없는-메시지"><a href="#정적-타입-언어와-이해할-수-없는-메시지" class="headerlink" title="정적 타입 언어와 이해할 수 없는 메시지"></a>정적 타입 언어와 이해할 수 없는 메시지</h2><p>정적 타입 언어에서는 <strong>코드를 컴파일할 때</strong> 상속 계층 안의 클래스들이 메시지를 이해할 수 있는지 여부를 판단한다.<br>따라서 상속 계층 전체를 탐색한 후에도 메시지를 처리할 수 있는 메서드를 발견하지 못했다면 컴파일 에러를 발생시킨다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lecture</span> <span class="variable">lecture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GradeLecture</span>();</span><br><span class="line">lecture.unknownMessage(); <span class="comment">//컴파일 에러!</span></span><br></pre></td></tr></table></figure>
<p>이 경우 상속 계층을 따라 <code>unknownMessage</code>를 처리할 수 있는 메서드가 존재하는 지 검색한다.<br>만약 최상위 클래스까지 탐색을 했는데 <code>unknownMessage</code>를 이해할 수 없다면 더 이상 부모 클래스가 존재하지 않기 때문에 컴파일 에러를 발생시켜 메시지를 처리할 수 없다는 사실을 프로그래머에게 알린다. </p>
<h2 id="동적-타입-언어와-이해할-수-없는-메세지"><a href="#동적-타입-언어와-이해할-수-없는-메세지" class="headerlink" title="동적 타입 언어와 이해할 수 없는 메세지"></a>동적 타입 언어와 이해할 수 없는 메세지</h2><p>동적 타입에서도 메시지를 수신한 객체의 클래스로 부터 부모 클래스의 방향으로 메서드를 탐색한다.<br>동적 타입 언어에서는 컴파일 단계가 존재하지 않기 때문에 실제로 코드를 실행해보기 전에는 메시지 처리 가능 여부를 판단할 수 없다.</p>
<p>몇 가지 동적 타입 언어는 최상위 클래스까지 메서드를 탐색한 후에 메서드를 처리할 수 없다는 사실을 발견하면 self 참조가 가리키는 현재 객체에게 메시지를 이해할 수 없다는 메시지를 전송한다.  </p>
<ul>
<li>스몰토크 : doesNotUnderstand 메시지를 전송한다</li>
<li>루비 : method_missing 메시지를 전송한다</li>
</ul>
<p>이해할 수 없는 메시지를 처리할 수 있는 동적 타입 언어는 좀 더 순수한 관점에서 객체지향 패러다임을 구현한다고 볼 수 있다.<br>협력을 위해 메시지를 전송하는 객체는 메시지를 수신한 객체의 내부 구현에 대해 알지 못한다.<br>단지 객체가 메시지를 처리할 수 있다고 믿고 메시지를 전송할 뿐이다.</p>
<p>동적 타입 언어는 이해할 수 없는 메시지를 처리할 수 있는 능력을 가짐으로써 메시지가 선언된 인터페이스와 메서드가 정의된 구현을 분리할 수 있다.<br>하지만 동적 타입 언어의 이러한 동적인 특성과 유연성은 코드를 이해하고 수정하기 어렵게 만든다.<br>정적 타입 언어에는 이런 유연성은 부족하지만 컴파일타임에 확인되고 이해할 수 없는 메시지는 컴파일에러로 이어져 좀 더 안정적이다.</p>
<h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><p>자식 클래스에서 부모 클래스의 구현을 재사용해야 하는 경우가 있다.<br>대부분의 객체지향 언어들은 자식 클래스에서 부모 클래스의 인스턴스 변수나 메서드에 접근하기 위해 사용할 수 있는 super 참조라는 내부 변수를 제공한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeLecture</span> <span class="keyword">extends</span> <span class="title class_">Lecture</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">evaluate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.evaluate() + <span class="string">&quot;, &quot;</span> + gradesStatistics();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormattedGradeLecture</span> <span class="keyword">extends</span> <span class="title class_">GradeLecture</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FormattedGradeLecture</span><span class="params">(String name, <span class="type">int</span> pass, List&lt;Grade&gt; grades, List&lt;Integer&gt; scores)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, pass, grades, scores);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">formatAverage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;Avg: %1.1f&quot;</span>, <span class="built_in">super</span>.average());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./super_find.jpeg" alt="super_find"></p>
<p>super 참조의 정확한 의도는 <strong>지금 self 참조가 가리키는 클래스의 부모 클래스에서 부터 메서드 탐색을 시작하세요</strong> 이다.<br>만약 부모 클래스에서 원하는 메서드를 찾지 못한다면 더 상위의 부모 클래스로 이동하면서 메서드가 존재하는지 검사한다.</p>
<p>이것은 super 참조를 통해 실행하고자 하는 메서드가 반드시 부모 클래스에 위치하지 않아도 되는 유연성을 제공한다.<br>그 메서드가 조상 클래스 어딘가에 있기만 하면 성공적으로 탐색될 것이기 때문이다.</p>
<p>이 처럼 super 참조를 통해 메시지를 전송하는 것을 <strong>super 전송(super send)</strong> 이라고 부른다.</p>
<blockquote>
<p>super 전송과 동적 바인딩</p>
<p>상속에서 super가 컴파일 시점에 미리 결정된다고 설명했지만 super를 런타임에 결정하는 경우도 있다.<br>믹스인을 사용하는 경우에는 런타임에 동적으로 결정된다.<br>스칼라의 traits는 super의 대상을 믹스인 되는 순서에 따라 동적으로 결정한다.<br>따라서 사용하는 언어의 특성에 따라 컴파일 시점이 아닌 실행 시점에 super의 대상이 결정될 수도 있다는 점을 기억해야 한다.</p>
</blockquote>
<h1 id="위임과-self"><a href="#위임과-self" class="headerlink" title="위임과 self"></a>위임과 self</h1><p>상속을 이용하면 자식 클래스에서 메시지를 처리하지 못하는 경우 상속 계층에 따라 메시지를 위임한다.<br>이 경우 self참조는 무엇을 가리키는가?<br>메시지를 위임하더라도 self는 맨 처음 메시지를 수신한 객체를 가리킨다.</p>
<p><img src="./delegate.jpeg" alt="delegate"></p>
<h1 id="프로토타입-기반의-객체지향-언어"><a href="#프로토타입-기반의-객체지향-언어" class="headerlink" title="프로토타입 기반의 객체지향 언어"></a>프로토타입 기반의 객체지향 언어</h1><p>다른 언어에서는 클래스가 아닌 객체를 이용해서도 상속을 흉내내고 있다.<br>클래스가 존재하지 않고 오직 객체만 존재하는 프로토타입 기반의 객체지향 언어에서 상속을 구현하는 유일한 방법은 객체 사이의 위임을 이용하는 것이다.<br>클래스 기반의 객체지향 언어들이 상속을 이용해 클래스 사이에 self 참조를 자동으로 전달하는 것처럼 프로토타입 기반의 객체지향 언어들 역시 위임을 이용해 객체 사이에 self 참조를 자동으로 전달한다.</p>
<p>현재 가장 널리 사용되는 프로토타입 기반의 객체지향 언어는 <strong>자바스크립트</strong> 이다.<br>자바스크립트의 모든 객체들은 다른 객체를 가리키는 용도로 사용되는 <code>prototype</code> 이라는 이름의 링크를 가진다.  </p>
<p><code>prototype</code>은 언어 차원에서 제공되기 때문에 self 참조를 직접 전달하거나 메세지 포워딩을 번거롭게 구현하지 않아도 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Lecture</span>(<span class="params">name, scores</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">scores</span> = scores;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Lecture</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">stats</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;, Evaludation Method: &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">getEvaluationMethod</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Lecture</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getEvaluationMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Pass or Fail&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>자바스크립트의 인스턴스는 메시지를 수신하면 먼저 메시지를 수신한 객체의 prototype 안에서 메시지에 응답할 적절한 메서드가 있는지 검사한다.<br>만약 메서드가 존재하지 않는다면 prototype이 가리키는 객체를 따라 메시지 처리를 자동적으로 위임한다.<br>자바스크립트에서는 prototype 체인으로 연결된 객체 사이에 메시지를 위임함으로써 상속을 구현할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GradeLecture</span>(<span class="params">name, canceled, scores</span>) &#123;</span><br><span class="line">  <span class="title class_">Lecture</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, scores);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">canceled</span> = canceled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">GradeLecture</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Lecture</span>();</span><br><span class="line"><span class="title class_">GradeLecture</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">GradeLecture</span>;</span><br><span class="line"><span class="title class_">GradeLecture</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getEvaludationMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Grade&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드에서는 GradeLecture의 prototype에 Lecture 인스턴스를 할당했다.<br>이 과정을 통해 GradeLecture를 이용해 생성된 모든 객체들이 prototype을 통해 Lecture에 정의된 모든 속성과 함수에 접근할 수 있게 된다.</p>
<p>이제 메시지를 전송하면 prototype으로 연결된 객체 사이의 경로를 통해 객체 사이의 메서드 탐색이 자동으로 이뤄진다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> grade_lecture = <span class="keyword">new</span> <span class="title class_">GradeLecture</span>(<span class="string">&quot;OOP&quot;</span>, <span class="literal">false</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">grade_lecture.<span class="title function_">stats</span>();</span><br></pre></td></tr></table></figure>

<p><img src="./prototype_chain.jpeg" alt="prototype_chain"></p>
<p>자바스크립트에서는 클래스가 존재하지 않기 때문에 오직 객체들 사이의 메시지 위임만을 이용해 다형성을 구현한다.<br>이것은 객체지향 패러다임에서 클래스가 필수 요소가 아니라는 점을 잘 보여준다.<br>또한 상속 이외의 방법으로도 다형성을 구현할 수 있다는 사실을 잘 보여준다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - chapter12. 다형성</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="2020/07/11/object-chapter11/">Objects Study - Chapter11. 합성과 유연한 설계</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-11</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="상속과-합성"><a href="#상속과-합성" class="headerlink" title="상속과 합성"></a>상속과 합성</h1><p>상속과 합성은 객체지향 프로그래밍에서 가장 널리 사용되는 코드 재사용 기법이다.  </p>
<ul>
<li>상속<ul>
<li>부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용한다</li>
<li>컴파일 타임 의존성을 가진다 (정적인 관계)</li>
<li>is-a 관계</li>
<li>부모 클래스의 내부 구현에 대해 상세히 알아야하기 때문에 자식 클래스와 부모 클래스 사이의 결합도가 높아진다.</li>
<li>부모 클래스에 구현된 코드를 재사용한다</li>
</ul>
</li>
<li>합성<ul>
<li>전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다</li>
<li>런타임 의존성을 가진다 (동적인 관계) </li>
<li>has-a 관계</li>
<li>클래스와 클래스간의 퍼블릭 인터페이스에 의존하여 결합도가 낮다.</li>
<li>내부 구현의 변경의 영향이 최소화 된다</li>
<li>객체의 퍼블릭 인터페이스를 재사용한다</li>
</ul>
</li>
</ul>
<p>코드 작성 시점에 결정된 상속 관계는 런타임에 변경이 불가하지만 합성 관계는 실행 시점에 동적으로 변경할 수 있기 때문에<br>상속 대신 합성을 사용하면 변경하기 쉽고 유연한 설계를 얻을 수 있다.</p>
<blockquote>
<p><strong>화이트박스 재사용 (white-box reuse)</strong><br>상속으로 인한 재사용을 일컫는다. 상속을 받으면 부모 클래스의 내부가 자식 클래스에 공개되기 때문에 화이트 박스인 셈이다.</p>
</blockquote>
<blockquote>
<p><strong>블랙박스 재사용 (black-box reuse)</strong><br>합성으로 인한 재사용을 일컫는다. 합성 시에는 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문이다.</p>
</blockquote>
<h1 id="상속을-합성으로-변경하기"><a href="#상속을-합성으로-변경하기" class="headerlink" title="상속을 합성으로 변경하기"></a>상속을 합성으로 변경하기</h1><p>코드의 재사용을 위해 상속을 남용하는 경우 발생하는 문제점은 아래와 같다.</p>
<ul>
<li>불필요한 인터페이스 상속문제</li>
<li>메서드 오버라이딩 오작용 문제</li>
<li>부모 클래스와 자식 클래스의 동시 수정 문제</li>
</ul>
<p>합성을 사용하면 상속이 초래하는 문제점을 해결할 수 있다.<br>상속을 합성으로 바꾸는 방법은 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.</p>
<h2 id="불필요한-인터페이스-상속문제"><a href="#불필요한-인터페이스-상속문제" class="headerlink" title="불필요한 인터페이스 상속문제"></a>불필요한 인터페이스 상속문제</h2><p>상속을 이용한 Stack에서는 부모클래스에서 제공하는 퍼블릭 인터페이스 때문에 Stack의 규칙을 위반할 수 있다.<br>Vector는 임의의 위치(index)에서 요소를 조회하고, 추가하고, 삭제할 수 있는 get, add, remove 오퍼레이션을 제공한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;1st&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;2nd&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;3rd&quot;</span>);</span><br><span class="line">stack.add(<span class="number">0</span>, <span class="string">&quot;4th&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;4th&quot;</span>, stack.pop()); <span class="comment">//에러</span></span><br></pre></td></tr></table></figure>



<p>기존 상속을 이용하던 Stack을 합성으로 바꿔보았다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span>&lt;E&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Vector&lt;E&gt; elements = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">push</span><span class="params">(E item)</span> &#123;</span><br><span class="line">    elements.add(item);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(elements.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements.remove(elements.size()-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 Vector의 퍼블릭 인터페이스는 Stack에 포함되지 않는다.<br>클라이언트는 더 이상 임의의 위치에 요소를 추가하거나 삭제할 수 없다.  따라서 Stack의 규칙을 깰 수 있는 요소가 없게 된다.</p>
<h2 id="메서드-오버라이딩의-오작용-문제-InstrumentedHashSet"><a href="#메서드-오버라이딩의-오작용-문제-InstrumentedHashSet" class="headerlink" title="메서드 오버라이딩의 오작용 문제: InstrumentedHashSet"></a>메서드 오버라이딩의 오작용 문제: InstrumentedHashSet</h2><p>상속을 이용한 기존 InstrumentedHashSet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentedHashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">addCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    addCount += c.size();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.addAll(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>기존에 상속을 이용하던 InstrumentedHashSet을 합성으로 바꿔보았다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentedHashSet</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">addCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> Set&lt;E&gt; set;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">InstrumentedHashSet</span><span class="params">(Set&lt;E&gt; set)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.set = set;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addCount++;</span><br><span class="line">    <span class="keyword">return</span> set.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    addCount += c.size();</span><br><span class="line">    <span class="keyword">return</span> set.addAll(c);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAddCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addCount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 과정까지는 위의 Stack의 예제와 같다.<br>하지만 InstrumentedHashSet은 기존의 HashSet의 퍼블릭 인터페이스까지 제공을 해야한다.</p>
<p>이를 해결하기 위해 아래와 같이 코드를 작성하였다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentedHashSet</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">addCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> Set&lt;E&gt; set;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">InstrumentedHashSet</span><span class="params">(Set&lt;E&gt; set)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.set = set;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addCount++;</span><br><span class="line">    <span class="keyword">return</span> set.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    addCount += c.size();</span><br><span class="line">    <span class="keyword">return</span> set.addAll(c);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAddCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addCount;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E e)</span> &#123;<span class="keyword">return</span> set.remove(e);&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.clear();&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(E e)</span> &#123;<span class="keyword">return</span> set.equals(e);&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.hashCode();&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.spliterator();&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.isEmpty(e);&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span> &#123;<span class="keyword">return</span> set.contains(e);&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;<span class="keyword">return</span> set.iterator();&#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> E[] toArray(E e) &#123;<span class="keyword">return</span> set.remove(e);&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>포워딩 메서드(forwarding method)</strong></p>
<p>위와 같이 오퍼레이션을 오버라이딩한 인스턴스 메서드에서 내부의 HashSet 인스턴스에게 동일한 메서드 호출을 그대로 전달하는 것을 알 수 있다.<br>이를 <strong>포워딩(forwarding)</strong> 이라 부르고 동일한 메서드를 호출하기 위해 추가된 메서드를 <strong>포워딩 메서드(forwarding method)</strong> 라고 부른다.<br>포워딩은 기존 클래스의 인터페이스를 그대로 외부에 제공하면서 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 사용하는 유용한 기법이다.</p>
</blockquote>
<h1 id="상속으로-인한-조합의-폭발적인-증가"><a href="#상속으로-인한-조합의-폭발적인-증가" class="headerlink" title="상속으로 인한 조합의 폭발적인 증가"></a>상속으로 인한 조합의 폭발적인 증가</h1><p>상속으로 인해 결합도가 높아지면 코드를 수정하는 데 필요한 작업의 양이 과도하게 증가할 수 있다.<br>일반적으로 작은 기능들을 조합해서 더 큰 기능을 수행하는 객체를 만들어야 하는 경우이다.</p>
<ul>
<li>하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.</li>
<li>단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.</li>
</ul>
<p><img src="./class_explosion.jpg" alt="class explosion"></p>
<p>위의 이미지와 같이 상속의 남용으로 모든 케이스에 대한 조합을 클래스로 표현하는 경우를 가리켜 클래스 폭발(class explosion)이라 한다.  또는 조합의 폭발이라 한다.<br>클래스 폭발 문제는 자식 클래스가 부모 클래스의 구현에 강하게 결합되도록 강요하는 상속의 근본적인 한계로 인해 발생하는 문제다.<br>클래스 폭발 문제는 새로운 기능을 추가하는 경우에는 많은 코드를 변경해야 할 뿐만 아니라 기능을 추가하는 경우에도 기하급수적으로 클래스가 생성될 수 있다.</p>
<h1 id="합성-관계로-변경하기"><a href="#합성-관계로-변경하기" class="headerlink" title="합성 관계로 변경하기"></a>합성 관계로 변경하기</h1><p>상속 관계는 컴파일타임에 결정되고 고정되기 때문에 코드를 실행하는 도중에는 변경할 수 없다.<br>따라서 여러 기능을 조합해야하는 설계에 상속을 이용하면 모든 조합 가능한 경우별로 클래스를 추가해야한다.</p>
<p>하지만 합성을 사용하면 컴파일 관계를 런타임 관계로 변경함으로써 이 문제를 해결한다.<br>합성을 사용하면 구현이 아닌 퍼블릭 인터페이스에 대해서만 의존할 수 있기 때문에 런타임에 객체의 관계를 변경할 수 있다.</p>
<p>따라서 합성을 사용하면 구현 시점에 관계를 고정시킬 필요가 없으며 실행 시점에 정책들의 관계를 유연하게 변경할 수 있다.<br>컴파일 의존성에 속박되지 않고 다양한 방식의 런타임 의존성을 구성할 수 있다는 것이 합성이 제공하는 가장 커다란 장점이다.</p>
<p>위의 상속관계로 나온 case를 합성을 사용하면 아래와 같이 사용할 수 있다.</p>
<p><img src="./composition.jpg" alt="composition"></p>
<p><img src="./composition2.jpg" alt="composition2"></p>
<h1 id="믹스인"><a href="#믹스인" class="headerlink" title="믹스인"></a>믹스인</h1><p>믹스인(mixin)은 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법을 가리키는 용어다.<br>합성이 실행 시점에 객체를 조합하는 재사용 방법이라면 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법이다.  </p>
<h2 id="믹스인은-상속과는-다르다"><a href="#믹스인은-상속과는-다르다" class="headerlink" title="믹스인은 상속과는 다르다"></a>믹스인은 상속과는 다르다</h2><p>믹스인이 상속이 유사한 것 처럼 보이겠지만 사실은 다르다.<br>상속의 결과로 부모 클래스의 코드를 재사용한다는 사실은 맞지만 상속의 목적은 자식 클래스를 부모 클래스와 동일한 개념적인 범주로 묶어 is-a 관계를 만들기 위한 것이다.<br>반면 믹스인은 말 그래로 코드를 다른 코드 안에 섞어 넣기 위한 방법이다.   </p>
<p>상속이 클래스와 클래스 사이의 관계를 고정시키는 데 비해 믹스인은 유연하게 관계를 재구성 할 수 있다.<br>믹스인은 코드 재사용에 특화된 방법이면서도 상속과 같은 결합도 문제를 초래하지 않는다.</p>
<blockquote>
<p><strong>믹스인의 유래</strong></p>
<p>믹스인은 Flavors라는 언어에서 처음으로 도입됐고 이후 Flavors의 특징을 흡수한 CLOS(Common Lisp Object System)에 의해 대중화됐다.  </p>
</blockquote>
<h2 id="트레이트-trait"><a href="#트레이트-trait" class="headerlink" title="트레이트(trait)"></a>트레이트(trait)</h2><p>스칼라 언어에서 제공하는 믹스인 기법이다.<br>간단하게 설명하면 trait는 <strong>super</strong> 라는 코드가 부모클래스 하나를 고정하지 않는다.<br>super는 런타임에 달라질 수 있으며 실제로 trait가 믹스인 되는 시점에 결정된다. (실행시점에 결정)  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RateDiscountablePolicy</span> <span class="keyword">extends</span> <span class="title">BasicRatePolicy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> discountAmount: <span class="type">Money</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">calculateFee</span></span>(phone: <span class="type">Phone</span>): <span class="type">Money</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> fee = <span class="keyword">super</span>.calculateFee(phone)</span><br><span class="line">    fee - discountAmount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 예제에서 super는 BasicRatePolicy의 클래스 어떤 것이든 될 수 있다.<br>BasicRatePolicy 클래스이든, BasicRatePolicy를 상속한 자식 클래스이든 trait에 대한 코드를 믹스인 할 수 있다.</p>
<h2 id="트레이트의-선형화"><a href="#트레이트의-선형화" class="headerlink" title="트레이트의 선형화"></a>트레이트의 선형화</h2><p>스칼라는 특정 클래스에 믹스인한 클래스와 트레이트를 선형화해서 어떤 메서드를 호출할 지 결정한다.<br>클래스의 인스턴스를 생성할 때 스칼라는 클래스 자신과 조상 클래스, 트레이트를 일렬로 나열해서 순서를 정한다.<br>그리고 실행 중인 메서드 내부에서 super 호출을 하면 다음 단계에 위치한 클래스나 트레이트의 메서드가 호출된다.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RateDiscountableAndTaxableRegularPolicy</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">  amount: <span class="type">Money</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  seconds: <span class="type">Duration</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  val taxRate: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">RegularPolicy</span>(amount, seconds)</span><br><span class="line"><span class="keyword">with</span> <span class="type">TaxablePolicy</span></span><br><span class="line"><span class="keyword">with</span> <span class="type">RateDiscountablePolicy</span></span><br></pre></td></tr></table></figure>

<p>위와 같은 클래스에서는 아래와 같이 선형화 된다.</p>
<p><img src="./trait_serialization.jpg" alt="trait serialization"></p>
<p>만약 RateDiscountableAndTaxableRegularPolicy 인스턴스가 calculateFee 메시지를 수신했다고 가정하면 RateDiscountableAndTaxableRegularPolicy에는 calculateFee 메서드가 없기 때문에 다음 단계에 위치한 RateDiscountablePolicy에서 calculateFee 메서드가 존재하는지 찾는다.<br>RateDiscountablePolicy에서 calculateFee를 찾으면 실행한다.<br>RateDiscountablePolicy에서 또 super.calculateFee를 호출하기 때문에 위의 단계인 TaxablePolicy의 calculateFee 메서드를 찾는다.<br>이렇게 올라가다 보면 BasicRatePolicy의 기본요금부터 재귀호출 되듯이 코드가 실행되며 내려오기 때문에 금액 계산이 순차적으로 된다.</p>
<p>만약 RateDiscountablePolicy와 TaxablePolicy의 순서를 바꾸고 싶다면</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RateDiscountableAndTaxableRegularPolicy</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">  amount: <span class="type">Money</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  seconds: <span class="type">Duration</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  val taxRate: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">RegularPolicy</span>(amount, seconds)</span><br><span class="line"><span class="keyword">with</span> <span class="type">RateDiscountablePolicy</span></span><br><span class="line"><span class="keyword">with</span> <span class="type">TaxablePolicy</span></span><br></pre></td></tr></table></figure>
<p>아래와 같이 코드를 변경하여 선형화된 순서를 바꿀 수 있다.</p>
<h2 id="믹스인을-사용하더라도-클래스-폭발이-남아있는-것인가"><a href="#믹스인을-사용하더라도-클래스-폭발이-남아있는-것인가" class="headerlink" title="믹스인을 사용하더라도 클래스 폭발이 남아있는 것인가?"></a>믹스인을 사용하더라도 클래스 폭발이 남아있는 것인가?</h2><p>믹스인을 사용하더라도 상속에서 클래스의 숫자가 기하급수적으로 늘어나는 클래스 폭발 문제는 여전히 남아있는게 아니냐고 반문할 수 있다.<br>클래스 폭발 문제의 단점은 클래스가 늘어난다는 것이 아니라 클래스가 늘어날수록 중복 코드도 함께 기하급수적으로 늘어난다는 점이다.<br>믹스인은 이런 문제가 발생하지 않는다.</p>
<p>또 클래스를 만들지 않고도 믹스인을 사용할 수 있다. </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">RegularPolicy</span>(<span class="type">Money</span>(<span class="number">100</span>), <span class="type">Duration</span>.ofSecond(<span class="number">10</span>))</span><br><span class="line">  <span class="keyword">with</span> <span class="type">RateDiscountablePolicy</span></span><br><span class="line">  <span class="keyword">with</span> <span class="type">TaxablePolicy</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> discountAmount = <span class="type">Money</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">val</span> taxRate = <span class="number">0.02</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>하지만 코드 여러 곳에서 동일한 트레이트를 믹스인해서 사용해야 한다면 명시적으로 클래스를 정의하는게 좋다.</p>
<h1 id="쌓을-수-있는-변경"><a href="#쌓을-수-있는-변경" class="headerlink" title="쌓을 수 있는 변경"></a>쌓을 수 있는 변경</h1><p>믹스인은 상속 계층 안에서 확장한 클래스보다 더 하위에 위치하게 된다.<br>다시 말해 믹스인은 대상 클래스의 자식 클래스처럼 사용될 용도로 만들어 지는 것이다.  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RateDiscountableAndTaxableRegularPolicy</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">  amount: <span class="type">Money</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  seconds: <span class="type">Duration</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  val taxRate: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">RegularPolicy</span>(amount, seconds)</span><br><span class="line"><span class="keyword">with</span> <span class="type">RateDiscountablePolicy</span></span><br><span class="line"><span class="keyword">with</span> <span class="type">TaxablePolicy</span></span><br></pre></td></tr></table></figure>
<p>위의 코드 처럼 trait를 믹스인한 with 구문은 항상 extends 구문 뒤에 나온다.</p>
<p>믹스인을 사용하면 특정한 클래스에 대한 변경 또는 확장을 독립적으로 구현한 후 필요한 시점에 차례대로 추가할 수 있다.<br>믹스인의 이러한 특징을 <strong>쌓을 수 있는 변경(stackable modification)</strong> 이라고 부른다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - chapter11. 합성과 유연한 설계</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="2020/07/05/object-chapter10/">Objects Study - Chapter10. 유연한 설계</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-05</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h1><p>객체지향 프로그래밍의 장점 중 하나는 코드를 재사용하기가 용이하다는 점이다.<br>전통적인 패러다임에서는 코드를 복사 후 붙여넣기 하고 수정하여 코드를 재사용하였다.<br>객체지향에서는 코드를 재사용하기 위해 새로운 코드를 추가한다.<br>재사용 관점에서 상속이란 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현 기법이다.</p>
<h1 id="상속과-중복-코드"><a href="#상속과-중복-코드" class="headerlink" title="상속과 중복 코드"></a>상속과 중복 코드</h1><p>객체지향 프로그래밍을 배울때 부터 기본적으로 중복 코드는 제거해야한다고 배우고 시작한다.<br>그렇기 때문에 습관적으로 중복코드가 보이면 하나로 합치는 작업을 하게된다.  </p>
<p>상속을 이용해 코드를 재사용하기 위해서는 부모 클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야 한다.<br>이것은 자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 한다는 것을 의미한다.<br>따라서 상속은 결합도를 높이며, 이 높은 결합도로 인해 코드를 수정하기 어렵게 만든다.</p>
<blockquote>
<p>상속을 위한 경고1<br>자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다.<br>super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.</p>
</blockquote>
<h2 id="Dry-원칙"><a href="#Dry-원칙" class="headerlink" title="Dry 원칙"></a>Dry 원칙</h2><p>신뢰할 수 있고 수정하기 쉬운 소프트웨어를 만드는 효과적인 방법 중 하나는 중복을 제거하는 것이다.<br>따라서 프로그래머들은 DRY 원칙을 따라야 한다.<br>Dry 원칙이란, <strong>반복하지 마라</strong> 라는 뜻의 Don’t Refeat Yourself의 첫 글자를 모아 만든 용어로 동일한 지식을 중복하지 말라는 것이다.<br>Dry 원칙은 한 번, 단 한번 (Once and Only Once) 원칙 또는 단일 지점 제어 (Single-Point Control) 원칙이라고 부른다.<br>원칙의 이름이 무엇이건, 코드 안에 중복이 존재해서는 안 된다는 것이다.  </p>
<h2 id="중복을-제거해야하는-이유"><a href="#중복을-제거해야하는-이유" class="headerlink" title="중복을 제거해야하는 이유"></a>중복을 제거해야하는 이유</h2><p><strong>중복 코드는 변경을 방해한다.</strong> 이것이 중복 코드를 제거해야 하는 가장 큰 이유다.<br>중복 코드가 가지는 가장 큰 문제는 코드를 수정하는 데 필요한 노력을 몇 배로 증가시킨다는 것이다.  </p>
<ul>
<li>우선 어떤 코드가 중복 코드인지 찾아야 한다</li>
<li>중복 코드를 찾았으면 모든 코드를 일관되게 수정해야 한다. </li>
<li>모든 중복 코드를 개별적으로 테스트 해서 동일한 결과가 나오는지 확인해야 한다.<br>이런 작업들 때문에 중복 코드는 수정과 테스트에 드는 비용을 증가시킬뿐만 아니라 개발자를 힘들게 만든다.</li>
</ul>
<h2 id="어떤-코드가-중복-코드인가"><a href="#어떤-코드가-중복-코드인가" class="headerlink" title="어떤 코드가 중복 코드인가?"></a>어떤 코드가 중복 코드인가?</h2><p>중복 여부를 판단하는 기준은 변경이다.<br>요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복이다. (함께 수정할 필요가 없다면 중복이 아니다.)<br>중복 코드를 결정하는 기준은 코드의 모양이 아니다. (유사하다는 것은 단지 중복의 징후일 뿐이다.)</p>
<h1 id="취약한-기반-클래스-문제"><a href="#취약한-기반-클래스-문제" class="headerlink" title="취약한 기반 클래스 문제"></a>취약한 기반 클래스 문제</h1><p>자식 클래스는 부모 클래스의 불필요한 세부사항에 엮이게 된다.<br>부모 클래스의 작은 변경에도 자식 클래스는 컴파일 오류와 실행 에러라는 고통에 시달려야 할 수도 있다.<br>이처럼 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상을 <strong>취약한 기반 클래스 문제</strong> 라고 부른다.<br>상속을 사용한다면 피할 수 없는 객체지향 프로그래밍의 근본적인 취약성이다.</p>
<h2 id="높은-결합도"><a href="#높은-결합도" class="headerlink" title="높은 결합도"></a>높은 결합도</h2><p>취약한 기반 클래스 문제는 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리키는 용어다.<br>상속 관계를 추가할수록 전체 시스템의 결합도가 높아진다는 사실을 알고 있어야 한다.<br>상속은 자식 클래스를 점진적으로 추가해서 기능을 확장하는 데는 용이하지만 높은 결합도로 인해 부모 클래스를 점진적으로 개선하는 것은 어렵게 만든다.</p>
<h2 id="캡슐화-약화"><a href="#캡슐화-약화" class="headerlink" title="캡슐화 약화"></a>캡슐화 약화</h2><p>취약한 기반 클래스 문제는 캡슐화를 약화시키고 결합도를 높인다.<br>상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다.<br>객체를 사용하는 이유는 구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화할 수 있기 때문이다.<br>캡슐화는 변경에 의한 파급효과를 제어할 수 있기 때문에 가치가 있다.<br>객체는 변경될지도 모르는 불안정한 요소를 캡슐화함으로써 파급효과를 걱정하지 않고도 자유롭게 내부를 변경할 수 있다.</p>
<p>상속을 이용하면 부모 클래스의 퍼블릭 인터페이스가 아닌 구현을 변경하더라도 자식 클래스가 영향을 받기 쉬워진다.<br>상속 계층의 상위에 위치한 클래스에 가해지는 작은 변경만으로도 상속 계층에 속한 모든 자손들이 급격하게 요동칠 수 있다.  </p>
<h1 id="불필요한-인터페이스-상속-문제"><a href="#불필요한-인터페이스-상속-문제" class="headerlink" title="불필요한 인터페이스 상속 문제"></a>불필요한 인터페이스 상속 문제</h1><p>자바 초기 버전에서 상속을 잘못 사용한 대표적인 사례는 두 가지가 있다.</p>
<ul>
<li>java.util.Properties</li>
<li>java.util.Stack</li>
</ul>
<p>위의 두 클래스의 공통점은 부모 클래스에서 상속받은 메서드를 사용할 경우 자식 클래스의 규칙이 위반될 수 있다는 것이다.</p>
<h2 id="Stack의-문제점"><a href="#Stack의-문제점" class="headerlink" title="Stack의 문제점"></a>Stack의 문제점</h2><p>Stack은 가장 나중에 추가된 요소가 가장 먼저 추출되는 (Last In First Out, LIFO) 자료 구조인 스택을 구현한 클래스다.<br>Vector는 임의의 위치에서 요소를 추출하고 삽입할 수 있는 리스트 자료 구조의 구현체로서 java.util.List의 초기버전이라고 할 수 있다.<br>자바의 초기 컬렉션 프레임워크 개발자들은 요소의 추가, 삭제 오퍼레이션을 제공하는 Vector를 재사용하기 위해 Stack을 Vector의 자식 클래스로 구현했다.</p>
<p><img src="./Stack.jpg" alt="Stack"></p>
<p>그림 10.1의 퍼블릭 인터페이스를 살펴보면 이 상속 관계가 가지는 문제점을 잘 알 수 있다.<br>Vector는 임의의 위치(index)에서 요소를 조회하고, 추가하고, 삭제할 수 있는 get, add, remove 오퍼레이션을 제공한다.<br>이에 비해 Stack은 맨 마지막 위치에서만 요소를 추가하거나 제거할 수 있는 push, pop 오퍼레이션을 제공한다.<br>Stack은 Vector를 상속받기 때문에 Stack의 퍼블릭 인터페이스에 Vector의 퍼블릭 인터페이스가 합쳐진다.<br>따라서 Stack에게 상속된 Vector의 퍼블릭 인터페이스를 이용하면 임의의 위치에서 요소를 추가하거나 삭제할 수 있다.<br>따라서 맨 마지막 위치에서만 요소를 추가하거나 제거할 수 있도록 허용하는 Stack의 규칙을 쉽게 위반할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;1st&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;2nd&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;3rd&quot;</span>);</span><br><span class="line">stack.add(<span class="number">0</span>, <span class="string">&quot;4th&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;4th&quot;</span>, stack.pop()); <span class="comment">//에러</span></span><br></pre></td></tr></table></figure>
<p>위 코드에서 Stack에 마지막으로 추가한 값은 <strong>4th</strong>이지만 pop 메서드의 반환값은 <strong>3rd</strong>이다.<br>그 이유는 Vector의 add 메서드를 이용해서 스택의 맨 앞에 <strong>4th</strong>를 추가했기 때문이다.</p>
<p>Stack의 예는 퍼블릭 인터페이스에 대한 고려 없이 단순히 코드 재사용을 위해 상속을 이용하는 것이 얼마나 위험한지를 잘 보여준다.<br>객체지향의 핵심은 객체들의 협력이다.<br>단순히 코드를 재사용하기 위해 오퍼레이션이 인터페이스에 스며들도록 방치해서는 안 된다.</p>
<blockquote>
<p>상속을 위한 경고2<br>상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.</p>
</blockquote>
<h1 id="메서드-오버라이딩의-부작용-문제"><a href="#메서드-오버라이딩의-부작용-문제" class="headerlink" title="메서드 오버라이딩의 부작용 문제"></a>메서드 오버라이딩의 부작용 문제</h1><p>이펙티브 자바에서 HashSet의 구현에 강하게 결합된 InstrumentedHashSet 클래스를 소개한다.<br>InstrumentedHashSet은 HashSet의 내부에 저장된 요소의 수를 셀 수 있는 기능을 추가한 클래스로서 HashSet의 자식 클래스로 구현돼 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentedHashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">addCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.add(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    addCount += c.size();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.addAll(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>여기서 아래의 코드를 실행했을때 결과를 예측해보자</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InstrumentedHashSet&lt;String&gt; languages = <span class="keyword">new</span> <span class="title class_">InstrumentedHashSet</span>&lt;&gt;();</span><br><span class="line">languages.addAll(Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Ruby&quot;</span>, <span class="string">&quot;Scala&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>눈에 보이는 코드만 보면 결과는 <strong>3</strong> 이라고 예상된다.<br>하지만 실제 결과는 <strong>6</strong>이다.  왜 6이 리턴되었을까?</p>
<p>사실은 HashSet의 addAll 메서드에서 add 메서드를 호출하기 때문이다.<br>부모클래스의 구현을 자세히 알지 못한 채 사용했기 때문에 예상과 다르게 동작한 것이다.   </p>
<p>이 문제를 해결하기 위해 InstrumentedHashSet 클래스의 addAll 메서드를 제거할 수 있다.<br>이러면 컬렉션을 파라미터로 전달하는 경우에는 자동으로 HashSet의 addAll 메서드가 호출되고 내부적으로 추가하려는 각 요소에 대해 InstrumentedHashSet의 add 메서드가 호출되어 예상했던 결과가 나올 것이다.<br>이 방법 또한 문제가 될 수 있는데 나중에 HashSet의 addAll 메서드가 add 메시지를 전송하지 않도록 수정된다면 addAll 메서드를 이용해 추가되는 요소들에 대한 카운트가 누락될 것이기 때문이다.</p>
<p>이를 해결하기 위한 가장 좋은 방법은 addAll 메서드를 오버라이딩하고 추가되는 각 요소에 대해 한번씩 add 메세지를 호출하는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentedHashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">      <span class="keyword">if</span>(add(e)) &#123;</span><br><span class="line">        modified = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>하지만 위의 방법도 문제가 없는 것은 아니다.<br>바로 오버라이딩 된 addAll 메서드의 구현이 HashSet의 것과 동일하다는 것이다.<br>즉, 미래에 발생할지 모르는 위험을 방지하기 위해 코드를 중복시킨 것이다. </p>
<blockquote>
<p>상속을 위한 경고3<br>자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.</p>
</blockquote>
<p>이펙티브 자바에서는 <strong>상속을 할 경우에는 상속을 위해 클래스를 설계하고 문서화해야 하며, 그렇지 않은 경우에는 상속을 금지해야 한다고 한다.</strong>  </p>
<h1 id="부모-클래스와-자식-클래스의-동시-수정-문제"><a href="#부모-클래스와-자식-클래스의-동시-수정-문제" class="headerlink" title="부모 클래스와 자식 클래스의 동시 수정 문제"></a>부모 클래스와 자식 클래스의 동시 수정 문제</h1><p>자식 클래스가 부모 클래스의 메서드를 오버라이딩하거나 불필요한 인터페이스를 상속받지 않았음에도<br>부모 클래스를 수정할 때 자식 클래스를 함께 수정해야 할 수도 있다는 사실을 잘 보여준다.<br>상속을 사용하면 자식 클래스가 부모 클래스의 구현에 강하게 결합되기 때문에 이 문제를 피하기는 어렵다.  </p>
<p>부모 클래스와 자식 클래스 간의 결합도가 높기 때문에 코드를 함께 수정해야 하는 상황 역시 빈번하게 발생할 수 밖에 없는 것이다.  </p>
<blockquote>
<p>서브클래스는 올바른 기능을 위해 슈퍼클래스의 세부적인 구현에 의존한다.<br>슈퍼클래스의 구현은 릴리스를 거치면서 변경될 수 있고, 그에 따라 서브클래스의 코드를 변경하지 않더라도 깨질 수 있다.<br>결과적으로, 슈퍼클래스의 작성자가 확장될 목적으로 특별히 그 클래스를 설계하지 않았다면 서브클래스는 슈퍼클래스와 보조를 맞춰서 진화해야 한다.</p>
</blockquote>
<blockquote>
<p>상속을 위한 경고 4<br>클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없다.</p>
</blockquote>
<h1 id="추상화에-의존된-코드를-작성하라"><a href="#추상화에-의존된-코드를-작성하라" class="headerlink" title="추상화에 의존된 코드를 작성하라"></a>추상화에 의존된 코드를 작성하라</h1><p>자식 클래스는 부모 클래스에 강하게 결합되기 때문에 부모 클래스가 변경될 경우 함께 변경될 가능성이 높다.<br>이 문제를 해결하는 가장 일반적인 방법은 자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 만드는 것이다.<br>정확하게 말해서 부모 클래스와 자식 클래스 모두 추상화에 의존하도록 수정해야 한다.  </p>
<p>코드 중복을 제거하기 위해 상속을 도입할 때 따르는 두 가지 원칙이 있다.  </p>
<ul>
<li><strong>두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라.</strong> 메세드 추출을 통해 동일한 형태로 보이도록 만들 수 있다.<br>흔히 말하는 <strong>“변하는 것으로 부터 변하지 않는 것을 분리하라” “변하는 부분을 찾고 이를 캡슐화하라”</strong> 라는 조언을 메서드 수준에서 적용한 것이다.</li>
<li><strong>부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라.</strong><br>부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.</li>
</ul>
<h1 id="추상화가-핵심이다"><a href="#추상화가-핵심이다" class="headerlink" title="추상화가 핵심이다"></a>추상화가 핵심이다</h1><p><strong>추상화의 장점</strong></p>
<ul>
<li>공통 코드를 이동시킨 후에 각 클래스는 서로 다른 변경의 이유를 가진다는 것에 주목하라.<br>이런 클래스는 단일 책임의 원칙을 준수하기 때문에 응집도가 높다.  </li>
<li>부모 클래스 역시 자신의 내부에 구현된 추상 메서드를 호출 하기 때문에 추상화에 의존한다고 말할 수 있다.  </li>
<li>새로운 자식 클래스를 추가하기 쉬운 구조가 된다.  추상 클래스 내의 추상 메서드만 구현하면 되기 때문이다.  </li>
<li>새로운 자식 클래스가 추가되도 다른 클래스를 수정할 필요가 없다<br>현재의 설계는 확장에는 열려 있고 수정에는 닫혀 있기 때문에 개방-폐쇄 원칙 역시 준수한다.</li>
</ul>
<h1 id="차이에-의한-프로그래밍"><a href="#차이에-의한-프로그래밍" class="headerlink" title="차이에 의한 프로그래밍"></a>차이에 의한 프로그래밍</h1><p>상속을 사용하면 이미 존재하는 클래스의 코드를 기반으로 다른 부분을 구현함으로써 새로운 기능을 쉽고 빠르게 추가할 수 있다.<br>상속이 강력한 이유는 익숙한 개념을 이용해서 새로운 개념을 쉽고 빠르게 추가할 수 있기 때문이다.  </p>
<p>이처럼 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법을 <strong>차이에 의한 프로그래밍(programming by difference)</strong> 이라고 부른다.</p>
<p>차이에 의한 프로그래밍의 목표는 중복 코드를 제거하고 코드를 재사용하는 것이다.<br>사실 중복 제거와 코드 재사용은 동일한 행동을 가리키는 서로 다른 단어다.<br>중복을 제거하기 위해서는 코드를 재사용 가능한 단위로 분해하고 재구성해야 한다.<br>코드를 재사용하기 위해서는 중복 코드를 제거해서 하나의 모듈로 모아야 한다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - chapter10. 유연한 설계</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="2020/06/14/object-chapter9/">Objects Study - Chapter9. 유연한 설계</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-14</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="개방-폐쇄-원칙"><a href="#개방-폐쇄-원칙" class="headerlink" title="개방-폐쇄 원칙"></a>개방-폐쇄 원칙</h1><p>개방폐쇄의 원칙(OCP, Open-Closed Principle)은 다음과 같이 설명된다.</p>
<blockquote>
<p>소프트웨어 개채(클래스, 모듈, 함수 등등)는 <strong>확장</strong>에 대해 열려 있어야 하고, <strong>수정</strong>에 대해서는 닫혀 있어야 한다.</p>
</blockquote>
<p>여기서의 키워드는 확장과 수정이다.</p>
<ul>
<li>확장에 대해 열려있다 - 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 동작을 추가해서 애플리케이션의 기능을 확장할 수 있다.</li>
<li>수정에 대해 닫혀있다 - 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.</li>
</ul>
<h2 id="컴파일타임-의존성을-고정시키고-런타임-의존성을-변경하라"><a href="#컴파일타임-의존성을-고정시키고-런타임-의존성을-변경하라" class="headerlink" title="컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라"></a>컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라</h2><p>사실 개방-폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 이야기다.  </p>
<ul>
<li>런타임 의존성 - 실행 시에 협력에 참여하는 객체들 사이의 관계다.  </li>
<li>컴파일타임 의존성 - 코드에서 드러나는 클래스들 사이의 관계다.</li>
</ul>
<p><img src="./diff-dependencies.jpg" alt="compile-time-dependency vs run-time-dependency"></p>
<p>위의 코드에서는 개방-폐쇄 정책을 이미 따르고 있다.<br>만약 복합 할인 정책이 추가되는 경우 기존의 코드는 수정하지 않고 <code>OpverlappedDiscountPolicy</code> 만 추가하여 기능을 <strong>확장</strong> 할 수 있다<br>따라서 <strong>확장</strong>에 대해 열려 있어야 하고, <strong>수정</strong>에 대해서는 닫혀있다.</p>
<p><img src="./open-closed-dependency.jpg" alt="open-closed dependency"></p>
<h2 id="추상화가-핵심이다"><a href="#추상화가-핵심이다" class="headerlink" title="추상화가 핵심이다."></a>추상화가 핵심이다.</h2><p>개방-폐쇄 원칙의 핵심은 <strong>추상화에 의존하는 것</strong>이다.  여기서 <code>추상화</code> 와 <code>의존</code> 이라는 두 개념 모두가 중요하다.</p>
<p>추상화란 <strong>핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법</strong>이다.<br>추상화 과정을 거치면 문맥이 바뀌더라도 <strong>변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략된다.</strong><br>추상화를 사용하면 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.</p>
<p>따라서 추상화 부분은 수정에 닫혀 있다. (공통적인 부분은 변하지 않는다)<br><strong>추상화를 통해 생략된 부분은 확장의 여지를 남긴다.</strong> 이것이 추상화가 개방-폐쇄 원칙을 가능하게 만드는 이유다.</p>
<p>하지만 단순히 어떤 개념을 추상화했다고 해서 수정에 대해 닫혀 있는 설게를 만들 수 있는 것은 아니다.<br>개방-폐쇄 원칙에서 폐쇄를 가능하게 하는 것은 의존성의 방향이다.<br>수정에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존해야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Money <span class="title function_">calculateMovieFee</span><span class="params">(Screening screening)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fee.minus(discountPolicy.calculateDiscountAmount(screening));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 예제에서는 Movie 클래스는 안정적인 DiscountPolicy에 대해서만 의존한다.<br>따라서 할인정책이 수정되더도 calculateMovieFee 메서드는 수정하지 않고 DiscountPolicy 객체만 변경하면 되기 때문에<br><strong>수정</strong> 에 닫혀 있고 <strong>확장</strong> 에 열려 있는 구조가 된다.</p>
<h1 id="생성-사용-분리"><a href="#생성-사용-분리" class="headerlink" title="생성 사용 분리"></a>생성 사용 분리</h1><p>결합도가 높아질수록 개방-폐쇄 원칙을 따르는 구조를 설계하기가 어려워진다. 알아야 하는 지식이 많으면 결합도도 높아진다.<br>특히 객체 생성에 대한 지식은 과도한 결합도를 초래하는 경향이 있다.</p>
<p>객체의 타입과 생성자에 전달해야 하는 인자에 대한 과도한 지식은 코드를 특정한 컨텍스트에 강하게 결합시킨다.<br>컨텍스트를 바꾸기 위한 유일한 방법은 코드 안에 명시돼 있는 컨텍스트에 대한 정보를 직접 수정하는 것 뿐이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String title, Duration runningTime, Money fee)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = <span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Money <span class="title function_">calculateMovieFee</span><span class="params">(Screening screening)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fee.minus(discountPolicy.calculateDiscountAmount(screening));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>위의 코드에서 <code>AmountDiscountPolicy</code> 를 <code>PercentDiscountPolicy</code> 로 변경하는 방법은 직접 코드를 수정하는 방법 뿐이다.<br>이것은 동작을 추가하거나 변경하기 위해 기존의 코드를 수정하도록 만들기 때문에 개방-폐쇄 원칙을 위반한다.</p>
<p>따라서 유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 두 가지 책임을 서로 다른 객체로 분리해야 한다.<br>하나는 <strong>생성하는 것</strong>, 하나는 <strong>객체를 사용하는 것</strong> 이다.<br>한 마디로 말해서 객체에 대한 생성과 사용을 분리(seperation use from creation) 해야 한다.</p>
<p>사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법은 객체를 생성할 책임을 클라이언트로 옮기는 것이다.<br>다시 말하면 Movie의 클라이언트가 적절한 DiscountPolicy 인스턴스를 생성한 후, Movie에게 전달하는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Money <span class="title function_">getAvatarFee</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Movie</span> <span class="variable">avatar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>), <span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br><span class="line">    <span class="keyword">return</span> avartar.getFee();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>현재 컨텍스트에 관한 결정권을 가지고 있는 클라이언트로 컨텍스트에 대한 지식을 옮김으로써 Movie는 특정한 클라이언트에 결합되지 않고 독립적일 수 있다.</p>
<h2 id="Factory-추가하기"><a href="#Factory-추가하기" class="headerlink" title="Factory 추가하기"></a>Factory 추가하기</h2><p>생성 책임을 Client로 옮긴 배경에는 Movie는 특정 컨텍스트에 묶여서는 안 되지만 Client는 묶여도 상관이 없다는 전제가 깔려있다.<br>하지만 Movie를 사용하는 Client도 특정한 컨텐스트에 묶이지 않기를 바란다고 가정해보자.</p>
<p>Client의 코드를 다시 보면 Movie의 인스턴스를 생성하는 동시에 getFee 메세지도 함께 전송한다는 것을 알 수 있다.<br>Client 역시 생성과 사용의 책임을 함께 지니고 있는 것이다.</p>
<p>이 경우에는 객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가하고 Client는 이 객체를 사용하도록 만들 수 있다.<br>이처럼 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 FACTORY라고 부른다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Movie <span class="title function_">createAvartarMovie</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>), <span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Factory factory;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Client</span><span class="params">(Factory factory)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.factory = factory;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Money <span class="title function_">getAvatarFee</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Movie</span> <span class="variable">avatar</span> <span class="operator">=</span> factory.createAvartarMovie();</span><br><span class="line">    <span class="keyword">return</span> avartar.getFee();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제는 Client는 Factory를 사용하여 생성된 Movie의 인스턴스를 반환받아 사용하기만 하면 된다.</p>
<p>factory를 사용하면 Movie와 AmountDiscountPolicy를 생성하는 책임을 모두 FACTORY로 이동할 수 있다.<br>이제 Client에는 사용과 관련된 책임만 남게 되는데 하나는 FACTORY를 통해 생성된 Movie 객체를 얻기 위한 것이고<br>다른 하나는 Movie를 통해 가격을 계산하기 위한 것이다.<br>Client는 오직 사용과 관련된 책임만 지고 생성과 관련된 어떤 지식도 가지지 않을 수 있다.</p>
<p><img src="./factory.jpg" alt="factory"></p>
<h2 id="순수한-가공물에게-책임-할당하기"><a href="#순수한-가공물에게-책임-할당하기" class="headerlink" title="순수한 가공물에게 책임 할당하기"></a>순수한 가공물에게 책임 할당하기</h2><p>책임 할당의 가장 기본이 되는 원칙은 책임을 수행하는 데 필요한 정보를 가장 많이 알고 있는 INFORMATION EXPERT에게 책임을 할당하는 것이다.<br>어떤 책임을 할당하고 싶다면 제일 먼저 도메인 모델 안의 개념 중에서 적절한 후보가 존재하는지 찾아봐야 한다. </p>
<p>하지만 방금전에 추가한 Factory는 도메인 모델에 속하지 않는다.<br>Factory를 추가한 이유는 순수하게 기술적인 결정이다. 전체적으로 결합도를 낮추고 재사용성을 높이기 위해 도메인 개념에게 할당돼 있던 객체 생성 책임을<br>도메인 개념과는 아무런 상관이 없는 가공의 객체로 이동시킨 것이다.</p>
<h2 id="표면적-분해-vs-행위적-분해"><a href="#표면적-분해-vs-행위적-분해" class="headerlink" title="표면적 분해 vs 행위적 분해"></a>표면적 분해 vs 행위적 분해</h2><ul>
<li>표면적 분해 - 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것<ul>
<li>도메인 모델에 담겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목적으로 한다.</li>
<li>객체지향 설계를 위한 가장 기본적인 접근법</li>
</ul>
</li>
<li>행위적 분해 - 도메인 개념을 표현한 객체가 아닌 설계자가 편의를 위해 임의로 만든 객체를 이용해 시스템을 분해하는 것<ul>
<li>도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로는 부족한 경우 발생</li>
<li>데이터베이스 접근을 위한 객체와 같이 도메인 개념들을 초월하는 기계적인 개념이 필요한 경우도 있다. (DAO와 같은.)</li>
<li>책임을 할당하기 위해 창조죄는 도메인과 무관한 인공적인 객체를  PURE FABRICATION(순수한 가공물)이라 한다.</li>
<li>어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재 하지 않는 경우 PURE FABRICATION을 생성하고<br>이 객체에게 책임을 할당하면 된다.</li>
<li>객체지향 어플리케이션에서는 도메인 개념을 반영하는 객체들 보다 인공적으로 창조한 객체들이 더 많은 비중을 차지한다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>PURE FABRICATION 패턴</p>
<p>객체지향 설게는 문제 도메인 상의 개념을 소프트웨어 객체로 구현하고 책임을 할당한다. 하지만 만약 도메인 객체에 책임을 할당할 경우<br>HIGH COHESION, LOW COUPLING, 재사용성 등의 목적을 위반한다면 어떻게 해야 하는가?  </p>
<p>문제 도메인 개념을 표현하지 않는, 인위적으로 또는 편의상 만든 클래스에 매우 응집된 책임을 할당하라. 이들 클래스는<br>문제 도메인 상에는 존재하지 않지만 순수하게 전체 설계의 품질을 높이기 위해 설계자의 임의에 따라 추가한 상상속의 가공물이다.</p>
<p>PURE FABRICATION은 INFORMATION EXPERT 패턴에 따라 책임을 할당한 결과가 바람직하지 않을 경우 대안으로 사용된다.<br>어떤 객체가 책임을 수행하는 데 필요한 많은 정보를 가졌지만 해당 책임을 할당할 경우 응집도가 낮아지고 결합도가 높아진다면<br>가공의 객체를 추가해서 책임을 옮기는 것을 고민하라 </p>
<p>순수한 가공물(pure fabrication)이라는 표현은 적절한 대안이 없을때 사람들이 창조적인 무언가를 만들어낸다는 것을 의미하는 관용적인 표현이다.</p>
</blockquote>
<h1 id="의존성-주입"><a href="#의존성-주입" class="headerlink" title="의존성 주입"></a>의존성 주입</h1><p>사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 <strong>의존성 주입</strong> 이라고 부른다.<br>이 기법을 의존성 주입이라고 부르는 이유는 외부에서 의존성의 대상을 해결한 후 사용하는 객체 쪽으로 주입하기 때문이다.</p>
<p>의존성 주입은 의존성을 해결하기 위해 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내서 외부에서 필요한 런타임 의존성을 전달할 수 있도록<br>만드는 방법을 포괄하는 명칭이다.</p>
<h2 id="생성자-주입-Constructor-Injection"><a href="#생성자-주입-Constructor-Injection" class="headerlink" title="생성자 주입 (Constructor Injection)"></a>생성자 주입 (Constructor Injection)</h2><p>객체를 생성하는 시점에 생성자를 통한 의존성 주입</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Movie</span> <span class="variable">avartar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>), <span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br></pre></td></tr></table></figure>



<h2 id="setter-주입-Setter-Injection"><a href="#setter-주입-Setter-Injection" class="headerlink" title="setter 주입 (Setter Injection)"></a>setter 주입 (Setter Injection)</h2><p>setter 주입은 이미 생성된 객체에 대해 setter 메서드를 통해 의존성을 해결한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Movie</span> <span class="variable">avartar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>));</span><br><span class="line">avartar.setDiscountPolicy(<span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br></pre></td></tr></table></figure>

<p>setter 주입의 단점은 객체가 올바로 생성되기 위해 어떤 의존성이 필수적인지를 명시적으로 표현할 수 없다는 것이다.<br>setter 메서드는 객체가 생성된 후에 호출돼야 하기 때문에 setter 메서드 호출을 누락한다면 객체는 비정상적인 상태로 생성될 것이다.</p>
<h2 id="메서드-주입-Method-Injection"><a href="#메서드-주입-Method-Injection" class="headerlink" title="메서드 주입 (Method Injection)"></a>메서드 주입 (Method Injection)</h2><p>메서드 주입은 메서드 호출 주입 (method call injection)이라고도 부르며 메서드가 의존성을 필요로 하는 유일한 경우일 때 사용할 수 있다.<br>생성자 주입을 통해 의존성을 전달받으면 객체가 올바른 상태로 생성되는 데 필요한 의존성을 명확하게 표현할 수 있다는 장점이 있지만<br>주입된 의존성이 1~2개의 메서드에서만 사용된다면 각 메서드의 인자로 전달하는 것이 더 나은 방법일 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Movie</span> <span class="variable">avartar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>));</span><br><span class="line">avartar.calculateDiscountAmount(screnning, <span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br></pre></td></tr></table></figure>



<h2 id="숨겨진-의존성은-나쁘다"><a href="#숨겨진-의존성은-나쁘다" class="headerlink" title="숨겨진 의존성은 나쁘다"></a>숨겨진 의존성은 나쁘다</h2><p>의존성 주입 외에도 의존성을 해결할 수 있는 방법이 존재한다.<br>대표적인 방법은 SERVICE LOCATOR 패턴이다. SERVICE LOCATOR는 의존성을 해결할 객체들을 보관하는 일종의 저장소다.<br>외부에서 객체에게 의존성을 전달하는 의존성 주입과 달리 SERVICE LOCATOR의 경우 객체가 직접 SERVICE LOCATOR에게 의존성을 해결해줄 것을 요청한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String title, Duration runningTime, Money fee)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.title = title;</span><br><span class="line">    <span class="built_in">this</span>.runningTime = runningTime;</span><br><span class="line">    <span class="built_in">this</span>.fee = fee;</span><br><span class="line">    <span class="built_in">this</span>.dicountPolicy = ServiceLocator.discountPolicy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceLocator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ServiceLocator</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceLocator</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> DiscountPolicy <span class="title function_">discountPolicy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> singleton.discountPolicy();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">provide</span><span class="params">(DicountPolicy discountPolicy)</span> &#123;</span><br><span class="line">    singleton.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServiceLocator.provide(<span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br><span class="line"><span class="type">Movie</span> <span class="variable">avartar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>));</span><br></pre></td></tr></table></figure>

<p>여기까지만 보면 SERVICE LOCATOR 패턴은 의존성을 해결할 수 있는 가장 쉽고 간단한 도구인 것처럼 보인다.<br>하지만 SERVICE LOCATOR 패턴의 큰 단점은 의존성을 감춘다는 것이다.</p>
<p>Movie는 DicountPolicy에 의존적이지만 Movie의 퍼블릭 인터페이스에 표시 되지 않고, 의존성은 암시적이며 코드 깊숙한 곳에 숨겨져 있다.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Movie</span> <span class="variable">avartar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;아바타&quot;</span>, Duration.ofMinutes(<span class="number">120</span>), Money.wons(<span class="number">10000</span>));</span><br></pre></td></tr></table></figure>
<p>위의 경우 NullPointerException이 발생하게 된다.</p>
<p>의존성을 구현 내부로 감출 경우 의존성과 관련된 문제가 **컴파일 타임이 아닌 런타임에 가서야 발견된다는 사실을 알 수 있다.  **<br>숨겨진 의존성이 이해하기 어렵고 디버깅하기 어려운 이유는 문제점을 발견할 수 있는 시점을 코드 작성 시점이 아니라 실행 시점으로 미루기 때문이다.</p>
<p>ServiceLocator는 내부적으로 정적 변수를 이용해 객체들을 관리하기 때문에 모든 단위 테스트 케이스에 걸쳐 ServiceLocator의 상태를 공유하게 된다.<br><strong>이것은 각 단위 테스트는 서로 고립돼야 한다는 단위 테스트의 기본 원칙을 위반한 것이다.</strong></p>
<p>캡슐화는 코드를 읽고 이해하는 행위와 관련이 있다. 클래스의 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡슐화의 관점에서 훌륭한 코드다.<br>클래스의 사용법을 익히기 위해 구현 내부를 샅샅이 뒤져야 한다면 그 클래스의 캡슐화는 무너진 것이다.</p>
<p>**숨겨진 의존성이 가지는 가장 큰 문제점은 의존성을 이해하기 위해 코드늬 내부 구현을 이해할 것을 강요한다. **<br>다라서 숨겨진 의존성은 캡슐화를 위반한다.<br>결과적으로 의존성을 구현 내부로 감추도록 강요하는 Service Locator는 캡슐화를 위반할 수밖에 없다.</p>
<p>숨겨진 의존성은 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어트려 놓는다.<br>이것은 코드를 이해하고 디버깅하기 어렵게 만든다.</p>
<p><strong>따라서 의존성 주입을 사용하여 외부 인터페이스에 의존성을 노출 시키는 것이 가장 깔끔하다</strong></p>
<h1 id="의존성-역전-원칙"><a href="#의존성-역전-원칙" class="headerlink" title="의존성 역전 원칙"></a>의존성 역전 원칙</h1><p>객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 상위 수준의 정책이다.<br>Movie와 AmountDiscountPolicy 사이의 협력이 가지는 본질은 영화의 가격을 계산하는 것이다.<br>어떻게 할인 금액을 계산할 것인지는 협력의 본질이 아니다.<br>다시 말해서 어떤 협력에서 중요한 정책이나 의사결정, 비지니스의 본질을 담고 있는 것은 상위 수준의 클래스이다.</p>
<p>그러나 이런 상위 수준의 클래스가 하위 수준의 클래스에 의존한다면 하위 수준의 변경에 의해 상위 수준 클래스가 영향을 받게 될 것이다.</p>
<p>의존성은 변경의 전파와 관련된 것이기 때문에 설계는 변경의 영향을 최소화하도록 의존성을 관리해야 한다.<br>상위 수준의 클래스는 어떤 식으로든 하위 수준의 클래스에 의존해서는 안 되는 것이다.</p>
<p>대부분 재사용하려는 대상은 상위 수준의 클래스이다.<br>상위 수준의 클래스가 하위 수준의 클래스에 의존하면 상위 수준의 클래스를 재사용할 때 하위 수준의 클래스도 필요하기 때문에 재사용하기가 어려워진다.</p>
<p>이 경우에도 추상화를 통해 해결한다.  Movie와 AmountDiscountPolicy 모두가 추상화에 의존하도록 수정하면<br>하위 수준 클래스의 변경으로 인해 상위 수준 클래스가 영향을 받는 것을 방지할 수 있다.<br>또한 상위 수준을 재사용할 때 하위 수준의 클래스에 얽매이지 않고도 다양한 컨텍스트에서 재사용이 가능하다.</p>
<p><strong>가장 중요한 것은 추상화에 의존하는 것이다.</strong><br><strong>유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야 한다.</strong></p>
<p><strong>정리</strong></p>
<ul>
<li>상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.</li>
<li>추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.</li>
</ul>
<p>이를 의존성 역전 원칙(Dependency Inversion Principle, DIP) 이라고 부른다. </p>
<p>역전(Inversion)이라는 단어를 사용한 이유는<br>의존성 역전 원칙을 따르는 설계는 의존성의 방향이 전통적인 절차형 프로그래밍과는 반대 방향으로 나타나기 때문이다.<br>(전통적인 절차형에서는 상위 수준의 모듈이 하위 수준 모듈에 의존적이다.)</p>
<h2 id="의존성-역전-원칙과-패키지"><a href="#의존성-역전-원칙과-패키지" class="headerlink" title="의존성 역전 원칙과 패키지"></a>의존성 역전 원칙과 패키지</h2><p>역전은 의존성의 방향뿐만 아니라 인터페이스의 소유권에도 적용된다.  </p>
<p><img src="./dependency-inversion.jpg" alt="dependency-inversion"></p>
<p>이 그림에서 구체 클래스인 Movie, AmountDiscountPolicy, PercentDiscountPolicy는 모두 추상 클래스인 DiscountPolicy에 의존한다.<br>따라서 개방-폐쇄 원칙을 준수할뿐만 아니라 의존성 역전 원칙도 따르고 있기 때문에 이 설계가 유연하고 재사용 가능하다고 생각할 것이다.<br>하지만 Movie를 다양한 컨텍스트에 재사용하기 위해서는 불필요한 클래스들이 Movie와 함께 배포돼야만 한다.</p>
<p>Movie가 DiscountPolicy에 대해 컴파일 타임 의존성을 가진다.<br>이 말은 Movie 클래스를 빌드하기 위해 DiscountPolicy가 같은 패키지 내에 필요함을 의미한다.<br>하지만 DiscountPolicy가 있는 패키지에서는 AmountDiscountPolicy, PercentDiscountPolicy가 있기때문에 전체적인 빌드 타임이 증가한다.</p>
<p>따라서 Movie의 재사용을 위해 필요한 것이 DiscountPolicy 뿐이라면 DiscountPolicy를 Movie와 같은 패키지로 모으고<br>AmountDiscountPolicy, PercentDiscountPolicy를 별도의 패키지에 위치시켜 의존성 문제를 해결할 수 있다.</p>
<h2 id="Seperated-Interface-패턴"><a href="#Seperated-Interface-패턴" class="headerlink" title="Seperated Interface 패턴"></a>Seperated Interface 패턴</h2><p><img src="./seperated-interface.jpg" alt="seperated-interface"></p>
<p>위의 그림과 같이 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 한다.<br>그리고 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 한다.<br>이와 같은 기법을 <strong>Seperated Interface 패턴</strong> 이라 부른다.</p>
<p>이제 Movie클래스를 다른 컨텍스트에서 사용하기 위해서는 단지 Movie, DiscountPolicy가 포함된 패키지만 재사용하면 된다.</p>
<p>따라서 의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 한다.</p>
<blockquote>
<p>전통적인 패러다임에서는 상위 수준의 모듈이 하위 수준 모듈에 의존했다면<br>객체지향 패러다임에서는 상위 수준 모듈과 하위 수준 모듈이 모두 <strong>추상화</strong>에 의존한다.<br>전통적인 패러다임에서는 인터페이스가 하위 수준 모듈에 속했다면 <strong>객체지향 패러다임에서는 인터페이스가 상위 수준 모듈에 속한다.</strong>  </p>
<p>훌륭한 객체지향 설계를 위해서는 의존성을 역전시켜야 한다.<br>그리고 의존성을 역전시켜야만 유연하고 재사용 가능한 설계를 얻을 수 있다.</p>
</blockquote>
<h1 id="유연한-설계는-유연성이-필요할-때만-옳다"><a href="#유연한-설계는-유연성이-필요할-때만-옳다" class="headerlink" title="유연한 설계는 유연성이 필요할 때만 옳다"></a>유연한 설계는 유연성이 필요할 때만 옳다</h1><p>유연하고 재사용 가능한 설계란 런타임 의존성과 컴파일타임 의존성의 차이를 인식하고<br>동일한 컴파일 타임 의존성으로부터 런타임 의존성을 만들 수 있는 코드 구조를 가진 설계를 의미한다.<br>하지만 유연하고 재사용 가능한 설계가 항상 좋은 것은 아니다.<br>설계의 미덕은 단순함과 명확함으로부터 나온다. 단순하고 명확한 설계를 가진 코드는 읽기 쉽고 이해하기도 편하다.<br>변경하기 쉽고 확장하기 쉬운 구조를 만들기 위해서는 단순함과 명확함을 버리게 된다.</p>
<h2 id="유연한-설계-x3D-복잡한-설계"><a href="#유연한-설계-x3D-복잡한-설계" class="headerlink" title="유연한 설계 &#x3D; 복잡한 설계"></a>유연한 설계 &#x3D; 복잡한 설계</h2><p>사실 <strong>유연한 설계 &#x3D; 복잡한 설계</strong> 이다.<br>변경에 대비 하기 위해 유연한 설계를 하고 복잡한 구조를 만든다.<br>하지만 변경은 예상이 아니라 현실이어야 한다. 미래에 일어날지도 모른다는 막연한 불안감은 불필요하게 복잡한 설계를 낳는다.<br>아직 일어나지 않은 변경은 변경이 아니다.</p>
<h2 id="유연성은-항상-복잡성을-수반한다"><a href="#유연성은-항상-복잡성을-수반한다" class="headerlink" title="유연성은 항상 복잡성을 수반한다"></a>유연성은 항상 복잡성을 수반한다</h2><p>유연하지 않은 설계는 단순하고 명확하다. 유연한 설계는 복잡하고 암시적이다.<br>객체지향에 입문한 개발자들이 가장 이해하기 어려워하는 부분이 바로 코드 상에 표현된 정적인 클래스 구조와 실행 시점의 동적인 구조가 다르다는 사실이다.<br><strong>절차적 프로그래밍 방식은 코드의 구조가 곧 실행구조이다.</strong><br>하지만 객체지향 프로그래밍 방식에서 클래스의 구조는 발생 가능한 모든 객체 구조를 담는 틀일 뿐이다.<br>특정 시점의 객체 구조를 파악하는 유일한 방법은 클래스를 사용하는 클라이언트 코드 내에서 객체를 생성하거나 변경하는 부분을 직접 살펴보는 것이다.</p>
<h2 id="불필요한-유연성은-불필요한-복잡성을-낳는다"><a href="#불필요한-유연성은-불필요한-복잡성을-낳는다" class="headerlink" title="불필요한 유연성은 불필요한 복잡성을 낳는다."></a>불필요한 유연성은 불필요한 복잡성을 낳는다.</h2><p>단순하고 명확한 해법이 그런대로 만족스럽다면 유연성을 제거하라<br>유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다.<br>하지만 복잡성에 대한 걱정보다 유연하고 재사용 가능한 설계의 필요성이 더 크다면 코드의 구조와 실행 구조를 다르게 만들어야 한다.</p>
<h1 id="협력과-책임이-중요하다"><a href="#협력과-책임이-중요하다" class="headerlink" title="협력과 책임이 중요하다"></a>협력과 책임이 중요하다</h1><p>설계를 유연하게 만들기 위해서는 먼저 역할, 책임, 협력에 초점을 맞춰야 한다.<br>다양한 컨텍스트에서 재사용할 필요가 없다면 설계를 유연하게 만들 당위성도 함께 사라진다.</p>
<p>중요한 비지니스 로직을 처리하기 위해 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것 보다 우선이다. </p>
<p>객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는 것이 적절하다.</p>
<p>의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다.<br>따라서 역할, 책임, 협력에 먼저 집중해야 한다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - chapter9. 유연한 설계</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="2020/06/06/object-chapter8/">Objects Study - Chapter8. 의존성 관리하기</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-06</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>잘 설계된 객체지향 어플리케이션은 작고 응집도 높은 객체들로 구성된다.<br>작고 응집성 높은 객체란 책임의 초점이 명확하고 한 가지 일만 잘하는 객체를 의미한다.<br>따라서 객체 간 협력을 통해 다른 객체에게 도움을 요청하여 여러가지 일을 수행할 수 있다.<br><strong>협력은 객체가 다른 객체에 대해 알 것을 강요한다</strong><br><strong>다른 객체와 협력하기 위해서는 그런 객체 또는 클래스가 있다는 사실을 알고 있어야 한다.</strong><br><strong>객체가 수신할 수 있는 메세지에 대해서도 알고 있어야 한다.</strong>  </p>
<p>이런 지식들이 객체 사이의 의존성을 낳는다.</p>
<h1 id="의존성이란"><a href="#의존성이란" class="headerlink" title="의존성이란"></a>의존성이란</h1><p><strong>의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성</strong>을 의미한다.<br>어떤 객체가 협력하기 위해 다른 객체로 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다.<br>나아가 두 객체 사이 뿐만 아니라 모듈이나 더 큰 규모의 실행 시스템일 수도 있다. (ex. API 의존성)<br>의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.</p>
<ul>
<li>실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다. </li>
<li>구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.</li>
</ul>
<h2 id="의존성은-방향성을-가진다"><a href="#의존성은-방향성을-가진다" class="headerlink" title="의존성은 방향성을 가진다."></a>의존성은 방향성을 가진다.</h2><p>의존성은 방향성을 가지며 항상 단방향이다. (그 역은 성립하지 않는다.)<br>예를들어 PerioidCondition class에서 Screening class를 인자로 받는 경우  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Screening screening)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> screenging.startTime() ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PeriodCondition 클래스는 Screening 클래스에 의존한다</code> 라고 표현한다.  </p>
<p><img src="./dependency.jpg" alt="의존성표현"></p>
<h2 id="의존성은-변경에-취약하다"><a href="#의존성은-변경에-취약하다" class="headerlink" title="의존성은 변경에 취약하다"></a>의존성은 변경에 취약하다</h2><p>설계과 관련된 대부분의 용어들이 변경과 관련이 있다.<br>의존성 역시 변경과 관련이 있다.<br>두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다.<br>따라서 의존성은 변경에 의한 영향의 전파가능성을 암시한다.</p>
<h1 id="의존성-전이"><a href="#의존성-전이" class="headerlink" title="의존성 전이"></a>의존성 전이</h1><p><img src="./dependency-transfer.jpg" alt="dependency-transfer"></p>
<p>PeriodCondition 클래스가 Screening 클래스에 의존하고,  Screening 클래스가 Movie 클래스에 의존하는 경우 의존성이 전이될 수 있다.   </p>
<p>의존성이란 함께 변경될 수 있는 <strong>가능성</strong> 을 의미하기 때문에 모든 경우에 의존성이 전이되는 것은 아니다.<br>의존성이 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다.  </p>
<p>단, 의존성 전이는 변경에 의해 영향이 전파될 수도 있다는 일종의 경고이다.</p>
<h2 id="직접-의존성과-간접-의존성"><a href="#직접-의존성과-간접-의존성" class="headerlink" title="직접 의존성과 간접 의존성"></a>직접 의존성과 간접 의존성</h2><ul>
<li>직접 의존성: 말 그대로 한 요소가 다른 요소에 직접 의존하는 경우를 가르킨다.</li>
<li>위의 예제에서 PeriodCondition은 Screening에 직접 의존한다.</li>
<li>이 경우 의존성은 코드에 명시적으로 드러난다. (PeriodCondition 내부 코드에서 Screening을 참조하는 코드가 존재한다)</li>
<li>간접 의존성: 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 가리킨다.<ul>
<li>위의 예제에서 Movie 클래스 변경으로 인해 PeriodCondition까지 변경의 영향이 있을 수도 있음을 의미한다.</li>
<li>이 경우 의존성은 명시적으로 드러나지 않는다. (PeriodCondition 내부 코드에서 Movie에 대한 참조는 없다)</li>
</ul>
</li>
</ul>
<h1 id="Runtime-의존성과-Compile-time-의존성"><a href="#Runtime-의존성과-Compile-time-의존성" class="headerlink" title="Runtime 의존성과 Compile time 의존성"></a>Runtime 의존성과 Compile time 의존성</h1><h2 id="Runtime-의존성"><a href="#Runtime-의존성" class="headerlink" title="Runtime 의존성"></a>Runtime 의존성</h2><ul>
<li>어플리케이션이 실행되는 시점에 갖는 의존성을 의미</li>
<li>런타임에 실제 생성되는 객체 간의 의존성을 가리킨다.</li>
</ul>
<p><img src="./runtime-dependency.jpg" alt="runtime-dependency"></p>
<p>Movie라는 클래스와 AmountDiscountPolicy, PercentDiscountPolicy는 런타임에 직접적인 의존성을 갖는다.</p>
<h2 id="Compile-time-의존성"><a href="#Compile-time-의존성" class="headerlink" title="Compile time 의존성"></a>Compile time 의존성</h2><ul>
<li>작성된 코드를 컴파일 하는 시점을 의미 (또는 문맥에 따라서는 코드 그 차제를 가리키기도 한다.)</li>
<li>동적 타입 언어의 경우에는 컴파일 타입이 존재하지 않기 때문에 컴파일이 수행되는 시점으로만 생각하면 의미가 모호해진다.</li>
<li>컴파일 타임에서는 코드에 대한 의존성을 가리킨다.</li>
<li>코드 관점에서는 Class 간의 의존성을 가리킨다.</li>
</ul>
<p><img src="./compiletime-dependency.jpg" alt="compiletime-dependency"></p>
<p>Movie라는 클래스는 DiscountPolicy라는 클래스는 컴파일타임 의존성을 갖는다.<br>실제 Movie 클래스와 AmountDiscountPolicy, PercentDiscountPolicy는 코드 관점에서의 의존성은 존재하지 않는다.</p>
<h1 id="유연하고-재사용-가능한-설계"><a href="#유연하고-재사용-가능한-설계" class="headerlink" title="유연하고 재사용 가능한 설계"></a>유연하고 재사용 가능한 설계</h1><p>유연하고 재사용 가능한 설계를 하기 위해서는 동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 한다.<br>어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안된다.<br>실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다.<br>만약 클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 읺스턴스와 협력할 가능성 자체가 없어지게 된다.<br>따라서 <strong>컴파일 타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연하고 재사용 가능해 진다.</strong></p>
<blockquote>
<p>객체지향 프로그램의 실행 구조는 소스코드 구조와 일치하지 않는 경우가 종종 있다.<br>코드 구조는 컴파일 시점에 확정되는 것이고 이 구조에는 고정된 상속 클래스 관계들이 포함된다.<br>하지만 프로그램 실행 시점 구조는 협력하는 객체에 따라 달라질 수 있다.</p>
</blockquote>
<h2 id="컨텍스트-독립성"><a href="#컨텍스트-독립성" class="headerlink" title="컨텍스트 독립성"></a>컨텍스트 독립성</h2><p>유연하고 확장 가능한 설계를 만들기 위해서는 compile time 의존성과 runtime 의존성이 달라야 한다.<br>클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안 된다.<br>구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문이다.</p>
<p>클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다.<br>클래스가 사용 될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다.</p>
<p>이를 <strong>컨텍스트 독립성</strong> 이라 부른다.</p>
<p><strong>설계를 유연하게 만드는 마법</strong></p>
<ul>
<li>자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 작게 알아야 한다.<ul>
<li>각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못한다는 의미</li>
<li>최소한의 정보만 알자</li>
</ul>
</li>
<li>정보가 적으면 다양한 컨텍스트에서 재사용 될 수 있다.</li>
<li>설계는 더 유연해지고 변경에 대응하기 쉬워진다.<ul>
<li>응집력 있는 객체를 만들 수 있다</li>
<li>객체 구성 조합에 따라 변경 가능한 시스템으로 나아갈 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="의존성-해결하기"><a href="#의존성-해결하기" class="headerlink" title="의존성 해결하기"></a>의존성 해결하기</h2><p><strong>compile time 의존성은 구체적인 runtime 의존성으로 대체돼야 한다.</strong></p>
<p>이를 <strong>의존성 해결</strong> 이라 부른다.</p>
<p>의존성을 해결하는 방법은 일반적으로 다음과 같은 세 가지 방법을 사용한다.</p>
<ul>
<li><p>객체를 생성하는 시점에 생성자를 통해 의존성을 해결</p>
<ul>
<li>new A(new B())</li>
</ul>
</li>
<li><p>객체 생성 후 setter 메서드를 통해 의존성 해결</p>
<ul>
<li>(new A()).setB(new B())</li>
</ul>
</li>
<li><p>메서드 실행 시 인자를 이용해 의존성 해결</p>
<ul>
<li>(new A()).method(new B())</li>
<li>이 방식은 협력 대상에 대해 지속적으로 의존 관계를 맺을 필요 없이 메서드가 실행되는 동안만 의존 관계가 존재해도 무방한 경우</li>
<li>메서드 실행 시마다 의존 대상이 매번 달라져야 하는 경우에 유용</li>
</ul>
</li>
</ul>
<h2 id="Setter-Method-방식의-단점"><a href="#Setter-Method-방식의-단점" class="headerlink" title="Setter Method 방식의 단점"></a>Setter Method 방식의 단점</h2><p>setter 메서드를 이용하는 방법은 실행 시점에 의존 대상을 변경할 수 있기 때문에 설계를 좀 더 유연하게 만들 수 있다.<br>하지만 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에<br><strong>객체를 생성하고 의존 대상을 설정하기 전까지는 객체의 상태가 불완전</strong>할 수 있다는 점이다.</p>
<p>아래와 같은 코드는 NullPointerException 예외가 발생할 것이다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Movie</span> <span class="variable">avatar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>();</span><br><span class="line">avatar.caculateFee(); <span class="comment">//discount policy가 아직 설정되지 않았기 때문에 NPE가 발생한다</span></span><br><span class="line">avatar.setDiscountPolicy(<span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br></pre></td></tr></table></figure>

<h2 id="생성자-방식-setter-방식"><a href="#생성자-방식-setter-방식" class="headerlink" title="생성자 방식 + setter 방식"></a>생성자 방식 + setter 방식</h2><p>setter method 방식을 보완하기 위해서는 생성자 방식와 setter 방식을 혼합하는 것이다.<br>항상 객체를 생성할 때 의존성을 해결해서 완전한 상태의 객체를 생성한 후 필요에 따라 setter 메서드를 이용해 의존대상을 변경할 수 있게 할 수 있다.<br>이 방법은 시스템의 상태를 안정적으로 유지하면서도 유연성을 향상시킬 수 있기 때문에 의존성 해결을 위해 가장 선호되는 방법이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Movie</span> <span class="variable">avatar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>());</span><br><span class="line">avatar.setDiscountPolicy(<span class="keyword">new</span> <span class="title class_">PercentDiscountPolicy</span>());</span><br></pre></td></tr></table></figure>

<h1 id="의존성과-결합도"><a href="#의존성과-결합도" class="headerlink" title="의존성과 결합도"></a>의존성과 결합도</h1><p>객체지향 패러다임의 근간은 협력이다. 따라서 객체들이 협력하기 위해서는 서로의 존재와 수행 가능한 책임을 알아야한다.<br>이런 지식들이 의존성을 낳는다.<br>따라서 모든 의존성이 나쁜 것은 아니다. 의존성은 객체들의 협력을 가능하게 하는 매개체이기 때문이다.<br>하지만 의존성이 과하면 문제가 된다.</p>
<p>바람직한 의존성을 위해서는 <strong>재사용성</strong>을 고려해야한다.  </p>
<ul>
<li>어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못하다  <ul>
<li>특정 컨텍스트에 강하게 결합된 의존성은 바람직하지 못하다</li>
</ul>
</li>
<li>어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 있다면 그 의존성은 바람직하다.<ul>
<li>특정 컨텍스트에 독립적인 의존성은 바람직한 의존성이다.</li>
</ul>
</li>
</ul>
<p>바람직한 의존성과 바람직 하지 못한 의존성을 나타내는 용어로 <strong>결합도</strong> 라는 용어를 사용한다. </p>
<ul>
<li>강한 결합도 (tight coupling)<ul>
<li>의존성이 다양한 환경에서 클래스를 재사용할 수 없는 바람직하지 못한 의존성</li>
</ul>
</li>
<li>약한 결합도 (loose coupling)<ul>
<li>의존성이 다양한 환경에서 클래스를 재사용할 수 있는 의존성</li>
<li>컨텍스트 독립적인 의존성</li>
</ul>
</li>
</ul>
<h2 id="지식이-결합을-낳는다"><a href="#지식이-결합을-낳는다" class="headerlink" title="지식이 결합을 낳는다."></a>지식이 결합을 낳는다.</h2><p>결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.<br>많은 요소를 알고 있을 수록 두 요소는 강하게 결합된다. </p>
<p>예시</p>
<ul>
<li>일단 가격을 계산한다. -&gt; 약한 결합도</li>
<li>가격을 계산하는데 할인방식은 금액 할인 방식이고 평일에만 할인이 된다. -&gt; 강한 결합도</li>
</ul>
<h2 id="추상화에-의존하라"><a href="#추상화에-의존하라" class="headerlink" title="추상화에 의존하라"></a>추상화에 의존하라</h2><p>추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나<br>감춤으로써 복잡도를 극복하는 방법이다.</p>
<p>추상화를 이용하면 현재 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다.<br>따라서 대상에 대해 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있다.</p>
<p>목록에서 아래쪽으로 갈수록 클라이언트가 알아야하는 지식의 양이 적어지기 때문에 결합도가 느슨해진다.</p>
<ul>
<li>구체 클래스 의존성 (concrete class dependency)</li>
<li>추상 클래스 의존성 (abstract class dependency)</li>
<li>인터페이스 의존성 (interface dependency)</li>
</ul>
<p>따라서 의존하는 대상이 더 추상적일 수록 결합도는 낮아진다</p>
<h2 id="명시적인-의존성"><a href="#명시적인-의존성" class="headerlink" title="명시적인 의존성"></a>명시적인 의존성</h2><p>결합도를 느슨하게 만들기 위해서는 인스턴스 변수의 타입을 추상 클래스나 인터페이스로 선언하는 것만으로는 부족하다<br>클래스 안에서 구체 클래스에 대한 모든 의존성을 제거해야 한다. (아예 import도 안되게)<br>하지만 런타임에는 구체클래스의 인스턴스와 협력해야 하기 때문에 클래스의 인스턴스 타입이 뭔지는 알아야 한다.</p>
<p>위에서 얘기했던 것 처럼 의존성을 해결하는 방법에는 생성자, setter 메서드, 메서드 파라미터를 사용하는 세 가지 방식이 있다.<br>여기서의 방법은 인스턴스 변수의 타입은 추상 클래스나 인터페이스로 정의하고<br>생성자, setter 메서드, 메서드 파라미터로 실제 코드를 작성할 때에는 구체 클래스를 사용하는 것이다</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(DiscountPoilcy discountPolicy)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Movie</span> <span class="variable">movie</span> <span class="operator">=</span> Movie(<span class="keyword">new</span> <span class="title class_">AccountDiscountPolicy</span>());</span><br></pre></td></tr></table></figure>

<p>의존성을 대상을 <strong>생성자의 인자로 전달받는 방법</strong>과 <strong>생성자 안에서 직접 생성하는 방식</strong> 의 큰 차이점은<br>퍼블릭 인터페이스를 통해 할인 정책을 설정할 수 있는 방법을 제공하는지의 대한 여부다<br>명시적으로 퍼블릭 인터페이스를 통해 의존성을 노출하는 방식을 <strong>명시적인 의존성</strong> 이라고 부른다.</p>
<h2 id="숨겨진-의존성"><a href="#숨겨진-의존성" class="headerlink" title="숨겨진 의존성"></a>숨겨진 의존성</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = <span class="keyword">new</span> <span class="title class_">AccountDiscountPolicy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>반면 위와 같은 코드에서는 할인 정책에 대한 의존성을 퍼블릭 인터페이스로 제공하지 않고 코드 내에 숨겨져 있다.<br>의존성이 퍼블릭 인터페이스에 표현되지 않는 방식을 <strong>숨겨진 의존성</strong> 이라고 부른다.<br>의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수 밖에 없다.</p>
<h2 id="의존성을-내부-구현으로-숨겨두지-마라"><a href="#의존성을-내부-구현으로-숨겨두지-마라" class="headerlink" title="의존성을 내부 구현으로 숨겨두지 마라"></a>의존성을 내부 구현으로 숨겨두지 마라</h2><p>의존성은 명시적으로 표현되어야 한다.<br>의존성을 내부 구현에 숨겨 두면 개발자가 직접 내부 구현을 살펴봐야하는 고통이 따른다.<br>유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계이다.<br>명시적인 의존성을 사용해야지만 퍼블릭 인터페이스를 통해 컴파일 타임 의존성을 적절한 런타임 의존성으로 교체할 수  있다.  </p>
<h2 id="new는-해롭다"><a href="#new는-해롭다" class="headerlink" title="new는 해롭다"></a>new는 해롭다</h2><p>대부분의 언어에서는 클래스의 인스턴스를 생성할 수 있는 new 연산자를 제공한다.<br>안타까운 사실은 new를 잘못 사용하면 클래스 사이의 결합도가 극단적으로 높아진다.<br>결합도 측면에서 new가 해로운 이유는 크게 두 가지다.</p>
<ul>
<li>new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 서술하여야 한다.<ul>
<li>따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수밖에 없기 때문에 결합도가 높아진다.</li>
</ul>
</li>
<li>new 연산자는 생성하려는 구체 클래스 뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다.<ul>
<li>따라서 new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다.</li>
</ul>
</li>
</ul>
<p>따라서 new 연산자를 통한 구체 클래스 생성을 잘못하면 결합도가 높아지므로 변경에 의해 영향을 받기 쉬워진다.<br>또한 new를 통해 구체 클래스 생성에 끝나는 것이 아닌 협력할 구체 클래스의 인스턴스를 생성하기 위해 아래와 같은 지식이 필요하다</p>
<ul>
<li>어떤 인자들이 필요한가?</li>
<li>어떤 순서로 파라미터를 사용해야 하는가?</li>
<li>인자들에 대한 타입도 의존성에 추가된다</li>
</ul>
<h2 id="new를-없애기-위해서는"><a href="#new를-없애기-위해서는" class="headerlink" title="new를 없애기 위해서는"></a>new를 없애기 위해서는</h2><p>new를 사용하지 않도록 하기 위해서는 다음과 같은 방법을 사용하면 된다.</p>
<p><strong>인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리한다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(DiscountPolicy discountPolicy)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//다른 클라이언트 코드에서 생성</span></span><br><span class="line"><span class="type">Movie</span> <span class="variable">movie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>()); <span class="comment">//1</span></span><br><span class="line">movie.setDiscountPolicy(<span class="keyword">new</span> <span class="title class_">PercentDiscountPolicy</span>()); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>위의 코드처럼 사용한다면 Movie라는 클래스 내에서는 구체 클래스에 대한 의존성 없이 DiscountPolicy라는 인터페이스 의존성만 존재한다.  </p>
<ol>
<li><p>실제 구체 클래스가 되는 AmountDiscountPolicy의 대한 생성 책임은 Movie 클래스를 생성하는 클라이언트로 옮겨지고<br>Movie는 AmountDiscountPolicy의 인스턴스를 사용하는 책임만 남는다.</p>
</li>
<li><p>DiscountPolicy라는 인터페이스 의존성만 Movie 클래스에 두었기 때문에 다른 할인정책을 적용하더라도 유연하게 사용이 가능하다</p>
</li>
</ol>
<h2 id="new를-가끔은-사용해도-괜찮다"><a href="#new를-가끔은-사용해도-괜찮다" class="headerlink" title="new를 가끔은 사용해도 괜찮다."></a>new를 가끔은 사용해도 괜찮다.</h2><p>클래스 안에서 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우도 있다.<br>주로 협력하는 기본 객체를 설정하고 싶은 경우가 이에 속한다. </p>
<p>대부분의 경우에는 <code>AmountDiscountPolicy</code> 의 인스턴스와 협력하는 경우를 생각해보자 </p>
<p>이런 상황에서 모든 경우에 인스턴스를 생성하는 책임을 클라이언트로 옮긴다면 클라이언트 코드들 사이에 중복 코드가 늘어나고<br>Movie의 사용성도 나빠질 것이다.</p>
<p>이런 문제를 해결하는 방법을 기본 객체에 생성하는 생성자를 추가하고<br>이 생성자에서 DiscountPolicy의 인스턴스를 인자로 받는 생성자를 체이닝 하는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>()); <span class="comment">//1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(DiscountPolicy discountPolicy)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>기본 생성자에서 DiscountPolicy를 파라미터로 받는 생성자를 호출한다.<br>호출 시, AmountDiscountPolicy 객체를 사용하여 Movie 객체를 생성하도록 한다.</li>
</ol>
<p>이제 클라이언트에서는 대부분의 경우에 기본 생성자를 통해 AmountDiscountPolicy의 인스턴스와 협력하게 하면서도<br>컨텍스트에 적절한 DiscountPolicy의 인스턴스로 의존성을 교체할 수 있다.</p>
<h2 id="표준-클래스에-대한-의존은-해롭지-않다"><a href="#표준-클래스에-대한-의존은-해롭지-않다" class="headerlink" title="표준 클래스에 대한 의존은 해롭지 않다"></a>표준 클래스에 대한 의존은 해롭지 않다</h2><p>의존성이 불편한 이유는 그것이 항상 변경에 대한 영향을 암시하기 때문이다.<br>따라서 변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다. </p>
<p>예를 들어 JDK에 포함된 표준 클래스가 이 부류에 속한다.<br>String, ArrayList와 같은 클래스들은 거의 제로에 가깝기 때문에 인스턴스를 직접 new로 생성하더라도 문제가 되지 않는다.</p>
<p>비록 클래스를 직접 생성하더라도 가능한 추상적인 타입을 사용하는 것이 확장성 측면에서 유리하다</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;DiscountCondition&gt; conditions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>위의 코드와 같이 ArrayList를 사용하여 객체를 생성하더라도 타입을 ArrayList의 인터페이스인 List를 사용하면<br>확장성 측면에서 유리하다</p>
<p>추가적으로 <strong>의존성에 대한 영향이 적은 경우에도 추상화에 의존하고 의존성을 명시적으로 드러내는 것은 좋은 설계</strong>이다.</p>
<h1 id="조합-가능한-행동"><a href="#조합-가능한-행동" class="headerlink" title="조합 가능한 행동"></a>조합 가능한 행동</h1><p>어떤 객체와 협력하느냐에 따라 객체의 행동이 달라지는 것은 유연하고 재사용 가능한 설계가 가진 특징이다.<br>유연하고 재사용 가능한 설계는 응집도 높은 책임들을 가진 작은 객체들을 다양한 방식으로 연결함으로써 애플리케이션의 기능을 쉽게 확장할 수 있다.</p>
<p>그렇다면 유연하고 재사용 가능한 설계는 무엇인가?<br>바로 객체가 어떻게(how) 하는지에 대한 코드를 장황하게 나열하지 않고,<br>객체들의 조합을 통해 무엇(what)을 하는지를 표현하는 클래스들로 구성된다. </p>
<p>따라서 클래스의 인스턴스를 생성하는 코드를 보는 것만으로 객체가 어떤 일을 하는지 쉽게 파악할 수 있다.<br>코드에 드러난 로직을 해석할 필요 없이 객체가 어떤 객체와 연결됐는지를 보는 것만으로도 객체의 행동을 쉽게 예상하고 이해할 수 있기 때문이다.</p>
<p>다시 말해 선언적으로 객체의 행동을 정의할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Movie</span>(</span><br><span class="line">  <span class="string">&quot;아바타&quot;</span>,</span><br><span class="line">  Duration.ofMinutes(<span class="number">120</span>),</span><br><span class="line">  Money.wons(<span class="number">10000</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">AmountDiscountPolicy</span>(</span><br><span class="line">    Money.wons(<span class="number">800</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SequenceCondition</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SequenceCondition</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PeriodCondition</span>(</span><br><span class="line">      DayOfWeek.MONDAY, </span><br><span class="line">      LocalTime.of(<span class="number">10</span>, <span class="number">0</span>), </span><br><span class="line">      LocalTime.of(<span class="number">12</span>, <span class="number">0</span>)</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PeriodCondition</span>(</span><br><span class="line">      DayOfWeek.THURSDAY, </span><br><span class="line">      LocalTime.of(<span class="number">10</span>, <span class="number">0</span>), </span><br><span class="line">      LocalTime.of(<span class="number">21</span>, <span class="number">0</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>위의 코드를 보면 객체의 행동이 짐작이 간다. </p>
<ol>
<li>영화 제목은 아바타</li>
<li>영화의 가격은 10,000원</li>
<li>가격 할인 정책이 적용된다</li>
<li>할인 금액은 800원</li>
<li>1회차, 10회차 영화에 대해 할인이 적용된다</li>
<li>월요일에는 10시~12시 사이의 영화에 대해서 할인이 적용된다</li>
<li>목요일에는 10시~21시 사이의 영화에 대해서 할인이 적용된다</li>
</ol>
<p>이와 같이 유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로써 새로운 행돌을 이끌어낼 수 있는 설계다<br><strong>훌륭한 객체지향 설계란 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계다</strong></p>
<p>그리고 지금까지 설명한 것처럼 이런 설계를 창조하는 데 있어서의 핵심은 의존성을 관리하는 것이다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - chapter8. 의존성 관리하기</li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="archives/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="archives/12/">12</a><a class="extend next" rel="next" href="archives/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Carrey</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>