<!DOCTYPE html><html lang="lang"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spring IoC &amp; DI(2)"><meta name="keywords" content="Spring"><meta name="author" content="Carrey"><meta name="copyright" content="Carrey"><title>Spring IoC &amp; DI(2) | Carrey`s 기술블로그</title><link rel="shortcut icon" href="../../../../melody-favicon.ico"><link rel="stylesheet" href="../../../../css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IoC%EB%9E%80"><span class="toc-number">1.</span> <span class="toc-text">IoC란?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Container%EA%B0%80-%EB%8F%84%EB%8D%B0%EC%B2%B4-%EB%AD%90%EB%9E%8C"><span class="toc-number">2.</span> <span class="toc-text">Container가 도데체 뭐람?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DI%EB%9E%80"><span class="toc-number">3.</span> <span class="toc-text">DI란?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-Annotation"><span class="toc-number">4.</span> <span class="toc-text">의존성 주입 Annotation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DI-%EA%B5%AC%ED%98%84%EB%B0%A9%EC%8B%9D"><span class="toc-number">5.</span> <span class="toc-text">DI 구현방식</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Constructor-Injection"><span class="toc-number">5.1.</span> <span class="toc-text">Constructor Injection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Extension-Constructor-Injection"><span class="toc-number">5.2.</span> <span class="toc-text">Extension Constructor Injection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Setter-Injection"><span class="toc-number">5.3.</span> <span class="toc-text">Setter Injection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Field-Injection"><span class="toc-number">5.4.</span> <span class="toc-text">Field Injection</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%9A%A9%EC%96%B4-%EC%84%A4%EB%AA%85"><span class="toc-number">6.</span> <span class="toc-text">용어 설명</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bean-%EB%93%B1%EB%A1%9D-%EB%B0%A9%EB%B2%95"><span class="toc-number">7.</span> <span class="toc-text">Bean 등록 방법</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Component-Scan"><span class="toc-number">7.1.</span> <span class="toc-text">Component-Scan</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet-Context-xml"><span class="toc-number">7.2.</span> <span class="toc-text">Servlet-Context.xml</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Configuration"><span class="toc-number">7.3.</span> <span class="toc-text">@Configuration</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bean-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0"><span class="toc-number">8.</span> <span class="toc-text">Bean 생명주기</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#InitializingBean-DisposableBean-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EA%B5%AC%ED%98%84"><span class="toc-number">8.1.</span> <span class="toc-text">InitializingBean, DisposableBean 인터페이스 구현</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%EC%A0%95%EC%9D%98-%EC%8B%9C-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%A7%80%EC%A0%95"><span class="toc-number">8.2.</span> <span class="toc-text">Bean정의 시 , 메소드 지정</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PostConstruct-PreDestroy-Annotation-%EC%82%AC%EC%9A%A9"><span class="toc-number">8.3.</span> <span class="toc-text">@PostConstruct, @PreDestroy Annotation 사용</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bean-Scope"><span class="toc-number">9.</span> <span class="toc-text">Bean Scope</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%B0%B8%EC%A1%B0"><span class="toc-number">10.</span> <span class="toc-text">참조</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300"></div><div class="author-info__name text-center">Carrey</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="../../../../archives"><span class="pull-left">Articles</span><span class="pull-right">112</span></a><a class="author-info-articles__tags article-meta" href="../../../../tags"><span class="pull-left">Tags</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="../../../../index.html">Carrey`s 기술블로그</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Spring IoC &amp; DI(2)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-22</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="IoC란"><a href="#IoC란" class="headerlink" title="IoC란?"></a>IoC란?</h1><p>Inversion of Control (제어의 역전) 이라는 의미로 사용되고 있다.<br>보통의 프로그램에서는 개발자가 필요한 객체를 직접 new를 통해 생성하여 사용한다.<br>하지만 Spring과 같은 프레임워크에서는 흐름의 주체가 Container가 되어 Container에서 객체의 생성과 소멸을 관리하며<br>개발자가 개발한 애플리케이션 코드를 호출하여 프로그램의 흐름을 관장한다.</p>
<p>따라서 프로그램의 흐름을 개발자가 관장하는 것이 아닌 프레임워크에게 그 권한이 넘어갔다(역전되었다.) 하여<br>제어의 역전 (Inversion of Control)이라 불린다.</p>
<h1 id="Container가-도데체-뭐람"><a href="#Container가-도데체-뭐람" class="headerlink" title="Container가 도데체 뭐람?"></a>Container가 도데체 뭐람?</h1><p><img src="./containers.jpg" alt="containers"></p>
<p>개발 공부를 하다보면 은근 컨테이너(Container)라는 용어를 많이 듣게 된다.<br>Spring 컨테이너, 서블릿 컨테이너, EJB컨테이너등등.. Container라는 용어를 듣게 되는데 컨테이너는 도데체 무엇일까?<br>위의 이미지와 연상해보면 무엇인가를 담아놓은 박스를 연상할 수 있다.<br>이러한 컨테이너 말고도, 컨테이너 처럼 생긴 공장도 있다. 이게 개발자가 상상해야 하는 컨테이너와 부합하는 이미지 같다.<br>컨테이너 내부에 물건을 적재하고 물건에 대한 관리도 하는.. 컨테이너를 생각하는 것이 도움이 될 것 같다.<br>실제 프레임워크에서의 컨테이너도 같은 역할을 한다. </p>
<p><strong>이는 객체에 대한 생성부터 소멸까지 생명주기를 관리하며, 시스템이 로드 될 때, 필요한 객체를 생성하여 컨테이너에 담아두고 필요 할 때 사용한다. 뿐만아니라 객체에 대한 추가적인 기능을 제공하는 주체</strong>라고 할 수 있다. </p>
<p>위에서 예시로 든 컨테이너를 바탕으로 생각을 해보면</p>
<p>서블릿 (Servlet) 컨테이너는 WAS(Web Application Server) 내 에서 서블릿 객체의 생성, 소멸 대한 처리를 담당하며,<br>외부에서 요청이 들어오면 서블릿 객체를 사용한다. 이 뿐만 아니라 Spring Security 같은 Servlet filter를 이용하여 추가적인 기능을 제공한다.</p>
<p>Spring Container는 POJO 클래스를 Bean으로 생성하고 소멸까지 생명주기를 관리한다. 또한 Bean이 호출 될 때 의존성을 갖는 클래스에 대해 컨테이너에서 필요한 객체를 찾아 주입해 준다. 이 뿐만 아니라 객체에 대한 Transaction, Security, Pooling에 대한 기능을 추가적으로 제공하고 있다.</p>
<h1 id="DI란"><a href="#DI란" class="headerlink" title="DI란?"></a>DI란?</h1><p>DI란 Dependency Injection의 의미로 의존성 주입이라는 뜻을 가지고 있다.<br>DI는 IoC라는 개념을 실제로 구현한 대표적인 예이며, 대부분 IoC와 혼용하여 사용한다.<br>개념 자체는 <code>IoC의 형태 중 하나</code>라고 볼 수 있다.</p>
<p>DI는 Spring 프레임워크에서 객체의 의존성 관계를 생성하는 역할을 한다.<br>클래스 내에서 개발자가 new를 통해 객체 생성을 직접 하지 않아도 DI를 통해 객체를 주입하여 컴포넌트화 하여 객체 내에서 사용 할 수 있다는 장점이 있다.</p>
<p>Spring에서는 @Autowired 어노테이션을 통해 간단하게 의존성 주입 설정을 할 수 있으며<br>객체 내에 의존성 객체를 주입하는 방식은 4가지 정도 있다.</p>
<ol>
<li>Constructor Injection</li>
<li>Dependency Constructor Injection</li>
<li>Setter Injection</li>
<li>Field Injection</li>
</ol>
<h1 id="의존성-주입-Annotation"><a href="#의존성-주입-Annotation" class="headerlink" title="의존성 주입 Annotation"></a>의존성 주입 Annotation</h1><p>Spring&#x2F;Java에서는 의존성 주입을 위한 어노테이션을 제공하여 간단하게 의존성 주입을 구현할 수 있다.</p>
<ul>
<li>@Autowired<ul>
<li>Spring에서 지원하는 Annotation</li>
<li><code>Type</code>에 맞춰서 주입이 된다.</li>
<li>Interface에 상응하는 Bean이 2개 이상 인 경우에는 <code>@Qualifier(&quot;beanName&quot;)을 혼용</code>하여<br>필요한 Bean객체를 주입한다.</li>
</ul>
</li>
<li>@Inject<ul>
<li>Java에서 지원하는 Annotation</li>
<li><code>Type</code>에 맞춰서 주입이 된다.</li>
</ul>
</li>
<li>@Resource<ul>
<li>Java에서 지원하는 Annotation</li>
<li><code>이름</code>에 맞춰서 주입이 된다.</li>
</ul>
</li>
</ul>
<p>Spring Framework 기반에서 Java Framework로의 Conversion 계획이 있다면, @Inject&#x2F;@Resource를 사용하면 문제는 없을 것이나.. 대부분은 @Autowired를 사용한다.</p>
<h1 id="DI-구현방식"><a href="#DI-구현방식" class="headerlink" title="DI 구현방식"></a>DI 구현방식</h1><h2 id="Constructor-Injection"><a href="#Constructor-Injection" class="headerlink" title="Constructor Injection"></a>Constructor Injection</h2><p>생성자에 @Autowired 어노테이션을 이용하여 UserRepository 객체를 삽입하는 방법이다.<br>이 방법은 xml 설정 시에 유용한 방법이다.<br>객체 생성 시, 주입을 하기 때문에 객체가 생성된 이후에는 주입된 객체를 변경 할 수 없다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class UserService &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userRepository&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.user.UserRepository&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span>, <span class="attr">class</span>=<span class="string">&quot;com.example.user.UserService&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">construct-args</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;userRepository&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">construct-args</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Extension-Constructor-Injection"><a href="#Extension-Constructor-Injection" class="headerlink" title="Extension Constructor Injection"></a>Extension Constructor Injection</h2><p>Spring 4에 추가된 DI방법이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class UserService &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserService에 @Autowired를 선언 하지 않아도 의존성 주입을 할 수 있게 되었다.<br>어찌보면 당연한 내용 같은데…  Lombok을 이용해서 의존성 주입이 가능해 졌다는 점이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> Class UserService &#123;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Setter-Injection"><a href="#Setter-Injection" class="headerlink" title="Setter Injection"></a>Setter Injection</h2><p>Setter를 통해 DI하는 방법이다.<br>이 방법은 외부에서 setter를 통해 의존성 객체를 변경 할 수 있는 소지가 있어 상당히 주의해야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class UserService &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">setUserRepository</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Field-Injection"><a href="#Field-Injection" class="headerlink" title="Field Injection"></a>Field Injection</h2><p>Spring을 사용하는 개발자들이 가장많이 사용하는 DI방법이다.<br>아무래도 코드량이 적으니 다들 많이 사용하는 방법인 듯 싶다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class UserService &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="용어-설명"><a href="#용어-설명" class="headerlink" title="용어 설명"></a>용어 설명</h1><ul>
<li>Bean<ul>
<li>Spring Container에 등록 되는 POJO객체 </li>
<li>Spring Application의 Component들이 등록 된다.</li>
<li>기본적으로 Bean은 특별한 경우가 아닌이상 Stateless(상태정보는 없음) Bean을 등록한다.</li>
</ul>
</li>
<li>Bean Factory<ul>
<li>Spring IoC를 담당하는 핵심 컨테이너</li>
<li>Bean에 대한 등록&#x2F;생성&#x2F;조회&#x2F;소멸을 관리한다.</li>
<li>BeanFactory는 interface이며 주로 구현체인 ApplicationContext를 사용한다.</li>
<li>대표적으로 getBean() 메서드를 제공한다. (Bean의 Meta 정보를 바탕으로 Bean 조회)</li>
</ul>
</li>
<li>Application Context<ul>
<li>BeanFactory 인터페이스의 구현체 ()<ul>
<li>정확히는 ListableBeanFactory</li>
<li>Bean을 Listable하게 보관하는 인터페이스를 말한다.</li>
</ul>
</li>
<li>BeanFactory의 기능 이외에 Spring의 추가적인 기능을 제공한다.<ul>
<li>ResourceLoader - ApplicationContext 로드에 필요한 설정 파일들을 로드한다.</li>
<li>ApplicationEventPublisher - 이벤트 발생을 관장한다.</li>
<li>MessageSource - properties파일을 통해 다국어 설정이 가능</li>
<li>BeanLifecycle - Bean의 초기화, 소멸을 담당한다.</li>
</ul>
</li>
</ul>
</li>
<li>Configuration Meta Data <ul>
<li>Application Context에서 IoC 설정을 위해 사용되는 메타정보</li>
<li>컨테이너에 어떤 기능을 세팅할때 사용</li>
<li>Bean 생성&#x2F;구성할 경우에도 사용</li>
<li>@Configuration 어노테이션을 통해 클래스로 설정 정보 구현이 가능</li>
</ul>
</li>
</ul>
<h1 id="Bean-등록-방법"><a href="#Bean-등록-방법" class="headerlink" title="Bean 등록 방법"></a>Bean 등록 방법</h1><h2 id="Component-Scan"><a href="#Component-Scan" class="headerlink" title="Component-Scan"></a>Component-Scan</h2><p>Spring에서 가장 편하게 Bean을 등록할 수 있는 방법이다.<br>Spring에서 component-scan에 package나 class를 설정하면 해당 class들에 대해 @Component 어노테이션이 달려 있는 경우 자동으로 Spring Bean으로 등록 해주는 기능이다.<br>분명 편리한 기능이긴 하지만 여러 프로젝트에서 공통적으로 패키지를 사용하는 경우에는 안쓰는 Bean들도 생길 수 있기 때문에<br>불필요한 메모리 할당이 이루어질 수 있다.<br>그렇기는 해도 최근 Spring을 사용하여 개발하는 경우에는 <code>가장 많이 하는 설정</code>이 아닐까 싶다.</p>
<ul>
<li>@Component 종류<ul>
<li>@Controller : Presentaion Layer의 Bean을 선언 (주로 외부로부터 요청을 받는 Controller Class)</li>
<li>@Service :  Service Layer의 Bean을 선언 (핵심 비지니스 로직을 구현한 Class)</li>
<li>@Repository : Persistent Layer의 Bean을 선언 (주로 DB, Cache와 같은 저장소와 연동을 위한 Class)</li>
<li>@Configuration : Configuration Layer의 Bean을 선언 (주로 Bean을 생성하거나, Spring Container에 대한 설정을 하는 Class)</li>
</ul>
</li>
</ul>
<h2 id="Servlet-Context-xml"><a href="#Servlet-Context-xml" class="headerlink" title="Servlet-Context.xml"></a>Servlet-Context.xml</h2><p>기존 Bean 생성을 xml로 등록하는 방식이다.<br>이 방식을 Bean등록을 한군데에서 모아 볼 수 있다는 장점이 있지만…<br>보통의 Enterprise급 프로젝트에서는 설정하는 Bean이 너무 많아 오히려 복잡하다.<br>위에서 언급한 <code>Component-scan</code>을 주로 사용하는 것이 좋다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;beanNameViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>xml파일에서 Bean등록을 하던 역할을 Java Config로 할 수 있도록 해준다.<br>뿐만아니라 @Configuration 어노테이션을 붙인 클래스는 Spring Container에 대한 설정까지 추가 할 수 있다.<br>Bean을 추가하고자 하는 경우에는 추가하고자 하는 Bean을 return 하는 메서드를 만들어 <code>@Bean</code> 어노테이션을 붙여주면 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123; <span class="comment">//메소드 명이 기본적으로 Bean Name으로 추가된다.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java Config를 이용할 수 있다는 장점과 Test Case 작성 시 Mock객체를 Bean으로 생성해야 하는 경우<br>아주 유용한 방법이라 할 수 있겠다.</p>
<h1 id="Bean-생명주기"><a href="#Bean-생명주기" class="headerlink" title="Bean 생명주기"></a>Bean 생명주기</h1><p>Spring Container에서는 Bean의 생성~소멸까지 Bean을 관리한다.<br>Bean의 생성 시점과 소멸 시점에 대한 처리를 할 수 있는 기능을 제공하고 있다.</p>
<p>Bean 생명주기 처리를 하는 방법은 3가지 방식이 있다.</p>
<ol>
<li>InitializingBean, DisposableBean 인터페이스 구현</li>
<li>Bean정의 시 , 메소드 지정</li>
<li>@PostConstruct, @PreDestroy Annotation 사용</li>
</ol>
<h2 id="InitializingBean-DisposableBean-인터페이스-구현"><a href="#InitializingBean-DisposableBean-인터페이스-구현" class="headerlink" title="InitializingBean, DisposableBean 인터페이스 구현"></a>InitializingBean, DisposableBean 인터페이스 구현</h2><p>InitializingBean, DisposableBean 인터페이스를 구현 하여, Bean의 생성과 소멸 시<br>기능을 확장 할 수 있다.</p>
<p>InitializingBean, DisposableBean 클래스는 Spring에서 제공하는 인터페이스 이기 때문에<br>Spring에 종속적이게 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanClass</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> Connection conn;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//자원의 할당 처리</span></span><br><span class="line">        conn = DBConnectionCaller.getConnection();</span><br><span class="line">        System.out.println(<span class="string">&quot;bean 생성 및 초기화 : afterPropertiesSet() 호출됨&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//주로 할당된 자원의 해제를 한다.</span></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>) conn.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;bean 소멸 : destroy 호출됨&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Bean정의-시-메소드-지정"><a href="#Bean정의-시-메소드-지정" class="headerlink" title="Bean정의 시 , 메소드 지정"></a>Bean정의 시 , 메소드 지정</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.TestBeanClass&quot;</span>                      </span></span><br><span class="line"><span class="tag">   <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>xml설정 파일 <bean>에서 <strong>init-method</strong> 지정 시 Bean생성과 properties의존성 주입 후 지정한 메소드 호출</li>
<li>xml설정 파일 <bean>에서 <strong>destroy-method</strong> 지정 시 Bean소멸 전 콜백으로 지정한 메소드 호출</li>
</ul>
<h2 id="PostConstruct-PreDestroy-Annotation-사용"><a href="#PostConstruct-PreDestroy-Annotation-사용" class="headerlink" title="@PostConstruct, @PreDestroy Annotation 사용"></a>@PostConstruct, @PreDestroy Annotation 사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanClass</span> &#123;be</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> Connection conn;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//자원의 할당 처리</span></span><br><span class="line">        conn = DBConnectionCaller.getConnection();</span><br><span class="line">        System.out.println(<span class="string">&quot;bean 생성 및 초기화&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//주로 할당된 자원의 해제를 한다.</span></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>) conn.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;bean 소멸&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@PostConstuct, @PreDestroy 은 <code>JSR-250 Annotation</code> 기반이다 (한마디로 자바기반)<br>따라서 Spring프레임워크에 종속적이지 않다는 장점이 있다. 따라서 Spring 기반에서 다른 Java기반의 프레임워크로 이식 할 경우 별도로 수정할 필요가 없다.</p>
<p>@PostConstuct, @PreDestroy 을 사용하기 위해서는<br><code>&lt;annotation-config/&gt; </code>설정이나, <code>@AnnotationDrivenConfig </code>어노테이션을 붙여줘야 한다.</p>
<h1 id="Bean-Scope"><a href="#Bean-Scope" class="headerlink" title="Bean Scope"></a>Bean Scope</h1><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html">https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html</a> 을 참고함</p>
<ul>
<li>Singleton Scope : IoC Container 단위 별로 Bean이 생성 된다.</li>
<li>Prototype Scope : Bean이 사용되는 시점 별로 다른 Bean이 생성된다.</li>
<li>Request Scope : Web프로젝트에서 http 요청 별로 Bean이 생성된다. http의 Lifecycle동안 같은 Bean을 사용</li>
<li>Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Session별로 Bean이 생성된다.<br>(이 경우에는 Bean에 Session정보를 세팅하여 사용할 수 있다.)</li>
<li>Global Session Scope : Request Scope와 마찬가지로 Web 프로젝트에서 사용하며, Global Http Session별로 다른 Bean을 생성한다. 일반적으로 Portlet Context에서 사용된다.</li>
</ul>
<h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p><a target="_blank" rel="noopener" href="http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F">http://www.javajigi.net/pages/viewpage.action?pageId=3664&amp;focusedCommentId=3751#Spring%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%86%8C%EA%B0%9C%EC%99%80IoC%EB%B0%8FSpringIoC%EC%9D%98%EA%B0%9C%EB%85%90-2.1IoC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F</a><br><a target="_blank" rel="noopener" href="http://wiki.javajigi.net/pages/viewpage.action?pageId=281">http://wiki.javajigi.net/pages/viewpage.action?pageId=281</a><br><a target="_blank" rel="noopener" href="https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/">https://jongmin92.github.io/2018/02/11/Spring/spring-ioc-di/</a><br><a target="_blank" rel="noopener" href="https://okky.kr/article/415474">https://okky.kr/article/415474</a><br><a target="_blank" rel="noopener" href="http://www.javajigi.net/pages/viewpage.action?pageId=68">http://www.javajigi.net/pages/viewpage.action?pageId=68</a><br><a target="_blank" rel="noopener" href="http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1">http://www.javajigi.net/download/attachments/5614/V3_InversionOfControl.pdf?version=1</a><br><a target="_blank" rel="noopener" href="http://isstory83.tistory.com/91">http://isstory83.tistory.com/91</a><br><a target="_blank" rel="noopener" href="https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3">https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3</a><br>토비의 스프링 VOL.2 Spring IoC</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Carrey</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://jaehun2841.github.io/2018/09/22/2018-09-21-spring-ioc-2/">https://jaehun2841.github.io/2018/09/22/2018-09-21-spring-ioc-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="../../../../tags/Spring/">Spring</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="../../../10/21/2018-10-21-spring-context/"><i class="fa fa-chevron-left">  </i><span>Application-Context와 Servlet-Context</span></a></div><div class="next-post pull-right"><a href="../../21/2018-09-12-spring-ioc/"><span>Spring IoC &amp; DI(1) - IoC 등장배경(과정)</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://jaehun2841.github.io/2018/09/22/2018-09-21-spring-ioc-2/';
  this.page.identifier = '2018/09/22/2018-09-21-spring-ioc-2/';
  this.page.title = 'Spring IoC & DI(2)';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'Carrey' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Carrey</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="../../../../js/utils.js?version=1.9.0"></script><script src="../../../../js/fancybox.js?version=1.9.0"></script><script src="../../../../js/sidebar.js?version=1.9.0"></script><script src="../../../../js/copy.js?version=1.9.0"></script><script src="../../../../js/fireworks.js?version=1.9.0"></script><script src="../../../../js/transition.js?version=1.9.0"></script><script src="../../../../js/scroll.js?version=1.9.0"></script><script src="../../../../js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>